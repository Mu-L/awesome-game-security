Project Path: arc_gmh5225_LibreMaple-Client_y7er4akw

Source Tree:

```txt
arc_gmh5225_LibreMaple-Client_y7er4akw
├── Audio
│   ├── Audio.cpp
│   └── Audio.h
├── CMakeLists.txt
├── Character
│   ├── ActiveBuffs.cpp
│   ├── ActiveBuffs.h
│   ├── Buff.cpp
│   ├── Buff.h
│   ├── Char.cpp
│   ├── Char.h
│   ├── CharEffect.h
│   ├── CharStats.cpp
│   ├── CharStats.h
│   ├── EquipStat.cpp
│   ├── EquipStat.h
│   ├── ExpTable.cpp
│   ├── ExpTable.h
│   ├── Inventory
│   │   ├── Equip.cpp
│   │   ├── Equip.h
│   │   ├── EquipQuality.cpp
│   │   ├── EquipQuality.h
│   │   ├── Inventory.cpp
│   │   ├── Inventory.h
│   │   ├── InventoryType.cpp
│   │   ├── InventoryType.h
│   │   ├── Item.cpp
│   │   ├── Item.h
│   │   ├── Pet.cpp
│   │   ├── Pet.h
│   │   ├── Weapon.cpp
│   │   └── Weapon.h
│   ├── Job.cpp
│   ├── Job.h
│   ├── Look
│   │   ├── Afterimage.cpp
│   │   ├── Afterimage.h
│   │   ├── Body.cpp
│   │   ├── Body.h
│   │   ├── BodyDrawInfo.cpp
│   │   ├── BodyDrawInfo.h
│   │   ├── CharEquips.cpp
│   │   ├── CharEquips.h
│   │   ├── CharLook.cpp
│   │   ├── CharLook.h
│   │   ├── Clothing.cpp
│   │   ├── Clothing.h
│   │   ├── EquipSlot.cpp
│   │   ├── EquipSlot.h
│   │   ├── Face.cpp
│   │   ├── Face.h
│   │   ├── Hair.cpp
│   │   ├── Hair.h
│   │   ├── PetLook.cpp
│   │   ├── PetLook.h
│   │   ├── Stance.cpp
│   │   └── Stance.h
│   ├── MapleStat.cpp
│   ├── MapleStat.h
│   ├── MonsterBook.cpp
│   ├── MonsterBook.h
│   ├── OtherChar.cpp
│   ├── OtherChar.h
│   ├── PassiveBuffs.cpp
│   ├── PassiveBuffs.h
│   ├── Player.cpp
│   ├── Player.h
│   ├── PlayerStates.cpp
│   ├── PlayerStates.h
│   ├── QuestLog.cpp
│   ├── QuestLog.h
│   ├── SkillBook.cpp
│   ├── SkillBook.h
│   ├── SkillId.h
│   ├── StatCaps.h
│   ├── TeleRock.cpp
│   └── TeleRock.h
├── Configuration.cpp
├── Configuration.h
├── Console.h
├── Constants.h
├── Data
│   ├── BulletData.cpp
│   ├── BulletData.h
│   ├── EquipData.cpp
│   ├── EquipData.h
│   ├── ItemData.cpp
│   ├── ItemData.h
│   ├── JobData.cpp
│   ├── JobData.h
│   ├── SkillData.cpp
│   ├── SkillData.h
│   ├── WeaponData.cpp
│   └── WeaponData.h
├── Error.h
├── Gameplay
│   ├── Camera.cpp
│   ├── Camera.h
│   ├── Combat
│   │   ├── Attack.h
│   │   ├── Bullet.cpp
│   │   ├── Bullet.h
│   │   ├── Combat.cpp
│   │   ├── Combat.h
│   │   ├── DamageNumber.cpp
│   │   ├── DamageNumber.h
│   │   ├── RegularAttack.cpp
│   │   ├── RegularAttack.h
│   │   ├── Skill.cpp
│   │   ├── Skill.h
│   │   ├── SkillAction.cpp
│   │   ├── SkillAction.h
│   │   ├── SkillBullet.cpp
│   │   ├── SkillBullet.h
│   │   ├── SkillHitEffect.cpp
│   │   ├── SkillHitEffect.h
│   │   ├── SkillSound.cpp
│   │   ├── SkillSound.h
│   │   ├── SkillUseEffect.cpp
│   │   ├── SkillUseEffect.h
│   │   └── SpecialMove.h
│   ├── MapleMap
│   │   ├── Drop.cpp
│   │   ├── Drop.h
│   │   ├── ItemDrop.cpp
│   │   ├── ItemDrop.h
│   │   ├── Layer.h
│   │   ├── MapBackgrounds.cpp
│   │   ├── MapBackgrounds.h
│   │   ├── MapChars.cpp
│   │   ├── MapChars.h
│   │   ├── MapDrops.cpp
│   │   ├── MapDrops.h
│   │   ├── MapInfo.cpp
│   │   ├── MapInfo.h
│   │   ├── MapMobs.cpp
│   │   ├── MapMobs.h
│   │   ├── MapNpcs.cpp
│   │   ├── MapNpcs.h
│   │   ├── MapObject.cpp
│   │   ├── MapObject.h
│   │   ├── MapObjects.cpp
│   │   ├── MapObjects.h
│   │   ├── MapPortals.cpp
│   │   ├── MapPortals.h
│   │   ├── MapReactors.cpp
│   │   ├── MapReactors.h
│   │   ├── MapTilesObjs.cpp
│   │   ├── MapTilesObjs.h
│   │   ├── MesoDrop.cpp
│   │   ├── MesoDrop.h
│   │   ├── Mob.cpp
│   │   ├── Mob.h
│   │   ├── Npc.cpp
│   │   ├── Npc.h
│   │   ├── Obj.cpp
│   │   ├── Obj.h
│   │   ├── Portal.cpp
│   │   ├── Portal.h
│   │   ├── Reactor.cpp
│   │   ├── Reactor.h
│   │   ├── Tile.cpp
│   │   └── Tile.h
│   ├── Movement.h
│   ├── Physics
│   │   ├── Foothold.cpp
│   │   ├── Foothold.h
│   │   ├── FootholdTree.cpp
│   │   ├── FootholdTree.h
│   │   ├── Physics.cpp
│   │   ├── Physics.h
│   │   └── PhysicsObject.h
│   ├── Playable.h
│   ├── Spawn.cpp
│   ├── Spawn.h
│   ├── Stage.cpp
│   └── Stage.h
├── Graphics
│   ├── Animation.cpp
│   ├── Animation.h
│   ├── Color.cpp
│   ├── Color.h
│   ├── DrawArgument.h
│   ├── EffectLayer.cpp
│   ├── EffectLayer.h
│   ├── Geometry.cpp
│   ├── Geometry.h
│   ├── GraphicsGL.cpp
│   ├── GraphicsGL.h
│   ├── Sprite.cpp
│   ├── Sprite.h
│   ├── Text.cpp
│   ├── Text.h
│   ├── Texture.cpp
│   └── Texture.h
├── IO
│   ├── Components
│   │   ├── AreaButton.cpp
│   │   ├── AreaButton.h
│   │   ├── Button.cpp
│   │   ├── Button.h
│   │   ├── Charset.cpp
│   │   ├── Charset.h
│   │   ├── ChatBalloon.cpp
│   │   ├── ChatBalloon.h
│   │   ├── EquipTooltip.cpp
│   │   ├── EquipTooltip.h
│   │   ├── Gauge.cpp
│   │   ├── Gauge.h
│   │   ├── Icon.cpp
│   │   ├── Icon.h
│   │   ├── IconCover.cpp
│   │   ├── IconCover.h
│   │   ├── ItemTooltip.cpp
│   │   ├── ItemTooltip.h
│   │   ├── MapleButton.cpp
│   │   ├── MapleButton.h
│   │   ├── MapleFrame.cpp
│   │   ├── MapleFrame.h
│   │   ├── Nametag.cpp
│   │   ├── Nametag.h
│   │   ├── NpcText.cpp
│   │   ├── ScrollingNotice.cpp
│   │   ├── ScrollingNotice.h
│   │   ├── SkillTooltip.cpp
│   │   ├── SkillTooltip.h
│   │   ├── Slider.cpp
│   │   ├── Slider.h
│   │   ├── SliderHoriz.cpp
│   │   ├── SliderHoriz.h
│   │   ├── Textfield.cpp
│   │   ├── Textfield.h
│   │   ├── Tooltip.h
│   │   ├── TwoSpriteButton.cpp
│   │   └── TwoSpriteButton.h
│   ├── Cursor.cpp
│   ├── Cursor.h
│   ├── KeyAction.h
│   ├── KeyType.h
│   ├── Keyboard.cpp
│   ├── Keyboard.h
│   ├── Messages.cpp
│   ├── Messages.h
│   ├── UI.cpp
│   ├── UI.h
│   ├── UIDragElement.h
│   ├── UIElement.cpp
│   ├── UIElement.h
│   ├── UIState.h
│   ├── UIStateGame.cpp
│   ├── UIStateGame.h
│   ├── UIStateLogin.cpp
│   ├── UIStateLogin.h
│   ├── UITypes
│   │   ├── UIBuffList.cpp
│   │   ├── UIBuffList.h
│   │   ├── UIChangeChannel.cpp
│   │   ├── UIChangeChannel.h
│   │   ├── UICharCreation.cpp
│   │   ├── UICharCreation.h
│   │   ├── UICharSelect.cpp
│   │   ├── UICharSelect.h
│   │   ├── UIChatBar.cpp
│   │   ├── UIChatBar.h
│   │   ├── UIEquipInventory.cpp
│   │   ├── UIEquipInventory.h
│   │   ├── UIGameSettings.cpp
│   │   ├── UIGameSettings.h
│   │   ├── UIItemInventory.cpp
│   │   ├── UIItemInventory.h
│   │   ├── UIKeyConfig.cpp
│   │   ├── UIKeyConfig.h
│   │   ├── UILogin.cpp
│   │   ├── UILogin.h
│   │   ├── UILoginNotice.cpp
│   │   ├── UILoginNotice.h
│   │   ├── UILoginWait.cpp
│   │   ├── UILoginWait.h
│   │   ├── UINotice.cpp
│   │   ├── UINotice.h
│   │   ├── UINpcTalk.cpp
│   │   ├── UINpcTalk.h
│   │   ├── UIShop.cpp
│   │   ├── UIShop.h
│   │   ├── UISkillBook.cpp
│   │   ├── UISkillBook.h
│   │   ├── UISoftKey.cpp
│   │   ├── UISoftKey.h
│   │   ├── UIStatsInfo.cpp
│   │   ├── UIStatsInfo.h
│   │   ├── UIStatusBar.cpp
│   │   ├── UIStatusBar.h
│   │   ├── UIStatusMessenger.cpp
│   │   ├── UIStatusMessenger.h
│   │   ├── UISystemMenu.cpp
│   │   ├── UISystemMenu.h
│   │   ├── UISystemSettings.cpp
│   │   ├── UISystemSettings.h
│   │   ├── UIWorldSelect.cpp
│   │   └── UIWorldSelect.h
│   ├── Window.cpp
│   └── Window.h
├── Journey.cpp
├── Journey.h
├── LICENSE
├── Net
│   ├── Cryptography.cpp
│   ├── Cryptography.h
│   ├── Handlers
│   │   ├── AttackHandlers.cpp
│   │   ├── AttackHandlers.h
│   │   ├── CommonHandlers.cpp
│   │   ├── CommonHandlers.h
│   │   ├── CustomHandlers.cpp
│   │   ├── CustomHandlers.h
│   │   ├── Helpers
│   │   │   ├── ItemParser.cpp
│   │   │   ├── ItemParser.h
│   │   │   ├── LoginParser.cpp
│   │   │   ├── LoginParser.h
│   │   │   ├── MovementParser.cpp
│   │   │   └── MovementParser.h
│   │   ├── InventoryHandlers.cpp
│   │   ├── InventoryHandlers.h
│   │   ├── LoginHandlers.cpp
│   │   ├── LoginHandlers.h
│   │   ├── MapObjectHandlers.cpp
│   │   ├── MapObjectHandlers.h
│   │   ├── MessagingHandlers.cpp
│   │   ├── MessagingHandlers.h
│   │   ├── NpcInteractionHandlers.cpp
│   │   ├── NpcInteractionHandlers.h
│   │   ├── PlayerHandlers.cpp
│   │   ├── PlayerHandlers.h
│   │   ├── SetfieldHandlers.cpp
│   │   └── SetfieldHandlers.h
│   ├── InPacket.cpp
│   ├── InPacket.h
│   ├── Login.h
│   ├── NetConstants.h
│   ├── OutPacket.cpp
│   ├── OutPacket.h
│   ├── PacketError.h
│   ├── PacketHandler.h
│   ├── PacketSwitch.cpp
│   ├── PacketSwitch.h
│   ├── Packets
│   │   ├── AttackAndSkillPackets.h
│   │   ├── CharCreationPackets.h
│   │   ├── CommonPackets.h
│   │   ├── CustomPackets.h
│   │   ├── GameplayPackets.h
│   │   ├── InventoryPackets.h
│   │   ├── LoginPackets.h
│   │   ├── MessagingPackets.h
│   │   ├── MovementPacket.h
│   │   ├── NpcInteractionPackets.h
│   │   ├── PlayerPackets.h
│   │   └── SelectCharPackets.h
│   ├── Session.cpp
│   ├── Session.h
│   ├── SocketAsio.cpp
│   ├── SocketAsio.h
│   ├── SocketWinsock.cpp
│   └── SocketWinsock.h
├── README.md
├── Template
│   ├── BoolPair.h
│   ├── Cache.h
│   ├── EnumMap.h
│   ├── Enumeration.h
│   ├── Interpolated.h
│   ├── Point.h
│   ├── Range.h
│   ├── Rectangle.h
│   ├── Singleton.h
│   ├── TimedQueue.h
│   ├── TypeMap.h
│   └── nullable_ptr.h
├── Timer.h
├── Util
│   ├── HashUtility.cpp
│   ├── HashUtility.h
│   ├── Lerp.h
│   ├── Misc.cpp
│   ├── Misc.h
│   ├── NxFiles.cpp
│   ├── NxFiles.h
│   ├── QuadTree.h
│   ├── Randomizer.h
│   ├── Str.h
│   └── TimedBool.h
├── clang-format.py
├── code-guidelines.md
├── fonts
│   └── Roboto
│       ├── LICENSE.txt
│       ├── Roboto-Black.ttf
│       ├── Roboto-BlackItalic.ttf
│       ├── Roboto-Bold.ttf
│       ├── Roboto-BoldItalic.ttf
│       ├── Roboto-Italic.ttf
│       ├── Roboto-Light.ttf
│       ├── Roboto-LightItalic.ttf
│       ├── Roboto-Medium.ttf
│       ├── Roboto-MediumItalic.ttf
│       ├── Roboto-Regular.ttf
│       ├── Roboto-Thin.ttf
│       └── Roboto-ThinItalic.ttf
├── gen_header_filter.py
├── libremaple.doxygen.in
├── logo.png
├── settings.toml
└── tidy.sh

```

`Audio/Audio.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Audio.h"

#include "../Configuration.h"

#define WIN32_LEAN_AND_MEAN
#include "nlnx/audio.hpp"
#include "nlnx/nx.hpp"

#include <cstddef>

namespace jrc
{
constexpr const char* Error::messages[];

Sound::Sound() noexcept : id{0}
{
}

Sound::Sound(Name name) noexcept : id{sound_ids[name]}
{
}

Sound::Sound(nl::node src) noexcept : id{add_sound(src)}
{
}

void Sound::play() const noexcept
{
    if (!initialized) {
        return;
    }

    if (auto sample_iter = samples.find(id); sample_iter != samples.end()) {
        Mix_PlayChannel(-1, sample_iter->second, 0);
    }
}

Error Sound::init()
{
    // Initialize SDL.
    if (SDL_Init(SDL_INIT_AUDIO) < 0) {
        return Error::AUDIO;
    }

    // Open 44.1kHz, signed 16-bit, system byteorder, stereo audio, using
    // 1024-byte chunks.
    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 1024) == -1) {
        return Error::AUDIO;
    }

    // Dynamically load library for decoding ogg/vorbis audio.
    Mix_Init(MIX_INIT_OGG);

    // Allocate 16 channels for playing sound effects.
    Mix_AllocateChannels(16);

    nl::node ui_src = nl::nx::sound["UI.img"];

    add_sound(Sound::BUTTON_CLICK, ui_src["BtMouseClick"]);
    add_sound(Sound::BUTTON_OVER, ui_src["BtMouseOver"]);
    add_sound(Sound::SELECT_CHAR, ui_src["CharSelect"]);

    nl::node game_src = nl::nx::sound["Game.img"];

    add_sound(Sound::GAME_START, game_src["GameIn"]);
    add_sound(Sound::JUMP, game_src["Jump"]);
    add_sound(Sound::DROP, game_src["DropItem"]);
    add_sound(Sound::PICK_UP, game_src["PickUpItem"]);
    add_sound(Sound::PORTAL, game_src["Portal"]);
    add_sound(Sound::LEVEL_UP, game_src["LevelUp"]);

    set_sfx_volume(Configuration::get().audio.volume.sound_effects);

    return Error::NONE;
}

void Sound::init_sfx() noexcept
{
    initialized = true;
}

Mix_Music* Music::stream;

void Sound::close() noexcept
{
    if (!initialized) {
        return;
    }

    if (Music::stream) {
        Mix_HaltMusic();
        Mix_FreeMusic(Music::stream);
    }

    for (auto [_, sample] : samples) {
        Mix_FreeChunk(sample);
    }
    samples.clear();

    Mix_CloseAudio();
    Mix_Quit();
    SDL_Quit();

    initialized = false;
}

void Sound::set_sfx_volume(std::uint8_t vol) noexcept
{
    if (!initialized) {
        return;
    }

    Mix_Volume(-1, MIX_MAX_VOLUME * static_cast<int>(vol) / 100);
}

std::size_t Sound::add_sound(nl::node src) noexcept
{
    if (!initialized) {
        return 0;
    }

    nl::audio ad = src;

    auto data = static_cast<const std::byte*>(ad.data());

    if (data) {
        std::size_t id = ad.id();

        samples[id] = Mix_LoadWAV_RW(
            SDL_RWFromConstMem(data + 82, ad.length() - 82), 0);

        return id;
    } else {
        return 0;
    }
}

void Sound::add_sound(Name name, nl::node src) noexcept
{
    if (!initialized) {
        return;
    }

    std::size_t id = add_sound(src);

    if (id) {
        sound_ids[name] = id;
    }
}

bool Sound::is_initialized() noexcept
{
    return initialized;
}

std::unordered_map<std::size_t, Mix_Chunk*> Sound::samples;
EnumMap<Sound::Name, std::size_t> Sound::sound_ids;
bool Sound::initialized = false;

Error Music::play(const std::string& bgm_path)
{
    if (!initialized) {
        return Error::NONE;
    }

    static std::string path;

    if (path == bgm_path) {
        return Error::NONE;
    }

    nl::audio ad = nl::nx::sound.resolve(bgm_path);
    auto data = static_cast<const std::byte*>(ad.data());

    if (data) {
        if (stream) {
            Mix_HaltMusic();
            Mix_FreeMusic(stream);
        }

        stream = Mix_LoadMUSType_RW(
            SDL_RWFromConstMem(data + 82, ad.length() - 82), MUS_OGG, 0);
        if (Mix_PlayMusic(stream, -1) == -1) {
            return Error::AUDIO;
        }

        path = bgm_path;
    }

    return Error::NONE;
}

void Music::init() noexcept
{
    stream = nullptr;
    initialized = true;
    set_bgm_volume(Configuration::get().audio.volume.music);
}

void Music::set_bgm_volume(std::uint8_t vol) noexcept
{
    if (!initialized) {
        return;
    }

    Mix_VolumeMusic(MIX_MAX_VOLUME * static_cast<int>(vol) / 100);
}

bool Music::is_initialized() noexcept
{
    return initialized;
}

bool Music::initialized = false;
} // namespace jrc

```

`Audio/Audio.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Error.h"
#include "../Template/EnumMap.h"
#include "nlnx/node.hpp"

#include <SDL.h>
#include <SDL_mixer.h>
#include <cstdint>
#include <string>
#include <unordered_map>

namespace jrc
{
class Sound
{
public:
    //! Preloaded sounds.
    enum Name {
        // UI
        BUTTON_CLICK,
        BUTTON_OVER,

        // Login
        SELECT_CHAR,
        GAME_START,

        // Game
        JUMP,
        DROP,
        PICK_UP,
        PORTAL,
        LEVEL_UP,

        LENGTH
    };

    Sound() noexcept;
    Sound(Name name) noexcept;
    Sound(nl::node src) noexcept;

    void play() const noexcept;

    [[nodiscard]] static Error init();
    static void init_sfx() noexcept;
    static void close() noexcept;
    static void set_sfx_volume(std::uint8_t volume) noexcept;

    [[nodiscard]] static bool is_initialized() noexcept;

private:
    std::size_t id;

    static std::size_t add_sound(nl::node src) noexcept;
    static void add_sound(Sound::Name name, nl::node src) noexcept;

    static std::unordered_map<std::size_t, Mix_Chunk*> samples;
    static EnumMap<Name, std::size_t> sound_ids;
    static bool initialized;
};

class Music
{
public:
    [[nodiscard]] static Error play(const std::string& bgm_path);

    static void init() noexcept;
    static void set_bgm_volume(std::uint8_t volume) noexcept;

    [[nodiscard]] static bool is_initialized() noexcept;

private:
    static Mix_Music* stream;
    static bool initialized;

    friend Sound;
};
} // namespace jrc

```

`CMakeLists.txt`:

```txt
## CMake file for the JourneyClient from-scratch Maplestory client ##
cmake_minimum_required(VERSION 3.10)
project(JourneyClient)

# Emit compile commands/JSON "database", can be used for e.g. clangd.
SET(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Set default build type as "Debug" if not specified
if(NOT CMAKE_BUILD_TYPE)
    message(WARNING "No build type specified, using Debug build by default.")
    SET(CMAKE_BUILD_TYPE Debug)
endif()

# Force the use of lld for linking on non-macOS platforms
if(UNIX AND NOT APPLE)
    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=lld")
    SET(CMAKE_AR "llvm-ar")
    SET(CMAKE_RANLIB "llvm-ranlib")
elseif(WIN32)
    SET(CMAKE_AR "C:/Program Files/LLVM/bin/llvm-ar.exe")
    SET(CMAKE_RANLIB "C:/Program Files/LLVM/bin/llvm-ranlib.exe")
endif()

# Set compiler flags
if(UNIX AND NOT APPLE)
    SET(REQUIRED_FLAGS "-std=c++17 -fcolor-diagnostics -pipe -DASIO_STANDALONE -DGLEW_NO_GLU -DBOOST_BIMAP_DISABLE_SERIALIZATION -lglut -lGL -lSDL2 -lSDL2_mixer -ldl -lXinerama -lXext -lXrandr -lXi -lXcursor -lX11 -lXxf86vm -pthread -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wstrict-prototypes -Werror-implicit-function-declaration -Wformat=2 -Wnull-dereference -Wstrict-overflow=5 -Wno-unused-command-line-argument -Wno-unused-private-field -Wno-narrowing")
elseif(APPLE)
    SET(REQUIRED_FLAGS "-std=c++17 -fcolor-diagnostics -nostdinc++ -I/usr/local/Cellar/llvm/6.0.0/include/c++/v1 -L/usr/local/Cellar/llvm/6.0.0/lib -Wl,-rpath,/usr/local/Cellar/llvm/6.0.0/lib -pipe -DASIO_STANDALONE -DGLEW_NO_GLU -DBOOST_BIMAP_DISABLE_SERIALIZATION -framework OpenGL -framework Cocoa -framework IOKit -framework CoreVideo -lglut -lSDL2 -lSDL2_mixer -ldl -pthread -Wall -Wextra -Wshadow -Wpointer-arith -Wcast-align -Wstrict-prototypes -Werror-implicit-function-declaration -Wformat=2 -Wnull-dereference -Wstrict-overflow=5 -Wno-unused-private-field -Wno-unused-command-line-argument -Wno-narrowing")
elseif(WIN32)
    SET(REQUIRED_FLAGS "/std:c++17 /GX /D ASIO_STANDALONE /D GLEW_NO_GLU /D BOOST_BIMAP_DISABLE_SERIALIZATION /W4 -Wshadow -Wpointer-arith -Wcast-align -Wstrict-prototypes -Werror-implicit-function-declaration -Wformat=2 -Wnull-dereference -Wstrict-overflow=5 -Wno-unused-private-field -Wno-unused-command-line-argument -Wno-narrowing")
else()
    message(FATAL_ERROR "Unrecognized platform")
endif()

if(NOT WIN32)
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        SET(CMAKE_CXX_FLAGS "-O0 -g -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=undefined ${REQUIRED_FLAGS}")
        SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=undefined")
    elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
        SET(CMAKE_CXX_FLAGS "-O3 -flto=full -ffast-math -DNDEBUG ${REQUIRED_FLAGS}")
    elseif(CMAKE_BUILD_TYPE STREQUAL "MinSizeRel")
        SET(CMAKE_CXX_FLAGS "-Oz -ffast-math -DNDEBUG ${REQUIRED_FLAGS}") # LTO doesn't work with "-Os" nor "-Oz" on clang :(
    elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
        SET(CMAKE_CXX_FLAGS "-O3 -g -ffast-math -fno-omit-frame-pointer -fno-optimize-sibling-calls ${REQUIRED_FLAGS}")
    else()
        SET(CMAKE_CXX_FLAGS "-O0 -g -fno-omit-frame-pointer -fno-optimize-sibling-calls -fsanitize=undefined ${REQUIRED_FLAGS}")
        SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fsanitize=undefined")
    endif()

    if(NATIVE_BUILD)
        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native")
    else()
        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=x86-64 -mtune=generic")
    endif()
else()
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        SET(CMAKE_CXX_FLAGS "/Od ${REQUIRED_FLAGS}")
    elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
        SET(CMAKE_CXX_FLAGS "/O2 /fp:fast /D NDEBUG ${REQUIRED_FLAGS}")
    elseif(CMAKE_BUILD_TYPE STREQUAL "MinSizeRel")
        SET(CMAKE_CXX_FLAGS "/O1 /fp:fast /D NDEBUG ${REQUIRED_FLAGS}")
    elseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
        SET(CMAKE_CXX_FLAGS "/O2 /fp:fast ${REQUIRED_FLAGS}")
    else()
        SET(CMAKE_CXX_FLAGS "/Od ${REQUIRED_FLAGS}")
    endif()

    if(NATIVE_BUILD)
        message(WARNING "Architecture detection is not supported for Windows builds through clang-cl. If you want, you can manually insert the \"/arch:AVX\" and/or \"/arch:AVX2\" flags.")
    endif()
endif()

SET(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Globbing together each src folder's top-level *.cpp files to each form
# their own libraries
FILE(GLOB Root_CPP       "./*.cpp")

FILE(GLOB Audio_CPP      "Audio/*.cpp")
FILE(GLOB Character_CPP  "Character/*.cpp")
FILE(GLOB Data_CPP       "Data/*.cpp")
FILE(GLOB Gameplay_CPP   "Gameplay/*.cpp")
FILE(GLOB Graphics_CPP   "Graphics/*.cpp")
FILE(GLOB IO_CPP         "IO/*.cpp")
FILE(GLOB Net_CPP        "Net/*.cpp")
FILE(GLOB Util_CPP       "Util/*.cpp")

# Headers as well
FILE(GLOB Root_H         "./*.h")

FILE(GLOB Audio_H        "Audio/*.h")
FILE(GLOB Character_H    "Character/*.h")
FILE(GLOB Data_H         "Data/*.h")
FILE(GLOB Gameplay_H     "Gameplay/*.h")
FILE(GLOB Graphics_H     "Graphics/*.h")
FILE(GLOB IO_H           "IO/*.h")
FILE(GLOB Net_H          "Net/*.h")
FILE(GLOB Util_H         "Util/*.h")
FILE(GLOB Template_H     "Template/*.h")

# Glob each subdirectory as well
FILE(GLOB Inventory_CPP  "Character/Inventory/*.cpp")
FILE(GLOB Look_CPP       "Character/Look/*.cpp")
FILE(GLOB Combat_CPP     "Gameplay/Combat/*.cpp")
FILE(GLOB MapleMap_CPP   "Gameplay/MapleMap/*.cpp")
FILE(GLOB Physics_CPP    "Gameplay/Physics/*.cpp")
FILE(GLOB Components_CPP "IO/Components/*.cpp")
FILE(GLOB UITypes_CPP    "IO/UITypes/*.cpp")
FILE(GLOB Handlers_CPP   "Net/Handlers/*.cpp")

FILE(GLOB Helpers_CPP    "Net/Handlers/Helpers/*.cpp")

# Those headers too
FILE(GLOB Inventory_H    "Character/Inventory/*.h")
FILE(GLOB Look_H         "Character/Look/*.h")
FILE(GLOB Combat_H       "Gameplay/Combat/*.h")
FILE(GLOB MapleMap_H     "Gameplay/MapleMap/*.h")
FILE(GLOB Physics_H      "Gameplay/Physics/*.h")
FILE(GLOB Components_H   "IO/Components/*.h")
FILE(GLOB UITypes_H      "IO/UITypes/*.h")
FILE(GLOB Handlers_H     "Net/Handlers/*.h")
FILE(GLOB Packets_H      "Net/Packets/*.h")

FILE(GLOB Helpers_H      "Net/Handlers/Helpers/*.h")

# Glob dependencies
FILE(GLOB nlnx_CPP       "../nlnx/*.cpp")

# Glob dependency headers
FILE(GLOB nlnx_H         "../nlnx/*.hpp")

# Add all source files to $SOURCE_FILES for easy access
SET(SOURCE_FILES ${Root_CPP}
                 ${Audio_CPP}
                 ${Character_CPP}
                 ${Data_CPP}
                 ${Gameplay_CPP}
                 ${Graphics_CPP}
                 ${IO_CPP}
                 ${Net_CPP}
                 ${Util_CPP}
                 ${Inventory_CPP}
                 ${Look_CPP}
                 ${Combat_CPP}
                 ${MapleMap_CPP}
                 ${Physics_CPP}
                 ${Components_CPP}
                 ${UITypes_CPP}
                 ${Handlers_CPP}
                 ${Helpers_CPP}
                 ${nlnx_CPP}
                 "Configuration.cpp"
                 ${Root_H}
                 ${Audio_H}
                 ${Character_H}
                 ${Data_H}
                 ${Gameplay_H}
                 ${Graphics_H}
                 ${IO_H}
                 ${Net_H}
                 ${Util_H}
                 ${Template_H}
                 ${Inventory_H}
                 ${Look_H}
                 ${Combat_H}
                 ${MapleMap_H}
                 ${Physics_H}
                 ${Components_H}
                 ${UITypes_H}
                 ${Handlers_H}
                 ${Packets_H}
                 ${Helpers_H}
                 ${nlnx_H}
                 "../boost/boost/bimap.hpp"
                 "../boost/boost/container/flat_map.hpp"
                 "../boost/boost/container/flat_set.hpp"
                 "../boost/boost/container/static_vector.hpp"
                 "../cpptoml/include/cpptoml.h"
                 "../pcg-cpp/include/pcg_random.hpp")

# Adding file globs created above as libraries
add_library(Audio         ${Audio_CPP})
add_library(Character     ${Character_CPP})
add_library(Data          ${Data_CPP})
add_library(Gameplay      ${Gameplay_CPP})
add_library(Graphics      ${Graphics_CPP})
add_library(IO            ${IO_CPP})
add_library(Net           ${Net_CPP})
add_library(Util          ${Util_CPP})

add_library(Inventory     ${Inventory_CPP})
add_library(Look          ${Look_CPP})
add_library(Combat        ${Combat_CPP})
add_library(MapleMap      ${MapleMap_CPP})
add_library(Physics       ${Physics_CPP})
add_library(Components    ${Components_CPP})
add_library(UITypes       ${UITypes_CPP})
add_library(Handlers      ${Handlers_CPP})

add_library(Helpers       ${Helpers_CPP})

# Just the one file
add_library(Configuration "Configuration.cpp")

add_library(nlnx          ${nlnx_CPP})

# Target executable
add_executable(JourneyClient ${SOURCE_FILES})

# Linking between libraries
target_link_libraries(Inventory     Data)
target_link_libraries(MapleMap      Gameplay)
target_link_libraries(MapleMap      Graphics)
target_link_libraries(Components    Character)
target_link_libraries(UITypes       Components)
target_link_libraries(Handlers      UITypes)
target_link_libraries(Combat        IO)
target_link_libraries(UITypes       IO)
target_link_libraries(Character     MapleMap)
target_link_libraries(Gameplay      MapleMap)

# Linking executable to libraries
target_link_libraries(JourneyClient MapleMap)

target_link_libraries(JourneyClient Audio)
target_link_libraries(JourneyClient Character)
target_link_libraries(JourneyClient Data)
target_link_libraries(JourneyClient Gameplay)
target_link_libraries(JourneyClient Graphics)
target_link_libraries(JourneyClient IO)
target_link_libraries(JourneyClient Net)
target_link_libraries(JourneyClient Util)

target_link_libraries(JourneyClient Inventory)
target_link_libraries(JourneyClient Look)
target_link_libraries(JourneyClient Combat)
target_link_libraries(JourneyClient Physics)
target_link_libraries(JourneyClient Components)
target_link_libraries(JourneyClient UITypes)
target_link_libraries(JourneyClient Handlers)

target_link_libraries(JourneyClient Helpers)

target_link_libraries(JourneyClient Configuration)

target_link_libraries(JourneyClient nlnx)

# Link in shared object files
if(UNIX AND NOT APPLE)
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../freetype/objs/.libs/libfreetype.so")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glew/lib/libGLEW.so")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glfw/build/src/libglfw3.a")
    target_link_libraries(nlnx          "${CMAKE_CURRENT_SOURCE_DIR}/../lz4/lib/liblz4.so")
elseif(APPLE)
    target_link_libraries(JourneyClient "/usr/local/Cellar/freetype/2.9.1/lib/libfreetype.dylib")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glew/lib/libGLEW.dylib")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glfw/build/src/libglfw3.a")
    target_link_libraries(nlnx          "${CMAKE_CURRENT_SOURCE_DIR}/../lz4/lib/liblz4.dylib")
elseif(WIN32)
    INCLUDE(${CMAKE_ROOT}/Modules/FindOpenGL.cmake)
    SET(CMAKE_REQUIRED_LIBRARIES ${GLUT_LIBRARY} ${GL_LIBRARY})
    target_link_libraries(JourneyClient ${OPENGL_LIBRARIES})

    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../freetype/win64/freetype.lib")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glew/lib/Release/x64/glew32.lib")
    target_link_libraries(JourneyClient "${CMAKE_CURRENT_SOURCE_DIR}/../glfw/lib-vc2015/glfw3.lib")
    target_link_libraries(nlnx          "${CMAKE_CURRENT_SOURCE_DIR}/../lz4/dll/liblz4.lib")
else()
    message(FATAL_ERROR "Unrecognized platform")
endif()

# Include directories for project dependencies
include_directories(".")
include_directories("..")
if(NOT APPLE)
    include_directories("../freetype/include")
else()
    include_directories("/usr/local/Cellar/freetype/2.9.1/include/freetype2")
endif()
include_directories("../glew/include")
include_directories("../glfw/include")
include_directories("../asio/include")
if(NOT WIN32)
    include_directories("../lz4/lib")
else()
    include_directories("../lz4/include")
endif()
include_directories("../boost")
include_directories("/usr/include")
include_directories("/usr/include/SDL2")
include_directories("../cpptoml/include")
include_directories("../pcg-cpp/include")

```

`Character/ActiveBuffs.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ActiveBuffs.h"

namespace jrc
{
template<Equipstat::Id STAT>
void SimpleStatBuff<STAT>::apply_to(CharStats& stats, std::int16_t value) const
{
    stats.add_buff(STAT, value);
}

template<Equipstat::Id STAT>
void PercentageStatBuff<STAT>::apply_to(CharStats& stats,
                                        std::int16_t value) const
{
    stats.add_percent(STAT, static_cast<float>(value) / 100);
}

void MapleWarriorBuff::apply_to(CharStats& stats, std::int16_t value) const
{
    stats.add_percent(Equipstat::STR, static_cast<float>(value) / 100.0f);
    stats.add_percent(Equipstat::DEX, static_cast<float>(value) / 100.0f);
    stats.add_percent(Equipstat::INT, static_cast<float>(value) / 100.0f);
    stats.add_percent(Equipstat::LUK, static_cast<float>(value) / 100.0f);
}

void StanceBuff::apply_to(CharStats& stats, std::int16_t value) const
{
    stats.set_stance(static_cast<float>(value) / 100.0f);
}

void BoosterBuff::apply_to(CharStats& stats, std::int16_t value) const
{
    stats.set_attack_speed(static_cast<std::int8_t>(value));
}

ActiveBuffs::ActiveBuffs()
{
    buffs[Buffstat::MAPLE_WARRIOR] = std::make_unique<MapleWarriorBuff>();
    buffs[Buffstat::STANCE] = std::make_unique<StanceBuff>();
    buffs[Buffstat::BOOSTER] = std::make_unique<BoosterBuff>();
    buffs[Buffstat::WATK]
        = std::make_unique<SimpleStatBuff<Equipstat::WATK>>();
    buffs[Buffstat::WDEF]
        = std::make_unique<SimpleStatBuff<Equipstat::WDEF>>();
    buffs[Buffstat::MATK]
        = std::make_unique<SimpleStatBuff<Equipstat::MAGIC>>();
    buffs[Buffstat::MDEF]
        = std::make_unique<SimpleStatBuff<Equipstat::MDEF>>();
    buffs[Buffstat::SPEED]
        = std::make_unique<SimpleStatBuff<Equipstat::SPEED>>();
    buffs[Buffstat::JUMP]
        = std::make_unique<SimpleStatBuff<Equipstat::JUMP>>();
    buffs[Buffstat::HYPERBODYHP]
        = std::make_unique<PercentageStatBuff<Equipstat::HP>>();
    buffs[Buffstat::HYPERBODYMP]
        = std::make_unique<PercentageStatBuff<Equipstat::MP>>();
}

void ActiveBuffs::apply_buff(CharStats& stats,
                             Buffstat::Id stat,
                             std::int16_t value) const
{
    if (auto& buff = buffs[stat]) {
        buff->apply_to(stats, value);
    }
}
} // namespace jrc

```

`Character/ActiveBuffs.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Buff.h"
#include "CharStats.h"

#include <memory>

namespace jrc
{
//! Interface for active buffs which are applied to character stats.
class ActiveBuff
{
public:
    virtual ~ActiveBuff() = default;

    virtual void apply_to(CharStats& stats, std::int16_t value) const = 0;
};

template<Equipstat::Id STAT>
//! Template for buffs which just add their value to a stat.
class SimpleStatBuff : public ActiveBuff
{
    void apply_to(CharStats& stats, std::int16_t value) const override;
};

template<Equipstat::Id STAT>
//! Template for buffs which apply an increase by percentage.
class PercentageStatBuff : public ActiveBuff
{
    void apply_to(CharStats& stats, std::int16_t value) const override;
};

//! Buff for MAPLEWARRIOR
class MapleWarriorBuff : public ActiveBuff
{
    void apply_to(CharStats& stats, std::int16_t value) const override;
};

//! Buff for STANCE
class StanceBuff : public ActiveBuff
{
    void apply_to(CharStats& stats, std::int16_t value) const override;
};

//! Buff for BOOSTER
class BoosterBuff : public ActiveBuff
{
    void apply_to(CharStats& stats, std::int16_t value) const override;
};

class ActiveBuffs
{
public:
    //! Register all buffs effects.
    ActiveBuffs();

    //! Return the buff effect associated with the buff stat.
    void
    apply_buff(CharStats& stats, Buffstat::Id stat, std::int16_t value) const;

private:
    EnumMap<Buffstat::Id, std::unique_ptr<ActiveBuff>> buffs;
};
} // namespace jrc

```

`Character/Buff.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Buff.h"

namespace jrc
{
namespace Buffstat
{
const std::unordered_map<Id, std::uint64_t> first_codes
    = {{DASH2, 0x8000000000000L},
       {DASH, 0x10000000000000L},
       {ELEMENTAL_RESET, 0x200000000L},
       {ARAN_COMBO, 0x1000000000L},
       {COMBO_DRAIN, 0x2000000000L},
       {COMBO_BARRIER, 0x4000000000L},
       {BODY_PRESSURE, 0x8000000000L},
       {SMART_KNOCKBACK, 0x10000000000L},
       {PYRAMID_PQ, 0x20000000000L},
       {ENERGY_CHARGE, 0x4000000000000L},
       {MONSTER_RIDING, 0x20000000000000L},
       {HOMING_BEACON, 0x80000000000000L},
       {SPEED_INFUSION, 0x100000000000000L}};

const std::unordered_map<Id, std::uint64_t> second_codes
    = {{NONE, 0x0},
       {MORPH, 0x2},
       {RECOVERY, 0x4},
       {MAPLE_WARRIOR, 0x8},
       {STANCE, 0x10},
       {SHARP_EYES, 0x20},
       {MANA_REFLECTION, 0x40},
       {SHADOW_CLAW, 0x100},
       {INFINITY_, 0x200},
       {HOLY_SHIELD, 0x400},
       {HAMSTRING, 0x800},
       {BLIND, 0x1000},
       {CONCENTRATE, 0x2000},
       {ECHO_OF_HERO, 0x8000},
       {GHOST_MORPH, 0x20000},
       {AURA, 0x40000},
       {CONFUSE, 0x80000},
       {BERSERK_FURY, 0x8000000},
       {DIVINE_BODY, 0x10000000},
       {SPARK, 0x20000000L},
       {FINALATTACK, 0x80000000L},
       {BATTLESHIP, 0xA00000040L},
       {WATK, 0x100000000L},
       {WDEF, 0x200000000L},
       {MATK, 0x400000000L},
       {MDEF, 0x800000000L},
       {ACC, 0x1000000000L},
       {AVOID, 0x2000000000L},
       {HANDS, 0x4000000000L},
       {SHOWDASH, 0x4000000000L},
       {SPEED, 0x8000000000L},
       {JUMP, 0x10000000000L},
       {MAGIC_GUARD, 0x20000000000L},
       {DARKSIGHT, 0x40000000000L},
       {BOOSTER, 0x80000000000L},
       {POWERGUARD, 0x100000000000L},
       {HYPERBODYHP, 0x200000000000L},
       {HYPERBODYMP, 0x400000000000L},
       {INVINCIBLE, 0x800000000000L},
       {SOULARROW, 0x1000000000000L},
       {STUN, 0x2000000000000L},
       {POISON, 0x4000000000000L},
       {SEAL, 0x8000000000000L},
       {DARKNESS, 0x10000000000000L},
       {COMBO, 0x20000000000000L},
       {SUMMON, 0x20000000000000L},
       {WK_CHARGE, 0x40000000000000L},
       {DRAGONBLOOD, 0x80000000000000L},
       {HOLY_SYMBOL, 0x100000000000000L},
       {MESOUP, 0x200000000000000L},
       {SHADOWPARTNER, 0x400000000000000L},
       {PICKPOCKET, 0x800000000000000L},
       {PUPPET, 0x800000000000000L},
       {MESOGUARD, 0x1000000000000000L},
       {WEAKEN, 0x4000000000000000L}};
} // namespace Buffstat
} // namespace jrc

```

`Character/Buff.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <unordered_map>

namespace jrc
{
namespace Buffstat
{
enum Id {
    NONE,

    MORPH,
    RECOVERY,
    MAPLE_WARRIOR,
    STANCE,
    SHARP_EYES,
    MANA_REFLECTION,
    SHADOW_CLAW,
    INFINITY_,
    HOLY_SHIELD,
    HAMSTRING,
    BLIND,
    CONCENTRATE,
    ECHO_OF_HERO,
    GHOST_MORPH,
    AURA,
    CONFUSE,
    BERSERK_FURY,
    DIVINE_BODY,
    SPARK,
    FINALATTACK,
    BATTLESHIP,
    WATK,
    WDEF,
    MATK,
    MDEF,
    ACC,
    AVOID,
    HANDS,
    SHOWDASH,
    SPEED,
    JUMP,
    MAGIC_GUARD,
    DARKSIGHT,
    BOOSTER,
    POWERGUARD,
    HYPERBODYHP,
    HYPERBODYMP,
    INVINCIBLE,
    SOULARROW,
    STUN,
    POISON,
    SEAL,
    DARKNESS,
    COMBO,
    SUMMON,
    WK_CHARGE,
    DRAGONBLOOD,
    HOLY_SYMBOL,
    MESOUP,
    SHADOWPARTNER,
    PICKPOCKET,
    PUPPET,
    MESOGUARD,
    WEAKEN,

    DASH,
    DASH2,
    ELEMENTAL_RESET,
    ARAN_COMBO,
    COMBO_DRAIN,
    COMBO_BARRIER,
    BODY_PRESSURE,
    SMART_KNOCKBACK,
    PYRAMID_PQ,
    ENERGY_CHARGE,
    MONSTER_RIDING,
    HOMING_BEACON,
    SPEED_INFUSION,

    LENGTH
};

extern const std::unordered_map<Id, std::uint64_t> first_codes;
extern const std::unordered_map<Id, std::uint64_t> second_codes;
} // namespace Buffstat

struct Buff {
    Buffstat::Id stat;
    std::int16_t value;
    std::int32_t skillid;
    std::int32_t duration;

    constexpr Buff(Buffstat::Id stat,
                   std::int16_t value,
                   std::int32_t skillid,
                   std::int32_t duration)
        : stat(stat), value(value), skillid(skillid), duration(duration)
    {
    }

    constexpr Buff() : Buff(Buffstat::NONE, 0, 0, 0)
    {
    }
};
} // namespace jrc

```

`Character/Char.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Char.h"

#include "../Constants.h"
#include "../Data/WeaponData.h"
#include "../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <algorithm>
#include <cmath>

namespace jrc
{
Char::Char(std::int32_t o, const CharLook& lk, std::string&& name) noexcept
    : MapObject(o),
      look(lk),
      name_label({Text::A13M,
                  Text::CENTER,
                  Text::WHITE,
                  Text::NAMETAG,
                  std::move(name)})
{
}

void Char::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);

    effects.draw_below(absp, alpha);

    Color color;
    if (invincible) {
        float phi = invincible.alpha() * 30.0f;
        float rgb = 0.9f - 0.5f * std::abs(std::sin(phi));
        color = {rgb, rgb, rgb, 1.0f};
    } else {
        color = Color::WHITE;
    }
    look.draw({absp, color}, alpha);

    afterimage.draw(look.get_frame(), {absp, flip}, alpha);

    if (iron_body) {
        float ibalpha = iron_body.alpha();
        float scale = 1.0f + ibalpha;
        float opacity = 1.0f - ibalpha;
        look.draw({absp, scale, scale, opacity}, alpha);
    }

    for (const auto& pet : pets) {
        if (pet.get_item_id()) {
            pet.draw(viewx, viewy, alpha);
        }
    }

    name_label.draw(absp);
    chat_balloon.draw(absp - Point<std::int16_t>(0, 85));

    effects.draw_above(absp, alpha);

    for (const auto& number : damage_numbers) {
        number.draw(viewx, viewy, alpha);
    }
}

bool Char::update(const Physics& physics, float speed)
{
    damage_numbers.erase(std::remove_if(damage_numbers.begin(),
                                        damage_numbers.end(),
                                        [](auto& dn) { return dn.update(); }),
                         damage_numbers.end());
    effects.update();
    chat_balloon.update();
    invincible.update();
    iron_body.update();

    for (auto& pet : pets) {
        if (pet.get_item_id()) {
            switch (state) {
            case LADDER:
            case ROPE:
                pet.set_stance(PetLook::HANG);
                break;
            case SWIM:
                pet.set_stance(PetLook::FLY);
                break;
            default:
                if (pet.get_stance() == PetLook::HANG
                    || pet.get_stance() == PetLook::FLY) {
                    pet.set_stance(PetLook::STAND);
                }
            }

            pet.update(physics, get_position());
        }
    }

    std::uint16_t stance_speed = 0;
    if (speed >= 1.0f / Constants::TIMESTEP) {
        stance_speed = static_cast<std::uint16_t>(Constants::TIMESTEP * speed);
    }

    afterimage.update(look.get_frame(), stance_speed);
    return look.update(stance_speed);
}

float Char::get_stance_speed() const
{
    if (attacking) {
        return get_real_attack_speed();
    }

    switch (state) {
    case WALK:
        return static_cast<float>(std::abs(ph_obj.hspeed));
    case LADDER:
    case ROPE:
        return static_cast<float>(std::abs(ph_obj.vspeed));
    default:
        return 1.0f;
    }
}

float Char::get_real_attack_speed() const
{
    std::int8_t speed = get_integer_attack_speed();
    return 1.7f - static_cast<float>(speed) / 10.0f;
}

std::uint16_t Char::get_attack_delay(std::size_t no) const
{
    std::uint8_t first_frame = afterimage.get_first_frame();
    std::uint16_t delay = look.get_attack_delay(no, first_frame);
    float fspeed = get_real_attack_speed();
    return static_cast<std::uint16_t>(delay / fspeed);
}

std::int8_t Char::update(const Physics& physics)
{
    update(physics, 1.0f);
    return get_layer();
}

std::int8_t Char::get_layer() const
{
    return is_climbing() ? static_cast<std::int8_t>(7) : ph_obj.fh_layer;
}

void Char::show_attack_effect(Animation to_show, std::int8_t z)
{
    effects.add(to_show, {flip}, z, get_real_attack_speed());
}

void Char::show_effect_id(CharEffect::Id to_show)
{
    effects.add(char_effects[to_show]);
}

void Char::show_iron_body()
{
    iron_body.set_for(500);
}

void Char::show_damage(std::int32_t damage)
{
    std::int16_t start_y = ph_obj.get_y() - 60;
    std::int16_t x = ph_obj.get_x() - 10;
    damage_numbers.emplace_back(DamageNumber::TO_PLAYER, damage, start_y, x);

    look.set_alerted(5'000);
    invincible.set_for(2'000);
}

void Char::speak(std::string&& line)
{
    chat_balloon.change_text(std::move(line));
}

void Char::change_look(Maplestat::Id stat, std::int32_t id)
{
    switch (stat) {
    case Maplestat::SKIN:
        look.set_body(id);
        break;
    case Maplestat::FACE:
        look.set_face(id);
        break;
    case Maplestat::HAIR:
        look.set_hair(id);
        break;
    default:
        break;
    }
}

void Char::set_state(std::uint8_t state_byte)
{
    if (state_byte % 2 == 1) {
        set_direction(false);
        state_byte -= 1;
    } else {
        set_direction(true);
    }

    Char::State new_state = by_value(state_byte);
    set_state(new_state);
}

void Char::set_expression(std::int32_t exp_id)
{
    Expression::Id expression = Expression::byaction(exp_id);
    look.set_expression(expression);
}

void Char::attack(const std::string& action)
{
    look.set_action(action);

    attacking = true;
    look.set_alerted(5'000);
}

void Char::attack(Stance::Id stance)
{
    look.attack(stance);

    attacking = true;
    look.set_alerted(5'000);
}

void Char::attack(bool degenerate)
{
    look.attack(degenerate);

    attacking = true;
    look.set_alerted(5'000);
}

void Char::set_afterimage(std::int32_t skill_id)
{
    std::int32_t weapon_id = look.get_equips().get_weapon();
    if (weapon_id <= 0) {
        return;
    }

    const WeaponData& weapon = WeaponData::get(weapon_id);

    std::string stance_name = Stance::names[look.get_stance()];
    std::int16_t weapon_level
        = weapon.get_equip_data().get_req_stat(Maplestat::LEVEL);
    auto ai_name = weapon.get_afterimage();
    afterimage = {skill_id, ai_name, stance_name, weapon_level};
}

const Afterimage& Char::get_afterimage() const
{
    return afterimage;
}

void Char::set_direction(bool f)
{
    flip = f;
    look.set_direction(f);
}

void Char::set_state(State st)
{
    state = st;

    Stance::Id stance = Stance::by_state(state);
    look.set_stance(stance);
}

void Char::add_pet(std::uint8_t index,
                   std::int32_t iid,
                   std::string&& name,
                   std::int32_t uniqueid,
                   Point<std::int16_t> pos,
                   std::uint8_t stance,
                   std::int32_t fhid)
{
    if (index > 2) {
        return;
    }

    pets[index] = PetLook(iid, std::move(name), uniqueid, pos, stance, fhid);
}

void Char::remove_pet(std::uint8_t index, bool hunger)
{
    if (index > 2) {
        return;
    }

    pets[index] = PetLook();
    if (hunger) {
        // TODO ?
    }
}

bool Char::is_invincible() const
{
    return invincible == true;
}

bool Char::is_sitting() const
{
    return state == SIT;
}

bool Char::is_climbing() const
{
    return state == LADDER || state == ROPE;
}

bool Char::is_two_handed() const
{
    return look.get_equips().is_two_handed();
}

Weapon::Type Char::get_weapon_type() const
{
    std::int32_t weapon_id = look.get_equips().get_weapon();
    if (weapon_id <= 0) {
        return Weapon::NONE;
    }

    return WeaponData::get(weapon_id).get_type();
}

bool Char::get_flip() const
{
    return flip;
}

std::string_view Char::get_name() const
{
    return name_label.get_text();
}

CharLook& Char::get_look()
{
    return look;
}

const CharLook& Char::get_look() const
{
    return look;
}

PhysicsObject& Char::get_phobj()
{
    return ph_obj;
}

void Char::init()
{
    CharLook::init();

    nl::node src = nl::nx::effect["BasicEff.img"];
    for (auto path : CharEffect::PATHS) {
        char_effects.emplace(path.first, src.resolve(path.second));
    }
}

EnumMap<CharEffect::Id, Animation> Char::char_effects;
} // namespace jrc

```

`Character/Char.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http:///www.gnu.org/licenses/>.   //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Gameplay/Combat/DamageNumber.h"
#include "../Gameplay/MapleMap/MapObject.h"
#include "../Graphics/EffectLayer.h"
#include "../IO/Components/ChatBalloon.h"
#include "../Template/EnumMap.h"
#include "../Template/Rectangle.h"
#include "../Util/TimedBool.h"
#include "CharEffect.h"
#include "Inventory/Weapon.h"
#include "Look/Afterimage.h"
#include "Look/CharLook.h"
#include "Look/PetLook.h"

#include <vector>

namespace jrc
{
//! Base for characters, e.g. the player and other clients on the same map.
class Char : public MapObject
{
public:
    //! Player states which determine animation and state.
    //! Values are used in movement packets (add 1 if facing left).
    enum State : std::int8_t {
        WALK = 2,
        STAND = 4,
        FALL = 6,
        ALERT = 8,
        PRONE = 10,
        SWIM = 12,
        LADDER = 14,
        ROPE = 16,
        DIED = 18,
        SIT = 20
    };

    static State by_value(std::int8_t value) noexcept
    {
        return static_cast<State>(value);
    }

    //! Draw look, nametag, effects and chat bubble.
    void draw(double viewx, double viewy, float alpha) const override;
    //! Update look and movements.
    std::int8_t update(const Physics& physics) override;
    //! Return the current map layer, or 7 if on a ladder or rope.
    std::int8_t get_layer() const override;

    //! Check wether the character is invincible.
    virtual bool is_invincible() const;
    //! Return the character's level.
    virtual std::uint16_t get_level() const = 0;
    //! Return the character's level.
    virtual std::int32_t get_skill_level(std::int32_t skillid) const = 0;
    //! Return the character's base attacking speed.
    virtual std::int8_t get_integer_attack_speed() const = 0;

    //! Return the attack speed as a multiplier.
    float get_real_attack_speed() const;
    //! Return the delay until applying an attack.
    std::uint16_t get_attack_delay(std::size_t no) const;

    //! Set if the character sprite is mirrored (true = facing left)
    virtual void set_direction(bool flipped);
    //! Change the character's state.
    virtual void set_state(State newstate);
    //! Change the character's stance to an attack action.
    void attack(const std::string& action);
    //! Change the character's stance to an attack stance.
    void attack(Stance::Id stance);
    //! Change the character's stance to it's regular attack.
    void attack(bool degenerate);
    //! Set the afterimage for an attack.
    void set_afterimage(std::int32_t skill_id);
    //! Return the current afterimage.
    const Afterimage& get_afterimage() const;

    //! Display an animation as an effect with the character.
    void show_attack_effect(Animation to_show, std::int8_t z);
    //! Display an animation as an effect ontop of the character.
    void show_effect_id(CharEffect::Id to_show);
    //! Display the iron body skill animation.
    void show_iron_body();
    //! Display damage over the characters head.
    void show_damage(std::int32_t damage);
    //! Display a chat bubble with the specified line in it.
    void speak(std::string&& line);
    //! Change a part of the character's look.
    void change_look(Maplestat::Id stat, std::int32_t id);
    //! Change the character's state by id.
    void set_state(std::uint8_t state_byte);
    //! Change the character's face expression by id.
    void set_expression(std::int32_t exp_id);

    //! Add a pet with the specified stats.
    void add_pet(std::uint8_t index,
                 std::int32_t iid,
                 std::string&& name,
                 std::int32_t uniqueid,
                 Point<std::int16_t> pos,
                 std::uint8_t stance,
                 std::int32_t fhid);
    //! Remove a pet with the specified index and reason.
    void remove_pet(std::uint8_t index, bool hunger);

    //! Return if the character is facing left.
    bool get_flip() const;
    //! Return the name of this character.
    std::string_view get_name() const;

    //! Return if the char is in the Char::SIT state.
    bool is_sitting() const;
    //! Return if the char is in the Char::LADDER or Char::ROPE state.
    bool is_climbing() const;
    //! Return wether the character sprite uses stances for two-handed weapons.
    bool is_two_handed() const;
    //! Return the type of the currently equipped weapon.
    Weapon::Type get_weapon_type() const;

    //! Obtain a reference to this character's look.
    CharLook& get_look();
    //! Obtain a const reference to this character's look.
    const CharLook& get_look() const;
    //! Return a reference to this characters's physics.
    PhysicsObject& get_phobj();

    //! Initialize character effects.
    static void init();

protected:
    Char(std::int32_t oid, const CharLook& look, std::string&& name) noexcept;

    //! Update the character's animation with the given speed.
    bool update(const Physics& physics, float speed);
    //! Get a speed modifier for the current stance.
    float get_stance_speed() const;

    CharLook look;
    PetLook pets[3];

    State state;
    bool attacking;
    bool flip;

private:
    Text name_label;
    ChatBalloon chat_balloon;
    EffectLayer effects;
    Afterimage afterimage;
    TimedBool invincible;
    TimedBool iron_body;
    std::vector<DamageNumber> damage_numbers;

    static EnumMap<CharEffect::Id, Animation> char_effects;
};
} // namespace jrc

```

`Character/CharEffect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"

#include <string_view>

namespace jrc::CharEffect
{
//! Character effects from Effect.nx
enum Id {
    LEVELUP,
    JOBCHANGE,
    SCROLL_SUCCESS,
    SCROLL_FAILURE,
    MONSTER_CARD,

    LENGTH
};

constexpr const EnumMap<Id, std::string_view> PATHS{"LevelUp",
                                                    "JobChanged",
                                                    "Enchant/Success",
                                                    "Enchant/Failure",
                                                    "MonsterBook/cardGet"};
} // namespace jrc::CharEffect

```

`Character/CharStats.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "CharStats.h"

#include "StatCaps.h"

namespace jrc
{
CharStats::CharStats(const StatsEntry& s)
    : name(s.name),
      pet_ids(s.pet_ids),
      exp(s.exp),
      map_id(s.map_id),
      portal(s.portal),
      rank(s.rank),
      job_rank(s.job_rank),
      base_stats(s.stats)
{
    job = base_stats[Maplestat::JOB];
    init_total_stats();
}

CharStats::CharStats() = default;

void CharStats::init_total_stats()
{
    total_stats.clear();
    buff_deltas.clear();
    percentages.clear();

    total_stats[Equipstat::HP] = get_stat(Maplestat::MAXHP);
    total_stats[Equipstat::MP] = get_stat(Maplestat::MAXMP);
    total_stats[Equipstat::STR] = get_stat(Maplestat::STR);
    total_stats[Equipstat::DEX] = get_stat(Maplestat::DEX);
    total_stats[Equipstat::INT] = get_stat(Maplestat::INT);
    total_stats[Equipstat::LUK] = get_stat(Maplestat::LUK);
    total_stats[Equipstat::SPEED] = 100;
    total_stats[Equipstat::JUMP] = 100;

    max_damage = 0;
    min_damage = 0;
    honor = 0;
    attack_speed = 0;
    projectile_range = 400;
    mastery = 0.0f;
    critical = 0.05f;
    min_crit = 0.5f;
    max_crit = 0.75f;
    damage_percent = 0.0f;
    boss_dmg = 0.0f;
    ignore_def = 0.0f;
    stance = 0.0f;
    resist_status = 0.0f;
    reduce_damage = 0.0f;
}

void CharStats::close_total_stats()
{
    total_stats[Equipstat::ACC] += calculate_accuracy();

    for (auto [stat, percent] : percentages) {
        std::int32_t total = total_stats[stat];
        total += static_cast<std::int32_t>(total * percent);
        set_total(stat, total);
    }

    std::int32_t primary = get_primary_stat();
    std::int32_t secondary = get_secondary_stat();
    std::int32_t attack = get_total(Equipstat::WATK);
    float multiplier = damage_percent + static_cast<float>(attack) / 100.0f;
    max_damage = static_cast<std::int32_t>((primary + secondary) * multiplier);
    min_damage = static_cast<std::int32_t>(
        (primary * 0.9f * mastery + secondary) * multiplier);
}

std::int32_t CharStats::calculate_accuracy() const
{
    std::int32_t total_dex = get_total(Equipstat::DEX);
    std::int32_t total_luk = get_total(Equipstat::LUK);
    return static_cast<std::int32_t>(total_dex * 0.8f + total_luk * 0.5f);
}

std::int32_t CharStats::get_primary_stat() const
{
    Equipstat::Id primary = job.get_primary(weapon_type);
    return static_cast<std::int32_t>(get_multiplier() * get_total(primary));
}

std::int32_t CharStats::get_secondary_stat() const
{
    Equipstat::Id secondary = job.get_secondary(weapon_type);
    return get_total(secondary);
}

float CharStats::get_multiplier() const
{
    switch (weapon_type) {
    case Weapon::SWORD_1H:
        return 4.0f;
    case Weapon::AXE_1H:
    case Weapon::MACE_1H:
    case Weapon::WAND:
    case Weapon::STAFF:
        return 4.4f;
    case Weapon::DAGGER:
    case Weapon::CROSSBOW:
    case Weapon::CLAW:
    case Weapon::GUN:
        return 3.6f;
    case Weapon::SWORD_2H:
        return 4.6f;
    case Weapon::AXE_2H:
    case Weapon::MACE_2H:
    case Weapon::KNUCKLE:
        return 4.8f;
    case Weapon::SPEAR:
    case Weapon::POLEARM:
        return 5.0f;
    case Weapon::BOW:
        return 3.4f;
    default:
        return 0.0f;
    }
}

void CharStats::set_stat(Maplestat::Id stat, std::uint16_t value)
{
    base_stats[stat] = value;
}

void CharStats::set_total(Equipstat::Id stat, std::int32_t value)
{
    auto iter = EQSTAT_CAPS.find(stat);
    if (iter != EQSTAT_CAPS.end()) {
        std::int32_t cap_value = iter.second();

        if (value > cap_value) {
            value = cap_value;
        }
    }

    total_stats[stat] = value;
}

void CharStats::add_buff(Equipstat::Id stat, std::int32_t value)
{
    std::int32_t current = get_total(stat);
    set_total(stat, current + value);
    buff_deltas[stat] += value;
}

void CharStats::add_value(Equipstat::Id stat, std::int32_t value)
{
    std::int32_t current = get_total(stat);
    set_total(stat, current + value);
}

void CharStats::add_percent(Equipstat::Id stat, float percent)
{
    percentages[stat] += percent;
}

void CharStats::set_weapon_type(Weapon::Type wep_type)
{
    weapon_type = wep_type;
}

void CharStats::set_exp(std::int64_t e)
{
    exp = e;
}

void CharStats::set_portal(std::uint8_t p)
{
    portal = p;
}

void CharStats::set_mastery(float m)
{
    mastery = 0.5f + m;
}

void CharStats::set_damage_percent(float dmg_percent)
{
    damage_percent = dmg_percent;
}

void CharStats::set_reduce_damage(float reduce_dmg)
{
    reduce_damage = reduce_dmg;
}

void CharStats::change_job(std::uint16_t id)
{
    base_stats[Maplestat::JOB] = id;
    job.change_job(id);
}

std::int32_t CharStats::calculate_damage(std::int32_t mob_atk) const
{
    // TODO: This is just random stuff, need to find the actual formula
    // somewhere.
    std::int32_t reduce_atk
        = mob_atk / 2 + mob_atk / get_total(Equipstat::WDEF);
    return reduce_atk - static_cast<std::int32_t>(reduce_atk * reduce_damage);
}

bool CharStats::is_damage_buffed() const
{
    return get_buff_delta(Equipstat::WATK) > 0
           || get_buff_delta(Equipstat::MAGIC) > 0;
}

std::uint16_t CharStats::get_stat(Maplestat::Id stat) const
{
    return base_stats[stat];
}

std::int32_t CharStats::get_total(Equipstat::Id stat) const
{
    return total_stats[stat];
}

std::int32_t CharStats::get_buff_delta(Equipstat::Id stat) const
{
    return buff_deltas[stat];
}

Rectangle<std::int16_t> CharStats::get_range() const
{
    return {-projectile_range, -5, -50, 50};
}

std::int32_t CharStats::get_map_id() const
{
    return map_id;
}

std::uint8_t CharStats::get_portal() const
{
    return portal;
}

std::int64_t CharStats::get_exp() const
{
    return exp;
}

std::string_view CharStats::get_name() const
{
    return name;
}

std::string_view CharStats::get_job_name() const
{
    return job.get_name();
}

Weapon::Type CharStats::get_weapon_type() const
{
    return weapon_type;
}

float CharStats::get_mastery() const
{
    return mastery;
}

float CharStats::get_critical() const
{
    return critical;
}

float CharStats::get_min_crit() const
{
    return min_crit;
}

float CharStats::get_max_crit() const
{
    return max_crit;
}

float CharStats::get_reduce_damage() const
{
    return reduce_damage;
}

float CharStats::get_boss_dmg() const
{
    return boss_dmg;
}

float CharStats::get_ignore_def() const
{
    return ignore_def;
}

void CharStats::set_stance(float s)
{
    stance = s;
}

float CharStats::get_stance() const
{
    return stance;
}

float CharStats::get_resistance() const
{
    return resist_status;
}

std::int32_t CharStats::get_max_damage() const
{
    return max_damage;
}

std::int32_t CharStats::get_min_damage() const
{
    return min_damage;
}

std::uint16_t CharStats::get_honor() const
{
    return honor;
}

void CharStats::set_attack_speed(std::int8_t as)
{
    attack_speed = as;
}

std::int8_t CharStats::get_attack_speed() const
{
    return attack_speed;
}

const Job& CharStats::get_job() const
{
    return job;
}
} // namespace jrc

```

`Character/CharStats.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Net/Login.h"
#include "../Template/EnumMap.h"
#include "../Template/Rectangle.h"
#include "EquipStat.h"
#include "Inventory/Weapon.h"
#include "Job.h"

#include <string_view>

namespace jrc
{
class CharStats
{
public:
    CharStats(const StatsEntry& entry);
    CharStats();

    void init_total_stats();
    void set_stat(Maplestat::Id stat, std::uint16_t value);
    void set_total(Equipstat::Id stat, std::int32_t value);
    void add_buff(Equipstat::Id stat, std::int32_t value);
    void add_value(Equipstat::Id stat, std::int32_t value);
    void add_percent(Equipstat::Id stat, float percent);
    void close_total_stats();

    void set_weapon_type(Weapon::Type wep_type);
    void set_exp(std::int64_t exp);
    void set_portal(std::uint8_t portal);
    void set_mastery(float mastery);
    void set_damage_percent(float dmg_percent);
    void set_reduce_damage(float reduce_dmg);

    void change_job(std::uint16_t id);

    std::int32_t calculate_damage(std::int32_t mob_atk) const;

    bool is_damage_buffed() const;
    std::uint16_t get_stat(Maplestat::Id stat) const;
    std::int32_t get_total(Equipstat::Id stat) const;
    std::int32_t get_buff_delta(Equipstat::Id stat) const;
    Rectangle<std::int16_t> get_range() const;

    std::int32_t get_map_id() const;
    std::uint8_t get_portal() const;
    std::int64_t get_exp() const;
    std::string_view get_name() const;
    std::string_view get_job_name() const;
    Weapon::Type get_weapon_type() const;
    float get_mastery() const;
    float get_critical() const;
    float get_min_crit() const;
    float get_max_crit() const;
    float get_reduce_damage() const;
    float get_boss_dmg() const;
    float get_ignore_def() const;
    void set_stance(float stance);
    float get_stance() const;
    float get_resistance() const;
    std::int32_t get_max_damage() const;
    std::int32_t get_min_damage() const;
    std::uint16_t get_honor() const;
    void set_attack_speed(std::int8_t speed);
    std::int8_t get_attack_speed() const;
    const Job& get_job() const;

private:
    std::int32_t calculate_accuracy() const;
    std::int32_t get_primary_stat() const;
    std::int32_t get_secondary_stat() const;
    float get_multiplier() const;

    std::string name;
    std::vector<std::int64_t> pet_ids;
    Job job;
    std::int64_t exp;
    std::int32_t map_id;
    std::uint8_t portal;
    std::pair<std::int32_t, std::int8_t> rank;
    std::pair<std::int32_t, std::int8_t> job_rank;
    EnumMap<Maplestat::Id, std::uint16_t> base_stats;
    EnumMap<Equipstat::Id, std::int32_t> total_stats;
    EnumMap<Equipstat::Id, std::int32_t> buff_deltas;
    EnumMap<Equipstat::Id, float> percentages;
    std::int32_t max_damage;
    std::int32_t min_damage;
    std::uint16_t honor;
    std::int8_t attack_speed;
    std::int16_t projectile_range;
    Weapon::Type weapon_type;
    float mastery;
    float critical;
    float min_crit;
    float max_crit;
    float damage_percent;
    float boss_dmg;
    float ignore_def;
    float stance;
    float resist_status;
    float reduce_damage;
};
} // namespace jrc

```

`Character/EquipStat.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EquipStat.h"

namespace jrc
{
Equipstat::Id Equipstat::by_id(std::size_t id)
{
    return static_cast<Id>(id);
}

std::int32_t Equipstat::value_of(Id value)
{
    return value;
}

const char* Equipstat::names[LENGTH] = {"STR",
                                        "DEX",
                                        "INT",
                                        "LUK",
                                        "MAX HP",
                                        "MAX MP",
                                        "WEAPON ATT",
                                        "MAGIC ATT",
                                        "WEAPON DEFENSE",
                                        "MAGIC DEFENSE",
                                        "ACCURACY",
                                        "AVOID",
                                        "HANDS",
                                        "SPEED",
                                        "JUMP"};
} // namespace jrc

```

`Character/EquipStat.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Enumeration.h"

#include <cstdint>

namespace jrc
{
namespace Equipstat
{
enum Id {
    STR,
    DEX,
    INT,
    LUK,
    HP,
    MP,
    WATK,
    MAGIC,
    WDEF,
    MDEF,
    ACC,
    AVOID,
    HANDS,
    SPEED,
    JUMP,
    LENGTH
};

Id by_id(std::size_t id);
std::int32_t value_of(Id value);

constexpr Enumeration<Id> values;
extern const char* names[LENGTH];
}; // namespace Equipstat
} // namespace jrc

```

`Character/ExpTable.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ExpTable.h"

namespace jrc
{
const std::array<std::int64_t, ExpTable::LEVELCAP> ExpTable::values
    = {1,          15,         34,         57,         92,         135,
       372,        560,        840,        1242,       1144,       1573,
       2144,       2800,       3640,       4700,       5893,       7360,
       9144,       11120,      13477,      16268,      19320,      22880,
       27008,      31477,      36600,      42444,      48720,      55813,
       63800,      86784,      98208,      110932,     124432,     139372,
       155865,     173280,     192400,     213345,     235372,     259392,
       285532,     312928,     342624,     374760,     408336,     445544,
       483532,     524160,     567772,     598886,     631704,     666321,
       702836,     741351,     781976,     824828,     870028,     917625,
       967995,     1021041,    1076994,    1136013,    1198266,    1263930,
       1333194,    1406252,    1483314,    1564600,    1650340,    1740778,
       1836173,    1936794,    2042930,    2154882,    2272970,    2397528,
       2528912,    2667496,    2813674,    2967863,    3130502,    3302053,
       3483005,    3673873,    3875201,    4087562,    4311559,    4547832,
       4797053,    5059931,    5337215,    5629694,    5938202,    6263614,
       6606860,    6968915,    7350811,    7753635,    8178534,    8626718,
       9099462,    9598112,    10124088,   10678888,   11264090,   11881362,
       12532461,   13219239,   13943653,   14707765,   15513750,   16363902,
       17260644,   18206527,   19204245,   20256637,   21366700,   22537594,
       23772654,   25075395,   26449526,   27898960,   29427822,   31040466,
       32741483,   34535716,   36428273,   38424542,   40530206,   42751262,
       45094030,   47565183,   50171755,   52921167,   55821246,   58880250,
       62106888,   65510344,   69100311,   72887008,   76881216,   81094306,
       85594273,   90225770,   95170142,   100385466,  105886589,  111689174,
       117809740,  124265714,  131075474,  138258410,  145834970,  153826726,
       162256430,  171148082,  180526997,  190419876,  200854885,  211861732,
       223471711,  223471711,  248635353,  262260570,  276632449,  291791906,
       307782102,  324648562,  342439302,  361204976,  380999008,  401877754,
       423900654,  447130410,  471633156,  497478653,  524740482,  553496261,
       583827855,  615821622,  649568646,  685165008,  722712050,  762316670,
       804091623,  848155844,  894634784,  943660770,  995373379,  1049919840,
       1107455447, 1168144006, 1232158297, 1299680571, 1370903066, 1446028554,
       1525246918, 1608855764, 1697021059};
}

```

`Character/ExpTable.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <array>

namespace jrc
{
namespace ExpTable
{
constexpr std::size_t LEVELCAP = 201;
extern const std::array<std::int64_t, LEVELCAP> values;
} // namespace ExpTable
} // namespace jrc

```

`Character/Inventory/Equip.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Equip.h"

namespace jrc
{
Equip::Equip(std::int32_t item_id,
             std::int64_t expiration,
             const std::string& owner,
             std::int16_t flags,
             std::uint8_t slots,
             std::uint8_t level,
             const EnumMap<Equipstat::Id, std::uint16_t>& stats,
             std::uint8_t itemlevel,
             std::int16_t itemexp,
             std::int32_t vicious)
    : stats(stats),
      item_id(item_id),
      expiration(expiration),
      owner(owner),
      flags(flags),
      slots(slots),
      level(level),
      itemlevel(itemlevel),
      itemexp(itemexp),
      vicious(vicious)
{
    potrank = POT_NONE;
    quality = EquipQuality::check_quality(item_id, level > 0, stats);
}

std::int32_t Equip::get_item_id() const
{
    return item_id;
}

std::int64_t Equip::get_expiration() const
{
    return expiration;
}

const std::string& Equip::get_owner() const
{
    return owner;
}

std::int16_t Equip::get_flags() const
{
    return flags;
}

std::uint8_t Equip::get_slots() const
{
    return slots;
}

std::uint8_t Equip::get_level() const
{
    return level;
}

std::uint8_t Equip::get_itemlevel() const
{
    return itemlevel;
}

std::uint16_t Equip::get_stat(Equipstat::Id type) const
{
    return stats[type];
}

std::int32_t Equip::get_vicious() const
{
    return vicious;
}

Equip::Potential Equip::get_potrank() const
{
    return potrank;
}

EquipQuality::Id Equip::get_quality() const
{
    return quality;
}
} // namespace jrc

```

`Character/Inventory/Equip.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "EquipQuality.h"

#include <string>

namespace jrc
{
class Equip
{
public:
    enum Potential {
        POT_NONE,
        POT_HIDDEN,
        POT_RARE,
        POT_EPIC,
        POT_UNIQUE,
        POT_LEGENDARY,
        LENGTH
    };

    Equip(std::int32_t item_id,
          std::int64_t expiration,
          const std::string& owner,
          std::int16_t flags,
          std::uint8_t slots,
          std::uint8_t level,
          const EnumMap<Equipstat::Id, std::uint16_t>& stats,
          std::uint8_t itemlevel,
          std::int16_t itemexp,
          std::int32_t vicious);

    std::int32_t get_item_id() const;
    std::int64_t get_expiration() const;
    const std::string& get_owner() const;
    std::int16_t get_flags() const;
    std::uint8_t get_slots() const;
    std::uint8_t get_level() const;
    std::uint8_t get_itemlevel() const;
    std::uint16_t get_stat(Equipstat::Id type) const;
    std::int32_t get_vicious() const;
    Potential get_potrank() const;
    EquipQuality::Id get_quality() const;

private:
    EnumMap<Equipstat::Id, std::uint16_t> stats;
    std::int32_t item_id;
    std::int64_t expiration;
    std::string owner;
    std::int16_t flags;
    std::uint8_t slots;
    std::uint8_t level;
    std::uint8_t itemlevel;
    std::int16_t itemexp;
    std::int32_t vicious;
    Potential potrank;
    EquipQuality::Id quality;
};
} // namespace jrc

```

`Character/Inventory/EquipQuality.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EquipQuality.h"

#include "../../Data/EquipData.h"

namespace jrc
{
EquipQuality::Id
EquipQuality::check_quality(std::int32_t item_id,
                            bool scrolled,
                            const EnumMap<Equipstat::Id, std::uint16_t>& stats)
{
    const EquipData& data = EquipData::get(item_id);

    std::int16_t delta = 0;
    for (auto iter : stats) {
        Equipstat::Id es = iter.first;
        std::uint16_t stat = iter.second;
        std::uint16_t defstat = data.get_def_stat(es);
        delta += stat - defstat;
    }

    if (delta < -5) {
        return scrolled ? ORANGE : GREY;
    } else if (delta < 7) {
        return scrolled ? ORANGE : WHITE;
    } else if (delta < 14) {
        return BLUE;
    } else if (delta < 21) {
        return VIOLET;
    } else {
        return GOLD;
    }
}
} // namespace jrc

```

`Character/Inventory/EquipQuality.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "../EquipStat.h"

namespace jrc
{
namespace EquipQuality
{
enum Id { GREY, WHITE, ORANGE, BLUE, VIOLET, GOLD };

Id check_quality(std::int32_t item_id,
                 bool scrolled,
                 const EnumMap<Equipstat::Id, std::uint16_t>& stats);
} // namespace EquipQuality
} // namespace jrc

```

`Character/Inventory/Inventory.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Inventory.h"

#include "../../Console.h"
#include "../../Data/BulletData.h"
#include "../../Data/EquipData.h"
#include "../../Data/ItemData.h"

namespace jrc
{
Inventory::Inventory()
{
    bullet_slot = 0;
    meso = 0;
    running_uid = 0;
    slotmaxima[InventoryType::EQUIPPED] = Equipslot::LENGTH;
}

void Inventory::recalc_stats(Weapon::Type type)
{
    total_stats.clear();
    for (const auto& iter : inventories[InventoryType::EQUIPPED]) {
        auto equip_iter = equips.find(iter.second.unique_id);
        if (equip_iter != equips.end()) {
            const Equip& equip = equip_iter->second;
            for (auto stat_iter : total_stats) {
                stat_iter.second += equip.get_stat(stat_iter.first);
            }
        }
    }

    std::int32_t prefix = [](auto t) {
        switch (t) {
        case Weapon::BOW:
            return 2060;
        case Weapon::CROSSBOW:
            return 2061;
        case Weapon::CLAW:
            return 2070;
        case Weapon::GUN:
            return 2330;
        default:
            return 0;
        }
    }(type);

    bullet_slot = 0;
    if (prefix) {
        for (const auto& iter : inventories[InventoryType::USE]) {
            const Slot& slot = iter.second;
            if (slot.count && slot.item_id / 1000 == prefix) {
                bullet_slot = iter.first;
                break;
            }
        }
    }

    if (const auto bulletid = get_bullet_id()) {
        total_stats[Equipstat::WATK] += BulletData::get(bulletid).get_watk();
    }
}

void Inventory::set_meso(std::int64_t m)
{
    meso = m;
}

void Inventory::set_slotmax(InventoryType::Id type, std::uint8_t slotmax)
{
    slotmaxima[type] = slotmax;
}

void Inventory::add_item(InventoryType::Id invtype,
                         std::int16_t slot,
                         std::int32_t item_id,
                         bool cash,
                         std::int64_t expire,
                         std::uint16_t count,
                         const std::string& owner,
                         std::int16_t flags)
{
    items.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(add_slot(invtype, slot, item_id, count, cash)),
        std::forward_as_tuple(item_id, expire, owner, flags));
}

void Inventory::add_pet(InventoryType::Id invtype,
                        std::int16_t slot,
                        std::int32_t item_id,
                        bool cash,
                        std::int64_t expire,
                        const std::string& name,
                        std::int8_t level,
                        std::int16_t closeness,
                        std::int8_t fullness)
{
    pets.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(add_slot(invtype, slot, item_id, 1, cash)),
        std::forward_as_tuple(
            item_id, expire, name, level, closeness, fullness));
}

void Inventory::add_equip(InventoryType::Id invtype,
                          std::int16_t slot,
                          std::int32_t item_id,
                          bool cash,
                          std::int64_t expire,
                          std::uint8_t slots,
                          std::uint8_t level,
                          const EnumMap<Equipstat::Id, std::uint16_t>& stats,
                          const std::string& owner,
                          std::int16_t flag,
                          std::uint8_t ilevel,
                          std::uint16_t iexp,
                          std::int32_t vicious)
{
    equips.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(add_slot(invtype, slot, item_id, 1, cash)),
        std::forward_as_tuple(item_id,
                              expire,
                              owner,
                              flag,
                              slots,
                              level,
                              stats,
                              ilevel,
                              iexp,
                              vicious));
}

void Inventory::remove(InventoryType::Id type, std::int16_t slot)
{
    auto iter = inventories[type].find(slot);
    if (iter == inventories[type].end()) {
        return;
    }

    std::int32_t unique_id = iter->second.unique_id;
    inventories[type].erase(iter);

    switch (type) {
    case InventoryType::EQUIPPED:
    case InventoryType::EQUIP:
        equips.erase(unique_id);
        break;
    case InventoryType::CASH:
        items.erase(unique_id);
        pets.erase(unique_id);
        break;
    default:
        items.erase(unique_id);
        break;
    }
}

void Inventory::swap(InventoryType::Id first_type,
                     std::int16_t first_slot,
                     InventoryType::Id second_type,
                     std::int16_t second_slot)
{
    Slot first = std::move(inventories[first_type][first_slot]);
    inventories[first_type][first_slot]
        = std::move(inventories[second_type][second_slot]);
    inventories[second_type][second_slot] = std::move(first);

    if (!inventories[first_type][first_slot].item_id) {
        remove(first_type, first_slot);
    }
    if (!inventories[second_type][second_slot].item_id) {
        remove(second_type, second_slot);
    }
}

std::int32_t Inventory::add_slot(InventoryType::Id type,
                                 std::int16_t slot,
                                 std::int32_t item_id,
                                 std::int16_t count,
                                 bool cash)
{
    ++running_uid;
    inventories[type][slot] = {running_uid, item_id, count, cash};
    return running_uid;
}

void Inventory::change_count(InventoryType::Id type,
                             std::int16_t slot,
                             std::int16_t count)
{
    auto iter = inventories[type].find(slot);
    if (iter != inventories[type].end()) {
        iter->second.count = count;
    }
}

void Inventory::modify(InventoryType::Id type,
                       std::int16_t slot,
                       std::int8_t mode,
                       std::int16_t arg,
                       Movement move)
{
    if (slot < 0) {
        slot = -slot;
        type = InventoryType::EQUIPPED;
    }
    arg = arg < 0 ? -arg : arg;

    switch (mode) {
    case CHANGE_COUNT:
        change_count(type, slot, arg);
        break;
    case SWAP:
        switch (move) {
        case MOVE_INTERNAL:
            swap(type, slot, type, arg);
            break;
        case MOVE_UNEQUIP:
            swap(InventoryType::EQUIPPED, slot, InventoryType::EQUIP, arg);
            break;
        case MOVE_EQUIP:
            swap(InventoryType::EQUIP, slot, InventoryType::EQUIPPED, arg);
            break;
        case MOVE_NONE:
        default:
            break;
        }
        break;
    case REMOVE:
        remove(type, slot);
        break;
    default:
        break;
    }
}

std::uint8_t Inventory::get_slotmax(InventoryType::Id type) const
{
    return slotmaxima[type];
}

std::uint16_t Inventory::get_stat(Equipstat::Id type) const
{
    return total_stats[type];
}

std::int64_t Inventory::get_meso() const
{
    return meso;
}

bool Inventory::has_projectile() const
{
    return bullet_slot > 0;
}

bool Inventory::has_equipped(Equipslot::Id slot) const
{
    return inventories[InventoryType::EQUIPPED].count(slot) > 0;
}

std::int16_t Inventory::get_bullet_slot() const
{
    return bullet_slot;
}

std::uint16_t Inventory::get_bullet_count() const
{
    return static_cast<std::uint16_t>(
        get_item_count(InventoryType::USE, bullet_slot));
}

std::int32_t Inventory::get_bullet_id() const
{
    return get_item_id(InventoryType::USE, bullet_slot);
}

Equipslot::Id Inventory::find_equip_slot(std::int32_t itemid) const
{
    const EquipData& cloth = EquipData::get(itemid);
    if (!cloth.is_valid()) {
        return Equipslot::NONE;
    }

    Equipslot::Id eqslot = cloth.get_eq_slot();
    if (eqslot == Equipslot::RING) {
        if (!has_equipped(Equipslot::RING2)) {
            return Equipslot::RING2;
        }

        if (!has_equipped(Equipslot::RING3)) {
            return Equipslot::RING3;
        }

        if (!has_equipped(Equipslot::RING4)) {
            return Equipslot::RING4;
        }

        return Equipslot::RING;
    } else {
        return eqslot;
    }
}

std::int16_t Inventory::find_free_slot(InventoryType::Id type) const
{
    std::int16_t counter = 1;
    for (const auto& iter : inventories[type]) {
        if (iter.first != counter) {
            return counter;
        }

        ++counter;
    }
    return counter < slotmaxima[type] ? counter : static_cast<std::int16_t>(0);
}

std::int16_t Inventory::find_item(InventoryType::Id type,
                                  std::int32_t itemid) const
{
    for (auto& iter : inventories[type]) {
        if (iter.second.item_id == itemid) {
            return iter.first;
        }
    }
    return 0;
}

std::int16_t Inventory::get_item_count(InventoryType::Id type,
                                       std::int16_t slot) const
{
    auto iter = inventories[type].find(slot);
    if (iter != inventories[type].end()) {
        return iter->second.count;
    } else {
        return 0;
    }
}

std::int32_t Inventory::get_item_id(InventoryType::Id type,
                                    std::int16_t slot) const
{
    auto iter = inventories[type].find(slot);
    if (iter != inventories[type].end()) {
        return iter->second.item_id;
    } else {
        return 0;
    }
}

nullable_ptr<const Equip> Inventory::get_equip(InventoryType::Id type,
                                               std::int16_t slot) const
{
    if (type != InventoryType::EQUIPPED && type != InventoryType::EQUIP) {
        return {};
    }

    auto slot_iter = inventories[type].find(slot);
    if (slot_iter == inventories[type].end()) {
        return {};
    }

    auto equip_iter = equips.find(slot_iter->second.unique_id);
    if (equip_iter == equips.end()) {
        return {};
    }

    return equip_iter->second;
}

Inventory::Movement Inventory::movement_by_value(std::int8_t value)
{
    if (value >= MOVE_INTERNAL && value <= MOVE_EQUIP) {
        return static_cast<Movement>(value);
    }

    Console::get().print("Unknown move type: " + std::to_string(value));
    return MOVE_NONE;
}
} // namespace jrc

```

`Character/Inventory/Inventory.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "../../Template/nullable_ptr.h"
#include "../Look/EquipSlot.h"
#include "Equip.h"
#include "InventoryType.h"
#include "Item.h"
#include "Pet.h"
#include "Weapon.h"
#include "boost/container/flat_map.hpp"

#include <unordered_map>

namespace jrc
{
//! The player's inventory.
class Inventory
{
public:
    enum Movement : std::int8_t {
        MOVE_NONE = -1,
        MOVE_INTERNAL = 0,
        MOVE_UNEQUIP = 1,
        MOVE_EQUIP = 2
    };

    enum Modification : std::int8_t {
        ADD,
        CHANGE_COUNT,
        SWAP,
        REMOVE,
        ADD_COUNT
    };

    //! Return the move type by value.
    static Movement movement_by_value(std::int8_t value);

    Inventory();

    //! Recalculate sums of equip stats.
    void recalc_stats(Weapon::Type weapontype);
    //! Set the meso amount.
    void set_meso(std::int64_t meso);
    //! Set the number of slots for a given inventory.
    void set_slotmax(InventoryType::Id type, std::uint8_t value);

    //! Modify the inventory with info from a packet.
    void modify(InventoryType::Id type,
                std::int16_t pos,
                std::int8_t mode,
                std::int16_t arg,
                Movement movement);
    //! Add a general item.
    void add_item(InventoryType::Id type,
                  std::int16_t slot,
                  std::int32_t itemid,
                  bool cash,
                  std::int64_t expire,
                  std::uint16_t count,
                  const std::string& owner,
                  std::int16_t flag);
    //! Add a pet item.
    void add_pet(InventoryType::Id type,
                 std::int16_t slot,
                 std::int32_t itemid,
                 bool cash,
                 std::int64_t expire,
                 const std::string& name,
                 std::int8_t level,
                 std::int16_t closeness,
                 std::int8_t fullness);
    //! Add an equip item.
    void add_equip(InventoryType::Id type,
                   std::int16_t slot,
                   std::int32_t itemid,
                   bool cash,
                   std::int64_t expire,
                   std::uint8_t slots,
                   std::uint8_t level,
                   const EnumMap<Equipstat::Id, std::uint16_t>& stats,
                   const std::string& owner,
                   std::int16_t flag,
                   std::uint8_t itemlevel,
                   std::uint16_t itemexp,
                   std::int32_t vicious);

    //! Check if the use inventory contains at least one projectile.
    bool has_projectile() const;
    //! Return if an equip is equipped in the specfied slot.
    bool has_equipped(Equipslot::Id slot) const;
    //! Return the currently active projectile slot.
    std::int16_t get_bullet_slot() const;
    //! Return the count of the currently active projectile.
    std::uint16_t get_bullet_count() const;
    //! Return the item_id of the currently active projectile.
    std::int32_t get_bullet_id() const;
    //! Return the number of slots for the specified inventory.
    std::uint8_t get_slotmax(InventoryType::Id type) const;
    //! Return a total stat.
    std::uint16_t get_stat(Equipstat::Id type) const;
    //! Return the amount of meso.
    std::int64_t get_meso() const;
    //! Find a free slot for the specified equip.
    Equipslot::Id find_equip_slot(std::int32_t itemid) const;
    //! Find a free slot in the specfified inventory.
    std::int16_t find_free_slot(InventoryType::Id type) const;
    //! Return the first slot which contains the specified item.
    std::int16_t find_item(InventoryType::Id type, std::int32_t itemid) const;
    //! Return the count of an item. Returns 0 if the slot is empty.
    std::int16_t get_item_count(InventoryType::Id type,
                                std::int16_t slot) const;
    //! Return the id of an item. Returns 0 if the slot is empty.
    std::int32_t get_item_id(InventoryType::Id type, std::int16_t slot) const;

    //! Return a pointer to an equip.
    nullable_ptr<const Equip> get_equip(InventoryType::Id type,
                                        std::int16_t slot) const;

private:
    //! Add an inventory slot and return the unique_id.
    std::int32_t add_slot(InventoryType::Id type,
                          std::int16_t slot,
                          std::int32_t item_id,
                          std::int16_t count,
                          bool cash);
    //! Change the quantity of an item.
    void change_count(InventoryType::Id type,
                      std::int16_t slot,
                      std::int16_t count);
    //! Swap two items.
    void swap(InventoryType::Id first_type,

              std::int16_t first_slot,
              InventoryType::Id second_type,
              std::int16_t second_slot);
    //! Remove an item.
    void remove(InventoryType::Id type, std::int16_t slot);

    struct Slot {
        std::int32_t unique_id;
        std::int32_t item_id;
        std::int16_t count;
        bool cash;
    };

    EnumMap<InventoryType::Id, boost::container::flat_map<std::int16_t, Slot>>
        inventories;
    std::unordered_map<std::int32_t, Item> items;
    std::unordered_map<std::int32_t, Equip> equips;
    std::unordered_map<std::int32_t, Pet> pets;
    std::int32_t running_uid;

    EnumMap<Equipstat::Id, std::uint16_t> total_stats;
    EnumMap<InventoryType::Id, std::uint8_t> slotmaxima;
    std::int64_t meso;
    std::int16_t bullet_slot;
};
} // namespace jrc

```

`Character/Inventory/InventoryType.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "InventoryType.h"

#include "../../Console.h"

namespace jrc
{
InventoryType::Id InventoryType::by_item_id(std::int32_t item_id)
{
    constexpr Id values_by_id[6] = {NONE, EQUIP, USE, SETUP, ETC, CASH};

    std::int32_t prefix = item_id / 1000000;
    return (prefix > NONE && prefix <= CASH) ? values_by_id[prefix] : NONE;
}

InventoryType::Id InventoryType::by_value(std::int8_t value)
{
    switch (value) {
    case -1:
        return EQUIPPED;
    case 1:
        return EQUIP;
    case 2:
        return USE;
    case 3:
        return SETUP;
    case 4:
        return ETC;
    case 5:
        return CASH;
    }

    Console::get().print("Unknown inventory type: " + std::to_string(value));
    return NONE;
}
} // namespace jrc

```

`Character/Inventory/InventoryType.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>

namespace jrc
{
namespace InventoryType
{
//! Inventory types.
enum Id : std::int8_t { NONE, EQUIP, USE, SETUP, ETC, CASH, EQUIPPED, LENGTH };

//! Return the inventory type by item id.
Id by_item_id(std::int32_t item_id);
//! Return the inventory type by value.
Id by_value(std::int8_t value);
} // namespace InventoryType

struct InventoryPosition {
    InventoryType::Id type;
    std::int16_t slot;
};
} // namespace jrc

```

`Character/Inventory/Item.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Item.h"

namespace jrc
{
Item::Item(std::int32_t item_id,
           std::int64_t expiration,
           const std::string& owner,
           std::int16_t flags)
    : item_id(item_id), expiration(expiration), owner(owner), flags(flags)
{
}
} // namespace jrc

```

`Character/Inventory/Item.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <string>

namespace jrc
{
class Item
{
public:
    Item(std::int32_t itemid,
         std::int64_t expiration,
         const std::string& owner,
         std::int16_t flags);

private:
    std::int32_t item_id;
    std::int64_t expiration;
    std::string owner;
    std::int16_t flags;
};
} // namespace jrc

```

`Character/Inventory/Pet.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Pet.h"

namespace jrc
{
Pet::Pet(std::int32_t item_id,
         std::int64_t expiration,
         const std::string& petname,
         std::uint8_t level,
         std::uint16_t closeness,
         std::uint8_t fullness)
    : item_id(item_id),
      expiration(expiration),
      petname(petname),
      petlevel(level),
      closeness(closeness),
      fullness(fullness)
{
}
} // namespace jrc

```

`Character/Inventory/Pet.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <string>

namespace jrc
{
class Pet
{
public:
    Pet(std::int32_t item_id,
        std::int64_t expiration,
        const std::string& name,
        std::uint8_t level,
        std::uint16_t closeness,
        std::uint8_t fullness);

private:
    std::int32_t item_id;
    std::int64_t expiration;
    std::string petname;
    std::uint8_t petlevel;
    std::uint16_t closeness;
    std::uint8_t fullness;
};
} // namespace jrc

```

`Character/Inventory/Weapon.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Weapon.h"

#include "../../Console.h"
#include "../../Util/Misc.h"

namespace jrc
{
Weapon::Type Weapon::by_value(std::int32_t value)
{
    if (value < 130 || (value > 133 && value < 137) || value == 139
        || (value > 149 && value < 170) || value > 170) {
        Console::get().print(str::concat(
            "Warning: Unhandled weapon type (", std::to_string(value), ")."));
        return Weapon::NONE;
    }

    return static_cast<Type>(value);
}
} // namespace jrc

```

`Character/Inventory/Weapon.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>

namespace jrc
{
namespace Weapon
{
enum Type {
    NONE = 0,
    SWORD_1H = 130,
    AXE_1H = 131,
    MACE_1H = 132,
    DAGGER = 133,
    WAND = 137,
    STAFF = 138,
    SWORD_2H = 140,
    AXE_2H = 141,
    MACE_2H = 142,
    SPEAR = 143,
    POLEARM = 144,
    BOW = 145,
    CROSSBOW = 146,
    CLAW = 147,
    KNUCKLE = 148,
    GUN = 149,
    CASH = 170
};

Type by_value(std::int32_t value);
}; // namespace Weapon
} // namespace jrc

```

`Character/Job.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Job.h"

namespace jrc
{
Job::Job(std::uint16_t i)
{
    change_job(i);
}

Job::Job()
{
    change_job(0);
}

void Job::change_job(std::uint16_t i)
{
    id = i;
    name = get_name(id);

    if (id == 0) {
        level = BEGINNER;
    } else if (id % 100 == 0) {
        level = FIRST;
    } else if (id % 10 == 0) {
        level = SECOND;
    } else if (id % 10 == 1) {
        level = THIRD;
    } else {
        level = FOURTH;
    }
}

bool Job::is_sub_job(std::uint16_t subid) const
{
    for (std::int32_t lvit = BEGINNER; lvit <= FOURTH; ++lvit) {
        Level lv = static_cast<Level>(lvit);
        if (subid == get_subjob(lv)) {
            return true;
        }
    }

    return false;
}

bool Job::can_use(std::int32_t skill_id) const
{
    auto required = static_cast<std::uint16_t>(skill_id / 10000);
    return is_sub_job(required);
}

std::uint16_t Job::get_id() const
{
    return id;
}

std::uint16_t Job::get_subjob(Level lv) const
{
    if (lv <= level) {
        switch (lv) {
        case BEGINNER:
            return 0;
        case FIRST:
            return (id / 100) * 100;
        case SECOND:
            return (id / 10) * 10;
        case THIRD:
            return (level == FOURTH) ? id - 1 : id;
        case FOURTH:
            return id;
        }
    }
    return 0;
}

std::string_view Job::get_name() const
{
    return name;
}

Job::Level Job::get_level() const
{
    return level;
}

std::string Job::get_name(std::uint16_t jid) const
{
    switch (jid) {
    case 0:
        return "Beginner";
    case 100:
        return "Swordsman";
    case 110:
        return "Fighter";
    case 111:
        return "Crusader";
    case 112:
        return "Hero";
    case 120:
        return "Page";
    case 121:
        return "White Knight";
    case 122:
        return "Paladin";
    case 130:
        return "Spearman";
    case 131:
        return "Dragon Knight";
    case 132:
        return "Dark Knight";
    case 200:
        return "Magician";
    case 210:
        return "Wizard (F/P)";
    case 211:
        return "Mage (F/P)";
    case 212:
        return "Archmage (F/P)";
    case 220:
        return "Wizard (I/L)";
    case 221:
        return "Mage (I/L)";
    case 222:
        return "Archmage (I/L)";
    case 230:
        return "Cleric";
    case 231:
        return "Priest";
    case 232:
        return "Bishop";
    case 300:
        return "Archer";
    case 310:
        return "Hunter";
    case 311:
        return "Ranger";
    case 312:
        return "Bowmaster";
    case 320:
        return "Crossbowman";
    case 321:
        return "Sniper";
    case 322:
        return "Marksman";
    case 400:
        return "Rogue";
    case 410:
        return "Assassin";
    case 411:
        return "Hermit";
    case 412:
        return "Nightlord";
    case 420:
        return "Bandit";
    case 421:
        return "Chief Bandit";
    case 422:
        return "Shadower";
    case 500:
        return "Pirate";
    case 510:
        return "Brawler";
    case 511:
        return "Marauder";
    case 512:
        return "Buccaneer";
    case 520:
        return "Gunslinger";
    case 521:
        return "Outlaw";
    case 522:
        return "Corsair";
    case 2000:
    case 2100:
    case 2110:
    case 2111:
    case 2112:
        return "Aran";
    default:
        return "";
    }
}

Equipstat::Id Job::get_primary(Weapon::Type weapontype) const
{
    switch (id / 100) {
    case 2:
        return Equipstat::INT;
    case 3:
        return Equipstat::DEX;
    case 4:
        return Equipstat::LUK;
    case 5:
        return (weapontype == Weapon::GUN) ? Equipstat::DEX : Equipstat::STR;
    default:
        return Equipstat::STR;
    }
}

Equipstat::Id Job::get_secondary(Weapon::Type weapontype) const
{
    switch (id / 100) {
    case 2:
        return Equipstat::LUK;
    case 3:
        return Equipstat::STR;
    case 4:
        return Equipstat::DEX;
    case 5:
        return (weapontype == Weapon::GUN) ? Equipstat::STR : Equipstat::DEX;
    default:
        return Equipstat::DEX;
    }
}
} // namespace jrc

```

`Character/Job.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "EquipStat.h"
#include "Inventory/Weapon.h"

#include <cstdint>
#include <string>
#include <string_view>

namespace jrc
{
class Job
{
public:
    enum Level : std::uint16_t { BEGINNER, FIRST, SECOND, THIRD, FOURTH };

    static Level get_next_level(Level level)
    {
        switch (level) {
        case BEGINNER:
            return FIRST;
        case FIRST:
            return SECOND;
        case SECOND:
            return THIRD;
        default:
            return FOURTH;
        }
    }

    Job(std::uint16_t id);
    Job();

    void change_job(std::uint16_t id);
    bool is_sub_job(std::uint16_t subid) const;
    bool can_use(std::int32_t skill_id) const;
    std::uint16_t get_id() const;
    std::uint16_t get_subjob(Level level) const;
    Level get_level() const;
    std::string_view get_name() const;
    Equipstat::Id get_primary(Weapon::Type weapontype) const;
    Equipstat::Id get_secondary(Weapon::Type weapontype) const;

private:
    std::string get_name(std::uint16_t id) const;

    std::string name;
    std::uint16_t id;
    Level level;
};
} // namespace jrc

```

`Character/Look/Afterimage.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Afterimage.h"

#include "../../Util/Misc.h"
#include "nlnx/nx.hpp"

#include <string_view>

namespace jrc
{
Afterimage::Afterimage(std::int32_t skill_id,
                       std::string_view name,
                       std::string_view stance_name,
                       std::int16_t level)
{
    nl::node src;
    if (skill_id > 0) {
        std::string str_id = string_format::extend_id(skill_id, 7);
        src = nl::nx::skill[str::concat(std::string_view(str_id).substr(0, 3),
                                        ".img")]["skill"][str_id]["afterimage"]
                           [name][stance_name];
    }

    if (!src) {
        src = nl::nx::character["Afterimage"][str::concat(name, ".img")]
                               [level / 10][stance_name];
    }

    range = src;
    first_frame = 0;
    displayed = false;

    for (nl::node sub : src) {
        std::uint8_t frame
            = string_conversion::or_default<std::uint8_t>(sub.name(), 255);
        if (frame < 255) {
            animation = sub;
            first_frame = frame;
        }
    }
}

Afterimage::Afterimage() noexcept
{
    first_frame = 0;
    displayed = true;
}

void Afterimage::draw(std::uint8_t st_frame,
                      const DrawArgument& args,
                      float alpha) const
{
    if (!displayed && st_frame >= first_frame) {
        animation.draw(args, alpha);
    }
}

void Afterimage::update(std::uint8_t st_frame, std::uint16_t timestep)
{
    if (!displayed && st_frame >= first_frame) {
        displayed = animation.update(timestep);
    }
}

std::uint8_t Afterimage::get_first_frame() const
{
    return first_frame;
}

Rectangle<std::int16_t> Afterimage::get_range() const
{
    return range;
}
} // namespace jrc

```

`Character/Look/Afterimage.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../../Template/Rectangle.h"

namespace jrc
{
class Afterimage
{
public:
    Afterimage(std::int32_t skill_id,
               std::string_view name,
               std::string_view stance,
               std::int16_t level);
    Afterimage() noexcept;

    void
    draw(std::uint8_t st_frame, const DrawArgument& args, float alpha) const;
    void update(std::uint8_t st_frame, std::uint16_t timestep);

    std::uint8_t get_first_frame() const;
    Rectangle<std::int16_t> get_range() const;

private:
    Animation animation;
    Rectangle<std::int16_t> range;
    std::uint8_t first_frame;
    bool displayed;
};
} // namespace jrc

```

`Character/Look/Body.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Body.h"

#include "../../Console.h"
#include "../../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
Body::Body(std::int32_t skin, const BodyDrawinfo& draw_info)
{
    std::string str_img
        = str::concat("000020", string_format::extend_id(skin, 2), ".img");
    nl::node bodynode = nl::nx::character[str_img];
    str_img[3] = '1';
    nl::node head_node = nl::nx::character[str_img];

    for (auto iter : Stance::names) {
        Stance::Id stance = iter.first;
        const std::string& stance_name = iter.second;

        nl::node stance_node = bodynode[stance_name];
        if (!stance_node) {
            continue;
        }

        for (std::uint8_t frame = 0; nl::node frame_node = stance_node[frame];
             ++frame) {
            for (nl::node part_node : frame_node) {
                std::string part = part_node.name();
                if (part != "delay" && part != "face") {
                    std::string z = part_node["z"];
                    Layer layer = layer_by_name(z);
                    if (layer == Layer::NONE) {
                        continue;
                    }

                    Point<std::int16_t> shift;
                    switch (layer) {
                    case HAND_BELOW_WEAPON:
                        shift = draw_info.get_hand_pos(stance, frame);
                        shift -= part_node["map"]["handMove"];
                        break;
                    default:
                        shift = draw_info.get_body_pos(stance, frame);
                        shift -= part_node["map"]["navel"];
                        break;
                    }

                    stances[stance][layer]
                        .emplace(frame, part_node)
                        .first->second.shift(shift);
                }
            }

            if (nl::node head_s_f_node
                = head_node[stance_name][frame]["head"]) {
                Point<std::int16_t> shift
                    = draw_info.get_head_pos(stance, frame);

                stances[stance][Layer::HEAD]
                    .emplace(frame, head_s_f_node)
                    .first->second.shift(shift);
            }
        }
    }

    static constexpr const std::size_t NUM_SKIN_TYPES = 12ull;
    static constexpr const char* const skin_types[NUM_SKIN_TYPES] = {"Light",
                                                                     "Tan",
                                                                     "Dark",
                                                                     "Pale",
                                                                     "Blue",
                                                                     "Green",
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     "Grey",
                                                                     "Pink",
                                                                     "Red"};
    auto index = static_cast<std::size_t>(skin);
    name = index < NUM_SKIN_TYPES ? skin_types[index] : "";
}

void Body::draw(Stance::Id stance,
                Layer layer,
                std::uint8_t frame,
                const DrawArgument& args) const
{
    auto frame_it = stances[stance][layer].find(frame);
    if (frame_it == stances[stance][layer].end()) {
        return;
    }

    frame_it->second.draw(args);
}

std::string_view Body::get_name() const noexcept
{
    return name;
}

Body::Layer Body::layer_by_name(const std::string& name)
{
    auto layer_iter = layers_by_name.find(name);
    if (layer_iter == layers_by_name.end()) {
        Console::get().print(
            str::concat("Warning: Unhandled body layer (", name, ')'));
        return Layer::NONE;
    }
    return layer_iter->second;
}

const std::unordered_map<std::string, Body::Layer> Body::layers_by_name
    = {{"body", Body::BODY},
       {"backBody", Body::BODY},
       {"arm", Body::ARM},
       {"armBelowHead", Body::ARM_BELOW_HEAD},
       {"armBelowHeadOverMailChest", Body::ARM_BELOW_HEAD_OVER_MAIL},
       {"armOverHair", Body::ARM_OVER_HAIR},
       {"armOverHairBelowWeapon", Body::ARM_OVER_HAIR_BELOW_WEAPON},
       {"handBelowWeapon", Body::HAND_BELOW_WEAPON},
       {"handOverHair", Body::HAND_OVER_HAIR},
       {"handOverWeapon", Body::HAND_OVER_WEAPON},
       {"head", Body::HEAD}};
} // namespace jrc

```

`Character/Look/Body.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "BodyDrawInfo.h"

namespace jrc
{
class Body
{
public:
    enum Layer {
        NONE,
        BODY,
        ARM,
        ARM_BELOW_HEAD,
        ARM_BELOW_HEAD_OVER_MAIL,
        ARM_OVER_HAIR,
        ARM_OVER_HAIR_BELOW_WEAPON,
        HAND_BELOW_WEAPON,
        HAND_OVER_HAIR,
        HAND_OVER_WEAPON,
        HEAD,
        NUM_LAYERS
    };

    Body(std::int32_t skin, const BodyDrawinfo& draw_info);

    void draw(Stance::Id stance,
              Layer layer,
              std::uint8_t frame,
              const DrawArgument& args) const;

    std::string_view get_name() const noexcept;

    static Layer layer_by_name(const std::string& name);

private:
    std::unordered_map<std::uint8_t, Texture> stances[Stance::LENGTH]
                                                     [Layer::NUM_LAYERS];
    std::string name;

    static const std::unordered_map<std::string, Layer> layers_by_name;
};
} // namespace jrc

```

`Character/Look/BodyDrawInfo.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "BodyDrawInfo.h"

#include "Body.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
void BodyDrawinfo::init()
{
    nl::node body_node = nl::nx::character["00002000.img"];
    nl::node head_node = nl::nx::character["00012000.img"];

    for (nl::node stance_node : body_node) {
        std::string st_str = stance_node.name();

        std::uint16_t attack_delay = 0;
        for (std::uint8_t frame = 0; nl::node frame_node = stance_node[frame];
             ++frame) {
            bool is_action
                = frame_node["action"].data_type() == nl::node::type::string;
            if (is_action) {
                BodyAction action = frame_node;
                body_actions[st_str][frame] = action;

                if (action.is_attack_frame()) {
                    attack_delays[st_str].push_back(attack_delay);
                }
                attack_delay += action.get_delay();
            } else {
                Stance::Id stance = Stance::by_string(st_str);
                std::int16_t delay = frame_node["delay"];
                if (delay <= 0) {
                    delay = 100;
                }
                stance_delays[stance][frame]
                    = static_cast<std::uint16_t>(delay);

                std::unordered_map<
                    Body::Layer,
                    std::unordered_map<std::string, Point<std::int16_t>>>
                    body_shift_map;
                for (auto part_node : frame_node) {
                    std::string part = part_node.name();
                    if (part != "delay" && part != "face") {
                        std::string z_str = part_node["z"];
                        Body::Layer z = Body::layer_by_name(z_str);

                        for (auto map_node : part_node["map"]) {
                            body_shift_map[z].emplace(map_node.name(),
                                                      map_node);
                        }
                    }
                }

                nl::node head_map = head_node[st_str][frame]["head"]["map"];
                for (auto map_node : head_map) {
                    body_shift_map[Body::HEAD].emplace(map_node.name(),
                                                       map_node);
                }

                body_positions[stance][frame]
                    = body_shift_map[Body::BODY]["navel"];
                arm_positions[stance][frame]
                    = body_shift_map.count(Body::ARM)
                          ? (body_shift_map[Body::ARM]["hand"]
                             - body_shift_map[Body::ARM]["navel"]
                             + body_shift_map[Body::BODY]["navel"])
                          : (body_shift_map[Body::ARM_OVER_HAIR]["hand"]
                             - body_shift_map[Body::ARM_OVER_HAIR]["navel"]
                             + body_shift_map[Body::BODY]["navel"]);
                hand_positions[stance][frame]
                    = body_shift_map[Body::HAND_BELOW_WEAPON]["handMove"];
                head_positions[stance][frame]
                    = body_shift_map[Body::BODY]["neck"]
                      - body_shift_map[Body::HEAD]["neck"];
                face_positions[stance][frame]
                    = body_shift_map[Body::BODY]["neck"]
                      - body_shift_map[Body::HEAD]["neck"]
                      + body_shift_map[Body::HEAD]["brow"];
                hair_positions[stance][frame]
                    = body_shift_map[Body::HEAD]["brow"]
                      - body_shift_map[Body::HEAD]["neck"]
                      + body_shift_map[Body::BODY]["neck"];
            }
        }
    }
}

Point<std::int16_t> BodyDrawinfo::get_body_pos(Stance::Id stance,
                                               std::uint8_t frame) const
{
    auto iter = body_positions[stance].find(frame);
    if (iter == body_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

Point<std::int16_t> BodyDrawinfo::get_arm_pos(Stance::Id stance,
                                              std::uint8_t frame) const
{
    auto iter = arm_positions[stance].find(frame);
    if (iter == arm_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

Point<std::int16_t> BodyDrawinfo::get_hand_pos(Stance::Id stance,
                                               std::uint8_t frame) const
{
    auto iter = hand_positions[stance].find(frame);
    if (iter == hand_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

Point<std::int16_t> BodyDrawinfo::get_head_pos(Stance::Id stance,
                                               std::uint8_t frame) const
{
    auto iter = head_positions[stance].find(frame);
    if (iter == head_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

Point<std::int16_t> BodyDrawinfo::get_hair_pos(Stance::Id stance,
                                               std::uint8_t frame) const
{
    auto iter = hair_positions[stance].find(frame);
    if (iter == hair_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

Point<std::int16_t> BodyDrawinfo::get_face_pos(Stance::Id stance,
                                               std::uint8_t frame) const
{
    auto iter = face_positions[stance].find(frame);
    if (iter == face_positions[stance].end()) {
        return {};
    }

    return iter->second;
}

std::uint8_t BodyDrawinfo::next_frame(Stance::Id stance,
                                      std::uint8_t frame) const
{
    if (stance_delays[stance].count(frame + 1)) {
        return frame + 1;
    } else {
        return 0;
    }
}

std::uint16_t BodyDrawinfo::get_delay(Stance::Id stance,
                                      std::uint8_t frame) const
{
    auto iter = stance_delays[stance].find(frame);
    if (iter == stance_delays[stance].end()) {
        return 100u;
    }

    return iter->second;
}

std::uint16_t BodyDrawinfo::get_attack_delay(const std::string& action,
                                             std::size_t no) const
{
    auto action_iter = attack_delays.find(action);
    if (action_iter != attack_delays.end()) {
        if (no < action_iter->second.size()) {
            return action_iter->second[no];
        }
    }
    return 0;
}

std::uint8_t BodyDrawinfo::next_action_frame(const std::string& action,
                                             std::uint8_t frame) const
{
    auto action_iter = body_actions.find(action);
    if (action_iter != body_actions.end()) {
        if (action_iter->second.count(frame + 1)) {
            return frame + 1;
        }
    }
    return 0;
}

const BodyAction* BodyDrawinfo::get_action(const std::string& action,
                                           std::uint8_t frame) const
{
    auto action_iter = body_actions.find(action);
    if (action_iter != body_actions.end()) {
        auto frame_iter = action_iter->second.find(frame);
        if (frame_iter != action_iter->second.end()) {
            return &(frame_iter->second);
        }
    }
    return nullptr;
}
} // namespace jrc

```

`Character/Look/BodyDrawInfo.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Point.h"
#include "Stance.h"

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace jrc
{
//! A frame of animation for a skill or similiar 'meta-stance'.
//! This simply redirects to a different stance and frame to use.
class BodyAction
{
public:
    BodyAction(nl::node src)
    {
        stance = Stance::by_string(src["action"].get_string());
        frame = src["frame"];
        move = src["move"];

        std::int16_t sgn_delay = src["delay"];
        if (sgn_delay == 0) {
            sgn_delay = 100;
        }
        if (sgn_delay > 0) {
            delay = sgn_delay;
            attack_frame = true;
        } else if (sgn_delay < 0) {
            delay = -sgn_delay;
            attack_frame = false;
        }
    }

    BodyAction() noexcept = default;

    bool is_attack_frame() const
    {
        return attack_frame;
    }

    std::uint8_t get_frame() const
    {
        return frame;
    }

    std::uint16_t get_delay() const
    {
        return delay;
    }

    Point<std::int16_t> get_move() const
    {
        return move;
    }

    Stance::Id get_stance() const
    {
        return stance;
    }

private:
    Stance::Id stance;
    std::uint8_t frame;
    std::uint16_t delay;
    Point<std::int16_t> move;
    bool attack_frame;
};

class BodyDrawinfo
{
public:
    void init();

    Point<std::int16_t> get_body_pos(Stance::Id stance,
                                     std::uint8_t frame) const;
    Point<std::int16_t> get_arm_pos(Stance::Id stance,
                                    std::uint8_t frame) const;
    Point<std::int16_t> get_hand_pos(Stance::Id stance,
                                     std::uint8_t frame) const;
    Point<std::int16_t> get_head_pos(Stance::Id stance,
                                     std::uint8_t frame) const;
    Point<std::int16_t> get_hair_pos(Stance::Id stance,
                                     std::uint8_t frame) const;
    Point<std::int16_t> get_face_pos(Stance::Id stance,
                                     std::uint8_t frame) const;
    std::uint8_t next_frame(Stance::Id stance, std::uint8_t frame) const;
    std::uint16_t get_delay(Stance::Id stance, std::uint8_t frame) const;

    std::uint16_t get_attack_delay(const std::string& action,
                                   std::size_t no) const;
    std::uint8_t next_action_frame(const std::string& action,
                                   std::uint8_t frame) const;
    const BodyAction* get_action(const std::string& action,
                                 std::uint8_t frame) const;

private:
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        body_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        arm_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        hand_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        head_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        hair_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, Point<std::int16_t>>
        face_positions[Stance::LENGTH];
    std::unordered_map<std::uint8_t, std::uint16_t>
        stance_delays[Stance::LENGTH];

    std::unordered_map<std::string,
                       std::unordered_map<std::uint8_t, BodyAction>>
        body_actions;
    std::unordered_map<std::string, std::vector<std::uint16_t>> attack_delays;
};
} // namespace jrc

```

`Character/Look/CharEquips.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "CharEquips.h"

namespace jrc
{
CharEquips::CharEquips()
{
    for (auto iter : clothes) {
        iter.second = nullptr;
    }
}

void CharEquips::draw(Equipslot::Id slot,
                      Stance::Id stance,
                      Clothing::Layer layer,
                      std::uint8_t frame,
                      const DrawArgument& args) const
{
    if (const Clothing* cloth = clothes[slot]) {
        cloth->draw(stance, layer, frame, args);
    }
}

void CharEquips::add_equip(std::int32_t itemid, const BodyDrawinfo& drawinfo)
{
    if (itemid <= 0) {
        return;
    }

    auto iter = cloth_cache.find(itemid);
    if (iter == cloth_cache.end()) {
        iter = cloth_cache
                   .emplace(std::piecewise_construct,
                            std::forward_as_tuple(itemid),
                            std::forward_as_tuple(itemid, drawinfo))
                   .first;
    }
    const Clothing& cloth = iter->second;

    Equipslot::Id slot = cloth.get_equip_slot();
    clothes[slot] = &cloth;
}

void CharEquips::remove_equip(Equipslot::Id slot)
{
    clothes[slot] = nullptr;
}

bool CharEquips::is_visible(Equipslot::Id slot) const
{
    if (const Clothing* cloth = clothes[slot]) {
        return !cloth->is_transparent();
    } else {
        return false;
    }
}

bool CharEquips::comparelayer(Equipslot::Id slot,
                              Stance::Id stance,
                              Clothing::Layer layer) const
{
    if (const Clothing* cloth = clothes[slot]) {
        return cloth->contains_layer(stance, layer);
    } else {
        return false;
    }
}

bool CharEquips::has_overall() const
{
    return get_equip(Equipslot::TOP) / 10000 == 105;
}

bool CharEquips::has_weapon() const
{
    return get_weapon() != 0;
}

bool CharEquips::is_two_handed() const
{
    if (const Clothing* weapon = clothes[Equipslot::WEAPON]) {
        return weapon->is_two_handed();
    } else {
        return false;
    }
}

CharEquips::CapType CharEquips::getcaptype() const
{
    if (const Clothing* cap = clothes[Equipslot::CAP]) {
        const auto vslot = cap->get_vslot();
        if (vslot == "CpH1H5") {
            return HALFCOVER;
        } else if (vslot == "CpH1H5AyAs") {
            return FULLCOVER;
        } else if (vslot == "CpH5") {
            return HEADBAND;
        }
    }

    return NONE;
}

Stance::Id CharEquips::adjust_stance(Stance::Id stance) const
{
    if (const Clothing* weapon = clothes[Equipslot::WEAPON]) {
        switch (stance) {
        case Stance::STAND1:
        case Stance::STAND2:
            return weapon->get_stand();
        case Stance::WALK1:
        case Stance::WALK2:
            return weapon->get_walk();
        default:
            return stance;
        }
    } else {
        return stance;
    }
}

std::int32_t CharEquips::get_equip(Equipslot::Id slot) const
{
    if (const Clothing* cloth = clothes[slot]) {
        return cloth->get_id();
    } else {
        return 0;
    }
}

std::int32_t CharEquips::get_weapon() const
{
    return get_equip(Equipslot::WEAPON);
}

std::unordered_map<std::int32_t, Clothing> CharEquips::cloth_cache;
} // namespace jrc

```

`Character/Look/CharEquips.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Clothing.h"

namespace jrc
{
// A characters equipment (the visual part).
class CharEquips
{
public:
    // Cap types (vslot).
    enum CapType { NONE, HEADBAND, HAIRPIN, HALFCOVER, FULLCOVER };

    // Initialize pointers with 0.
    CharEquips();

    // Draw an equip.
    void draw(Equipslot::Id slot,
              Stance::Id stance,
              Clothing::Layer layer,
              std::uint8_t frame,
              const DrawArgument& args) const;
    // Add an equip, if not in cache, the equip is created from the files.
    void add_equip(std::int32_t itemid, const BodyDrawinfo& drawinfo);
    // Remove an equip.
    void remove_equip(Equipslot::Id slot);

    // Check if an equip is visible.
    bool is_visible(Equipslot::Id slot) const;
    // Check if the equip at the specified slot in the specified stance
    // contains a part on the specified layer.
    bool comparelayer(Equipslot::Id slot,
                      Stance::Id stance,
                      Clothing::Layer layer) const;
    // Return if there is an overall equipped.
    bool has_overall() const;
    // Return if there is a weapon equipped.
    bool has_weapon() const;
    // Return wether the equipped weapon is two_handed.
    bool is_two_handed() const;
    // Return the cap type (vslot).
    CapType getcaptype() const;
    // Return a stance which has been adjusted to the equipped weapon type.
    Stance::Id adjust_stance(Stance::Id stance) const;
    // Return the item id of the equip at the specified slot.
    std::int32_t get_equip(Equipslot::Id slot) const;
    // Return the item id of the equipped weapon.
    std::int32_t get_weapon() const;

private:
    EnumMap<Equipslot::Id, const Clothing*> clothes;

    static std::unordered_map<std::int32_t, Clothing> cloth_cache;
};
} // namespace jrc

```

`Character/Look/CharLook.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "CharLook.h"

#include "../../Constants.h"
#include "../../Data/WeaponData.h"

#include <array>

namespace jrc
{
CharLook::CharLook(const LookEntry& entry)
{
    reset();

    set_body(entry.skin);
    set_hair(entry.hair_id);
    set_face(entry.face_id);

    for (auto& [_, equip] : entry.equips) {
        add_equip(equip);
    }
}

CharLook::CharLook()
{
    reset();

    body = nullptr;
    hair = nullptr;
    face = nullptr;
}

void CharLook::reset()
{
    flip = true;

    action = nullptr;
    action_str = "";
    act_frame = 0;

    set_stance(Stance::STAND1);
    st_frame.set(0);
    st_elapsed = 0;

    set_expression(Expression::DEFAULT);
    exp_frame.set(0);
    exp_elapsed = 0;
}

void CharLook::draw(const DrawArgument& args,
                    Stance::Id inter_stance,
                    Expression::Id inter_expression,
                    std::uint8_t inter_frame,
                    std::uint8_t inter_exp_frame) const
{
    Point<std::int16_t> face_shift
        = draw_info.get_face_pos(inter_stance, inter_frame);
    DrawArgument faceargs
        = args + DrawArgument{face_shift, false, Point<std::int16_t>{}};

    if (Stance::is_climbing(inter_stance)) {
        body->draw(inter_stance, Body::BODY, inter_frame, args);
        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::GLOVE,
                    inter_frame,
                    args);
        equips.draw(Equipslot::SHOES,
                    inter_stance,
                    Clothing::SHOES,
                    inter_frame,
                    args);
        equips.draw(Equipslot::PANTS,
                    inter_stance,
                    Clothing::PANTS,
                    inter_frame,
                    args);
        equips.draw(
            Equipslot::TOP, inter_stance, Clothing::TOP, inter_frame, args);
        equips.draw(
            Equipslot::TOP, inter_stance, Clothing::MAIL, inter_frame, args);
        equips.draw(
            Equipslot::CAPE, inter_stance, Clothing::CAPE, inter_frame, args);
        body->draw(inter_stance, Body::HEAD, inter_frame, args);
        equips.draw(Equipslot::EARRINGS,
                    inter_stance,
                    Clothing::EARRINGS,
                    inter_frame,
                    args);

        switch (equips.getcaptype()) {
        case CharEquips::NONE:
            hair->draw(inter_stance, Hair::BACK, inter_frame, args);
            break;
        case CharEquips::HEADBAND:
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            hair->draw(inter_stance, Hair::BACK, inter_frame, args);
            break;
        case CharEquips::HALFCOVER:
            hair->draw(inter_stance, Hair::BELOWCAP, inter_frame, args);
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            break;
        case CharEquips::FULLCOVER:
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            break;
        case CharEquips::HAIRPIN:
            // TODO
            break;
        }

        equips.draw(Equipslot::SHIELD,
                    inter_stance,
                    Clothing::BACKSHIELD,
                    inter_frame,
                    args);
        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::BACKWEAPON,
                    inter_frame,
                    args);
    } else {
        hair->draw(inter_stance, Hair::BELOWBODY, inter_frame, args);
        equips.draw(
            Equipslot::CAPE, inter_stance, Clothing::CAPE, inter_frame, args);
        equips.draw(Equipslot::SHIELD,
                    inter_stance,
                    Clothing::SHIELD_BELOW_BODY,
                    inter_frame,
                    args);
        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::WEAPON_BELOW_BODY,
                    inter_frame,
                    args);
        equips.draw(Equipslot::CAP,
                    inter_stance,
                    Clothing::CAP_BELOW_BODY,
                    inter_frame,
                    args);
        body->draw(inter_stance, Body::BODY, inter_frame, args);
        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::WRIST_OVER_BODY,
                    inter_frame,
                    args);
        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::GLOVE_OVER_BODY,
                    inter_frame,
                    args);
        equips.draw(Equipslot::SHOES,
                    inter_stance,
                    Clothing::SHOES,
                    inter_frame,
                    args);
        body->draw(inter_stance, Body::ARM_BELOW_HEAD, inter_frame, args);

        if (equips.has_overall()) {
            equips.draw(Equipslot::TOP,
                        inter_stance,
                        Clothing::MAIL,
                        inter_frame,
                        args);
        } else {
            equips.draw(Equipslot::PANTS,
                        inter_stance,
                        Clothing::PANTS,
                        inter_frame,
                        args);
            equips.draw(Equipslot::TOP,
                        inter_stance,
                        Clothing::TOP,
                        inter_frame,
                        args);
        }

        body->draw(
            inter_stance, Body::ARM_BELOW_HEAD_OVER_MAIL, inter_frame, args);
        hair->draw(inter_stance, Hair::DEFAULT, inter_frame, args);
        equips.draw(Equipslot::SHIELD,
                    inter_stance,
                    Clothing::SHIELD_OVER_HAIR,
                    inter_frame,
                    args);
        equips.draw(Equipslot::EARRINGS,
                    inter_stance,
                    Clothing::EARRINGS,
                    inter_frame,
                    args);
        body->draw(inter_stance, Body::HEAD, inter_frame, args);
        hair->draw(inter_stance, Hair::SHADE, inter_frame, args);
        face->draw(inter_expression, inter_exp_frame, faceargs);
        equips.draw(
            Equipslot::FACEACC, inter_stance, Clothing::FACEACC, 0, faceargs);
        equips.draw(Equipslot::EYEACC,
                    inter_stance,
                    Clothing::EYEACC,
                    inter_frame,
                    args);
        equips.draw(Equipslot::SHIELD,
                    inter_stance,
                    Clothing::SHIELD,
                    inter_frame,
                    args);

        switch (equips.getcaptype()) {
        case CharEquips::NONE:
            hair->draw(inter_stance, Hair::OVERHEAD, inter_frame, args);
            break;
        case CharEquips::HEADBAND:
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            hair->draw(inter_stance, Hair::DEFAULT, inter_frame, args);
            hair->draw(inter_stance, Hair::OVERHEAD, inter_frame, args);
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP_OVER_HAIR,
                        inter_frame,
                        args);
            break;
        case CharEquips::HALFCOVER:
            hair->draw(inter_stance, Hair::DEFAULT, inter_frame, args);
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            break;
        case CharEquips::FULLCOVER:
            equips.draw(Equipslot::CAP,
                        inter_stance,
                        Clothing::CAP,
                        inter_frame,
                        args);
            break;
        default:
            break;
        }

        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::WEAPON_BELOW_ARM,
                    inter_frame,
                    args);
        bool twohanded = is_twohanded(inter_stance);
        if (twohanded) {
            equips.draw(Equipslot::TOP,
                        inter_stance,
                        Clothing::MAILARM,
                        inter_frame,
                        args);
            body->draw(inter_stance, Body::ARM, inter_frame, args);
            equips.draw(Equipslot::WEAPON,
                        inter_stance,
                        Clothing::WEAPON,
                        inter_frame,
                        args);
        } else {
            equips.draw(Equipslot::WEAPON,
                        inter_stance,
                        Clothing::WEAPON,
                        inter_frame,
                        args);
            body->draw(inter_stance, Body::ARM, inter_frame, args);
            equips.draw(Equipslot::TOP,
                        inter_stance,
                        Clothing::MAILARM,
                        inter_frame,
                        args);
        }

        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::WRIST,
                    inter_frame,
                    args);
        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::GLOVE,
                    inter_frame,
                    args);
        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::WEAPON_OVER_GLOVE,
                    inter_frame,
                    args);

        body->draw(inter_stance, Body::HAND_BELOW_WEAPON, inter_frame, args);

        body->draw(inter_stance, Body::ARM_OVER_HAIR, inter_frame, args);
        body->draw(
            inter_stance, Body::ARM_OVER_HAIR_BELOW_WEAPON, inter_frame, args);
        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::WEAPON_OVER_HAND,
                    inter_frame,
                    args);
        equips.draw(Equipslot::WEAPON,
                    inter_stance,
                    Clothing::WEAPON_OVER_BODY,
                    inter_frame,
                    args);
        body->draw(inter_stance, Body::HAND_OVER_HAIR, inter_frame, args);
        body->draw(inter_stance, Body::HAND_OVER_WEAPON, inter_frame, args);

        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::WRIST_OVER_HAIR,
                    inter_frame,
                    args);
        equips.draw(Equipslot::GLOVES,
                    inter_stance,
                    Clothing::GLOVE_OVER_HAIR,
                    inter_frame,
                    args);
    }
}

void CharLook::draw(const DrawArgument& args, float alpha) const
{
    if (!body || !hair || !face) {
        return;
    }

    Point<std::int16_t> ac_move;
    if (action) {
        ac_move = action->get_move();
    }

    DrawArgument rel_args = {ac_move, flip};

    Stance::Id inter_stance = stance.get(alpha);
    Expression::Id inter_expression = expression.get(alpha);
    std::uint8_t inter_frame = st_frame.get(alpha);
    std::uint8_t inter_exp_frame = exp_frame.get(alpha);

    switch (inter_stance) {
    case Stance::STAND1:
    case Stance::STAND2:
        if (alerted) {
            inter_stance = Stance::ALERT;
        }
        break;
    default:
        break;
    }

    draw(rel_args + args,
         inter_stance,
         inter_expression,
         inter_frame,
         inter_exp_frame);
}

void CharLook::draw(Point<std::int16_t> position,
                    bool flipped,
                    Stance::Id inter_stance,
                    Expression::Id inter_expression) const
{
    inter_stance = equips.adjust_stance(inter_stance);
    draw({position, flipped}, inter_stance, inter_expression, 0, 0);
}

bool CharLook::update(std::uint16_t timestep)
{
    if (timestep == 0) {
        stance.normalize();
        st_frame.normalize();
        expression.normalize();
        exp_frame.normalize();

        return false;
    }

    alerted.update();

    bool ani_end = false;
    if (action == nullptr) {
        std::uint16_t delay = get_delay(stance.get(), st_frame.get());
        std::uint16_t delta = delay - st_elapsed;
        if (timestep >= delta) {
            st_elapsed = timestep - delta;

            std::uint8_t nextframe
                = get_next_frame(stance.get(), st_frame.get());
            float threshold = static_cast<float>(delta) / timestep;
            st_frame.next(nextframe, threshold);

            if (st_frame == 0) {
                ani_end = true;
            }
        } else {
            stance.normalize();
            st_frame.normalize();

            st_elapsed += timestep;
        }
    } else {
        std::uint16_t delay = action->get_delay();
        std::uint16_t delta = delay - st_elapsed;
        if (timestep >= delta) {
            st_elapsed = timestep - delta;

            act_frame = draw_info.next_action_frame(action_str, act_frame);
            if (act_frame > 0) {
                action = draw_info.get_action(action_str, act_frame);

                float threshold = static_cast<float>(delta) / timestep;
                stance.next(action->get_stance(), threshold);
                st_frame.next(action->get_frame(), threshold);
            } else {
                ani_end = true;
                action = nullptr;
                action_str = "";
                set_stance(Stance::STAND1);
            }
        } else {
            stance.normalize();
            st_frame.normalize();

            st_elapsed += timestep;
        }
    }

    auto exp_delay = static_cast<std::uint16_t>(
        face->get_delay(expression.get(), exp_frame.get()));
    std::uint16_t exp_delta = exp_delay - exp_elapsed;
    if (timestep >= exp_delta) {
        exp_elapsed = timestep - exp_delta;

        std::uint8_t next_exp_frame
            = face->next_frame(expression.get(), exp_frame.get());
        float fc_threshold = static_cast<float>(exp_delta) / timestep;
        exp_frame.next(next_exp_frame, fc_threshold);

        if (exp_frame == 0) {
            if (expression == Expression::DEFAULT) {
                expression.next(Expression::BLINK, fc_threshold);
            } else {
                expression.next(Expression::DEFAULT, fc_threshold);
            }
        }
    } else {
        expression.normalize();
        exp_frame.normalize();

        exp_elapsed += timestep;
    }

    return ani_end;
}

void CharLook::set_body(std::int32_t skin_id)
{
    auto iter = body_types.find(skin_id);
    if (iter == body_types.end()) {
        iter = body_types
                   .emplace(std::piecewise_construct,
                            std::forward_as_tuple(skin_id),
                            std::forward_as_tuple(skin_id, draw_info))
                   .first;
    }
    body = &iter->second;
}

void CharLook::set_hair(std::int32_t hair_id)
{
    auto iter = hair_styles.find(hair_id);
    if (iter == hair_styles.end()) {
        iter = hair_styles
                   .emplace(std::piecewise_construct,
                            std::forward_as_tuple(hair_id),
                            std::forward_as_tuple(hair_id, draw_info))
                   .first;
    }
    hair = &iter->second;
}

void CharLook::set_face(std::int32_t face_id)
{
    auto iter = face_types.find(face_id);
    if (iter == face_types.end()) {
        iter = face_types.emplace(face_id, face_id).first;
    }
    face = &iter->second;
}

void CharLook::update_two_handed()
{
    Stance::Id base_stance = Stance::base_of(stance.get());
    set_stance(base_stance);
}

void CharLook::add_equip(std::int32_t item_id)
{
    equips.add_equip(item_id, draw_info);
    update_two_handed();
}

void CharLook::remove_equip(Equipslot::Id slot)
{
    equips.remove_equip(slot);
    if (slot == Equipslot::WEAPON) {
        update_two_handed();
    }
}

void CharLook::attack(bool degenerate)
{
    std::int32_t weapon_id = equips.get_weapon();
    if (weapon_id <= 0) {
        return;
    }

    const WeaponData& weapon = WeaponData::get(weapon_id);

    std::uint8_t attack_type = weapon.get_attack();
    if (attack_type == 9 && !degenerate) {
        stance.set(Stance::SHOT);
        set_action("handgun");
    } else {
        stance.set(get_attack_stance(attack_type, degenerate));
        st_frame.set(0);
        st_elapsed = 0;
    }

    weapon.get_use_sound(degenerate).play();
}

void CharLook::attack(Stance::Id new_stance)
{
    if (action || new_stance == Stance::NONE) {
        return;
    }

    switch (new_stance) {
    case Stance::SHOT:
        set_action("handgun");
        break;
    default:
        set_stance(new_stance);
    }
}

void CharLook::set_stance(Stance::Id new_stance)
{
    if (action || new_stance == Stance::NONE) {
        return;
    }

    Stance::Id adjstance = equips.adjust_stance(new_stance);
    if (stance != adjstance) {
        stance.set(adjstance);
        st_frame.set(0);
        st_elapsed = 0;
    }
}

Stance::Id CharLook::get_attack_stance(std::uint8_t attack,
                                       bool degenerate) const
{
    if (stance == Stance::PRONE) {
        return Stance::PRONESTAB;
    }

    enum Attack {
        NONE = 0,
        S1A1M1D = 1,
        SPEAR = 2,
        BOW = 3,
        CROSSBOW = 4,
        S2A2M2 = 5,
        WAND = 6,
        CLAW = 7,
        GUN = 9,
        NUM_ATTACKS
    };

    static const std::array<std::vector<Stance::Id>, NUM_ATTACKS>
        degen_stances{{{Stance::NONE},
                       {Stance::NONE},
                       {Stance::NONE},
                       {Stance::SWINGT1, Stance::SWINGT3},
                       {Stance::SWINGT1, Stance::STABT1},
                       {Stance::NONE},
                       {Stance::NONE},
                       {Stance::SWINGT1, Stance::STABT1},
                       {Stance::NONE},
                       {Stance::SWINGP1, Stance::STABT2}}};

    static const std::array<std::vector<Stance::Id>, NUM_ATTACKS>
        attack_stances{{{Stance::NONE},
                        {Stance::STABO1,
                         Stance::STABO2,
                         Stance::SWINGO1,
                         Stance::SWINGO2,
                         Stance::SWINGO3},
                        {Stance::STABT1, Stance::SWINGP1},
                        {Stance::SHOOT1},
                        {Stance::SHOOT2},
                        {Stance::STABO1,
                         Stance::STABO2,
                         Stance::SWINGT1,
                         Stance::SWINGT2,
                         Stance::SWINGT3},
                        {Stance::SWINGO1, Stance::SWINGO2},
                        {Stance::SWINGO1, Stance::SWINGO2},
                        {Stance::NONE},
                        {Stance::SHOT}}};

    if (attack <= NONE || attack >= NUM_ATTACKS) {
        return Stance::STAND1;
    }

    const auto& stances
        = degenerate ? degen_stances[attack] : attack_stances[attack];
    if (stances.empty()) {
        return Stance::STAND1;
    }

    return stances[Randomizer::next_int(stances.size())];
}

std::uint16_t CharLook::get_delay(Stance::Id st, std::uint8_t fr) const
{
    return draw_info.get_delay(st, fr);
}

std::uint8_t CharLook::get_next_frame(Stance::Id st, std::uint8_t fr) const
{
    return draw_info.next_frame(st, fr);
}

void CharLook::set_expression(Expression::Id new_expression)
{
    if (expression != new_expression) {
        expression.set(new_expression);
        exp_frame.set(0);

        exp_elapsed = 0;
    }
}

void CharLook::set_action(const std::string& ac_str)
{
    if (ac_str == action_str || ac_str.empty()) {
        return;
    }

    if (Stance::Id ac_stance = Stance::by_string(ac_str)) {
        set_stance(ac_stance);
    } else {
        action = draw_info.get_action(ac_str, 0);

        if (action) {
            act_frame = 0;
            st_elapsed = 0;
            action_str = ac_str;

            stance.set(action->get_stance());
            st_frame.set(action->get_frame());
        }
    }
}

void CharLook::set_direction(bool f)
{
    flip = f;
}

void CharLook::set_alerted(std::int64_t millis)
{
    alerted.set_for(millis);
}

bool CharLook::is_twohanded(Stance::Id st) const
{
    switch (st) {
    case Stance::STAND1:
    case Stance::WALK1:
        return false;
    case Stance::STAND2:
    case Stance::WALK2:
        return true;
    default:
        return equips.is_two_handed();
    }
}

std::uint16_t CharLook::get_attack_delay(std::size_t no,
                                         std::uint8_t first_frame) const
{
    if (action) {
        return draw_info.get_attack_delay(action_str, no);
    } else {
        std::uint16_t delay = 0;
        for (std::uint8_t frame = 0; frame < first_frame; ++frame) {
            delay += get_delay(stance.get(), frame);
        }
        return delay;
    }
}

std::uint8_t CharLook::get_frame() const
{
    return st_frame.get();
}

Stance::Id CharLook::get_stance() const
{
    return stance.get();
}

const Body* CharLook::get_body() const
{
    return body;
}

const Hair* CharLook::get_hair() const
{
    return hair;
}

const Face* CharLook::get_face() const
{
    return face;
}

const CharEquips& CharLook::get_equips() const
{
    return equips;
}

void CharLook::init()
{
    draw_info.init();
}

BodyDrawinfo CharLook::draw_info;
std::unordered_map<std::int32_t, Hair> CharLook::hair_styles;
std::unordered_map<std::int32_t, Face> CharLook::face_types;
std::unordered_map<std::int32_t, Body> CharLook::body_types;
} // namespace jrc

```

`Character/Look/CharLook.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Net/Login.h"
#include "../../Template/Interpolated.h"
#include "../../Util/Randomizer.h"
#include "../../Util/TimedBool.h"
#include "Body.h"
#include "BodyDrawInfo.h"
#include "CharEquips.h"
#include "Face.h"
#include "Hair.h"

namespace jrc
{
class CharLook
{
public:
    CharLook(const LookEntry& entry);
    CharLook();

    void reset();
    void draw(const DrawArgument& args, float alpha) const;
    void draw(Point<std::int16_t> pos,
              bool flip,
              Stance::Id inter_stance,
              Expression::Id inter_expression) const;
    bool update(std::uint16_t timestep);

    void set_hair(std::int32_t hairid);
    void set_body(std::int32_t skinid);
    void set_face(std::int32_t faceid);
    void add_equip(std::int32_t item_id);
    void remove_equip(Equipslot::Id slot);

    void attack(bool degenerate);
    void attack(Stance::Id new_stance);
    void set_stance(Stance::Id new_stance);
    void set_expression(Expression::Id new_expression);
    void set_action(const std::string& ac_str);
    void set_direction(bool mirrored);
    void set_alerted(std::int64_t millis);

    bool is_twohanded(Stance::Id stance) const;
    std::uint16_t get_attack_delay(std::size_t no,
                                   std::uint8_t first_frame) const;
    std::uint8_t get_frame() const;
    Stance::Id get_stance() const;

    const Body* get_body() const;
    const Hair* get_hair() const;
    const Face* get_face() const;
    const CharEquips& get_equips() const;

    //! Initialize draw_info.
    static void init();

private:
    void update_two_handed();
    void draw(const DrawArgument& args,
              Stance::Id inter_stance,
              Expression::Id inter_expression,
              std::uint8_t inter_frame,
              std::uint8_t inter_exp_frame) const;
    std::uint16_t get_delay(Stance::Id stance, std::uint8_t frame) const;
    std::uint8_t get_next_frame(Stance::Id stance, std::uint8_t frame) const;
    Stance::Id get_attack_stance(std::uint8_t attack, bool degenerate) const;

    Nominal<Stance::Id> stance;
    Nominal<std::uint8_t> st_frame;
    std::uint16_t st_elapsed;

    Nominal<Expression::Id> expression;
    Nominal<std::uint8_t> exp_frame;
    std::uint16_t exp_elapsed;

    bool flip;

    const BodyAction* action;
    std::string action_str;
    std::uint8_t act_frame;

    const Body* body;
    const Hair* hair;
    const Face* face;
    CharEquips equips;

    TimedBool alerted;

    static BodyDrawinfo draw_info;
    static std::unordered_map<std::int32_t, Hair> hair_styles;
    static std::unordered_map<std::int32_t, Face> face_types;
    static std::unordered_map<std::int32_t, Body> body_types;
};
} // namespace jrc

```

`Character/Look/Clothing.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Clothing.h"

#include "../../Data/EquipData.h"
#include "../../Data/WeaponData.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <string>
#include <unordered_set>

namespace jrc
{
using namespace std::string_literals;

Clothing::Clothing(std::int32_t id, const BodyDrawinfo& drawinfo) : item_id(id)
{
    const EquipData& equipdata = EquipData::get(item_id);

    equip_slot = equipdata.get_eq_slot();
    if (equip_slot == Equipslot::WEAPON) {
        two_handed = WeaponData::get(item_id).is_two_handed();
    } else {
        two_handed = false;
    }

    constexpr std::size_t NON_WEAPON_TYPES = 15;
    constexpr std::size_t WEAPON_OFFSET = NON_WEAPON_TYPES + 15;
    constexpr std::size_t WEAPON_TYPES = 20;
    constexpr Layer layers[NON_WEAPON_TYPES] = {Layer::CAP,
                                                Layer::FACEACC,
                                                Layer::EYEACC,
                                                Layer::EARRINGS,
                                                Layer::TOP,
                                                Layer::MAIL,
                                                Layer::PANTS,
                                                Layer::SHOES,
                                                Layer::GLOVE,
                                                Layer::SHIELD,
                                                Layer::CAPE,
                                                Layer::RING,
                                                Layer::PENDANT,
                                                Layer::BELT,
                                                Layer::MEDAL};

    Layer chlayer;
    std::size_t index = (static_cast<std::size_t>(item_id) / 10000ul) - 100ul;
    if (index < NON_WEAPON_TYPES) {
        chlayer = layers[index];
    } else if (index >= WEAPON_OFFSET
               && index < WEAPON_OFFSET + WEAPON_TYPES) {
        chlayer = Layer::WEAPON;
    } else {
        chlayer = Layer::CAPE;
    }

    std::string str_id = std::to_string(item_id);
    str_id.insert(0, "0", 1);
    str_id += ".img";
    nl::node src
        = nl::nx::character[equipdata.get_item_data().get_category()][str_id];
    nl::node info = src["info"];

    vslot = info["vslot"].get_string();

    switch (std::int32_t standno = info["stand"]) {
    case 1:
        stand = Stance::STAND1;
        break;
    case 2:
        stand = Stance::STAND2;
        break;
    default:
        stand = two_handed ? Stance::STAND2 : Stance::STAND1;
        break;
    }

    switch (std::int32_t walkno = info["walk"]) {
    case 1:
        walk = Stance::WALK1;
        break;
    case 2:
        walk = Stance::WALK2;
        break;
    default:
        walk = two_handed ? Stance::WALK2 : Stance::WALK1;
        break;
    }

    for (auto iter : Stance::names) {
        Stance::Id stance = iter.first;
        const std::string& stancename = iter.second;

        nl::node stancenode = src[stancename];
        if (!stancenode) {
            continue;
        }

        for (std::uint8_t frame = 0; nl::node framenode = stancenode[frame];
             ++frame) {
            for (nl::node partnode : framenode) {
                std::string part = partnode.name();
                if (!partnode
                    || partnode.data_type() != nl::node::type::bitmap) {
                    continue;
                }

                Layer z = chlayer;
                std::string zs = partnode["z"];
                if (part == "mailArm") {
                    z = Layer::MAILARM;
                } else {
                    auto sublayer_iter = sublayernames.find(zs);
                    if (sublayer_iter != sublayernames.end()) {
                        z = sublayer_iter->second;
                    }
                }

                std::string parent;
                Point<std::int16_t> parentpos;
                for (const auto& mapnode : partnode["map"]) {
                    if (mapnode.data_type() == nl::node::type::vector) {
                        parent = mapnode.name();
                        parentpos = mapnode;
                    }
                }

                // nl::node mapnode = partnode["map"];
                Point<std::int16_t> shift;
                switch (equip_slot) {
                case Equipslot::FACEACC:
                    shift -= parentpos;
                    break;
                case Equipslot::SHOES:
                case Equipslot::GLOVES:
                case Equipslot::TOP:
                case Equipslot::PANTS:
                case Equipslot::CAPE:
                    shift = drawinfo.get_body_pos(stance, frame) - parentpos;
                    break;
                case Equipslot::CAP:
                case Equipslot::EARRINGS:
                case Equipslot::EYEACC:
                    shift = drawinfo.get_face_pos(stance, frame) - parentpos;
                    break;
                case Equipslot::SHIELD:
                case Equipslot::WEAPON:
                    if (parent == "handMove") {
                        shift += drawinfo.get_hand_pos(stance, frame);
                    } else if (parent == "hand") {
                        shift += drawinfo.get_arm_pos(stance, frame);
                    } else if (parent == "navel") {
                        shift += drawinfo.get_body_pos(stance, frame);
                    }
                    shift -= parentpos;
                    break;
                default:
                    break;
                }

                stances[stance][z]
                    .emplace(frame, partnode)
                    ->second.shift(shift);
            }
        }
    }

    static const std::unordered_set<std::int32_t> transparents = {1002186};
    transparent = transparents.count(item_id) > 0;
}

void Clothing::draw(Stance::Id stance,
                    Layer layer,
                    std::uint8_t frame,
                    const DrawArgument& args) const
{
    auto range = stances[stance][layer].equal_range(frame);
    for (auto iter = range.first; iter != range.second; ++iter) {
        iter->second.draw(args);
    }
}

bool Clothing::contains_layer(Stance::Id stance, Layer layer) const noexcept
{
    return !stances[stance][layer].empty();
}

bool Clothing::is_transparent() const noexcept
{
    return transparent;
}

bool Clothing::is_two_handed() const noexcept
{
    return two_handed;
}

std::int32_t Clothing::get_id() const noexcept
{
    return item_id;
}

Stance::Id Clothing::get_stand() const noexcept
{
    return stand;
}

Stance::Id Clothing::get_walk() const noexcept
{
    return walk;
}

Equipslot::Id Clothing::get_equip_slot() const noexcept
{
    return equip_slot;
}

std::string_view Clothing::get_vslot() const noexcept
{
    return vslot;
}

const std::unordered_map<std::string, Clothing::Layer> Clothing::sublayernames
    = {
        // WEAPON
        {"weaponOverHand"s, Layer::WEAPON_OVER_HAND},
        {"weaponOverGlove"s, Layer::WEAPON_OVER_GLOVE},
        {"weaponOverBody"s, Layer::WEAPON_OVER_BODY},
        {"weaponBelowArm"s, Layer::WEAPON_BELOW_ARM},
        {"weaponBelowBody"s, Layer::WEAPON_BELOW_BODY},
        {"backWeaponOverShield"s, Layer::BACKWEAPON},
        // SHIELD
        {"shieldOverHair"s, Layer::SHIELD_OVER_HAIR},
        {"shieldBelowBody"s, Layer::SHIELD_BELOW_BODY},
        {"backShield"s, Layer::BACKSHIELD},
        // GLOVE
        {"gloveWrist"s, Layer::WRIST},
        {"gloveOverHair"s, Layer::GLOVE_OVER_HAIR},
        {"gloveOverBody"s, Layer::GLOVE_OVER_BODY},
        {"gloveWristOverHair"s, Layer::WRIST_OVER_HAIR},
        {"gloveWristOverBody"s, Layer::WRIST_OVER_BODY},
        // CAP
        {"capOverHair"s, Layer::CAP_OVER_HAIR},
        {"capBelowBody"s, Layer::CAP_BELOW_BODY},
};
} // namespace jrc

```

`Character/Look/Clothing.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../../Template/EnumMap.h"
#include "BodyDrawInfo.h"
#include "EquipSlot.h"

#include <unordered_map>

namespace jrc
{
class Clothing
{
public:
    enum Layer {
        CAPE,
        SHOES,
        PANTS,
        TOP,
        MAIL,
        MAILARM,
        EARRINGS,
        FACEACC,
        EYEACC,
        PENDANT,
        BELT,
        MEDAL,
        RING,
        CAP,
        CAP_BELOW_BODY,
        CAP_OVER_HAIR,
        GLOVE,
        WRIST,
        GLOVE_OVER_HAIR,
        WRIST_OVER_HAIR,
        GLOVE_OVER_BODY,
        WRIST_OVER_BODY,
        SHIELD,
        BACKSHIELD,
        SHIELD_BELOW_BODY,
        SHIELD_OVER_HAIR,
        WEAPON,
        BACKWEAPON,
        WEAPON_BELOW_ARM,
        WEAPON_BELOW_BODY,
        WEAPON_OVER_HAND,
        WEAPON_OVER_BODY,
        WEAPON_OVER_GLOVE,
        NUM_LAYERS
    };

    //! Construct a new equip.
    Clothing(std::int32_t itemid, const BodyDrawinfo& drawinfo);

    //! Draw the equip.
    void draw(Stance::Id stance,
              Layer layer,
              std::uint8_t frame,
              const DrawArgument& args) const;
    //! Check if a part of the equip lies on the specified layer while in the
    //! specified stance.
    [[nodiscard]] bool contains_layer(Stance::Id stance, Layer layer) const
        noexcept;

    //! Return wether the equip is invisble.
    [[nodiscard]] bool is_transparent() const noexcept;
    //! Return wether this equip uses two_handed stances.
    [[nodiscard]] bool is_two_handed() const noexcept;
    //! Return the item id.
    [[nodiscard]] std::int32_t get_id() const noexcept;
    //! Return the equip slot for this cloth.
    [[nodiscard]] Equipslot::Id get_equip_slot() const noexcept;
    //! Return the standing stance to use while equipped.
    [[nodiscard]] Stance::Id get_stand() const noexcept;
    //! Return the walking stance to use while equipped.
    [[nodiscard]] Stance::Id get_walk() const noexcept;
    //! Return the vslot, used to distinguish some layering types.
    [[nodiscard]] std::string_view get_vslot() const noexcept;

private:
    EnumMap<Stance::Id,
            EnumMap<Layer,
                    std::unordered_multimap<std::uint8_t, Texture>,
                    NUM_LAYERS>>
        stances;
    std::int32_t item_id;
    Equipslot::Id equip_slot;
    Stance::Id walk;
    Stance::Id stand;
    std::string vslot;
    bool two_handed;
    bool transparent;

    static const std::unordered_map<std::string, Layer> sublayernames;
};
} // namespace jrc

```

`Character/Look/EquipSlot.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EquipSlot.h"

#include "../../Console.h"

namespace jrc
{
Equipslot::Id Equipslot::by_id(std::int16_t id) noexcept
{
    if (id >= LENGTH) {
        Console::get().print("Invalid Equipslot id: " + std::to_string(id));
        return NONE;
    }
    return static_cast<Id>(id);
}
} // namespace jrc

```

`Character/Look/EquipSlot.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "../../Template/Enumeration.h"

#include <cstdint>

namespace jrc::Equipslot
{
enum Id : std::int16_t {
    NONE = 0,
    CAP = 1,
    FACEACC = 2,
    EYEACC = 3,
    EARRINGS = 4,
    TOP = 5,
    PANTS = 6,
    SHOES = 7,
    GLOVES = 8,
    CAPE = 9,
    SHIELD = 10,
    WEAPON = 11,
    RING = 12,
    RING2 = 13,
    RING3 = 15,
    RING4 = 16,
    PENDANT = 17,
    TAMEDMOB = 18,
    SADDLE = 19,
    MEDAL = 49,
    BELT = 50,

    LENGTH
};

[[nodiscard]] Id by_id(std::int16_t id) noexcept;

constexpr Enumeration<Id> values;
} // namespace jrc::Equipslot

```

`Character/Look/Face.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Face.h"

#include "../../Console.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
Expression::Id Expression::byaction(std::size_t action)
{
    action -= 98;
    if (action < LENGTH) {
        return static_cast<Id>(action);
    }

    Console::get().print("Unhandled expression id: " + std::to_string(action));
    return DEFAULT;
}

const EnumMap<Expression::Id, std::string> Expression::names
    = {"default", "blink",      "hit",     "smile",   "troubled", "cry",
       "angry",   "bewildered", "stunned", "blaze",   "bowing",   "cheers",
       "chu",     "dam",        "despair", "glitter", "hot",      "hum",
       "love",    "oops",       "pain",    "shine",   "vomit",    "wink"};

Face::Face(std::int32_t face_id)
{
    const std::string face_id_str = std::to_string(face_id);
    nl::node face_node
        = nl::nx::character["Face"][str::concat("000", face_id_str, ".img")];

    for (auto iter : Expression::names) {
        Expression::Id exp = iter.first;
        if (exp == Expression::DEFAULT) {
            expressions[Expression::DEFAULT].emplace(0, face_node["default"]);
        } else {
            nl::node exp_node = face_node[iter.second];
            for (std::uint8_t frame = 0; nl::node framenode = exp_node[frame];
                 ++frame) {
                expressions[exp].emplace(frame, framenode);
            }
        }
    }

    name = nl::nx::string["Eqp.img"]["Eqp"]["Face"][face_id_str]["name"]
               .get_string();
}

void Face::draw(Expression::Id expression,
                std::uint8_t frame,
                const DrawArgument& args) const
{
    auto frameit = expressions[expression].find(frame);
    if (frameit != expressions[expression].end()) {
        frameit->second.texture.draw(args);
    }
}

std::uint8_t Face::next_frame(Expression::Id exp, std::uint8_t frame) const
{
    return expressions[exp].count(frame + 1) ? frame + 1 : 0;
}

std::int16_t Face::get_delay(Expression::Id exp, std::uint8_t frame) const
{
    auto delayit = expressions[exp].find(frame);
    return delayit != expressions[exp].end() ? delayit->second.delay : 100;
}

std::string_view Face::get_name() const noexcept
{
    return name;
}
} // namespace jrc

```

`Character/Look/Face.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../../Template/EnumMap.h"
#include "BodyDrawInfo.h"

namespace jrc
{
class Expression
{
public:
    enum Id {
        DEFAULT,
        BLINK,
        HIT,
        SMILE,
        TROUBLED,
        CRY,
        ANGRY,
        BEWILDERED,
        STUNNED,
        BLAZE,
        BOWING,
        CHEERS,
        CHU,
        DAM,
        DESPAIR,
        GLITTER,
        HOT,
        HUM,
        LOVE,
        OOPS,
        PAIN,
        SHINE,
        VOMIT,
        WINK,
        LENGTH
    };

    static Id byaction(std::size_t action);

    static const EnumMap<Id, std::string> names;
};

class Face
{
public:
    Face(std::int32_t face_id);

    void draw(Expression::Id expression,
              std::uint8_t frame,
              const DrawArgument& args) const;

    std::uint8_t next_frame(Expression::Id expression,
                            std::uint8_t frame) const;
    std::int16_t get_delay(Expression::Id expression,
                           std::uint8_t frame) const;
    [[nodiscard]] std::string_view get_name() const noexcept;

private:
    struct Frame {
        Texture texture;
        std::uint16_t delay;

        Frame(nl::node src)
        {
            texture = src["face"];

            Point<std::int16_t> shift = src["face"]["map"]["brow"];
            texture.shift(-shift);

            delay = src["delay"];
            if (delay == 0) {
                delay = 2500;
            }
        }
    };

    std::unordered_map<std::uint8_t, Frame> expressions[Expression::LENGTH];
    std::string name;
};
} // namespace jrc

```

`Character/Look/Hair.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Hair.h"

#include "../../Console.h"
#include "../../Util/Misc.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Hair::Hair(std::int32_t hairid, const BodyDrawinfo& drawinfo)
{
    nl::node hairnode = nl::nx::character["Hair"][str::concat(
        "000", std::to_string(hairid), ".img")];

    for (const auto& s : Stance::names) {
        auto stance = s.first;
        auto stance_name = s.second;

        nl::node stancenode = hairnode[stance_name];
        if (!stancenode) {
            continue;
        }

        for (std::uint8_t frame = 0; nl::node framenode = stancenode[frame];
             ++frame) {
            for (nl::node layernode : framenode) {
                std::string layer_name = layernode.name();
                auto layer_iter = layers_by_name.find(layer_name);
                if (layer_iter == layers_by_name.end()) {
                    Console::get().print(str::concat(
                        "Warning: Unhandled hair layer (", layer_name, ')'));
                    continue;
                }
                Layer layer = layer_iter->second;

                Point<std::int16_t> brow = layernode["map"]["brow"];
                Point<std::int16_t> shift
                    = drawinfo.get_hair_pos(stance, frame) - brow;

                stances[stance][layer]
                    .emplace(frame, layernode)
                    .first->second.shift(shift);
            }
        }
    }

    name = nl::nx::string["Eqp.img"]["Eqp"]["Hair"][std::to_string(hairid)]
                         ["name"]
                             .get_string();

    constexpr std::size_t NUM_COLORS = 8;
    constexpr char const* haircolors[NUM_COLORS] = {"Black",
                                                    "Red",
                                                    "Orange",
                                                    "Blonde",
                                                    "Green",
                                                    "Blue",
                                                    "Violet",
                                                    "Brown"};
    std::size_t index = static_cast<std::size_t>(hairid) % 10ull;
    color = index < NUM_COLORS ? haircolors[index] : "";
}

void Hair::draw(Stance::Id stance,
                Layer layer,
                std::uint8_t frame,
                const DrawArgument& args) const
{
    auto frameit = stances[stance][layer].find(frame);
    if (frameit == stances[stance][layer].end()) {
        return;
    }

    frameit->second.draw(args);
}

std::string_view Hair::get_name() const noexcept
{
    return name;
}

std::string_view Hair::get_color() const noexcept
{
    return color;
}

const std::unordered_map<std::string, Hair::Layer> Hair::layers_by_name
    = {{"hair", Hair::DEFAULT},
       {"hairBelowBody", Hair::BELOWBODY},
       {"hairOverHead", Hair::OVERHEAD},
       {"hairShade", Hair::SHADE},
       {"backHair", Hair::BACK},
       {"backHairBelowCap", Hair::BELOWCAP}};
} // namespace jrc

```

`Character/Look/Hair.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "BodyDrawInfo.h"

namespace jrc
{
class Hair
{
public:
    enum Layer {
        NONE,
        DEFAULT,
        BELOWBODY,
        OVERHEAD,
        SHADE,
        BACK,
        BELOWCAP,
        NUM_LAYERS
    };

    Hair(std::int32_t hairid, const BodyDrawinfo& drawinfo);

    void draw(Stance::Id stance,
              Layer layer,
              std::uint8_t frame,
              const DrawArgument& args) const;

    [[nodiscard]] std::string_view get_name() const noexcept;
    [[nodiscard]] std::string_view get_color() const noexcept;

private:
    std::unordered_map<std::uint8_t, Texture> stances[Stance::LENGTH]
                                                     [Layer::NUM_LAYERS];
    std::string name;
    std::string color;

    static const std::unordered_map<std::string, Layer> layers_by_name;
};
} // namespace jrc

```

`Character/Look/PetLook.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "PetLook.h"

#include "../../Constants.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
PetLook::PetLook(std::int32_t iid,
                 std::string&& nm,
                 std::int32_t uqid,
                 Point<std::int16_t> pos,
                 std::uint8_t st,
                 std::int32_t)
{
    item_id = iid;
    name = std::move(nm);
    unique_id = uqid;
    set_position(pos.x(), pos.y());
    set_stance(st);

    namelabel = {Text::A13M,
                 Text::CENTER,
                 Text::WHITE,
                 Text::NAMETAG,
                 std::string{name}};

    std::string str_id = std::to_string(iid);

    nl::node src = nl::nx::item["Pet"][str_id + ".img"];

    animations[MOVE] = src["move"];
    animations[STAND] = src["stand0"];
    animations[JUMP] = src["jump"];
    animations[ALERT] = src["alert"];
    animations[PRONE] = src["prone"];
    animations[FLY] = src["fly"];
    animations[HANG] = src["hang"];

    nl::node effsrc = nl::nx::effect["PetEff.img"][str_id];

    animations[WARP] = effsrc["warp"];
}

PetLook::PetLook() noexcept
{
    item_id = 0;
    name = "";
    unique_id = 0;
    stance = Stance::STAND;
}

void PetLook::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absp = phobj.get_absolute(viewx, viewy, alpha);

    animations[stance].draw(DrawArgument(absp, flip), alpha);
    namelabel.draw(absp);
}

void PetLook::update(const Physics& physics,
                     Point<std::int16_t> char_pos) noexcept
{
    static constexpr double PET_WALK_FORCE = 0.35;
    static constexpr double PET_FLY_FORCE = 0.2;

    Point<std::int16_t> cur_pos = phobj.get_position();
    switch (stance) {
    case STAND:
    case MOVE:
        if (cur_pos.disp(char_pos) > 150) {
            set_position(char_pos.x(), char_pos.y());
        } else {
            if (char_pos.x() - cur_pos.x() > 50) {
                phobj.h_force = PET_WALK_FORCE;
                flip = true;
                set_stance(MOVE);
            } else if (char_pos.x() - cur_pos.x() < -50) {
                phobj.h_force = -PET_WALK_FORCE;
                flip = false;
                set_stance(MOVE);
            } else {
                phobj.h_force = 0.0;
                set_stance(STAND);
            }
        }
        phobj.type = PhysicsObject::NORMAL;
        phobj.clear_flag(PhysicsObject::NO_GRAVITY);
        break;
    case HANG:
        set_position(char_pos.x(), char_pos.y());
        phobj.set_flag(PhysicsObject::NO_GRAVITY);
        break;
    case FLY:
        if (char_pos.disp(cur_pos) > 250) {
            set_position(char_pos.x(), char_pos.y());
        } else {
            if (char_pos.x() - cur_pos.x() > 50) {
                phobj.h_force = PET_FLY_FORCE;
                flip = true;
            } else if (char_pos.x() - cur_pos.x() < -50) {
                phobj.h_force = -PET_FLY_FORCE;
                flip = false;
            } else {
                phobj.h_force = 0.0f;
            }

            if (char_pos.y() - cur_pos.y() > 50.0f) {
                phobj.v_force = PET_FLY_FORCE;
            } else if (char_pos.y() - cur_pos.y() < -50.0f) {
                phobj.v_force = -PET_FLY_FORCE;
            } else {
                phobj.v_force = 0.0f;
            }
        }
        phobj.type = PhysicsObject::FLYING;
        phobj.clear_flag(PhysicsObject::NO_GRAVITY);
        break;
    default:
        // TODO: Handle all the other cases
        break;
    }

    physics.move_object(phobj);

    animations[stance].update();
}

void PetLook::set_position(std::int16_t x, std::int16_t y) noexcept
{
    phobj.set_x(x);
    phobj.set_y(y);
}

void PetLook::set_stance(Stance st) noexcept
{
    if (stance != st) {
        stance = st;
        animations[stance].reset();
    }
}

void PetLook::set_stance(std::uint8_t stancebyte) noexcept
{
    flip = stancebyte % 2 == 1;
    stance = stance_by_value(stancebyte);
}

std::int32_t PetLook::get_item_id() const noexcept
{
    return item_id;
}

PetLook::Stance PetLook::get_stance() const noexcept
{
    return stance;
}
} // namespace jrc

```

`Character/Look/PetLook.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Gameplay/Physics/Physics.h"
#include "../../Graphics/Animation.h"
#include "../../Graphics/Text.h"
#include "../../Template/EnumMap.h"
#include "../../Template/Point.h"

#include <cstdint>
#include <map>
#include <string>

namespace jrc
{
class PetLook
{
public:
    enum Stance : std::uint8_t {
        MOVE,
        STAND,
        JUMP,
        ALERT,
        PRONE,
        FLY,
        HANG,
        WARP,
        LENGTH
    };

    static Stance stance_by_value(std::uint8_t value)
    {
        std::uint8_t value_h = value >> 1;
        return value_h >= LENGTH ? STAND : static_cast<Stance>(value_h);
    }

    PetLook(std::int32_t iid,
            std::string&& name,
            std::int32_t uniqueid,
            Point<std::int16_t> pos,
            std::uint8_t stance,
            std::int32_t fhid);
    PetLook() noexcept;

    void draw(double viewx, double viewy, float alpha) const;
    void update(const Physics& physics, Point<std::int16_t> char_pos) noexcept;

    void set_position(std::int16_t xpos, std::int16_t ypos) noexcept;
    void set_stance(Stance stance) noexcept;
    void set_stance(std::uint8_t stancebyte) noexcept;

    std::int32_t get_item_id() const noexcept;
    Stance get_stance() const noexcept;

private:
    std::int32_t item_id;
    std::string name;
    std::int32_t unique_id;
    Stance stance;
    bool flip;

    EnumMap<Stance, Animation> animations;
    PhysicsObject phobj;
    Text namelabel;
};
} // namespace jrc

```

`Character/Look/Stance.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Stance.h"

#include "../../Console.h"

namespace jrc
{
Stance::Id Stance::by_state(std::int8_t state)
{
    std::int8_t index = state / 2 - 1;
    if (index < 0 || index > 10) {
        return WALK1;
    }

    static constexpr Id state_values[10]
        = {WALK1, STAND1, JUMP, ALERT, PRONE, FLY, LADDER, ROPE, DEAD, SIT};
    return state_values[index];
}

Stance::Id Stance::by_id(std::uint8_t id)
{
    if (id <= NONE || id >= LENGTH) {
        return NONE;
    }

    return static_cast<Stance::Id>(id);
}

Stance::Id Stance::by_string(std::string_view name)
{
    for (const auto& iter : names) {
        if (iter.second == name) {
            return iter.first;
        }
    }

    Console::get().print(str::concat("Unhandled stance: ", name));
    return NONE;
}

bool Stance::is_climbing(Id value)
{
    return value == LADDER || value == ROPE;
}

Stance::Id Stance::base_of(Id value)
{
    switch (value) {
    case STAND2:
        return STAND1;
    case WALK2:
        return WALK1;
    default:
        return value;
    }
}

Stance::Id Stance::second_of(Id value)
{
    switch (value) {
    case STAND1:
        return STAND2;
    case WALK1:
        return WALK2;
    default:
        return value;
    }
}

const EnumMap<Stance::Id, std::string> Stance::names
    = {"",        "alert",   "dead",      "fly",     "heal",    "jump",
       "ladder",  "prone",   "proneStab", "rope",    "shot",    "shoot1",
       "shoot2",  "shootF",  "sit",       "stabO1",  "stabO2",  "stabOF",
       "stabT1",  "stabT2",  "stabTF",    "stand1",  "stand2",  "swingO1",
       "swingO2", "swingO3", "swingOF",   "swingP1", "swingP2", "swingPF",
       "swingT1", "swingT2", "swingT3",   "swingTF", "walk1",   "walk2"};
} // namespace jrc

```

`Character/Look/Stance.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"

#include <cstdint>
#include <string>
#include <string_view>

namespace jrc
{
namespace Stance
{
enum Id : std::uint8_t {
    NONE,
    ALERT,
    DEAD,
    FLY,
    HEAL,
    JUMP,
    LADDER,
    PRONE,
    PRONESTAB,
    ROPE,
    SHOT,
    SHOOT1,
    SHOOT2,
    SHOOTF,
    SIT,
    STABO1,
    STABO2,
    STABOF,
    STABT1,
    STABT2,
    STABTF,
    STAND1,
    STAND2,
    SWINGO1,
    SWINGO2,
    SWINGO3,
    SWINGOF,
    SWINGP1,
    SWINGP2,
    SWINGPF,
    SWINGT1,
    SWINGT2,
    SWINGT3,
    SWINGTF,
    WALK1,
    WALK2,
    LENGTH
};

Id by_state(std::int8_t state);
Id by_id(std::uint8_t id);
Id by_string(std::string_view name);

bool is_climbing(Id value);
Id base_of(Id value);
Id second_of(Id value);

extern const EnumMap<Id, std::string> names;
}; // namespace Stance
} // namespace jrc

```

`Character/MapleStat.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapleStat.h"

#include "../Console.h"
#include "../Util/Misc.h"

namespace jrc
{
Maplestat::Id Maplestat::by_id(std::size_t id)
{
    if (id >= LENGTH) {
        Console::get().print("Invalid Maplestat id: " + std::to_string(id));
    }
    return static_cast<Id>(id);
}

const EnumMap<Maplestat::Id, std::int32_t> Maplestat::codes
    = {0x1,    0x2,     0x4,     0x10,    0x20,     0x40,    0x80,
       0x100,  0x200,   0x400,   0x800,   0x1000,   0x2000,  0x4000,
       0x8000, 0x10000, 0x20000, 0x40000, 0x180008, 0x200000};
} // namespace jrc

```

`Character/MapleStat.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"

#include <cstdint>

namespace jrc::Maplestat
{
enum Id {
    SKIN,
    FACE,
    HAIR,
    LEVEL,
    JOB,
    STR,
    DEX,
    INT,
    LUK,
    HP,
    MAXHP,
    MP,
    MAXMP,
    AP,
    SP,
    EXP,
    FAME,
    MESO,
    PET,
    GACHAEXP,
    LENGTH
};

Id by_id(std::size_t id);

extern const EnumMap<Id, std::int32_t> codes;
} // namespace jrc::Maplestat

```

`Character/MonsterBook.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MonsterBook.h"

namespace jrc
{
Monsterbook::Monsterbook() noexcept : cover(0)
{
}

void Monsterbook::set_cover(std::int32_t cov) noexcept
{
    cover = cov;
}

void Monsterbook::add_card(std::int16_t card, std::int8_t level) noexcept
{
    cards[card] = level;
}
} // namespace jrc

```

`Character/MonsterBook.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <unordered_map>

namespace jrc
{
//! Class that represents the monster card collection of an individual
//! character.
class Monsterbook
{
public:
    Monsterbook() noexcept;

    void set_cover(std::int32_t) noexcept;
    void add_card(std::int16_t, std::int8_t) noexcept;

private:
    std::int32_t cover;
    std::unordered_map<std::int16_t, std::int8_t> cards;
};
} // namespace jrc

```

`Character/OtherChar.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "OtherChar.h"

#include "../Constants.h"

namespace jrc
{
OtherChar::OtherChar(std::int32_t id,
                     const CharLook& lk,
                     std::uint8_t lvl,
                     std::int16_t jb,
                     std::string&& nm,
                     std::int8_t st,
                     Point<std::int16_t> pos) noexcept
    : Char{id, lk, std::move(nm)}
{
    level = lvl;
    job = jb;
    set_position(pos);

    lastmove.xpos = pos.x();
    lastmove.ypos = pos.y();
    lastmove.newstate = st;
    timer = 0;

    attackspeed = 6;
    attacking = false;
}

std::int8_t OtherChar::update(const Physics& physics)
{
    if (timer > 1) {
        --timer;
    } else if (timer == 1) {
        if (!movements.empty()) {
            lastmove = movements.front();
            movements.pop();
        } else {
            timer = 0;
        }
    }

    if (!attacking) {
        std::uint8_t laststate = lastmove.newstate;
        set_state(laststate);
    }

    ph_obj.hspeed = lastmove.xpos - ph_obj.crnt_x();
    ph_obj.vspeed = lastmove.ypos - ph_obj.crnt_y();
    ph_obj.move();

    physics.get_fht().update_fh(ph_obj);

    bool aniend = Char::update(physics, get_stance_speed());
    if (aniend && attacking) {
        attacking = false;
    }

    return get_layer();
}

void OtherChar::send_movement(const std::vector<Movement>& newmoves)
{
    movements.push(newmoves.back());

    if (timer == 0) {
        constexpr std::uint16_t DELAY = 50;
        timer = DELAY;
    }
}

void OtherChar::update_skill(std::int32_t skillid, std::uint8_t skilllevel)
{
    skilllevels[skillid] = skilllevel;
}

void OtherChar::update_speed(std::uint8_t as)
{
    attackspeed = as;
}

void OtherChar::update_look(const LookEntry& newlook)
{
    look = newlook;

    std::uint8_t laststate = lastmove.newstate;
    set_state(laststate);
}

std::int8_t OtherChar::get_integer_attack_speed() const
{
    return attackspeed;
}

std::uint16_t OtherChar::get_level() const
{
    return level;
}

std::int32_t OtherChar::get_skill_level(std::int32_t skillid) const
{
    auto iter = skilllevels.find(skillid);
    if (iter == skilllevels.end()) {
        return 0;
    }

    return iter->second;
}
} // namespace jrc

```

`Character/OtherChar.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Gameplay/Movement.h"
#include "Char.h"
#include "Look/CharLook.h"

#include <queue>
#include <vector>

namespace jrc
{
//! Other client's players.
class OtherChar : public Char
{
public:
    OtherChar(std::int32_t charid,
              const CharLook& look,
              std::uint8_t level,
              std::int16_t job,
              std::string&& name,
              std::int8_t stance,
              Point<std::int16_t> position) noexcept;

    //! Update the character.
    std::int8_t update(const Physics& physics) override;
    //! Add the movements which this character will go through next.
    void send_movement(const std::vector<Movement>& movements);

    //! Update a skill level.
    void update_skill(std::int32_t skillid, std::uint8_t skilllevel);
    //! Update the attack speed.
    void update_speed(std::uint8_t attackspeed);
    //! Update the character look.
    void update_look(const LookEntry& look);

    //! Return the character's attacking speed.
    std::int8_t get_integer_attack_speed() const override;
    //! Return the character's level.
    std::uint16_t get_level() const override;
    //! Return the character's level of a skill.
    std::int32_t get_skill_level(std::int32_t skillid) const override;

private:
    std::uint16_t level;
    std::int16_t job;
    std::queue<Movement> movements;
    Movement lastmove;
    std::uint16_t timer;

    std::unordered_map<std::int32_t, std::uint8_t> skilllevels;
    std::uint8_t attackspeed;
};
} // namespace jrc

```

`Character/PassiveBuffs.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "PassiveBuffs.h"

#include "../Character/SkillId.h"
#include "../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
bool ConditionlessBuff::is_applicable(CharStats&, nl::node) const
{
    return true;
}

void AngelBlessingBuff::apply_to(CharStats& stats, nl::node level) const
{
    stats.add_value(Equipstat::WATK, level["x"]);
    stats.add_value(Equipstat::MAGIC, level["y"]);
    stats.add_value(Equipstat::ACC, level["z"]);
    stats.add_value(Equipstat::AVOID, level["z"]);
}

template<Weapon::Type W1, Weapon::Type W2>
bool f_is_applicable(CharStats& stats, nl::node level)
{
    return f_is_applicable<W1>(stats, level)
           || f_is_applicable<W2>(stats, level);
}

template<Weapon::Type W1>
bool f_is_applicable(CharStats& stats, nl::node)
{
    return stats.get_weapon_type() == W1;
}

template<Weapon::Type... W>
bool WeaponMasteryBuff<W...>::is_applicable(CharStats& stats,
                                            nl::node level) const
{
    return f_is_applicable<W...>(stats, level);
}

template<Weapon::Type... W>
void WeaponMasteryBuff<W...>::apply_to(CharStats& stats, nl::node level) const
{
    float mastery = static_cast<float>(level["mastery"]) / 100;
    stats.set_mastery(mastery);
    stats.add_value(Equipstat::ACC, level["x"]);
}

void AchillesBuff::apply_to(CharStats& stats, nl::node level) const
{
    float reducedamage = static_cast<float>(level["x"]) / 1000;
    stats.set_reduce_damage(reducedamage);
}

bool BerserkBuff::is_applicable(CharStats& stats, nl::node level) const
{
    float hp_percent = static_cast<float>(level["x"]) / 100;
    std::int32_t hp_threshold = static_cast<std::int32_t>(
        stats.get_total(Equipstat::HP) * hp_percent);
    std::int32_t hp_current = stats.get_stat(Maplestat::HP);
    return hp_current <= hp_threshold;
}

void BerserkBuff::apply_to(CharStats& stats, nl::node level) const
{
    float damagepercent = static_cast<float>(level["damage"]) / 100;
    stats.set_damage_percent(damagepercent);
}

PassiveBuffs::PassiveBuffs()
{
    // Beginner
    buffs[SkillId::ANGEL_BLESSING] = std::make_unique<AngelBlessingBuff>();

    // Fighter
    buffs[SkillId::SWORD_MASTERY_FIGHTER] = std::make_unique<
        WeaponMasteryBuff<Weapon::SWORD_1H, Weapon::SWORD_2H>>();
    buffs[SkillId::AXE_MASTERY] = std::make_unique<
        WeaponMasteryBuff<Weapon::AXE_1H, Weapon::AXE_2H>>();

    // Crusader

    // Hero
    buffs[SkillId::ACHILLES_HERO] = std::make_unique<AchillesBuff>();

    // Page
    buffs[SkillId::SWORD_MASTERY_FIGHTER] = std::make_unique<
        WeaponMasteryBuff<Weapon::SWORD_1H, Weapon::SWORD_2H>>();
    buffs[SkillId::BW_MASTERY] = std::make_unique<
        WeaponMasteryBuff<Weapon::MACE_1H, Weapon::MACE_2H>>();

    // White Knight

    // Paladin
    buffs[SkillId::ACHILLES_PALADIN] = std::make_unique<AchillesBuff>();

    // Spearman
    buffs[SkillId::SPEAR_MASTERY]
        = std::make_unique<WeaponMasteryBuff<Weapon::SPEAR>>();
    buffs[SkillId::PA_MASTERY]
        = std::make_unique<WeaponMasteryBuff<Weapon::POLEARM>>();

    // Dragon Knight

    // Dark Knight
    buffs[SkillId::ACHILLES_DK] = std::make_unique<AchillesBuff>();
    buffs[SkillId::BERSERK] = std::make_unique<BerserkBuff>();
}

void PassiveBuffs::apply_buff(CharStats& stats,
                              std::int32_t skill_id,
                              std::int32_t skill_level) const
{
    auto iter = buffs.find(skill_id);
    if (iter == buffs.end()) {
        return;
    }

    bool wrong_job = !stats.get_job().can_use(skill_id);
    if (wrong_job) {
        return;
    }

    std::string str_id = skill_id < 10'000'000
                             ? string_format::extend_id(skill_id, 7)
                             : std::to_string(skill_id);
    nl::node src = nl::nx::skill[str::concat(
        std::string_view(str_id).substr(0, 3), ".img")]["skill"][str_id]
                                ["level"][skill_level];

    const PassiveBuff* buff = iter->second.get();
    if (buff && buff->is_applicable(stats, src)) {
        buff->apply_to(stats, src);
    }
}
} // namespace jrc

```

`Character/PassiveBuffs.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "CharStats.h"

#include <memory>
#include <unordered_map>

namespace jrc
{
//! Interface for passive buffs.
class PassiveBuff
{
public:
    virtual ~PassiveBuff() = default;

    virtual bool is_applicable(CharStats& stats, nl::node level) const = 0;
    virtual void apply_to(CharStats& stats, nl::node level) const = 0;
};

//! Abstract base for passives without conditions.
class ConditionlessBuff : public PassiveBuff
{
public:
    bool is_applicable(CharStats& stats, nl::node level) const final;
};

//! Buff for angel blessing/blessing of the spirit.
class AngelBlessingBuff : public ConditionlessBuff
{
public:
    void apply_to(CharStats& stats, nl::node level) const override;
};

template<Weapon::Type... W>
//! Buff for Mastery skills.
class WeaponMasteryBuff : public PassiveBuff
{
public:
    bool is_applicable(CharStats& stats, nl::node level) const override;
    void apply_to(CharStats& stats, nl::node level) const override;
};

//! Buff for Achilles.
class AchillesBuff : public ConditionlessBuff
{
public:
    void apply_to(CharStats& stats, nl::node level) const override;
};

//! Buff for Berserk.
class BerserkBuff : public PassiveBuff
{
public:
    bool is_applicable(CharStats& stats, nl::node level) const override;
    void apply_to(CharStats& stats, nl::node level) const override;
};

//! Collection of passive buffs.
class PassiveBuffs
{
public:
    //! Register all effects.
    PassiveBuffs();

    //! Apply a passive skill effect to the character stats.
    void apply_buff(CharStats& stats,
                    std::int32_t skill_id,
                    std::int32_t skill_level) const;

private:
    std::unordered_map<std::int32_t, std::unique_ptr<PassiveBuff>> buffs;
};
} // namespace jrc

```

`Character/Player.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Player.h"

#include "../Constants.h"
#include "../Data/SkillData.h"
#include "../Data/WeaponData.h"
#include "../IO/UI.h"
#include "../IO/UITypes/UIStatsInfo.h"
#include "../Net/Packets/GameplayPackets.h"
#include "../Net/Packets/InventoryPackets.h"
#include "PlayerStates.h"

namespace jrc
{
const PlayerNullState null_state;

const PlayerState* get_state(Char::State state)
{
    static PlayerStandState standing;
    static PlayerWalkState walking;
    static PlayerFallState falling;
    static PlayerProneState lying;
    static PlayerClimbState climbing;
    static PlayerSitState sitting;
    static PlayerFlyState flying;

    switch (state) {
    case Char::STAND:
        return &standing;
    case Char::WALK:
        return &walking;
    case Char::FALL:
        return &falling;
    case Char::PRONE:
        return &lying;
    case Char::LADDER:
    case Char::ROPE:
        return &climbing;
    case Char::SIT:
        return &sitting;
    case Char::SWIM:
        return &flying;
    default:
        return nullptr;
    }
}

Player::Player(const CharEntry& entry)
    : Char(entry.cid, entry.look, std::string{entry.stats.name}),
      stats(entry.stats)
{
    attacking = false;
    underwater = false;

    set_state(STAND);
    set_direction(false);
}

Player::Player() : Char{0, {}, ""}
{
}

void Player::respawn(Point<std::int16_t> pos, bool uw)
{
    set_position(pos.x(), pos.y());
    underwater = uw;
    keys_down.clear();
    attacking = false;
    ladder = nullptr;
    null_state.update_state(*this);
}

void Player::send_action(KeyAction::Id action, bool down)
{
    const PlayerState* pst = get_state(state);
    if (pst) {
        pst->send_action(*this, action, down);
    }
    keys_down[action] = down;
}

void Player::recalc_stats(bool equip_changed)
{
    Weapon::Type weapon_type = get_weapon_type();

    stats.set_weapon_type(weapon_type);
    stats.init_total_stats();

    if (equip_changed) {
        inventory.recalc_stats(weapon_type);
    }

    for (auto stat : Equipstat::values) {
        std::int32_t inventory_total = inventory.get_stat(stat);
        stats.add_value(stat, inventory_total);
    }

    /* // More efficient alternative to `skillbook.collect_passives()` when the
       // order of applying passives doesn't matter. IMO it shouldn't matter,
       // but in the interest of being compliant with standard Maplestory
       // behavior, we retain the order.
    for (const auto& [skill_id, entry] : skillbook.get_entries()) {
        if (SkillData::get(skill_id).is_passive()) {
            passive_buffs.apply_buff(stats, skill_id, entry.level);
        }
    }
    */
    for (auto&& [skill_id, skill_level] : skillbook.collect_passives()) {
        passive_buffs.apply_buff(stats, skill_id, skill_level);
    }

    for (const Buff& buff : buffs.values()) {
        active_buffs.apply_buff(stats, buff.stat, buff.value);
    }

    stats.close_total_stats();

    if (auto stats_info = UI::get().get_element<UIStatsinfo>(); stats_info) {
        stats_info->update_all_stats();
    }
}

void Player::change_equip(std::int16_t slot)
{
    if (std::int32_t item_id
        = inventory.get_item_id(InventoryType::EQUIPPED, slot)) {
        look.add_equip(item_id);
    } else {
        look.remove_equip(Equipslot::by_id(slot));
    }
}

void Player::use_item(std::int32_t item_id)
{
    InventoryType::Id type = InventoryType::by_item_id(item_id);
    if (std::int16_t slot = inventory.find_item(type, item_id); slot) {
        switch (type) {
        case InventoryType::USE:
            UseItemPacket{slot, item_id}.dispatch();
            break;
        default:
            return;
        }
    }
}

void Player::draw(Layer::Id layer,
                  double viewx,
                  double viewy,
                  float alpha) const
{
    if (layer == get_layer()) {
        Char::draw(viewx, viewy, alpha);
    }
}

void Player::draw(double viewx, double viewy, float alpha) const
{
    Char::draw(viewx, viewy, alpha);
}

std::int8_t Player::update(const Physics& physics)
{
    const PlayerState* pst = get_state(state);
    if (pst) {
        pst->update(*this);
        physics.move_object(ph_obj);

        bool aniend = Char::update(physics, get_stance_speed());
        if (aniend && attacking) {
            attacking = false;
            null_state.update_state(*this);
        } else {
            pst->update_state(*this);
        }
    }

    std::uint8_t stancebyte = flip ? state : state + 1;
    Movement newmove(ph_obj, stancebyte);
    bool needupdate = last_move.hasmoved(newmove);
    if (needupdate) {
        MovePlayerPacket(newmove).dispatch();
        last_move = newmove;
    }

    return get_layer();
}

std::int8_t Player::get_integer_attack_speed() const
{
    std::int32_t weapon_id = look.get_equips().get_weapon();
    if (weapon_id <= 0) {
        return 0;
    }

    const WeaponData& weapon = WeaponData::get(weapon_id);

    std::int8_t base_speed = stats.get_attack_speed();
    std::int8_t weapon_speed = weapon.get_speed();
    return base_speed + weapon_speed;
}

void Player::set_direction(bool flipped)
{
    if (!attacking) {
        Char::set_direction(flipped);
    }
}

void Player::set_state(State st)
{
    if (!attacking) {
        Char::set_state(st);

        const PlayerState* pst = get_state(st);
        if (pst) {
            pst->initialize(*this);
        }
    }
}

bool Player::is_attacking() const
{
    return attacking;
}

bool Player::can_attack() const
{
    return !attacking && !is_climbing() && !is_sitting()
           && look.get_equips().has_weapon();
}

SpecialMove::ForbidReason Player::can_use(const SpecialMove& move) const
{
    if (move.is_skill() && state == PRONE) {
        return SpecialMove::FBR_OTHER;
    }

    if (move.is_attack() && (state == LADDER || state == ROPE)) {
        return SpecialMove::FBR_OTHER;
    }

    if (has_cooldown(move.get_id())) {
        return SpecialMove::FBR_COOLDOWN;
    }

    std::int32_t level = skillbook.get_level(move.get_id());
    Weapon::Type weapon = get_weapon_type();
    const Job& job = stats.get_job();
    std::uint16_t hp = stats.get_stat(Maplestat::HP);
    std::uint16_t mp = stats.get_stat(Maplestat::MP);
    std::uint16_t bullets = inventory.get_bullet_count();

    return move.can_use(level, weapon, job, hp, mp, bullets);
}

Attack Player::prepare_attack(bool skill) const
{
    Attack::Type attacktype;
    bool degenerate;
    if (state == PRONE) {
        degenerate = true;
        attacktype = Attack::CLOSE;
    } else {
        Weapon::Type weapontype = get_weapon_type();
        switch (weapontype) {
        case Weapon::BOW:
        case Weapon::CROSSBOW:
        case Weapon::CLAW:
        case Weapon::GUN:
            degenerate = !inventory.has_projectile();
            attacktype = degenerate ? Attack::CLOSE : Attack::RANGED;
            break;
        case Weapon::WAND:
        case Weapon::STAFF:
            degenerate = !skill;
            attacktype = degenerate ? Attack::CLOSE : Attack::MAGIC;
            break;
        default:
            attacktype = Attack::CLOSE;
            degenerate = false;
        }
    }

    Attack attack;
    attack.type = attacktype;
    attack.min_damage = stats.get_min_damage();
    attack.max_damage = stats.get_max_damage();
    if (degenerate) {
        attack.min_damage /= 10;
        attack.max_damage /= 10;
    }
    attack.critical = stats.get_critical();
    attack.ignore_def = stats.get_ignore_def();
    attack.accuracy = stats.get_total(Equipstat::ACC);
    attack.player_level = stats.get_stat(Maplestat::LEVEL);
    attack.range = stats.get_range();
    attack.bullet = inventory.get_bullet_id();
    attack.origin = get_position();
    attack.to_left = !flip;
    attack.speed = static_cast<std::uint8_t>(get_integer_attack_speed());

    return attack;
}

void Player::rush(double target_x)
{
    if (ph_obj.on_ground) {
        std::uint16_t delay = get_attack_delay(1);
        ph_obj.move_x_until(target_x, delay);
        ph_obj.set_flag(PhysicsObject::TURN_AT_EDGES);
    }
}

bool Player::is_invincible() const
{
    if (state == DIED) {
        return true;
    }

    if (has_buff(Buffstat::DARKSIGHT)) {
        return true;
    }

    return Char::is_invincible();
}

MobAttackResult Player::damage(const MobAttack& attack)
{
    std::int32_t damage = stats.calculate_damage(attack.watk);
    show_damage(damage);

    bool from_left = attack.origin.x() > ph_obj.get_x();

    bool missed = damage <= 0;
    bool immovable = ladder || state == DIED;
    bool knockback = !missed && !immovable;
    if (knockback && Randomizer::above(stats.get_stance())) {
        ph_obj.hspeed = from_left ? -1.5 : 1.5;
        ph_obj.v_force -= 3.5;
    }

    std::uint8_t direction = from_left ? 0 : 1;
    return {attack, damage, direction};
}

void Player::give_buff(Buff buff)
{
    buffs[buff.stat] = buff;
}

void Player::cancel_buff(Buffstat::Id stat)
{
    buffs[stat] = {};
}

bool Player::has_buff(Buffstat::Id stat) const
{
    return buffs[stat].value > 0;
}

void Player::change_skill(std::int32_t skill_id,
                          std::int32_t skill_level,
                          std::int32_t master_level,
                          std::int64_t expiration)
{
    std::int32_t old_level = skillbook.get_level(skill_id);
    skillbook.set_skill(skill_id, skill_level, master_level, expiration);

    if (old_level != skill_level) {
        recalc_stats(false);
    }
}

void Player::add_cooldown(std::int32_t skill_id, std::int32_t cool_time)
{
    cooldowns[skill_id] = cool_time;
}

bool Player::has_cooldown(std::int32_t skill_id) const
{
    auto iter = cooldowns.find(skill_id);
    if (iter == cooldowns.end()) {
        return false;
    }

    return iter->second > 0;
}

void Player::change_level(std::uint16_t level)
{
    std::uint16_t oldlevel = get_level();
    if (level > oldlevel) {
        show_effect_id(CharEffect::LEVELUP);
    }
    stats.set_stat(Maplestat::LEVEL, level);
}

std::uint16_t Player::get_level() const
{
    return stats.get_stat(Maplestat::LEVEL);
}

std::int32_t Player::get_skill_level(std::int32_t skill_id) const
{
    return skillbook.get_level(skill_id);
}

void Player::change_job(std::uint16_t job_id)
{
    show_effect_id(CharEffect::JOBCHANGE);
    stats.change_job(job_id);
}

void Player::set_seat(nullable_ptr<const Seat> seat)
{
    if (seat) {
        set_position(seat->get_pos());
        set_state(Char::SIT);
    }
}

void Player::set_ladder(nullable_ptr<const Ladder> ldr)
{
    ladder = ldr;

    if (ladder) {
        ph_obj.set_x(ldr->get_x());
        ph_obj.hspeed = 0.0;
        ph_obj.vspeed = 0.0;
        ph_obj.fh_layer = 7;
        set_state(ldr->is_ladder() ? Char::LADDER : Char::ROPE);
        set_direction(false);
    }
}

float Player::get_walk_force() const
{
    return 0.05f
           + 0.11f * static_cast<float>(stats.get_total(Equipstat::SPEED))
                 / 100;
}

float Player::get_jump_force() const
{
    return 1.0f
           + 3.5f * static_cast<float>(stats.get_total(Equipstat::JUMP)) / 100;
}

float Player::get_climb_force() const
{
    return static_cast<float>(stats.get_total(Equipstat::SPEED)) / 100;
}

float Player::get_fly_force() const
{
    return 0.25f;
}

bool Player::is_underwater() const
{
    return underwater;
}

bool Player::is_key_down(KeyAction::Id action) const
{
    return keys_down.count(action) ? keys_down.at(action) : false;
}

CharStats& Player::get_stats()
{
    return stats;
}

const CharStats& Player::get_stats() const
{
    return stats;
}

Inventory& Player::get_inventory()
{
    return inventory;
}

const Inventory& Player::get_inventory() const
{
    return inventory;
}

Skillbook& Player::get_skills()
{
    return skillbook;
}

Questlog& Player::get_quests()
{
    return questlog;
}

Telerock& Player::get_telerock()
{
    return telerock;
}

Monsterbook& Player::get_monsterbook()
{
    return monsterbook;
}

nullable_ptr<const Ladder> Player::get_ladder() const
{
    return ladder;
}
} // namespace jrc

```

`Character/Player.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Gameplay/Combat/Attack.h"
#include "../Gameplay/Combat/Skill.h"
#include "../Gameplay/MapleMap/Layer.h"
#include "../Gameplay/MapleMap/MapInfo.h"
#include "../Gameplay/Movement.h"
#include "../Gameplay/Physics/Physics.h"
#include "../Gameplay/Playable.h"
#include "../Util/Randomizer.h"
#include "ActiveBuffs.h"
#include "Buff.h"
#include "Char.h"
#include "CharStats.h"
#include "Inventory/Inventory.h"
#include "Look/CharLook.h"
#include "MonsterBook.h"
#include "PassiveBuffs.h"
#include "QuestLog.h"
#include "SkillBook.h"
#include "TeleRock.h"

#include <unordered_map>

namespace jrc
{
class Player : public Playable, public Char
{
public:
    //! Construct a player object from the given character entry.
    Player(const CharEntry& entry);
    Player();

    //! Draw the player.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    //! Overload of `draw` that is inherited from `Char`.
    void draw(double viewx, double viewy, float alpha) const override;
    //! Update the player's animation, physics and states.
    std::int8_t update(const Physics& physics) override;
    //! Set flipped ignore if attacking.
    void set_direction(bool flipped) override;
    //! Set state ignore if attacking.
    void set_state(State stance) override;

    //! Respawn the player at the given position.
    void respawn(Point<std::int16_t> position, bool underwater);
    //! Sends a Keyaction to the player's state, to apply forces, change the
    //! state and other behaviour.
    void send_action(KeyAction::Id action, bool pressed) override;
    //! Recalculates the total stats from base stats, inventories and skills.
    void recalc_stats(bool equip_changed);
    //! Change the equipment at the specified slot and recalculate stats.
    void change_equip(std::int16_t slot);
    //! Use the item from the player's inventory with the given id.
    void use_item(std::int32_t itemid);

    //! Return if the player is attacking.
    bool is_attacking() const;
    //! Return whether the player can attack or not.
    bool can_attack() const;
    //! Return whether the player can use a skill or not.
    SpecialMove::ForbidReason can_use(const SpecialMove& move) const;
    //! Create an attack struct using the player's stats.
    Attack prepare_attack(bool skill) const;

    //! Execute a rush movement.
    void rush(double target_x);

    //! Check whether the player is invincible.
    bool is_invincible() const override;
    //! Handle an attack to the player.
    MobAttackResult damage(const MobAttack& attack);

    //! Apply a buff to the player.
    void give_buff(Buff buff);
    //! Cancel a buff.
    void cancel_buff(Buffstat::Id stat);
    //! Return whether the buff is active.
    bool has_buff(Buffstat::Id stat) const;

    //! Change a skill.
    void change_skill(std::int32_t skill_id,
                      std::int32_t level,
                      std::int32_t master_level,
                      std::int64_t expiration);
    //! Put a skill on cooldown.
    void add_cooldown(std::int32_t skill_id, std::int32_t cool_time);
    //! Check if a skill is on cooldown.
    bool has_cooldown(std::int32_t skill_id) const;

    //! Change the player's level, display the levelup effect.
    void change_level(std::uint16_t level);
    //! Change the player's job, display the job change effect.
    void change_job(std::uint16_t job_id);

    //! Return the character's level.
    std::uint16_t get_level() const override;
    //! Return the character's level of a skill.
    std::int32_t get_skill_level(std::int32_t skill_id) const override;
    //! Return the character's attacking speed.
    std::int8_t get_integer_attack_speed() const override;

    //! Returns the current walking force, calculated from the total ES_SPEED
    //! stat.
    float get_walk_force() const;
    //! Returns the current jumping force, calculated from the total ES_JUMP
    //! stat.
    float get_jump_force() const;
    //! Returns the climbing force, calculated from the total ES_SPEED stat.
    float get_climb_force() const;
    //! Returns the flying force.
    float get_fly_force() const;

    //! Return whether the player is underwater.
    bool is_underwater() const;
    //! Returns if a Keyaction is currently active.
    bool is_key_down(KeyAction::Id action) const;
    //! Return a pointer to the ladder the player is on.
    nullable_ptr<const Ladder> get_ladder() const;

    //! Change players position to the seat's position and stance to Char::SIT.
    void set_seat(nullable_ptr<const Seat> seat);
    //! Change players xpos to the ladder x and change stance to Char::LADDER
    //! or Char::ROPE.
    void set_ladder(nullable_ptr<const Ladder> ladder);

    //! Obtain a reference to the player's stats.
    CharStats& get_stats();
    //! Obtain a reference to the player's stats.
    const CharStats& get_stats() const;
    //! Obtain a reference to the player's inventory.
    Inventory& get_inventory();
    //! Obtain a reference to the player's inventory.
    const Inventory& get_inventory() const;
    //! Obtain a reference to the player's skills.
    Skillbook& get_skills();
    //! Obtain a reference to the player's questlog.
    Questlog& get_quests();
    //! Obtain a reference to the player's telerock locations.
    Telerock& get_telerock();
    //! Obtain a reference to the player's monsterbook.
    Monsterbook& get_monsterbook();

private:
    CharStats stats;
    Inventory inventory;
    Skillbook skillbook;
    Questlog questlog;
    Telerock telerock;
    Monsterbook monsterbook;

    EnumMap<Buffstat::Id, Buff> buffs;
    ActiveBuffs active_buffs;
    PassiveBuffs passive_buffs;

    std::unordered_map<std::int32_t, std::int32_t> cooldowns;

    std::unordered_map<KeyAction::Id, bool> keys_down;

    Movement last_move;

    nullable_ptr<const Ladder> ladder;
    bool underwater;
};
} // namespace jrc

```

`Character/PlayerStates.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "PlayerStates.h"

#include "../Audio/Audio.h"

namespace jrc
{
//! Base class.
void PlayerState::play_jumpsound() const
{
    Sound(Sound::JUMP).play();
}

//! Null state.
void PlayerNullState::update_state(Player& player) const
{
    Char::State state;
    if (player.get_phobj().on_ground) {
        if (player.is_key_down(KeyAction::LEFT)) {
            state = Char::WALK;
            player.set_direction(false);
        } else if (player.is_key_down(KeyAction::RIGHT)) {
            state = Char::WALK;
            player.set_direction(true);
        } else if (player.is_key_down(KeyAction::DOWN)) {
            state = Char::PRONE;
        } else {
            state = Char::STAND;
        }
    } else {
        nullable_ptr<const Ladder> ladder = player.get_ladder();
        if (ladder) {
            state = ladder->is_ladder() ? Char::LADDER : Char::ROPE;
        } else {
            state = Char::FALL;
        }
    }

    player.get_phobj().clear_flags();

    player.set_state(state);
}

//! Standing.
void PlayerStandState::initialize(Player& player) const
{
    player.get_phobj().type = PhysicsObject::NORMAL;
}

void PlayerStandState::send_action(Player& player,
                                   KeyAction::Id ka,
                                   bool down) const
{
    if (player.is_attacking()) {
        return;
    }

    if (down) {
        switch (ka) {
        case KeyAction::LEFT:
            player.set_direction(false);
            player.set_state(Char::WALK);
            break;
        case KeyAction::RIGHT:
            player.set_direction(true);
            player.set_state(Char::WALK);
            break;
        case KeyAction::JUMP:
            play_jumpsound();
            player.get_phobj().v_force = -player.get_jump_force();
            break;
        case KeyAction::DOWN:
            player.set_state(Char::PRONE);
            break;
        default:
            break;
        }
    }
}

void PlayerStandState::update(Player& player) const
{
    if (!player.get_phobj().enable_jd) {
        player.get_phobj().set_flag(PhysicsObject::CHECK_BELOW);
    }
}

void PlayerStandState::update_state(Player& player) const
{
    if (!player.get_phobj().on_ground) {
        player.set_state(Char::FALL);
    }
}

//! Walking.
void PlayerWalkState::initialize(Player& player) const
{
    player.get_phobj().type = PhysicsObject::NORMAL;
}

void PlayerWalkState::send_action(Player& player,
                                  KeyAction::Id ka,
                                  bool down) const
{
    if (player.is_attacking()) {
        return;
    }

    if (down) {
        switch (ka) {
        case KeyAction::LEFT:
            player.set_direction(false);
            break;
        case KeyAction::RIGHT:
            player.set_direction(true);
            break;
        case KeyAction::JUMP:
            play_jumpsound();
            player.get_phobj().v_force = -player.get_jump_force();
            break;
        case KeyAction::DOWN:
            player.set_state(Char::PRONE);
            break;
        default:
            break;
        }
    }
}

bool PlayerWalkState::haswalkinput(const Player& player) const
{
    return player.is_key_down(KeyAction::LEFT)
           || player.is_key_down(KeyAction::RIGHT);
}

void PlayerWalkState::update(Player& player) const
{
    if (!player.is_attacking() && haswalkinput(player)) {
        player.get_phobj().h_force += player.get_flip()
                                          ? player.get_walk_force()
                                          : -player.get_walk_force();
    }

    if (!player.get_phobj().enable_jd) {
        player.get_phobj().set_flag(PhysicsObject::CHECK_BELOW);
    }
}

void PlayerWalkState::update_state(Player& player) const
{
    if (player.get_phobj().on_ground) {
        if (!haswalkinput(player) || player.get_phobj().hspeed == 0.0f) {
            player.set_state(Char::STAND);
        }
    } else {
        player.set_state(Char::FALL);
    }
}

//! Falling.
void PlayerFallState::initialize(Player& player) const
{
    player.get_phobj().type = PhysicsObject::NORMAL;
}

void PlayerFallState::send_action(Player& player,
                                  KeyAction::Id ka,
                                  bool down) const
{
    if (down) {
        switch (ka) {
        case KeyAction::LEFT:
            player.set_direction(false);
            break;
        case KeyAction::RIGHT:
            player.set_direction(true);
            break;
        default:
            break;
        }
    }
}

void PlayerFallState::update(Player& player) const
{
    auto& hspeed = player.get_phobj().hspeed;
    if (player.is_key_down(KeyAction::LEFT) && hspeed > 0.0) {
        hspeed -= 0.025;
        if (hspeed < 0.0) {
            hspeed = 0.0;
        }
    } else if (player.is_key_down(KeyAction::RIGHT) && hspeed < 0.0) {
        hspeed += 0.025;
        if (hspeed > 0.0) {
            hspeed = 0.0;
        }
    }
}

void PlayerFallState::update_state(Player& player) const
{
    if (player.get_phobj().on_ground) {
        if (player.is_key_down(KeyAction::LEFT)) {
            player.set_direction(false);
            player.set_state(Char::WALK);
        } else if (player.is_key_down(KeyAction::RIGHT)) {
            player.set_direction(true);
            player.set_state(Char::WALK);
        } else {
            player.set_state(Char::STAND);
        }
    } else if (player.is_underwater()) {
        player.set_state(Char::SWIM);
    }
}

//! Prone.
void PlayerProneState::send_action(Player& player,
                                   KeyAction::Id ka,
                                   bool down) const
{
    if (down) {
        switch (ka) {
        case KeyAction::JUMP:
            if (player.get_phobj().enable_jd
                && player.is_key_down(KeyAction::DOWN)) {
                play_jumpsound();
                player.get_phobj().y = player.get_phobj().ground_below;
                player.set_state(Char::FALL);
            } else {
                player.set_state(Char::STAND);
                player.send_action(ka, down);
            }
            break;
        default:
            break;
        }
    } else {
        switch (ka) {
        case KeyAction::DOWN:
            player.set_state(Char::STAND);
            break;
        default:
            break;
        }
    }
}

void PlayerProneState::update(Player& player) const
{
    if (!player.get_phobj().enable_jd) {
        player.get_phobj().set_flag(PhysicsObject::CHECK_BELOW);
    }
}

//! Sitting.
void PlayerSitState::send_action(Player& player,
                                 KeyAction::Id ka,
                                 bool down) const
{
    if (down) {
        switch (ka) {
        case KeyAction::LEFT:
            player.set_direction(false);
            player.set_state(Char::WALK);
            break;
        case KeyAction::RIGHT:
            player.set_direction(true);
            player.set_state(Char::WALK);
            break;
        case KeyAction::JUMP:
            play_jumpsound();
            player.set_state(Char::STAND);
            break;
        case KeyAction::UP:
            player.set_state(Char::SWIM);
            break;
        default:
            break;
        }
    }
}

//! Flying.
void PlayerFlyState::initialize(Player& player) const
{
    player.get_phobj().type = player.is_underwater() ? PhysicsObject::SWIMMING
                                                     : PhysicsObject::FLYING;
}

void PlayerFlyState::send_action(Player& player,
                                 KeyAction::Id ka,
                                 bool down) const
{
    if (down) {
        switch (ka) {
        case KeyAction::LEFT:
            player.set_direction(false);
            break;
        case KeyAction::RIGHT:
            player.set_direction(true);
            break;
        default:
            break;
        }
    }
}

void PlayerFlyState::update(Player& player) const
{
    if (player.is_attacking()) {
        return;
    }

    if (player.is_key_down(KeyAction::LEFT)) {
        player.get_phobj().h_force = -player.get_fly_force();
    } else if (player.is_key_down(KeyAction::RIGHT)) {
        player.get_phobj().h_force = player.get_fly_force();
    }

    if (player.is_key_down(KeyAction::UP)) {
        player.get_phobj().v_force = -player.get_fly_force();
    } else if (player.is_key_down(KeyAction::DOWN)) {
        player.get_phobj().v_force = player.get_fly_force();
    }
}

void PlayerFlyState::update_state(Player& player) const
{
    if (player.get_phobj().on_ground && player.is_underwater()) {
        Char::State state;
        if (player.is_key_down(KeyAction::LEFT)) {
            state = Char::WALK;
            player.set_direction(false);
        } else if (player.is_key_down(KeyAction::RIGHT)) {
            state = Char::WALK;
            player.set_direction(true);
        } else if (player.is_key_down(KeyAction::DOWN)) {
            state = Char::PRONE;
        } else {
            state = Char::STAND;
        }
        player.set_state(state);
    }
}

//! Climbing.
void PlayerClimbState::initialize(Player& player) const
{
    player.get_phobj().type = PhysicsObject::FIXATED;
}

void PlayerClimbState::send_action(Player& player,
                                   KeyAction::Id ka,
                                   bool down) const
{
    if (down) {
        switch (ka) {
        case KeyAction::JUMP:
            if (player.is_key_down(KeyAction::LEFT)) {
                play_jumpsound();
                player.set_direction(false);
                player.get_phobj().hspeed = -player.get_walk_force() * 8.0;
                player.get_phobj().vspeed = -player.get_jump_force() / 1.5;
                cancel_ladder(player);
            } else if (player.is_key_down(KeyAction::RIGHT)) {
                play_jumpsound();
                player.set_direction(true);
                player.get_phobj().hspeed = player.get_walk_force() * 8.0;
                player.get_phobj().vspeed = -player.get_jump_force() / 1.5;
                cancel_ladder(player);
            }
            break;
        default:
            break;
        }
    }
}

void PlayerClimbState::update(Player& player) const
{
    if (player.is_key_down(KeyAction::UP)) {
        player.get_phobj().vspeed = -player.get_climb_force();
    } else if (player.is_key_down(KeyAction::DOWN)) {
        player.get_phobj().vspeed = player.get_climb_force();
    } else {
        player.get_phobj().vspeed = 0.0;
    }
}

void PlayerClimbState::update_state(Player& player) const
{
    std::int16_t y = player.get_phobj().get_y();
    bool downwards = player.is_key_down(KeyAction::DOWN);
    auto ladder = player.get_ladder();
    if (ladder && ladder->fell_off(y, downwards)) {
        cancel_ladder(player);
    }
}

void PlayerClimbState::cancel_ladder(Player& player) const
{
    player.set_state(Char::FALL);
    player.set_ladder(nullptr);
}
} // namespace jrc

```

`Character/PlayerStates.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Player.h"

namespace jrc
{
//! Base class for player states
class PlayerState
{
public:
    virtual ~PlayerState() = default;

    //! Actions taken when transitioning into the state.
    virtual void initialize(Player& player) const = 0;
    //! How to handle inputs while in the state.
    virtual void
    send_action(Player& player, KeyAction::Id action, bool pressed) const = 0;
    //! Actions taken in the player's update method, before physics are
    //! applied.
    virtual void update(Player& player) const = 0;
    //! Transition into a new state after physics have been applied.
    virtual void update_state(Player& player) const = 0;

protected:
    //! Play the jumping sound.
    void play_jumpsound() const;
};

//! The initial state, determines which state the player should be in.
class PlayerNullState : public PlayerState
{
public:
    PlayerNullState() = default;

    void initialize(Player&) const override
    {
    }
    void send_action(Player&, KeyAction::Id, bool) const override
    {
    }
    void update(Player&) const override
    {
    }

    void update_state(Player& player) const override;
};

//! The standing state.
class PlayerStandState : public PlayerState
{
public:
    void initialize(Player& player) const override;
    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player&) const override;
    void update_state(Player& player) const override;
};

//! The walking state.
class PlayerWalkState : public PlayerState
{
    void initialize(Player& player) const override;
    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player& player) const override;
    void update_state(Player& player) const override;

private:
    bool haswalkinput(const Player& player) const;
};

//! The falling state.
class PlayerFallState : public PlayerState
{
public:
    void initialize(Player& player) const override;

    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player& player) const override;

    void update_state(Player& player) const override;
};

//! The prone state (lying down).
class PlayerProneState : public PlayerState
{
public:
    void initialize(Player&) const override
    {
    }

    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player&) const override;

    void update_state(Player&) const override
    {
    }
};

//! The sitting state.
class PlayerSitState : public PlayerState
{
public:
    void initialize(Player&) const override
    {
    }

    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;

    void update(Player&) const override
    {
    }
    void update_state(Player&) const override
    {
    }
};

//! The flying or swimming state.
class PlayerFlyState : public PlayerState
{
    void initialize(Player& player) const override;
    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player& player) const override;
    void update_state(Player& player) const override;
};

//! The climbing state.
class PlayerClimbState : public PlayerState
{
public:
    void initialize(Player& player) const override;
    void
    send_action(Player& player, KeyAction::Id ka, bool down) const override;
    void update(Player& player) const override;
    void update_state(Player& player) const override;

private:
    void cancel_ladder(Player& player) const;
};
} // namespace jrc

```

`Character/QuestLog.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "QuestLog.h"

namespace jrc
{
void Questlog::add_started(std::int16_t qid, std::string&& qdata)
{
    started[qid] = std::move(qdata);
}

void Questlog::add_in_progress(std::int16_t qid,
                               std::int16_t qidl,
                               std::string&& qdata)
{
    in_progress[qid] = {qidl, std::move(qdata)};
}

void Questlog::add_completed(std::int16_t qid, std::int64_t time)
{
    completed[qid] = time;
}

bool Questlog::is_started(std::int16_t qid)
{
    return started.count(qid) > 0;
}

std::int16_t Questlog::get_last_started()
{
    auto qend = started.end();
    --qend;
    return qend->first;
}
} // namespace jrc

```

`Character/QuestLog.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "boost/container/flat_map.hpp"

#include <cstdint>
#include <string>
#include <unordered_map>

namespace jrc
{
//! Class that stores information on the questlog of an individual character.
class Questlog
{
public:
    void add_started(std::int16_t, std::string&& quest_data);
    void add_in_progress(std::int16_t, std::int16_t, std::string&& quest_data);
    void add_completed(std::int16_t, std::int64_t);
    bool is_started(std::int16_t);
    std::int16_t get_last_started();

private:
    boost::container::flat_map<std::int16_t, std::string> started;
    std::unordered_map<std::int16_t, std::pair<std::int16_t, std::string>>
        in_progress;
    std::unordered_map<std::int16_t, std::int64_t> completed;
};
} // namespace jrc

```

`Character/SkillBook.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillBook.h"

#include "../Data/SkillData.h"

namespace jrc
{
void Skillbook::set_skill(std::int32_t id,
                          std::int32_t level,
                          std::int32_t master_level,
                          std::int64_t expire) noexcept
{
    skill_entries[id] = {level, master_level, expire};
}

bool Skillbook::has_skill(std::int32_t id) const noexcept
{
    return skill_entries.count(id) > 0;
}

std::int32_t Skillbook::get_level(std::int32_t id) const noexcept
{
    auto iter = skill_entries.find(id);
    if (iter == skill_entries.end()) {
        return 0;
    }

    return iter->second.level;
}

std::int32_t Skillbook::get_master_level(std::int32_t id) const noexcept
{
    auto iter = skill_entries.find(id);
    if (iter == skill_entries.end()) {
        return 0;
    }

    return iter->second.master_level;
}

std::int64_t Skillbook::get_expiration(std::int32_t id) const noexcept
{
    auto iter = skill_entries.find(id);
    if (iter == skill_entries.end()) {
        return 0;
    }

    return iter->second.expiration;
}

const std::unordered_map<int32_t, Skillbook::SkillEntry>&
Skillbook::get_entries() const noexcept
{
    return skill_entries;
}

boost::container::flat_map<std::int32_t, std::int32_t>
Skillbook::collect_passives() const noexcept
{
    boost::container::flat_map<std::int32_t, std::int32_t> passives;
    for (auto [id, entry] : skill_entries) {
        if (SkillData::get(id).is_passive()) {
            passives.emplace(id, entry.level);
        }
    }
    return passives;
}
} // namespace jrc

```

`Character/SkillBook.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "boost/container/flat_map.hpp"

#include <cstdint>
#include <unordered_map>

namespace jrc
{
//! Class that stores all information about the skills of an individual
//! character.
class Skillbook
{
public:
    struct SkillEntry {
        std::int32_t level;
        std::int32_t master_level;
        std::int64_t expiration;
    };

    void set_skill(std::int32_t id,
                   std::int32_t level,
                   std::int32_t master_level,
                   std::int64_t expiration) noexcept;

    [[nodiscard]] bool has_skill(std::int32_t id) const noexcept;
    [[nodiscard]] std::int32_t get_level(std::int32_t id) const noexcept;
    [[nodiscard]] std::int32_t get_master_level(std::int32_t id) const
        noexcept;
    [[nodiscard]] std::int64_t get_expiration(std::int32_t id) const noexcept;

    [[nodiscard]] const std::unordered_map<std::int32_t, SkillEntry>&
    get_entries() const noexcept;

    //! Return ID and level of all passive skills.
    //!
    //! An ordered map is used so that lower passive skills don't override
    //! higher ones.
    [[nodiscard]] boost::container::flat_map<std::int32_t, std::int32_t>
    collect_passives() const noexcept;

private:
    std::unordered_map<std::int32_t, SkillEntry> skill_entries;
};
} // namespace jrc

```

`Character/SkillId.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once

namespace jrc::SkillId
{
enum {
    // Beginner
    FOLLOW_THE_LEAD = 8,
    ANGEL_BLESSING = 12,
    THREE_SNAILS = 1000,
    HEAL = 1001,
    FEATHER = 1002,
    LEGENDARY_SPIRIT = 1003,
    MONSTER_RIDER = 1004,
    ECHO_OF_THE_HERO = 1005,

    // Swordman
    IMPROVED_HP_RECOVERY = 1000000,
    IMPROVED_MAX_HP = 1000001,
    IMPROVED_LADDER_RECOVERY = 1000002,
    IRON_BODY = 1001003,
    POWER_STRIKE = 1001004,
    SLASH_BLAST = 1001005,

    // Fighter
    SWORD_MASTERY_FIGHTER = 1100000,
    AXE_MASTERY = 1100001,
    SWORD_FA_FIGHTER = 1100002,
    AXE_FA = 1100003,
    SWORD_BOOSTER_FIGHTER = 1101004,
    AXE_BOOSTER = 1101005,
    RAGE = 1101006,
    POWER_GUARD_FIGHTER = 1101007,

    // Crusader
    IMPROVED_MP_RECOVERY_CRUSADER = 1110000,
    SHIELD_MASTERY = 1110001,
    SWORD_PANIC = 1111003,
    AXE_PANIC = 1111004,
    SWORD_COMA = 1111005,
    AXE_COMA = 1111005,
    SHOUT = 1111008,

    // Hero
    ADVANCED_COMBO_ATTACK = 1120003,
    ACHILLES_HERO = 1120004,
    GUARDIAN_HERO = 1120005,
    RUSH_HERO = 1121006,
    BRANDISH = 1121008,

    // Page
    SWORD_MASTERY_PAGE = 1200000,
    BW_MASTERY = 1200001,
    SWORD_FA_PAGE = 1200002,
    BW_FA = 1200003,
    SWORD_BOOSTER_PAGE = 1201004,
    BW_BOOSTER = 1201005,
    THREATEN = 1201006,
    POWER_GUARD_PAGE = 1201007,

    // White Knight
    CHARGE = 1211002,

    // Paladin
    ACHILLES_PALADIN = 1220005,
    GUARDIAN_PALADIN = 1220006,
    ADVANCED_CHARGE = 1220010,
    RUSH_PALADIN = 1221007,
    BLAST = 1221009,
    HEAVENS_HAMMER = 1221011,

    // Spearman
    SPEAR_MASTERY = 1300000,
    PA_MASTERY = 1300001,
    SPEAR_FA = 1300002,
    PA_FA = 1300003,
    SPEAR_BOOSTER = 1301004,
    PA_BOOSTER = 1301005,
    IRON_WILL = 1301006,
    HYPER_BODY = 1301007,

    // Dragon Knight
    DRAGON_BUSTER = 1311001,
    DRAGON_FURY = 1311002,
    PA_BUSTER = 1311003,
    PA_FURY = 1311004,
    SACRIFICE = 1311005,
    DRAGONS_ROAR = 1311006,

    // Dark Knight
    ACHILLES_DK = 1320005,
    BERSERK = 1320006,
    BEHOLDER_HEAL = 1320008,
    BEHOLDER_BUFF = 1320009,
    RUSH_DK = 1321003,
    BEHOLDER = 1321007,

    // Magician
    IMPROVE_HP_RECOVERY = 2000000,
    IMPROVE_MAX_HP = 2000001,
    MAGIC_GUARD = 2001002,
    MAGIC_ARMOR = 2001003,
    ENERGY_BOLT = 2001004,
    MAGIC_CLAW = 2001005,

    // F/P Mage
    MP_EATER_FP = 2100000,
    MEDITATION_FP = 2101001,
    TELEPORT_FP = 2101002,
    SLOW_FP = 2101003,
    FIRE_ARROW = 2101004,
    POISON_BREATH = 2101005,

    // F/P Archmage
    PARTIAL_RESISTANCE_FP = 2110000,
    ELEMENT_AMPLIFICATION_FP = 2110001,
    EXPLOSION = 2111002,
    POISON_MIST = 2111003,
    SEAL_FP = 2111004,
    SPELL_BOOSTER_FP = 2111005,
    ELEMENT_COMPOSITION_FP = 2111006,

    //
    FIRE_DEMON = 2121003,
    ELQUINES = 2121005,
    PARALYZE = 2121006,
    METEOR_SHOWER = 2121007,

    // I/L Mage
    IL_TELEPORT = 2201002,

    // Priest
    PRIEST_TELEPORT = 2301001,

    // Hermit
    AVENGER = 4111005,
    FLASH_JUMP = 4111006,

    // Night Lord
    TRIPLE_THROW = 4121007,

    // Bandit
    MESO_EXPLOSION = 4211006
};
} // namespace jrc::SkillId

```

`Character/StatCaps.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"

#include <cstdint>

namespace jrc
{
//! Externalising this for easier configurability.
constexpr const EnumMap<Equipstat::Id, std::int32_t> EQSTAT_CAPS{
    {Equipstat::STR, 999},
    {Equipstat::DEX, 999},
    {Equipstat::INT, 999},
    {Equipstat::LUK, 999},
    {Equipstat::HP, 30000},
    {Equipstat::MP, 30000},
    {Equipstat::WATK, 999},
    {Equipstat::MAGIC, 2000},
    {Equipstat::WDEF, 999},
    {Equipstat::MDEF, 999},
    {Equipstat::ACC, 999},
    {Equipstat::AVOID, 999},
    {Equipstat::HANDS, 999},
    {Equipstat::SPEED, 140},
    {Equipstat::JUMP, 123}};
} // namespace jrc

```

`Character/TeleRock.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "TeleRock.h"

namespace jrc
{
void Telerock::addlocation(std::int32_t mapid)
{
    locations.push_back(mapid);
}

void Telerock::addviplocation(std::int32_t mapid)
{
    viplocations.push_back(mapid);
}
} // namespace jrc

```

`Character/TeleRock.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <vector>

namespace jrc
{
// Saved locations for the 'teleport rock' and 'VIP teleport rock' cash items.
class Telerock
{
public:
    void addlocation(std::int32_t);
    void addviplocation(std::int32_t);

private:
    std::vector<std::int32_t> locations;
    std::vector<std::int32_t> viplocations;
};
} // namespace jrc

```

`Configuration.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Configuration.h"

#include "Console.h"
#include "IO/UITypes/UIGameSettings.h"
#include "Util/Str.h"

#include <exception>
#include <fstream>
#include <iomanip>
#include <string_view>
#include <type_traits>

namespace jrc
{
Configuration::Configuration() noexcept
{
    try {
        load();
    } catch (const std::exception& ex) {
        Console::get().print(str::concat(
            "[settings.toml parse error] ", std::string_view{ex.what()}, '.'));
    }
}

Configuration::~Configuration() noexcept
{
    save();
}

void Configuration::load() noexcept(false)
{
    auto settings = cpptoml::parse_file("settings.toml");

    auto network_table = settings->get_table("network");
    auto video_table = settings->get_table("video");
    auto fonts_table = settings->get_table("fonts");
    auto audio_table = settings->get_table("audio");
    auto account_table = settings->get_table("account");
    auto ui_table = settings->get_table("ui");

    if (network_table) {
        if (auto ip = network_table->get_as<std::string>("ip"); ip) {
            network.ip = *ip;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:network.ip\" found; using "
                "default.");
        }

        if (auto port = network_table->get_as<std::uint16_t>("port"); port) {
            network.port = *port;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:network.port\" found; "
                "using default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:network\" found; using default.");
    }

    if (video_table) {
        if (auto fullscreen = video_table->get_as<bool>("fullscreen");
            fullscreen) {
            video.fullscreen = *fullscreen;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:video.fullscreen\" found; "
                "using default.");
        }

        if (auto vsync = video_table->get_as<bool>("vsync"); vsync) {
            video.vsync = *vsync;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:video.vsync\" found; "
                "using default.");
        }

        if (auto low_quality = video_table->get_as<bool>("low_quality");
            low_quality) {
            video.low_quality = *low_quality;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:video.low_quality\" "
                "found; using default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:video\" found; using default.");
    }

    if (fonts_table) {
        if (auto normal = fonts_table->get_as<std::string>("normal"); normal) {
            fonts.normal = *normal;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:fonts.normal\" found; "
                "using default.");
        }

        if (auto bold = fonts_table->get_as<std::string>("bold"); bold) {
            fonts.bold = *bold;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:fonts.bold\" found; "
                "using default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:fonts\" found; using default.");
    }

    if (audio_table) {
        if (auto sound_effects = audio_table->get_as<bool>("sound_effects");
            sound_effects) {
            audio.sound_effects = *sound_effects;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:audio.sound_effects\" "
                "found; using default.");
        }

        if (auto music = audio_table->get_as<bool>("music"); music) {
            audio.music = *music;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:audio.music\" "
                "found; using default.");
        }

        auto volume = audio_table->get_table("volume");

        if (volume) {
            if (auto sound_effects
                = volume->get_as<std::uint8_t>("sound_effects");
                sound_effects) {
                audio.volume.sound_effects = *sound_effects;
            } else {
                Console::get().print(
                    "No valid value for "
                    "\"settings.toml:audio.volume.sound_effects\" found; "
                    "using default.");
            }

            if (auto music = volume->get_as<std::uint8_t>("music"); music) {
                audio.volume.music = *music;
            } else {
                Console::get().print(
                    "No valid value for \"settings.toml:audio.volume.music\" "
                    "found; using default.");
            }
        } else {
            Console::get().print(
                "No valid table \"settings.toml:audio.volume\" found; using "
                "default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:audio\" found; using default.");
    }

    if (account_table) {
        if (auto save_login = account_table->get_as<bool>("save_login");
            save_login) {
            account.save_login = *save_login;
        } else {
            Console::get().print("No valid value for "
                                 "\"settings.toml:account.save_login\" found; "
                                 "using default.");
        }

        if (auto account_name
            = account_table->get_as<std::string>("account_name");
            account_name) {
            account.account_name = *account_name;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:account.account_name\" "
                "found; using default.");
        }

        if (auto world = account_table->get_as<std::uint8_t>("world"); world) {
            account.world = *world;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:account.world\" found; "
                "using default.");
        }

        if (auto channel = account_table->get_as<std::uint8_t>("channel");
            channel) {
            account.channel = *channel;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:account.channel\" found; "
                "using default.");
        }

        if (auto character = account_table->get_as<std::uint8_t>("character");
            character) {
            account.character = *character;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:account.character\" "
                "found; using default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:account\" found; using default.");
    }

    if (ui_table) {
        if (auto hp_alert = ui_table->get_as<std::uint8_t>("hp_alert");
            hp_alert) {
            ui.hp_alert = *hp_alert;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:ui.hp_alert\" found; "
                "using default.");
        }

        if (auto mp_alert = ui_table->get_as<std::uint8_t>("mp_alert");
            mp_alert) {
            ui.mp_alert = *mp_alert;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:ui.mp_alert\" found; "
                "using default.");
        }

        if (auto shake_screen = ui_table->get_as<bool>("shake_screen");
            shake_screen) {
            ui.shake_screen = *shake_screen;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:ui.shake_screen\" found; "
                "using default.");
        }

        if (auto simple_minimap = ui_table->get_as<bool>("simple_minimap");
            simple_minimap) {
            ui.simple_minimap = *simple_minimap;
        } else {
            Console::get().print(
                "No valid value for \"settings.toml:ui.simple_minimap\" "
                "found; using default.");
        }

        auto position = ui_table->get_table("position");

        if (position) {
            if (auto key_config
                = position->get_array_of<std::int64_t>("key_config");
                key_config) {
                if (auto key_config_point
                    = vec_to_point<std::int16_t>(*key_config);
                    key_config_point) {
                    ui.position.key_config = *key_config_point;
                } else {
                    Console::get().print("No valid value for "
                                         "\"settings.toml:ui.position.key_"
                                         "config\" found; using default.");
                }
            } else {
                Console::get().print(
                    "No valid value for "
                    "\"settings.toml:ui.position.key_config\" "
                    "found; using default.");
            }

            if (auto stats = position->get_array_of<std::int64_t>("stats");
                stats) {
                if (auto stats_point = vec_to_point<std::int16_t>(*stats);
                    stats_point) {
                    ui.position.stats = *stats_point;
                } else {
                    Console::get().print("No valid value for "
                                         "\"settings.toml:ui.position.stats\" "
                                         "found; using default.");
                }
            } else {
                Console::get().print(
                    "No valid value for \"settings.toml:ui.position.stats\" "
                    "found; using default.");
            }

            if (auto inventory
                = position->get_array_of<std::int64_t>("inventory");
                inventory) {
                if (auto inventory_point
                    = vec_to_point<std::int16_t>(*inventory);
                    inventory_point) {
                    ui.position.inventory = *inventory_point;
                } else {
                    Console::get().print(
                        "No valid value for "
                        "\"settings.toml:ui.position.inventory\" "
                        "found; using default.");
                }
            } else {
                Console::get().print("No valid value for "
                                     "\"settings.toml:ui.position.inventory\" "
                                     "found; using default.");
            }

            if (auto equip_inventory
                = position->get_array_of<std::int64_t>("equip_inventory");
                equip_inventory) {
                if (auto equip_inventory_point
                    = vec_to_point<std::int16_t>(*equip_inventory);
                    equip_inventory_point) {
                    ui.position.equip_inventory = *equip_inventory_point;
                } else {
                    Console::get().print(
                        "No valid value for "
                        "\"settings.toml:ui.position.equip_inventory\" "
                        "found; using default.");
                }
            } else {
                Console::get().print(
                    "No valid value for "
                    "\"settings.toml:ui.position.equip_inventory\" "
                    "found; using default.");
            }

            if (auto skillbook
                = position->get_array_of<std::int64_t>("skillbook");
                skillbook) {
                if (auto skillbook_point
                    = vec_to_point<std::int16_t>(*skillbook);
                    skillbook_point) {
                    ui.position.skillbook = *skillbook_point;
                } else {
                    Console::get().print(
                        "No valid value for "
                        "\"settings.toml:ui.position.skillbook\" "
                        "found; using default.");
                }
            } else {
                Console::get().print("No valid value for "
                                     "\"settings.toml:ui.position.skillbook\" "
                                     "found; using default.");
            }

            if (auto change_channel
                = position->get_array_of<std::int64_t>("change_channel");
                change_channel) {
                if (auto change_channel_point
                    = vec_to_point<std::int16_t>(*change_channel);
                    change_channel_point) {
                    ui.position.change_channel = *change_channel_point;
                } else {
                    Console::get().print("No valid value for "
                                         "\"settings.toml:ui.position.change_"
                                         "channel\" found; using default.");
                }
            } else {
                Console::get().print("No valid value for "
                                     "\"settings.toml:ui.position.change_"
                                     "channel\" found; using default.");
            }

            if (auto game_settings
                = position->get_array_of<std::int64_t>("game_settings");
                game_settings) {
                if (auto game_settings_point
                    = vec_to_point<std::int16_t>(*game_settings);
                    game_settings_point) {
                    ui.position.game_settings = *game_settings_point;
                } else {
                    Console::get().print("No valid value for "
                                         "\"settings.toml:ui.position.game_"
                                         "settings\" found; using default.");
                }
            } else {
                Console::get().print("No valid value for "
                                     "\"settings.toml:ui.position.game_"
                                     "settings\" found; using default.");
            }

            if (auto system_settings
                = position->get_array_of<std::int64_t>("system_settings");
                system_settings) {
                if (auto system_settings_point
                    = vec_to_point<std::int16_t>(*system_settings);
                    system_settings_point) {
                    ui.position.system_settings = *system_settings_point;
                } else {
                    Console::get().print("No valid value for "
                                         "\"settings.toml:ui.position.system_"
                                         "settings\" found; using default.");
                }
            } else {
                Console::get().print("No valid value for "
                                     "\"settings.toml:ui.position.system_"
                                     "settings\" found; using default.");
            }
        } else {
            Console::get().print(
                "No valid table \"settings.toml:ui.position\" found; using "
                "default.");
        }
    } else {
        Console::get().print(
            "No valid table \"settings.toml:ui\" found; using default.");
    }

    if (auto character_tables = settings->get_table_array("character");
        character_tables) {
        for (const auto& character_table : *character_tables) {
            Character character;
            std::string name;
            if (auto name_ = character_table->get_as<std::string>("name");
                name_) {
                name = *name_;
            } else {
                Console::get().print("No valid name found for a "
                                     "\"settings.toml:character\"; ignoring.");
                continue;
            }

            if (auto game_settings
                = character_table->get_table("game_settings");
                game_settings) {
                if (auto whispers = game_settings->get_as<bool>("whispers");
                    whispers) {
                    if (*whispers) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::WHISPERS;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::WHISPERS);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "whispers\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto friend_invites
                    = game_settings->get_as<bool>("friend_invites");
                    friend_invites) {
                    if (*friend_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::FRIEND_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::FRIEND_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "friend_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto chat_invites
                    = game_settings->get_as<bool>("chat_invites");
                    chat_invites) {
                    if (*chat_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::CHAT_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::CHAT_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "chat_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto trade_requests
                    = game_settings->get_as<bool>("trade_requests");
                    trade_requests) {
                    if (*trade_requests) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::TRADE_REQUESTS;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::TRADE_REQUESTS);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "trade_requests\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto party_invites
                    = game_settings->get_as<bool>("party_invites");
                    party_invites) {
                    if (*party_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::PARTY_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::PARTY_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "party_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto sidekick_invites
                    = game_settings->get_as<bool>("sidekick_invites");
                    sidekick_invites) {
                    if (*sidekick_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::SIDEKICK_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::SIDEKICK_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "sidekick_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto expedition_invites
                    = game_settings->get_as<bool>("expedition_invites");
                    expedition_invites) {
                    if (*expedition_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::EXPEDITION_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::EXPEDITION_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "expedition_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto guild_chat
                    = game_settings->get_as<bool>("guild_chat");
                    guild_chat) {
                    if (*guild_chat) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::GUILD_CHAT;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::GUILD_CHAT);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "guild_chat\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto guild_invites
                    = game_settings->get_as<bool>("guild_invites");
                    guild_invites) {
                    if (*guild_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::GUILD_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::GUILD_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "guild_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto alliance_chat
                    = game_settings->get_as<bool>("alliance_chat");
                    alliance_chat) {
                    if (*alliance_chat) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::ALLIANCE_CHAT;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::ALLIANCE_CHAT);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "alliance_chat\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto alliance_invites
                    = game_settings->get_as<bool>("alliance_invites");
                    alliance_invites) {
                    if (*alliance_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::ALLIANCE_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::ALLIANCE_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "alliance_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto family_invites
                    = game_settings->get_as<bool>("family_invites");
                    family_invites) {
                    if (*family_invites) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::FAMILY_INVITES;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::FAMILY_INVITES);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "family_invites\" found for \"",
                                    name,
                                    "\"; using default."));
                }

                if (auto follow = game_settings->get_as<bool>("follow");
                    follow) {
                    if (*follow) {
                        character.game_settings.flags
                            |= 1 << UIGameSettings::FOLLOW;
                    } else {
                        character.game_settings.flags
                            &= ~(1 << UIGameSettings::FOLLOW);
                    }
                } else {
                    Console::get().print(
                        str::concat("No valid value "
                                    "\"settings.toml:character.game_settings."
                                    "follow\" found for \"",
                                    name,
                                    "\"; using default."));
                }
            } else {
                Console::get().print(str::concat(
                    "No valid table \"settings.toml:character.game_settings\" "
                    "found for \"",
                    name,
                    "\"; using default."));
            }

            characters.emplace(name, character);
        }
    }
}

void Configuration::save() const noexcept
{
    using namespace std::literals;

    static constexpr const std::string_view OUTPUT_TEMPLATE = u8R"(
# Settings for the LibreMaple client.
#
# LibreMaple client code is © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple
# Team, licensed under the GNU Affero General Public License version 3 or
# higher.

[network]
ip = $
port = $

[video]
fullscreen = $
vsync = $
low_quality = $

[fonts]
normal = $
bold = $

[audio]
sound_effects = $
music = $
    [audio.volume]  # Volumes are in percentages.
    sound_effects = $
    music = $

[account]
save_login = $
account_name = $
world = $
channel = $
character = $

[ui]
hp_alert = $
mp_alert = $
shake_screen = $
simple_minimap = $
    [ui.position]
    key_config = $
    stats = $
    inventory = $
    equip_inventory = $
    skillbook = $
    change_channel = $
    game_settings = $
    system_settings = $)"sv.substr(1);

    std::ofstream settings{"settings.toml"};
    if (!settings || !settings.is_open()) {
        Console::get().print("[settings.toml write error] Could not open "
                             "\"settings.toml\" for writing.");
    }

    std::size_t last_ix = 0;
    std::size_t template_ix = 0;
    std::size_t entry_ix = 0;
    auto write = [&settings](const auto& x) {
        using x_type = std::decay_t<decltype(x)>;

        if constexpr (std::is_same_v<x_type, std::string>) {
            // TODO: Escape special characters.
            settings << std::quoted(x);
        } else if constexpr (std::is_same_v<x_type, bool>) {
            if (x) {
                settings << "true";
            } else {
                settings << "false";
            }
        } else if constexpr (is_point<x_type>::value) {
            settings.put('[');
            settings << x.x() << ", " << x.y();
            settings.put(']');
        } else if constexpr (
            std::is_same_v<
                x_type,
                std::uint8_t> || std::is_same_v<x_type, std::int8_t>) {
            settings << static_cast<int>(x);
        } else {
            settings << x;
        }
    };
    while (template_ix < OUTPUT_TEMPLATE.length()) {
        if (OUTPUT_TEMPLATE[template_ix] == '$') {
            settings << OUTPUT_TEMPLATE.substr(last_ix, template_ix - last_ix);
            ++template_ix;
            last_ix = template_ix;

            switch (entry_ix) {
            case 0:
                write(network.ip);
                break;
            case 1:
                write(network.port);
                break;
            case 2:
                write(video.fullscreen);
                break;
            case 3:
                write(video.vsync);
                break;
            case 4:
                write(video.low_quality);
                break;
            case 5:
                write(fonts.normal);
                break;
            case 6:
                write(fonts.bold);
                break;
            case 7:
                write(audio.sound_effects);
                break;
            case 8:
                write(audio.music);
                break;
            case 9:
                write(audio.volume.sound_effects);
                break;
            case 10:
                write(audio.volume.music);
                break;
            case 11:
                write(account.save_login);
                break;
            case 12:
                write(account.account_name);
                break;
            case 13:
                write(account.world);
                break;
            case 14:
                write(account.channel);
                break;
            case 15:
                write(account.character);
                break;
            case 16:
                write(ui.hp_alert);
                break;
            case 17:
                write(ui.mp_alert);
                break;
            case 18:
                write(ui.shake_screen);
                break;
            case 19:
                write(ui.simple_minimap);
                break;
            case 20:
                write(ui.position.key_config);
                break;
            case 21:
                write(ui.position.stats);
                break;
            case 22:
                write(ui.position.inventory);
                break;
            case 23:
                write(ui.position.equip_inventory);
                break;
            case 24:
                write(ui.position.skillbook);
                break;
            case 25:
                write(ui.position.change_channel);
                break;
            case 26:
                write(ui.position.game_settings);
                break;
            case 27:
                write(ui.position.system_settings);
                break;
            default:
                Console::get().print(
                    "[logic error] Number of `case` statements in "
                    "`Configuration::save()` is incorrect. [0]");
                break;
            }

            ++entry_ix;
        } else {
            ++template_ix;
        }
    }
    settings << OUTPUT_TEMPLATE.substr(last_ix);

    static constexpr const std::string_view CHARACTER_TEMPLATE = u8R"(

[[character]]
name = $
    [character.game_settings]
    whispers = $
    friend_invites = $
    chat_invites = $
    trade_requests = $
    party_invites = $
    sidekick_invites = $
    expedition_invites = $
    guild_chat = $
    guild_invites = $
    alliance_chat = $
    alliance_invites = $
    family_invites = $
    follow = $)";

    for (const auto& [name, ch] : characters) {
        last_ix = 0;
        template_ix = 0;
        entry_ix = 0;
        while (template_ix < CHARACTER_TEMPLATE.length()) {
            if (CHARACTER_TEMPLATE[template_ix] == '$') {
                settings << CHARACTER_TEMPLATE.substr(last_ix,
                                                      template_ix - last_ix);
                ++template_ix;
                last_ix = template_ix;

                switch (entry_ix) {
                case 0:
                    write(name);
                    break;
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    write(static_cast<bool>(ch.game_settings.flags
                                            & 1 << (entry_ix - 1)));
                    break;
                default:
                    Console::get().print(
                        "[logic error] Number of `case` statements in "
                        "`Configuration::save()` is incorrect. [1]");
                    break;
                }

                ++entry_ix;
            } else {
                ++template_ix;
            }
        }
        settings << CHARACTER_TEMPLATE.substr(last_ix);
    }

    settings << '\n';
    settings.flush();
}

Point<std::int16_t> Configuration::get_position_of(PositionOf po) const
    noexcept
{
    switch (po) {
    case PositionOf::KEY_CONFIG:
        return ui.position.key_config;
    case PositionOf::STATS:
        return ui.position.stats;
    case PositionOf::INVENTORY:
        return ui.position.inventory;
    case PositionOf::EQUIP_INVENTORY:
        return ui.position.equip_inventory;
    case PositionOf::SKILLBOOK:
        return ui.position.skillbook;
    case PositionOf::CHANGE_CHANNEL:
        return ui.position.change_channel;
    case PositionOf::GAME_SETTINGS:
        return ui.position.game_settings;
    case PositionOf::SYSTEM_SETTINGS:
        return ui.position.system_settings;
    }

    return {};
}

void Configuration::set_position_of(PositionOf po,
                                    Point<std::int16_t> pos) noexcept
{
    switch (po) {
    case PositionOf::KEY_CONFIG:
        ui.position.key_config = pos;
        break;
    case PositionOf::STATS:
        ui.position.stats = pos;
        break;
    case PositionOf::INVENTORY:
        ui.position.inventory = pos;
        break;
    case PositionOf::EQUIP_INVENTORY:
        ui.position.equip_inventory = pos;
        break;
    case PositionOf::SKILLBOOK:
        ui.position.skillbook = pos;
        break;
    case PositionOf::CHANGE_CHANNEL:
        ui.position.change_channel = pos;
        break;
    case PositionOf::GAME_SETTINGS:
        ui.position.game_settings = pos;
        break;
    case PositionOf::SYSTEM_SETTINGS:
        ui.position.system_settings = pos;
        break;
    }
}

Configuration::Character&
Configuration::get_character(const std::string& name) noexcept
{
    auto [iter, inserted] = characters.try_emplace(name);
    return iter->second;
}
} // namespace jrc

```

`Configuration.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Template/Point.h"
#include "cpptoml.h"

#include <cstdint>
#include <optional>
#include <string>
#include <vector>

namespace jrc
{
//! Manages the "settings.toml" file which contains configurations set by user
//! behavior.
//!
//! The format of this `struct` is in 1:1 correspondence with the format of the
//! "settings.toml".
//!
//! TODO: Almost all of this code can be generated based on the default
//! "settings.toml".
struct Configuration : public Singleton<Configuration> {
    //! Initialize settings using defaults, and then load as much as possible
    //! from "settings.toml".
    Configuration() noexcept;
    //! Automatically save on destruction.
    ~Configuration() noexcept override;

    //! Load all settings. If anything is missing, the defaults are used. Can
    //! be used for reloading.
    //!
    //! **Throws** cpptoml exceptions.
    void load() noexcept(false);
    //! Save the current settings.
    void save() const noexcept;

    enum class PositionOf {
        KEY_CONFIG,
        STATS,
        INVENTORY,
        EQUIP_INVENTORY,
        SKILLBOOK,
        CHANGE_CHANNEL,
        GAME_SETTINGS,
        SYSTEM_SETTINGS
    };

    [[nodiscard]] Point<std::int16_t> get_position_of(PositionOf po) const
        noexcept;
    void set_position_of(PositionOf po, Point<std::int16_t> pos) noexcept;

    //////////////// Data layout ////////////////

    struct Network {
        std::string ip = "127.0.0.1";
        std::uint16_t port = 8484;
    };

    struct Video {
        bool fullscreen = false;
        bool vsync = true;
        bool low_quality = false;
    };

    struct Fonts {
        std::string normal = "../fonts/Roboto/Roboto-Regular.ttf";
        std::string bold = "../fonts/Roboto/Roboto-Bold.ttf";
    };

    struct Audio {
        struct Volume // Volumes are in percentages.
        {
            std::uint8_t sound_effects = 50;
            std::uint8_t music = 50;
        };

        bool sound_effects = true;
        bool music = true;
        Volume volume;
    };

    struct Account {
        std::string account_name = "";
        std::uint8_t world = 0;
        std::uint8_t channel = 0;
        std::uint8_t character = 0;
        bool save_login = false;
    };

    struct Ui {
        struct Position {
            Point<std::int16_t> key_config = {150, 150};
            Point<std::int16_t> stats = {100, 150};
            Point<std::int16_t> inventory = {300, 150};
            Point<std::int16_t> equip_inventory = {250, 150};
            Point<std::int16_t> skillbook = {50, 150};
            Point<std::int16_t> change_channel = {350, 300};
            Point<std::int16_t> game_settings = {450, 250};
            Point<std::int16_t> system_settings = {350, 150};
        };

        std::uint8_t hp_alert = 20;
        std::uint8_t mp_alert = 20;
        bool shake_screen = true;
        bool simple_minimap = false;
        Position position;
    };

    struct Character {
        struct GameSettings {
            //! whispers = true
            //! friend_invites = true
            //! chat_invites = true
            //! trade_requests = true
            //! party_invites = true
            //! sidekick_invites = true
            //! expedition_invites = true
            //! guild_chat = true
            //! guild_invites = true
            //! alliance_chat = true
            //! alliance_invites = true
            //! family_invites = true
            //! follow = true
            std::uint16_t flags = 0b00011111'11111111;
        };

        GameSettings game_settings;
    };

    // Data members are reordered here for compactness (blame the ABI).
    Network network;
    Fonts fonts;
    Account account;
    std::unordered_map<std::string, Character> characters;
    Video video;
    Audio audio;
    Ui ui;

    //! Gets a reference to the character-specific configuration for the
    //! character identified by name. **Inserts a new character with the**
    //! **default configuration if there isn't already one with the specified**
    //! **name**.
    [[nodiscard]] Character& get_character(const std::string& name) noexcept;

private:
    //! Helper function for getting `Point`s out of TOML arrays. Converts the
    //! `std::vector`'s elements into a `Point` of another type by using
    //! `static_cast` on the elements.
    template<typename T>
    static std::optional<Point<T>>
    vec_to_point(const std::vector<std::int64_t>& vec) noexcept
    {
        if (vec.size() != 2) {
            return {};
        }
        return {{static_cast<T>(vec[0]), static_cast<T>(vec[1])}};
    }
};
} // namespace jrc

```

`Console.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Journey.h"
#include "Template/Singleton.h"
#include "Util/Str.h"

#include <iostream>
#include <string>
#include <unordered_set>

namespace jrc
{
#ifndef JOURNEY_PRINT_WARNINGS

class Console : public Singleton<Console>
{
public:
    void print(const char*, std::string_view)
    {
    }

    void print(const char*, const std::exception&)
    {
    }

    void print(const std::string&)
    {
    }
};

#else

class Console : public Singleton<Console>
{
public:
    void print(const char* func, std::string_view msg) noexcept
    {
        print(str::concat(std::string_view{func}, ", ", msg));
    }

    void print(const char* func, const std::exception& ex) noexcept
    {
        print(func, {ex.what()});
    }

    void print(const std::string& str) noexcept
    {
        if (!printed.count(str)) {
            std::cout << str << '\n' << std::flush;
            printed.insert(str);
        }
    }

private:
    std::unordered_set<std::string> printed;
};

#endif
} // namespace jrc

```

`Constants.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>

namespace jrc
{
namespace Constants
{
//! Timestep, e.g. the granularity in which the game advances.
constexpr std::uint16_t TIMESTEP = 8;

//! Initial window and screen width.
constexpr std::int16_t VIEW_WIDTH = 800;

//! Initial window and screen height.
constexpr std::int16_t VIEW_HEIGHT = 600;

//! In-game window and screen width.
constexpr std::int16_t GAME_VIEW_WIDTH = 1024;

//! In-game window and screen height.
constexpr std::int16_t GAME_VIEW_HEIGHT = 768;

//! View y-offset.
constexpr std::int16_t VIEW_Y_OFFSET = 10;
} // namespace Constants
} // namespace jrc

```

`Data/BulletData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "BulletData.h"

#include "nlnx/nx.hpp"

namespace jrc
{
BulletData::BulletData(std::int32_t item_id)
    : item_data(ItemData::get(item_id))
{
    std::string prefix = std::to_string(item_id / 10000);
    prefix.insert(0, "0", 1);
    prefix += ".img";

    std::string str_id = std::to_string(item_id);
    str_id.insert(0, "0", 1);

    nl::node src = nl::nx::item["Consume"][prefix][str_id];

    bullet = src["bullet"];
    watk = src["info"]["incPAD"];
}

bool BulletData::is_valid() const
{
    return item_data.is_valid();
}

BulletData::operator bool() const
{
    return is_valid();
}

std::int16_t BulletData::get_watk() const
{
    return watk;
}

const Animation& BulletData::get_animation() const
{
    return bullet;
}

const ItemData& BulletData::get_item_data() const
{
    return item_data;
}
} // namespace jrc

```

`Data/BulletData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Animation.h"
#include "ItemData.h"

namespace jrc
{
//! Information about a bullet type item.
class BulletData : public Cache<BulletData>
{
public:
    //! Returns wether the bullet was loaded correctly.
    [[nodiscard]] bool is_valid() const;
    //! Returns wether the bullet was loaded correctly.
    explicit operator bool() const;

    //! Returns the watk increase when using this bullet.
    [[nodiscard]] std::int16_t get_watk() const;
    //! Returns the bullet animation.
    [[nodiscard]] const Animation& get_animation() const;
    //! Returns the general item data.
    [[nodiscard]] const ItemData& get_item_data() const;

private:
    //! Allow the cache to use the constructor.
    friend Cache<BulletData>;
    //! Load a bullet from the game files.
    BulletData(std::int32_t item_id);

    const ItemData& item_data;

    Animation bullet;
    std::int16_t watk;
};
} // namespace jrc

```

`Data/EquipData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EquipData.h"

#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
EquipData::EquipData(std::int32_t id) : itemdata(ItemData::get(id))
{
    std::string str_id = std::to_string(id);
    str_id.insert(0, "0", 1);
    str_id += ".img";
    nl::node src = nl::nx::character[itemdata.get_category()][str_id]["info"];

    cash = src["cash"].get_bool();
    tradeblock = src["tradeBlock"].get_bool();
    slots = src["tuc"];
    reqstats[Maplestat::LEVEL] = src["reqLevel"];
    reqstats[Maplestat::JOB] = src["reqJob"];
    reqstats[Maplestat::STR] = src["reqSTR"];
    reqstats[Maplestat::DEX] = src["reqDEX"];
    reqstats[Maplestat::INT] = src["reqINT"];
    reqstats[Maplestat::LUK] = src["reqLUK"];
    defstats[Equipstat::STR] = src["incSTR"];
    defstats[Equipstat::DEX] = src["incDEX"];
    defstats[Equipstat::INT] = src["incINT"];
    defstats[Equipstat::LUK] = src["incLUK"];
    defstats[Equipstat::WATK] = src["incPAD"];
    defstats[Equipstat::WDEF] = src["incPDD"];
    defstats[Equipstat::MAGIC] = src["incMAD"];
    defstats[Equipstat::MDEF] = src["incMDD"];
    defstats[Equipstat::HP] = src["incMHP"];
    defstats[Equipstat::MP] = src["incMMP"];
    defstats[Equipstat::ACC] = src["incACC"];
    defstats[Equipstat::AVOID] = src["incEVA"];
    defstats[Equipstat::HANDS] = src["incHANDS"];
    defstats[Equipstat::SPEED] = src["incSPEED"];
    defstats[Equipstat::JUMP] = src["incJUMP"];

    static constexpr std::size_t NON_WEAPON_TYPES = 15;
    static constexpr std::size_t WEAPON_OFFSET = NON_WEAPON_TYPES + 15;
    static constexpr std::size_t WEAPON_TYPES = 20;
    auto index = static_cast<std::size_t>(id / 10000 - 100);
    if (index < NON_WEAPON_TYPES) {
        static constexpr const char* const types[NON_WEAPON_TYPES]
            = {"HAT",
               "FACE ACCESSORY",
               "EYE ACCESSORY",
               "EARRINGS",
               "TOP",
               "OVERALL",
               "BOTTOM",
               "SHOES",
               "GLOVES",
               "SHIELD",
               "CAPE",
               "RING",
               "PENDANT",
               "BELT",
               "MEDAL"};
        static constexpr Equipslot::Id equipslots[NON_WEAPON_TYPES]
            = {Equipslot::CAP,
               Equipslot::FACEACC,
               Equipslot::EYEACC,
               Equipslot::EARRINGS,
               Equipslot::TOP,
               Equipslot::TOP,
               Equipslot::PANTS,
               Equipslot::SHOES,
               Equipslot::GLOVES,
               Equipslot::SHIELD,
               Equipslot::CAPE,
               Equipslot::RING,
               Equipslot::PENDANT,
               Equipslot::BELT,
               Equipslot::MEDAL};

        type = types[index];
        eqslot = equipslots[index];
    } else if (index >= WEAPON_OFFSET
               && index < WEAPON_OFFSET + WEAPON_TYPES) {
        static constexpr const char* const types[WEAPON_TYPES]
            = {"ONE-HANDED SWORD",
               "ONE-HANDED AXE",
               "ONE-HANDED MACE",
               "DAGGER",
               "",
               "",
               "",
               "WAND",
               "STAFF",
               "",
               "TWO-HANDED SWORD",
               "TWO-HANDED AXE",
               "TWO-HANDED MACE",
               "SPEAR",
               "POLEARM",
               "BOW",
               "CROSSBOW",
               "CLAW",
               "KNUCKLE",
               "GUN"};

        std::size_t weaponindex = index - WEAPON_OFFSET;
        type = types[weaponindex];
        eqslot = Equipslot::WEAPON;
    } else {
        type = "CASH";
        eqslot = Equipslot::NONE;
    }
}

bool EquipData::is_valid() const noexcept
{
    return itemdata.is_valid();
}

EquipData::operator bool() const noexcept
{
    return is_valid();
}

bool EquipData::is_weapon() const noexcept
{
    return eqslot == Equipslot::WEAPON;
}

std::int16_t EquipData::get_req_stat(Maplestat::Id stat) const noexcept
{
    return reqstats[stat];
}

std::int16_t EquipData::get_def_stat(Equipstat::Id stat) const noexcept
{
    return defstats[stat];
}

Equipslot::Id EquipData::get_eq_slot() const noexcept
{
    return eqslot;
}

std::string_view EquipData::get_type() const noexcept
{
    return type;
}

const ItemData& EquipData::get_item_data() const noexcept
{
    return itemdata;
}
} // namespace jrc

```

`Data/EquipData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Character/EquipStat.h"
#include "../Character/Look/EquipSlot.h"
#include "../Character/MapleStat.h"
#include "../Template/EnumMap.h"
#include "ItemData.h"

#include <string_view>

namespace jrc
{
//! Contains information about an equip.
class EquipData : public Cache<EquipData>
{
public:
    //! Returns wether the equip was loaded correctly.
    bool is_valid() const noexcept;
    //! Returns wether the equip was loaded correctly.
    explicit operator bool() const noexcept;

    //! Returns wether this equip has equipslot WEAPON.
    bool is_weapon() const noexcept;
    //! Returns a required base stat.
    std::int16_t get_req_stat(Maplestat::Id stat) const noexcept;
    //! Returns a default stat.
    std::int16_t get_def_stat(Equipstat::Id stat) const noexcept;
    //! Returns the equip slot.
    Equipslot::Id get_eq_slot() const noexcept;
    //! Returns the category name.
    std::string_view get_type() const noexcept;
    //! Returns the general item data (name, price, etc.).
    const ItemData& get_item_data() const noexcept;

private:
    //! Allow the cache to use the constructor.
    friend Cache<EquipData>;
    //! Load an equip from the game files.
    EquipData(std::int32_t id);

    const ItemData& itemdata;

    EnumMap<Maplestat::Id, std::int16_t> reqstats;
    EnumMap<Equipstat::Id, std::int16_t> defstats;
    std::string type;
    Equipslot::Id eqslot;
    std::uint8_t slots;
    bool cash;
    bool tradeblock;
};
} // namespace jrc

```

`Data/ItemData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ItemData.h"

#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
ItemData::ItemData(std::int32_t id) : item_id(id)
{
    nl::node src;
    nl::node strsrc;

    std::string str_prefix = std::to_string(item_id / 10000);
    str_prefix.insert(0, "0", 1);
    str_prefix += ".img";

    std::string str_id = std::to_string(item_id);
    str_id.insert(0, "0", 1);

    switch (item_id / 1000000) {
    case 1:
        category = get_equip_category_str(item_id);
        src = nl::nx::character[category][str_id + ".img"]["info"];
        strsrc = nl::nx::string["Eqp.img"]["Eqp"][category]
                               [std::to_string(item_id)];
        break;
    case 2:
        category = "Consume";
        src = nl::nx::item["Consume"][str_prefix][str_id]["info"];
        strsrc = nl::nx::string["Consume.img"][std::to_string(item_id)];
        break;
    case 3:
        category = "Install";
        src = nl::nx::item["Install"][str_prefix][str_id]["info"];
        strsrc = nl::nx::string["Ins.img"][std::to_string(item_id)];
        break;
    case 4:
        category = "Etc";
        src = nl::nx::item["Etc"][str_prefix][str_id]["info"];
        strsrc = nl::nx::string["Etc.img"]["Etc"][std::to_string(item_id)];
        break;
    case 5:
        category = "Cash";
        src = nl::nx::item["Cash"][str_prefix][str_id]["info"];
        strsrc = nl::nx::string["Cash.img"][std::to_string(item_id)];
        break;
    }

    if (src) {
        icons[false] = src["icon"];
        icons[true] = src["iconRaw"];
        price = src["price"];

        name = strsrc["name"].get_string();
        desc = strsrc["desc"].get_string();

        valid = true;
    } else {
        valid = false;
    }
}

std::string_view ItemData::get_equip_category_str(std::int32_t id) noexcept
{
    static constexpr std::string_view category_names[15] = {"Cap",
                                                            "Accessory",
                                                            "Accessory",
                                                            "Accessory",
                                                            "Coat",
                                                            "Longcoat",
                                                            "Pants",
                                                            "Shoes",
                                                            "Glove",
                                                            "Shield",
                                                            "Cape",
                                                            "Ring",
                                                            "Accessory",
                                                            "Accessory",
                                                            "Accessory"};

    std::size_t index = (static_cast<std::size_t>(id) / 10000ull) - 100ull;
    if (index < 15ull) {
        return category_names[index];
    } else if (index >= 30ull && index <= 70ull) {
        return "Weapon";
    } else {
        return {};
    }
}

bool ItemData::is_valid() const noexcept
{
    return valid;
}

ItemData::operator bool() const noexcept
{
    return is_valid();
}

std::int32_t ItemData::get_id() const noexcept
{
    return item_id;
}

std::int32_t ItemData::get_price() const noexcept
{
    return price;
}

std::string_view ItemData::get_name() const noexcept
{
    return name;
}

std::string_view ItemData::get_desc() const noexcept
{
    return desc;
}

std::string_view ItemData::get_category() const noexcept
{
    return category;
}

const Texture& ItemData::get_icon(bool raw) const noexcept
{
    return icons[raw];
}
} // namespace jrc

```

`Data/ItemData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Texture.h"
#include "../Template/BoolPair.h"
#include "../Template/Cache.h"

namespace jrc
{
//! Class that represents an item loaded from the game's files. Contains all
//! shared data between concrete items.
class ItemData : public Cache<ItemData>
{
public:
    //! Returns wether the item was loaded correctly.
    [[nodiscard]] bool is_valid() const noexcept;
    //! Returns wether the item was loaded correctly.
    explicit operator bool() const noexcept;

    //! Returns the item id.
    [[nodiscard]] std::int32_t get_id() const noexcept;
    //! Returns the item price.
    [[nodiscard]] std::int32_t get_price() const noexcept;
    //! Returns the item's name loaded from the String.nx file.
    [[nodiscard]] std::string_view get_name() const noexcept;
    //! Returns the item's description loaded from the String.nx file.
    [[nodiscard]] std::string_view get_desc() const noexcept;
    //! Return the item category (also the node name).
    [[nodiscard]] std::string_view get_category() const noexcept;
    //! Returns one of the item's icons. For each item there is a 'raw' icon
    //! and an icon with a drop shadow.
    [[nodiscard]] const Texture& get_icon(bool raw) const noexcept;

private:
    //! Allow the cache to use the constructor.
    friend Cache<ItemData>;
    //! Creates an item from the game's Item.nx with the specified id.
    ItemData(std::int32_t itemid);

    [[nodiscard]] static std::string_view
    get_equip_category_str(std::int32_t id) noexcept;

    BoolPair<Texture> icons;
    std::int32_t item_id;
    std::int32_t price;
    std::string name;
    std::string desc;
    std::string category;

    bool valid;
};
} // namespace jrc

```

`Data/JobData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "JobData.h"

#include "../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
JobData::JobData(std::int32_t id)
{
    std::string strid = string_format::extend_id(id, 3);
    nl::node src = nl::nx::skill[strid + ".img"];
    nl::node strsrc = nl::nx::string["Skill.img"][strid];

    icon = src["info"]["icon"];

    name = strsrc["bookName"].get_string();

    for (nl::node sub : src["skill"]) {
        std::int32_t skill_id
            = string_conversion::or_zero<std::int32_t>(sub.name());
        if (skill_id == 0)
            continue;

        skills.push_back(skill_id);
    }
}

const std::vector<std::int32_t>& JobData::get_skills() const
{
    return skills;
}

const std::string& JobData::get_name() const
{
    return name;
}

const Texture& JobData::get_icon() const
{
    return icon;
}
} // namespace jrc

```

`Data/JobData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Texture.h"
#include "../Template/Cache.h"

#include <vector>

namespace jrc
{
// Contains information about a job.
class JobData : public Cache<JobData>
{
public:
    // Return the ids of the skills for this job.
    const std::vector<std::int32_t>& get_skills() const;
    // Return the name of the skill book.
    const std::string& get_name() const;
    // Return the book cover icon.
    const Texture& get_icon() const;

private:
    friend Cache<JobData>;
    JobData(std::int32_t id);

    Texture icon;
    std::vector<std::int32_t> skills;
    std::string name;
};
} // namespace jrc

```

`Data/SkillData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillData.h"

#include "../Character/SkillId.h"
#include "../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <string_view>
#include <unordered_set>

namespace jrc
{
SkillData::SkillData(std::int32_t id)
{
    // Locate sources
    std::string strid = string_format::extend_id(id, 7);
    nl::node src = nl::nx::skill[str::concat(
        std::string_view(strid).substr(0, 3), ".img")]["skill"][strid];
    nl::node strsrc = nl::nx::string["Skill.img"][strid];

    // Load icons
    icons = {src["icon"], src["iconDisabled"], src["iconMouseOver"]};

    // Load strings
    name = strsrc["name"].get_string();
    desc = strsrc["desc"].get_string();

    for (std::int32_t level = 1;
         nl::node sub = strsrc["h" + std::to_string(level)];
         ++level) {
        levels.emplace(level, sub);
    }

    // Load stats
    nl::node levelsrc = src["level"];
    for (auto sub : levelsrc) {
        float damage = (float)sub["damage"] / 100;
        std::int32_t matk = sub["mad"];
        std::int32_t fixdamage = sub["fix_damage"];
        std::int32_t mastery = sub["mastery"];
        std::uint8_t attackcount
            = (std::uint8_t)sub["attackCount"].get_integer(1);
        std::uint8_t mobcount = (std::uint8_t)sub["mobCount"].get_integer(1);
        std::uint8_t bulletcount
            = (std::uint8_t)sub["bulletCount"].get_integer(1);
        std::int16_t bulletcost
            = (std::int16_t)sub["bulletConsume"].get_integer(bulletcount);
        std::int32_t hpcost = sub["hpCon"];
        std::int32_t mpcost = sub["mpCon"];
        float chance = (float)sub["prop"].get_real(100.0) / 100;
        float critical = 0.0f;
        float ignoredef = 0.0f;
        float hrange = (float)sub["range"].get_real(100.0) / 100;
        Rectangle<std::int16_t> range = sub;
        std::int32_t level
            = string_conversion::or_default<std::int32_t>(sub.name(), -1);
        stats.emplace(std::piecewise_construct,
                      std::forward_as_tuple(level),
                      std::forward_as_tuple(damage,
                                            matk,
                                            fixdamage,
                                            mastery,
                                            attackcount,
                                            mobcount,
                                            bulletcount,
                                            bulletcost,
                                            hpcost,
                                            mpcost,
                                            chance,
                                            critical,
                                            ignoredef,
                                            hrange,
                                            range));
    }

    element = src["elemAttr"].get_string();
    reqweapon = Weapon::by_value(100 + (std::int32_t)src["weapon"]);
    masterlevel = static_cast<std::int32_t>(stats.size());
    passive = (id % 10000) / 1000 == 0;
    flags = flags_of(id);
    invisible = src["invisible"].get_bool();
}

std::int32_t SkillData::flags_of(std::int32_t id) const noexcept
{
    static const std::unordered_map<std::int32_t, std::int32_t> skill_flags
        = {// Beginner
           {SkillId::THREE_SNAILS, ATTACK},
           // Warrior
           {SkillId::POWER_STRIKE, ATTACK},
           {SkillId::SLASH_BLAST, ATTACK},
           // Fighter
           // Page
           // Crusader
           {SkillId::SWORD_PANIC, ATTACK},
           {SkillId::AXE_PANIC, ATTACK},
           {SkillId::SWORD_COMA, ATTACK},
           {SkillId::AXE_COMA, ATTACK},
           // Hero
           {SkillId::RUSH_HERO, ATTACK},
           {SkillId::BRANDISH, ATTACK},
           // Page
           // White Knight
           {SkillId::CHARGE, ATTACK},
           // Paladin
           {SkillId::RUSH_PALADIN, ATTACK},
           {SkillId::BLAST, ATTACK},
           {SkillId::HEAVENS_HAMMER, ATTACK},
           // Spearman
           // Dragon Knight
           {SkillId::DRAGON_BUSTER, ATTACK},
           {SkillId::DRAGON_FURY, ATTACK},
           {SkillId::PA_BUSTER, ATTACK},
           {SkillId::PA_FURY, ATTACK},
           {SkillId::SACRIFICE, ATTACK},
           {SkillId::DRAGONS_ROAR, ATTACK},
           // Dark Knight
           {SkillId::RUSH_DK, ATTACK},
           // Mage
           {SkillId::ENERGY_BOLT, ATTACK | RANGED},
           {SkillId::MAGIC_CLAW, ATTACK | RANGED},
           // F/P Mage
           {SkillId::SLOW_FP, ATTACK},
           {SkillId::FIRE_ARROW, ATTACK | RANGED},
           {SkillId::POISON_BREATH, ATTACK | RANGED},
           // F/P ArchMage
           {SkillId::EXPLOSION, ATTACK},
           {SkillId::POISON_BREATH, ATTACK},
           {SkillId::SEAL_FP, ATTACK},
           {SkillId::ELEMENT_COMPOSITION_FP, ATTACK | RANGED},
           //
           {SkillId::FIRE_DEMON, ATTACK},
           {SkillId::PARALYZE, ATTACK | RANGED},
           {SkillId::METEOR_SHOWER, ATTACK}};

    auto iter = skill_flags.find(id);
    if (iter == skill_flags.end()) {
        return NONE;
    }

    return iter->second;
}

bool SkillData::is_passive() const noexcept
{
    return passive;
}

bool SkillData::is_attack() const noexcept
{
    return !passive && (flags & ATTACK);
}

bool SkillData::is_invisible() const noexcept
{
    return invisible;
}

std::int32_t SkillData::get_master_level() const noexcept
{
    return masterlevel;
}

Weapon::Type SkillData::get_required_weapon() const noexcept
{
    return reqweapon;
}

const SkillData::Stats& SkillData::get_stats(std::int32_t level) const noexcept
{
    auto iter = stats.find(level);
    if (iter == stats.end()) {
        static constexpr Stats null_stats{
            0.0f, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0f, 0.0f, 0.0f, 0.0f, {}};
        return null_stats;
    }
    return iter->second;
}

std::string_view SkillData::get_name() const noexcept
{
    return name;
}

std::string_view SkillData::get_desc() const noexcept
{
    return desc;
}

std::string_view SkillData::get_level_desc(std::int32_t level) const noexcept
{
    auto iter = levels.find(level);
    if (iter == levels.end()) {
        static constexpr std::string_view null_level
            = "Missing level description.";
        return null_level;
    } else {
        return iter->second;
    }
}

const Texture& SkillData::get_icon(Icon icon) const noexcept
{
    return icons[icon];
}
} // namespace jrc

```

`Data/SkillData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Character/Inventory/Weapon.h"
#include "../Graphics/Texture.h"
#include "../Template/Cache.h"
#include "../Template/Rectangle.h"

#include <array>
#include <string>
#include <unordered_map>

namespace jrc
{
//! Contains information about a skill.
class SkillData : public Cache<SkillData>
{
public:
    //! The stats of one level.
    struct Stats {
        float damage;
        std::int32_t matk;
        std::int32_t fixdamage;
        std::int32_t mastery;
        std::uint8_t attackcount;
        std::uint8_t mobcount;
        std::uint8_t bulletcount;
        std::int16_t bulletcost;
        std::int32_t hpcost;
        std::int32_t mpcost;
        float chance;
        float critical;
        float ignoredef;
        float hrange;
        Rectangle<std::int16_t> range;

        constexpr Stats(float damage,
                        std::int32_t matk,
                        std::int32_t fixdamage,
                        std::int32_t mastery,
                        std::uint8_t attackcount,
                        std::uint8_t mobcount,
                        std::uint8_t bulletcount,
                        std::int16_t bulletcost,
                        std::int32_t hpcost,
                        std::int32_t mpcost,
                        float chance,
                        float critical,
                        float ignoredef,
                        float hrange,
                        Rectangle<std::int16_t> range) noexcept
            : damage(damage),
              matk(matk),
              fixdamage(fixdamage),
              mastery(mastery),
              attackcount(attackcount),
              mobcount(mobcount),
              bulletcount(bulletcount),
              bulletcost(bulletcost),
              hpcost(hpcost),
              mpcost(mpcost),
              chance(chance),
              critical(critical),
              ignoredef(ignoredef),
              hrange(hrange),
              range(range)
        {
        }
    };

    //! Skill flags, unfortunately these just have to be hardcoded
    enum Flags { NONE = 0x0000, ATTACK = 0x0001, RANGED = 0x0002 };

    //! Icon types
    enum Icon { NORMAL, DISABLED, MOUSEOVER, NUM_ICONS };

    //! Return whether the skill is passive.
    [[nodiscard]] bool is_passive() const noexcept;
    //! Return whether the skill is an attack skill.
    [[nodiscard]] bool is_attack() const noexcept;
    //! Return whether this skill is invisible in the skill book ui.
    [[nodiscard]] bool is_invisible() const noexcept;
    //! Return the default masterlevel.
    [[nodiscard]] std::int32_t get_master_level() const noexcept;
    //! Return the required weapon.
    [[nodiscard]] Weapon::Type get_required_weapon() const noexcept;
    //! Return the stats of one level.
    //!
    //! If there are no stats for that level, a default object is returned.
    [[nodiscard]] const Stats& get_stats(std::int32_t level) const noexcept;

    //! Return the name of the skill.
    [[nodiscard]] std::string_view get_name() const noexcept;
    //! Return the description of the skill.
    [[nodiscard]] std::string_view get_desc() const noexcept;
    //! Return the description of a level.
    //!
    //! If there is no description for this level, a warning message is
    //! returned.
    [[nodiscard]] std::string_view get_level_desc(std::int32_t level) const
        noexcept;

    //! Return one of the skill icons.
    //!
    //! Cannot fail if type is a valid enum.
    [[nodiscard]] const Texture& get_icon(Icon icon) const noexcept;

private:
    //! Allow the cache to use the constructor.
    friend Cache<SkillData>;
    //! Load a skill from the game files.
    SkillData(std::int32_t id);

    //! Get some hardcoded information.
    [[nodiscard]] std::int32_t flags_of(std::int32_t id) const noexcept;

    std::unordered_map<std::int32_t, Stats> stats;
    std::string element;
    Weapon::Type reqweapon;
    std::int32_t masterlevel;
    std::int32_t flags;
    bool passive;
    bool invisible;

    std::string name;
    std::string desc;
    std::unordered_map<std::int32_t, std::string> levels;

    std::array<Texture, NUM_ICONS> icons;
};
} // namespace jrc

```

`Data/WeaponData.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "WeaponData.h"

#include "../Console.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
WeaponData::WeaponData(std::int32_t equip_id)
    : equip_data(EquipData::get(equip_id))
{
    std::int32_t prefix = equip_id / 10000;
    type = Weapon::by_value(prefix);
    two_handed = prefix == Weapon::STAFF
                 || (prefix >= Weapon::SWORD_2H && prefix <= Weapon::POLEARM)
                 || prefix == Weapon::CROSSBOW;

    nl::node src = nl::nx::character["Weapon"][str::concat(
        '0', std::to_string(equip_id), ".img")]["info"];

    attack_speed = static_cast<std::uint8_t>(src["attackSpeed"]);
    attack = static_cast<std::uint8_t>(src["attack"]);

    nl::node soundsrc = nl::nx::sound["Weapon.img"][src["sfx"]];

    if (soundsrc["Attack2"].data_type() == nl::node::type::audio) {
        use_sounds[false] = soundsrc["Attack"];
        use_sounds[true] = soundsrc["Attack2"];
    } else {
        use_sounds[false] = soundsrc["Attack"];
        use_sounds[true] = soundsrc["Attack"];
    }

    afterimage = src["afterImage"].get_string();
}

bool WeaponData::is_valid() const noexcept
{
    return equip_data.is_valid();
}

WeaponData::operator bool() const noexcept
{
    return is_valid();
}

bool WeaponData::is_two_handed() const noexcept
{
    return two_handed;
}

std::uint8_t WeaponData::get_speed() const noexcept
{
    return attack_speed;
}

std::uint8_t WeaponData::get_attack() const noexcept
{
    return attack;
}

std::string_view WeaponData::get_speed_string() const noexcept
{
    switch (attack_speed) {
    case 1:
        return "FAST (1)";
    case 2:
        return "FAST (2)";
    case 3:
        return "FAST (3)";
    case 4:
        return "FAST (4)";
    case 5:
        return "NORMAL (5)";
    case 6:
        return "NORMAL (6)";
    case 7:
        return "SLOW (7)";
    case 8:
        return "SLOW (8)";
    case 9:
        return "SLOW (9)";
    default:
        return {};
    }
}

std::uint8_t WeaponData::get_attack_delay() const noexcept
{
    if (type == Weapon::NONE) {
        return 0;
    } else {
        return 50 - 25 / attack_speed;
    }
}

Weapon::Type WeaponData::get_type() const noexcept
{
    return type;
}

Sound WeaponData::get_use_sound(bool degenerate) const noexcept
{
    return use_sounds[degenerate];
}

std::string_view WeaponData::get_afterimage() const noexcept
{
    return afterimage;
}

const EquipData& WeaponData::get_equip_data() const noexcept
{
    return equip_data;
}
} // namespace jrc

```

`Data/WeaponData.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Audio/Audio.h"
#include "../Character/Inventory/Weapon.h"
#include "../Character/Look/Stance.h"
#include "EquipData.h"

namespace jrc
{
//! Contains information about a weapon.
class WeaponData : public Cache<WeaponData>
{
public:
    //! Returns whether the weapon was loaded correctly.
    [[nodiscard]] bool is_valid() const noexcept;
    //! Returns whether the weapon was loaded correctly.
    explicit operator bool() const noexcept;

    //! Return whether this weapon uses twohanded-stances.
    [[nodiscard]] bool is_two_handed() const noexcept;
    //! Return the attack speed.
    [[nodiscard]] std::uint8_t get_speed() const noexcept;
    //! Return the attack type.
    [[nodiscard]] std::uint8_t get_attack() const noexcept;
    //! Return the speed as displayed in a tooltip.
    [[nodiscard]] std::string_view get_speed_string() const noexcept;
    //! Return the attack delay.
    [[nodiscard]] std::uint8_t get_attack_delay() const noexcept;
    //! Return the weapon type.
    [[nodiscard]] Weapon::Type get_type() const noexcept;
    //! Return the sound to play when attacking.
    [[nodiscard]] Sound get_use_sound(bool degenerate) const noexcept;
    //! Return the name of the afterimage.
    [[nodiscard]] std::string_view get_afterimage() const noexcept;
    //! Return the general equip data.
    [[nodiscard]] const EquipData& get_equip_data() const noexcept;

private:
    //! Allow the cache to use the constructor.
    friend Cache<WeaponData>;
    //! Load a weapon from the game files.
    WeaponData(std::int32_t equip_id);

    const EquipData& equip_data;

    Weapon::Type type;
    bool two_handed;
    std::uint8_t attack_speed;
    std::uint8_t attack;
    BoolPair<Sound> use_sounds;
    std::string afterimage;
};
} // namespace jrc

```

`Error.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once

namespace jrc
{
//! Error codes to be checked after initialisation.
class Error
{
public:
    enum Code {
        NONE,
        CONNECTION,
        NLNX,
        MISSING_FILE,
        WRONG_UI_FILE,
        GLFW,
        GLEW,
        FREETYPE,
        VERTEX_SHADER,
        FRAGMENT_SHADER,
        SHADER_PROGRAM,
        SHADER_VARS,
        WINDOW,
        AUDIO,
        LENGTH
    };

    constexpr Error(Code c) : Error(c, "")
    {
    }

    constexpr Error(Code c, const char* args) : code(c), args(args)
    {
    }

    constexpr operator bool() const
    {
        return code != NONE;
    }

    constexpr bool can_retry() const
    {
        return code == CONNECTION || code == MISSING_FILE;
    }

    constexpr const char* get_message() const
    {
        return messages[code];
    }

    constexpr const char* get_args() const
    {
        return args;
    }

private:
    Code code;
    const char* args;

    static constexpr const char* messages[LENGTH]
        = {"",
           "The server seems to be offline. Please start the server and enter "
           "'retry'.",
           "Could not initialize NLNX. Message: ",
           "Missing a game file: ",
           "UI.nx has wrong version.",
           "Could not initialize GLFW.",
           "Could not initialize GLEW.",
           "Could not initialize FreeType.",
           "Failed to create vertex shader.",
           "Failed to create fragment shader.",
           "Failed to create shader program.",
           "Failed to locate shader variables.",
           "Failed to create window.",
           "Failed to initialize audio."};
};
} // namespace jrc

```

`Gameplay/Camera.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Camera.h"

#include "../Constants.h"

namespace jrc
{
Camera::Camera()
{
    x.set(0.0);
    y.set(0.0);
}

void Camera::update(Point<std::int16_t> position)
{
    double next_x = x.get();
    double hdelta = Constants::GAME_VIEW_WIDTH / 2 - position.x() - next_x;
    if (std::abs(hdelta) >= 5.0) {
        next_x += hdelta * (12.0 / Constants::GAME_VIEW_WIDTH);
    }

    double next_y = y.get();
    double vdelta = Constants::GAME_VIEW_HEIGHT / 2 - position.y() - next_y;
    if (std::abs(vdelta) >= 5.0) {
        next_y += vdelta * (12.0 / Constants::GAME_VIEW_HEIGHT);
    }

    if (next_x > hbounds.first()
        || hbounds.length() < Constants::GAME_VIEW_WIDTH) {
        next_x = hbounds.first();
    } else if (next_x < hbounds.second() + Constants::GAME_VIEW_WIDTH) {
        next_x = hbounds.second() + Constants::GAME_VIEW_WIDTH;
    }

    if (next_y > vbounds.first()
        || vbounds.length() < Constants::GAME_VIEW_HEIGHT) {
        next_y = vbounds.first();
    } else if (next_y < vbounds.second() + Constants::GAME_VIEW_HEIGHT) {
        next_y = vbounds.second() + Constants::GAME_VIEW_HEIGHT;
    }

    x = next_x;
    y = next_y;
}

void Camera::set_position(Point<std::int16_t> position)
{
    x.set(Constants::GAME_VIEW_WIDTH / 2 - position.x());
    y.set(Constants::GAME_VIEW_HEIGHT / 2 - position.y());
}

void Camera::set_view(Range<std::int16_t> mapwalls,
                      Range<std::int16_t> mapborders)
{
    hbounds = -mapwalls;
    vbounds = -mapborders;
}

Point<std::int16_t> Camera::position() const
{
    auto shortx = static_cast<std::int16_t>(std::round(x.get()));
    auto shorty = static_cast<std::int16_t>(std::round(y.get()));
    return {shortx, shorty};
}

Point<std::int16_t> Camera::position(float alpha) const
{
    auto interx = static_cast<std::int16_t>(std::round(x.get(alpha)));
    auto intery = static_cast<std::int16_t>(std::round(y.get(alpha)));
    return {interx, intery};
}

Point<double> Camera::realposition(float alpha) const
{
    return {x.get(alpha), y.get(alpha)};
}
} // namespace jrc

```

`Gameplay/Camera.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Interpolated.h"
#include "../Template/Point.h"
#include "../Template/Range.h"

#include <cstdint>

namespace jrc
{
// View on stage which follows the player object.
class Camera
{
public:
    // Initialize everything to 0, we need the player's spawnpoint first to
    // properly set the position.
    Camera();

    // Update the view with the current player position. (Or any other target)
    void update(Point<std::int16_t> position);
    // Set the position, changing the view immediatly.
    void set_position(Point<std::int16_t> position);
    // Updates the view's boundaries. Determined by map_info or footholds.
    void set_view(Range<std::int16_t> hborders, Range<std::int16_t> vborders);
    // Return the current position.
    Point<std::int16_t> position() const;
    // Return the interpolated position.
    Point<std::int16_t> position(float alpha) const;
    // Return the interpolated position.
    Point<double> realposition(float alpha) const;

private:
    // Movement variables.
    Linear<double> x;
    Linear<double> y;

    // View limits.
    Range<std::int16_t> hbounds;
    Range<std::int16_t> vbounds;
};
} // namespace jrc

```

`Gameplay/Combat/Attack.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Rectangle.h"

#include <cstdint>
#include <unordered_map>
#include <vector>

namespace jrc
{
struct Attack {
    enum Type { CLOSE, RANGED, MAGIC };

    enum DamageType { DMG_WEAPON, DMG_MAGIC, DMG_FIXED };

    Type type = CLOSE;
    DamageType damage_type = DMG_WEAPON;

    double min_damage = 1.0;
    double max_damage = 1.0;
    float critical = 0.0f;
    float ignore_def = 0.0f;
    std::int32_t matk = 0;
    std::int32_t accuracy = 0;
    std::int32_t fix_damage = 0;
    std::int16_t player_level = 1;

    std::uint8_t hit_count = 0;
    std::uint8_t mob_count = 0;
    std::uint8_t speed = 0;
    std::uint8_t stance = 0;
    std::int32_t skill = 0;
    std::int32_t bullet = 0;

    Point<std::int16_t> origin;
    Rectangle<std::int16_t> range;
    float h_range = 1.0f;
    bool to_left = false;
};

struct MobAttack {
    Attack::Type type = Attack::CLOSE;
    std::int32_t watk = 0;
    std::int32_t matk = 0;
    std::int32_t mob_id = 0;
    std::int32_t oid = 0;
    Point<std::int16_t> origin;
    bool valid = false;

    //! Create a mob attack for touch damage.
    MobAttack(std::int32_t watk,
              Point<std::int16_t> origin,
              std::int32_t mobid,
              std::int32_t oid) noexcept
        : watk(watk), mob_id(mobid), oid(oid), origin(origin), valid(true)
    {
    }

    MobAttack() noexcept = default;

    explicit operator bool() const
    {
        return valid;
    }
};

struct MobAttackResult {
    std::int32_t damage;
    std::int32_t mob_id;
    std::int32_t oid;
    std::uint8_t direction;

    MobAttackResult(const MobAttack& attack,
                    std::int32_t damage,
                    std::uint8_t direction)
        : damage(damage),
          mob_id(attack.mob_id),
          oid(attack.oid),
          direction(direction)
    {
    }
};

struct AttackResult {
    AttackResult(const Attack& attack)
        : type(attack.type),
          hit_count(attack.hit_count),
          skill(attack.skill),
          bullet(attack.bullet),
          stance(attack.stance),
          speed(attack.speed),
          to_left(attack.to_left)
    {
    }

    AttackResult() = default;

    Attack::Type type;
    std::int32_t attacker = 0;
    std::uint8_t mob_count = 0;
    std::uint8_t hit_count = 1;
    std::int32_t skill = 0;
    std::int32_t charge = 0;
    std::int32_t bullet = 0;
    std::uint8_t level = 0;
    std::uint8_t display = 0;
    std::uint8_t stance = 0;
    std::uint8_t speed = 0;
    bool to_left = false;
    std::unordered_map<std::int32_t,
                       std::vector<std::pair<std::int32_t, bool>>>
        damage_lines;
    std::int32_t first_oid;
    std::int32_t last_oid;
};

struct AttackUser {
    std::int32_t skill_level;
    std::uint16_t level;
    bool second_weapon;
    bool flip;
};
} // namespace jrc

```

`Gameplay/Combat/Bullet.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Bullet.h"

namespace jrc
{
Bullet::Bullet(Animation a, Point<std::int16_t> origin, bool toleft)
{
    animation = a;

    moveobj.set_x(origin.x() + (toleft ? -30.0 : 30.0));
    moveobj.set_y(origin.y() - 26.0);
}

void Bullet::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> bulletpos = moveobj.get_absolute(viewx, viewy, alpha);
    DrawArgument args(bulletpos, flip);
    animation.draw(args, alpha);
}

bool Bullet::settarget(Point<std::int16_t> target)
{
    double xdelta = target.x() - moveobj.crnt_x();
    double ydelta = target.y() - moveobj.crnt_y();
    if (std::abs(xdelta) < 10.0)
        return true;

    flip = xdelta > 0.0;

    moveobj.hspeed = xdelta / 32;
    if (xdelta > 0.0) {
        if (moveobj.hspeed < 3.0) {
            moveobj.hspeed = 3.0;
        } else if (moveobj.hspeed > 6.0) {
            moveobj.hspeed = 6.0;
        }
    } else if (xdelta < 0.0) {
        if (moveobj.hspeed > -3.0) {
            moveobj.hspeed = -3.0;
        } else if (moveobj.hspeed < -6.0) {
            moveobj.hspeed = -6.0;
        }
    }
    moveobj.vspeed = moveobj.hspeed * ydelta / xdelta;
    return false;
}

bool Bullet::update(Point<std::int16_t> target)
{
    animation.update();
    moveobj.move();

    std::int16_t xdelta = target.x() - moveobj.get_x();
    return moveobj.hspeed > 0.0 ? xdelta < 10 : xdelta > 10;
}
} // namespace jrc

```

`Gameplay/Combat/Bullet.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../../Template/Point.h"
#include "../Physics/PhysicsObject.h"

namespace jrc
{
// Represents a projectile on a map.
class Bullet
{
public:
    Bullet(Animation animation, Point<std::int16_t> origin, bool toleft);

    void draw(double viewx, double viewy, float alpha) const;
    bool settarget(Point<std::int16_t> target);
    bool update(Point<std::int16_t> target);

private:
    Animation animation;
    MovingObject moveobj;
    bool flip;
};
} // namespace jrc

```

`Gameplay/Combat/Combat.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Combat.h"

#include "../../Character/SkillId.h"
#include "../../IO/Messages.h"
#include "../../Net/Packets/AttackAndSkillPackets.h"

namespace jrc
{
Combat::Combat(Player& in_player, MapChars& in_chars, MapMobs& in_mobs)
    : player(in_player),
      chars(in_chars),
      mobs(in_mobs),
      attack_results(
          [&](const AttackResult& attack) { apply_attack(attack); }),
      bullet_effects(
          [&](const BulletEffect& effect) { apply_bullet_effect(effect); }),
      damage_effects(
          [&](const DamageEffect& effect) { apply_damage_effect(effect); })
{
}

void Combat::draw(double viewx, double viewy, float alpha) const
{
    for (auto& be : bullets) {
        be.bullet.draw(viewx, viewy, alpha);
    }
    for (auto& dn : damage_numbers) {
        dn.draw(viewx, viewy, alpha);
    }
}

void Combat::update()
{
    attack_results.update();
    bullet_effects.update();
    damage_effects.update();

    bullets.erase(
        std::remove_if(bullets.begin(),
                       bullets.end(),
                       [this](BulletEffect& mb) {
                           std::int32_t target_oid
                               = mb.damage_effect.target_oid;
                           if (mobs.contains(target_oid)) {
                               mb.target
                                   = mobs.get_mob_head_position(target_oid);
                               bool apply = mb.bullet.update(mb.target);
                               if (apply) {
                                   apply_damage_effect(mb.damage_effect);
                               }
                               return apply;
                           } else {
                               return mb.bullet.update(mb.target);
                           }
                       }),
        bullets.end());

    damage_numbers.erase(
        std::remove_if(damage_numbers.begin(),
                       damage_numbers.end(),
                       [](DamageNumber& dn) { return dn.update(); }),
        damage_numbers.end());
}

void Combat::use_move(std::int32_t move_id)
{
    if (!player.can_attack()) {
        return;
    }

    const SpecialMove& move = get_move(move_id);

    SpecialMove::ForbidReason reason = player.can_use(move);
    Weapon::Type weapontype = player.get_stats().get_weapon_type();
    switch (reason) {
    case SpecialMove::FBR_NONE:
        apply_move(move);
        break;
    default:
        ForbidSkillMessage(reason, weapontype).drop();
        break;
    }
}

void Combat::apply_move(const SpecialMove& move)
{
    if (move.is_attack()) {
        Attack attack = player.prepare_attack(move.is_skill());

        move.apply_useeffects(player);
        move.apply_actions(player, attack.type);

        player.set_afterimage(move.get_id());

        move.apply_stats(player, attack);

        AttackResult result = mobs.send_attack(attack);
        result.attacker = player.get_oid();
        extract_effects(player, move, result);

        apply_use_movement(move);
        apply_result_movement(move, result);

        AttackPacket(result).dispatch();
    } else {
        move.apply_useeffects(player);
        move.apply_actions(player, Attack::MAGIC);

        std::int32_t moveid = move.get_id();
        std::int32_t level = player.get_skills().get_level(moveid);
        UseSkillPacket(moveid, level).dispatch();
    }
}

void Combat::apply_use_movement(const SpecialMove& move)
{
    switch (move.get_id()) {
    case SkillId::TELEPORT_FP:
    case SkillId::IL_TELEPORT:
    case SkillId::PRIEST_TELEPORT:
        break;
    case SkillId::FLASH_JUMP:
        break;
    }
}

void Combat::apply_result_movement(const SpecialMove& move,
                                   const AttackResult& result)
{
    switch (move.get_id()) {
    case SkillId::RUSH_HERO:
    case SkillId::RUSH_PALADIN:
    case SkillId::RUSH_DK:
        apply_rush(result);
        break;
    }
}

void Combat::apply_rush(const AttackResult& result)
{
    if (result.mob_count == 0)
        return;

    Point<std::int16_t> mob_position = mobs.get_mob_position(result.last_oid);
    std::int16_t targetx = mob_position.x();
    player.rush(targetx);
}

void Combat::apply_bullet_effect(const BulletEffect& effect)
{
    bullets.push_back(effect);
    if (bullets.back().bullet.settarget(effect.target)) {
        apply_damage_effect(effect.damage_effect);
        bullets.pop_back();
    }
}

void Combat::apply_damage_effect(const DamageEffect& effect)
{
    Point<std::int16_t> head_position
        = mobs.get_mob_head_position(effect.target_oid);
    damage_numbers.push_back(effect.number);
    damage_numbers.back().set_x(head_position.x());

    const SpecialMove& move = get_move(effect.move_id);
    mobs.apply_damage(
        effect.target_oid, effect.damage, effect.to_left, effect.user, move);
}

void Combat::push_attack(const AttackResult& attack)
{
    attack_results.push(400, attack);
}

void Combat::apply_attack(const AttackResult& attack)
{
    if (nullable_ptr<OtherChar> ouser = chars.get_char(attack.attacker)) {
        OtherChar& user = *ouser;
        user.update_skill(attack.skill, attack.level);
        user.update_speed(attack.speed);

        const SpecialMove& move = get_move(attack.skill);
        move.apply_useeffects(user);

        if (Stance::Id stance = Stance::by_id(attack.stance)) {
            user.attack(stance);
        } else {
            move.apply_actions(user, attack.type);
        }

        user.set_afterimage(attack.skill);

        extract_effects(user, move, attack);
    }
}

void Combat::extract_effects(const Char& user,
                             const SpecialMove& move,
                             const AttackResult& result)
{
    AttackUser attackuser = {user.get_skill_level(move.get_id()),
                             user.get_level(),
                             user.is_two_handed(),
                             !result.to_left};
    if (result.bullet) {
        Bullet bullet{move.get_bullet(user, result.bullet),
                      user.get_position(),
                      result.to_left};

        for (auto& line : result.damage_lines) {
            std::int32_t oid = line.first;
            if (mobs.contains(oid)) {
                std::vector<DamageNumber> numbers
                    = place_numbers(oid, line.second);
                Point<std::int16_t> head = mobs.get_mob_head_position(oid);

                std::size_t i = 0;
                for (auto& number : numbers) {
                    DamageEffect effect{attackuser,
                                        number,
                                        line.second[i].first,
                                        result.to_left,
                                        oid,
                                        move.get_id()};
                    bullet_effects.emplace(user.get_attack_delay(i),
                                           std::move(effect),
                                           bullet,
                                           head);
                    ++i;
                }
            }
        }

        if (result.damage_lines.empty()) {
            std::int16_t xshift = result.to_left ? -400 : 400;
            Point<std::int16_t> target
                = user.get_position() + Point<std::int16_t>(xshift, -26);
            for (std::uint8_t i = 0; i < result.hit_count; ++i) {
                DamageEffect effect{attackuser, {}, 0, false, 0, 0};
                bullet_effects.emplace(user.get_attack_delay(i),
                                       std::move(effect),
                                       bullet,
                                       target);
            }
        }
    } else {
        for (auto& line : result.damage_lines) {
            std::int32_t oid = line.first;
            if (mobs.contains(oid)) {
                std::vector<DamageNumber> numbers
                    = place_numbers(oid, line.second);

                std::size_t i = 0;
                for (auto& number : numbers) {
                    damage_effects.emplace(user.get_attack_delay(i),
                                           attackuser,
                                           number,
                                           line.second[i].first,
                                           result.to_left,
                                           oid,
                                           move.get_id());

                    ++i;
                }
            }
        }
    }
}

std::vector<DamageNumber> Combat::place_numbers(
    std::int32_t oid,
    const std::vector<std::pair<std::int32_t, bool>>& damage_lines)
{
    std::vector<DamageNumber> numbers;
    std::int16_t head = mobs.get_mob_head_position(oid).y();
    for (auto& line : damage_lines) {
        std::int32_t amount = line.first;
        bool critical = line.second;
        DamageNumber::Type type
            = critical ? DamageNumber::CRITICAL : DamageNumber::NORMAL;
        numbers.emplace_back(type, amount, head);

        head -= DamageNumber::row_height(critical);
    }
    return numbers;
}

void Combat::show_buff(std::int32_t cid,
                       std::int32_t skill_id,
                       std::int8_t level)
{
    if (nullable_ptr<OtherChar> ouser = chars.get_char(cid)) {
        OtherChar& user = *ouser;
        user.update_skill(skill_id, level);

        const SpecialMove& move = get_move(skill_id);
        move.apply_useeffects(user);
        move.apply_actions(user, Attack::MAGIC);
    }
}

void Combat::show_player_buff(std::int32_t skill_id)
{
    get_move(skill_id).apply_useeffects(player);
}

const SpecialMove& Combat::get_move(std::int32_t move_id)
{
    if (move_id == 0) {
        return regular_attack;
    }

    auto iter = skills.find(move_id);
    if (iter == skills.end()) {
        iter = skills.emplace(move_id, move_id).first;
    }
    return iter->second;
}
} // namespace jrc

```

`Gameplay/Combat/Combat.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Player.h"
#include "../../Template/TimedQueue.h"
#include "../MapleMap/MapChars.h"
#include "../MapleMap/MapMobs.h"
#include "Attack.h"
#include "RegularAttack.h"
#include "Skill.h"

namespace jrc
{
class Combat
{
public:
    Combat(Player& player, MapChars& chars, MapMobs& mobs);

    //! Draw bullets, damage numbers etc.
    void draw(double viewx, double viewy, float alpha) const;
    //! Poll attacks, damage effects, etc.
    void update();

    //! Make the player use a special move.
    void use_move(std::int32_t move_id);

    //! Add an attack to the attack queue.
    void push_attack(const AttackResult& attack);
    //! Show a buff effect.
    void show_buff(std::int32_t cid, std::int32_t skill_id, std::int8_t level);
    //! Show a buff effect.
    void show_player_buff(std::int32_t skill_id);

private:
    struct DamageEffect {
        AttackUser user;
        DamageNumber number;
        std::int32_t damage;
        bool to_left;
        std::int32_t target_oid;
        std::int32_t move_id;
    };

    struct BulletEffect {
        DamageEffect damage_effect;
        Bullet bullet;
        Point<std::int16_t> target;
    };

    void apply_attack(const AttackResult& attack);
    void apply_move(const SpecialMove& move);
    void apply_use_movement(const SpecialMove& move);
    void apply_result_movement(const SpecialMove& move,
                               const AttackResult& result);
    void apply_rush(const AttackResult& result);
    void apply_bullet_effect(const BulletEffect& effect);
    void apply_damage_effect(const DamageEffect& effect);
    void extract_effects(const Char& user,
                         const SpecialMove& move,
                         const AttackResult& result);
    std::vector<DamageNumber> place_numbers(
        std::int32_t oid,
        const std::vector<std::pair<std::int32_t, bool>>& damage_lines);
    const SpecialMove& get_move(std::int32_t move_id);

    Player& player;
    MapChars& chars;
    MapMobs& mobs;

    std::unordered_map<std::int32_t, Skill> skills;
    RegularAttack regular_attack;

    TimedQueue<AttackResult> attack_results;
    TimedQueue<BulletEffect> bullet_effects;
    TimedQueue<DamageEffect> damage_effects;

    std::vector<BulletEffect> bullets;
    std::vector<DamageNumber> damage_numbers;
};
} // namespace jrc

```

`Gameplay/Combat/DamageNumber.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "DamageNumber.h"

#include "../../Constants.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
DamageNumber::DamageNumber(Type t,
                           std::int32_t damage,
                           std::int16_t starty,
                           std::int16_t x) noexcept
{
    type = t;

    if (damage > 0) {
        miss = false;

        std::string number = std::to_string(damage);
        first_num = number[0];
        if (number.length() > 1) {
            rest_num = number.substr(1);
            multiple = true;
        } else {
            rest_num = "";
            multiple = false;
        }

        std::int16_t total = get_advance(first_num, true);
        for (std::size_t i = 0; i < rest_num.length(); ++i) {
            char c = rest_num[i];
            std::int16_t advance;
            if (i < rest_num.length() - 1) {
                char n = rest_num[i + 1];
                advance = (get_advance(c, false) + get_advance(n, false)) / 2;
            } else {
                advance = get_advance(c, false);
            }
            total += advance;
        }
        shift = total / 2;
    } else {
        shift = charsets[type][true].get_w('M') / static_cast<std::int16_t>(2);
        miss = true;
    }

    move_obj.set_x(x);
    move_obj.set_y(starty);
    move_obj.vspeed = -0.25;
    opacity.set(1.5f);
}

DamageNumber::DamageNumber() noexcept = default;

void DamageNumber::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absolute = move_obj.get_absolute(viewx, viewy, alpha);
    Point<std::int16_t> position = absolute - Point<std::int16_t>{0, shift};
    float interopc = opacity.get(alpha);

    if (miss) {
        charsets[type][true].draw('M', {position, interopc});
    } else {
        charsets[type][false].draw(first_num, {position, interopc});

        if (multiple) {
            std::int16_t first_advance = get_advance(first_num, true);
            position.shift_x(first_advance);

            for (std::size_t i = 0; i < rest_num.length(); ++i) {
                char c = rest_num[i];
                Point<std::int16_t> yshift = {0, i % 2 ? -2 : 2};
                charsets[type][true].draw(c, {position + yshift, interopc});

                std::int16_t advance;
                if (i < rest_num.length() - 1) {
                    char n = rest_num[i + 1];
                    std::int16_t c_advance = get_advance(c, false);
                    std::int16_t n_advance = get_advance(n, false);
                    advance = (c_advance + n_advance) >> 1;
                } else {
                    advance = get_advance(c, false);
                }

                position.shift_x(advance);
            }
        }
    }
}

std::int16_t DamageNumber::get_advance(char c, bool first) const
{
    static constexpr const std::size_t LENGTH = 10;
    static constexpr const std::array<std::int16_t, LENGTH> advances{
        24, 20, 22, 22, 24, 23, 24, 22, 24, 24};

    std::size_t index = static_cast<unsigned char>(c) - 48ull;
    if (index < LENGTH) {
        std::int16_t advance = advances[index];
        switch (type) {
        case CRITICAL:
            if (first) {
                advance += 8;
            } else {
                advance += 4;
            }
            break;
        default:
            if (first) {
                advance += 2;
            }
        }
        return advance;
    } else {
        return 0;
    }
}

void DamageNumber::set_x(std::int16_t head_x)
{
    move_obj.set_x(head_x);
}

bool DamageNumber::update()
{
    move_obj.move();

    static constexpr const float FADE_STEP
        = Constants::TIMESTEP * 1.0f / FADE_TIME;
    opacity -= FADE_STEP;
    return opacity.last() <= 0.0f;
}

std::int16_t DamageNumber::row_height(bool critical)
{
    return critical ? 36 : 30;
}

void DamageNumber::init()
{
    charsets[NORMAL].set(
        false, nl::nx::effect["BasicEff.img"]["NoRed1"], Charset::LEFT);
    charsets[NORMAL].set(
        true, nl::nx::effect["BasicEff.img"]["NoRed0"], Charset::LEFT);
    charsets[CRITICAL].set(
        false, nl::nx::effect["BasicEff.img"]["NoCri1"], Charset::LEFT);
    charsets[CRITICAL].set(
        true, nl::nx::effect["BasicEff.img"]["NoCri0"], Charset::LEFT);
    charsets[TO_PLAYER].set(
        false, nl::nx::effect["BasicEff.img"]["NoViolet1"], Charset::LEFT);
    charsets[TO_PLAYER].set(
        true, nl::nx::effect["BasicEff.img"]["NoViolet0"], Charset::LEFT);
}

std::array<BoolPair<Charset>, DamageNumber::NUM_TYPES> DamageNumber::charsets;
} // namespace jrc

```

`Gameplay/Combat/DamageNumber.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../IO/Components/Charset.h"
#include "../../Template/BoolPair.h"
#include "../../Template/Interpolated.h"
#include "../../Template/Point.h"
#include "../Physics/PhysicsObject.h"

#include <array>

namespace jrc
{
class DamageNumber
{
public:
    static constexpr const std::size_t NUM_TYPES = 3;
    enum Type { NORMAL, CRITICAL, TO_PLAYER };

    DamageNumber(Type type,
                 std::int32_t damage,
                 std::int16_t starty,
                 std::int16_t x = 0) noexcept;
    DamageNumber() noexcept;

    void draw(double viewx, double viewy, float alpha) const;
    void set_x(std::int16_t head_x);
    bool update();

    static std::int16_t row_height(bool critical);
    static void init();

private:
    std::int16_t get_advance(char c, bool first) const;

    static constexpr const std::uint16_t FADE_TIME = 500;

    Type type;
    bool miss;
    bool multiple;
    std::int8_t first_num;
    std::string rest_num;
    std::int16_t shift;
    MovingObject move_obj;
    Linear<float> opacity;

    static std::array<BoolPair<Charset>, NUM_TYPES> charsets;
};
} // namespace jrc

```

`Gameplay/Combat/RegularAttack.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "RegularAttack.h"

namespace jrc
{
void RegularAttack::apply_useeffects(Char&) const
{
}

void RegularAttack::apply_actions(Char& user, Attack::Type type) const
{
    action.apply(user, type);
}

void RegularAttack::apply_stats(const Char& user, Attack& attack) const
{
    attack.damage_type = Attack::DMG_WEAPON;
    attack.skill = 0;
    attack.mob_count = 1;
    attack.hit_count = 1;
    attack.stance = user.get_look().get_stance();
    if (attack.type == Attack::CLOSE) {
        attack.range = user.get_afterimage().get_range();
    }
}

void RegularAttack::apply_hit_effects(const AttackUser&, Mob&) const
{
}

Animation RegularAttack::get_bullet(const Char& user,
                                    std::int32_t bulletid) const
{
    return bullet.get(user, bulletid);
}

bool RegularAttack::is_attack() const
{
    return true;
}

bool RegularAttack::is_skill() const
{
    return false;
}

std::int32_t RegularAttack::get_id() const
{
    return 0;
}

SpecialMove::ForbidReason RegularAttack::can_use(std::int32_t,
                                                 Weapon::Type weapon,
                                                 const Job&,
                                                 std::uint16_t,
                                                 std::uint16_t,
                                                 std::uint16_t bullets) const
{
    switch (weapon) {
    case Weapon::BOW:
    case Weapon::CROSSBOW:
    case Weapon::CLAW:
    case Weapon::GUN:
        return bullets ? FBR_NONE : FBR_BULLETCOST;
    default:
        return FBR_NONE;
    }
}
} // namespace jrc

```

`Gameplay/Combat/RegularAttack.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "SkillAction.h"
#include "SkillBullet.h"
#include "SpecialMove.h"

namespace jrc
{
class RegularAttack : public SpecialMove
{
public:
    void apply_useeffects(Char& user) const override;
    void apply_actions(Char& user, Attack::Type type) const override;
    void apply_stats(const Char& user, Attack& attack) const override;
    void apply_hit_effects(const AttackUser& user, Mob& target) const override;
    Animation get_bullet(const Char& user,
                         std::int32_t bulletid) const override;

    bool is_attack() const override;
    bool is_skill() const override;
    std::int32_t get_id() const override;

    ForbidReason can_use(std::int32_t level,
                         Weapon::Type weapon,
                         const Job& job,
                         std::uint16_t hp,
                         std::uint16_t mp,
                         std::uint16_t bullets) const override;

private:
    RegularAction action;
    RegularBullet bullet;
};
} // namespace jrc

```

`Gameplay/Combat/Skill.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Skill.h"

#include "../../Character/SkillId.h"
#include "../../Data/SkillData.h"
#include "../../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <cstring>

namespace jrc
{
Skill::Skill(std::int32_t id) : skillid(id)
{
    const SkillData& data = SkillData::get(skillid);

    std::string str_id = skillid < 10000000
                             ? string_format::extend_id(skillid, 7)
                             : std::to_string(skillid);
    char img_str_buf[7];
    std::memcpy(img_str_buf, str_id.data(), 3);
    std::memcpy(img_str_buf + 3, ".img", 4);
    nl::node src
        = nl::nx::skill[std::string_view{img_str_buf, 7}]["skill"][str_id];

    projectile = true;
    overregular = false;

    sound = std::make_unique<SingleSkillSound>(str_id);

    bool by_level_effect = src["CharLevel"]["10"]["effect"].size() > 0;
    bool multi_effect = src["effect0"].size() > 0;
    if (by_level_effect) {
        useeffect = std::make_unique<ByLevelUseEffect>(src);
    } else if (multi_effect) {
        useeffect = std::make_unique<MultiUseEffect>(src);
    } else {
        bool is_animation
            = src["effect"]["0"].data_type() == nl::node::type::bitmap;
        bool has_effect1 = src["effect"]["1"].size() > 0;
        if (is_animation) {
            useeffect = std::make_unique<SingleUseEffect>(src);
        } else if (has_effect1) {
            useeffect = std::make_unique<TwoHUseEffect>(src);
        } else {
            switch (skillid) {
            case SkillId::IRON_BODY:
            case SkillId::MAGIC_ARMOR:
                useeffect = std::make_unique<IronBodyUseEffect>();
                break;
            default:
                useeffect = std::make_unique<NoUseEffect>();
            }
        }
    }

    bool bylevelhit = src["CharLevel"]["10"]["hit"].size() > 0;
    bool byskilllevelhit = src["level"]["1"]["hit"].size() > 0;
    bool hashit0 = src["hit"]["0"].size() > 0;
    bool hashit1 = src["hit"]["1"].size() > 0;
    if (bylevelhit) {
        if (hashit0 && hashit1) {
            hiteffect = std::make_unique<ByLevelTwoHHitEffect>(src);
        } else {
            hiteffect = std::make_unique<ByLevelHitEffect>(src);
        }
    } else if (byskilllevelhit) {
        hiteffect = std::make_unique<BySkillLevelHitEffect>(src);
    } else if (hashit0 && hashit1) {
        hiteffect = std::make_unique<TwoHHitEffect>(src);
    } else if (hashit0) {
        hiteffect = std::make_unique<SingleHitEffect>(src);
    } else {
        hiteffect = std::make_unique<NoHitEffect>();
    }

    bool hasaction0 = src["action"]["0"].data_type() == nl::node::type::string;
    bool hasaction1 = src["action"]["1"].data_type() == nl::node::type::string;
    if (hasaction0 && hasaction1) {
        action = std::make_unique<TwoHAction>(src);
    } else if (hasaction0) {
        action = std::make_unique<SingleAction>(src);
    } else if (data.is_attack()) {
        bool bylevel = src["level"]["1"]["action"].data_type()
                       == nl::node::type::string;
        if (bylevel) {
            action = std::make_unique<ByLevelAction>(src, skillid);
        } else {
            action = std::make_unique<RegularAction>();
            overregular = true;
        }
    } else {
        action = std::make_unique<NoAction>();
    }

    bool hasball = src["ball"].size() > 0;
    bool bylevelball = src["level"]["1"]["ball"].size() > 0;
    if (bylevelball) {
        bullet = std::make_unique<BySkillLevelBullet>(src, skillid);
    } else if (hasball) {
        bullet = std::make_unique<SingleBullet>(src);
    } else {
        bullet = std::make_unique<RegularBullet>();
        projectile = false;
    }
}

void Skill::apply_useeffects(Char& user) const
{
    useeffect->apply(user);

    sound->play_use();
}

void Skill::apply_actions(Char& user, Attack::Type type) const
{
    action->apply(user, type);
}

void Skill::apply_stats(const Char& user, Attack& attack) const
{
    attack.skill = skillid;

    std::int32_t level = user.get_skill_level(skillid);
    const SkillData::Stats stats = SkillData::get(skillid).get_stats(level);

    if (stats.fixdamage) {
        attack.fix_damage = stats.fixdamage;
        attack.damage_type = Attack::DMG_FIXED;
    } else if (stats.matk) {
        attack.matk += stats.matk;
        attack.damage_type = Attack::DMG_MAGIC;
    } else {
        attack.min_damage *= stats.damage;
        attack.max_damage *= stats.damage;
        attack.damage_type = Attack::DMG_WEAPON;
    }
    attack.critical += stats.critical;
    attack.ignore_def += stats.ignoredef;
    attack.mob_count = stats.mobcount;
    attack.h_range = stats.hrange;

    switch (attack.type) {
    case Attack::RANGED:
        attack.hit_count = stats.bulletcount;
        break;
    default:
        attack.hit_count = stats.attackcount;
    }

    if (!stats.range.empty())
        attack.range = stats.range;

    if (projectile && !attack.bullet) {
        switch (skillid) {
        case SkillId::THREE_SNAILS:
            switch (level) {
            case 1:
                attack.bullet = 4000019;
                break;
            case 2:
                attack.bullet = 4000000;
                break;
            case 3:
                attack.bullet = 4000016;
                break;
            }
            break;
        default:
            attack.bullet = skillid;
        }
    }

    if (overregular) {
        attack.stance = user.get_look().get_stance();
        if (attack.type == Attack::CLOSE && !projectile) {
            attack.range = user.get_afterimage().get_range();
        }
    }
}

void Skill::apply_hit_effects(const AttackUser& user, Mob& target) const
{
    hiteffect->apply(user, target);

    sound->play_hit();
}

Animation Skill::get_bullet(const Char& user, std::int32_t bulletid) const
{
    return bullet->get(user, bulletid);
}

bool Skill::is_attack() const
{
    return SkillData::get(skillid).is_attack();
}

bool Skill::is_skill() const
{
    return true;
}

std::int32_t Skill::get_id() const
{
    return skillid;
}

SpecialMove::ForbidReason Skill::can_use(std::int32_t level,
                                         Weapon::Type weapon,
                                         const Job& job,
                                         std::uint16_t hp,
                                         std::uint16_t mp,
                                         std::uint16_t bullets) const
{
    if (level <= 0 || level > SkillData::get(skillid).get_master_level())
        return FBR_OTHER;

    if (!job.can_use(skillid))
        return FBR_OTHER;

    const SkillData::Stats stats = SkillData::get(skillid).get_stats(level);

    if (hp <= stats.hpcost)
        return FBR_HPCOST;

    if (mp < stats.mpcost)
        return FBR_MPCOST;

    Weapon::Type reqweapon = SkillData::get(skillid).get_required_weapon();
    if (weapon != reqweapon && reqweapon != Weapon::NONE) {
        return FBR_WEAPONTYPE;
    }

    switch (weapon) {
    case Weapon::BOW:
    case Weapon::CROSSBOW:
    case Weapon::CLAW:
    case Weapon::GUN:
        return (bullets >= stats.bulletcost) ? FBR_NONE : FBR_BULLETCOST;
    default:
        return FBR_NONE;
    }
}
} // namespace jrc

```

`Gameplay/Combat/Skill.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "SkillAction.h"
#include "SkillBullet.h"
#include "SkillHitEffect.h"
#include "SkillSound.h"
#include "SkillUseEffect.h"
#include "SpecialMove.h"

#include <memory>

namespace jrc
{
// The skill implementation of special move.
class Skill : public SpecialMove
{
public:
    Skill(std::int32_t skillid);

    void apply_useeffects(Char& user) const override;
    void apply_actions(Char& user, Attack::Type type) const override;
    void apply_stats(const Char& user, Attack& attack) const override;
    void apply_hit_effects(const AttackUser& user, Mob& target) const override;
    Animation get_bullet(const Char& user,
                         std::int32_t bulletid) const override;

    bool is_attack() const override;
    bool is_skill() const override;
    std::int32_t get_id() const override;

    ForbidReason can_use(std::int32_t level,
                         Weapon::Type weapon,
                         const Job& job,
                         std::uint16_t hp,
                         std::uint16_t mp,
                         std::uint16_t bullets) const override;

private:
    std::unique_ptr<SkillAction> action;
    std::unique_ptr<SkillBullet> bullet;
    std::unique_ptr<SkillSound> sound;
    std::unique_ptr<SkillUseEffect> useeffect;
    std::unique_ptr<SkillHitEffect> hiteffect;

    std::int32_t skillid;
    bool overregular;
    bool projectile;
};
} // namespace jrc

```

`Gameplay/Combat/SkillAction.cpp`:

```cpp
// Copyright © 2015-2016 Daniel Allendorf                                   //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillAction.h"

#include "../../Util/Misc.h"

namespace jrc
{
void RegularAction::apply(Char& target, Attack::Type atk_type) const
{
    Weapon::Type weapon_type = target.get_weapon_type();
    bool degenerate;
    switch (weapon_type) {
    case Weapon::BOW:
    case Weapon::CROSSBOW:
    case Weapon::CLAW:
    case Weapon::GUN:
        degenerate = atk_type != Attack::RANGED;
        break;
    default:
        degenerate = false;
    }

    target.attack(degenerate);
}

SingleAction::SingleAction(nl::node src)
{
    action = src["action"]["0"].get_string();
}

void SingleAction::apply(Char& target, Attack::Type) const
{
    target.attack(action);
}

TwoHAction::TwoHAction(nl::node src)
{
    actions[false] = src["action"]["0"].get_string();
    actions[true] = src["action"]["1"].get_string();
}

void TwoHAction::apply(Char& target, Attack::Type) const
{
    bool twohanded = target.is_two_handed();
    std::string action = actions[twohanded];

    target.attack(action);
}

ByLevelAction::ByLevelAction(nl::node src, std::int32_t id)
{
    for (auto sub : src["level"]) {
        std::int32_t level
            = string_conversion::or_zero<std::int32_t>(sub.name());
        actions[level] = sub["action"].get_string();
    }

    skillid = id;
}

void ByLevelAction::apply(Char& target, Attack::Type) const
{
    std::int32_t level = target.get_skill_level(skillid);
    auto iter = actions.find(level);
    if (iter != actions.end()) {
        target.attack(iter->second);
    }
}
} // namespace jrc

```

`Gameplay/Combat/SkillAction.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Char.h"
#include "Attack.h"

#include <unordered_map>

namespace jrc
{
class SkillAction
{
public:
    virtual ~SkillAction() = default;

    virtual void apply(Char& target, Attack::Type atype) const = 0;
};

class NoAction : public SkillAction
{
public:
    void apply(Char&, Attack::Type) const override
    {
    }
};

class RegularAction : public SkillAction
{
public:
    void apply(Char& target, Attack::Type atk_type) const override;
};

class SingleAction : public SkillAction
{
public:
    SingleAction(nl::node src);

    void apply(Char& target, Attack::Type atype) const override;

private:
    std::string action;
};

class TwoHAction : public SkillAction
{
public:
    TwoHAction(nl::node src);

    void apply(Char& target, Attack::Type atype) const override;

private:
    BoolPair<std::string> actions;
};

class ByLevelAction : public SkillAction
{
public:
    ByLevelAction(nl::node src, std::int32_t skillid);

    void apply(Char& target, Attack::Type atype) const override;

private:
    std::unordered_map<std::int32_t, std::string> actions;
    std::int32_t skillid;
};
} // namespace jrc

```

`Gameplay/Combat/SkillBullet.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillBullet.h"

#include "../../Data/BulletData.h"
#include "../../Util/Misc.h"

namespace jrc
{
Animation RegularBullet::get(const Char&, std::int32_t bulletid) const
{
    return BulletData::get(bulletid).get_animation();
}

SingleBullet::SingleBullet(nl::node src)
{
    ball = src["ball"];
}

Animation SingleBullet::get(const Char&, std::int32_t) const
{
    return ball.animation;
}

BySkillLevelBullet::BySkillLevelBullet(nl::node src, std::int32_t id)
{
    skillid = id;

    for (auto sub : src["level"]) {
        auto level = string_conversion::or_zero<std::int32_t>(sub.name());
        bullets[level] = sub["ball"];
    }
}

Animation BySkillLevelBullet::get(const Char& user, std::int32_t) const
{
    std::int32_t level = user.get_skill_level(skillid);
    auto iter = bullets.find(level);
    if (iter != bullets.end()) {
        return iter->second.animation;
    } else {
        return {};
    }
}
} // namespace jrc

```

`Gameplay/Combat/SkillBullet.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Char.h"
#include "../../Graphics/Animation.h"

#include <unordered_map>

namespace jrc
{
class SkillBullet
{
public:
    virtual ~SkillBullet() = default;

    virtual Animation get(const Char& user, std::int32_t bulletid) const = 0;

protected:
    struct Ball {
        Animation animation;

        Ball(nl::node src)
        {
            animation = src;
        }

        Ball()
        {
        }
    };
};

class RegularBullet : public SkillBullet
{
public:
    Animation get(const Char& user, std::int32_t bulletid) const override;
};

class SingleBullet : public SkillBullet
{
public:
    SingleBullet(nl::node src);

    Animation get(const Char& user, std::int32_t bulletid) const override;

private:
    Ball ball;
};

class BySkillLevelBullet : public SkillBullet
{
public:
    BySkillLevelBullet(nl::node src, std::int32_t skillid);

    Animation get(const Char& user, std::int32_t bulletid) const override;

private:
    std::unordered_map<std::int32_t, Ball> bullets;
    std::int32_t skillid;
};
} // namespace jrc

```

`Gameplay/Combat/SkillHitEffect.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillHitEffect.h"

#include "../../Util/Misc.h"

namespace jrc
{
SingleHitEffect::SingleHitEffect(nl::node src) : effect(src["hit"]["0"])
{
}

void SingleHitEffect::apply(const AttackUser& user, Mob& target) const
{
    effect.apply(target, user.flip);
}

TwoHHitEffect::TwoHHitEffect(nl::node src)
    : effects(src["hit"]["0"], src["hit"]["1"])
{
}

void TwoHHitEffect::apply(const AttackUser& user, Mob& target) const
{
    effects[user.second_weapon].apply(target, user.flip);
}

ByLevelHitEffect::ByLevelHitEffect(nl::node src)
{
    for (auto sub : src["CharLevel"]) {
        std::uint16_t level
            = string_conversion::or_zero<std::uint16_t>(sub.name());
        effects.emplace(level, sub["hit"]["0"]);
    }
}

void ByLevelHitEffect::apply(const AttackUser& user, Mob& target) const
{
    if (effects.empty()) {
        return;
    }

    auto iter = effects.upper_bound(user.level);
    if (iter != effects.begin()) {
        --iter;
    }

    iter->second.apply(target, user.flip);
}

ByLevelTwoHHitEffect::ByLevelTwoHHitEffect(nl::node src)
{
    for (auto sub : src["CharLevel"]) {
        auto level = string_conversion::or_zero<std::uint16_t>(sub.name());
        effects.emplace(
            std::piecewise_construct,
            std::forward_as_tuple(level),
            std::forward_as_tuple(sub["hit"]["0"], sub["hit"]["1"]));
    }
}

void ByLevelTwoHHitEffect::apply(const AttackUser& user, Mob& target) const
{
    if (effects.empty()) {
        return;
    }

    auto iter = effects.upper_bound(user.level);
    if (iter != effects.begin()) {
        --iter;
    }

    iter->second[user.second_weapon].apply(target, user.flip);
}

BySkillLevelHitEffect::BySkillLevelHitEffect(nl::node src)
{
    for (auto sub : src["level"]) {
        auto level = string_conversion::or_zero<std::int32_t>(sub.name());
        effects.emplace(level, sub["hit"]["0"]);
    }
}

void BySkillLevelHitEffect::apply(const AttackUser& user, Mob& target) const
{
    auto iter = effects.find(user.skill_level);
    if (iter != effects.end()) {
        iter->second.apply(target, user.flip);
    }
}
} // namespace jrc

```

`Gameplay/Combat/SkillHitEffect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/BoolPair.h"
#include "../MapleMap/Mob.h"
#include "Attack.h"
#include "boost/container/flat_map.hpp"

#include <unordered_map>

namespace jrc
{
//! Interface for hit effects, animations applied to a mob for each hit.
class SkillHitEffect
{
public:
    virtual ~SkillHitEffect() = default;

    virtual void apply(const AttackUser& user, Mob& target) const = 0;

protected:
    class Effect
    {
    public:
        Effect(nl::node src)
        {
            animation = src;
            pos = src["pos"];
            z = src["z"];
        }

        void apply(Mob& target, bool flip) const
        {
            target.show_effect(animation, pos, z, flip);
        }

    private:
        Animation animation;
        std::int8_t pos;
        std::int8_t z;
    };
};

//! No animation.
class NoHitEffect : public SkillHitEffect
{
public:
    void apply(const AttackUser&, Mob&) const override
    {
    }
};

//! A single animation.
class SingleHitEffect : public SkillHitEffect
{
public:
    SingleHitEffect(nl::node src);

    void apply(const AttackUser& user, Mob& target) const override;

private:
    Effect effect;
};

//! The animation changes depending on the weapon used.
class TwoHHitEffect : public SkillHitEffect
{
public:
    TwoHHitEffect(nl::node src);

    void apply(const AttackUser& user, Mob& target) const override;

private:
    BoolPair<Effect> effects;
};

//! The animation changes with the character level.
class ByLevelHitEffect : public SkillHitEffect
{
public:
    ByLevelHitEffect(nl::node src);

    void apply(const AttackUser& user, Mob& target) const override;

private:
    boost::container::flat_map<std::uint16_t, Effect> effects;
};

//! The animation changes with the character level and weapon used.
class ByLevelTwoHHitEffect : public SkillHitEffect
{
public:
    ByLevelTwoHHitEffect(nl::node src);

    void apply(const AttackUser& user, Mob& target) const override;

private:
    boost::container::flat_map<std::uint16_t, BoolPair<Effect>> effects;
};

//! The animation changes with the skill level.
class BySkillLevelHitEffect : public SkillHitEffect
{
public:
    BySkillLevelHitEffect(nl::node src);

    void apply(const AttackUser& user, Mob& target) const override;

private:
    std::unordered_map<std::int32_t, Effect> effects;
};
} // namespace jrc

```

`Gameplay/Combat/SkillSound.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillSound.h"

#include "nlnx/nx.hpp"

namespace jrc
{
SingleSkillSound::SingleSkillSound(std::string_view str_id)
{
    nl::node sound_src = nl::nx::sound["Skill.img"][str_id];

    use_sound = sound_src["Use"];
    hit_sound = sound_src["Hit"];
}

void SingleSkillSound::play_use() const
{
    use_sound.play();
}

void SingleSkillSound::play_hit() const
{
    hit_sound.play();
}
} // namespace jrc

```

`Gameplay/Combat/SkillSound.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "../../Audio/Audio.h"

#include <string_view>

namespace jrc
{
//! Interface for skill sound.
class SkillSound
{
public:
    virtual ~SkillSound() = default;

    virtual void play_use() const = 0;
    virtual void play_hit() const = 0;
};

//! No sound.
class NoSkillSound : public SkillSound
{
public:
    void play_use() const override
    {
    }
    void play_hit() const override
    {
    }
};

//! Plays one use and one hit sound.
class SingleSkillSound : public SkillSound
{
public:
    SingleSkillSound(std::string_view str_id);

    void play_use() const override;
    void play_hit() const override;

private:
    Sound use_sound;
    Sound hit_sound;
};
} // namespace jrc

```

`Gameplay/Combat/SkillUseEffect.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillUseEffect.h"

#include "../../Util/Misc.h"

namespace jrc
{
SingleUseEffect::SingleUseEffect(nl::node src) : effect(src["effect"])
{
}

void SingleUseEffect::apply(Char& target) const
{
    effect.apply(target);
}

TwoHUseEffect::TwoHUseEffect(nl::node src)
    : effects(src["effect"]["0"], src["effect"]["1"])
{
}

void TwoHUseEffect::apply(Char& target) const
{
    effects[target.is_two_handed()].apply(target);
}

MultiUseEffect::MultiUseEffect(nl::node src)
{
    std::int8_t no = -1;
    nl::node sub = src["effect"];
    while (sub) {
        effects.push_back(sub);

        ++no;
        sub = src["effect" + std::to_string(no)];
    }
}

void MultiUseEffect::apply(Char& target) const
{
    for (const auto& effect : effects) {
        effect.apply(target);
    }
}

ByLevelUseEffect::ByLevelUseEffect(nl::node src)
{
    for (auto sub : src["CharLevel"]) {
        auto level = string_conversion::or_zero<std::uint16_t>(sub.name());
        effects.emplace(level, sub["effect"]);
    }
}

void ByLevelUseEffect::apply(Char& target) const
{
    if (effects.empty()) {
        return;
    }

    auto iter = effects.upper_bound(target.get_level());
    if (iter != effects.begin()) {
        --iter;
    }

    iter->second.apply(target);
}

void IronBodyUseEffect::apply(Char& target) const
{
    target.show_iron_body();
}
} // namespace jrc

```

`Gameplay/Combat/SkillUseEffect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Char.h"
#include "../../Graphics/Animation.h"
#include "../../Template/BoolPair.h"
#include "boost/container/flat_map.hpp"

#include <unordered_map>
#include <vector>

namespace jrc
{
//! Interface for skill effects.
class SkillUseEffect
{
public:
    virtual ~SkillUseEffect() = default;

    virtual void apply(Char& target) const = 0;

protected:
    class Effect
    {
    public:
        Effect(nl::node src)
        {
            animation = src;
            z = src["z"];
        }

        void apply(Char& target) const
        {
            target.show_attack_effect(animation, z);
        }

    private:
        Animation animation;
        std::int8_t z;
    };
};

//! No animation.
class NoUseEffect : public SkillUseEffect
{
public:
    void apply(Char&) const override
    {
    }
};

//! An effect which displays an animation over the character's position.
class SingleUseEffect : public SkillUseEffect
{
public:
    SingleUseEffect(nl::node src);

    void apply(Char& target) const override;

private:
    Effect effect;
};

//! An effect which displays an animation over the character's position.
//! The effect changes based on whether the character uses a two-handed weapon.
class TwoHUseEffect : public SkillUseEffect
{
public:
    TwoHUseEffect(nl::node src);

    void apply(Char& target) const override;

private:
    BoolPair<Effect> effects;
};

//! An effect which displays multiple animations over the character's position.
class MultiUseEffect : public SkillUseEffect
{
public:
    MultiUseEffect(nl::node src);

    void apply(Char& target) const override;

private:
    std::vector<Effect> effects;
};

//! The animation changes with the character level.
class ByLevelUseEffect : public SkillUseEffect
{
public:
    ByLevelUseEffect(nl::node src);

    void apply(Char& target) const override;

private:
    boost::container::flat_map<std::uint16_t, Effect> effects;
};

//! Use effect for Iron Body.
class IronBodyUseEffect : public SkillUseEffect
{
public:
    void apply(Char& target) const override;
};
} // namespace jrc

```

`Gameplay/Combat/SpecialMove.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Char.h"
#include "../../Character/Job.h"
#include "../MapleMap/Mob.h"
#include "Attack.h"

namespace jrc
{
// Base class for attacks and buffs.
class SpecialMove
{
public:
    enum ForbidReason {
        FBR_NONE,
        FBR_WEAPONTYPE,
        FBR_HPCOST,
        FBR_MPCOST,
        FBR_BULLETCOST,
        FBR_COOLDOWN,
        FBR_OTHER
    };

    virtual ~SpecialMove() = default;

    virtual void apply_useeffects(Char& user) const = 0;
    virtual void apply_actions(Char& user, Attack::Type type) const = 0;
    virtual void apply_stats(const Char& user, Attack& attack) const = 0;
    virtual void apply_hit_effects(const AttackUser& user,
                                   Mob& target) const = 0;
    virtual Animation get_bullet(const Char& user,
                                 std::int32_t bulletid) const = 0;

    virtual bool is_attack() const = 0;
    virtual bool is_skill() const = 0;
    virtual std::int32_t get_id() const = 0;

    virtual ForbidReason can_use(std::int32_t level,
                                 Weapon::Type weapon,
                                 const Job& job,
                                 std::uint16_t hp,
                                 std::uint16_t mp,
                                 std::uint16_t bullets) const = 0;
};
} // namespace jrc

```

`Gameplay/MapleMap/Drop.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Drop.h"

namespace jrc
{
Drop::Drop(std::int32_t id,
           std::int32_t own,
           Point<std::int16_t> start,
           Point<std::int16_t> dst,
           std::int8_t type,
           std::int8_t mode,
           bool pldrp)
    : MapObject(id)
{
    owner = own;
    set_position(start.x(), start.y() - 4);
    dest = dst;
    pickuptype = type;
    playerdrop = pldrp;

    angle.set(0.0f);
    opacity.set(1.0f);
    moved = 0.0f;
    looter = nullptr;

    switch (mode) {
    case 0:
    case 1:
        state = DROPPED;
        basey = static_cast<double>(dest.y() - 4);
        ph_obj.vspeed = -5.0f;
        ph_obj.hspeed = static_cast<double>(dest.x() - start.x()) / 48;
        break;
    case 2:
        state = FLOATING;
        basey = ph_obj.crnt_y();
        ph_obj.type = PhysicsObject::FIXATED;
        break;
    case 3:
        state = PICKEDUP;
        ph_obj.vspeed = -5.0f;
        break;
    }
}

std::int8_t Drop::update(const Physics& physics)
{
    physics.move_object(ph_obj);

    if (state == DROPPED) {
        if (ph_obj.on_ground) {
            ph_obj.hspeed = 0.0;
            ph_obj.type = PhysicsObject::FIXATED;
            state = FLOATING;
            angle.set(0.0f);
            set_position(dest.x(), dest.y() - 4);
        } else {
            static const float SPINSTEP = 0.2f;
            angle += SPINSTEP;
        }
    }

    if (state == FLOATING) {
        ph_obj.y = basey + 5.0f + (cos(moved) - 1.0f) * 2.5f;
        moved = (moved < 360.0f) ? moved + 0.025f : 0.0f;
    }

    if (state == PICKEDUP) {
        static const std::uint16_t PICKUPTIME = 48;
        static const float OPCSTEP = 1.0f / PICKUPTIME;

        if (looter) {
            double hdelta = looter->x - ph_obj.x;
            ph_obj.hspeed
                = looter->hspeed / 2.0 + (hdelta - 16.0) / PICKUPTIME;
        }

        opacity -= OPCSTEP;
        if (opacity.last() <= OPCSTEP) {
            opacity.set(1.0f);

            MapObject::deactivate();
            return -1;
        }
    }

    return ph_obj.fh_layer;
}

void Drop::expire(std::int8_t type, const PhysicsObject* lt)
{
    switch (type) {
    case 0:
        state = PICKEDUP;
        break;
    case 1:
        deactivate();
        break;
    case 2:
        angle.set(0.0f);
        state = PICKEDUP;
        looter = lt;
        ph_obj.vspeed = -4.5f;
        ph_obj.type = PhysicsObject::NORMAL;
        break;
    }
}

Rectangle<std::int16_t> Drop::bounds() const
{
    auto lt = get_position();
    auto rb = lt + Point<std::int16_t>(32, 32);
    return Rectangle<std::int16_t>(lt, rb);
}
} // namespace jrc

```

`Gameplay/MapleMap/Drop.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Interpolated.h"
#include "../../Template/Rectangle.h"
#include "MapObject.h"

namespace jrc
{
class Drop : public MapObject
{
public:
    virtual std::int8_t update(const Physics& physics) override;

    void init(std::int8_t);
    void expire(std::int8_t, const PhysicsObject*);

    Rectangle<std::int16_t> bounds() const;

protected:
    Drop(std::int32_t oid,
         std::int32_t owner,
         Point<std::int16_t> start,
         Point<std::int16_t> dest,
         std::int8_t type,
         std::int8_t mode,
         bool playerdrop);

    Linear<float> opacity;
    Linear<float> angle;

private:
    enum State { DROPPED, FLOATING, PICKEDUP };

    std::int32_t owner;
    std::int8_t pickuptype;
    bool playerdrop;

    const PhysicsObject* looter;
    State state;

    Point<std::int16_t> dest;
    double basey;
    double moved;
};
} // namespace jrc

```

`Gameplay/MapleMap/ItemDrop.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ItemDrop.h"

namespace jrc
{
ItemDrop::ItemDrop(std::int32_t oid,
                   std::int32_t owner,
                   Point<std::int16_t> start,
                   Point<std::int16_t> dest,
                   std::int8_t type,
                   std::int8_t mode,
                   std::int32_t iid,
                   bool pd,
                   const Texture& icn)
    : Drop(oid, owner, start, dest, type, mode, pd), icon(icn), itemid(iid)
{
}

void ItemDrop::draw(double viewx, double viewy, float alpha) const
{
    if (!active)
        return;

    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);
    icon.draw({angle.get(alpha), absp, opacity.get(alpha)});
}
} // namespace jrc

```

`Gameplay/MapleMap/ItemDrop.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "Drop.h"

namespace jrc
{
class ItemDrop : public Drop
{
public:
    ItemDrop(std::int32_t oid,
             std::int32_t owner,
             Point<std::int16_t> start,
             Point<std::int16_t> dest,
             std::int8_t type,
             std::int8_t mode,
             std::int32_t iid,
             bool playerdrop,
             const Texture& icon);

    void draw(double viewx, double viewy, float alpha) const override;

private:
    const Texture& icon;
    std::int32_t itemid;
};
} // namespace jrc

```

`Gameplay/MapleMap/Layer.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Enumeration.h"

namespace jrc
{
namespace Layer
{
enum Id { ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, LENGTH };

constexpr Enumeration<Id> IDs;
} // namespace Layer
} // namespace jrc

```

`Gameplay/MapleMap/MapBackgrounds.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapBackgrounds.h"

#include "../../Constants.h"
#include "../../Graphics/GraphicsGL.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Background::Background(nl::node src)
{
    nl::node backsrc = nl::nx::map["Back"];
    animated = src["ani"].get_bool();
    animation
        = backsrc[src["bS"] + ".img"][animated ? "ani" : "back"][src["no"]];
    opacity = src["a"];
    flipped = src["f"].get_bool();
    cx = src["cx"];
    cy = src["cy"];
    rx = src["rx"];
    ry = src["ry"];
    moveobj.set_x(src["x"]);
    moveobj.set_y(src["y"]);

    Type type = typebyid(src["type"]);
    settype(type);
}

void Background::settype(Type type)
{
    if (cx == 0) {
        cx = animation.get_dimensions().x();
    }

    if (cy == 0) {
        cy = animation.get_dimensions().y();
    }

    htile = 1;
    vtile = 1;
    switch (type) {
    case HTILED:
    case HMOVEA:
        htile = Constants::GAME_VIEW_WIDTH / cx + 3;
        break;
    case VTILED:
    case VMOVEA:
        vtile = Constants::GAME_VIEW_HEIGHT / cy + 3;
        break;
    case TILED:
    case HMOVEB:
    case VMOVEB:
        htile = Constants::GAME_VIEW_WIDTH / cx + 3;
        vtile = Constants::GAME_VIEW_HEIGHT / cy + 3;
        break;
    default:
        break;
    }

    switch (type) {
    case HMOVEA:
    case HMOVEB:
        moveobj.hspeed = rx / 16;
        break;
    case VMOVEA:
    case VMOVEB:
        moveobj.vspeed = ry / 16;
        break;
    default:
        break;
    }
}

void Background::draw(double viewx, double viewy, float alpha) const
{
    double x;
    if (moveobj.h_mobile()) {
        x = moveobj.get_absolute_x(viewx, alpha);
    } else {
        double shift_x = rx * (WOFFSET - viewx) / 100 + WOFFSET;
        x = moveobj.get_absolute_x(shift_x, alpha);
    }

    double y;
    if (moveobj.v_mobile()) {
        y = moveobj.get_absolute_y(viewy, alpha);
    } else {
        double shift_y = ry * (HOFFSET - viewy) / 100 + HOFFSET;
        y = moveobj.get_absolute_y(shift_y, alpha);
    }

    if (htile > 1) {
        while (x > 0) {
            x -= cx;
        }
        while (x < -cx) {
            x += cx;
        }
    }

    if (vtile > 1) {
        while (y > 0) {
            y -= cy;
        }
        while (y < -cy) {
            y += cy;
        }
    }
    auto ix = static_cast<std::int16_t>(std::round(x));
    auto iy = static_cast<std::int16_t>(std::round(y));

    std::int16_t tw = cx * htile;
    std::int16_t th = cy * vtile;
    for (std::int16_t tx = 0; tx < tw; tx += cx) {
        for (std::int16_t ty = 0; ty < th; ty += cy) {
            animation.draw(DrawArgument(Point<std::int16_t>(ix + tx, iy + ty),
                                        flipped,
                                        opacity / 255),
                           alpha);
        }
    }
}

void Background::update()
{
    moveobj.move();
    animation.update();
}

MapBackgrounds::MapBackgrounds(nl::node src)
{
    std::int16_t no = 0;
    nl::node back = src[std::to_string(no)];
    while (back.size() > 0) {
        bool front = back["front"].get_bool();
        if (front) {
            foregrounds.push_back(back);
        } else {
            backgrounds.push_back(back);
        }

        ++no;
        back = src[std::to_string(no)];
    }

    black = src["0"]["bS"].get_string().empty();
}

MapBackgrounds::MapBackgrounds() = default;

void MapBackgrounds::drawbackgrounds(double viewx,
                                     double viewy,
                                     float alpha) const
{
    if (black) {
        GraphicsGL::get().draw_screen_fill(0.0f, 0.0f, 0.0f, 1.0f);
    }

    for (auto& background : backgrounds) {
        background.draw(viewx, viewy, alpha);
    }
}

void MapBackgrounds::drawforegrounds(double viewx,
                                     double viewy,
                                     float alpha) const
{
    for (auto& foreground : foregrounds) {
        foreground.draw(viewx, viewy, alpha);
    }
}

void MapBackgrounds::update()
{
    for (auto& background : backgrounds) {
        background.update();
    }

    for (auto& foreground : foregrounds) {
        foreground.update();
    }
}
} // namespace jrc

```

`Gameplay/MapleMap/MapBackgrounds.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Console.h"
#include "../../Constants.h"
#include "../../Graphics/Animation.h"
#include "../../Graphics/Texture.h"
#include "../Physics/PhysicsObject.h"

#include <vector>

namespace jrc
{
class Background
{
public:
    Background(nl::node src);

    void draw(double viewx, double viewy, float alpha) const;
    void update();

private:
    enum Type {
        NORMAL,
        HTILED,
        VTILED,
        TILED,
        HMOVEA,
        VMOVEA,
        HMOVEB,
        VMOVEB
    };

    static Type typebyid(std::int32_t id)
    {
        if (id >= NORMAL && id <= VMOVEB) {
            return static_cast<Type>(id);
        }

        Console::get().print("Unhandled background type: "
                             + std::to_string(id));

        return NORMAL;
    }

    void settype(Type type);

    static const std::int16_t WOFFSET = Constants::GAME_VIEW_WIDTH / 2;
    static const std::int16_t HOFFSET
        = Constants::GAME_VIEW_HEIGHT / 2 - Constants::VIEW_Y_OFFSET;

    Animation animation;
    bool animated;
    std::int16_t cx;
    std::int16_t cy;
    double rx;
    double ry;
    std::int16_t htile;
    std::int16_t vtile;
    float opacity;
    bool flipped;

    MovingObject moveobj;
};

class MapBackgrounds
{
public:
    MapBackgrounds(nl::node src);
    MapBackgrounds();

    void drawbackgrounds(double viewx, double viewy, float alpha) const;
    void drawforegrounds(double viewx, double viewy, float alpha) const;
    void update();

private:
    std::vector<Background> backgrounds;
    std::vector<Background> foregrounds;
    bool black;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapChars.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapChars.h"

namespace jrc
{
void MapChars::draw(Layer::Id layer,
                    double viewx,
                    double viewy,
                    float alpha) const
{
    chars.draw(layer, viewx, viewy, alpha);
}

void MapChars::update(const Physics& physics)
{
    for (; !spawns.empty(); spawns.pop()) {
        const CharSpawn& spawn = spawns.front();

        std::int32_t cid = spawn.get_cid();
        nullable_ptr<OtherChar> ochar = get_char(cid);
        if (ochar) {
        } else {
            chars.add(spawn.instantiate());
        }
    }

    chars.update(physics);
}

void MapChars::spawn(CharSpawn&& spawn)
{
    spawns.emplace(std::move(spawn));
}

void MapChars::remove(std::int32_t cid)
{
    chars.remove(cid);
}

void MapChars::clear()
{
    chars.clear();
}

void MapChars::send_movement(std::int32_t cid,
                             const std::vector<Movement>& movements)
{
    if (nullable_ptr<OtherChar> otherchar = get_char(cid)) {
        otherchar->send_movement(movements);
    }
}

void MapChars::update_look(std::int32_t cid, const LookEntry& look)
{
    if (nullable_ptr<OtherChar> otherchar = get_char(cid)) {
        otherchar->update_look(look);
    }
}

nullable_ptr<OtherChar> MapChars::get_char(std::int32_t cid)
{
    return chars.get(cid);
}
} // namespace jrc

```

`Gameplay/MapleMap/MapChars.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/OtherChar.h"
#include "../Movement.h"
#include "../Spawn.h"
#include "MapObjects.h"

#include <queue>

namespace jrc
{
// A collection of remote controlled characters on a map.
class MapChars
{
public:
    // Draw all characters on a layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    // Update all characters.
    void update(const Physics& physics);

    // Spawn a new character, if it has not been spawned yet.
    void spawn(CharSpawn&& spawn);
    // Remove a character.
    void remove(std::int32_t cid);
    // Remove all characters.
    void clear();

    // Update a characters movement.
    void send_movement(std::int32_t cid,
                       const std::vector<Movement>& movements);
    // Update a characters look.
    void update_look(std::int32_t cid, const LookEntry& look);

    nullable_ptr<OtherChar> get_char(std::int32_t cid);

private:
    MapObjects chars;

    std::queue<CharSpawn> spawns;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapDrops.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapDrops.h"

#include "../../Constants.h"
#include "../../Data/ItemData.h"
#include "Drop.h"
#include "ItemDrop.h"
#include "MesoDrop.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
MapDrops::MapDrops()
{
    lootenabled = false;
}

void MapDrops::init()
{
    nl::node src = nl::nx::item["Special"]["0900.img"];

    mesoicons[BRONZE] = src["09000000"]["iconRaw"];
    mesoicons[GOLD] = src["09000001"]["iconRaw"];
    mesoicons[BUNDLE] = src["09000002"]["iconRaw"];
    mesoicons[BAG] = src["09000003"]["iconRaw"];
}

void MapDrops::draw(Layer::Id layer,
                    double viewx,
                    double viewy,
                    float alpha) const
{
    drops.draw(layer, viewx, viewy, alpha);
}

void MapDrops::update(const Physics& physics)
{
    for (; !spawns.empty(); spawns.pop()) {
        const DropSpawn& spawn = spawns.front();

        std::int32_t oid = spawn.get_oid();
        if (nullable_ptr<MapObject> drop = drops.get(oid)) {
            drop->activate();
        } else {
            std::int32_t itemid = spawn.get_itemid();
            bool meso = spawn.is_meso();
            if (meso) {
                MesoIcon mesotype = (itemid > 999)
                                        ? BAG
                                        : (itemid > 99)
                                              ? BUNDLE
                                              : (itemid > 49) ? GOLD : BRONZE;
                const Animation& icon = mesoicons[mesotype];
                drops.add(spawn.instantiate(icon));
            } else if (const ItemData& itemdata = ItemData::get(itemid)) {
                const Texture& icon = itemdata.get_icon(true);
                drops.add(spawn.instantiate(icon));
            }
        }
    }

    for (auto& mesoicon : mesoicons) {
        mesoicon.update();
    }

    drops.update(physics);

    lootenabled = true;
}

void MapDrops::spawn(DropSpawn&& spawn)
{
    spawns.emplace(std::move(spawn));
}

void MapDrops::remove(std::int32_t oid,
                      std::int8_t mode,
                      const PhysicsObject* looter)
{
    if (nullable_ptr<Drop> drop = drops.get(oid)) {
        drop->expire(mode, looter);
    }
}

void MapDrops::clear()
{
    drops.clear();
}

MapDrops::Loot MapDrops::find_loot_at(Point<std::int16_t> playerpos)
{
    if (!lootenabled)
        return {0, {}};

    for (auto& mmo : drops) {
        nullable_ptr<const Drop> drop = mmo.second.get();
        if (drop && drop->bounds().contains(playerpos)) {
            lootenabled = false;

            std::int32_t oid = mmo.first;
            Point<std::int16_t> position = drop->get_position();
            return {oid, position};
        }
    }
    return {0, {}};
}
} // namespace jrc

```

`Gameplay/MapleMap/MapDrops.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../Spawn.h"
#include "MapObjects.h"

#include <array>
#include <queue>

namespace jrc
{
class MapDrops
{
public:
    MapDrops();

    // Initialize the meso icons.
    void init();

    // Draw all drops on a layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    // Update all drops.
    void update(const Physics& physics);

    // Spawn a new drop.
    void spawn(DropSpawn&& spawn);
    // Remove a drop.
    void
    remove(std::int32_t oid, std::int8_t mode, const PhysicsObject* looter);
    // Remove all drops.
    void clear();

    // Find a drop which can be picked up at the specified position.
    using Loot = std::pair<std::int32_t, Point<std::int16_t>>;
    Loot find_loot_at(Point<std::int16_t> playerpos);

private:
    MapObjects drops;

    enum MesoIcon { BRONZE, GOLD, BUNDLE, BAG, NUM_ICONS };
    std::array<Animation, NUM_ICONS> mesoicons;
    bool lootenabled;

    std::queue<DropSpawn> spawns;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapInfo.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapInfo.h"

#include "../../Constants.h"
#include "../../Util/Misc.h"

#include <string_view>

namespace jrc
{
MapInfo::MapInfo(nl::node src,
                 Range<std::int16_t> walls,
                 Range<std::int16_t> borders)
{
    nl::node info = src["info"];
    if (info["VRLeft"].data_type() == nl::node::type::integer) {
        map_walls = {info["VRLeft"], info["VRRight"]};
        map_borders = {info["VRTop"], info["VRBottom"]};
        map_borders = {map_borders.first() + Constants::VIEW_Y_OFFSET,
                       map_borders.second() - Constants::VIEW_Y_OFFSET};
    } else {
        map_walls = walls;
        map_borders = borders;
    }

    std::string bgm_path = info["bgm"];
    std::size_t split = bgm_path.find('/');
    std::string_view bgm_path_view = bgm_path;
    bgm = str::concat(bgm_path_view.substr(0, split),
                      ".img/",
                      bgm_path_view.substr(split + 1));

    cloud = info["cloud"].get_bool();
    fieldlimit = info["fieldLimit"];
    hide_minimap = info["hideMinimap"].get_bool();
    map_mark = info["mapMark"].get_string();
    swim = info["swim"].get_bool();
    town = info["town"].get_bool();

    for (auto&& seat : src["seat"]) {
        seats.push_back(seat);
    }

    for (auto&& ladder : src["ladderRope"]) {
        ladders.push_back(ladder);
    }
}

MapInfo::MapInfo() = default;

bool MapInfo::is_underwater() const
{
    return swim;
}

std::string MapInfo::get_bgm() const
{
    return bgm;
}

Range<std::int16_t> MapInfo::get_walls() const
{
    return map_walls;
}

Range<std::int16_t> MapInfo::get_borders() const
{
    return map_borders;
}

nullable_ptr<const Seat> MapInfo::find_seat(Point<std::int16_t> position) const
{
    for (auto& seat : seats) {
        if (seat.in_range(position)) {
            return seat;
        }
    }
    return nullptr;
}

nullable_ptr<const Ladder> MapInfo::find_ladder(Point<std::int16_t> position,
                                                bool upwards) const
{
    for (auto& ladder : ladders) {
        if (ladder.in_range(position, upwards)) {
            return ladder;
        }
    }
    return nullptr;
}

Seat::Seat(nl::node src)
{
    pos = src;
}

bool Seat::in_range(Point<std::int16_t> position) const
{
    auto hor = Range<std::int16_t>::symmetric(position.x(), 10);
    auto ver = Range<std::int16_t>::symmetric(position.y(), 10);
    return hor.contains(pos.x()) && ver.contains(pos.y());
}

Point<std::int16_t> Seat::get_pos() const
{
    return pos;
}

Ladder::Ladder(nl::node src)
{
    x = src["x"];
    y1 = src["y1"];
    y2 = src["y2"];
    ladder = src["l"].get_bool();
}

bool Ladder::is_ladder() const
{
    return ladder;
}

bool Ladder::in_range(Point<std::int16_t> position, bool upwards) const
{
    auto hor = Range<std::int16_t>::symmetric(position.x(), 10);
    auto ver = Range<std::int16_t>(y1, y2);
    std::int16_t y = upwards ? position.y() - 5 : position.y() + 5;
    return hor.contains(x) && ver.contains(y);
}

bool Ladder::fell_off(std::int16_t y, bool downwards) const
{
    std::int16_t dy = downwards ? y + 5 : y - 5;
    return dy > y2 || y + 5 < y1;
}

std::int16_t Ladder::get_x() const
{
    return x;
}
} // namespace jrc

```

`Gameplay/MapleMap/MapInfo.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Point.h"
#include "../../Template/Range.h"
#include "../../Template/nullable_ptr.h"
#include "nlnx/node.hpp"

#include <vector>

namespace jrc
{
class Seat
{
public:
    Seat(nl::node source);

    bool in_range(Point<std::int16_t> position) const;
    Point<std::int16_t> get_pos() const;

private:
    Point<std::int16_t> pos;
};

class Ladder
{
public:
    Ladder(nl::node source);

    bool is_ladder() const;
    bool in_range(Point<std::int16_t> position, bool upwards) const;
    bool fell_off(std::int16_t y, bool downwards) const;
    std::int16_t get_x() const;

private:
    std::int16_t x;
    std::int16_t y1;
    std::int16_t y2;
    bool ladder;
};

class MapInfo
{
public:
    MapInfo(nl::node src,
            Range<std::int16_t> walls,
            Range<std::int16_t> borders);
    MapInfo();

    bool is_underwater() const;
    std::string get_bgm() const;
    Range<std::int16_t> get_walls() const;
    Range<std::int16_t> get_borders() const;

    //! Find a seat at the player's position.
    nullable_ptr<const Seat> find_seat(Point<std::int16_t> position) const;
    //! Find a ladder at the player's position. `upwards == false` implies
    //! downwards.
    nullable_ptr<const Ladder> find_ladder(Point<std::int16_t> position,
                                           bool upwards) const;

private:
    std::int32_t fieldlimit;
    bool cloud;
    std::string bgm;
    std::string map_desc;
    std::string map_name;
    std::string street_name;
    std::string map_mark;
    bool swim;
    bool town;
    bool hide_minimap;
    Range<std::int16_t> map_walls;
    Range<std::int16_t> map_borders;
    std::vector<Seat> seats;
    std::vector<Ladder> ladders;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapMobs.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapMobs.h"

#include "Mob.h"

#include <algorithm>
#include <iostream>
#include <limits>

namespace jrc
{
void MapMobs::draw(Layer::Id layer,
                   double viewx,
                   double viewy,
                   float alpha) const
{
    mobs.draw(layer, viewx, viewy, alpha);
}

void MapMobs::update(const Physics& physics)
{
    for (; !spawns.empty(); spawns.pop()) {
        const MobSpawn& spawn = spawns.front();

        if (nullable_ptr<Mob> mob = mobs.get(spawn.get_oid())) {
            std::int8_t mode = spawn.get_mode();
            if (mode > 0) {
                mob->set_control(mode);
            }
            mob->activate();
        } else {
            mobs.add(spawn.instantiate());
        }
    }

    mobs.update(physics);
}

void MapMobs::spawn(MobSpawn&& spawn)
{
    spawns.emplace(std::move(spawn));
}

void MapMobs::remove(std::int32_t oid, std::int8_t animation)
{
    if (nullable_ptr<Mob> mob = mobs.get(oid)) {
        mob->kill(animation);
    }
}

void MapMobs::clear()
{
    mobs.clear();
}

void MapMobs::set_control(std::int32_t oid, bool control)
{
    auto mode = static_cast<std::int8_t>(control ? 1 : 0);
    if (nullable_ptr<Mob> mob = mobs.get(oid)) {
        mob->set_control(mode);
    }
}

void MapMobs::send_mobhp(std::int32_t oid,
                         std::int8_t percent,
                         std::uint16_t playerlevel)
{
    if (nullable_ptr<Mob> mob = mobs.get(oid)) {
        mob->show_hp(percent, playerlevel);
    }
}

void MapMobs::send_movement(std::int32_t oid,
                            Point<std::int16_t> start,
                            std::vector<Movement>&& movements)
{
    if (nullable_ptr<Mob> mob = mobs.get(oid)) {
        mob->send_movement(start, std::move(movements));
    }
}

AttackResult MapMobs::send_attack(const Attack& attack)
{
    Point<std::int16_t> origin = attack.origin;
    Rectangle<std::int16_t> range = attack.range;
    std::int16_t h_range
        = static_cast<std::int16_t>(range.l() * attack.h_range);
    if (attack.to_left) {
        range = {origin.x() + h_range,
                 origin.x() + range.r(),
                 origin.y() + range.t(),
                 origin.y() + range.b()};
    } else {
        range = {origin.x() - range.r(),
                 origin.x() - h_range,
                 origin.y() + range.t(),
                 origin.y() + range.b()};
    }

    std::uint8_t mob_count = attack.mob_count;
    AttackResult result = attack;
    for (auto [_, target] : find_closest(range, origin, mob_count)) {
        if (nullable_ptr<Mob> mob = mobs.get(target)) {
            result.damage_lines[target] = mob->calculate_damage(attack);
            ++result.mob_count;

            if (result.mob_count == 1) {
                result.first_oid = target;
            }
            if (result.mob_count == mob_count) {
                result.last_oid = target;
            }
        }
    }

    return result;
}

void MapMobs::apply_damage(std::int32_t oid,
                           std::int32_t damage,
                           bool to_left,
                           const AttackUser& user,
                           const SpecialMove& move)
{
    if (nullable_ptr<Mob> mob = mobs.get(oid)) {
        mob->apply_damage(damage, to_left);

        // Maybe move this into the method above too?
        move.apply_hit_effects(user, *mob);
    }
}

boost::container::flat_map<std::uint16_t, std::int32_t>
MapMobs::find_closest(Rectangle<std::int16_t> range,
                      Point<std::int16_t> origin,
                      std::uint8_t mob_count) const noexcept
{
    if (mob_count == 0) {
        return {};
    }
    if (mob_count == 1) {
        auto closest_oid = std::numeric_limits<std::int32_t>::lowest();
        auto closest_distance = std::numeric_limits<std::uint16_t>::max();
        for (const auto& mmo : mobs) {
            auto mob = static_cast<const Mob*>(mmo.second.get());
            if (mob && mob->is_alive() && mob->is_in_range(range)) {
                std::int32_t oid = mob->get_oid();
                auto distance = static_cast<std::uint16_t>(
                    mob->get_position().disp(origin));

                if (distance < closest_distance) {
                    closest_distance = distance;
                    closest_oid = oid;
                }
            }
        }

        if (closest_oid == std::numeric_limits<std::int32_t>::lowest()) {
            return {};
        } else {
            return {{{closest_distance, closest_oid}}};
        }
    }

    boost::container::flat_map<std::uint16_t, std::int32_t> targets;
    targets.reserve(mob_count + 1);

    for (const auto& mmo : mobs) {
        auto mob = static_cast<const Mob*>(mmo.second.get());
        if (mob && mob->is_alive() && mob->is_in_range(range)) {
            std::int32_t oid = mob->get_oid();
            auto distance
                = static_cast<std::uint16_t>(mob->get_position().disp(origin));
            targets.emplace(distance, oid);

            if (targets.size() > mob_count) {
                auto furthest = targets.end();
                --furthest;
                targets.erase(furthest);
            }
        }
    }

    return targets;
}

bool MapMobs::contains(std::int32_t oid) const
{
    return mobs.contains(oid);
}

std::int32_t MapMobs::find_colliding(const MovingObject& moveobj) const
{
    Range<std::int16_t> horizontal{moveobj.get_last_x(), moveobj.get_x()};
    Range<std::int16_t> vertical{moveobj.get_last_y(), moveobj.get_y()};
    Rectangle<std::int16_t> player_rect{horizontal.smaller(),
                                        horizontal.greater(),
                                        vertical.smaller()
                                            - static_cast<std::int16_t>(50),
                                        vertical.greater()};

    auto iter
        = std::find_if(mobs.begin(), mobs.end(), [player_rect](auto& mmo) {
              nullable_ptr<Mob> mob = mmo.second.get();
              return mob && mob->is_alive() && mob->is_in_range(player_rect);
          });

    if (iter == mobs.end()) {
        return 0;
    }

    return iter->second->get_oid();
}

MobAttack MapMobs::create_attack(std::int32_t oid) const
{
    if (nullable_ptr<const Mob> mob = mobs.get(oid)) {
        return mob->create_touch_attack();
    } else {
        return {};
    }
}

Point<std::int16_t> MapMobs::get_mob_position(std::int32_t oid) const
{
    if (auto mob = mobs.get(oid)) {
        return mob->get_position();
    } else {
        return {};
    }
}

Point<std::int16_t> MapMobs::get_mob_head_position(std::int32_t oid) const
{
    if (nullable_ptr<const Mob> mob = mobs.get(oid)) {
        return mob->get_head_position();
    } else {
        return {};
    }
}
} // namespace jrc

```

`Gameplay/MapleMap/MapMobs.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Combat/Attack.h"
#include "../Combat/SpecialMove.h"
#include "../Spawn.h"
#include "MapObjects.h"
#include "boost/container/flat_map.hpp"

#include <queue>

namespace jrc
{
//! A collection of mobs on a map.
class MapMobs
{
public:
    //! Draw all mobs on a layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    //! Update all mobs.
    void update(const Physics& physics);

    //! Spawn a new mob.
    void spawn(MobSpawn&& spawn);
    //! Kill a mob.
    void remove(std::int32_t oid, std::int8_t effect);
    //! Remove all mobs.
    void clear();

    //! Update who a mob is controlled by.
    void set_control(std::int32_t oid, bool control);
    //! Update a mob's hp display.
    void send_mobhp(std::int32_t oid,
                    std::int8_t percent,
                    std::uint16_t playerlevel);
    //! Update a mob's movements.
    void send_movement(std::int32_t oid,
                       Point<std::int16_t> start,
                       std::vector<Movement>&& movements);

    //! Calculate the results of an attack.
    AttackResult send_attack(const Attack& attack);
    //! Applies damage to a mob.
    void apply_damage(std::int32_t oid,
                      std::int32_t damage,
                      bool to_left,
                      const AttackUser& user,
                      const SpecialMove& move);

    //! Check if the mob with the specified oid exists.
    bool contains(std::int32_t oid) const;
    //! Return the id of the first mob who collides with the object.
    std::int32_t find_colliding(const MovingObject& moveobj) const;
    //! Create an attack by the specified mob.
    MobAttack create_attack(std::int32_t oid) const;
    //! Return the position of a mob.
    Point<std::int16_t> get_mob_position(std::int32_t oid) const;
    //! Return the head position of a mob.
    Point<std::int16_t> get_mob_head_position(std::int32_t oid) const;

private:
    [[nodiscard]] boost::container::flat_map<std::uint16_t, std::int32_t>
    find_closest(Rectangle<std::int16_t> range,
                 Point<std::int16_t> origin,
                 std::uint8_t mob_count) const noexcept;

    MapObjects mobs;

    std::queue<MobSpawn> spawns;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapNpcs.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapNpcs.h"

#include "../../Net/Packets/NpcInteractionPackets.h"
#include "Npc.h"

namespace jrc
{
void MapNpcs::draw(Layer::Id layer,
                   double viewx,
                   double viewy,
                   float alpha) const
{
    npcs.draw(layer, viewx, viewy, alpha);
}

void MapNpcs::update(const Physics& physics)
{
    for (; !spawns.empty(); spawns.pop()) {
        const NpcSpawn& spawn = spawns.front();

        std::int32_t oid = spawn.get_oid();
        nullable_ptr<MapObject> npc = npcs.get(oid);
        if (npc) {
            npc->activate();
        } else {
            npcs.add(spawn.instantiate(physics));
        }
    }

    npcs.update(physics);
}

void MapNpcs::spawn(NpcSpawn&& spawn)
{
    spawns.emplace(std::move(spawn));
}

void MapNpcs::remove(std::int32_t oid)
{
    if (auto npc = npcs.get(oid))
        npc->deactivate();
}

void MapNpcs::clear()
{
    npcs.clear();
}

Cursor::State MapNpcs::send_cursor(bool pressed,
                                   Point<std::int16_t> position,
                                   Point<std::int16_t> viewpos)
{
    for (auto& mmo : npcs) {
        Npc* npc = static_cast<Npc*>(mmo.second.get());
        if (npc && npc->is_active() && npc->in_range(position, viewpos)) {
            if (pressed) {
                // TODO: try finding dialogue first
                TalkToNPCPacket(npc->get_oid()).dispatch();
                return Cursor::IDLE;
            } else {
                return Cursor::CAN_CLICK;
            }
        }
    }
    return Cursor::IDLE;
}
} // namespace jrc

```

`Gameplay/MapleMap/MapNpcs.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../IO/Cursor.h"
#include "../Spawn.h"
#include "MapObjects.h"

#include <queue>

namespace jrc
{
class MapNpcs
{
public:
    //! Draw all NPCs on a layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    //! Update all NPCs.
    void update(const Physics& physics);

    //! Add an NPC to the spawn queue.
    void spawn(NpcSpawn&& spawn);
    //! Remove the NPC with the specified oid;
    void remove(std::int32_t oid);
    //! Remove all NPCs.
    void clear();

    //! Send mouse input to clickable NPCs.
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> position,
                              Point<std::int16_t> viewpos);

private:
    MapObjects npcs;

    std::queue<NpcSpawn> spawns;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapObject.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapObject.h"

namespace jrc
{
MapObject::MapObject(std::int32_t o, Point<std::int16_t> p) : oid(o)
{
    set_position(p);
    active = true;
}

std::int8_t MapObject::update(const Physics& physics)
{
    physics.move_object(ph_obj);
    return ph_obj.fh_layer;
}

void MapObject::set_position(std::int16_t x, std::int16_t y)
{
    ph_obj.set_x(x);
    ph_obj.set_y(y);
}

void MapObject::set_position(Point<std::int16_t> position)
{
    std::int16_t x = position.x();
    std::int16_t y = position.y();
    set_position(x, y);
}

void MapObject::activate()
{
    active = true;
}

void MapObject::deactivate()
{
    active = false;
}

bool MapObject::is_active() const
{
    return active;
}

std::int8_t MapObject::get_layer() const
{
    return ph_obj.fh_layer;
}

std::int32_t MapObject::get_oid() const
{
    return oid;
}

Point<std::int16_t> MapObject::get_position() const
{
    return ph_obj.get_position();
}
} // namespace jrc

```

`Gameplay/MapleMap/MapObject.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Camera.h"
#include "../Physics/Physics.h"

namespace jrc
{
//! Base for objects on a map, eg. mobs, npcs, characters etc.
class MapObject
{
public:
    virtual ~MapObject() = default;

    //! Draws the object at the given position and with the specified
    //! interpolation.
    virtual void draw(double viewx, double viewy, float alpha) const = 0;

    //! Updates the object and returns the updated layer.
    virtual std::int8_t update(const Physics& physics);
    //! Reactivates the object.
    virtual void activate();
    //! Deactivates the object.
    virtual void deactivate();
    //! Checks whether this object is active or not.
    virtual bool is_active() const;
    //! Obtains the layer used to determine the drawing order on the map.
    virtual std::int8_t get_layer() const;

    //! Changes the objects position.
    void set_position(std::int16_t x, std::int16_t y);
    //! Changes the objects position.
    void set_position(Point<std::int16_t> position);

    //! Returns the object id unique to every object on one map.
    std::int32_t get_oid() const;
    //! Returns the current position.
    Point<std::int16_t> get_position() const;

protected:
    MapObject(std::int32_t oid, Point<std::int16_t> position = {});

    PhysicsObject ph_obj;
    std::int32_t oid;
    bool active;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapObjects.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapObjects.h"

namespace jrc
{
void MapObjects::draw(Layer::Id layer,
                      double viewx,
                      double viewy,
                      float alpha) const
{
    for (auto& oid : layers[layer]) {
        auto mmo = get(oid);
        if (mmo && mmo->is_active()) {
            mmo->draw(viewx, viewy, alpha);
        }
    }
}

void MapObjects::update(const Physics& physics)
{
    for (auto iter = objects.begin(); iter != objects.end();) {
        bool remove_mob = false;
        if (auto& mmo = iter->second) {
            std::int8_t oldlayer = mmo->get_layer();
            std::int8_t newlayer = mmo->update(physics);
            if (newlayer == -1) {
                remove_mob = true;
            } else if (newlayer != oldlayer) {
                std::int32_t oid = iter->first;
                layers[oldlayer].erase(oid);
                layers[newlayer].insert(oid);
            }
        } else {
            remove_mob = true;
        }

        if (remove_mob) {
            iter = objects.erase(iter);
        } else {
            ++iter;
        }
    }
}

void MapObjects::clear()
{
    objects.clear();

    for (auto& layer : layers) {
        layer.clear();
    }
}

bool MapObjects::contains(std::int32_t oid) const
{
    return objects.count(oid) > 0;
}

void MapObjects::add(std::unique_ptr<MapObject> toadd)
{
    std::int32_t oid = toadd->get_oid();
    std::int8_t layer = toadd->get_layer();
    objects[oid] = std::move(toadd);
    layers[layer].insert(oid);
}

void MapObjects::remove(std::int32_t oid)
{
    auto iter = objects.find(oid);
    if (iter != objects.end() && iter->second) {
        std::int8_t layer = iter->second->get_layer();
        objects.erase(iter);

        layers[layer].erase(oid);
    }
}

nullable_ptr<MapObject> MapObjects::get(std::int32_t oid)
{
    auto iter = objects.find(oid);
    return iter != objects.end() ? iter->second.get() : nullptr;
}

nullable_ptr<const MapObject> MapObjects::get(std::int32_t oid) const
{
    auto iter = objects.find(oid);
    return iter != objects.end() ? iter->second.get() : nullptr;
}

std::size_t MapObjects::size() const noexcept
{
    return objects.size();
}

MapObjects::underlying_t::iterator MapObjects::begin()
{
    return objects.begin();
}

MapObjects::underlying_t::iterator MapObjects::end()
{
    return objects.end();
}

MapObjects::underlying_t::const_iterator MapObjects::begin() const
{
    return objects.begin();
}

MapObjects::underlying_t::const_iterator MapObjects::end() const
{
    return objects.end();
}
} // namespace jrc

```

`Gameplay/MapleMap/MapObjects.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/nullable_ptr.h"
#include "Layer.h"
#include "MapObject.h"

#include <array>
#include <memory>
#include <unordered_map>
#include <unordered_set>

namespace jrc
{
//! A collection of generic mapobjects.
class MapObjects
{
public:
    //! Draw all mapobjects that are on the specified layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    //! Update all mapobjects of this type. Also updates layers eg. drawing
    //! order.
    void update(const Physics& physics);

    //! Adds a mapobject of this type.
    void add(std::unique_ptr<MapObject> mapobject);
    //! Removes the mapobject with the given oid.
    void remove(std::int32_t oid);
    //! Removes all mapobjects of this type.
    void clear();

    //! Check if a map object with the specified id exists on the map.
    bool contains(std::int32_t oid) const;
    //! Obtains a pointer to the mapobject with the given oid.
    nullable_ptr<MapObject> get(std::int32_t oid);
    //! Obtains a const pointer to the mapobject with the given oid.
    nullable_ptr<const MapObject> get(std::int32_t oid) const;
    //! Number of mapobjects in this collection.
    [[nodiscard]] std::size_t size() const noexcept;

    using underlying_t =
        typename std::unordered_map<std::int32_t, std::unique_ptr<MapObject>>;
    //! Return a begin iterator.
    underlying_t::iterator begin();
    //! Return an end iterator.
    underlying_t::iterator end();
    //! Return a begin iterator.
    underlying_t::const_iterator begin() const;
    //! Return an end iterator.
    underlying_t::const_iterator end() const;

private:
    std::unordered_map<std::int32_t, std::unique_ptr<MapObject>> objects;
    std::array<std::unordered_set<std::int32_t>, Layer::LENGTH> layers;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapPortals.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapPortals.h"

#include "../../Constants.h"
#include "../../Util/Misc.h"
#include "nlnx/nx.hpp"

namespace jrc
{
MapPortals::MapPortals(nl::node src, std::int32_t map_id)
{
    for (const auto& sub : src) {
        auto portal_id
            = string_conversion::or_default<std::int8_t>(sub.name(), -1);
        if (portal_id < 0) {
            continue;
        }

        Portal::Type type = Portal::typebyid(sub["pt"]);
        std::string name = sub["pn"];
        std::string target_name = sub["tn"];
        std::int32_t target_id = sub["tm"];
        Point<std::int16_t> position = {sub["x"], sub["y"]};

        const Animation* animation = &animations[type];
        bool intramap = target_id == map_id;

        portal_ids_by_name.emplace(std::string{name}, portal_id);
        portals_by_id.emplace(std::piecewise_construct,
                              std::forward_as_tuple(portal_id),
                              std::forward_as_tuple(animation,
                                                    type,
                                                    std::move(name),
                                                    intramap,
                                                    position,
                                                    target_id,
                                                    std::move(target_name)));
    }

    cooldown = WARP_CD;
}

MapPortals::MapPortals()
{
    cooldown = WARP_CD;
}

void MapPortals::update(Point<std::int16_t> playerpos)
{
    animations[Portal::REGULAR].update(Constants::TIMESTEP);
    animations[Portal::HIDDEN].update(Constants::TIMESTEP);

    for (auto& iter : portals_by_id) {
        Portal& portal = iter.second;
        switch (portal.get_type()) {
        case Portal::HIDDEN:
        case Portal::TOUCH:
            portal.update(playerpos);
            break;
        default:
            break;
        }
    }

    if (cooldown > 0) {
        --cooldown;
    }
}

void MapPortals::draw(Point<std::int16_t> viewpos, float inter) const
{
    for (auto& pt_it : portals_by_id) {
        pt_it.second.draw(viewpos, inter);
    }
}

Point<std::int16_t> MapPortals::get_portal_by_id(std::uint8_t portal_id) const
{
    auto iter = portals_by_id.find(portal_id);
    if (iter != portals_by_id.end()) {
        constexpr Point<std::int16_t> ABOVE(0, 30);
        return iter->second.get_position() - ABOVE;
    } else {
        return {};
    }
}

Point<std::int16_t>
MapPortals::get_portal_by_name(const std::string& portal_name) const
{
    auto iter = portal_ids_by_name.find(portal_name);
    if (iter != portal_ids_by_name.end()) {
        return get_portal_by_id(iter->second);
    } else {
        return {};
    }
}

Portal::WarpInfo MapPortals::find_warp_at(Point<std::int16_t> playerpos)
{
    if (cooldown == 0) {
        cooldown = WARP_CD;

        for (const auto& iter : portals_by_id) {
            const Portal& portal = iter.second;
            if (portal.bounds().contains(playerpos)) {
                return portal.getwarpinfo();
            }
        }
    }

    return {};
}

void MapPortals::init()
{
    nl::node src = nl::nx::map["MapHelper.img"]["portal"]["game"];

    animations[Portal::HIDDEN] = src["ph"]["default"]["portalContinue"];
    animations[Portal::REGULAR] = src["pv"];
}

std::unordered_map<Portal::Type, Animation> MapPortals::animations;
} // namespace jrc

```

`Gameplay/MapleMap/MapPortals.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/nullable_ptr.h"
#include "Portal.h"
#include "nlnx/node.hpp"

#include <unordered_map>

namespace jrc
{
// Collecton of portals on a map. Draws and updates portals.
// Also contains methods for using portals and obtaining spawn points.
class MapPortals
{
public:
    static void init();

    MapPortals(nl::node source, std::int32_t map_id);
    MapPortals();

    void update(Point<std::int16_t> playerpos);
    void draw(Point<std::int16_t> viewpos, float inter) const;

    Portal::WarpInfo find_warp_at(Point<std::int16_t> playerpos);

    Point<std::int16_t> get_portal_by_id(std::uint8_t id) const;
    Point<std::int16_t> get_portal_by_name(const std::string& name) const;

private:
    static std::unordered_map<Portal::Type, Animation> animations;

    std::unordered_map<std::uint8_t, Portal> portals_by_id;
    std::unordered_map<std::string, std::uint8_t> portal_ids_by_name;

    static const std::int16_t WARP_CD = 48;
    std::int16_t cooldown;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapReactors.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapReactors.h"

#include "Reactor.h"

namespace jrc
{
void MapReactors::draw(Layer::Id layer,
                       double viewx,
                       double viewy,
                       float alpha) const
{
    reactors.draw(layer, viewx, viewy, alpha);
}

void MapReactors::update(const Physics& physics)
{
    for (; !spawns.empty(); spawns.pop()) {
        const ReactorSpawn& spawn = spawns.front();

        std::int32_t oid = spawn.get_oid();
        if (auto reactor = reactors.get(oid)) {
            reactor->activate();
        } else {
            reactors.add(spawn.instantiate(physics));
        }
    }

    reactors.update(physics);
}

void MapReactors::spawn(ReactorSpawn&& spawn)
{
    spawns.emplace(std::move(spawn));
}

void MapReactors::remove(std::int32_t oid,
                         std::int8_t state,
                         Point<std::int16_t> position)
{
    if (nullable_ptr<Reactor> reactor = reactors.get(oid)) {
        reactor->destroy(state, position);
    }
}

void MapReactors::clear()
{
    reactors.clear();
}
} // namespace jrc

```

`Gameplay/MapleMap/MapReactors.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Spawn.h"
#include "MapObjects.h"

#include <queue>

namespace jrc
{
// Collection of reactors on a map.
class MapReactors
{
public:
    // Draw all reactors on a layer.
    void draw(Layer::Id layer, double viewx, double viewy, float alpha) const;
    // Update all reactors.
    void update(const Physics& physics);

    // Spawn a new reactor.
    void spawn(ReactorSpawn&& spawn);
    // Remove a reactor.
    void
    remove(std::int32_t oid, std::int8_t state, Point<std::int16_t> position);
    // Remove all reactors.
    void clear();

private:
    MapObjects reactors;

    std::queue<ReactorSpawn> spawns;
};
} // namespace jrc

```

`Gameplay/MapleMap/MapTilesObjs.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapTilesObjs.h"

namespace jrc
{
TilesObjs::TilesObjs(nl::node src)
{
    std::string tile_set = src["info"]["tS"];
    tile_set.append(".img", 4);
    for (auto tile_node : src["tile"]) {
        Tile tile{tile_node, tile_set};
        std::int8_t z = tile.get_z();
        tiles.emplace(z, std::move(tile));
    }

    for (auto obj_node : src["obj"]) {
        Obj obj{obj_node};
        std::int8_t z = obj.get_z();
        objs.emplace(z, std::move(obj));
    }
}

TilesObjs::TilesObjs() = default;

void TilesObjs::update()
{
    for (auto& [_, obj] : objs) {
        obj.update();
    }
}

void TilesObjs::draw(Point<std::int16_t> view_pos, float alpha) const
{
    for (auto& [_, obj] : objs) {
        obj.draw(view_pos, alpha);
    }

    for (auto& [_, tile] : tiles) {
        tile.draw(view_pos);
    }
}

MapTilesObjs::MapTilesObjs(nl::node src)
{
    for (auto iter : layers) {
        iter.second = src[iter.first];
    }
}

MapTilesObjs::MapTilesObjs() = default;

void MapTilesObjs::draw(Layer::Id layer,
                        Point<std::int16_t> view_pos,
                        float alpha) const
{
    layers[layer].draw(view_pos, alpha);
}

void MapTilesObjs::update()
{
    for (auto iter : layers) {
        iter.second.update();
    }
}
} // namespace jrc

```

`Gameplay/MapleMap/MapTilesObjs.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "Layer.h"
#include "Obj.h"
#include "Tile.h"
#include "boost/container/flat_map.hpp"

#include <vector>

namespace jrc
{
//! A tile and obj layer.
class TilesObjs
{
public:
    TilesObjs(nl::node src);
    TilesObjs();

    void draw(Point<std::int16_t> view_pos, float alpha) const;
    void update();

private:
    boost::container::flat_multimap<std::uint8_t, Tile> tiles;
    boost::container::flat_multimap<std::uint8_t, Obj> objs;
};

//! The collection of tile and obj layers on a map.
class MapTilesObjs
{
public:
    MapTilesObjs(nl::node src);
    MapTilesObjs();

    void
    draw(Layer::Id layer, Point<std::int16_t> view_pos, float alpha) const;
    void update();

private:
    EnumMap<Layer::Id, TilesObjs> layers;
};
} // namespace jrc

```

`Gameplay/MapleMap/MesoDrop.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MesoDrop.h"

namespace jrc
{
MesoDrop::MesoDrop(std::int32_t oid,
                   std::int32_t owner,
                   Point<std::int16_t> start,
                   Point<std::int16_t> dest,
                   std::int8_t type,
                   std::int8_t mode,
                   bool pd,
                   const Animation& icn)
    : Drop(oid, owner, start, dest, type, mode, pd), icon(icn)
{
}

void MesoDrop::draw(double viewx, double viewy, float alpha) const
{
    if (!active)
        return;

    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);
    icon.draw({angle.get(alpha), absp, opacity.get(alpha)}, alpha);
}
} // namespace jrc

```

`Gameplay/MapleMap/MesoDrop.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "Drop.h"

namespace jrc
{
class MesoDrop : public Drop
{
public:
    MesoDrop(std::int32_t oid,
             std::int32_t owner,
             Point<std::int16_t> start,
             Point<std::int16_t> dest,
             std::int8_t type,
             std::int8_t mode,
             bool playerdrop,
             const Animation& icon);

    void draw(double viewx, double viewy, float alpha) const override;

private:
    const Animation& icon;
};
} // namespace jrc

```

`Gameplay/MapleMap/Mob.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Mob.h"

#include "../../Constants.h"
#include "../../Net/Packets/GameplayPackets.h"
#include "../../Util/Misc.h"
#include "../Movement.h"
#include "nlnx/nx.hpp"

#include <algorithm>
#include <functional>

namespace jrc
{
Mob::Mob(std::int32_t oid,
         std::int32_t mob_id,
         std::int8_t mode,
         std::uint8_t stance,
         std::uint16_t fh,
         bool new_spawn,
         std::int8_t tm,
         Point<std::int16_t> position)
    : MapObject(oid)
{
    std::string strid = string_format::extend_id(mob_id, 7);
    const nl::node src = nl::nx::mob[strid + ".img"];

    nl::node info = src["info"];

    level = info["level"];
    watk = info["PADamage"];
    matk = info["MADamage"];
    wdef = info["PDDamage"];
    mdef = info["MDDamage"];
    accuracy = info["acc"];
    avoid = info["eva"];
    knockback = info["pushed"];
    speed = info["speed"];
    fly_speed = info["flySpeed"];
    touch_damage = info["bodyAttack"].get_bool();
    undead = info["undead"].get_bool();
    no_flip = info["noFlip"].get_bool();
    not_attack = info["notAttack"].get_bool();
    can_jump = src["jump"].size() > 0;
    can_fly = src["fly"].size() > 0;
    can_move = src["move"].size() > 0 || can_fly;

    if (can_fly) {
        animations[STAND] = src["fly"];
        animations[MOVE] = src["fly"];
    } else {
        animations[STAND] = src["stand"];
        animations[MOVE] = src["move"];
    }
    animations[JUMP] = src["jump"];
    animations[HIT] = src["hit1"];
    animations[DIE] = src["die1"];

    name = nl::nx::string["Mob.img"][std::to_string(mob_id)]["name"]
               .get_string();

    nl::node sndsrc = nl::nx::sound["Mob.img"][strid];

    hit_sound = sndsrc["Damage"];
    die_sound = sndsrc["Die"];

    speed += 100;
    speed *= 0.001f;

    fly_speed += 100;
    fly_speed *= 0.0005f;

    if (can_fly) {
        ph_obj.type = PhysicsObject::FLYING;
    }

    id = mob_id;
    team = tm;
    set_position(position);
    set_control(mode);
    ph_obj.fh_id = fh;
    ph_obj.set_flag(PhysicsObject::TURN_AT_EDGES);

    hp_percent = 0;
    dying = false;
    dead = false;
    fading = false;
    await_death = false;
    set_stance(stance);
    fly_direction = STRAIGHT;
    counter = 0;

    name_label = {Text::A13M,
                  Text::CENTER,
                  Text::WHITE,
                  Text::NAMETAG,
                  std::string{name}};

    if (new_spawn) {
        fade_in = true;
        opacity.set(0.0f);
    } else {
        fade_in = false;
        opacity.set(1.0f);
    }

    if (control && stance == Stance::STAND) {
        next_move();
    }
}

void Mob::set_stance(std::uint8_t stancebyte)
{
    flip = (stancebyte % 2) == 0;
    if (!flip) {
        stancebyte -= 1;
    }

    if (stancebyte < MOVE) {
        stancebyte = MOVE;
    }

    set_stance(static_cast<Stance>(stancebyte));
}

void Mob::set_stance(Stance newstance)
{
    if (stance != newstance) {
        stance = newstance;

        animations.at(stance).reset();
    }
}

std::int8_t Mob::update(const Physics& physics)
{
    if (!active) {
        return ph_obj.fh_layer;
    }

    bool aniend = animations.at(stance).update();
    if (aniend && stance == DIE) {
        dead = true;
    }

    if (fading) {
        opacity -= 0.025f;
        if (opacity.last() < 0.025f) {
            opacity.set(0.0f);
            fading = false;
            dead = true;
        }
    } else if (fade_in) {
        opacity += 0.025f;
        if (opacity.last() > 0.975f) {
            opacity.set(1.0f);
            fade_in = false;
        }
    }

    if (dead) {
        active = false;
        return -1;
    }

    effects.update();
    do_show_hp.update();

    if (!dying) {
        if (!can_fly) {
            if (ph_obj.is_flag_not_set(PhysicsObject::TURN_AT_EDGES)) {
                flip = !flip;
                ph_obj.set_flag(PhysicsObject::TURN_AT_EDGES);

                if (stance == HIT) {
                    set_stance(STAND);
                }
            }
        }

        switch (stance) {
        case MOVE:
            if (can_fly) {
                ph_obj.h_force = flip ? fly_speed : -fly_speed;
                switch (fly_direction) {
                case UPWARDS:
                    ph_obj.v_force = -fly_speed;
                    break;
                case DOWNWARDS:
                    ph_obj.v_force = fly_speed;
                    break;
                default:
                    break;
                }
            } else {
                ph_obj.h_force = flip ? speed : -speed;
            }
            break;
        case HIT:
            if (can_move) {
                double KBFORCE = ph_obj.on_ground ? 0.2 : 0.1;
                ph_obj.h_force = flip ? -KBFORCE : KBFORCE;
            }
            break;
        case JUMP:
            ph_obj.v_force = -5.0;
            break;
        default:
            break;
        }

        physics.move_object(ph_obj);

        if (control) {
            ++counter;

            bool next;
            switch (stance) {
            case HIT:
                next = counter > 200;
                break;
            case JUMP:
                next = ph_obj.on_ground;
                break;
            default:
                next = aniend && counter > 200;
                break;
            }

            if (next) {
                next_move();
                update_movement();
                counter = 0;
            }
        }
    } else {
        ph_obj.normalize();
        physics.get_fht().update_fh(ph_obj);
    }

    return ph_obj.fh_layer;
}

void Mob::next_move()
{
    if (can_move) {
        switch (stance) {
        case HIT:
        case STAND:
            set_stance(MOVE);
            flip = Randomizer::next_bool();
            break;
        case MOVE:
        case JUMP:
            if (can_jump && ph_obj.on_ground && Randomizer::below(0.25f)) {
                set_stance(JUMP);
            } else {
                switch (Randomizer::next_int(3)) {
                case 0:
                    set_stance(STAND);
                    break;
                case 1:
                    set_stance(MOVE);
                    flip = false;
                    break;
                case 2:
                    set_stance(MOVE);
                    flip = true;
                    break;
                default:
                    break;
                }
            }
            break;
        default:
            break;
        }

        if (stance == MOVE && can_fly) {
            fly_direction = Randomizer::next_enum(NUM_DIRECTIONS);
        }
    } else {
        set_stance(STAND);
    }
}

void Mob::update_movement()
{
    MoveMobPacket(oid,
                  1,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  get_position(),
                  Movement(ph_obj, value_of(stance, flip)))
        .dispatch();
}

void Mob::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);
    Point<std::int16_t> headpos = get_head_position(absp);

    effects.draw_below(absp, alpha);

    if (!dead) {
        float interopc = opacity.get(alpha);

        animations.at(stance).draw(
            DrawArgument(absp, flip && !no_flip, interopc), alpha);

        if (do_show_hp) {
            name_label.draw(absp);

            if (!dying && hp_percent > 0) {
                hp_bar.draw(headpos, hp_percent);
            }
        }
    }

    effects.draw_above(absp, alpha);
}

void Mob::set_control(std::int8_t mode)
{
    control = mode > 0;
    aggro = mode == 2;
}

void Mob::send_movement(Point<std::int16_t> start,
                        std::vector<Movement>&& in_movements)
{
    if (control) {
        return;
    }

    set_position(start);

    movements = std::forward<decltype(in_movements)>(in_movements);

    if (movements.empty()) {
        return;
    }

    const Movement& lastmove = movements.front();

    std::uint8_t laststance = lastmove.newstate;
    set_stance(laststance);

    ph_obj.fh_id = lastmove.fh;
}

Point<std::int16_t> Mob::get_head_position(Point<std::int16_t> position) const
{
    Point<std::int16_t> head = animations.at(stance).get_head();
    position.shift_x((flip && !no_flip) ? -head.x() : head.x());
    position.shift_y(head.y());

    return position;
}

void Mob::kill(std::int8_t kill_type)
{
    switch (kill_type) {
    case 0:
        active = false;
        break;
    case 1:
        dying = true;
        if (await_death) {
            apply_death();
        }
        break;
    case 2:
        fading = true;
        dying = true;
        break;
    default:
        break;
    }
}

void Mob::show_hp(std::int8_t percent, std::uint16_t player_level)
{
    if (hp_percent == 0) {
        std::int16_t delta = player_level - level;
        if (delta > 9) {
            name_label.change_color(Text::YELLOW);
        } else if (delta < -9) {
            name_label.change_color(Text::RED);
        }
    }

    if (percent > 100) {
        percent = 100;
    } else if (percent < 0) {
        percent = 0;
    }
    hp_percent = percent;
    do_show_hp.set_for(2000);
}

void Mob::show_effect(const Animation& animation,
                      std::int8_t pos,
                      std::int8_t z,
                      bool f)
{
    if (!active) {
        return;
    }

    Point<std::int16_t> shift;
    switch (pos) {
    case 0:
        shift = get_head_position({});
        break;
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        break;
    default:
        break;
    }
    effects.add(animation, {shift, f}, z);
}

float Mob::calculate_hit_chance(std::int16_t level_delta,
                                std::int32_t player_accuracy) const
{
    auto faccuracy = static_cast<float>(player_accuracy);
    float hitchance
        = faccuracy / (((1.84f + 0.07f * level_delta) * avoid) + 1.0f);
    if (hitchance < 0.01f) {
        hitchance = 0.01f;
    }

    return hitchance;
}

double Mob::calculate_min_damage(std::int16_t level_delta,
                                 double min_damage,
                                 bool magic) const
{
    double mindamage
        = magic ? min_damage - (1 + 0.01 * level_delta) * mdef * 0.6
                : min_damage * (1 - 0.01 * level_delta) - wdef * 0.6;

    return mindamage < 1.0 ? 1.0 : mindamage;
}

double Mob::calculate_max_damage(std::int16_t level_delta,
                                 double max_damage,
                                 bool magic) const
{
    double maxdamage
        = magic ? max_damage - (1 + 0.01 * level_delta) * mdef * 0.5
                : max_damage * (1 - 0.01 * level_delta) - wdef * 0.5;

    return maxdamage < 1.0 ? 1.0 : maxdamage;
}

std::vector<std::pair<std::int32_t, bool>>
Mob::calculate_damage(const Attack& attack)
{
    double min_damage;
    double max_damage;
    float hit_chance;
    float critical;
    std::int16_t level_delta = level - attack.player_level;
    if (level_delta < 0) {
        level_delta = 0;
    }

    Attack::DamageType damage_type = attack.damage_type;
    switch (damage_type) {
    case Attack::DMG_WEAPON:
    case Attack::DMG_MAGIC:
        min_damage = calculate_min_damage(
            level_delta, attack.min_damage, damage_type == Attack::DMG_MAGIC);
        max_damage = calculate_max_damage(
            level_delta, attack.max_damage, damage_type == Attack::DMG_MAGIC);
        hit_chance = calculate_hit_chance(level_delta, attack.accuracy);
        critical = attack.critical;
        break;
    case Attack::DMG_FIXED:
        min_damage = attack.fix_damage;
        max_damage = attack.fix_damage;
        hit_chance = 1.0f;
        critical = 0.0f;
        break;
    }

    std::vector<std::pair<std::int32_t, bool>> result(attack.hit_count);
    std::generate(result.begin(), result.end(), [&]() {
        return next_damage(min_damage, max_damage, hit_chance, critical);
    });

    update_movement();
    await_death = false;

    return result;
}

std::pair<std::int32_t, bool> Mob::next_damage(double min_damage,
                                               double max_damage,
                                               float hit_chance,
                                               float critical) const
{
    bool hit = Randomizer::below(hit_chance);
    if (!hit) {
        return {0, false};
    }

    constexpr double DAMAGECAP = 999999.0;

    double damage = Randomizer::next_real(min_damage, max_damage);
    bool iscritical = Randomizer::below(critical);
    if (iscritical) {
        damage *= 1.5;
    }

    if (damage < 1) {
        damage = 1;
    } else if (damage > DAMAGECAP) {
        damage = DAMAGECAP;
    }

    auto intdamage = static_cast<std::int32_t>(damage);
    return {intdamage, iscritical};
}

void Mob::apply_damage(std::int32_t damage, bool to_left)
{
    hit_sound.play();

    if (dying && stance != DIE) {
        apply_death();
    } else if (control && is_alive() && damage >= knockback) {
        flip = to_left;
        counter = 170;
        set_stance(HIT);

        update_movement();
        await_death = true;
    }
}

MobAttack Mob::create_touch_attack() const
{
    if (!touch_damage) {
        return {};
    }

    auto minattack = static_cast<std::int32_t>(watk * 0.8f);
    std::int32_t maxattack = watk;
    std::int32_t attack = Randomizer::next_int(minattack, maxattack);
    return {attack, get_position(), id, oid};
}

void Mob::apply_death()
{
    set_stance(DIE);
    die_sound.play();
    dying = true;
}

bool Mob::is_alive() const
{
    return active && !dying;
}

bool Mob::is_in_range(const Rectangle<std::int16_t>& range) const
{
    if (!active) {
        return false;
    }

    Rectangle<std::int16_t> bounds = animations.at(stance).get_bounds();
    bounds.shift(get_position());
    return range.overlaps(bounds);
}

Point<std::int16_t> Mob::get_head_position() const
{
    Point<std::int16_t> position = get_position();
    return get_head_position(position);
}
} // namespace jrc

```

`Gameplay/MapleMap/Mob.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Audio/Audio.h"
#include "../../Constants.h"
#include "../../Graphics/EffectLayer.h"
#include "../../Graphics/Geometry.h"
#include "../../Graphics/Text.h"
#include "../../Template/Interpolated.h"
#include "../../Template/Rectangle.h"
#include "../../Util/Randomizer.h"
#include "../../Util/TimedBool.h"
#include "../Combat/Attack.h"
#include "../Combat/Bullet.h"
#include "../Combat/DamageNumber.h"
#include "../Movement.h"
#include "MapObject.h"

#include <unordered_map>

namespace jrc
{
class Mob : public MapObject
{
public:
    static constexpr const std::size_t NUM_STANCES = 6;
    enum Stance : std::uint8_t {
        MOVE = 2,
        STAND = 4,
        JUMP = 6,
        HIT = 8,
        DIE = 10
    };

    static std::string_view name_of(Stance stance) noexcept
    {
        static constexpr const std::string_view stance_names[NUM_STANCES]
            = {"move", "stand", "jump", "hit1", "die1", "fly"};

        return stance_names[(stance - 1) / 2];
    }

    static std::uint8_t value_of(Stance stance, bool flip) noexcept
    {
        return flip ? stance : stance + 1;
    }

    //! Construct a mob by combining data from game files with
    //! data sent by the server.
    Mob(std::int32_t oid,
        std::int32_t mob_id,
        std::int8_t mode,
        std::uint8_t stance,
        std::uint16_t fhid,
        bool new_spawn,
        std::int8_t team,
        Point<std::int16_t> position);

    //! Draw the mob.
    void draw(double viewx, double viewy, float alpha) const override;
    //! Update movement and animations.
    std::int8_t update(const Physics& physics) override;

    //! Change this mob's control mode:
    //!
    //! * 0 : No control
    //! * 1 : Control
    //! * 2 : Aggro
    void set_control(std::int8_t mode);
    //! Send movement to the mob.
    void send_movement(Point<std::int16_t> start,
                       std::vector<Movement>&& movements);
    //! Kill the mob with the appropriate type:
    //!
    //! * 0 : Make inactive
    //! * 1 : Death animation
    //! * 2 : Fade out
    void kill(std::int8_t kill_type);
    //! Display the HP percentage above the mob.
    //! Use the player's level to determine color of nametag.
    void show_hp(std::int8_t percentage, std::uint16_t player_level);
    //! Show an effect at the mob's position.
    void show_effect(const Animation& animation,
                     std::int8_t pos,
                     std::int8_t z,
                     bool flip);

    //! Calculate the damage to this mob with the spcecified attack.
    std::vector<std::pair<std::int32_t, bool>>
    calculate_damage(const Attack& attack);
    //! Apply damage to the mob.
    void apply_damage(std::int32_t damage, bool to_left);

    //! Create a touch damage attack to the player.
    MobAttack create_touch_attack() const;

    //! Check if this mob collides with the specified rectangle.
    bool is_in_range(const Rectangle<std::int16_t>& range) const;
    //! Check if this mob is still alive.
    bool is_alive() const;
    //! Return the head position.
    Point<std::int16_t> get_head_position() const;

private:
    enum FlyDirection { STRAIGHT, UPWARDS, DOWNWARDS, NUM_DIRECTIONS };

    //! Set the stance by byte value.
    void set_stance(std::uint8_t stancebyte);
    //! Set the stance by enum value.
    void set_stance(Stance newstance);
    //! Start the death animation.
    void apply_death();
    //! Decide on the next state.
    void next_move();
    //! Send the current position and state to the server.
    void update_movement();

    //! Calculate the hit chance.
    float calculate_hit_chance(std::int16_t level_delta,
                               std::int32_t accuracy) const;
    //! Calculate the minimum damage.
    double calculate_min_damage(std::int16_t level_delta,
                                double min_damage,
                                bool magic) const;
    //! Calculate the maximum damage.
    double calculate_max_damage(std::int16_t level_delta,
                                double max_damage,
                                bool magic) const;
    //! Calculate a random damage line based on the specified values.
    std::pair<std::int32_t, bool> next_damage(double min_damage,
                                              double max_damage,
                                              float hit_chance,
                                              float critical) const;

    //! Return the current 'head' position.
    Point<std::int16_t> get_head_position(Point<std::int16_t> position) const;

    std::unordered_map<Stance, Animation> animations;
    std::string name;
    Sound hit_sound;
    Sound die_sound;
    std::uint16_t level;
    float speed;
    float fly_speed;
    std::uint16_t watk;
    std::uint16_t matk;
    std::uint16_t wdef;
    std::uint16_t mdef;
    std::uint16_t accuracy;
    std::uint16_t avoid;
    std::uint16_t knockback;
    bool undead;
    bool touch_damage;
    bool no_flip;
    bool not_attack;
    bool can_move;
    bool can_jump;
    bool can_fly;

    EffectLayer effects;
    Text name_label;
    MobHpBar hp_bar;

    TimedBool do_show_hp;

    std::vector<Movement> movements;
    std::uint16_t counter;

    std::int32_t id;
    std::int8_t effect;
    std::int8_t team;
    bool dying;
    bool dead;
    bool await_death;
    bool control;
    bool aggro;
    Stance stance;
    bool flip;
    FlyDirection fly_direction;
    float walk_force;
    std::int8_t hp_percent;
    bool fading;
    bool fade_in;
    Linear<float> opacity;
};
} // namespace jrc

```

`Gameplay/MapleMap/Npc.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
//#pragma once
#include "Npc.h"

#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
Npc::Npc(std::int32_t npc_id_,
         std::int32_t o,
         bool fl,
         std::uint16_t f,
         bool cnt,
         Point<std::int16_t> position)
    : MapObject{o}
{
    std::string str_id = std::to_string(npc_id_);
    str_id.insert(0, 7 - str_id.size(), '0');
    str_id.append(".img");

    nl::node src = nl::nx::npc[str_id];
    nl::node strsrc = nl::nx::string["Npc.img"][std::to_string(npc_id_)];

    std::string link = src["info"]["link"];
    if (link.size() > 0) {
        link.append(".img");
        src = nl::nx::npc[link];
    }

    nl::node info = src["info"];

    hide_name = info["hideName"].get_bool();
    mouse_only = info["talkMouseOnly"].get_bool();
    scripted = info["script"].size() > 0 || info["shop"].get_bool();

    for (const auto& npc_node : src) {
        const std::string state = npc_node.name();
        if (state != "info") {
            animations[state] = npc_node;
            states.push_back(state);
        }

        for (auto speaknode : npc_node["speak"]) {
            lines[state].push_back(strsrc[speaknode.get_string()]);
        }
    }

    name = strsrc["name"].get_string();
    func = strsrc["func"].get_string();

    name_label = {Text::A13B,
                  Text::CENTER,
                  Text::YELLOW,
                  Text::NAMETAG,
                  std::string{name}};
    func_label = {Text::A13B,
                  Text::CENTER,
                  Text::YELLOW,
                  Text::NAMETAG,
                  std::string{func}};

    npc_id = npc_id_;
    flip = !fl;
    control = cnt;
    stance = "stand";

    ph_obj.fh_id = f;
    set_position(position);
}

void Npc::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);
    if (animations.count(stance)) {
        animations.at(stance).draw(DrawArgument(absp, flip), alpha);
    }

    if (!hide_name) {
        name_label.draw(absp);
        func_label.draw(absp + Point<std::int16_t>{0, 18});
    }
}

std::int8_t Npc::update(const Physics& physics)
{
    if (!active) {
        return ph_obj.fh_layer;
    }

    physics.move_object(ph_obj);

    if (animations.count(stance)) {
        bool ani_end = animations.at(stance).update();
        if (ani_end && states.size() > 0) {
            std::size_t next_stance = Randomizer::next_int(states.size());
            std::string new_stance = states[next_stance];
            set_stance(new_stance);
        }
    }

    return ph_obj.fh_layer;
}

void Npc::set_stance(std::string_view st) noexcept
{
    if (stance != st) {
        stance = std::string{st};

        auto iter = animations.find(stance);
        if (iter == animations.end()) {
            return;
        }

        iter->second.reset();
    }
}

bool Npc::is_scripted() const noexcept
{
    return scripted;
}

bool Npc::in_range(Point<std::int16_t> cursor_pos,
                   Point<std::int16_t> view_pos) const noexcept
{
    if (!active) {
        return false;
    }

    Point<std::int16_t> absp = get_position() + view_pos;
    Point<std::int16_t> dim = animations.count(stance)
                                  ? animations.at(stance).get_dimensions()
                                  : Point<std::int16_t>{};

    return Rectangle<std::int16_t>{absp.x() - dim.x() / 2,
                                   absp.x() + dim.x() / 2,
                                   absp.y() - dim.y(),
                                   absp.y()}
        .contains(cursor_pos);
}
} // namespace jrc

```

`Gameplay/MapleMap/Npc.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../../Graphics/Text.h"
#include "../../Util/Randomizer.h"
#include "../Physics/PhysicsObject.h"
#include "MapObject.h"

#include <string_view>
#include <unordered_map>

namespace jrc
{
//! Represents an NPC on the current map.
//! Implements the `Mapobject` interface to be used in a `Mapobjects` template.
class Npc : public MapObject
{
public:
    //! Constructs an NPC by combining data from game files with
    //! data sent by the server.
    Npc(std::int32_t npc_id_,
        std::int32_t oid,
        bool mirrored,
        std::uint16_t fhid,
        bool control,
        Point<std::int16_t> position);

    //! Draws the current animation and name/function tags.
    void draw(double viewx, double viewy, float alpha) const override;
    //! Updates the current animation and physics.
    std::int8_t update(const Physics& physics) override;

    //! Changes stance and resets animation.
    void set_stance(std::string_view stance) noexcept;

    //! Check whether this is a server-sided NPC.
    [[nodiscard]] bool is_scripted() const noexcept;
    //! Check if the NPC is in range of the cursor.
    bool in_range(Point<std::int16_t> cursor_pos,
                  Point<std::int16_t> view_pos) const noexcept;

private:
    std::unordered_map<std::string, Animation> animations;
    std::unordered_map<std::string, std::vector<std::string>> lines;
    std::vector<std::string> states;
    std::string name;
    std::string func;
    bool hide_name;
    bool scripted;
    bool mouse_only;

    std::int32_t npc_id;
    bool flip;
    std::string stance;
    bool control;

    Text name_label;
    Text func_label;
};
} // namespace jrc

```

`Gameplay/MapleMap/Obj.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Obj.h"

#include "nlnx/nx.hpp"

namespace jrc
{
Obj::Obj(nl::node src)
    : animation{nl::nx::map["Obj"][src["oS"] + ".img"][src["l0"]][src["l1"]]
                           [src["l2"]]},
      pos{src["x"], src["y"]},
      z{src["z"]},
      flip{src["f"].get_bool()}

{
}

void Obj::update()
{
    animation.update();
}

void Obj::draw(Point<std::int16_t> view_pos, float inter) const
{
    animation.draw(DrawArgument{pos + view_pos, flip}, inter);
}

std::uint8_t Obj::get_z() const noexcept
{
    return z;
}
} // namespace jrc

```

`Gameplay/MapleMap/Obj.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../../Template/Point.h"

namespace jrc
{
//! Represents an obj (map decoration) on a map.
class Obj
{
public:
    Obj(nl::node source);

    //! Update animation.
    void update();
    //! Draw the obj at the specified position.
    void draw(Point<std::int16_t> view_pos, float inter) const;
    //! Return depth of the obj.
    std::uint8_t get_z() const noexcept;

private:
    Animation animation;
    Point<std::int16_t> pos;
    std::uint8_t z;
    bool flip;
};
} // namespace jrc

```

`Gameplay/MapleMap/Portal.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Portal.h"

namespace jrc
{
Portal::Portal(const Animation* a,
               Type t,
               std::string&& nm,
               bool intramap,
               Point<std::int16_t> p,
               std::int32_t tid,
               std::string&& tnm)
    : animation(a),
      type(t),
      name(nm),
      position(p),
      warpinfo(tid, intramap, std::move(tnm), std::move(nm))
{
    touched = false;
}

Portal::Portal()
    : Portal(nullptr, SPAWN, "", false, Point<std::int16_t>(), 0, "")
{
}

void Portal::update(Point<std::int16_t> playerpos)
{
    touched = bounds().contains(playerpos);
}

void Portal::draw(Point<std::int16_t> viewpos, float inter) const
{
    if (!animation || (type == HIDDEN && !touched)) {
        return;
    }

    animation->draw(position + viewpos, inter);
}

std::string Portal::get_name() const
{
    return name;
}

Portal::Type Portal::get_type() const
{
    return type;
}

Point<std::int16_t> Portal::get_position() const
{
    return position;
}

Rectangle<std::int16_t> Portal::bounds() const
{
    auto lt = position + Point<std::int16_t>(-25, -100);
    auto rb = position + Point<std::int16_t>(25, 25);
    return Rectangle<std::int16_t>(lt, rb);
}

Portal::WarpInfo Portal::getwarpinfo() const
{
    return warpinfo;
}
} // namespace jrc

```

`Gameplay/MapleMap/Portal.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "../../Template/Rectangle.h"

#include <cstdint>
#include <map>

namespace jrc
{
class Portal
{
public:
    enum Type {
        SPAWN,
        INVISIBLE,
        REGULAR,
        TOUCH,
        TYPE4,
        TYPE5,
        WARP,
        SCRIPTED,
        SCRIPTED_INVISIBLE,
        SCRIPTED_TOUCH,
        HIDDEN,
        SCRIPTED_HIDDEN,
        SPRING1,
        SPRING2,
        TYPE14
    };

    static Type typebyid(std::int32_t id)
    {
        return static_cast<Type>(id);
    }

    struct WarpInfo {
        std::int32_t mapid;
        std::string to_name;
        std::string name;
        bool intramap;
        bool valid;

        WarpInfo(std::int32_t m, bool i, std::string&& tn, std::string&& n)
            : mapid(m),
              to_name(std::move(tn)),
              name(std::move(n)),
              intramap(i),
              valid(mapid < 999999999)
        {
        }

        WarpInfo() : WarpInfo(999999999, false, {}, {})
        {
        }
    };

    Portal(const Animation* animation,
           Type type,
           std::string&& name,
           bool intramap,
           Point<std::int16_t> position,
           std::int32_t tomap,
           std::string&& toname);
    Portal();

    void update(Point<std::int16_t> playerpos);
    void draw(Point<std::int16_t> viewpos, float alpha) const;

    std::string get_name() const;
    Type get_type() const;
    Point<std::int16_t> get_position() const;
    Rectangle<std::int16_t> bounds() const;

    WarpInfo getwarpinfo() const;

private:
    const Animation* animation;
    Type type;
    std::string name;
    Point<std::int16_t> position;
    WarpInfo warpinfo;
    bool touched;
};
} // namespace jrc

```

`Gameplay/MapleMap/Reactor.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Reactor.h"

#include "../../Util/Misc.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Reactor::Reactor(std::int32_t o,
                 std::int32_t r,
                 std::int8_t s,
                 Point<std::int16_t> p)
    : MapObject(o, p), rid(r), state(s)
{
    std::string strid = string_format::extend_id(rid, 7);
    nl::node src = nl::nx::reactor[strid + ".img"];

    normal = src["0"];
}

void Reactor::draw(double viewx, double viewy, float alpha) const
{
    Point<std::int16_t> absp = ph_obj.get_absolute(viewx, viewy, alpha);
    Point<std::int16_t> shift = {0, normal.get_dimensions().y() / 2};
    normal.draw(absp - shift, alpha);
}

void Reactor::destroy(std::int8_t, Point<std::int16_t>)
{
    deactivate();
}
} // namespace jrc

```

`Gameplay/MapleMap/Reactor.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Animation.h"
#include "MapObject.h"

#include <vector>

namespace jrc
{
class Reactor : public MapObject
{
public:
    Reactor(std::int32_t oid,
            std::int32_t rid,
            std::int8_t state,
            Point<std::int16_t> position);

    void draw(double viewx, double viewy, float alpha) const override;

    void destroy(std::int8_t state, Point<std::int16_t> position);

private:
    std::int32_t oid;
    std::int32_t rid;
    std::int8_t state;

    Animation normal;
};
} // namespace jrc

```

`Gameplay/MapleMap/Tile.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Tile.h"

#include "nlnx/nx.hpp"

namespace jrc
{
Tile::Tile(nl::node src, std::string_view ts)
{
    nl::node dsrc = nl::nx::map["Tile"][ts][src["u"]][src["no"]];
    texture = Texture(nl::nx::map["Tile"][ts][src["u"]][src["no"]]);
    pos = Point<std::int16_t>(src["x"], src["y"]);
    z = dsrc["z"];
    if (z == 0) {
        z = dsrc["zM"];
    }
}

void Tile::draw(Point<std::int16_t> viewpos) const
{
    texture.draw(pos + viewpos);
}

std::uint8_t Tile::get_z() const
{
    return z;
}
} // namespace jrc

```

`Gameplay/MapleMap/Tile.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../../Template/Point.h"
#include "nlnx/node.hpp"

#include <cstdint>
#include <string>
#include <string_view>

namespace jrc
{
//! Represents a tile on a map.
class Tile
{
public:
    Tile(nl::node src, std::string_view tileset);

    //! Draw the tile.
    void draw(Point<std::int16_t> viewpos) const;
    //! Returns depth of the tile.
    std::uint8_t get_z() const;

private:
    Texture texture;
    Point<std::int16_t> pos;
    std::uint8_t z;
};
} // namespace jrc

```

`Gameplay/Movement.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Physics/PhysicsObject.h"

namespace jrc
{
struct Movement {
    enum Type { NONE, _ABSOLUTE, _RELATIVE, CHAIR, JUMPDOWN };

    Movement(Type t,
             std::uint8_t c,
             std::int16_t x,
             std::int16_t y,
             std::int16_t lx,
             std::int16_t ly,
             std::uint16_t f,
             std::uint8_t s,
             std::int16_t d)
        : type(t),
          command(c),
          xpos(x),
          ypos(y),
          lastx(lx),
          lasty(ly),
          fh(f),
          newstate(s),
          duration(d)
    {
    }

    Movement(std::int16_t x,
             std::int16_t y,
             std::int16_t lx,
             std::int16_t ly,
             std::uint8_t s,
             std::int16_t d)
        : Movement(_ABSOLUTE, 0, x, y, lx, ly, 0, s, d)
    {
    }

    Movement(const PhysicsObject& phobj, std::uint8_t s)
        : Movement(_ABSOLUTE,
                   0,
                   phobj.get_x(),
                   phobj.get_y(),
                   phobj.get_last_x(),
                   phobj.get_last_y(),
                   phobj.fh_id,
                   s,
                   1)
    {
    }

    Movement() : Movement(NONE, 0, 0, 0, 0, 0)
    {
    }

    bool hasmoved(const Movement& newmove) const
    {
        return newmove.newstate != newstate || newmove.xpos != xpos
               || newmove.ypos != ypos || newmove.lastx != lastx
               || newmove.lasty != lasty;
    }

    Type type;
    std::uint8_t command;
    std::int16_t xpos;
    std::int16_t ypos;
    std::int16_t lastx;
    std::int16_t lasty;
    std::uint16_t fh;
    std::uint8_t newstate;
    std::int16_t duration;
};
} // namespace jrc

```

`Gameplay/Physics/Foothold.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Foothold.h"

namespace jrc
{
Foothold::Foothold(nl::node src, std::uint16_t id, std::uint8_t ly)
    : m_id(id),
      m_prev(src["prev"]),
      m_next(src["next"]),
      m_layer(ly),
      m_horizontal(src["x1"], src["x2"]),
      m_vertical(src["y1"], src["y2"])
{
}

Foothold::Foothold() : m_id(0), m_prev(0), m_next(0), m_layer(0)
{
}

std::uint16_t Foothold::id() const
{
    return m_id;
}

std::uint16_t Foothold::prev() const
{
    return m_prev;
}

std::uint16_t Foothold::next() const
{
    return m_next;
}

std::uint8_t Foothold::layer() const
{
    return m_layer;
}

const Range<std::int16_t>& Foothold::horizontal() const
{
    return m_horizontal;
}

const Range<std::int16_t>& Foothold::vertical() const
{
    return m_vertical;
}

std::int16_t Foothold::l() const
{
    return m_horizontal.smaller();
}

std::int16_t Foothold::r() const
{
    return m_horizontal.greater();
}

std::int16_t Foothold::t() const
{
    return m_vertical.smaller();
}

std::int16_t Foothold::b() const
{
    return m_vertical.greater();
}

std::int16_t Foothold::x1() const
{
    return m_horizontal.first();
}

std::int16_t Foothold::x2() const
{
    return m_horizontal.second();
}

std::int16_t Foothold::y1() const
{
    return m_vertical.first();
}

std::int16_t Foothold::y2() const
{
    return m_vertical.second();
}

bool Foothold::is_wall() const
{
    return m_id && m_horizontal.empty();
}

bool Foothold::is_floor() const
{
    return m_id && m_vertical.empty();
}

bool Foothold::is_left_edge() const
{
    return m_id && m_prev == 0;
}

bool Foothold::is_right_edge() const
{
    return m_id && m_next == 0;
}

bool Foothold::hcontains(std::int16_t x) const
{
    return m_id && m_horizontal.contains(x);
}

bool Foothold::vcontains(std::int16_t y) const
{
    return m_id && m_vertical.contains(y);
}

bool Foothold::is_blocking(const Range<std::int16_t>& vertical) const
{
    return is_wall() && m_vertical.overlaps(vertical);
}

std::int16_t Foothold::hdelta() const
{
    return m_horizontal.delta();
}

std::int16_t Foothold::vdelta() const
{
    return m_vertical.delta();
}

double Foothold::slope() const
{
    std::int16_t h_delta = hdelta();
    return h_delta == 0 || is_wall() ? 0.0
                                     : static_cast<double>(vdelta()) / h_delta;
}

double Foothold::ground_below(double x) const
{
    return is_floor() ? y1() : slope() * (x - x1()) + y1();
}
} // namespace jrc

```

`Gameplay/Physics/Foothold.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Range.h"
#include "nlnx/node.hpp"

namespace jrc
{
//! Represents a platform part on a maple-map.
class Foothold
{
public:
    Foothold(nl::node src, std::uint16_t id, std::uint8_t layer);
    Foothold();

    //! Returns the foothold id aka the identifier in game data of this
    //! platform.
    std::uint16_t id() const;
    //! Returns the platform left to this.
    std::uint16_t prev() const;
    //! Returns the platform right to this.
    std::uint16_t next() const;
    //! Returns the platform's layer.
    std::uint8_t layer() const;
    //! Returns the horizontal component.
    const Range<std::int16_t>& horizontal() const;
    //! Returns the vertical component.
    const Range<std::int16_t>& vertical() const;

    //! Return the left edge.
    std::int16_t l() const;
    //! Return the right edge.
    std::int16_t r() const;
    //! Return the top edge.
    std::int16_t t() const;
    //! Return the bottom edge.
    std::int16_t b() const;
    //! Return the first horizontal component.
    std::int16_t x1() const;
    //! Return the second horizontal component.
    std::int16_t x2() const;
    //! Return the first vertical component.
    std::int16_t y1() const;
    //! Return the second vertical component.
    std::int16_t y2() const;
    //! Return if the platform is a wall (x1 == x2).
    bool is_wall() const;
    //! Return if the platform is a floor (y1 == y2).
    bool is_floor() const;
    //! Return if this platform is a left edge.
    bool is_left_edge() const;
    //! Return if this platform is a right edge.
    bool is_right_edge() const;
    //! Returns if a x-coordinate is above or below this platform.
    bool hcontains(std::int16_t x) const;
    //! Returns if a y-coordinate is right or left of this platform.
    bool vcontains(std::int16_t y) const;
    //! Check wether this foothold blocks an object.
    bool is_blocking(const Range<std::int16_t>& vertical) const;
    //! Returns the width.
    std::int16_t hdelta() const;
    //! Returns the height.
    std::int16_t vdelta() const;
    //! Returns the slope as a ratio of vertical/horizontal.
    double slope() const;
    //! Returns a y-coordinate right below the given x-coordinate.
    double ground_below(double x) const;

private:
    std::uint16_t m_id;
    std::uint16_t m_prev;
    std::uint16_t m_next;
    std::uint8_t m_layer;
    Range<std::int16_t> m_horizontal;
    Range<std::int16_t> m_vertical;
};
} // namespace jrc

```

`Gameplay/Physics/FootholdTree.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "FootholdTree.h"

#include "../../Console.h"

namespace jrc
{
Footholdtree::Footholdtree(nl::node src)
{
    std::int16_t leftw = 30000;
    std::int16_t rightw = -30000;
    std::int16_t botb = -30000;
    std::int16_t topb = 30000;

    for (const auto& basef : src) {
        std::uint8_t layer;
        try {
            layer = static_cast<std::uint8_t>(std::stoi(basef.name()));
        } catch (const std::exception& ex) {
            Console::get().print(__func__, ex.what());
            continue;
        }

        for (const auto& midf : basef) {
            for (const auto& lastf : midf) {
                std::uint16_t id;
                try {
                    id = static_cast<std::uint16_t>(std::stoi(lastf.name()));
                } catch (const std::exception& ex) {
                    Console::get().print(__func__, ex.what());
                    continue;
                }

                const Foothold& foothold
                    = footholds
                          .emplace(std::piecewise_construct,
                                   std::forward_as_tuple(id),
                                   std::forward_as_tuple(lastf, id, layer))
                          .first->second;

                if (foothold.l() < leftw) {
                    leftw = foothold.l();
                }

                if (foothold.r() > rightw) {
                    rightw = foothold.r();
                }

                if (foothold.b() > botb) {
                    botb = foothold.b();
                }

                if (foothold.t() < topb) {
                    topb = foothold.t();
                }

                if (foothold.is_wall()) {
                    continue;
                }

                std::int16_t start = foothold.l();
                std::int16_t end = foothold.r();
                for (std::int16_t i = start; i <= end; ++i) {
                    footholdsbyx.emplace(i, id);
                }
            }
        }
    }

    walls = {leftw + 25, rightw - 25};
    borders = {topb - 300, botb + 100};
}

Footholdtree::Footholdtree() = default;

void Footholdtree::limit_movement(PhysicsObject& phobj) const
{
    if (phobj.h_mobile()) {
        double crnt_x = phobj.crnt_x();
        double next_x = phobj.next_x();

        bool left = phobj.hspeed < 0.0f;
        double wall = get_wall(phobj.fh_id, left, phobj.next_y());
        bool collision = left ? crnt_x >= wall && next_x <= wall
                              : crnt_x <= wall && next_x >= wall;

        if (!collision && phobj.is_flag_set(PhysicsObject::TURN_AT_EDGES)) {
            wall = get_edge(phobj.fh_id, left);
            collision = left ? crnt_x >= wall && next_x <= wall
                             : crnt_x <= wall && next_x >= wall;
        }

        if (collision) {
            phobj.limit_x(wall);
            phobj.clear_flag(PhysicsObject::TURN_AT_EDGES);
        }
    }

    if (phobj.v_mobile()) {
        double crnt_y = phobj.crnt_y();
        double next_y = phobj.next_y();

        auto ground
            = Range<double>(get_fh(phobj.fh_id).ground_below(phobj.crnt_x()),
                            get_fh(phobj.fh_id).ground_below(phobj.next_x()));
        bool collision = crnt_y <= ground.first() && next_y >= ground.second();
        if (collision) {
            phobj.limit_y(ground.second());

            limit_movement(phobj);
        } else {
            if (next_y < borders.first()) {
                phobj.limit_y(borders.first());
            } else if (next_y > borders.second()) {
                phobj.limit_y(borders.second());
            }
        }
    }
}

void Footholdtree::update_fh(PhysicsObject& phobj) const
{
    if (phobj.type == PhysicsObject::FIXATED && phobj.fh_id > 0) {
        return;
    }

    const Foothold& curfh = get_fh(phobj.fh_id);
    bool checkslope = false;

    double x = phobj.crnt_x();
    double y = phobj.crnt_y();
    if (phobj.on_ground) {
        if (std::floor(x) > curfh.r()) {
            phobj.fh_id = curfh.next();
        } else if (std::ceil(x) < curfh.l()) {
            phobj.fh_id = curfh.prev();
        }

        if (phobj.fh_id == 0) {
            phobj.fh_id = get_fhid_below(x, y);
        } else {
            checkslope = true;
        }
    } else {
        phobj.fh_id = get_fhid_below(x, y);
    }

    const Foothold& nextfh = get_fh(phobj.fh_id);
    phobj.fh_slope = nextfh.slope();

    double ground = nextfh.ground_below(x);
    if (phobj.vspeed == 0.0 && checkslope) {
        double vdelta = std::abs(phobj.fh_slope);
        if (phobj.fh_slope < 0.0) {
            vdelta *= (ground - y);
        } else if (phobj.fh_slope > 0.0) {
            vdelta *= (y - ground);
        }

        if (curfh.slope() != 0.0 || nextfh.slope() != 0.0) {
            if (phobj.hspeed > 0.0 && vdelta <= phobj.hspeed) {
                phobj.y = ground;
            } else if (phobj.hspeed < 0.0 && vdelta >= phobj.hspeed) {
                phobj.y = ground;
            }
        }
    }

    phobj.on_ground = phobj.y == ground;

    if (phobj.enable_jd || phobj.is_flag_set(PhysicsObject::CHECK_BELOW)) {
        std::uint16_t belowid
            = get_fhid_below(x, nextfh.ground_below(x) + 1.0);
        if (belowid > 0) {
            double nextground = get_fh(belowid).ground_below(x);
            phobj.enable_jd = (nextground - ground) < 600.0;
            phobj.ground_below = ground + 1.0;
        } else {
            phobj.enable_jd = false;
        }

        phobj.clear_flag(PhysicsObject::CHECK_BELOW);
    }

    if (phobj.fh_layer == 0 || phobj.on_ground) {
        phobj.fh_layer = nextfh.layer();
    }

    if (phobj.fh_id == 0) {
        phobj.fh_id = curfh.id();
        phobj.limit_x(curfh.x1());
    }
}

const Foothold& Footholdtree::get_fh(std::uint16_t fhid) const
{
    auto iter = footholds.find(fhid);
    if (iter == footholds.end()) {
        return nullfh;
    }

    return iter->second;
}

double Footholdtree::get_wall(std::uint16_t curid, bool left, double fy) const
{
    auto shorty = static_cast<std::int16_t>(fy);
    Range<std::int16_t> vertical(shorty - 50, shorty - 1);
    const Foothold& cur = get_fh(curid);
    if (left) {
        const Foothold& prev = get_fh(cur.prev());
        if (prev.is_blocking(vertical)) {
            return cur.l();
        }

        const Foothold& prev_prev = get_fh(prev.prev());
        if (prev_prev.is_blocking(vertical)) {
            return prev.l();
        }
        return walls.first();
    } else {
        const Foothold& next = get_fh(cur.next());
        if (next.is_blocking(vertical)) {
            return cur.r();
        }

        const Foothold& next_next = get_fh(next.next());
        if (next_next.is_blocking(vertical)) {
            return next.r();
        }
        return walls.second();
    }
}

double Footholdtree::get_edge(std::uint16_t curid, bool left) const
{
    const Foothold& fh = get_fh(curid);
    if (left) {
        std::uint16_t previd = fh.prev();
        if (!previd) {
            return fh.l();
        }

        const Foothold& prev = get_fh(previd);
        std::uint16_t prev_previd = prev.prev();
        if (!prev_previd) {
            return prev.l();
        }

        return walls.first();
    } else {
        std::uint16_t nextid = fh.next();
        if (!nextid) {
            return fh.r();
        }

        const Foothold& next = get_fh(nextid);
        std::uint16_t next_nextid = next.next();
        if (!next_nextid) {
            return next.r();
        }

        return walls.second();
    }
}

std::uint16_t Footholdtree::get_fhid_below(double fx, double fy) const
{
    std::uint16_t ret = 0;
    double comp = borders.second();

    auto x = static_cast<std::int16_t>(fx);
    auto range = footholdsbyx.equal_range(x);
    for (auto iter = range.first; iter != range.second; ++iter) {
        const Foothold& fh = footholds.at(iter->second);
        double ycomp = fh.ground_below(fx);
        if (comp >= ycomp && ycomp >= fy) {
            comp = ycomp;
            ret = fh.id();
        }
    }

    return ret;
}

std::int16_t Footholdtree::get_y_below(Point<std::int16_t> position) const
{
    if (std::uint16_t fhid = get_fhid_below(position.x(), position.y())) {
        const Foothold& fh = get_fh(fhid);
        return static_cast<std::int16_t>(fh.ground_below(position.x()));
    } else {
        return borders.second();
    }
}

Range<std::int16_t> Footholdtree::get_walls() const
{
    return walls;
}

Range<std::int16_t> Footholdtree::get_borders() const
{
    return borders;
}
} // namespace jrc

```

`Gameplay/Physics/FootholdTree.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Foothold.h"
#include "PhysicsObject.h"

#include <unordered_map>

namespace jrc
{
// The collection of platforms in a maple-map. Used for collision-detection.
class Footholdtree
{
public:
    Footholdtree(nl::node source);
    Footholdtree();

    void draw(Point<std::int16_t> pos) const;

    // Takes an accelerated PhysicsObject and limits its movement based on the
    // platforms in this tree.
    void limit_movement(PhysicsObject& touse) const;
    // Updates a PhysicsObject's fh_id based on it's position.
    void update_fh(PhysicsObject& touse) const;
    // Determine the point on the ground below the specified position.
    std::int16_t get_y_below(Point<std::int16_t> position) const;
    // Returns the leftmost and rightmost platform positions of the map.
    Range<std::int16_t> get_walls() const;
    // Returns the topmost and bottommost platform positions of the map.
    Range<std::int16_t> get_borders() const;

private:
    std::uint16_t get_fhid_below(double fx, double fy) const;
    double get_wall(std::uint16_t fhid, bool left, double fy) const;
    double get_edge(std::uint16_t fhid, bool left) const;
    const Foothold& get_fh(std::uint16_t fhid) const;

    std::unordered_map<std::uint16_t, Foothold> footholds;
    std::unordered_multimap<std::int16_t, std::uint16_t> footholdsbyx;

    Foothold nullfh;
    Range<std::int16_t> walls;
    Range<std::int16_t> borders;
};
} // namespace jrc

```

`Gameplay/Physics/Physics.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Physics.h"

#include <functional>

namespace jrc
{
const double GRAVFORCE = 0.14;
const double SWIMGRAVFORCE = 0.03;
const double FRICTION = 0.3;
const double SLOPEFACTOR = 0.1;
const double GROUNDSLIP = 3.0;
const double FLYFRICTION = 0.05;
const double SWIMFRICTION = 0.08;

Physics::Physics(nl::node src)
{
    fht = src;
}

Physics::Physics() = default;

void Physics::move_object(PhysicsObject& phobj) const
{
    // Determine which platform the object is currently on.
    fht.update_fh(phobj);

    // Use the appropriate physics for the terrain the object is on.
    switch (phobj.type) {
    case PhysicsObject::NORMAL:
        move_normal(phobj);
        fht.limit_movement(phobj);
        break;
    case PhysicsObject::FLYING:
        move_flying(phobj);
        fht.limit_movement(phobj);
        break;
    case PhysicsObject::SWIMMING:
        move_swimming(phobj);
        fht.limit_movement(phobj);
        break;
    case PhysicsObject::FIXATED:
        break;
    case PhysicsObject::ICE:
        // TODO
        break;
    }

    // Move the object forward.
    phobj.move();
}

void Physics::move_normal(PhysicsObject& phobj) const
{
    phobj.v_acc = 0.0;
    phobj.h_acc = 0.0;
    if (phobj.on_ground) {
        phobj.v_acc += phobj.v_force;
        phobj.h_acc += phobj.h_force;

        if (phobj.h_acc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1) {
            phobj.hspeed = 0.0;
        } else {
            double inertia = phobj.hspeed / GROUNDSLIP;
            double slopef = phobj.fh_slope;
            if (slopef > 0.5) {
                slopef = 0.5;
            } else if (slopef < -0.5) {
                slopef = -0.5;
            }
            phobj.h_acc -= (FRICTION + SLOPEFACTOR * (1.0 + slopef * -inertia))
                           * inertia;
        }
    } else if (phobj.is_flag_not_set(PhysicsObject::NO_GRAVITY)) {
        phobj.v_acc += GRAVFORCE;
    }
    phobj.h_force = 0.0;
    phobj.v_force = 0.0;

    phobj.hspeed += phobj.h_acc;
    phobj.vspeed += phobj.v_acc;
}

void Physics::move_flying(PhysicsObject& phobj) const
{
    phobj.h_acc = phobj.h_force;
    phobj.v_acc = phobj.v_force;
    phobj.h_force = 0.0;
    phobj.v_force = 0.0;

    phobj.h_acc -= FLYFRICTION * phobj.hspeed;
    phobj.v_acc -= FLYFRICTION * phobj.vspeed;

    phobj.hspeed += phobj.h_acc;
    phobj.vspeed += phobj.v_acc;

    if (phobj.h_acc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1) {
        phobj.hspeed = 0.0;
    }

    if (phobj.v_acc == 0.0 && phobj.vspeed < 0.1 && phobj.vspeed > -0.1) {
        phobj.vspeed = 0.0;
    }
}

void Physics::move_swimming(PhysicsObject& phobj) const
{
    phobj.h_acc = phobj.h_force;
    phobj.v_acc = phobj.v_force;
    phobj.h_force = 0.0;
    phobj.v_force = 0.0;

    phobj.h_acc -= SWIMFRICTION * phobj.hspeed;
    phobj.v_acc -= SWIMFRICTION * phobj.vspeed;

    if (phobj.is_flag_not_set(PhysicsObject::NO_GRAVITY)) {
        phobj.v_acc += SWIMGRAVFORCE;
    }

    phobj.hspeed += phobj.h_acc;
    phobj.vspeed += phobj.v_acc;

    if (phobj.h_acc == 0.0 && phobj.hspeed < 0.1 && phobj.hspeed > -0.1) {
        phobj.hspeed = 0.0;
    }
    if (phobj.v_acc == 0.0 && phobj.vspeed < 0.1 && phobj.vspeed > -0.1) {
        phobj.vspeed = 0.0f;
    }
}

Point<std::int16_t> Physics::get_y_below(Point<std::int16_t> position) const
{
    std::int16_t ground = fht.get_y_below(position);
    return Point<std::int16_t>(position.x(), ground - 1);
}

const Footholdtree& Physics::get_fht() const
{
    return fht;
}
} // namespace jrc

```

`Gameplay/Physics/Physics.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "FootholdTree.h"

namespace jrc
{
// Class that uses physics engines and the collection of platforms to determine
// object movement.
class Physics
{
public:
    Physics(nl::node src);
    Physics();

    // Move the specified object over the specified game-time.
    void move_object(PhysicsObject& tomove) const;
    // Determine the point on the ground below the specified position.
    Point<std::int16_t> get_y_below(Point<std::int16_t> position) const;
    // Return a reference to the collection of platforms.
    const Footholdtree& get_fht() const;

private:
    void move_normal(PhysicsObject&) const;
    void move_flying(PhysicsObject&) const;
    void move_swimming(PhysicsObject&) const;

    Footholdtree fht;
};
} // namespace jrc

```

`Gameplay/Physics/PhysicsObject.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Constants.h"
#include "../../Template/Interpolated.h"
#include "../../Template/Point.h"
#include "../../Util/Misc.h"

namespace jrc
{
//! Struct that contains all properties for movement calculations.
struct MovingObject {
    Linear<double> x;
    Linear<double> y;
    double hspeed = 0.0;
    double vspeed = 0.0;

    void normalize()
    {
        x.normalize();
        y.normalize();
    }

    void move()
    {
        x += hspeed;
        y += vspeed;
    }

    void set_x(double d)
    {
        x.set(d);
    }

    void set_y(double d)
    {
        y.set(d);
    }

    void limit_x(double d)
    {
        x = d;
        hspeed = 0.0;
    }

    void limit_y(double d)
    {
        y = d;
        vspeed = 0.0;
    }

    void move_x_until(double d, std::uint16_t delay)
    {
        if (delay) {
            double h_delta = d - x.get();
            hspeed = Constants::TIMESTEP * h_delta / delay;
        }
    }

    void move_y_until(double d, std::uint16_t delay)
    {
        if (delay) {
            double v_delta = d - y.get();
            vspeed = Constants::TIMESTEP * v_delta / delay;
        }
    }

    bool h_mobile() const
    {
        return hspeed != 0.0;
    }

    bool v_mobile() const
    {
        return vspeed != 0.0;
    }

    bool mobile() const
    {
        return h_mobile() || v_mobile();
    }

    double crnt_x() const
    {
        return x.get();
    }

    double crnt_y() const
    {
        return y.get();
    }

    double next_x() const
    {
        return x + hspeed;
    }

    double next_y() const
    {
        return y + vspeed;
    }

    std::int16_t get_x() const
    {
        double rounded = std::round(x.get());
        return static_cast<std::int16_t>(rounded);
    }

    std::int16_t get_y() const
    {
        double rounded = std::round(y.get());
        return static_cast<std::int16_t>(rounded);
    }

    std::int16_t get_last_x() const
    {
        double rounded = std::round(x.last());
        return static_cast<std::int16_t>(rounded);
    }

    std::int16_t get_last_y() const
    {
        double rounded = std::round(y.last());
        return static_cast<std::int16_t>(rounded);
    }

    Point<std::int16_t> get_position() const
    {
        return {get_x(), get_y()};
    }

    std::int16_t get_absolute_x(double viewx, float alpha) const
    {
        double interx = x.normalized() ? std::round(x.get()) : x.get(alpha);
        return math::saturating_cast<std::int16_t>(std::round(interx + viewx));
    }

    std::int16_t get_absolute_y(double viewy, float alpha) const
    {
        double intery = y.normalized() ? std::round(y.get()) : y.get(alpha);
        return math::saturating_cast<std::int16_t>(std::round(intery + viewy));
    }

    Point<std::int16_t>
    get_absolute(double viewx, double viewy, float alpha) const
    {
        return {get_absolute_x(viewx, alpha), get_absolute_y(viewy, alpha)};
    }
};

//! Struct that contains all properties neccessary for physics calculations.
struct PhysicsObject : public MovingObject {
    //! Determines which physics engine to use.
    enum Type { NORMAL, ICE, SWIMMING, FLYING, FIXATED };

    enum Flag : std::uint32_t {
        NO_GRAVITY = 0x00'00'00'01,
        TURN_AT_EDGES = 0x00'00'00'02,
        CHECK_BELOW = 0x00'00'00'04
    };

    Type type = NORMAL;
    std::uint32_t flags = 0;
    std::uint16_t fh_id = 0;
    double fh_slope = 0.0;
    std::int8_t fh_layer = 0;
    double ground_below = 0.0;
    bool on_ground = true;
    bool enable_jd = false;

    double h_force = 0.0;
    double v_force = 0.0;
    double h_acc = 0.0;
    double v_acc = 0.0;

    bool is_flag_set(Flag f)
    {
        return (flags & f) != 0;
    }

    bool is_flag_not_set(Flag f)
    {
        return !is_flag_set(f);
    }

    void set_flag(Flag f)
    {
        flags |= f;
    }

    void clear_flag(Flag f)
    {
        flags &= ~f;
    }

    void clear_flags()
    {
        flags = 0;
    }
};
} // namespace jrc

```

`Gameplay/Playable.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../IO/KeyAction.h"

namespace jrc
{
//! Interface for classes which can be controlled through key inputs.
class Playable
{
public:
    virtual ~Playable() = default;

    //! Sends a key_state to the object.
    virtual void send_action(KeyAction::Id action, bool pressed) = 0;
};
} // namespace jrc

```

`Gameplay/Spawn.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Spawn.h"

#include "../Character/OtherChar.h"
#include "MapleMap/ItemDrop.h"
#include "MapleMap/MesoDrop.h"
#include "MapleMap/Mob.h"
#include "MapleMap/Npc.h"
#include "MapleMap/Reactor.h"

namespace jrc
{
NpcSpawn::NpcSpawn(std::int32_t o,
                   std::int32_t i,
                   Point<std::int16_t> p,
                   bool fl,
                   std::uint16_t f)
    : oid(o), id(i), position(p), flip(fl), fh(f)
{
}

std::int32_t NpcSpawn::get_oid() const
{
    return oid;
}

std::unique_ptr<MapObject> NpcSpawn::instantiate(const Physics& physics) const
{
    auto spawnposition = physics.get_y_below(position);
    return std::make_unique<Npc>(id, oid, flip, fh, false, spawnposition);
}

MobSpawn::MobSpawn(std::int32_t o,
                   std::int32_t i,
                   std::int8_t m,
                   std::int8_t st,
                   std::uint16_t f,
                   bool ns,
                   std::int8_t t,
                   Point<std::int16_t> p)
    : oid(o),
      id(i),
      mode(m),
      stance(st),
      fh(f),
      newspawn(ns),
      team(t),
      position(p)
{
}

std::int8_t MobSpawn::get_mode() const
{
    return mode;
}

std::int32_t MobSpawn::get_oid() const
{
    return oid;
}

std::unique_ptr<MapObject> MobSpawn::instantiate() const
{
    return std::make_unique<Mob>(
        oid, id, mode, stance, fh, newspawn, team, position);
}

ReactorSpawn::ReactorSpawn(std::int32_t o,
                           std::int32_t r,
                           std::int8_t s,
                           Point<std::int16_t> p)
    : oid(o), rid(r), state(s), position(p)
{
}

std::int32_t ReactorSpawn::get_oid() const
{
    return oid;
}

std::unique_ptr<MapObject>
ReactorSpawn::instantiate(const Physics& physics) const
{
    auto spawnposition = physics.get_y_below(position);
    return std::make_unique<Reactor>(oid, rid, state, spawnposition);
}

DropSpawn::DropSpawn(std::int32_t o,
                     std::int32_t i,
                     bool ms,
                     std::int32_t ow,
                     Point<std::int16_t> p,
                     Point<std::int16_t> d,
                     std::int8_t t,
                     std::int8_t m,
                     bool pd)
    : oid(o),
      id(i),
      meso(ms),
      owner(ow),
      start(p),
      dest(d),
      droptype(t),
      mode(m),
      playerdrop(pd)
{
}

bool DropSpawn::is_meso() const
{
    return meso;
}

std::int32_t DropSpawn::get_itemid() const
{
    return id;
}

std::int32_t DropSpawn::get_oid() const
{
    return oid;
}

std::unique_ptr<MapObject> DropSpawn::instantiate(const Animation& icon) const
{
    return std::make_unique<MesoDrop>(
        oid, owner, start, dest, droptype, mode, playerdrop, icon);
}

std::unique_ptr<MapObject> DropSpawn::instantiate(const Texture& icon) const
{
    return std::make_unique<ItemDrop>(
        oid, owner, start, dest, droptype, mode, id, playerdrop, icon);
}

CharSpawn::CharSpawn(std::int32_t c,
                     const LookEntry& lk,
                     std::uint8_t l,
                     std::int16_t j,
                     const std::string& nm,
                     std::int8_t st,
                     Point<std::int16_t> p)
    : cid(c), level(l), job(j), name(nm), stance(st), position(p), look(lk)
{
}

std::int32_t CharSpawn::get_cid() const
{
    return cid;
}

std::unique_ptr<MapObject> CharSpawn::instantiate() const
{
    return std::make_unique<OtherChar>(
        cid, look, level, job, std::string{name}, stance, position);
}
} // namespace jrc

```

`Gameplay/Spawn.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Animation.h"
#include "../Net/Login.h"
#include "MapleMap/MapObject.h"

#include <cstdint>
#include <memory>

namespace jrc
{
class NpcSpawn
{
public:
    NpcSpawn(std::int32_t oid,
             std::int32_t npcid,
             Point<std::int16_t> position,
             bool mirrored,
             std::uint16_t fh);

    std::int32_t get_oid() const;
    std::unique_ptr<MapObject> instantiate(const Physics& physics) const;

private:
    std::int32_t oid;
    std::int32_t id;
    Point<std::int16_t> position;
    bool flip;
    std::uint16_t fh;
};

class MobSpawn
{
public:
    MobSpawn(std::int32_t oid,
             std::int32_t id,
             std::int8_t mode,
             std::int8_t stance,
             std::uint16_t fh,
             bool newspawn,
             std::int8_t team,
             Point<std::int16_t> position);

    std::int8_t get_mode() const;
    std::int32_t get_oid() const;
    std::unique_ptr<MapObject> instantiate() const;

private:
    std::int32_t oid;
    std::int32_t id;
    std::int8_t mode;
    std::int8_t stance;
    std::uint16_t fh;
    bool newspawn;
    std::int8_t team;
    Point<std::int16_t> position;
};

class ReactorSpawn
{
public:
    ReactorSpawn(std::int32_t oid,
                 std::int32_t rid,
                 std::int8_t state,
                 Point<std::int16_t> position);

    std::int32_t get_oid() const;
    std::unique_ptr<MapObject> instantiate(const Physics& physics) const;

private:
    std::int32_t oid;
    std::int32_t rid;
    std::int8_t state;
    Point<std::int16_t> position;
};

class DropSpawn
{
public:
    DropSpawn(std::int32_t oid,
              std::int32_t id,
              bool meso,
              std::int32_t owner,
              Point<std::int16_t> position,
              Point<std::int16_t> destination,
              std::int8_t droptype,
              std::int8_t mode,
              bool playerdrop);

    bool is_meso() const;
    std::int32_t get_itemid() const;
    std::int32_t get_oid() const;
    std::unique_ptr<MapObject> instantiate(const Animation& icon) const;
    std::unique_ptr<MapObject> instantiate(const Texture& icon) const;

private:
    std::int32_t oid;
    std::int32_t id;
    bool meso;
    std::int32_t owner;
    Point<std::int16_t> start;
    Point<std::int16_t> dest;
    std::int8_t droptype;
    std::int8_t mode;
    bool playerdrop;
};

class CharSpawn
{
public:
    CharSpawn(std::int32_t cid,
              const LookEntry& look,
              std::uint8_t level,
              std::int16_t job,
              const std::string& name,
              std::int8_t stance,
              Point<std::int16_t> position);

    std::int32_t get_cid() const;
    std::unique_ptr<MapObject> instantiate() const;

private:
    std::int32_t cid;
    std::uint8_t level;
    std::int16_t job;
    std::string name;
    std::int8_t stance;
    Point<std::int16_t> position;
    LookEntry look;
};
} // namespace jrc

```

`Gameplay/Stage.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Stage.h"

#include "../Audio/Audio.h"
#include "../Character/SkillId.h"
#include "../IO/Messages.h"
#include "../Net/Packets/AttackAndSkillPackets.h"
#include "../Net/Packets/GameplayPackets.h"
#include "../Util/Misc.h"
#include "nlnx/nx.hpp"

#include <iostream>

namespace jrc
{
Stage::Stage() : combat(player, chars, mobs)
{
    state = INACTIVE;
}

void Stage::init()
{
    drops.init();
}

void Stage::load(std::int32_t map_id, std::int8_t portal_id)
{
    switch (state) {
    case INACTIVE:
        load_map(map_id);
        respawn(portal_id);
        break;
    case TRANSITION:
        respawn(portal_id);
        break;
    case ACTIVE:
        break;
    }

    state = ACTIVE;
}

void Stage::loadplayer(const CharEntry& entry)
{
    player = entry;
    playable = player;
}

void Stage::clear()
{
    state = INACTIVE;

    chars.clear();
    npcs.clear();
    mobs.clear();
    drops.clear();
    reactors.clear();
}

void Stage::load_map(std::int32_t map_id)
{
    std::string str_id = string_format::extend_id(map_id, 9);
    str_id += ".img";

    nl::node src
        = nl::nx::map["Map"]["Map" + std::to_string(map_id / 100'000'000)]
                     [str_id];

    tiles_objs = MapTilesObjs(src);
    backgrounds = MapBackgrounds(src["back"]);
    physics = Physics(src["foothold"]);
    map_info = {
        src, physics.get_fht().get_walls(), physics.get_fht().get_borders()};
    portals = MapPortals(src["portal"], map_id);
}

void Stage::respawn(std::int8_t portal_id)
{
    std::string bgm_path = map_info.get_bgm();
    if (auto mus_err = Music::play(bgm_path); mus_err) {
        Console::get().print("Error playing music " + bgm_path);
    }

    Point<std::int16_t> spawn_point
        = portals.get_portal_by_id(static_cast<std::uint8_t>(portal_id));
    Point<std::int16_t> start_pos = physics.get_y_below(spawn_point);

    player.respawn(start_pos, map_info.is_underwater());
    camera.set_position(start_pos);
    camera.set_view(map_info.get_walls(), map_info.get_borders());
}

void Stage::draw(float alpha) const
{
    if (state != ACTIVE) {
        return;
    }

    Point<std::int16_t> viewpos = camera.position(alpha);
    Point<double> viewrpos = camera.realposition(alpha);
    double viewx = viewrpos.x();
    double viewy = viewrpos.y();

    backgrounds.drawbackgrounds(viewx, viewy, alpha);
    for (auto id : Layer::IDs) {
        tiles_objs.draw(id, viewpos, alpha);
        reactors.draw(id, viewx, viewy, alpha);
        npcs.draw(id, viewx, viewy, alpha);
        mobs.draw(id, viewx, viewy, alpha);
        chars.draw(id, viewx, viewy, alpha);
        player.draw(id, viewx, viewy, alpha);
        drops.draw(id, viewx, viewy, alpha);
    }
    combat.draw(viewx, viewy, alpha);
    portals.draw(viewpos, alpha);
    backgrounds.drawforegrounds(viewx, viewy, alpha);
}

void Stage::update()
{
    if (state != ACTIVE) {
        return;
    }

    combat.update();
    backgrounds.update();
    tiles_objs.update();

    reactors.update(physics);
    npcs.update(physics);
    mobs.update(physics);
    chars.update(physics);
    drops.update(physics);
    player.update(physics);

    portals.update(player.get_position());
    camera.update(player.get_position());

    if (player.is_invincible()) {
        return;
    }

    if (std::int32_t oid_id = mobs.find_colliding(player.get_phobj())) {
        if (MobAttack attack = mobs.create_attack(oid_id)) {
            MobAttackResult result = player.damage(attack);
            TakeDamagePacket{result, TakeDamagePacket::TOUCH}.dispatch();
        }
    }
}

void Stage::show_character_effect(std::int32_t cid, CharEffect::Id effect)
{
    if (auto character = get_character(cid)) {
        character->show_effect_id(effect);
    }
}

void Stage::check_portals()
{
    if (player.is_attacking()) {
        return;
    }

    Point<std::int16_t> playerpos = player.get_position();
    Portal::WarpInfo warpinfo = portals.find_warp_at(playerpos);
    if (warpinfo.intramap) {
        Point<std::int16_t> spawnpoint
            = portals.get_portal_by_name(warpinfo.to_name);
        Point<std::int16_t> startpos = physics.get_y_below(spawnpoint);
        player.respawn(startpos, map_info.is_underwater());
    } else if (warpinfo.valid) {
        ChangeMapPacket{false, warpinfo.mapid, warpinfo.name, false}
            .dispatch();
    }
}

void Stage::check_seats()
{
    if (player.is_sitting() || player.is_attacking()) {
        return;
    }

    nullable_ptr<const Seat> seat = map_info.find_seat(player.get_position());
    player.set_seat(seat);
}

void Stage::check_ladders(bool up)
{
    if (player.is_climbing() || player.is_attacking()) {
        return;
    }

    nullable_ptr<const Ladder> ladder
        = map_info.find_ladder(player.get_position(), up);
    player.set_ladder(ladder);
}

void Stage::check_drops()
{
    Point<std::int16_t> playerpos = player.get_position();
    MapDrops::Loot loot = drops.find_loot_at(playerpos);
    if (loot.first) {
        PickupItemPacket(loot.first, loot.second).dispatch();
    }
}

void Stage::send_key(KeyType::Id type, std::int32_t action, bool down)
{
    if (state != ACTIVE || !playable) {
        return;
    }

    switch (type) {
    case KeyType::ACTION:
        if (down) {
            switch (action) {
            case KeyAction::UP:
                check_ladders(true);
                check_portals();
                break;
            case KeyAction::DOWN:
                check_ladders(false);
                break;
            case KeyAction::SIT:
                check_seats();
                break;
            case KeyAction::ATTACK:
                combat.use_move(0);
                break;
            case KeyAction::PICK_UP:
                check_drops();
                break;
            default:
                break;
            }
        }

        playable->send_action(KeyAction::action_by_id(action), down);
        break;
    case KeyType::SKILL:
        combat.use_move(action);
        break;
    case KeyType::ITEM:
        player.use_item(action);
        break;
    case KeyType::FACE:
        player.set_expression(action);
        break;
    default:
        break;
    }
}

Cursor::State Stage::send_cursor(bool pressed, Point<std::int16_t> position)
{
    return npcs.send_cursor(pressed, position, camera.position());
}

bool Stage::is_player(std::int32_t cid) const
{
    return cid == player.get_oid();
}

MapNpcs& Stage::get_npcs()
{
    return npcs;
}

MapChars& Stage::get_chars()
{
    return chars;
}

MapMobs& Stage::get_mobs()
{
    return mobs;
}

MapReactors& Stage::get_reactors()
{
    return reactors;
}

MapDrops& Stage::get_drops()
{
    return drops;
}

Player& Stage::get_player()
{
    return player;
}

Combat& Stage::get_combat()
{
    return combat;
}

nullable_ptr<Char> Stage::get_character(std::int32_t cid)
{
    if (is_player(cid)) {
        return player;
    } else {
        return chars.get_char(cid);
    }
}

std::uint8_t Stage::get_world() const noexcept
{
    return world;
}

void Stage::set_world(std::uint8_t world_id) noexcept
{
    world = world_id;
}

std::uint8_t Stage::get_channel() const noexcept
{
    return channel;
}

void Stage::set_channel(std::uint8_t chan) noexcept
{
    channel = chan;
}

std::uint8_t Stage::get_channel_count() const noexcept
{
    return channel_count;
}

void Stage::set_channel_count(std::uint8_t ch_count) noexcept
{
    channel_count = ch_count;
}
} // namespace jrc

```

`Gameplay/Stage.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Character/Player.h"
#include "../IO/KeyType.h"
#include "../Template/Singleton.h"
#include "../Template/TimedQueue.h"
#include "Camera.h"
#include "Combat/Combat.h"
#include "MapleMap/MapBackgrounds.h"
#include "MapleMap/MapChars.h"
#include "MapleMap/MapDrops.h"
#include "MapleMap/MapInfo.h"
#include "MapleMap/MapMobs.h"
#include "MapleMap/MapNpcs.h"
#include "MapleMap/MapPortals.h"
#include "MapleMap/MapReactors.h"
#include "MapleMap/MapTilesObjs.h"
#include "Physics/Physics.h"
#include "Spawn.h"

namespace jrc
{
class Stage : public Singleton<Stage>
{
public:
    Stage();

    void init();

    //! Loads the map to be displayed.
    void load(std::int32_t map_id, std::int8_t portal_id);
    //! Removes all map objects and graphics.
    void clear();

    //! Contructs the player from a character entry.
    void loadplayer(const CharEntry& entry);

    //! Calls `draw(float)` on all objects that are on this `Stage`.
    void draw(float alpha) const;
    //! Calls `update()` on all objects that are on this `Stage`.
    void update();

    //! Show a character effect.
    void show_character_effect(std::int32_t cid, CharEffect::Id effect);

    //! Send key input to the stage.
    void send_key(KeyType::Id keytype, std::int32_t keycode, bool pressed);
    //! Send mouse input to the stage.
    Cursor::State send_cursor(bool pressed, Point<std::int16_t> position);

    //! Check if the specified ID is the player's ID.
    bool is_player(std::int32_t cid) const;

    //! Returns a reference to the NPCs on the current map.
    MapNpcs& get_npcs();
    //! Returns a reference to the other characters on the current map.
    MapChars& get_chars();
    //! Returns a reference to the mobs on the current map.
    MapMobs& get_mobs();
    //! Returns a reference to the reactors on the current map.
    MapReactors& get_reactors();
    //! Returns a reference to the drops on the current map.
    MapDrops& get_drops();
    //! Returns a reference to the Player.
    Player& get_player();
    //! Return a reference to the attack and buff component.
    Combat& get_combat();

    //! Return a pointer to a character, possibly the player.
    nullable_ptr<Char> get_character(std::int32_t cid);

    //! Getter for the ID of the current world.
    [[nodiscard]] std::uint8_t get_world() const noexcept;
    //! Setter for the ID of the current world.
    void set_world(std::uint8_t world_id) noexcept;

    //! Getter for the ID of the current channel.
    [[nodiscard]] std::uint8_t get_channel() const noexcept;
    //! Setter for the ID of the current channel.
    void set_channel(std::uint8_t chan) noexcept;

    //! Getter for the number of channels in the current world.
    [[nodiscard]] std::uint8_t get_channel_count() const noexcept;
    //! Setter for the number of channels in the current world.
    void set_channel_count(std::uint8_t ch_count) noexcept;

private:
    void load_map(std::int32_t map_id);
    void respawn(std::int8_t portal_id);
    void check_portals();
    void check_seats();
    void check_ladders(bool up);
    void check_drops();

    enum State { INACTIVE, TRANSITION, ACTIVE };

    Camera camera;
    Physics physics;
    Player player;

    nullable_ptr<Playable> playable;

    MapInfo map_info;
    MapTilesObjs tiles_objs;
    MapBackgrounds backgrounds;
    MapPortals portals;
    MapReactors reactors;
    MapNpcs npcs;
    MapChars chars;
    MapMobs mobs;
    MapDrops drops;

    Combat combat;

    State state;
    std::uint8_t world;
    std::uint8_t channel;
    std::uint8_t channel_count;
};
} // namespace jrc

```

`Graphics/Animation.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Animation.h"

#include "../Constants.h"
#include "../Util/Misc.h"

namespace jrc
{
Frame::Frame(nl::node src) : texture{src}, bounds{src}
{
    head = src["head"];
    delay = src["delay"];
    bool no_delay = false;
    if (delay == 0) {
        delay = 100;
        no_delay = true;
    }

    bool has_a0 = src["a0"].data_type() == nl::node::type::integer;
    bool has_a1 = src["a1"].data_type() == nl::node::type::integer;
    if (has_a0 && has_a1) {
        opacities = {src["a0"], src["a1"]};
    } else if (has_a0) {
        std::uint8_t a0 = src["a0"];
        opacities = {a0, no_delay ? a0 : 255 - a0};
    } else if (has_a1) {
        std::uint8_t a1 = src["a1"];
        opacities = {no_delay ? a1 : 255 - a1, a1};
    } else {
        opacities = {255, 255};
    }

    bool has_z0 = src["z0"].data_type() == nl::node::type::integer;
    bool has_z1 = src["z1"].data_type() == nl::node::type::integer;
    if (has_z0 && has_z1) {
        scales = {src["z0"], src["z1"]};
    } else if (has_z0) {
        scales = {src["z0"], no_delay ? src["z0"] : 0};
    } else if (has_z1) {
        scales = {no_delay ? src["z1"] : 100, src["z1"]};
    } else {
        scales = {100, 100};
    }
}

Frame::Frame() noexcept : delay{0}, opacities{0, 0}, scales{0, 0}
{
}

void Frame::draw(const DrawArgument& args) const
{
    texture.draw(args);
}

std::uint8_t Frame::start_opacity() const
{
    return opacities.first;
}

std::uint8_t Frame::end_opacity() const
{
    return opacities.second;
}

std::uint16_t Frame::start_scale() const
{
    return static_cast<std::uint16_t>(scales.first);
}

std::uint16_t Frame::end_scale() const
{
    return static_cast<std::uint16_t>(scales.second);
}

std::uint16_t Frame::get_delay() const
{
    return delay;
}

Point<std::int16_t> Frame::get_origin() const
{
    return texture.get_origin();
}

Point<std::int16_t> Frame::get_dimensions() const
{
    return texture.get_dimensions();
}

Point<std::int16_t> Frame::get_head() const
{
    return head;
}

Rectangle<std::int16_t> Frame::get_bounds() const
{
    return bounds;
}

float Frame::opc_step(std::uint16_t timestep) const
{
    if (delay == 0) {
        return 0.0f;
    }

    return timestep * static_cast<float>(opacities.second - opacities.first)
           / delay;
}

float Frame::scale_step(std::uint16_t timestep) const
{
    if (delay == 0) {
        return 0.0f;
    }

    return timestep * static_cast<float>(scales.second - scales.first) / delay;
}

Animation::Animation(nl::node src) : finished(false)
{
    bool is_texture = src.data_type() == nl::node::type::bitmap;
    if (is_texture) {
        frames.emplace_back(src);
    } else {
        std::vector<std::int16_t> frame_ids;
        frame_ids.reserve(src.size());
        for (auto sub : src) {
            if (sub.data_type() == nl::node::type::bitmap) {
                auto fid = string_conversion::or_default<std::int16_t>(
                    sub.name(), -1);
                if (fid >= 0) {
                    frame_ids.push_back(fid);
                }
            }
        }
        std::sort(frame_ids.begin(), frame_ids.end());

        for (auto fid : frame_ids) {
            frames.emplace_back(src[fid]);
        }

        if (frames.empty()) {
            frames.emplace_back();
        }
    }

    animated = frames.size() > 1;
    zigzag = src["zigzag"].get_bool();
    repeat = src["repeat"];

    reset();
}

Animation::Animation() noexcept
    : animated(false), zigzag(false), finished(true)
{
    frames.emplace_back();

    reset();
}

void Animation::reset()
{
    frame.set(0);
    opacity.set(frames[0].start_opacity());
    xy_scale.set(frames[0].start_scale());
    delay = frames[0].get_delay();
    frame_step = 1;
}

void Animation::draw(const DrawArgument& args, float alpha) const
{
    std::int16_t interframe = frame.get(alpha);
    float inter_opc = opacity.get(alpha) / 255.0f;
    float inter_scale = xy_scale.get(alpha) / 100.0f;

    bool modify_opc = inter_opc != 1.0f;
    bool modify_scale = inter_scale != 1.0f;
    if (modify_opc || modify_scale) {
        frames[interframe].draw(
            args + DrawArgument{inter_scale, inter_scale, inter_opc});
    } else {
        frames[interframe].draw(args);
    }
}

bool Animation::update()
{
    return update(Constants::TIMESTEP);
}

bool Animation::update(std::uint16_t timestep)
{
    if (finished) {
        return true;
    }

    const Frame& frame_data = get_frame();

    opacity += frame_data.opc_step(timestep);
    if (opacity.last() < 0.0f) {
        opacity.set(0.0f);
    } else if (opacity.last() > 255.0f) {
        opacity.set(255.0f);
    }

    xy_scale += frame_data.scale_step(timestep);
    if (xy_scale.last() < 0.0f) {
        opacity.set(0.0f);
    }

    if (timestep >= delay) {
        auto last_frame = static_cast<std::int16_t>(frames.size() - 1);
        std::int16_t next_frame;
        bool ended;
        if (zigzag && last_frame > 0) {
            if (frame_step == 1 && frame == last_frame) {
                frame_step = -frame_step;
                ended = false;
            } else if (frame_step == -1 && frame == 0) {
                frame_step = -frame_step;
                ended = true;
            } else {
                ended = false;
            }

            next_frame = frame + frame_step;
        } else {
            if (frame == last_frame) {
                next_frame = 0;
                ended = true;
            } else {
                next_frame = frame + 1;
                ended = false;
            }
        }

        if (ended && repeat == -1) {
            finished = true;

            opacity.set(frames[last_frame].end_opacity());
            xy_scale.set(frames[last_frame].end_scale());
        } else {
            std::uint16_t delta = timestep - delay;
            float threshold = static_cast<float>(delta) / timestep;
            frame.next(next_frame, threshold);

            delay = frames[next_frame].get_delay();
            if (delay >= delta) {
                delay -= delta;
            }

            opacity.set(frames[next_frame].start_opacity());
            xy_scale.set(frames[next_frame].start_scale());
        }

        return ended;
    }

    frame.normalize();
    delay -= timestep;

    return false;
}

std::uint16_t Animation::get_delay(std::int16_t frame_id) const
{
    return frame_id < static_cast<std::int16_t>(frames.size())
               ? frames[frame_id].get_delay()
               : 0u;
}

std::uint16_t Animation::get_delay_until(std::int16_t frame_id) const
{
    std::uint16_t total = 0;
    for (std::int16_t i = 0; i < frame_id; ++i) {
        if (i >= static_cast<std::int16_t>(frames.size())) {
            break;
        }

        total += frames[frame_id].get_delay();
    }

    return total;
}

Point<std::int16_t> Animation::get_origin() const
{
    return get_frame().get_origin();
}

Point<std::int16_t> Animation::get_dimensions() const
{
    return get_frame().get_dimensions();
}

Point<std::int16_t> Animation::get_head() const
{
    return get_frame().get_head();
}

Rectangle<std::int16_t> Animation::get_bounds() const
{
    return get_frame().get_bounds();
}

const Frame& Animation::get_frame() const
{
    return frames[frame.get()];
}
} // namespace jrc

```

`Graphics/Animation.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Interpolated.h"
#include "../Template/Rectangle.h"
#include "Texture.h"

#include <algorithm>
#include <vector>

namespace jrc
{
//! A single frame within an animation.
class Frame
{
public:
    Frame(nl::node src);
    Frame() noexcept;

    void draw(const DrawArgument& args) const;

    std::uint8_t start_opacity() const;
    std::uint8_t end_opacity() const;
    std::uint16_t start_scale() const;
    std::uint16_t end_scale() const;
    std::uint16_t get_delay() const;
    Point<std::int16_t> get_origin() const;
    Point<std::int16_t> get_dimensions() const;
    Point<std::int16_t> get_head() const;
    Rectangle<std::int16_t> get_bounds() const;
    float opc_step(std::uint16_t timestep) const;
    float scale_step(std::uint16_t timestep) const;

private:
    Texture texture;
    std::uint16_t delay;
    std::pair<std::uint8_t, std::uint8_t> opacities;
    std::pair<std::int16_t, std::int16_t> scales;
    Rectangle<std::int16_t> bounds;
    Point<std::int16_t> head;
};

//! Class which consists of multiple textures to make an Animation.
class Animation
{
public:
    Animation(nl::node source);
    Animation() noexcept;

    bool update();
    bool update(std::uint16_t timestep);
    void reset();

    void draw(const DrawArgument& arguments, float inter) const;

    std::uint16_t get_delay(std::int16_t frame) const;
    std::uint16_t get_delay_until(std::int16_t frame) const;
    Point<std::int16_t> get_origin() const;
    Point<std::int16_t> get_dimensions() const;
    Point<std::int16_t> get_head() const;
    Rectangle<std::int16_t> get_bounds() const;

private:
    const Frame& get_frame() const;

    std::vector<Frame> frames;
    bool animated;
    bool zigzag;

    Nominal<std::int16_t> frame;
    Linear<float> opacity;
    Linear<float> xy_scale;

    std::uint16_t delay;
    std::int16_t frame_step;
    float opcstep;

    std::int16_t repeat;
    bool finished;
};
} // namespace jrc

```

`Graphics/Color.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Color.h"

#include "../Util/Lerp.h"

#include <algorithm>

namespace jrc
{
const float* Color::data() const
{
    return rgba.data();
}

Color::underlying_t::const_iterator Color::begin() const
{
    return rgba.begin();
}

Color::underlying_t::const_iterator Color::end() const
{
    return rgba.end();
}

Color Color::blend(const Color& other, float alpha) const
{
    underlying_t blended;
    std::transform(begin(),
                   end(),
                   other.begin(),
                   blended.begin(),
                   [alpha](float f, float s) { return lerp(f, s, alpha); });
    return blended;
}
} // namespace jrc

```

`Graphics/Color.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <array>
#include <cstdint>

namespace jrc
{
//! Simple color class which stores RGBA components.
class Color
{
public:
    static constexpr const std::size_t LENGTH = 4;
    using underlying_t = std::array<float, LENGTH>;

    //! Codes of predefined colors.
    enum Code : std::uint32_t {
        NONE = 0x00000000,
        WHITE = 0xFFFFFFFF,
        BLACK = 0x000000FF,
        RED = 0xFF0000FF,
        GREEN = 0x00FF00FF,
        BLUE = 0x0000FFFF,
        YELLOW = 0xFFFF00FF,
        TURQUOISE = 0x00FFFFFF,
        PURPLE = 0xFF00FFFF
    };

    //! Create a color by an array of real numbers [0.0f, 1.0f].
    constexpr Color(underlying_t comps) : rgba(comps)
    {
    }
    //! Create a color by four real numbers [0.0f, 1.0f].
    constexpr Color(float red, float green, float blue, float alpha)
        : Color(underlying_t{{red, green, blue, alpha}})
    {
    }
    //! Create a color by an array of natural numbers [0, 255].
    constexpr Color(const std::array<std::uint8_t, Color::LENGTH> comps)
        : Color(comps[0], comps[1], comps[2], comps[3])
    {
    }
    //! Create a color by four natural numbers [0, 255].
    constexpr Color(std::uint8_t red,
                    std::uint8_t green,
                    std::uint8_t blue,
                    std::uint8_t alpha)
        : Color(static_cast<float>(red) / 255,
                static_cast<float>(green) / 255,
                static_cast<float>(blue) / 255,
                static_cast<float>(alpha) / 255)
    {
    }
    //! Create a color by code.
    constexpr Color(std::uint32_t code)
        : Color(static_cast<std::uint8_t>(code >> 24),
                static_cast<std::uint8_t>(code >> 16),
                static_cast<std::uint8_t>(code >> 8),
                static_cast<std::uint8_t>(code))
    {
    }
    //! Create a color by named code.
    constexpr Color(Code code) : Color((std::uint32_t)code)
    {
    }
    constexpr Color() : Color(NONE)
    {
    }

    //! Check whether the color is completely invisble.
    constexpr bool invisible() const
    {
        return rgba[3] <= 0.0f;
    }

    //! Return the red component.
    constexpr float r() const
    {
        return rgba[0];
    }

    //! Return the green component.
    constexpr float g() const
    {
        return rgba[1];
    }

    //! Return the blue component.
    constexpr float b() const
    {
        return rgba[2];
    }

    //! Return the alpha (opacity) component.
    constexpr float a() const
    {
        return rgba[3];
    }

    //! Return all components.
    const float* data() const;

    //! Return a begin iterator.
    underlying_t::const_iterator begin() const;

    //! Return an end iterator.
    underlying_t::const_iterator end() const;

    //! Blend the second color into the first.
    Color blend(const Color& other, float alpha) const;

    //! Combine two colors.
    constexpr Color operator*(const Color& o) const
    {
        return {r() * o.r(), g() * o.g(), b() * o.b(), a() * o.a()};
    }

    //! Combine two colors.
    constexpr Color operator/(const Color& o) const
    {
        return {r() / o.r(), g() / o.g(), b() / o.b(), a() / o.a()};
    }

private:
    underlying_t rgba;
};
} // namespace jrc

```

`Graphics/DrawArgument.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Rectangle.h"
#include "Color.h"

namespace jrc
{
class DrawArgument
{
public:
    constexpr DrawArgument() noexcept : DrawArgument(0, 0)
    {
    }

    constexpr DrawArgument(std::int16_t x, std::int16_t y) noexcept
        : DrawArgument(Point<std::int16_t>{x, y})
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p) noexcept
        : DrawArgument(p, 1.0f)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p, float xs, float ys) noexcept
        : DrawArgument(p, p, xs, ys, 1.0f)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           Point<std::int16_t> s) noexcept
        : DrawArgument(p, p, s, 1.0f, 1.0f, 1.0f, 0.0f)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p, bool flip) noexcept
        : DrawArgument(p, flip, 1.0f)
    {
    }

    constexpr DrawArgument(float ang,
                           Point<std::int16_t> p,
                           float opc) noexcept
        : DrawArgument(ang, p, false, opc)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p, float opc) noexcept
        : DrawArgument(p, false, opc)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p, Color color) noexcept
        : DrawArgument(p, p, {}, 1.0f, 1.0f, color, 0.0f)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           bool flip,
                           Point<std::int16_t> c) noexcept
        : DrawArgument(p, c, flip ? -1.0f : 1.0f, 1.0f, 1.0f)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           Point<std::int16_t> c,
                           float xs,
                           float ys,
                           float opc) noexcept
        : DrawArgument(p, c, {}, xs, ys, opc, 0.0f)
    {
    }

    constexpr DrawArgument(bool flip) noexcept
        : DrawArgument(flip ? -1.0f : 1.0f, 1.0f, 1.0f)
    {
    }

    constexpr DrawArgument(float xs, float ys, float opc) noexcept
        : DrawArgument({}, xs, ys, opc)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           float xs,
                           float ys,
                           float opc) noexcept
        : DrawArgument(p, p, xs, ys, opc)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           bool flip,
                           float opc) noexcept
        : DrawArgument(p, p, flip ? -1.0f : 1.0f, 1.0f, opc)
    {
    }

    constexpr DrawArgument(float ang,
                           Point<std::int16_t> p,
                           bool flip,
                           float opc) noexcept
        : DrawArgument(p, p, {}, flip ? -1.0f : 1.0f, 1.0f, opc, ang)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           Point<std::int16_t> c,
                           Point<std::int16_t> s,
                           float xs,
                           float ys,
                           float opc,
                           float ang) noexcept
        : color(1.0f, 1.0f, 1.0f, opc),
          pos(p),
          center(c),
          stretch(s),
          xscale(xs),
          yscale(ys),
          angle(ang)
    {
    }

    constexpr DrawArgument(Point<std::int16_t> p,
                           Point<std::int16_t> c,
                           Point<std::int16_t> s,
                           float xs,
                           float ys,
                           Color color,
                           float ang) noexcept
        : color(color),
          pos(p),
          center(c),
          stretch(s),
          xscale(xs),
          yscale(ys),
          angle(ang)
    {
    }

    constexpr Point<std::int16_t> getpos() const noexcept
    {
        return pos;
    }

    constexpr Point<std::int16_t> getstretch() const noexcept
    {
        return stretch;
    }

    constexpr float get_xscale() const noexcept
    {
        return xscale;
    }

    constexpr float get_yscale() const noexcept
    {
        return yscale;
    }

    constexpr const Color& get_color() const noexcept
    {
        return color;
    }

    constexpr float get_angle() const noexcept
    {
        return angle;
    }

    constexpr DrawArgument operator+(Point<std::int16_t> argpos) const noexcept
    {
        return {pos + argpos,
                center + argpos,
                stretch,
                xscale,
                yscale,
                color,
                angle};
    }

    constexpr DrawArgument operator+(float argopc) const noexcept
    {
        return {
            pos, center, stretch, xscale, yscale, color.a() * argopc, angle};
    }

    constexpr DrawArgument operator+(const DrawArgument& o) const noexcept
    {
        return {pos + o.pos,
                center + o.center,
                stretch + o.stretch,
                xscale * o.xscale,
                yscale * o.yscale,
                color * o.color,
                angle + o.angle};
    }

    constexpr DrawArgument operator-(const DrawArgument& o) const noexcept
    {
        return {pos - o.pos,
                center - o.center,
                stretch - o.stretch,
                xscale / o.xscale,
                yscale / o.yscale,
                color / o.color,
                angle - o.angle};
    }

    constexpr Rectangle<std::int16_t>
    get_rectangle(Point<std::int16_t> origin,
                  Point<std::int16_t> dimensions) const noexcept
    {
        std::int16_t w = stretch.x();
        if (w == 0) {
            w = dimensions.x();
        }

        std::int16_t h = stretch.y();
        if (h == 0) {
            h = dimensions.y();
        }

        Point<std::int16_t> rlt = pos - center - origin;
        std::int16_t rl = rlt.x();
        std::int16_t rr = rlt.x() + w;
        std::int16_t rt = rlt.y();
        std::int16_t rb = rlt.y() + h;
        std::int16_t cx = center.x();
        std::int16_t cy = center.y();

        return {cx + static_cast<std::int16_t>(xscale * rl),
                cx + static_cast<std::int16_t>(xscale * rr),
                cy + static_cast<std::int16_t>(yscale * rt),
                cy + static_cast<std::int16_t>(yscale * rb)};
    }

private:
    Color color;
    Point<std::int16_t> pos;
    Point<std::int16_t> center;
    Point<std::int16_t> stretch;
    float xscale;
    float yscale;
    float angle;
};
} // namespace jrc

```

`Graphics/EffectLayer.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EffectLayer.h"

namespace jrc
{
void EffectLayer::draw_below(Point<std::int16_t> position, float alpha) const
{
    for (auto iter = effects.begin(); iter != effects.upper_bound(-1);
         ++iter) {
        for (auto& effect : iter->second) {
            effect.draw(position, alpha);
        }
    }
}

void EffectLayer::draw_above(Point<std::int16_t> position, float alpha) const
{
    for (auto iter = effects.upper_bound(-1); iter != effects.end(); ++iter) {
        for (auto& effect : iter->second) {
            effect.draw(position, alpha);
        }
    }
}

void EffectLayer::update()
{
    for (auto& [_, effect_list] : effects) {
        effect_list.erase(
            std::remove_if(effect_list.begin(),
                           effect_list.end(),
                           [](Effect& effect) { return effect.update(); }),
            effect_list.end());
    }
}

void EffectLayer::add(const Animation& animation,
                      const DrawArgument& args,
                      std::int8_t z,
                      float speed)
{
    effects[z].emplace_back(animation, args, speed);
}

void EffectLayer::add(const Animation& animation,
                      const DrawArgument& args,
                      std::int8_t z)
{
    add(animation, args, z, 1.0f);
}

void EffectLayer::add(const Animation& animation, const DrawArgument& args)
{
    add(animation, args, 0, 1.0f);
}

void EffectLayer::add(const Animation& animation)
{
    add(animation, {}, 0, 1.0f);
}
} // namespace jrc

```

`Graphics/EffectLayer.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Constants.h"
#include "Sprite.h"
#include "boost/container/flat_map.hpp"

#include <vector>

namespace jrc
{
//! A list of animations. Animations will be removed after all frames were
//! displayed.
class EffectLayer
{
public:
    //! Draws all effects with a z-value strictly less than 0.
    void draw_below(Point<std::int16_t> position, float alpha) const;
    //! Draws all effects with a z-value greater than or equal to 0.
    void draw_above(Point<std::int16_t> position, float alpha) const;
    //! Remove effects whose animations are done, i.e. they have expired.
    void update();
    void add(const Animation& effect,
             const DrawArgument& args,
             std::int8_t z,
             float speed);
    void add(const Animation& effect, const DrawArgument& args, std::int8_t z);
    void add(const Animation& effect, const DrawArgument& args);
    void add(const Animation& effect);

private:
    class Effect
    {
    public:
        Effect(const Animation& a, const DrawArgument& args, float s)
            : sprite(a, args), speed(s)
        {
        }

        void draw(Point<std::int16_t> position, float alpha) const
        {
            sprite.draw(position, alpha);
        }

        bool update()
        {
            return sprite.update(
                static_cast<std::uint16_t>(Constants::TIMESTEP * speed));
        }

    private:
        Sprite sprite;
        float speed;
    };

    //! Sorted map that associates z-indices (can be negative or non-negative)
    //! with the effects at that z-index.
    boost::container::flat_map<std::int8_t, std::vector<Effect>> effects;
};
} // namespace jrc

```

`Graphics/Geometry.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Geometry.h"

#include "GraphicsGL.h"

namespace jrc
{
void Geometry::draw(std::int16_t x,
                    std::int16_t y,
                    std::int16_t w,
                    std::int16_t h,
                    Geometry::Color cid,
                    float opacity) const
{
    if (w == 0 || h == 0 || opacity <= 0.0f)
        return;

    constexpr float colors[NUM_COLORS][3] = {
        {0.0f, 0.0f, 0.0f},  // Black
        {1.0f, 1.0f, 1.0f},  // White
        {0.0f, 1.0f, 0.0f},  // Mob-hp-bar lightgreen
        {0.0f, 0.75f, 0.0f}, // Mob-hp-bar green
        {0.0f, 0.5f, 0.0f}   // Mob-hp-bar darkgreen
    };
    const float* color = colors[cid];

    GraphicsGL::get().draw_rectangle(
        x, y, w, h, color[0], color[1], color[2], opacity);
}

ColorBox::ColorBox(std::int16_t w, std::int16_t h, Geometry::Color c, float o)
    : width(w), height(h), color(c), opacity(o)
{
}

ColorBox::ColorBox() : ColorBox(0, 0, Geometry::BLACK, 0.0f)
{
}

void ColorBox::setwidth(std::int16_t w)
{
    width = w;
}

void ColorBox::setheight(std::int16_t h)
{
    height = h;
}

void ColorBox::set_color(Geometry::Color c)
{
    color = c;
}

void ColorBox::setopacity(float o)
{
    opacity = o;
}

void ColorBox::draw(const DrawArgument& args) const
{
    Point<std::int16_t> absp = args.getpos();
    std::int16_t absw = args.getstretch().x();
    if (absw == 0)
        absw = width;
    std::int16_t absh = args.getstretch().y();
    if (absh == 0)
        absh = height;
    absw = static_cast<std::int16_t>(absw * args.get_xscale());
    absh = static_cast<std::int16_t>(absh * args.get_yscale());
    float absopc = opacity * args.get_color().a();
    Geometry::draw(absp.x(), absp.y(), absw, absh, color, absopc);
}

ColorLine::ColorLine(std::int16_t w, Geometry::Color c, float o)
    : width(w), color(c), opacity(o)
{
}

ColorLine::ColorLine() : ColorLine(0, Geometry::BLACK, 0.0f)
{
}

void ColorLine::setwidth(std::int16_t w)
{
    width = w;
}

void ColorLine::set_color(Geometry::Color c)
{
    color = c;
}

void ColorLine::setopacity(float o)
{
    opacity = o;
}

void ColorLine::draw(const DrawArgument& args) const
{
    Point<std::int16_t> absp = args.getpos();
    std::int16_t absw = args.getstretch().x();
    if (absw == 0)
        absw = width;
    std::int16_t absh = args.getstretch().y();
    if (absh == 0)
        absh = 1;
    absw = static_cast<std::int16_t>(absw * args.get_xscale());
    absh = static_cast<std::int16_t>(absh * args.get_yscale());
    float absopc = opacity * args.get_color().a();
    Geometry::draw(absp.x(), absp.y(), absw, absh, color, absopc);
}

void MobHpBar::draw(Point<std::int16_t> position, std::int16_t hppercent) const
{
    std::int16_t fillw = static_cast<std::int16_t>(
        (WIDTH - 6) * static_cast<float>(hppercent) / 100);
    std::int16_t x = position.x() - WIDTH / 2;
    std::int16_t y = position.y() - HEIGHT * 3;
    Geometry::draw(x, y, WIDTH, HEIGHT, BLACK, 1.0f);
    Geometry::draw(x + 1, y + 1, WIDTH - 2, 1, WHITE, 1.0f);
    Geometry::draw(x + 1, y + HEIGHT - 2, WIDTH - 2, 1, WHITE, 1.0f);
    Geometry::draw(x + 1, y + 2, 1, HEIGHT - 4, WHITE, 1.0f);
    Geometry::draw(x + WIDTH - 2, y + 2, 1, HEIGHT - 4, WHITE, 1.0f);
    Geometry::draw(x + 3, y + 3, fillw, 3, HPBAR_LIGHTGREEN, 1.0f);
    Geometry::draw(x + 3, y + 6, fillw, 1, HPBAR_DARKGREEN, 1.0f);
}
} // namespace jrc

```

`Graphics/Geometry.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Point.h"
#include "DrawArgument.h"

#include <cstdint>

namespace jrc
{
class Geometry
{
public:
    static const std::size_t NUM_COLORS = 5;
    enum Color {
        // Common
        BLACK,
        WHITE,

        // Mob hp bar
        HPBAR_LIGHTGREEN,
        HPBAR_GREEN,
        HPBAR_DARKGREEN
    };

    virtual ~Geometry() = default;

protected:
    void draw(std::int16_t x,
              std::int16_t y,
              std::int16_t w,
              std::int16_t h,
              Geometry::Color color,
              float opacity) const;
};

class ColorBox : public Geometry
{
public:
    ColorBox(std::int16_t width,
             std::int16_t height,
             Geometry::Color color,
             float opacity);
    ColorBox();

    void setwidth(std::int16_t width);
    void setheight(std::int16_t height);
    void set_color(Geometry::Color color);
    void setopacity(float opacity);

    void draw(const DrawArgument& args) const;

private:
    std::int16_t width;
    std::int16_t height;
    Geometry::Color color;
    float opacity;
};

class ColorLine : public Geometry
{
public:
    ColorLine(std::int16_t width, Geometry::Color color, float opacity);
    ColorLine();

    void setwidth(std::int16_t width);
    void set_color(Geometry::Color color);
    void setopacity(float opacity);

    void draw(const DrawArgument& args) const;

private:
    std::int16_t width;
    Geometry::Color color;
    float opacity;
};

class MobHpBar : public Geometry
{
public:
    void draw(Point<std::int16_t> position, std::int16_t hppercent) const;

private:
    static const std::int16_t WIDTH = 50;
    static const std::int16_t HEIGHT = 10;
};
} // namespace jrc

```

`Graphics/GraphicsGL.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "GraphicsGL.h"

#include "../Configuration.h"
#include "../Console.h"
#include "../IO/Window.h"

#include <algorithm>

namespace jrc
{
Rectangle<std::int16_t> GraphicsGL::screen;

GraphicsGL::GraphicsGL()
{
    screen = {0,
              Constants::VIEW_WIDTH,
              -Constants::VIEW_Y_OFFSET,
              -Constants::VIEW_Y_OFFSET + Constants::VIEW_HEIGHT};
    locked = false;
}

Error GraphicsGL::init()
{
    if (glewInit()) {
        return Error::GLEW;
    }

    if (FT_Init_FreeType(&ft_library)) {
        return Error::FREETYPE;
    }

    GLint result = GL_FALSE;

    GLuint vs = glCreateShader(GL_VERTEX_SHADER);
    const char* vs_source
        = "#version 120\n"
          "attribute vec4 coord;"
          "attribute vec4 color;"
          "varying vec2 texpos;"
          "varying vec4 colormod;"
          "uniform vec2 screensize;"
          "uniform int yoffset;"

          "void main(void) {"
          "    float x = -1.0 + coord.x * 2.0 / screensize.x;"
          "    float y = 1.0 - (coord.y + yoffset) * 2.0 / screensize.y;"
          "    gl_Position = vec4(x, y, 0.0, 1.0);"
          "    texpos = coord.zw;"
          "    colormod = color;"
          "}";
    glShaderSource(vs, 1, &vs_source, NULL);
    glCompileShader(vs);
    glGetShaderiv(vs, GL_COMPILE_STATUS, &result);
    if (!result) {
        return Error::VERTEX_SHADER;
    }

    GLuint fs = glCreateShader(GL_FRAGMENT_SHADER);
    const char* fs_source
        = "#version 120\n"
          "varying vec2 texpos;"
          "varying vec4 colormod;"
          "uniform sampler2D texture;"
          "uniform vec2 atlassize;"
          "uniform int fontregion;"

          "void main(void) {"
          "    if (texpos.y == 0) {"
          "        gl_FragColor = colormod;"
          "    } else if (texpos.y <= fontregion) {"
          "        gl_FragColor = vec4(1, 1, 1, texture2D(texture, texpos / "
          "atlassize).r) * colormod;"
          "    } else {"
          "        gl_FragColor = texture2D(texture, texpos / atlassize) * "
          "colormod;"
          "    }"
          "}";
    glShaderSource(fs, 1, &fs_source, NULL);
    glCompileShader(fs);
    glGetShaderiv(fs, GL_COMPILE_STATUS, &result);
    if (!result) {
        return Error::FRAGMENT_SHADER;
    }

    program = glCreateProgram();
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    glLinkProgram(program);
    glGetProgramiv(program, GL_LINK_STATUS, &result);
    if (!result) {
        return Error::SHADER_PROGRAM;
    }

    attribute_coord = glGetAttribLocation(program, "coord");
    attribute_color = glGetAttribLocation(program, "color");
    uniform_texture = glGetUniformLocation(program, "texture");
    uniform_atlas_size = glGetUniformLocation(program, "atlassize");
    uniform_screen_size = glGetUniformLocation(program, "screensize");
    uniform_y_offset = glGetUniformLocation(program, "yoffset");
    uniform_font_region = glGetUniformLocation(program, "fontregion");
    if (attribute_coord == -1 || attribute_color == -1 || uniform_texture == -1
        || uniform_atlas_size == -1 || uniform_y_offset == -1
        || uniform_screen_size == -1) {
        return Error::SHADER_VARS;
    }

    glGenBuffers(1, &vbo);

    glGenTextures(1, &atlas);
    glBindTexture(GL_TEXTURE_2D, atlas);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D,
                 0,
                 GL_RGBA,
                 ATLASW,
                 ATLASH,
                 0,
                 GL_RGBA,
                 GL_UNSIGNED_BYTE,
                 nullptr);

    font_border.set_y(1);

    const std::string& FONT_NORMAL = Configuration::get().fonts.normal;
    const std::string& FONT_BOLD = Configuration::get().fonts.bold;
    if (FONT_NORMAL.empty() || FONT_BOLD.empty()) {
        Console::get().print(
            "[Warning] A font path is empty, check your settings file.");
    }

    const char* const FONT_NORMAL_STR = FONT_NORMAL.data();
    const char* const FONT_BOLD_STR = FONT_BOLD.data();

    addfont(FONT_NORMAL_STR, Text::A11L, 0, 11);
    addfont(FONT_NORMAL_STR, Text::A11M, 0, 11);
    addfont(FONT_BOLD_STR, Text::A11B, 0, 11);
    addfont(FONT_NORMAL_STR, Text::A12M, 0, 12);
    addfont(FONT_BOLD_STR, Text::A12B, 0, 12);
    addfont(FONT_NORMAL_STR, Text::A13M, 0, 13);
    addfont(FONT_BOLD_STR, Text::A13B, 0, 13);
    addfont(FONT_NORMAL_STR, Text::A18M, 0, 18);

    font_y_max += font_border.y();

    leftovers = QuadTree<std::size_t, Leftover>{
        [](const Leftover& first, const Leftover& second) {
            bool wcomp = first.width() >= second.width();
            bool hcomp = first.height() >= second.height();
            if (wcomp && hcomp) {
                return QuadTree<std::size_t, Leftover>::RIGHT;
            } else if (wcomp) {
                return QuadTree<std::size_t, Leftover>::DOWN;
            } else if (hcomp) {
                return QuadTree<std::size_t, Leftover>::UP;
            } else {
                return QuadTree<std::size_t, Leftover>::LEFT;
            }
        }};

    return Error::NONE;
}

bool GraphicsGL::addfont(const char* name,
                         Text::Font id,
                         FT_UInt pixelw,
                         FT_UInt pixelh)
{
    FT_Face face;
    if (FT_New_Face(ft_library, name, 0, &face)) {
        return false;
    }

    if (FT_Set_Pixel_Sizes(face, pixelw, pixelh)) {
        return false;
    }

    FT_GlyphSlot g = face->glyph;

    GLshort width = 0;
    GLshort height = 0;
    for (std::uint8_t c = 32; c < 128; ++c) {
        if (FT_Load_Char(face, c, FT_LOAD_RENDER)) {
            continue;
        }

        GLshort w = static_cast<GLshort>(g->bitmap.width);
        GLshort h = static_cast<GLshort>(g->bitmap.rows);

        width += w;
        if (h > height) {
            height = h;
        }
    }

    if (font_border.x() + width > ATLASW) {
        font_border.set_x(0);
        font_border.set_y(font_y_max);
        font_y_max = 0;
    }

    GLshort x = font_border.x();
    GLshort y = font_border.y();

    font_border.shift_x(width);
    if (height > font_y_max) {
        font_y_max = height;
    }

    fonts[id] = Font(width, height);

    GLshort ox = x;
    GLshort oy = y;
    for (std::uint8_t c = 32; c < 128; ++c) {
        if (FT_Load_Char(face, c, FT_LOAD_RENDER)) {
            continue;
        }

        GLshort ax = static_cast<GLshort>(g->advance.x >> 6);
        GLshort ay = static_cast<GLshort>(g->advance.y >> 6);
        GLshort l = static_cast<GLshort>(g->bitmap_left);
        GLshort t = static_cast<GLshort>(g->bitmap_top);
        GLshort w = static_cast<GLshort>(g->bitmap.width);
        GLshort h = static_cast<GLshort>(g->bitmap.rows);

        glTexSubImage2D(GL_TEXTURE_2D,
                        0,
                        ox,
                        oy,
                        w,
                        h,
                        GL_RED,
                        GL_UNSIGNED_BYTE,
                        g->bitmap.buffer);

        Offset offset = Offset(ox, oy, w, h);
        fonts[id].chars[c] = {ax, ay, w, h, l, t, offset};

        ox += w;
    }

    return true;
}

void GraphicsGL::reinit()
{
    glUseProgram(program);

    glUniform1i(uniform_y_offset, Constants::VIEW_Y_OFFSET);
    glUniform1i(uniform_font_region, font_y_max);
    glUniform2f(uniform_atlas_size, ATLASW, ATLASH);
    glUniform2f(uniform_screen_size,
                Window::get().get_width(),
                Window::get().get_height());

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glVertexAttribPointer(
        attribute_coord, 4, GL_SHORT, GL_FALSE, sizeof(Quad::Vertex), 0);
    glVertexAttribPointer(attribute_color,
                          4,
                          GL_FLOAT,
                          GL_FALSE,
                          sizeof(Quad::Vertex),
                          (const void*)8);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glBindTexture(GL_TEXTURE_2D, atlas);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

    clear_internal();
}

void GraphicsGL::clear_internal()
{
    border = Point<GLshort>(0, font_y_max);
    y_range = Range<GLshort>();

    offsets.clear();
    leftovers.clear();
    rlid = 1;
    wasted = 0;
}

void GraphicsGL::clear()
{
    std::size_t used = ATLASW * border.y() + border.x() * y_range.second();
    double usedpercent = static_cast<double>(used) / (ATLASW * ATLASH);
    if (usedpercent > 80.0) {
        clear_internal();
    }
}

void GraphicsGL::add_bitmap(const nl::bitmap& bmp)
{
    get_offset(bmp);
}

const GraphicsGL::Offset& GraphicsGL::get_offset(const nl::bitmap& bmp)
{
    std::size_t id = bmp.id();
    auto offiter = offsets.find(id);
    if (offiter != offsets.end()) {
        return offiter->second;
    }

    GLshort x = 0;
    GLshort y = 0;
    GLshort w = bmp.width();
    GLshort h = bmp.height();

    if (w <= 0 || h <= 0) {
        return null_offset;
    }

    const auto bmp_data = bmp.data();
    if (!bmp_data) {
        return null_offset;
    }

    auto value = Leftover(x, y, w, h);
    std::size_t lid = leftovers.find_node(value, [
    ](const Leftover& val, const Leftover& leaf) noexcept {
        return val.width() <= leaf.width() && val.height() <= leaf.height();
    });

    if (lid > 0) {
        const Leftover& leftover = leftovers[lid];

        x = leftover.l;
        y = leftover.t;

        GLshort wdelta = leftover.width() - w;
        GLshort hdelta = leftover.height() - h;

        leftovers.erase(lid);

        wasted -= w * h;

        if (wdelta >= MINLOSIZE && hdelta >= MINLOSIZE) {
            leftovers.add(rlid, Leftover(x + w, y + h, wdelta, hdelta));
            ++rlid;

            if (w >= MINLOSIZE) {
                leftovers.add(rlid, Leftover(x, y + h, w, hdelta));
                ++rlid;
            }

            if (h >= MINLOSIZE) {
                leftovers.add(rlid, Leftover(x + w, y, wdelta, h));
                ++rlid;
            }
        } else if (wdelta >= MINLOSIZE) {
            leftovers.add(rlid, Leftover(x + w, y, wdelta, h + hdelta));
            ++rlid;
        } else if (hdelta >= MINLOSIZE) {
            leftovers.add(rlid, Leftover(x, y + h, w + wdelta, hdelta));
            ++rlid;
        }
    } else {
        if (border.x() + w > ATLASW) {
            border.set_x(0);
            border.shift_y(y_range.second());
            if (border.y() + h > ATLASH) {
                clear_internal();
            } else {
                y_range = Range<GLshort>();
            }
        }
        x = border.x();
        y = border.y();

        border.shift_x(w);

        if (h > y_range.second()) {
            if (x >= MINLOSIZE && h - y_range.second() >= MINLOSIZE) {
                leftovers.add(
                    rlid,
                    Leftover(0, y_range.first(), x, h - y_range.second()));
                ++rlid;
            }

            wasted += x * (h - y_range.second());

            y_range = {y + h, h};
        } else if (h < y_range.first() - y) {
            if (w >= MINLOSIZE && y_range.first() - y - h >= MINLOSIZE) {
                leftovers.add(rlid,
                              Leftover(x, y + h, w, y_range.first() - y - h));
                ++rlid;
            }

            wasted += w * (y_range.first() - y - h);
        }
    }

    /*
    std::size_t used = ATLASW * border.y() + border.x() * y_range.second();
    double usedpercent = static_cast<double>(used) / (ATLASW * ATLASH);
    double wastedpercent = static_cast<double>(wasted) / used;
    Console::get().print("Used: " + std::to_string(usedpercent) + ", wasted: "
    + std::to_string(wastedpercent));
    */

    glTexSubImage2D(
        GL_TEXTURE_2D, 0, x, y, w, h, GL_BGRA, GL_UNSIGNED_BYTE, bmp_data);

    return offsets
        .emplace(std::piecewise_construct,
                 std::forward_as_tuple(id),
                 std::forward_as_tuple(x, y, w, h))
        .first->second;
}

void GraphicsGL::draw(const nl::bitmap& bmp,
                      const Rectangle<std::int16_t>& rect,
                      const Color& color,
                      float angle)
{
    if (locked) {
        return;
    }

    if (color.invisible()) {
        return;
    }

    if (!rect.overlaps(screen)) {
        return;
    }

    quads.emplace_back(
        rect.l(), rect.r(), rect.t(), rect.b(), get_offset(bmp), color, angle);
}

Text::Layout GraphicsGL::create_layout(std::string_view text,
                                       Text::Font id,
                                       Text::Alignment alignment,
                                       std::int16_t max_width,
                                       bool formatted)
{
    auto length = text.length();
    if (length == 0) {
        return {};
    }

    LayoutBuilder builder{fonts[id], alignment, max_width, formatted};

    std::string_view::size_type first = 0;
    std::string_view::size_type offset = 0;
    while (offset < length) {
        auto last = text.find_first_of(" \\#", offset + 1, 3);
        if (last == std::string_view::npos) {
            last = length;
        }

        first = builder.add(text, first, offset, last);
        offset = last;
    }

    return builder.finish(first, offset);
}

GraphicsGL::LayoutBuilder::LayoutBuilder(const Font& f,
                                         Text::Alignment a,
                                         std::int16_t mw,
                                         bool fm)
    : font(f), alignment(a), max_width(mw), formatted(fm)
{
    font_id = Text::NUM_FONTS;
    color = Text::NUM_COLORS;
    ax = 0;
    ay = font.line_space();
    width = 0;
    endy = 0;
    if (max_width == 0) {
        max_width = Window::get().get_width();
    }
}

std::string_view::size_type
GraphicsGL::LayoutBuilder::add(std::string_view text,
                               std::string_view::size_type prev,
                               std::string_view::size_type first,
                               std::string_view::size_type last)
{
    if (first == last) {
        return prev;
    }

    Text::Font last_font = font_id;
    Text::Color last_color = color;
    std::string_view::size_type skip = 0;
    bool line_break = false;
    if (formatted) {
        switch (text[first]) {
        case '\\':
            if (first + 1 < last) {
                switch (text[first + 1]) {
                case 'n':
                    line_break = true;
                    break;
                case 'r':
                    line_break = ax > 0;
                    break;
                }
                ++skip;
            }
            ++skip;
            break;
        case '#':
            if (first + 1 < last) {
                switch (text[first + 1]) {
                case 'k':
                    color = Text::DARKGREY;
                    break;
                case 'b':
                    color = Text::BLUE;
                    break;
                case 'r':
                    color = Text::RED;
                    break;
                case 'c':
                    color = Text::ORANGE;
                    break;
                }
                ++skip;
            }
            ++skip;
            break;
        }
    }

    std::int16_t word_width = 0;
    if (!line_break) {
        for (std::string_view::size_type i = first; i < last; ++i) {
            char c = text[i];
            word_width += font.chars[static_cast<std::size_t>(c)].ax;

            if (word_width > max_width) {
                if (last - first == 1) {
                    return last;
                } else {
                    prev = add(text, prev, first, i);
                    return add(text, prev, i, last);
                }
            }
        }
    }

    bool new_word = skip > 0;
    bool new_line = line_break || ax + word_width > max_width;
    if (new_word || new_line) {
        add_word(prev, first, last_font, last_color);
    }
    if (new_line) {
        add_line();

        endy = ay;
        ax = 0;
        ay += font.line_space();
    }

    for (std::string_view::size_type pos = first; pos < last; ++pos) {
        char c = text[pos];
        const Font::Char& ch = font.chars[static_cast<std::size_t>(c)];

        advances.push_back(ax);

        if (pos < first + skip || (new_line && c == ' ')) {
            continue;
        }

        ax += ch.ax;

        if (width < ax) {
            width = ax;
        }
    }

    if (new_word || new_line) {
        return first + skip;
    } else {
        return prev;
    }
}

Text::Layout GraphicsGL::LayoutBuilder::finish(std::size_t first,
                                               std::size_t last)
{
    add_word(first, last, font_id, color);
    add_line();

    advances.push_back(ax);
    return {lines, advances, width, ay, ax, endy};
}

void GraphicsGL::LayoutBuilder::add_word(std::size_t word_first,
                                         std::size_t word_last,
                                         Text::Font word_font,
                                         Text::Color word_color)
{
    words.push_back({word_first, word_last, word_font, word_color});
}

void GraphicsGL::LayoutBuilder::add_line()
{
    std::int16_t line_x = 0;
    std::int16_t line_y = ay;
    switch (alignment) {
    case Text::CENTER:
        line_x -= ax / 2;
        break;
    case Text::RIGHT:
        line_x -= ax;
        break;
    default:
        break;
    }

    lines.push_back({words, {line_x, line_y}});
    words.clear();
}

void GraphicsGL::draw_text(const DrawArgument& args,
                           std::string_view text,
                           const Text::Layout& layout,
                           Text::Font id,
                           Text::Color colorid,
                           Text::Background background)
{
    if (locked) {
        return;
    }

    const Color& color = args.get_color();

    if (text.empty() || color.invisible()) {
        return;
    }

    const Font& font = fonts[id];

    GLshort x = args.getpos().x();
    GLshort y = args.getpos().y();
    GLshort w = layout.width();
    GLshort h = layout.height();

    switch (background) {
    case Text::NAMETAG:
        for (const Text::Layout::Line& line : layout) {
            GLshort left = x + line.position.x() - 2;
            GLshort right = left + w + 3;
            GLshort top = y + line.position.y() - font.line_space() + 5;
            GLshort bottom = top + h - 2;
            Color ntcolor{0.0f, 0.0f, 0.0f, 0.6f};

            quads.emplace_back(
                left, right, top, bottom, null_offset, ntcolor, 0.0f);
            quads.emplace_back(left - 1,
                               left,
                               top + 1,
                               bottom - 1,
                               null_offset,
                               ntcolor,
                               0.0f);
            quads.emplace_back(right,
                               right + 1,
                               top + 1,
                               bottom - 1,
                               null_offset,
                               ntcolor,
                               0.0f);
        }
        break;
    default:
        break;
    }

    static constexpr const GLfloat colors[Text::NUM_COLORS][3] = {
        {0.0f, 0.0f, 0.0f},    // Black
        {1.0f, 1.0f, 1.0f},    // White
        {1.0f, 1.0f, 0.0f},    // Yellow
        {0.0f, 0.0f, 1.0f},    // Blue
        {1.0f, 0.0f, 0.0f},    // Red
        {0.8f, 0.3f, 0.3f},    // DarkRed
        {0.5f, 0.25f, 0.0f},   // Brown
        {0.5f, 0.5f, 0.5f},    // Lightgrey
        {0.25f, 0.25f, 0.25f}, // Darkgrey
        {1.0f, 0.5f, 0.0f},    // Orange
        {0.0f, 0.75f, 1.0f},   // Mediumblue
        {0.5f, 0.0f, 0.5f}     // Violet
    };

    for (const Text::Layout::Line& line : layout) {
        Point<std::int16_t> position = line.position;

        for (const Text::Layout::Word& word : line.words) {
            GLshort ax = position.x() + layout.advance(word.first);
            GLshort ay = position.y();

            const GLfloat* wordcolor;
            if (word.color < Text::NUM_COLORS) {
                wordcolor = colors[word.color];
            } else {
                wordcolor = colors[colorid];
            }
            Color abscolor
                = color
                  * Color{wordcolor[0], wordcolor[1], wordcolor[2], 1.0f};

            for (std::size_t pos = word.first; pos < word.last; ++pos) {
                const char c = text[pos];
                const Font::Char& ch = font.chars[static_cast<std::size_t>(c)];

                GLshort chx = x + ax + ch.bl;
                GLshort chy = y + ay - ch.bt;
                GLshort chw = ch.bw;
                GLshort chh = ch.bh;

                if (ax == 0 && c == ' ') {
                    continue;
                }

                ax += ch.ax;

                if (chw <= 0 || chh <= 0) {
                    continue;
                }

                quads.emplace_back(
                    chx, chx + chw, chy, chy + chh, ch.offset, abscolor, 0.0f);
            }
        }
    }
}

void GraphicsGL::draw_rectangle(std::int16_t x,
                                std::int16_t y,
                                std::int16_t w,
                                std::int16_t h,
                                float r,
                                float g,
                                float b,
                                float a)
{
    if (locked) {
        return;
    }

    quads.emplace_back(
        x, x + w, y, y + h, null_offset, Color{r, g, b, a}, 0.0f);
}

void GraphicsGL::draw_screen_fill(float r, float g, float b, float a)
{
    draw_rectangle(0,
                   -Constants::VIEW_Y_OFFSET,
                   Window::get().get_width(),
                   Window::get().get_height(),
                   r,
                   g,
                   b,
                   a);
}

void GraphicsGL::lock()
{
    locked = true;
}

void GraphicsGL::unlock()
{
    locked = false;
}

void GraphicsGL::flush(float opacity)
{
    bool coverscene = opacity != 1.0f;
    if (coverscene) {
        float complement = 1.0f - opacity;
        Color color{0.0f, 0.0f, 0.0f, complement};

        quads.emplace_back(screen.l(),
                           screen.r(),
                           screen.t(),
                           screen.b(),
                           null_offset,
                           color,
                           0.0f);
    }

    glClearColor(1.0, 1.0, 1.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);

    GLsizei csize = static_cast<GLsizei>(quads.size() * sizeof(Quad));
    GLsizei fsize = static_cast<GLsizei>(quads.size() * Quad::LENGTH);
    glEnableVertexAttribArray(attribute_coord);
    glEnableVertexAttribArray(attribute_color);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, csize, quads.data(), GL_STREAM_DRAW);
    glDrawArrays(GL_QUADS, 0, fsize);

    glDisableVertexAttribArray(attribute_coord);
    glDisableVertexAttribArray(attribute_color);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    if (coverscene) {
        quads.pop_back();
    }
}

void GraphicsGL::clearscene()
{
    if (!locked) {
        quads.clear();
    }
}

void GraphicsGL::set_screen(Rectangle<std::int16_t>&& new_screen) noexcept
{
    screen = new_screen;
}

void GraphicsGL::set_screen(std::int16_t l,
                            std::int16_t r,
                            std::int16_t t,
                            std::int16_t b) noexcept
{
    screen = {l, r, t, b};
}
} // namespace jrc

```

`Graphics/GraphicsGL.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Constants.h"
#include "../Error.h"
#include "../Template/Rectangle.h"
#include "../Template/Singleton.h"
#include "../Util/QuadTree.h"
#include "DrawArgument.h"
#include "GL/glew.h"
#include "Text.h"
#include "ft2build.h"
#include "nlnx/bitmap.hpp"
#include FT_FREETYPE_H

#include <string_view>
#include <unordered_map>
#include <vector>

namespace jrc
{
//! Graphics engine which uses OpenGL.
class GraphicsGL : public Singleton<GraphicsGL>
{
public:
    GraphicsGL();

    //! Initialise all resources.
    Error init();
    //! Re-initialise after changing screen modes.
    void reinit();

    //! Clear all bitmaps if most of the space is used up.
    void clear();

    //! Add a bitmap to the available resources.
    void add_bitmap(const nl::bitmap& bmp);
    //! Draw the bitmap with the given parameters.
    void draw(const nl::bitmap& bmp,
              const Rectangle<std::int16_t>& rect,
              const Color& color,
              float angle);

    //! Create a layout for the text with the parameters specified.
    Text::Layout create_layout(std::string_view text,
                               Text::Font font,
                               Text::Alignment alignment,
                               std::int16_t max_width,
                               bool formatted);
    //! Draw a text with the given parameters.
    void draw_text(const DrawArgument& args,
                   std::string_view text,
                   const Text::Layout& layout,
                   Text::Font font,
                   Text::Color color,
                   Text::Background back);

    //! Draw a rectangle filled with the specified color.
    void draw_rectangle(std::int16_t x,
                        std::int16_t y,
                        std::int16_t w,
                        std::int16_t h,
                        float r,
                        float g,
                        float b,
                        float a);
    //! Fill the screen with the specified color.
    void draw_screen_fill(float r, float g, float b, float a);

    //! Lock the current scene.
    void lock();
    //! Unlock the scene.
    void unlock();

    //! Draw the buffer contents with the specified scene opacity.
    void flush(float opacity);
    //! Clear the buffer contents.
    void clearscene();
    //! Set the screen rectangle.
    static void set_screen(Rectangle<std::int16_t>&& new_screen) noexcept;
    //! Set the screen rectangle.
    static void set_screen(std::int16_t l,
                           std::int16_t r,
                           std::int16_t t,
                           std::int16_t b) noexcept;

private:
    void clear_internal();
    bool
    addfont(const char* name, Text::Font id, FT_UInt width, FT_UInt height);

    struct Offset {
        GLshort l;
        GLshort r;
        GLshort t;
        GLshort b;

        Offset(GLshort x, GLshort y, GLshort w, GLshort h)
        {
            l = x;
            r = x + w;
            t = y;
            b = y + h;
        }

        Offset()
        {
            l = 0;
            r = 0;
            t = 0;
            b = 0;
        }
    };
    //! Add a bitmap to the available resources.
    const Offset& get_offset(const nl::bitmap& bmp);

    struct Leftover {
        GLshort l;
        GLshort r;
        GLshort t;
        GLshort b;

        Leftover(GLshort x, GLshort y, GLshort w, GLshort h)
        {
            l = x;
            r = x + w;
            t = y;
            b = y + h;
        }

        Leftover()
        {
            l = 0;
            r = 0;
            t = 0;
            b = 0;
        }

        GLshort width() const
        {
            return r - l;
        }

        GLshort height() const
        {
            return b - t;
        }
    };

    struct Quad {
        struct Vertex {
            GLshort x;
            GLshort y;
            GLshort s;
            GLshort t;

            Color c;
        };

        static const std::size_t LENGTH = 4;
        Vertex vertices[LENGTH];

        Quad(GLshort l,
             GLshort r,
             GLshort t,
             GLshort b,
             const Offset& o,
             const Color& color,
             GLfloat rot)
        {
            vertices[0] = {l, t, o.l, o.t, color};
            vertices[1] = {l, b, o.l, o.b, color};
            vertices[2] = {r, b, o.r, o.b, color};
            vertices[3] = {r, t, o.r, o.t, color};

            if (rot != 0.0f) {
                float cos = std::cos(rot);
                float sin = std::sin(rot);
                GLshort cx = (l + r) / 2;
                GLshort cy = (t + b) / 2;

                for (int i = 0; i < 4; ++i) {
                    GLshort vx = vertices[i].x - cx;
                    GLshort vy = vertices[i].y - cy;
                    GLfloat rx = std::roundf(vx * cos - vy * sin);
                    GLfloat ry = std::roundf(vx * sin + vy * cos);
                    vertices[i].x = static_cast<GLshort>(rx + cx);
                    vertices[i].y = static_cast<GLshort>(ry + cy);
                }
            }
        }
    };

    struct Font {
        struct Char {
            GLshort ax;
            GLshort ay;
            GLshort bw;
            GLshort bh;
            GLshort bl;
            GLshort bt;
            Offset offset;
        };

        GLshort width;
        GLshort height;
        Char chars[128];

        Font(GLshort w, GLshort h)
        {
            width = w;
            height = h;
        }

        Font()
        {
            width = 0;
            height = 0;
        }

        std::int16_t line_space() const
        {
            return static_cast<std::int16_t>(height * 1.35 + 1);
        }
    };

    class LayoutBuilder
    {
    public:
        LayoutBuilder(const Font& font,
                      Text::Alignment alignment,
                      std::int16_t maxwidth,
                      bool formatted);

        std::string_view::size_type add(std::string_view text,
                                        std::string_view::size_type prev,
                                        std::string_view::size_type first,
                                        std::string_view::size_type last);
        Text::Layout finish(std::size_t first, std::size_t last);

    private:
        void add_word(std::size_t first,
                      std::size_t last,
                      Text::Font font,
                      Text::Color color);
        void add_line();

        const Font& font;

        Text::Alignment alignment;
        Text::Font font_id;
        Text::Color color;
        std::int16_t max_width;
        bool formatted;

        std::int16_t ax;
        std::int16_t ay;

        std::vector<Text::Layout::Line> lines;
        std::vector<Text::Layout::Word> words;
        std::vector<std::int16_t> advances;
        std::int16_t width;
        std::int16_t endy;
    };

    static Rectangle<std::int16_t> screen;

    static const GLshort ATLASW = 8192;
    static const GLshort ATLASH = 8192;
    static const GLshort MINLOSIZE = 32;

    bool locked;

    std::vector<Quad> quads;
    GLuint vbo;
    GLuint atlas;

    GLint program;
    GLint attribute_coord;
    GLint attribute_color;
    GLint uniform_texture;
    GLint uniform_atlas_size;
    GLint uniform_screen_size;
    GLint uniform_y_offset;
    GLint uniform_font_region;

    std::unordered_map<std::size_t, Offset> offsets;
    Offset null_offset;

    QuadTree<std::size_t, Leftover> leftovers;
    std::size_t rlid;
    std::size_t wasted;
    Point<GLshort> border;
    Range<GLshort> y_range;

    FT_Library ft_library;
    Font fonts[Text::NUM_FONTS];
    Point<GLshort> font_border;
    GLshort font_y_max;
};

// constexpr Rectangle<std::int16_t> GraphicsGL::screen;
} // namespace jrc

```

`Graphics/Sprite.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Sprite.h"

namespace jrc
{
Sprite::Sprite(const Animation& a, const DrawArgument& s_args)
    : animation(a), state_args(s_args)
{
}

Sprite::Sprite(nl::node src, const DrawArgument& s_args)
    : animation(src), state_args(s_args)
{
}

Sprite::Sprite(nl::node src) : Sprite(src, {})
{
}

Sprite::Sprite() = default;

void Sprite::draw(Point<std::int16_t> parent_pos, float alpha) const
{
    auto abs_args = state_args + parent_pos;
    animation.draw(abs_args, alpha);
}

bool Sprite::update(std::uint16_t timestep)
{
    return animation.update(timestep);
}

bool Sprite::update()
{
    return animation.update();
}
} // namespace jrc

```

`Graphics/Sprite.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Animation.h"
#include "nlnx/node.hpp"

namespace jrc
{
//! Combines an `Animation` with additional state.
class Sprite
{
public:
    Sprite(const Animation& a, const DrawArgument& s_args);
    Sprite(nl::node src, const DrawArgument& s_args);
    Sprite(nl::node src);
    Sprite();

    void draw(Point<std::int16_t> parent_pos, float alpha) const;
    bool update(std::uint16_t timestep);
    bool update();

private:
    Animation animation;
    DrawArgument state_args;
};
} // namespace jrc

```

`Graphics/Text.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Text.h"

#include "GraphicsGL.h"

namespace jrc
{
Text::Text(Font f,
           Alignment a,
           Color c,
           Background b,
           std::string&& t,
           std::uint16_t mw,
           bool fm) noexcept
    : font(f),
      alignment(a),
      color(c),
      background(b),
      max_width(mw),
      formatted(fm)
{
    change_text(std::move(t));
}

Text::Text(Font f,
           Alignment a,
           Color c,
           std::string&& t,
           std::uint16_t mw,
           bool fm) noexcept
    : Text(f, a, c, NONE, std::move(t), mw, fm)
{
}

Text::Text() noexcept : Text(A11M, LEFT, BLACK)
{
}

void Text::reset_layout() noexcept
{
    if (text.empty()) {
        return;
    }

    layout = GraphicsGL::get().create_layout(
        text, font, alignment, max_width, formatted);
}

void Text::change_text(std::string&& t)
{
    if (text == t) {
        return;
    }

    text = std::move(t);

    reset_layout();
}

void Text::change_color(Color c)
{
    if (color == c) {
        return;
    }

    color = c;

    reset_layout();
}

void Text::set_background(Background b)
{
    background = b;
}

void Text::draw(const DrawArgument& args) const
{
    GraphicsGL::get().draw_text(args, text, layout, font, color, background);
}

std::uint16_t Text::advance(std::size_t pos) const
{
    return static_cast<std::uint16_t>(layout.advance(pos));
}

bool Text::empty() const
{
    return text.empty();
}

std::size_t Text::length() const
{
    return text.size();
}

std::int16_t Text::width() const
{
    return layout.width();
}

std::int16_t Text::height() const
{
    return layout.height();
}

Point<std::int16_t> Text::dimensions() const
{
    return layout.get_dimensions();
}

Point<std::int16_t> Text::endoffset() const
{
    return layout.get_endoffset();
}

std::string_view Text::get_text() const noexcept
{
    return text;
}

Text::Layout::Layout(const std::vector<Line>& l,
                     const std::vector<std::int16_t>& a,
                     std::int16_t w,
                     std::int16_t h,
                     std::int16_t ex,
                     std::int16_t ey)
    : lines(l), advances(a), dimensions(w, h), endoffset(ex, ey)
{
}

Text::Layout::Layout() : Layout({}, {}, 0, 0, 0, 0)
{
}

std::int16_t Text::Layout::width() const
{
    return dimensions.x();
}

std::int16_t Text::Layout::height() const
{
    return dimensions.y();
}

std::int16_t Text::Layout::advance(std::size_t index) const
{
    return static_cast<std::int16_t>(index < advances.size() ? advances[index]
                                                             : 0);
}

Point<std::int16_t> Text::Layout::get_dimensions() const
{
    return dimensions;
}

Point<std::int16_t> Text::Layout::get_endoffset() const
{
    return endoffset;
}

Text::Layout::iterator Text::Layout::begin() const
{
    return lines.begin();
}

Text::Layout::iterator Text::Layout::end() const
{
    return lines.end();
}
} // namespace jrc

```

`Graphics/Text.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "DrawArgument.h"

#include <cstdint>
#include <map>
#include <vector>

namespace jrc
{
class Text
{
public:
    enum Font { A11L, A11M, A11B, A12M, A12B, A13M, A13B, A18M, NUM_FONTS };

    enum Alignment { LEFT, CENTER, RIGHT };

    enum Color {
        BLACK,
        WHITE,
        YELLOW,
        BLUE,
        RED,
        DARKRED,
        BROWN,
        LIGHTGREY,
        DARKGREY,
        ORANGE,
        MEDIUMBLUE,
        VIOLET,
        NUM_COLORS
    };

    enum Background { NONE, NAMETAG };

    class Layout
    {
    public:
        struct Word {
            std::size_t first;
            std::size_t last;
            Font font;
            Color color;
        };

        struct Line {
            std::vector<Word> words;
            Point<std::int16_t> position;
        };

        Layout(const std::vector<Line>& lines,
               const std::vector<std::int16_t>& advances,
               std::int16_t width,
               std::int16_t height,
               std::int16_t endx,
               std::int16_t endy);
        Layout();

        std::int16_t width() const;
        std::int16_t height() const;
        std::int16_t advance(std::size_t index) const;
        Point<std::int16_t> get_dimensions() const;
        Point<std::int16_t> get_endoffset() const;

        using iterator = std::vector<Line>::const_iterator;
        iterator begin() const;
        iterator end() const;

    private:
        std::vector<Line> lines;
        std::vector<std::int16_t> advances;
        Point<std::int16_t> dimensions;
        Point<std::int16_t> endoffset;
    };

    Text(Font font,
         Alignment alignment,
         Color color,
         Background background,
         std::string&& text = "",
         std::uint16_t maxwidth = 0,
         bool formatted = true) noexcept;
    Text(Font font,
         Alignment alignment,
         Color color,
         std::string&& text = "",
         std::uint16_t maxwidth = 0,
         bool formatted = true) noexcept;
    Text() noexcept;

    void draw(const DrawArgument& args) const;

    void change_text(std::string&& text);
    void change_color(Color color);
    void set_background(Background background);

    bool empty() const;
    std::size_t length() const;
    std::int16_t width() const;
    std::int16_t height() const;
    std::uint16_t advance(std::size_t pos) const;
    Point<std::int16_t> dimensions() const;
    Point<std::int16_t> endoffset() const;
    std::string_view get_text() const noexcept;

private:
    void reset_layout() noexcept;

    Font font;
    Alignment alignment;
    Color color;
    Background background;
    Layout layout;
    std::uint16_t max_width;
    bool formatted;
    std::string text;
};
} // namespace jrc

```

`Graphics/Texture.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Texture.h"

#include "../Configuration.h"
#include "GraphicsGL.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Texture::Texture(nl::node src)
{
    if (src.data_type() == nl::node::type::bitmap) {
        const nl::node src_origin = src["origin"];
        const Point<std::int16_t> original_origin = src_origin;
        const bool use_original_origin
            = src_origin.data_type() == nl::node::type::vector;

        const std::string link = src["source"];
        if (!link.empty()) {
            nl::node src_file = src;
            while (src_file != src_file.root()) {
                src_file = src_file.root();
            }
            src = src_file.resolve(
                std::string_view{link}.substr(link.find('/') + 1));
        }

        bitmap = src;
        origin = use_original_origin ? original_origin : src["origin"];
        dimensions = {bitmap.width(), bitmap.height()};

        GraphicsGL::get().add_bitmap(bitmap);
    }
}

Texture::Texture(nl::bitmap bm, Point<std::int16_t> orig)
    : bitmap{bm}, origin{orig}, dimensions{bm.width(), bm.height()}
{
}

Texture::Texture() = default;

Texture::~Texture() = default;

void Texture::draw(const DrawArgument& args) const
{
    std::size_t id = bitmap.id();
    if (id == 0) {
        return;
    }

    GraphicsGL::get().draw(bitmap,
                           args.get_rectangle(origin, dimensions),
                           args.get_color(),
                           args.get_angle());
}

void Texture::shift(Point<std::int16_t> amount)
{
    origin -= amount;
}

bool Texture::is_valid() const
{
    return bitmap.id() > 0;
}

std::int16_t Texture::width() const
{
    return dimensions.x();
}

std::int16_t Texture::height() const
{
    return dimensions.y();
}

Point<std::int16_t> Texture::get_origin() const
{
    return origin;
}

Point<std::int16_t> Texture::get_dimensions() const
{
    return dimensions;
}
} // namespace jrc

```

`Graphics/Texture.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "DrawArgument.h"
#include "nlnx/bitmap.hpp"
#include "nlnx/node.hpp"

namespace jrc
{
//! Represents a single image loaded from a of game data.
class Texture
{
public:
    Texture(nl::node source);
    Texture(nl::bitmap bm, Point<std::int16_t> orig);
    Texture();
    ~Texture();

    void draw(const DrawArgument& args) const;
    void shift(Point<std::int16_t> amount);

    bool is_valid() const;
    std::int16_t width() const;
    std::int16_t height() const;
    Point<std::int16_t> get_origin() const;
    Point<std::int16_t> get_dimensions() const;

private:
    nl::bitmap bitmap;
    Point<std::int16_t> origin;
    Point<std::int16_t> dimensions;
};
} // namespace jrc

```

`IO/Components/AreaButton.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "AreaButton.h"

namespace jrc
{
AreaButton::AreaButton(Point<std::int16_t> pos, Point<std::int16_t> dim)
{
    position = pos;
    dimension = dim;
    state = NORMAL;
    active = true;
}

Rectangle<std::int16_t> AreaButton::bounds(Point<std::int16_t> parentpos) const
{
    Point<std::int16_t> absp = position + parentpos;
    return Rectangle<std::int16_t>(absp, absp + dimension);
}
} // namespace jrc

```

`IO/Components/AreaButton.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Button.h"

namespace jrc
{
//! An invisible button which is only defined by its area.
class AreaButton : public Button
{
public:
    AreaButton(Point<std::int16_t> position, Point<std::int16_t> dimensions);

    void draw(Point<std::int16_t>) const
    {
    }
    Rectangle<std::int16_t> bounds(Point<std::int16_t> parentpos) const;

private:
    Point<std::int16_t> dimension;
};
} // namespace jrc

```

`IO/Components/Button.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Button.h"

#include "../../Audio/Audio.h"

namespace jrc
{
void Button::set_position(Point<std::int16_t> pos)
{
    position = pos;
}

void Button::set_state(State s)
{
    if (s == IDENTITY) {
        return;
    }

    state = s;
}

void Button::set_active(bool a)
{
    active = a;
}

bool Button::is_active() const
{
    return active && state != DISABLED;
}

Button::State Button::get_state() const
{
    return state;
}
} // namespace jrc

```

`IO/Components/Button.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Rectangle.h"
#include "../Cursor.h"

#include <cstdint>
#include <functional>

namespace jrc
{
//! Base class for different button types.
class Button
{
public:
    enum State { NORMAL, DISABLED, MOUSE_OVER, PRESSED, IDENTITY, NUM_STATES };

    virtual ~Button() = default;

    virtual void draw(Point<std::int16_t> parentpos) const = 0;
    virtual Rectangle<std::int16_t>
    bounds(Point<std::int16_t> parentpos) const = 0;

    void set_position(Point<std::int16_t> position);
    void set_state(State state);
    void set_active(bool active);

    bool is_active() const;
    State get_state() const;

protected:
    State state;
    Point<std::int16_t> position;
    bool active;
};
} // namespace jrc

```

`IO/Components/Charset.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Charset.h"

namespace jrc
{
Charset::Charset(nl::node src, Alignment alignment) : alignment(alignment)
{
    for (auto sub : src) {
        std::string name = sub.name();
        if (sub.data_type() != nl::node::type::bitmap || name.empty()) {
            continue;
        }

        char c = *name.begin();
        if (c == '\\') {
            c = '/';
        }
        chars.emplace(c, sub);
    }
}

Charset::Charset() noexcept : alignment(LEFT)
{
}

void Charset::draw(std::int8_t c, const DrawArgument& args) const
{
    auto iter = chars.find(c);
    if (iter != chars.end()) {
        iter->second.draw(args);
    }
}

std::int16_t Charset::get_w(std::int8_t c) const
{
    auto iter = chars.find(c);
    return static_cast<std::int16_t>(iter != chars.end() ? iter->second.width()
                                                         : 0);
}

std::int16_t Charset::draw(std::string_view text,
                           const DrawArgument& args) const
{
    std::int16_t shift = 0;
    std::int16_t total = 0;

    switch (alignment) {
    case CENTER:
        for (char c : text) {
            total += get_w(c);
        }
        shift -= total / 2;
    case LEFT:
        for (char c : text) {
            draw(c, args + Point<std::int16_t>{shift, 0});
            shift += get_w(c);
        }
        break;
    case RIGHT:
        for (auto iter = text.rbegin(); iter != text.rend(); ++iter) {
            char c = *iter;
            shift += get_w(c);
            draw(c, args - Point<std::int16_t>{shift, 0});
        }
        break;
    }
    return shift;
}

std::int16_t Charset::draw(std::string_view text,
                           std::int16_t hspace,
                           const DrawArgument& args) const
{
    std::int16_t shift = 0;

    switch (alignment) {
    case CENTER:
        shift -= hspace * static_cast<std::int16_t>(text.length()) / 2;
    case LEFT:
        for (char c : text) {
            draw(c, args + Point<std::int16_t>(shift, 0));
            shift += hspace;
        }
        break;
    case RIGHT:
        for (auto iter = text.rbegin(); iter != text.rend(); ++iter) {
            char c = *iter;
            shift += hspace;
            draw(c, args - Point<std::int16_t>(shift, 0));
        }
        break;
    }
    return shift;
}
} // namespace jrc

```

`IO/Components/Charset.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"

#include <string_view>
#include <unordered_map>

namespace jrc
{
class Charset
{
public:
    enum Alignment { LEFT, CENTER, RIGHT };

    Charset(nl::node source, Alignment alignment);
    Charset() noexcept;

    void draw(std::int8_t character, const DrawArgument& args) const;
    std::int16_t draw(std::string_view text, const DrawArgument& args) const;
    std::int16_t draw(std::string_view text,
                      std::int16_t hspace,
                      const DrawArgument& args) const;
    std::int16_t get_w(std::int8_t character) const;

private:
    std::unordered_map<std::int8_t, Texture> chars;
    Alignment alignment;
};
} // namespace jrc

```

`IO/Components/ChatBalloon.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ChatBalloon.h"

#include "../../Constants.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
ChatBalloon::ChatBalloon(std::int8_t type)
{
    std::string typestr;
    if (type < 0) {
        switch (type) {
        case -1:
            typestr = "dead";
            break;
        }
    } else {
        typestr = std::to_string(type);
    }

    nl::node src = nl::nx::ui["ChatBalloon.img"][typestr];

    arrow = src["arrow"];
    frame = src;

    textlabel = {Text::A11M, Text::CENTER, Text::BLACK, "", 80};

    duration = 0;
}

ChatBalloon::ChatBalloon() : ChatBalloon(0)
{
}

void ChatBalloon::change_text(std::string&& text)
{
    textlabel.change_text(std::move(text));

    duration = DURATION;
}

void ChatBalloon::draw(Point<std::int16_t> position) const
{
    if (duration == 0) {
        return;
    }

    std::int16_t width = textlabel.width();
    std::int16_t height = textlabel.height();

    frame.draw(position, width, height);
    arrow.draw(position);
    textlabel.draw(position - Point<std::int16_t>(0, height + 4));
}

void ChatBalloon::update()
{
    duration -= Constants::TIMESTEP;
    if (duration < 0) {
        duration = 0;
    }
}

void ChatBalloon::expire()
{
    duration = 0;
}
} // namespace jrc

```

`IO/Components/ChatBalloon.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "MapleFrame.h"

namespace jrc
{
class ChatBalloon
{
public:
    ChatBalloon(std::int8_t type);
    ChatBalloon();

    void draw(Point<std::int16_t> position) const;
    void update();

    void change_text(std::string&& text);
    void expire();

private:
    //! How long a line stays on screen. 4 seconds.
    static constexpr std::int16_t DURATION = 4'000;

    MapleFrame frame;
    Text textlabel;
    Texture arrow;
    std::int16_t duration;
};
} // namespace jrc

```

`IO/Components/EquipTooltip.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "EquipTooltip.h"

#include "../../Data/EquipData.h"
#include "../../Data/WeaponData.h"
#include "../../Gameplay/Stage.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <cstdlib>

namespace jrc
{
EquipTooltip::EquipTooltip()
{
    nl::node item_tt = nl::nx::ui["UIToolTip.img"]["Item"];

    top = item_tt["Frame"]["top"];
    mid = item_tt["Frame"]["line"];
    line = item_tt["Frame"]["dotline"];
    bot = item_tt["Frame"]["bottom"];
    base = item_tt["ItemIcon"]["base"];
    cover = item_tt["ItemIcon"]["cover"];
    shade = item_tt["ItemIcon"]["shade"];

    potential[Equip::POT_NONE] = {};
    potential[Equip::POT_HIDDEN] = item_tt["ItemIcon"]["0"];
    potential[Equip::POT_RARE] = item_tt["ItemIcon"]["1"];
    potential[Equip::POT_EPIC] = item_tt["ItemIcon"]["2"];
    potential[Equip::POT_UNIQUE] = item_tt["ItemIcon"]["3"];
    potential[Equip::POT_LEGENDARY] = item_tt["ItemIcon"]["4"];

    requirements.push_back(Maplestat::LEVEL);
    requirements.push_back(Maplestat::STR);
    requirements.push_back(Maplestat::DEX);
    requirements.push_back(Maplestat::INT);
    requirements.push_back(Maplestat::LUK);

    req_stat_textures[Maplestat::LEVEL][false]
        = item_tt["Equip"]["Cannot"]["reqLEV"];
    req_stat_textures[Maplestat::LEVEL][true]
        = item_tt["Equip"]["Can"]["reqLEV"];
    req_stat_textures[Maplestat::FAME][false]
        = item_tt["Equip"]["Cannot"]["reqPOP"];
    req_stat_textures[Maplestat::FAME][true]
        = item_tt["Equip"]["Can"]["reqPOP"];
    req_stat_textures[Maplestat::STR][false]
        = item_tt["Equip"]["Cannot"]["reqSTR"];
    req_stat_textures[Maplestat::STR][true]
        = item_tt["Equip"]["Can"]["reqSTR"];
    req_stat_textures[Maplestat::DEX][false]
        = item_tt["Equip"]["Cannot"]["reqDEX"];
    req_stat_textures[Maplestat::DEX][true]
        = item_tt["Equip"]["Can"]["reqDEX"];
    req_stat_textures[Maplestat::INT][false]
        = item_tt["Equip"]["Cannot"]["reqINT"];
    req_stat_textures[Maplestat::INT][true]
        = item_tt["Equip"]["Can"]["reqINT"];
    req_stat_textures[Maplestat::LUK][false]
        = item_tt["Equip"]["Cannot"]["reqLUK"];
    req_stat_textures[Maplestat::LUK][true]
        = item_tt["Equip"]["Can"]["reqLUK"];

    req_stat_positions[Maplestat::LEVEL] = {98, 48};
    req_stat_positions[Maplestat::STR] = {98, 64};
    req_stat_positions[Maplestat::DEX] = {98, 72};
    req_stat_positions[Maplestat::INT] = {173, 64};
    req_stat_positions[Maplestat::LUK] = {173, 72};

    req_set[false] = {item_tt["Equip"]["Cannot"], Charset::LEFT};
    req_set[true] = {item_tt["Equip"]["Can"], Charset::LEFT};

    jobs_back = item_tt["Equip"]["Job"]["normal"];
    jobs[false][0] = item_tt["Equip"]["Job"]["disable"]["0"];
    jobs[false][1] = item_tt["Equip"]["Job"]["disable"]["1"];
    jobs[false][2] = item_tt["Equip"]["Job"]["disable"]["2"];
    jobs[false][3] = item_tt["Equip"]["Job"]["disable"]["3"];
    jobs[false][4] = item_tt["Equip"]["Job"]["disable"]["4"];
    jobs[false][5] = item_tt["Equip"]["Job"]["disable"]["5"];
    jobs[true][0] = item_tt["Equip"]["Job"]["enable"]["0"];
    jobs[true][1] = item_tt["Equip"]["Job"]["enable"]["1"];
    jobs[true][2] = item_tt["Equip"]["Job"]["enable"]["2"];
    jobs[true][3] = item_tt["Equip"]["Job"]["enable"]["3"];
    jobs[true][4] = item_tt["Equip"]["Job"]["enable"]["4"];
    jobs[true][5] = item_tt["Equip"]["Job"]["enable"]["5"];

    inv_pos = 0;
}

void EquipTooltip::set_equip(Parent parent, std::int16_t ivp)
{
    if (ivp == inv_pos) {
        return;
    }

    inv_pos = ivp;

    const Player& player = Stage::get().get_player();

    InventoryType::Id invtype;
    switch (parent) {
    case ITEM_INVENTORY:
    case SHOP:
        invtype = InventoryType::EQUIP;
        break;
    case EQUIP_INVENTORY:
        invtype = InventoryType::EQUIPPED;
        break;
    default:
        invtype = InventoryType::NONE;
    }

    auto oequip = player.get_inventory().get_equip(invtype, ivp);
    if (!oequip) {
        return;
    }

    const Equip& equip = *oequip;

    std::int32_t item_id = equip.get_item_id();

    const EquipData& equip_data = EquipData::get(item_id);
    const ItemData& item_data = equip_data.get_item_data();
    const CharStats& stats = player.get_stats();

    height = 500;

    item_icon = item_data.get_icon(true);

    for (auto& ms : requirements) {
        can_equip[ms] = stats.get_stat(ms) >= equip_data.get_req_stat(ms);
        std::string reqstr = std::to_string(equip_data.get_req_stat(ms));
        reqstr.insert(0, 3 - reqstr.size(), '0');
        req_stat_strings[ms] = reqstr;
    }

    ok_jobs.clear();
    switch (equip_data.get_req_stat(Maplestat::JOB)) {
    case 0:
        ok_jobs.push_back(0);
        ok_jobs.push_back(1);
        ok_jobs.push_back(2);
        ok_jobs.push_back(3);
        ok_jobs.push_back(4);
        ok_jobs.push_back(5);
        can_equip[Maplestat::JOB] = true;
        break;
    case 1:
        ok_jobs.push_back(1);
        can_equip[Maplestat::JOB]
            = (stats.get_stat(Maplestat::JOB) / 100 == 1)
              || (stats.get_stat(Maplestat::JOB) / 100 >= 20);
        break;
    case 2:
        ok_jobs.push_back(2);
        can_equip[Maplestat::JOB] = stats.get_stat(Maplestat::JOB) / 100 == 2;
        break;
    case 4:
        ok_jobs.push_back(3);
        can_equip[Maplestat::JOB] = stats.get_stat(Maplestat::JOB) / 100 == 3;
        break;
    case 8:
        ok_jobs.push_back(4);
        can_equip[Maplestat::JOB] = stats.get_stat(Maplestat::JOB) / 100 == 4;
        break;
    case 16:
        ok_jobs.push_back(5);
        can_equip[Maplestat::JOB] = stats.get_stat(Maplestat::JOB) / 100 == 5;
        break;
    default:
        can_equip[Maplestat::JOB] = false;
    }

    prank = equip.get_potrank();
    switch (prank) {
    case Equip::POT_HIDDEN:
        pot_flag = Text(Text::A11M, Text::CENTER, Text::RED);
        pot_flag.change_text("(Hidden Potential)");
        break;
    case Equip::POT_RARE:
        pot_flag = Text(Text::A11M, Text::CENTER, Text::WHITE);
        pot_flag.change_text("(Rare Item)");
        break;
    case Equip::POT_EPIC:
        pot_flag = Text(Text::A11M, Text::CENTER, Text::WHITE);
        pot_flag.change_text("(Epic Item)");
        break;
    case Equip::POT_UNIQUE:
        pot_flag = Text(Text::A11M, Text::CENTER, Text::WHITE);
        pot_flag.change_text("(Unique Item)");
        break;
    case Equip::POT_LEGENDARY:
        pot_flag = Text(Text::A11M, Text::CENTER, Text::WHITE);
        pot_flag.change_text("(Legendary Item)");
        break;
    default:
        height -= 16;
    }

    Text::Color namecolor;
    switch (equip.get_quality()) {
    case EquipQuality::GREY:
        namecolor = Text::LIGHTGREY;
        break;
    case EquipQuality::ORANGE:
        namecolor = Text::ORANGE;
        break;
    case EquipQuality::BLUE:
        namecolor = Text::MEDIUMBLUE;
        break;
    case EquipQuality::VIOLET:
        namecolor = Text::VIOLET;
        break;
    case EquipQuality::GOLD:
        namecolor = Text::YELLOW;
        break;
    default:
        namecolor = Text::WHITE;
    }

    std::string name_str{item_data.get_name()};
    if (equip.get_level() > 0) {
        name_str.append(" (+");
        name_str.append(std::to_string(equip.get_level()));
        name_str.push_back(')');
    }
    name = {Text::A12B, Text::CENTER, namecolor, std::move(name_str), 400};

    std::string_view desc_text = item_data.get_desc();
    has_desc = desc_text.size() > 0;
    if (has_desc) {
        desc = {
            Text::A12M, Text::LEFT, Text::WHITE, std::string{desc_text}, 250};
        height += desc.height() + 10;
    }

    category = {Text::A11L,
                Text::LEFT,
                Text::WHITE,
                str::concat("CATEGORY: ", equip_data.get_type())};

    is_weapon = equip_data.is_weapon();
    if (is_weapon) {
        const WeaponData& weapon = WeaponData::get(item_id);
        wep_speed = {Text::A11L,
                     Text::LEFT,
                     Text::WHITE,
                     str::concat("ATTACK SPEED: ", weapon.get_speed_string())};
    } else {
        height -= 18;
    }

    has_slots = equip.get_slots() > 0 || equip.get_level() > 0;
    if (has_slots) {
        slots = {Text::A11L,
                 Text::LEFT,
                 Text::WHITE,
                 "UPGRADES AVAILABLE: " + std::to_string(equip.get_slots())};

        std::string vicious = std::to_string(equip.get_vicious());
        if (equip.get_vicious() > 1) {
            vicious.append(" (MAX) ");
        }
        hammers = {Text::A11L,
                   Text::LEFT,
                   Text::WHITE,
                   "VICIOUS HAMMERS USED: " + vicious};
    } else {
        height -= 36;
    }

    stat_labels.clear();
    for (Equipstat::Id es = Equipstat::STR; es <= Equipstat::JUMP;
         es = static_cast<Equipstat::Id>(es + 1)) {
        if (equip.get_stat(es) > 0) {
            std::int16_t delta
                = equip.get_stat(es) - equip_data.get_def_stat(es);
            std::string stat_str = std::to_string(equip.get_stat(es));
            if (delta != 0) {
                stat_str.append(" (");
                stat_str.push_back(delta < 0 ? '-' : '+');
                stat_str.append(std::to_string(std::abs(delta)));
                stat_str.push_back(')');
            }
            stat_labels[es]
                = {Text::A11L,
                   Text::LEFT,
                   Text::WHITE,
                   Equipstat::names[es] + std::string(": ") + stat_str};
        } else {
            height -= 18;
        }
    }
}

void EquipTooltip::draw(Point<std::int16_t> pos) const
{
    if (inv_pos == 0) {
        return;
    }

    top.draw({pos});
    mid.draw(
        {pos + Point<std::int16_t>{0, 13}, Point<std::int16_t>{0, height}});
    bot.draw({pos + Point<std::int16_t>{0, height + 13}});

    name.draw(pos + Point<std::int16_t>{130, 3});
    if (prank != Equip::POT_NONE) {
        pot_flag.draw(pos + Point<std::int16_t>{130, 20});
        pos.shift_y(16);
    }
    pos.shift_y(26);

    line.draw({pos});

    auto pos_plus_10 = pos + 10;
    base.draw(pos_plus_10);
    shade.draw(pos_plus_10);
    item_icon.draw({pos + Point<std::int16_t>{20, 82}, 2.0f, 2.0f});
    potential[prank].draw(pos_plus_10);
    cover.draw(pos_plus_10);

    pos.shift_y(12);

    for (Maplestat::Id ms : requirements) {
        Point<std::int16_t> req_pos = req_stat_positions[ms];
        bool req_ok = can_equip[ms];
        req_stat_textures[ms][req_ok].draw({pos + req_pos});
        req_set[req_ok].draw(req_stat_strings[ms],
                             6,
                             {pos + req_pos + Point<std::int16_t>{54, 0}});
    }

    pos.shift_y(88);

    Point<std::int16_t> job_position(pos + Point<std::int16_t>{8, 0});
    jobs_back.draw(job_position);
    for (auto& ok_job : ok_jobs) {
        jobs[can_equip[Maplestat::JOB]][ok_job].draw(job_position);
    }

    line.draw({pos + Point<std::int16_t>{0, 30}});

    pos.shift_y(32);

    category.draw(pos + Point<std::int16_t>{10, 0});

    pos.shift_y(18);

    if (is_weapon) {
        wep_speed.draw(pos + Point<std::int16_t>{10, 0});
        pos.shift_y(18);
    }

    for (const Text& label : stat_labels.values()) {
        if (label.empty()) {
            continue;
        }

        label.draw(pos + Point<std::int16_t>{10, 0});
        pos.shift_y(18);
    }

    if (has_slots) {
        slots.draw(pos + Point<std::int16_t>{10, 0});
        pos.shift_y(18);
        hammers.draw(pos + Point<std::int16_t>{10, 0});
        pos.shift_y(18);
    }

    if (has_desc) {
        line.draw({pos + Point<std::int16_t>{0, 5}});
        desc.draw({pos + Point<std::int16_t>{10, 6}});
    }
}
} // namespace jrc

```

`IO/Components/EquipTooltip.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Equip.h"
#include "../../Character/Inventory/Weapon.h"
#include "../../Character/MapleStat.h"
#include "../../Graphics/Text.h"
#include "../../Template/BoolPair.h"
#include "../../Template/EnumMap.h"
#include "Charset.h"
#include "Tooltip.h"

#include <array>

namespace jrc
{
class EquipTooltip : public Tooltip
{
public:
    EquipTooltip();

    void set_equip(Parent parent, std::int16_t invpos);
    void draw(Point<std::int16_t> position) const override;

private:
    std::int16_t inv_pos;
    std::int16_t height;
    bool has_desc;
    bool has_slots;
    bool is_weapon;
    EnumMap<Maplestat::Id, std::string> req_stat_strings;
    Texture item_icon;

    Text name;
    Text desc;
    Text pot_flag;
    Text flag;
    Text category;
    Text wep_speed;
    Text slots;
    Text hammers;
    EnumMap<Equipstat::Id, Text> stat_labels;

    Texture top;
    Texture mid;
    Texture line;
    Texture bot;
    Texture base;

    EnumMap<Equip::Potential, Texture> potential;
    Equip::Potential prank;

    Texture cover;
    Texture shade;

    std::vector<Maplestat::Id> requirements;
    EnumMap<Maplestat::Id, BoolPair<Texture>> req_stat_textures;
    EnumMap<Maplestat::Id, bool> can_equip;
    EnumMap<Maplestat::Id, Point<std::int16_t>> req_stat_positions;
    BoolPair<Charset> req_set;

    Texture jobs_back;
    BoolPair<std::array<Texture, 6>> jobs;
    std::vector<std::uint8_t> ok_jobs;
};
} // namespace jrc

```

`IO/Components/Gauge.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Gauge.h"

namespace jrc
{
Gauge::Gauge(Texture front,
             Texture mid,
             Texture end,
             std::int16_t max,
             float percent) noexcept
    : bar_front{front},
      bar_mid{mid},
      bar_end{end},
      maximum{max},
      percentage{percent},
      target{percent}
{
}

Gauge::Gauge() = default;

void Gauge::draw(const DrawArgument& args) const
{
    auto length = static_cast<std::int16_t>(percentage * maximum);
    if (length > 0) {
        bar_front.draw(args);
        bar_mid.draw(args + DrawArgument{{1, 0}, {length, 0}});
        bar_end.draw(args + DrawArgument{length + 1, 0});
    }
}

void Gauge::update(float t)
{
    if (target != t) {
        target = t;
        step = (target - percentage) / 24.0f;
    }

    if (percentage != target) {
        percentage += step;
        if (step < 0.0f) {
            if (target - percentage >= step) {
                percentage = target;
            }
        } else if (step > 0.0f) {
            if (target - percentage <= step) {
                percentage = target;
            }
        }
    }
}
} // namespace jrc

```

`IO/Components/Gauge.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"

namespace jrc
{
class Gauge
{
public:
    Gauge(Texture front,
          Texture mid,
          Texture end,
          std::int16_t maximum,
          float percentage) noexcept;
    Gauge();

    void draw(const DrawArgument& args) const;
    void update(float target);

private:
    Texture bar_front;
    Texture bar_mid;
    Texture bar_end;
    std::int16_t maximum;

    float percentage;
    float target;
    float step;
};
} // namespace jrc

```

`IO/Components/Icon.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Icon.h"

#include "Charset.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Icon::Icon(std::unique_ptr<Type> t, Texture tx, std::int16_t c)
    : texture{tx}, type{std::move(t)}, count{c}
{
    texture.shift({0, 32});
    showcount = c > -1;
    dragged = false;
}

Icon::Icon() : Icon{std::make_unique<NullType>(), {}, -1}
{
}

void Icon::draw(Point<std::int16_t> position) const
{
    float opacity = dragged ? 0.5f : 1.0f;
    texture.draw({position, opacity});

    if (showcount) {
        static const Charset countset
            = {nl::nx::ui["Basic.img"]["ItemNo"], Charset::LEFT};
        std::int16_t tempc = count - (dragged ? 1 : 0);
        countset.draw(std::to_string(tempc),
                      position + Point<std::int16_t>{0, 20});
    }
}

void Icon::dragdraw(Point<std::int16_t> cursor_pos) const
{
    if (dragged) {
        texture.draw({cursor_pos - cursoroffset, 0.5f});
    }
}

void Icon::drop_on_stage() const
{
    type->drop_on_stage();
}

void Icon::drop_on_equips(Equipslot::Id eqslot) const
{
    type->drop_on_equips(eqslot);
}

void Icon::drop_on_items(InventoryType::Id tab,
                         Equipslot::Id eqslot,
                         std::int16_t slot,
                         bool equip) const
{
    type->drop_on_items(tab, eqslot, slot, equip);
}

std::int32_t Icon::get_action_id() const noexcept
{
    return type->get_action_id();
}

void Icon::start_drag(Point<std::int16_t> offset)
{
    cursoroffset = offset;
    dragged = true;
}

void Icon::reset()
{
    dragged = false;
}

void Icon::set_count(std::int16_t c)
{
    count = c;
}

std::int16_t Icon::get_count() const
{
    return count;
}
} // namespace jrc

```

`IO/Components/Icon.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Inventory.h"
#include "../../Graphics/Texture.h"
#include "../KeyAction.h"

#include <memory>

namespace jrc
{
class Icon
{
public:
    class Type
    {
    public:
        virtual ~Type() = default;

        virtual void drop_on_stage() const = 0;
        virtual void drop_on_equips(Equipslot::Id eqslot) const = 0;
        virtual void drop_on_items(InventoryType::Id tab,
                                   Equipslot::Id eqslot,
                                   std::int16_t slot,
                                   bool equip) const = 0;
        virtual std::int32_t get_action_id() const noexcept
        {
            return KeyAction::NO_ACTION;
        }
    };

    class NullType : public Type
    {
        void drop_on_stage() const override
        {
        }
        void drop_on_equips(Equipslot::Id) const override
        {
        }
        void drop_on_items(InventoryType::Id,
                           Equipslot::Id,
                           std::int16_t,
                           bool) const override
        {
        }
    };

    Icon(std::unique_ptr<Type> type, Texture texture, std::int16_t count);
    Icon();

    void draw(Point<std::int16_t> position) const;
    void dragdraw(Point<std::int16_t> cursor_pos) const;
    void drop_on_stage() const;
    void drop_on_equips(Equipslot::Id eqslot) const;
    void drop_on_items(InventoryType::Id tab,
                       Equipslot::Id eqslot,
                       std::int16_t slot,
                       bool equip) const;
    std::int32_t get_action_id() const noexcept;
    void start_drag(Point<std::int16_t> offset);
    void reset();
    void set_count(std::int16_t count);
    std::int16_t get_count() const;

private:
    Texture texture;
    std::unique_ptr<Type> type;
    Point<std::int16_t> cursoroffset;
    std::int16_t count;
    bool showcount;
    bool dragged;
};
} // namespace jrc

```

`IO/Components/IconCover.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "IconCover.h"

#include "../../Constants.h"

namespace jrc
{
IconCover::IconCover(Type t, std::int32_t duration)
{
    cover = ColorBox(30, 30, Geometry::BLACK, 0.6f);

    if (duration <= Constants::TIMESTEP) {
        scalestep = 1.0f;
    } else {
        scalestep = Constants::TIMESTEP * 1.0f / duration;
    }

    type = t;
    switch (type) {
    case BUFF:
        yscale.set(0.0f);
        break;
    case COOLDOWN:
        yscale.set(1.0f);
        break;
    }
}

void IconCover::draw(Point<std::int16_t> position, float alpha) const
{
    float interyscale = yscale.get(alpha);
    auto interheight = static_cast<std::int16_t>(30 * interyscale);
    if (interheight == 0)
        return;

    cover.draw({position + Point<std::int16_t>(0, 30 - interheight),
                Point<std::int16_t>(30, interheight)});
}

void IconCover::update()
{
    switch (type) {
    case BUFF:
        yscale += scalestep;
        if (yscale.last() >= 1.0f) {
            yscale.set(1.0f);
            scalestep = 0.0f;
        }
        break;
    case COOLDOWN:
        yscale -= scalestep;
        if (yscale.last() <= 0.0f) {
            yscale.set(0.0f);
            scalestep = 0.0f;
        }
        break;
    }
}
} // namespace jrc

```

`IO/Components/IconCover.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Geometry.h"
#include "../../Template/Interpolated.h"

namespace jrc
{
// A transparent rectangle with icon size (30x30).
class IconCover
{
public:
    enum Type { BUFF, COOLDOWN };

    IconCover(Type type, std::int32_t duration);

    void draw(Point<std::int16_t> position, float alpha) const;
    void update();

private:
    ColorBox cover;
    Linear<float> yscale;
    float scalestep;
    Type type;
};
} // namespace jrc

```

`IO/Components/ItemTooltip.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ItemTooltip.h"

#include "../../Data/ItemData.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
ItemTooltip::ItemTooltip()
{
    nl::node item_tt = nl::nx::ui["UIToolTip.img"]["Item"];

    top = item_tt["Frame"]["top"];
    mid = item_tt["Frame"]["line"];
    line = item_tt["Frame"]["dotline"];
    bot = item_tt["Frame"]["bottom"];
    base = item_tt["ItemIcon"]["base"];
    cover = item_tt["ItemIcon"]["cover"];
    shade = item_tt["ItemIcon"]["shade"];

    itemid = 0;
}

bool ItemTooltip::set_item(std::int32_t iid)
{
    if (itemid == iid) {
        return false;
    }

    itemid = iid;

    if (itemid == 0) {
        return false;
    }

    const ItemData& idata = ItemData::get(itemid);

    itemicon = idata.get_icon(false);
    name = {Text::A12B,
            Text::CENTER,
            Text::WHITE,
            std::string{idata.get_name()},
            240};
    desc = {Text::A12M,
            Text::LEFT,
            Text::WHITE,
            std::string{idata.get_desc()},
            150};

    fill_length = 81 + name.height();
    std::int16_t descdelta = desc.height() - 80;
    if (descdelta > 0) {
        fill_length += descdelta;
    }

    return true;
}

void ItemTooltip::draw(Point<std::int16_t> pos) const
{
    if (itemid == 0) {
        return;
    }

    top.draw(pos);
    mid.draw({pos + Point<std::int16_t>{0, 13},
              Point<std::int16_t>{0, fill_length}});
    bot.draw(pos + Point<std::int16_t>{0, fill_length + 13});

    name.draw(pos + Point<std::int16_t>{130, 3});

    pos.shift_y(4 + name.height());

    base.draw(pos + Point<std::int16_t>{10, 10});
    shade.draw(pos + Point<std::int16_t>{10, 10});
    itemicon.draw({pos + Point<std::int16_t>{20, 82}, 2.0f, 2.0f});
    cover.draw(pos + Point<std::int16_t>{10, 10});

    desc.draw(pos + Point<std::int16_t>{100, 6});
}
} // namespace jrc

```

`IO/Components/ItemTooltip.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "Charset.h"
#include "Tooltip.h"

namespace jrc
{
class ItemTooltip : public Tooltip
{
public:
    ItemTooltip();

    void draw(Point<std::int16_t> position) const override;

    bool set_item(std::int32_t itemid);

private:
    std::int32_t itemid;
    std::int16_t fill_length;
    Texture itemicon;

    Text name;
    Text desc;
    Texture top;
    Texture mid;
    Texture line;
    Texture bot;
    Texture base;
    Texture cover;
    Texture shade;
};
} // namespace jrc

```

`IO/Components/MapleButton.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapleButton.h"

namespace jrc
{
MapleButton::MapleButton(nl::node src, Point<std::int16_t> pos)
{
    textures[PRESSED] = src["pressed"]["0"];
    textures[MOUSE_OVER] = src["mouseOver"]["0"];
    textures[NORMAL] = src["normal"]["0"];
    textures[DISABLED] = src["disabled"]["0"];

    position = pos;
    state = NORMAL;
    active = true;
}

MapleButton::MapleButton(nl::node src) : MapleButton{src, {}}
{
}

void MapleButton::draw(Point<std::int16_t> parent_pos) const
{
    if (active) {
        textures[state].draw(position + parent_pos);
    }
}

Rectangle<std::int16_t>
MapleButton::bounds(Point<std::int16_t> parent_pos) const
{
    auto lt = parent_pos + position - textures[state].get_origin();
    auto rb = lt + textures[state].get_dimensions();
    return {lt, rb};
}
} // namespace jrc

```

`IO/Components/MapleButton.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "Button.h"

namespace jrc
{
//! A standard Maplestory button with 4 states and a texture for each state.
class MapleButton : public Button
{
public:
    MapleButton(nl::node src, Point<std::int16_t> position);
    MapleButton(nl::node src);

    void draw(Point<std::int16_t> parent_pos) const override;

    Rectangle<std::int16_t>
    bounds(Point<std::int16_t> parent_pos) const override;

private:
    Texture textures[NUM_STATES];
};
} // namespace jrc

```

`IO/Components/MapleFrame.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapleFrame.h"

#include "nlnx/nx.hpp"

#include <algorithm>

namespace jrc
{
MapleFrame::MapleFrame(nl::node src)
{
    center = src["c"];
    east = src["e"];
    northeast = src["ne"];
    north = src["n"];
    northwest = src["nw"];
    west = src["w"];
    southwest = src["sw"];
    south = src["s"];
    southeast = src["se"];

    x_tile = std::max<std::int16_t>(north.width(), 1);
    y_tile = std::max<std::int16_t>(west.height(), 1);
}

MapleFrame::MapleFrame() = default;

void MapleFrame::draw(Point<std::int16_t> position,
                      std::int16_t rwidth,
                      std::int16_t rheight) const
{
    std::int16_t numhor = rwidth / x_tile + 2;
    std::int16_t numver = rheight / y_tile;
    std::int16_t width = numhor * x_tile;
    std::int16_t height = numver * y_tile;
    std::int16_t left = position.x() - width / 2;
    std::int16_t top = position.y() - height;
    std::int16_t right = left + width;
    std::int16_t bottom = top + height;

    northwest.draw({left, top});
    southwest.draw({left, bottom});
    for (std::int16_t y = top; y < bottom; y += y_tile) {
        west.draw({left, y});
        east.draw({right, y});
    }
    center.draw({{left, top}, {width, height}});
    for (std::int16_t x = left; x < right; x += x_tile) {
        north.draw({x, top});
        south.draw({x, bottom});
    }
    northeast.draw({right, top});
    southeast.draw({right, bottom});
}
} // namespace jrc

```

`IO/Components/MapleFrame.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "nlnx/node.hpp"

namespace jrc
{
class MapleFrame
{
public:
    MapleFrame(nl::node src);
    MapleFrame();

    void draw(Point<std::int16_t> position,
              std::int16_t width,
              std::int16_t height) const;

private:
    Texture center;
    Texture east;
    Texture northeast;
    Texture north;
    Texture northwest;
    Texture west;
    Texture southwest;
    Texture south;
    Texture southeast;
    std::int16_t x_tile;
    std::int16_t y_tile;
};
} // namespace jrc

```

`IO/Components/Nametag.cpp`:

```cpp
//#pragma once
#include "Nametag.h"

namespace jrc
{
Nametag::Nametag(nl::node src, Text::Font f, Text::Color c, std::string&& n)
{
    name = Text(f, Text::CENTER, c);
    name.change_text(std::move(n));

    textures[false].push_back(src["0"]["0"]);
    textures[false].push_back(src["0"]["1"]);
    textures[false].push_back(src["0"]["2"]);
    textures[true].push_back(src["1"]["0"]);
    textures[true].push_back(src["1"]["1"]);
    textures[true].push_back(src["1"]["2"]);

    selected = false;
}

void Nametag::draw(Point<std::int16_t> position) const
{
    auto& tag = textures[selected];

    std::int16_t width = name.width();
    auto startpos = position - Point<std::int16_t>(8 + width / 2, -2);

    tag[0].draw(startpos);
    tag[1].draw(DrawArgument(startpos + Point<std::int16_t>(8, 0),
                             Point<std::int16_t>(width, 0)));
    tag[2].draw(DrawArgument(startpos + Point<std::int16_t>(width + 8, 0)));

    name.draw(position);
}

void Nametag::set_selected(bool s) noexcept
{
    selected = s;
}
} // namespace jrc

```

`IO/Components/Nametag.h`:

```h
#pragma once
#include "../../Graphics/Text.h"
#include "../../Graphics/Texture.h"
#include "../../Template/BoolPair.h"
#include "nlnx/node.hpp"

#include <vector>

namespace jrc
{
class Nametag
{
public:
    Nametag(nl::node src,
            Text::Font font,
            Text::Color color,
            std::string&& name);

    void draw(Point<std::int16_t> position) const;
    void set_selected(bool selected) noexcept;

private:
    Text name;
    BoolPair<std::vector<Texture>> textures;
    bool selected;
};
} // namespace jrc

```

`IO/Components/NpcText.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

// This will be moved into UINpcTalk.
// Keeping it so I can copypaste some code later.

/*
    std::size_t Npctext::parseL(std::string& str, std::size_t pos)
    {
        std::size_t next = str.find_first_of('#', pos + 2);
        if (next != std::string::npos)
        {
            try
            {
                //std::int32_t selection = std::stoi(str.substr(pos + 2, next -
   pos
   + 2)); str.replace(str.begin() + pos, str.begin() + next + 1, ""); return
   pos + 1;
            }
            catch (const std::exception&)
            {
                str.replace(str.begin() + pos, str.begin() + next + 1,
   "FORMATERROR"); return pos + 11 + 1;
            }
        }
        else
        {
            str.replace(str.begin() + pos, str.begin() + pos + 2,
   "SYNTAXERROR"); return pos + 11 + 1;
        }
    }

    std::size_t Npctext::parsez(std::string& str, std::size_t pos)
    {
        std::size_t next = str.find_first_of('#', pos + 2);
        if (next != std::string::npos)
        {
            try
            {
                const ItemData& idata = ItemData::get(std::stoi(str.substr(pos
   + 2, next))); if (idata.is_valid())
                {
                    str.replace(str.begin() + pos, str.begin() + next + 1,
   idata.get_name()); return pos + idata.get_name().length() + 1;
                }
                else
                {
                    str.replace(str.begin() + pos, str.begin() + next + 1,
   "IDERROR"); return pos + 7 + 1;
                }
            }
            catch (const std::exception&)
            {
                str.replace(str.begin() + pos, str.begin() + next + 1,
   "FORMATERROR"); return pos + 11 + 1;
            }
        }
        else
        {
            str.replace(str.begin() + pos, str.begin() + pos + 2,
   "SYNTAXERROR"); return pos + 11 + 1;
        }
    }

    std::size_t Npctext::parseh(std::string& str, std::size_t pos)
    {
        std::size_t next = str.find_first_of('#', pos + 2);
        if (next != std::string::npos)
        {
            try
            {
                std::int32_t type = std::stoi(str.substr(pos + 2, next - pos +
   2)); std::string insert; switch (type)
                {
                case 0:
                    insert = Stage::get().get_player().get_stats().get_name();
                    break;
                default:
                    insert = "";
                }
                str.replace(str.begin() + pos, str.begin() + next + 1, insert);
                return pos + insert.length() + 1;
            }
            catch (const std::exception&)
            {
                str.replace(str.begin() + pos, str.begin() + next + 1,
   "FORMATERROR"); return pos + 11 + 1;
            }
        }
        else
        {
            str.replace(str.begin() + pos, str.begin() + pos + 2,
   "SYNTAXERROR"); return pos + 11 + 1;
        }
    }

    std::size_t Npctext::parsev(std::string& str, std::size_t pos)
    {
        std::size_t next = str.find_first_of('#', pos + 2);
        if (next != std::string::npos)
        {
            try
            {
                if (const ItemData& idata =
   ItemData::get(std::stoi(str.substr(pos + 2, next))))
                {
                    Image image = { idata.get_icon(false), offset };
                    image.texture.shift(Point<std::int16_t>(0, 32));
                    images.push_back(image);
                    offset.shift_x(32);
                    str.replace(str.begin() + pos, str.begin() + next + 1, "");
                    return pos + 1;
                }
                else
                {
                    str.replace(str.begin() + pos, str.begin() + next + 1,
   "IDERROR"); return pos + 7 + 1;
                }
            }
            catch (const std::exception&)
            {
                str.replace(str.begin() + pos, str.begin() + next + 1,
   "FORMATERROR"); return pos + 11 + 1;
            }
        }
        else
        {
            str.replace(str.begin() + pos, str.begin() + pos + 2,
   "SYNTAXERROR"); return pos + 11 + 1;
        }
    }

    void Npctext::draw(Point<std::int16_t> position) const
    {
        for (auto& line : lines)
        {
            line.text
                .draw(line.offset + position);
        }

        for (auto& image : images)
        {
            image.texture
                .draw(image.offset + position);
        }
    }

    std::int16_t Npctext::getheight() const
    {
        return offset.y();
    }
*/

```

`IO/Components/ScrollingNotice.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ScrollingNotice.h"

#include "../../Constants.h"

namespace jrc
{
ScrollingNotice::ScrollingNotice()
{
    background = {Constants::GAME_VIEW_WIDTH, 20, ColorBox::BLACK, 0.6f};
    backposition = {0, -Constants::VIEW_Y_OFFSET};
    notice = Text(Text::A12M, Text::LEFT, Text::YELLOW);
    xpos.set(0.0);
    active = false;
}

void ScrollingNotice::set_notice(std::string&& n) noexcept
{
    notice.change_text(std::move(n));
    xpos.set(static_cast<double>(Constants::GAME_VIEW_WIDTH));
    active = n.size() > 0;
}

void ScrollingNotice::draw(float alpha) const
{
    if (active) {
        std::int16_t interx
            = static_cast<std::int16_t>(std::round(xpos.get(alpha)));
        auto position
            = Point<std::int16_t>(interx, -Constants::VIEW_Y_OFFSET - 2);
        background.draw(backposition);
        notice.draw(position);
    }
}

void ScrollingNotice::update() noexcept
{
    if (active) {
        xpos -= 0.5;

        auto xmin = static_cast<double>(-notice.width());
        if (xpos.last() < xmin) {
            xpos.set(static_cast<double>(Constants::GAME_VIEW_WIDTH));
        }
    }
}
} // namespace jrc

```

`IO/Components/ScrollingNotice.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Geometry.h"
#include "../../Graphics/Text.h"
#include "../../Template/Interpolated.h"

namespace jrc
{
//! The scrolling server notice at the top of the screen.
class ScrollingNotice
{
public:
    ScrollingNotice();

    void set_notice(std::string&& notice) noexcept;
    void draw(float alpha) const;
    void update() noexcept;

private:
    ColorBox background;
    Point<std::int16_t> backposition;
    Text notice;
    Linear<double> xpos;
    bool active;
};
} // namespace jrc

```

`IO/Components/SkillTooltip.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SkillTooltip.h"

#include "../../Data/SkillData.h"
#include "../../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
SkillTooltip::SkillTooltip() : line(318, Geometry::WHITE, 1.0f)
{
    nl::node itemtt = nl::nx::ui["UIToolTip.img"]["Item"];

    frame = itemtt["Frame2"];
    base = itemtt["ItemIcon"]["base"];
    cover = itemtt["ItemIcon"]["cover"];

    skill_id = 0;
}

void SkillTooltip::set_skill(std::int32_t id,
                             std::int32_t level,
                             std::int32_t mlevel,
                             std::int64_t expiration)
{
    if (skill_id == id) {
        return;
    }

    skill_id = id;

    if (skill_id == 0) {
        return;
    }

    const SkillData& data = SkillData::get(id);

    std::int32_t master_level;
    if (mlevel > 0) {
        master_level = mlevel;
    } else {
        master_level = data.get_master_level();
    }

    std::string desc_str{data.get_desc()};
    if (master_level > 0) {
        auto ml_str = std::to_string(master_level);
        std::size_t ml_start = desc_str.find("Master Level", 0, 12);
        std::size_t ml_pos = desc_str.find(':', ml_start) + 2;
        std::size_t ml_end = desc_str.find(']', ml_start);
        if (ml_pos < ml_end && ml_end != std::string::npos) {
            std::size_t ml_size = ml_end - ml_pos;
            desc_str.erase(ml_pos, ml_size);
            desc_str.insert(ml_pos, ml_str);

            // Fixing errors in the files...
            if (ml_start == 0) {
                desc_str.insert(0, "[", 1);
                ++ml_end;
            }
            std::size_t linebreak = desc_str.find("]\\n", ml_start, 3);
            if (linebreak != ml_end) {
                desc_str.insert(ml_end + 1, "\\n", 2);
            }
        } else {
            desc_str.insert(
                0, str::concat("[Master Level: ", std::move(ml_str), "]\\n"));
        }
    }

    if (expiration > 0) {
        // TODO
    } else {
        std::size_t exp_start = desc_str.find("#cAvailable until", 0, 17);
        std::size_t exp_end = desc_str.find('#', exp_start + 1);
        if (exp_start < exp_end && exp_end != std::string::npos) {
            std::size_t expsize = exp_end - exp_start + 1;
            desc_str.erase(exp_start, expsize);
        }
    }

    if (data.is_passive()) {
        desc_str += "\\r#cPassive Skill#";
    }

    icon = data.get_icon(SkillData::NORMAL);
    name = {Text::A12B,
            Text::LEFT,
            Text::WHITE,
            std::string{data.get_name()},
            320};
    desc = {Text::A12M, Text::LEFT, Text::WHITE, std::move(desc_str), 230};
    leveldesc
        = {Text::A12M,
           Text::LEFT,
           Text::WHITE,
           [level, master_level, &data]() {
               if (level > 0) {
                   if (level < master_level) {
                       return str::concat("[Current Level: ",
                                          std::to_string(level),
                                          "]\\n",
                                          data.get_level_desc(level),
                                          "\\n",
                                          "[Next Level: ",
                                          std::to_string(level + 1),
                                          "]\\n",
                                          data.get_level_desc(level + 1));
                   } else {
                       return str::concat("[Current Level: ",
                                          std::to_string(level),
                                          "]\\n",
                                          data.get_level_desc(level));
                   }
               } else {
                   if (level < master_level) {
                       return str::concat("[Next Level: ",
                                          std::to_string(level + 1),
                                          "]\\n",
                                          data.get_level_desc(level + 1));
                   } else {
                       return std::string{};
                   }
               }
           }(),
           330};

    icon_offset = 4 + name.height();
    level_offset = std::max<std::int16_t>(desc.height(), 92) + 16;
    height = icon_offset + level_offset + leveldesc.height();
}

void SkillTooltip::draw(Point<std::int16_t> pos) const
{
    if (skill_id == 0) {
        return;
    }

    frame.draw(pos + Point<std::int16_t>(176, height + 16), 320, height);
    name.draw(pos + Point<std::int16_t>(16, 8));

    pos.shift_y(icon_offset);

    base.draw({pos + Point<std::int16_t>(12, 16)});
    icon.draw({pos + Point<std::int16_t>(22, 90), 2.0f, 2.0f});
    cover.draw({pos + Point<std::int16_t>(12, 16)});

    desc.draw(pos + Point<std::int16_t>(102, 12));

    pos.shift_y(level_offset);

    line.draw(pos + Point<std::int16_t>(14, 4));
    leveldesc.draw(pos + Point<std::int16_t>(12, 12));
}
} // namespace jrc

```

`IO/Components/SkillTooltip.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Geometry.h"
#include "../../Graphics/Text.h"
#include "MapleFrame.h"
#include "Tooltip.h"

namespace jrc
{
class SkillTooltip : public Tooltip
{
public:
    SkillTooltip();

    void draw(Point<std::int16_t> position) const override;

    void set_skill(std::int32_t id,
                   std::int32_t level,
                   std::int32_t masterlevel,
                   std::int64_t expiration);

private:
    std::int32_t skill_id;
    std::int16_t height;
    std::int16_t icon_offset;
    std::int16_t level_offset;
    Texture icon;
    Texture required_icon;

    Text name;
    Text desc;
    Text leveldesc;
    MapleFrame frame;
    ColorLine line;
    Texture base;
    Texture cover;
};
} // namespace jrc

```

`IO/Components/Slider.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Slider.h"

#include "nlnx/nx.hpp"

namespace jrc
{
Slider::Slider(std::int32_t type,
               Range<std::int16_t> ver,
               std::int16_t x_,
               std::int16_t unit_rows,
               std::int16_t row_max,
               std::function<void(bool)> on_moved_)
    : on_moved{on_moved_},
      vertical{ver},
      start{x_, vertical.first()},
      end{x_, vertical.second()},
      x{x_},
      scrolling{false},
      enabled{true}
{
    nl::node src = nl::nx::ui["Basic.img"]["VScr" + std::to_string(type)];

    nl::node dsrc = src["disabled"];

    d_base = dsrc["base"];
    d_next = dsrc["next"];
    d_prev = dsrc["prev"];

    nl::node esrc = src["enabled"];

    base = esrc["base"];

    prev = {esrc["prev0"], esrc["prev1"], start};
    next = {esrc["next0"], esrc["next1"], end};
    thumb = {esrc["thumb0"], esrc["thumb1"]};

    button_height = d_next.get_dimensions().y();

    set_rows(unit_rows, row_max);
}

Slider::Slider() : Slider{0, {}, 0, 0, 0, {}}
{
}

bool Slider::is_enabled() const
{
    return enabled;
}

void Slider::set_enabled(bool en)
{
    enabled = en;
}

void Slider::set_rows(std::int16_t new_row,
                      std::int16_t unit_rows,
                      std::int16_t row_max_)
{
    row_max = row_max_ - unit_rows;
    if (row_max > 0) {
        row_height = (vertical.length() - button_height * 2) / row_max;
    } else {
        row_height = 0;
    }
    row = new_row;
}

void Slider::set_rows(std::int16_t unit_rows, std::int16_t row_max_)
{
    set_rows(0, unit_rows, row_max_);
}

void Slider::set_vertical(Range<std::int16_t> ver)
{
    vertical = ver;
    start = {x, vertical.first()};
    end = {x, vertical.second()};
    prev.set_position(start);
    next.set_position(end);
    if (row_max > 0) {
        row_height = (vertical.length() - button_height * 2) / row_max;
    } else {
        row_height = 0;
    }
}

void Slider::draw(Point<std::int16_t> position) const
{
    Point<std::int16_t> fill{0, vertical.length() + button_height};

    if (enabled) {
        base.draw({position + start, fill});
        if (row_height > 0) {
            thumb.draw({position + get_thumb_pos()});
        }
        prev.draw({position});
        next.draw({position});
    } else {
        d_base.draw({position + start, fill});
        d_prev.draw({position});
        d_next.draw({position});
    }
}

bool Slider::remove_cursor(bool clicked)
{
    if (scrolling) {
        scrolling = clicked;
        return clicked;
    } else {
        thumb.set_state(Button::NORMAL);
        next.set_state(Button::NORMAL);
        prev.set_state(Button::NORMAL);
        return false;
    }
}

Point<std::int16_t> Slider::get_thumb_pos() const
{
    std::int16_t y = row < row_max
                         ? vertical.first() + row * row_height + button_height
                         : vertical.second() - button_height * 2 - 2;
    return {x, y};
}

Cursor::State Slider::send_cursor(Point<std::int16_t> cursor, bool pressed)
{
    Point<std::int16_t> relative = cursor - start;
    if (scrolling) {
        if (pressed) {
            std::int16_t thumby = row * row_height + button_height * 2;
            std::int16_t delta = relative.y() - thumby;
            if (delta > row_height / 2 && row < row_max) {
                ++row;
                on_moved(false);
            } else if (delta < -row_height / 2 && row > 0) {
                --row;
                on_moved(true);
            }
            return Cursor::CLICKING;
        } else {
            scrolling = false;
        }
    } else if (relative.x() < 0 || relative.y() < 0 || relative.x() > 8
               || relative.y() > vertical.second()) {
        thumb.set_state(Button::NORMAL);
        next.set_state(Button::NORMAL);
        prev.set_state(Button::NORMAL);
        return Cursor::IDLE;
    }

    Point<std::int16_t> thumbpos = get_thumb_pos();
    if (thumb.bounds(thumbpos).contains(cursor)) {
        if (pressed) {
            scrolling = true;
            thumb.set_state(Button::PRESSED);
            return Cursor::CLICKING;
        } else {
            thumb.set_state(Button::MOUSE_OVER);
            return Cursor::V_SCROLL;
        }
    } else {
        thumb.set_state(Button::NORMAL);
    }

    if (prev.bounds(Point<std::int16_t>{}).contains(cursor)) {
        if (pressed) {
            if (row > 0) {
                --row;
                on_moved(true);
            }

            prev.set_state(Button::PRESSED);
            return Cursor::CLICKING;
        } else {
            prev.set_state(Button::MOUSE_OVER);
            return Cursor::CAN_CLICK;
        }
    } else {
        prev.set_state(Button::NORMAL);
    }

    if (next.bounds(Point<std::int16_t>{}).contains(cursor)) {
        if (pressed) {
            if (row < row_max) {
                ++row;
                on_moved(false);
            }

            next.set_state(Button::PRESSED);
            return Cursor::CLICKING;
        } else {
            next.set_state(Button::MOUSE_OVER);
            return Cursor::CAN_CLICK;
        }
    } else {
        next.set_state(Button::NORMAL);
    }

    if (pressed) {
        auto y_offset = static_cast<double>(relative.y() - button_height * 2);
        auto cursor_row
            = static_cast<std::int16_t>(std::round(y_offset / row_height));
        if (cursor_row < 0) {
            cursor_row = 0;
        } else if (cursor_row > row_max) {
            cursor_row = row_max;
        }

        std::int16_t delta = row - cursor_row;
        while (delta > 0) {
            --delta;
            on_moved(true);
        }
        while (delta < 0) {
            ++delta;
            on_moved(false);
        }

        row = cursor_row;
    }

    return Cursor::IDLE;
}
} // namespace jrc

```

`IO/Components/Slider.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../Cursor.h"
#include "TwoSpriteButton.h"

#include <functional>
#include <memory>

namespace jrc
{
class Slider
{
public:
    Slider(std::int32_t type,
           Range<std::int16_t> vertical,
           std::int16_t x,
           std::int16_t unit_rows,
           std::int16_t row_max,
           std::function<void(bool upwards)> on_moved);
    Slider();

    bool is_enabled() const;
    void set_enabled(bool enabled);
    void set_rows(std::int16_t new_row,
                  std::int16_t unit_rows,
                  std::int16_t row_max_);
    void set_rows(std::int16_t unit_rows, std::int16_t row_max);
    void set_vertical(Range<std::int16_t> vertical);

    void draw(Point<std::int16_t> position) const;
    bool remove_cursor(bool clicked);
    Cursor::State send_cursor(Point<std::int16_t> cursor, bool pressed);

private:
    Point<std::int16_t> get_thumb_pos() const;

    std::function<void(bool upwards)> on_moved;

    Range<std::int16_t> vertical;
    Point<std::int16_t> start;
    Point<std::int16_t> end;
    std::int16_t button_height;
    std::int16_t row_height;
    std::int16_t x;
    std::int16_t row;
    std::int16_t row_max;
    bool scrolling;
    bool enabled;

    Texture d_base;
    Texture d_next;
    Texture d_prev;
    Texture base;
    TwoSpriteButton next;
    TwoSpriteButton prev;
    TwoSpriteButton thumb;
};
} // namespace jrc

```

`IO/Components/SliderHoriz.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SliderHoriz.h"

namespace jrc
{
SliderHoriz::SliderHoriz(nl::node src,
                         Range<std::int16_t> horiz,
                         std::int16_t y_pos,
                         std::int16_t unit_cols,
                         std::int16_t col_max_,
                         std::function<void(std::int16_t, bool)> on_moved_)
    : on_moved{on_moved_},
      horizontal{horiz},
      start{horizontal.first(), y_pos},
      end{horizontal.second(), y_pos},
      y{y_pos},
      state{NORMAL},
      scrolling{false},
      enabled{true},
      normal{src["0"]},
      pressed{src["1"]},
      disabled{src["2"]},
      mouse_over{src["3"]}
{
    button_width = normal.get_dimensions().x();
    set_cols(unit_cols, col_max_);
}

bool SliderHoriz::is_enabled() const noexcept
{
    return enabled;
}

void SliderHoriz::set_enabled(bool en) noexcept
{
    enabled = en;
    if (!enabled) {
        state = DISABLED;
    }
}

void SliderHoriz::set_cols(std::int16_t new_col,
                           std::int16_t unit_cols,
                           std::int16_t col_max_) noexcept
{
    col_max = col_max_ - unit_cols;
    if (col_max > 0) {
        col_width = horizontal.length() / col_max;
    } else {
        col_width = 0;
    }
    col = new_col;
}

void SliderHoriz::set_cols(std::int16_t unit_cols,
                           std::int16_t col_max_) noexcept
{
    set_cols(0, unit_cols, col_max_);
}

void SliderHoriz::set_horizontal(Range<std::int16_t> horiz) noexcept
{
    horizontal = horiz;
    start = {horizontal.first(), y};
    end = {horizontal.second(), y};

    if (col_max > 0) {
        col_width = horizontal.length() / col_max;
    } else {
        col_width = 0;
    }
}

void SliderHoriz::draw(Point<std::int16_t> position) const
{
    if (col_width <= 0) {
        return;
    }

    const auto& texture = [this] {
        switch (state) {
        case NORMAL:
            return normal;
        case PRESSED:
            return pressed;
        case DISABLED:
            return disabled;
        case MOUSE_OVER:
            return mouse_over;
        }
    }();
    texture.draw({position + get_thumb_pos()});
}

bool SliderHoriz::remove_cursor(bool clicked) noexcept
{
    if (scrolling) {
        scrolling = clicked;
        state = clicked ? PRESSED : NORMAL;
        return clicked;
    }

    state = NORMAL;
    return false;
}

Point<std::int16_t> SliderHoriz::get_thumb_pos() const noexcept
{
    std::int16_t x = col < col_max ? horizontal.first()
                                         + col * horizontal.length() / col_max
                                   : horizontal.second();
    return {x, y};
}

Cursor::State SliderHoriz::send_cursor(Point<std::int16_t> cursor,
                                       bool cursor_pressed) noexcept
{
    if (!enabled) {
        return Cursor::IDLE;
    }

    Point<std::int16_t> relative = cursor - start;
    if (scrolling) {
        if (cursor_pressed) {
            std::int16_t thumb_x
                = col * horizontal.length() / col_max + button_width / 2;
            std::int16_t delta = relative.x() - thumb_x;
            if (delta > col_width / 2 && col < col_max) {
                ++col;
                on_moved(col, false);
            } else if (delta < -col_width / 2 && col > 0) {
                --col;
                on_moved(col, true);
            }

            state = PRESSED;
            return Cursor::CLICKING;
        } else {
            scrolling = false;
        }
    }

    if (relative.x() < 0 || relative.y() < 0
        || relative.x()
               > horizontal.second() - button_width * 2 - button_width / 2
        || relative.y() > normal.get_dimensions().y()) {
        state = NORMAL;
        return Cursor::IDLE;
    }

    if (cursor_pressed) {
        auto x_offset = static_cast<double>(relative.x() - button_width / 2);
        auto cursor_col = static_cast<std::int16_t>(
            std::round(x_offset * col_max / horizontal.length()));
        if (cursor_col < 0) {
            cursor_col = 0;
        } else if (cursor_col > col_max) {
            cursor_col = col_max;
        }

        std::int16_t old_col = col;
        col = cursor_col;
        if (col > old_col) {
            on_moved(col, true);
        } else if (old_col > col) {
            on_moved(col, false);
        }

        scrolling = true;
        state = PRESSED;

        return Cursor::CLICKING;
    }

    state = MOUSE_OVER;

    return Cursor::CAN_CLICK;
}

SliderHoriz::State SliderHoriz::get_state() const noexcept
{
    return state;
}

std::int16_t SliderHoriz::get_col() const noexcept
{
    return col;
}
} // namespace jrc

```

`IO/Components/SliderHoriz.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../Cursor.h"
#include "nlnx/nx.hpp"

#include <functional>

namespace jrc
{
class SliderHoriz
{
public:
    enum State : std::uint8_t { NORMAL, PRESSED, DISABLED, MOUSE_OVER };

    SliderHoriz(
        nl::node src,
        Range<std::int16_t> horiz,
        std::int16_t y_pos,
        std::int16_t unit_cols,
        std::int16_t col_max_,
        std::function<void(std::int16_t new_col, bool rightwards)> on_moved_);
    SliderHoriz() = default;

    bool is_enabled() const noexcept;
    void set_enabled(bool enabled) noexcept;
    void set_cols(std::int16_t new_col,
                  std::int16_t unit_cols,
                  std::int16_t col_max_) noexcept;
    void set_cols(std::int16_t unit_cols, std::int16_t col_max_) noexcept;
    void set_horizontal(Range<std::int16_t> horiz) noexcept;

    void draw(Point<std::int16_t> position) const;
    bool remove_cursor(bool clicked) noexcept;
    Cursor::State send_cursor(Point<std::int16_t> cursor,
                              bool pressed) noexcept;

    [[nodiscard]] State get_state() const noexcept;
    [[nodiscard]] std::int16_t get_col() const noexcept;

private:
    Point<std::int16_t> get_thumb_pos() const noexcept;

    std::function<void(std::int16_t new_col, bool rightwards)> on_moved;

    Range<std::int16_t> horizontal;
    Point<std::int16_t> start;
    Point<std::int16_t> end;
    std::int16_t button_width;
    std::int16_t col_width;
    std::int16_t y;
    std::int16_t col;
    std::int16_t col_max;
    State state;
    bool scrolling;
    bool enabled;

    Texture normal;
    Texture pressed;
    Texture disabled;
    Texture mouse_over;
};
} // namespace jrc

```

`IO/Components/Textfield.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Textfield.h"

#include "../../Constants.h"
#include "../UI.h"

namespace jrc
{
Textfield::Textfield(Text::Font font,
                     Text::Alignment alignment,
                     Text::Color color,
                     Rectangle<std::int16_t> bnd,
                     std::size_t lim) noexcept
    : text_label(font, alignment, color, "", 0, false),
      text(),
      marker(font, alignment, color, "|"),
      show_marker(true),
      marker_pos(0),
      bounds(bnd),
      limit(lim),
      crypt('\0'),
      state(NORMAL)
{
}

Textfield::Textfield() = default;

Textfield::~Textfield() = default;

void Textfield::draw(Point<std::int16_t> parent) const
{
    if (state == DISABLED) {
        return;
    }

    Point<std::int16_t> absp = bounds.get_lt() + parent;
    if (text.size() > 0) {
        text_label.draw(absp);
    }

    if (state == FOCUSED && show_marker) {
        Point<std::int16_t> mpos
            = absp + Point<std::int16_t>{text_label.advance(marker_pos), -1};
        marker.draw(mpos);
    }
}

void Textfield::update(Point<std::int16_t> parent) noexcept
{
    if (state == DISABLED) {
        return;
    }

    parent_pos = parent;

    elapsed += Constants::TIMESTEP;
    if (elapsed > 256) {
        show_marker = !show_marker;
        elapsed = 0;
    }
}

void Textfield::set_state(State st) noexcept
{
    if (state != st) {
        state = st;
        elapsed = 0;
        show_marker = true;

        if (state == FOCUSED) {
            UI::get().focus_text_field(this);
        }
    }
}

void Textfield::set_enter_callback(
    std::function<void(const std::string&)> on_ret) noexcept
{
    on_return = on_ret;
}

void Textfield::set_key_callback(std::int32_t key,
                                 std::function<void()> action) noexcept
{
    callbacks[key] = action;
}

void Textfield::send_key(KeyType::Id type,
                         std::int32_t key,
                         bool pressed) noexcept
{
    switch (type) {
    case KeyType::ACTION:
        if (pressed) {
            switch (key) {
            case KeyAction::LEFT:
                if (marker_pos > 0) {
                    --marker_pos;
                }
                break;
            case KeyAction::RIGHT:
                if (marker_pos < text.size()) {
                    ++marker_pos;
                }
                break;
            case KeyAction::BACK:
                if (text.size() > 0 && marker_pos > 0) {
                    text.erase(marker_pos - 1, 1);
                    --marker_pos;
                    text_modified();
                }
                break;
            case KeyAction::RETURN:
                if (on_return && text.size() > 0) {
                    on_return(text);
                    text = "";
                    marker_pos = 0;
                    text_modified();
                }
                break;
            case KeyAction::SPACE:
                if (marker_pos > 0 && below_limit()) {
                    text.insert(marker_pos, 1, ' ');
                    ++marker_pos;
                    text_modified();
                }
                break;
            default:
                if (callbacks.count(key)) {
                    callbacks.at(key)();
                }
                break;
            }
        }
        break;
    case KeyType::LETTER:
    case KeyType::NUMBER:
        if (pressed) {
            auto c = static_cast<char>(key);
            if (below_limit()) {
                text.insert(marker_pos, 1, c);
                ++marker_pos;
                text_modified();
            }
        }
        break;
    default:
        break;
    }
}

void Textfield::add_string(std::string_view str) noexcept
{
    for (char c : str) {
        if (below_limit()) {
            text.insert(marker_pos, 1, c);
            ++marker_pos;
            text_modified();
        }
    }
}

void Textfield::text_modified() noexcept
{
    if (crypt != '\0') {
        text_label.change_text(std::string(text.length(), crypt));
    } else {
        text_label.change_text(std::string{text});
    }
}

Cursor::State Textfield::send_cursor(Point<std::int16_t> cursorpos,
                                     bool clicked) noexcept
{
    if (state == DISABLED) {
        return Cursor::IDLE;
    }

    auto abs_bounds = get_bounds();
    if (abs_bounds.contains(cursorpos)) {
        if (clicked) {
            switch (state) {
            case NORMAL:
                set_state(FOCUSED);
                break;
            default:
                break;
            }
            return Cursor::CLICKING;
        } else {
            return Cursor::CAN_CLICK;
        }
    } else {
        if (clicked) {
            switch (state) {
            case FOCUSED:
                set_state(NORMAL);
                break;
            default:
                break;
            }
        }
        return Cursor::IDLE;
    }
}

void Textfield::change_text(std::string&& t) noexcept
{
    text = std::move(t);
    text_modified();
    marker_pos = text.size();
}

void Textfield::set_crypt_char(char c) noexcept
{
    crypt = c;
}

bool Textfield::below_limit() const noexcept
{
    if (limit > 0) {
        return text.size() < limit;
    } else {
        return text_label.advance(text.size()) + 50
               < bounds.get_horizontal().length();
    }
}

const std::string& Textfield::get_text() const noexcept
{
    return text;
}

bool Textfield::empty() const noexcept
{
    return text.empty();
}

Textfield::State Textfield::get_state() const noexcept
{
    return state;
}

Rectangle<std::int16_t> Textfield::get_bounds() const noexcept
{
    return {bounds.get_lt() + parent_pos, bounds.get_rb() + parent_pos};
}
} // namespace jrc

```

`IO/Components/Textfield.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "../../Template/Rectangle.h"
#include "../Cursor.h"
#include "../Keyboard.h"

#include <functional>
#include <string_view>
#include <unordered_map>

namespace jrc
{
class Textfield
{
public:
    enum State { NORMAL, DISABLED, FOCUSED };

    Textfield(Text::Font font,
              Text::Alignment alignment,
              Text::Color color,
              Rectangle<std::int16_t> bounds,
              std::size_t limit) noexcept;
    Textfield();
    ~Textfield();

    void draw(Point<std::int16_t> position) const;
    void update(Point<std::int16_t> parentpos) noexcept;
    void send_key(KeyType::Id type, std::int32_t code, bool down) noexcept;
    void add_string(std::string_view str) noexcept;

    void set_state(State state) noexcept;
    void change_text(std::string&& text) noexcept;
    void set_crypt_char(char c) noexcept;

    void set_enter_callback(
        std::function<void(const std::string&)> on_ret) noexcept;
    void set_key_callback(std::int32_t key,
                          std::function<void()> action) noexcept;

    Cursor::State send_cursor(Point<std::int16_t> cursorpos,
                              bool clicked) noexcept;

    bool empty() const noexcept;
    State get_state() const noexcept;
    Rectangle<std::int16_t> get_bounds() const noexcept;
    const std::string& get_text() const noexcept;

private:
    void text_modified() noexcept;
    bool below_limit() const noexcept;

    Text text_label;
    std::string text;
    Text marker;
    bool show_marker;
    std::uint16_t elapsed;
    std::size_t marker_pos;
    Rectangle<std::int16_t> bounds;
    Point<std::int16_t> parent_pos;
    std::size_t limit;
    char crypt;
    State state;

    std::unordered_map<std::int32_t, std::function<void()>> callbacks;
    std::function<void(const std::string&)> on_return;
};
} // namespace jrc

```

`IO/Components/Tooltip.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/Point.h"
#include "../UIElement.h"

#include <cstdint>

namespace jrc
{
//! Interface for tooltips, information windows about something
//! the mouse cursor is pointed at.
class Tooltip
{
public:
    //! Possible parent UIs for Tooltips.
    enum Parent { NONE, EQUIP_INVENTORY, ITEM_INVENTORY, SKILL_BOOK, SHOP };

    static constexpr bool same_ui_type(Parent p, UIElement::Type t) noexcept
    {
        switch (p) {
        case NONE:
            return t == UIElement::Type::NONE;
        case EQUIP_INVENTORY:
            return t == UIElement::Type::EQUIP_INVENTORY;
        case ITEM_INVENTORY:
            return t == UIElement::Type::ITEM_INVENTORY;
        case SKILL_BOOK:
            return t == UIElement::Type::SKILLBOOK;
        case SHOP:
            return t == UIElement::Type::SHOP;
        }

        return false;
    }

    virtual ~Tooltip() = default;

    virtual void draw(Point<std::int16_t> cursorpos) const = 0;
};
} // namespace jrc

```

`IO/Components/TwoSpriteButton.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "TwoSpriteButton.h"

namespace jrc
{
TwoSpriteButton::TwoSpriteButton(nl::node nsrc,
                                 nl::node ssrc,
                                 Point<std::int16_t> pos)
    : textures(ssrc, nsrc)
{
    position = pos;
    state = NORMAL;
    active = true;
}

TwoSpriteButton::TwoSpriteButton(nl::node nsrc, nl::node ssrc)
    : TwoSpriteButton(nsrc, ssrc, {})
{
}

TwoSpriteButton::TwoSpriteButton(Texture neg,
                                 Texture selected,
                                 Point<std::int16_t> pos)
    : textures(neg, selected)
{
    position = pos;
    state = NORMAL;
    active = true;
}

TwoSpriteButton::TwoSpriteButton(Texture neg, Texture selected)
    : TwoSpriteButton(neg, selected, {})
{
}

TwoSpriteButton::TwoSpriteButton() : textures({}, {})
{
}

void TwoSpriteButton::draw(Point<std::int16_t> parentpos) const
{
    if (active) {
        bool selected = state == MOUSE_OVER || state == PRESSED;
        textures[selected].draw(position + parentpos);
    }
}

Rectangle<std::int16_t>
TwoSpriteButton::bounds(Point<std::int16_t> parentpos) const
{
    bool selected = state == MOUSE_OVER || state == PRESSED;
    Point<std::int16_t> absp
        = parentpos + position - textures[selected].get_origin();
    Point<std::int16_t> dim = textures[selected].get_dimensions();
    return {absp, absp + dim};
}
} // namespace jrc

```

`IO/Components/TwoSpriteButton.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../../Template/BoolPair.h"
#include "Button.h"

#include <map>

namespace jrc
{
class TwoSpriteButton : public Button
{
public:
    TwoSpriteButton(nl::node nsrc,
                    nl::node ssrc,
                    Point<std::int16_t> position);
    TwoSpriteButton(nl::node nsrc, nl::node ssrc);
    TwoSpriteButton(Texture neg,
                    Texture selected,
                    Point<std::int16_t> position);
    TwoSpriteButton(Texture neg, Texture selected);
    TwoSpriteButton();

    void draw(Point<std::int16_t> position) const;
    Rectangle<std::int16_t> bounds(Point<std::int16_t> position) const;

private:
    BoolPair<Texture> textures;
};
} // namespace jrc

```

`IO/Cursor.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Cursor.h"

#include "../Constants.h"
#include "nlnx/nx.hpp"

namespace jrc
{
Cursor::Cursor()
{
    state = IDLE;
    hide_counter = 0;
}

void Cursor::init()
{
    nl::node src = nl::nx::ui["Basic.img"]["Cursor"];
    for (auto iter : animations) {
        iter.second = src[iter.first];
    }
}

void Cursor::draw(float alpha) const
{
    constexpr std::int64_t HIDE_AFTER = HIDE_TIME / Constants::TIMESTEP;

    if (hide_counter < HIDE_AFTER) {
        animations[state].draw(position, alpha);
    }
}

void Cursor::update()
{
    animations[state].update();

    switch (state) {
    case CAN_CLICK:
    case CAN_CLICK_2:
    case CAN_GRAB:
    case CLICKING:
    case GRABBING:
        hide_counter = 0;
        break;
    default:
        ++hide_counter;
        break;
    }
}

void Cursor::set_state(State s)
{
    if (state != s) {
        state = s;

        animations[state].reset();
        hide_counter = 0;
    }
}

void Cursor::set_position(Point<std::int16_t> pos)
{
    position = pos;
    hide_counter = 0;
}

Cursor::State Cursor::get_state() const
{
    return state;
}

Point<std::int16_t> Cursor::get_position() const
{
    return position;
}
} // namespace jrc

```

`IO/Cursor.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Animation.h"
#include "../Template/EnumMap.h"

namespace jrc
{
//! Class that represents the mouse cursor.
class Cursor
{
public:
    //! Maple-cursor states, linked to the cursor's animation.
    enum State {
        IDLE,
        CAN_CLICK,
        GAME,
        HOUSE,
        CAN_CLICK_2,
        CAN_GRAB,
        GIFT,
        V_SCROLL,
        H_SCROLL,
        V_SCROLL_IDLE,
        H_SCROLL_IDLE,
        GRABBING,
        CLICKING,
        R_CLICK,
        LENGTH
    };

    Cursor();

    void init();

    void draw(float alpha) const;
    void update();
    void set_state(State state);
    void set_position(Point<std::int16_t> position);
    State get_state() const;
    Point<std::int16_t> get_position() const;

private:
    EnumMap<State, Animation> animations;

    State state;
    Point<std::int16_t> position;
    std::int32_t hide_counter;

    static constexpr const std::int64_t HIDE_TIME = 15'000;
};
} // namespace jrc

```

`IO/KeyAction.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>

namespace jrc::KeyAction
{
//! Maple-specific keycodes, sent via the Keymap Packet.
enum Id : std::int32_t {
    EQUIPMENT_TAB = 0,
    INVENTORY = 1,
    CHAR_STATS = 2,
    SKILL_TAB = 3,
    BUDDY_TAB = 4,
    WORLD_MAP = 5,
    MESSENGER = 6,
    MINI_MAP = 7,
    QUEST_LOG = 8,
    KEY_CONFIG = 9,
    TO_ALL = 10,
    WHISPER = 11,
    TO_PARTY = 12,
    TO_FRIEND = 13,
    MAIN_MENU = 14,
    TOGGLE_QUICK_SLOT = 15,
    CHAT_WINDOW = 16,
    GUILD_TAB = 17,
    TO_GUILD = 18,
    PARTY_TAB = 19,
    HELPER = 20,
    MONSTER_BOOK = 21,
    CASH_SHOP = 22,
    TO_ALLIANCE = 23,
    PARTY_SEARCH = 24,
    TO_TALK = 25,
    MEDALS = 26,
    BOSS = 27,
    TO_EXPED = 28,
    PROFESSION = 29,
    ITEM_POT = 30,
    EVENT = 31,
    LEVEL_UP_GUIDE = 32,
    SILENT_CRUSADE = 33,
    BITS = 34,
    CHECK_NEW_TALK = 35,
    TOTS_KNOWHOW = 36,
    EPISODE = 37,
    HELPER_2 = 38, // ???
    GUIDE = 39,
    TO_SPOUSE = 40,
    EQUIP_ENHANCE = 41,
    PICK_UP = 50,
    SIT = 51,
    ATTACK = 52,
    JUMP = 53,
    NPC_CHAT = 54,
    LEFT = 60,
    RIGHT = 61,
    UP = 62,
    DOWN = 63,
    BACK = 64,
    RETURN = 65,
    SPACE = 66,
    TAB = 67,
    COPY = 68,
    PASTE = 69,
    NO_ACTION = 70,
    FACE_1 = 100,
    FACE_2 = 101,
    FACE_3 = 102,
    FACE_4 = 103,
    FACE_5 = 104,
    FACE_6 = 105,
    FACE_7 = 106,

    LAST
};

constexpr bool is_key_action(std::int32_t id) noexcept
{
    return id >= 0 && id < static_cast<std::int32_t>(LAST);
}

#ifdef NDEBUG
constexpr
#else
inline
#endif
    Id
    action_by_id(std::int32_t id) noexcept
{
#ifndef NDEBUG
    if (!is_key_action(id)) {
        Console::get().print("KeyAction::action_by_id(" + std::to_string(id)
                             + ") is not valid");
    }
#endif

    return static_cast<Id>(id);
}

constexpr bool is_item(std::int32_t id) noexcept
{
    return id >= 1'000'000;
}

//! We use negative numbers to represent skill IDs, e.g. a skill with ID
//! 1,000,001 is represented as `-1'000'001`.
constexpr bool is_skill(std::int32_t id) noexcept
{
    return id < 0;
}
} // namespace jrc::KeyAction

```

`IO/KeyType.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "KeyAction.h"

#include <array>
#include <cstdint>

namespace jrc::KeyType
{
//! Keytypes determine how a keycode is interpreted.
enum Id : std::uint8_t {
    NONE = 0,
    SKILL = 1,
    ITEM = 2,
    CASH = 3,
    MENU = 4,
    ACTION = 5,
    FACE = 6,
    MACRO = 8,
    LETTER = 9,
    NUMBER = 10,
    LENGTH
};

constexpr Id type_by_id(std::uint8_t id) noexcept
{
    if (id <= NONE || id >= LENGTH) {
        return NONE;
    }

    return static_cast<Id>(id);
}

constexpr Id type_by_action(std::int32_t action) noexcept
{
    constexpr const std::array<Id, KeyAction::LAST> ACTIONS_TO_TYPES{
        MENU,   MENU,   MENU,   MENU,   MENU,   MENU, MENU, MENU, MENU, MENU,
        MENU,   MENU,   MENU,   MENU,   MENU,   MENU, MENU, MENU, MENU, MENU,
        MENU,   MENU,   MENU,   MENU,   MENU,   MENU, MENU, MENU, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        ACTION, ACTION, ACTION, ACTION, ACTION, NONE, NONE, NONE, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        NONE,   NONE,   NONE,   NONE,   NONE,   NONE, NONE, NONE, NONE, NONE,
        FACE,   FACE,   FACE,   FACE,   FACE,   FACE, FACE};

    if (KeyAction::is_skill(action)) {
        return SKILL;
    } else if (KeyAction::is_item(action)) {
        return ITEM;
    }

    return ACTIONS_TO_TYPES[action];
}
} // namespace jrc::KeyType

```

`IO/Keyboard.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Keyboard.h"

#include <cstdint>

namespace jrc
{
Keyboard::Keyboard() noexcept
{
    keymap[GLFW_KEY_LEFT] = {KeyType::ACTION, KeyAction::LEFT};
    keymap[GLFW_KEY_RIGHT] = {KeyType::ACTION, KeyAction::RIGHT};
    keymap[GLFW_KEY_UP] = {KeyType::ACTION, KeyAction::UP};
    keymap[GLFW_KEY_DOWN] = {KeyType::ACTION, KeyAction::DOWN};

    textactions[GLFW_KEY_BACKSPACE] = KeyAction::BACK;
    textactions[GLFW_KEY_ENTER] = KeyAction::RETURN;
    textactions[GLFW_KEY_SPACE] = KeyAction::SPACE;
    textactions[GLFW_KEY_TAB] = KeyAction::TAB;
}

KeyAction::Id Keyboard::get_ctrl_action(std::int32_t keycode) const noexcept
{
    switch (keycode) {
    case GLFW_KEY_C:
        return KeyAction::COPY;
    case GLFW_KEY_V:
        return KeyAction::PASTE;
    default:
        return KeyAction::NO_ACTION;
    }
}

void Keyboard::assign(std::uint8_t key,
                      std::uint8_t tid,
                      std::int32_t action) noexcept
{
    if (KeyType::Id type = KeyType::type_by_id(tid); type) {
        Mapping mapping{type, action};
        keymap[KEY_TABLE[key]] = mapping;
        maplekeys[key] = mapping;
    }
}

Keyboard::Mapping Keyboard::get_text_mapping(std::int32_t keycode,
                                             bool shift) const noexcept
{
    if (textactions.count(keycode)) {
        return {KeyType::ACTION, textactions.at(keycode)};
    } else if (keycode >= 48 && keycode <= 64) {
        return {KeyType::NUMBER, keycode - (shift ? 15 : 0)};
    } else if (keycode >= 65 && keycode <= 90) {
        return {KeyType::LETTER, keycode + (shift ? 0 : 32)};
    } else {
        switch (keycode) {
        case GLFW_KEY_LEFT:
        case GLFW_KEY_RIGHT:
        case GLFW_KEY_UP:
        case GLFW_KEY_DOWN:
            if (auto keymap_iter = keymap.find(keycode);
                keymap_iter != keymap.end()) {
                return keymap.at(keycode);
            } else {
                return {};
            }
        default:
            return {};
        }
    }
}

Keyboard::Mapping Keyboard::get_mapping(std::int32_t keycode) const noexcept
{
    const auto iter = keymap.find(keycode);
    if (iter == keymap.end()) {
        return {};
    }

    return iter->second;
}

Keyboard::Mapping Keyboard::get_maple_mapping(std::uint8_t key_slot) const
    noexcept
{
    const auto iter = maplekeys.find(key_slot);
    if (iter == maplekeys.end()) {
        return {};
    }

    return iter->second;
}

const std::unordered_map<std::uint8_t, Keyboard::Mapping>&
Keyboard::get_maplekeys() const noexcept
{
    return maplekeys;
}

bool Keyboard::send_mappings() const noexcept
{
    return ChangeKeymapPacket{maplekeys}.dispatch();
}

void Keyboard::clear_mappings() noexcept
{
    keymap.clear();
    maplekeys.clear();

    keymap[GLFW_KEY_LEFT] = {KeyType::ACTION, KeyAction::LEFT};
    keymap[GLFW_KEY_RIGHT] = {KeyType::ACTION, KeyAction::RIGHT};
    keymap[GLFW_KEY_UP] = {KeyType::ACTION, KeyAction::UP};
    keymap[GLFW_KEY_DOWN] = {KeyType::ACTION, KeyAction::DOWN};
}
} // namespace jrc

```

`IO/Keyboard.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Net/Packets/GameplayPackets.h"
#include "../Template/Enumeration.h"
#include "KeyAction.h"
#include "KeyType.h"
#include "Window.h"

#include <cstdint>
#include <tuple>
#include <unordered_map>

namespace jrc
{
class Keyboard
{
public:
    struct Mapping {
        KeyType::Id type;
        std::int32_t action;

        Mapping() noexcept : type(KeyType::NONE)
        {
        }

        Mapping(KeyType::Id in_type, std::int32_t in_action) noexcept
            : type(in_type), action(in_action)
        {
        }

        explicit operator bool() const noexcept
        {
            return type != KeyType::NONE;
        }

        template<int I>
        auto const& get() const noexcept
        {
            static_assert(I == 0 || I == 1,
                          "Cannot `jrc::Keyboard::Mapping::get<I>()` for "
                          "`I != 0 && I != 1`");

            if constexpr (I == 0) {
                return type;
            } else {
                return action;
            }
        }
    };

    Keyboard() noexcept;
    Keyboard(const Keyboard&) = delete;
    Keyboard(Keyboard&&) = delete;

    void
    assign(std::uint8_t key, std::uint8_t type, std::int32_t action) noexcept;

    constexpr std::int32_t shift_code() const noexcept
    {
        return GLFW_KEY_LEFT_SHIFT;
    }

    constexpr std::int32_t ctrl_code() const noexcept
    {
        return GLFW_KEY_LEFT_CONTROL;
    }

    KeyAction::Id get_ctrl_action(std::int32_t keycode) const noexcept;
    Mapping get_mapping(std::int32_t keycode) const noexcept;
    Mapping get_maple_mapping(std::uint8_t key_slot) const noexcept;
    const std::unordered_map<std::uint8_t, Mapping>& get_maplekeys() const
        noexcept;
    Mapping get_text_mapping(std::int32_t keycode, bool shift) const noexcept;
    //! Sends a `ChangeKeymapPacket` packet to the server. Returns `true` on
    //! success.
    bool send_mappings() const noexcept;
    void clear_mappings() noexcept;

    static constexpr std::int32_t
    align_key_parity(std::int32_t keycode) noexcept
    {
        switch (keycode) {
        case GLFW_KEY_RIGHT_ALT:
            return GLFW_KEY_LEFT_ALT;
        case GLFW_KEY_RIGHT_CONTROL:
            return GLFW_KEY_LEFT_CONTROL;
        case GLFW_KEY_RIGHT_SHIFT:
            return GLFW_KEY_LEFT_SHIFT;
        default:
            return keycode;
        }
    }

private:
    std::unordered_map<std::int32_t, Mapping> keymap;
    std::unordered_map<std::uint8_t, Mapping> maplekeys;
    std::unordered_map<std::int32_t, KeyAction::Id> textactions;
    std::unordered_map<std::int32_t, bool> key_state;
};

constexpr std::array<std::int32_t, 90> KEY_TABLE{0,
                                                 0,
                                                 GLFW_KEY_0,
                                                 GLFW_KEY_1,
                                                 GLFW_KEY_2,
                                                 GLFW_KEY_3,
                                                 GLFW_KEY_4,
                                                 GLFW_KEY_5,
                                                 GLFW_KEY_6,
                                                 GLFW_KEY_7,
                                                 GLFW_KEY_8,
                                                 GLFW_KEY_9,
                                                 GLFW_KEY_MINUS,
                                                 GLFW_KEY_EQUAL,
                                                 0,
                                                 0,
                                                 GLFW_KEY_Q,
                                                 GLFW_KEY_W,
                                                 GLFW_KEY_E,
                                                 GLFW_KEY_R,
                                                 GLFW_KEY_T,
                                                 GLFW_KEY_Y,
                                                 GLFW_KEY_U,
                                                 GLFW_KEY_I,
                                                 GLFW_KEY_O,
                                                 GLFW_KEY_P,
                                                 GLFW_KEY_LEFT_BRACKET,
                                                 GLFW_KEY_RIGHT_BRACKET,
                                                 0,
                                                 GLFW_KEY_LEFT_CONTROL,
                                                 GLFW_KEY_A,
                                                 GLFW_KEY_S,
                                                 GLFW_KEY_D,
                                                 GLFW_KEY_F,
                                                 GLFW_KEY_G,
                                                 GLFW_KEY_H,
                                                 GLFW_KEY_J,
                                                 GLFW_KEY_K,
                                                 GLFW_KEY_L,
                                                 GLFW_KEY_SEMICOLON,
                                                 GLFW_KEY_APOSTROPHE,
                                                 GLFW_KEY_GRAVE_ACCENT,
                                                 GLFW_KEY_LEFT_SHIFT,
                                                 GLFW_KEY_BACKSLASH,
                                                 GLFW_KEY_Z,
                                                 GLFW_KEY_X,
                                                 GLFW_KEY_C,
                                                 GLFW_KEY_V,
                                                 GLFW_KEY_B,
                                                 GLFW_KEY_N,
                                                 GLFW_KEY_M,
                                                 GLFW_KEY_COMMA,
                                                 GLFW_KEY_PERIOD,
                                                 0,
                                                 0,
                                                 0,
                                                 GLFW_KEY_LEFT_ALT,
                                                 GLFW_KEY_SPACE,
                                                 0,
                                                 GLFW_KEY_F1,
                                                 GLFW_KEY_F2,
                                                 GLFW_KEY_F3,
                                                 GLFW_KEY_F4,
                                                 GLFW_KEY_F5,
                                                 GLFW_KEY_F6,
                                                 GLFW_KEY_F7,
                                                 GLFW_KEY_F8,
                                                 GLFW_KEY_F9,
                                                 GLFW_KEY_F10,
                                                 GLFW_KEY_F11,
                                                 GLFW_KEY_F12,
                                                 GLFW_KEY_HOME,
                                                 0,
                                                 GLFW_KEY_PAGE_UP,
                                                 0,
                                                 0,
                                                 0,
                                                 0,
                                                 0,
                                                 GLFW_KEY_END,
                                                 0,
                                                 GLFW_KEY_PAGE_DOWN,
                                                 GLFW_KEY_INSERT,
                                                 GLFW_KEY_DELETE,
                                                 0,
                                                 0,
                                                 0,
                                                 GLFW_KEY_F11,
                                                 GLFW_KEY_F12,
                                                 0};
} // namespace jrc

namespace std
{
template<>
struct tuple_size<jrc::Keyboard::Mapping>
    : std::integral_constant<std::size_t, 2> {
};

template<>
struct tuple_element<0, jrc::Keyboard::Mapping> {
    using type = jrc::KeyType::Id;
};

template<>
struct tuple_element<1, jrc::Keyboard::Mapping> {
    using type = std::int32_t;
};
} // namespace std

```

`IO/Messages.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Messages.h"

#include "UI.h"
#include "UITypes/UIStatusBar.h"

namespace jrc
{
const EnumMap<Messages::Type, const char*> Messages::messages = {
    "",
    "You cannot use this skill with this weapon.",
    "You do not have enough hp to use this skill.",
    "You do not have enough mp to use this skill.",
    "You do not have enough arrows to use this attack.",
    "You do not have enough bullets to use this attack.",
    "You do not have enough throwing stars to use this attack.",
    "You cannot use this skill as it is on cooldown.",
    "The scroll lights up and it's mysterious powers have been transferred to "
    "the item.",
    "The scroll lights up but the item remains as if nothing happened.",
    "The item has been destroyed due to the overwhelming power of the "
    "scroll."};

InChatMessage::InChatMessage(Messages::Type t)
{
    type = t;
}

void InChatMessage::drop() const
{
    if (type == Messages::NONE) {
        return;
    }

    if (auto statusbar = UI::get().get_element<UIStatusbar>()) {
        statusbar->display_message(type, UIChatbar::RED);
    }
}

ForbidSkillMessage::ForbidSkillMessage(SpecialMove::ForbidReason reason,
                                       Weapon::Type weapon)
    : InChatMessage(message_by_reason(reason, weapon))
{
}

Messages::Type
ForbidSkillMessage::message_by_reason(SpecialMove::ForbidReason reason,
                                      Weapon::Type weapon)
{
    switch (reason) {
    case SpecialMove::FBR_WEAPONTYPE:
        return Messages::SKILL_WEAPONTYPE;
    case SpecialMove::FBR_HPCOST:
        return Messages::SKILL_HPCOST;
    case SpecialMove::FBR_MPCOST:
        return Messages::SKILL_MPCOST;
    case SpecialMove::FBR_COOLDOWN:
        return Messages::SKILL_COOLDOWN;
    case SpecialMove::FBR_BULLETCOST:
        return message_by_weapon(weapon);
    default:
        return Messages::NONE;
    }
}

Messages::Type ForbidSkillMessage::message_by_weapon(Weapon::Type weapon)
{
    switch (weapon) {
    case Weapon::BOW:
    case Weapon::CROSSBOW:
        return Messages::SKILL_NOARROWS;
    case Weapon::CLAW:
        return Messages::SKILL_NOSTARS;
    default:
        return Messages::SKILL_NOBULLETS;
    }
}
} // namespace jrc

```

`IO/Messages.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Character/Inventory/Weapon.h"
#include "../Gameplay/Combat/SpecialMove.h"
#include "../Template/EnumMap.h"

#include <string>

namespace jrc
{
namespace Messages
{
enum Type {
    NONE,
    // Cannot use a skill
    SKILL_WEAPONTYPE,
    SKILL_HPCOST,
    SKILL_MPCOST,
    SKILL_NOARROWS,
    SKILL_NOBULLETS,
    SKILL_NOSTARS,
    SKILL_COOLDOWN,

    // Scrolling result
    SCROLL_SUCCESS,
    SCROLL_FAILURE,
    SCROLL_DESTROYED,
    LENGTH
};

extern const EnumMap<Type, const char*> messages;
}; // namespace Messages

class InChatMessage
{
public:
    InChatMessage(Messages::Type type);

    void drop() const;

private:
    Messages::Type type;
};

class ForbidSkillMessage : public InChatMessage
{
public:
    ForbidSkillMessage(SpecialMove::ForbidReason reason, Weapon::Type weapon);

private:
    Messages::Type message_by_reason(SpecialMove::ForbidReason reason,
                                     Weapon::Type weapon);
    Messages::Type message_by_weapon(Weapon::Type weapon);
};
} // namespace jrc

```

`IO/UI.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UI.h"

#include "../Graphics/GraphicsGL.h"
#include "UIStateGame.h"
#include "UIStateLogin.h"
#include "UITypes/UIChangeChannel.h"
#include "Window.h"

namespace jrc
{
UI::UI() noexcept : state{std::make_unique<UIStateNull>()}, enabled{true}
{
}

void UI::init()
{
    cursor.init();
    change_state(LOGIN);
}

void UI::draw(float alpha) const
{
    state->draw(alpha, cursor.get_position());

    scrolling_notice.draw(alpha);
    cursor.draw(alpha);
}

void UI::update()
{
    state->update();

    scrolling_notice.update();
    cursor.update();
}

void UI::enable()
{
    enabled = true;
}

void UI::disable()
{
    enabled = false;
}

void UI::change_state(State id)
{
    switch (id) {
    case LOGIN:
        Window::get().resize(false);
        state = std::make_unique<UIStateLogin>();
        break;
    case GAME:
        Window::get().resize(true);
        state = std::make_unique<UIStateGame>();
        break;
    }
}

void UI::quit()
{
    quitted = true;
}

bool UI::not_quitted() const
{
    return !quitted;
}

void UI::send_cursor(Point<std::int16_t> cursor_pos,
                     Cursor::State cursor_state)
{
    Cursor::State next_state = state->send_cursor(cursor_state, cursor_pos);
    cursor.set_state(next_state);
    cursor.set_position(cursor_pos);
}

void UI::send_cursor(bool pressed)
{
    Cursor::State cursor_state
        = pressed && enabled ? Cursor::CLICKING : Cursor::IDLE;
    auto cursor_pos = cursor.get_position();
    send_cursor(cursor_pos, cursor_state);

    if (focused_text_field && pressed) {
        Cursor::State t_state
            = focused_text_field->send_cursor(cursor_pos, pressed);
        switch (t_state) {
        case Cursor::IDLE:
            focused_text_field = {};
            break;
        default:
            break;
        }
    }
}

void UI::send_cursor(Point<std::int16_t> pos)
{
    send_cursor(pos, cursor.get_state());
}

void UI::doubleclick()
{
    auto pos = cursor.get_position();
    state->double_click(pos);
}

void UI::send_key(std::int32_t keycode, bool pressed)
{
    keycode = Keyboard::align_key_parity(keycode);

    if (focused_text_field) {
        bool ctrl = is_key_down[keyboard.ctrl_code()];
        if (ctrl) {
            if (!pressed) {
                KeyAction::Id action = keyboard.get_ctrl_action(keycode);
                switch (action) {
                case KeyAction::COPY:
                    Window::get().set_clipboard(
                        focused_text_field->get_text());
                    break;
                case KeyAction::PASTE:
                    focused_text_field->add_string(
                        Window::get().get_clipboard());
                    break;
                default:
                    break;
                }
            }
        } else {
            bool shift = is_key_down[keyboard.shift_code()];
            Keyboard::Mapping mapping
                = keyboard.get_text_mapping(keycode, shift);
            focused_text_field->send_key(
                mapping.type, mapping.action, pressed);
        }
    } else {
        if (auto cc_ui = get_element<UIChangeChannel>();
            cc_ui && cc_ui->is_active()) {
            auto cc_ui_key = [keycode] {
                switch (keycode) {
                case GLFW_KEY_UP:
                    return UIChangeChannel::SentKey::UP;
                case GLFW_KEY_DOWN:
                    return UIChangeChannel::SentKey::DOWN;
                case GLFW_KEY_LEFT:
                    return UIChangeChannel::SentKey::LEFT;
                case GLFW_KEY_RIGHT:
                    return UIChangeChannel::SentKey::RIGHT;
                case GLFW_KEY_ENTER:
                    return UIChangeChannel::SentKey::ENTER;
                default:
                    return UIChangeChannel::SentKey::NONE;
                }
            }();
            if (cc_ui_key != UIChangeChannel::SentKey::NONE) {
                if (!pressed) {
                    cc_ui->send_key(cc_ui_key);
                }
                is_key_down[keycode] = pressed;
                return;
            }
        }

        Keyboard::Mapping mapping = keyboard.get_mapping(keycode);
        if (mapping.type) {
            state->send_key(mapping.type, mapping.action, pressed);
        }
    }

    is_key_down[keycode] = pressed;
}

void UI::send_menu(KeyAction::Id action)
{
    state->send_key(KeyType::MENU, action, true);
}

void UI::set_scroll_notice(std::string&& notice) noexcept
{
    scrolling_notice.set_notice(std::move(notice));
}

void UI::focus_text_field(Textfield* to_focus) noexcept
{
    if (focused_text_field) {
        focused_text_field->set_state(Textfield::NORMAL);
    }

    focused_text_field = to_focus;
}

void UI::drag_icon(Icon* icon)
{
    state->drag_icon(icon);
}

void UI::add_keymapping(std::uint8_t no,
                        std::uint8_t type,
                        std::int32_t action)
{
    keyboard.assign(no, type, action);
}

void UI::clear_tooltip(Tooltip::Parent parent)
{
    state->clear_tooltip(parent);
}

void UI::show_equip(Tooltip::Parent parent, std::int16_t slot)
{
    state->show_equip(parent, slot);
}

void UI::show_item(Tooltip::Parent parent, std::int32_t item_id)
{
    state->show_item(parent, item_id);
}

void UI::show_skill(Tooltip::Parent parent,
                    std::int32_t skill_id,
                    std::int32_t level,
                    std::int32_t master_level,
                    std::int64_t expiration)
{
    state->show_skill(parent, skill_id, level, master_level, expiration);
}

void UI::remove(UIElement::Type type)
{
    focused_text_field = {};
    state->remove(type);
}

const Keyboard& UI::get_keyboard() const noexcept
{
    return keyboard;
}

Keyboard& UI::get_keyboard_mut() noexcept
{
    return keyboard;
}
} // namespace jrc

```

`IO/UI.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Singleton.h"
#include "../Template/nullable_ptr.h"
#include "Components/Icon.h"
#include "Components/ScrollingNotice.h"
#include "Components/Textfield.h"
#include "Cursor.h"
#include "Keyboard.h"
#include "UIState.h"

#include <unordered_map>

namespace jrc
{
class UI : public Singleton<UI>
{
public:
    enum State { LOGIN, GAME };

    UI() noexcept;

    void init();
    void draw(float alpha) const;
    void update();

    void enable();
    void disable();
    void change_state(State state);

    void quit();
    bool not_quitted() const;

    void send_cursor(Point<std::int16_t> pos);
    void send_cursor(bool pressed);
    void send_cursor(Point<std::int16_t> cursorpos, Cursor::State cursorstate);
    void doubleclick();
    void send_key(std::int32_t keycode, bool pressed);
    void send_menu(KeyAction::Id action);

    void set_scroll_notice(std::string&& notice) noexcept;
    void focus_text_field(Textfield* to_focus) noexcept;
    void drag_icon(Icon* icon);

    void
    add_keymapping(std::uint8_t no, std::uint8_t type, std::int32_t action);

    void clear_tooltip(Tooltip::Parent parent);
    void show_equip(Tooltip::Parent parent, std::int16_t slot);
    void show_item(Tooltip::Parent parent, std::int32_t item_id);
    void show_skill(Tooltip::Parent parent,
                    std::int32_t skill_id,
                    std::int32_t level,
                    std::int32_t master_level,
                    std::int64_t expiration);

    template<class T, typename... Args>
    nullable_ptr<T> emplace(Args&&... args);
    template<class T>
    nullable_ptr<T> get_element();
    void remove(UIElement::Type type);

    const Keyboard& get_keyboard() const noexcept;
    Keyboard& get_keyboard_mut() noexcept;

private:
    std::unique_ptr<UIState> state;
    Keyboard keyboard;
    Cursor cursor;
    ScrollingNotice scrolling_notice;

    nullable_ptr<Textfield> focused_text_field;
    std::unordered_map<std::int32_t, bool> is_key_down;

    bool enabled;
    bool quitted;
};

template<class T, typename... Args>
nullable_ptr<T> UI::emplace(Args&&... args)
{
    if (auto iter = state->pre_add(T::TYPE, T::TOGGLED, T::FOCUSED)) {
        (*iter).second = std::make_unique<T>(std::forward<Args>(args)...);
    }
    return state->get(T::TYPE);
}

template<class T>
nullable_ptr<T> UI::get_element()
{
    UIElement::Type type = T::TYPE;
    UIElement* element = state->get(type);
    return static_cast<T*>(element);
}
} // namespace jrc

```

`IO/UIDragElement.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Configuration.h"
#include "UIElement.h"

namespace jrc
{
template<Configuration::PositionOf P>
//! Base class for UI windows which can be moved with the mouse cursor.
class UIDragElement : public UIElement
{
public:
    bool remove_cursor(bool clicked, Point<std::int16_t> cursor_pos) override
    {
        if (dragged) {
            if (clicked) {
                position = cursor_pos - cursor_offset;
                return true;
            } else {
                dragged = false;
                Configuration::get().set_position_of(P, position);
            }
        }

        return false;
    }

    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> cursor_pos) override
    {
        if (clicked) {
            if (dragged) {
                position = cursor_pos - cursor_offset;
                return Cursor::CLICKING;
            } else if (in_drag_range(cursor_pos)) {
                cursor_offset = cursor_pos - position;
                dragged = true;
                return Cursor::CLICKING;
            }
        } else {
            if (dragged) {
                dragged = false;
                Configuration::get().set_position_of(P, position);
            }
        }

        return UIElement::send_cursor(clicked, cursor_pos);
    }

protected:
    UIDragElement(Point<std::int16_t> d) : dragged{false}, drag_area{d}
    {
        position = Configuration::get().get_position_of(P);
    }

    bool dragged;
    Point<std::int16_t> drag_area;
    Point<std::int16_t> cursor_offset;

private:
    bool in_drag_range(Point<std::int16_t> cursor_pos) const
    {
        const Rectangle<std::int16_t> bounds{position, position + drag_area};
        return bounds.contains(cursor_pos);
    }
};
} // namespace jrc

```

`IO/UIElement.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIElement.h"

#include "../Audio/Audio.h"
#include "../Constants.h"

namespace jrc
{
UIElement::UIElement(Point<std::int16_t> p, Point<std::int16_t> d, bool a)
    : position(p), dimension(d), active(a)
{
}

UIElement::UIElement(Point<std::int16_t> p, Point<std::int16_t> d)
    : UIElement(p, d, true)
{
}

UIElement::UIElement() : UIElement({}, {})
{
}

void UIElement::draw(float alpha) const
{
    draw_sprites(alpha);
    draw_buttons(alpha);
}

void UIElement::draw_sprites(float alpha) const
{
    for (const Sprite& sprite : sprites) {
        sprite.draw(position, alpha);
    }
}

void UIElement::draw_buttons(float) const
{
    for (const auto& [_, button] : buttons) {
        if (button) {
            button->draw(position);
        }
    }
}

void UIElement::update()
{
    for (auto& sprite : sprites) {
        sprite.update();
    }
}

void UIElement::make_active() noexcept
{
    active = true;
}

void UIElement::deactivate() noexcept
{
    active = false;
}

bool UIElement::is_active() const noexcept
{
    return active;
}

void UIElement::toggle_active()
{
    active = !active;
}

Button::State UIElement::button_pressed(std::uint16_t)
{
    return Button::DISABLED;
}

void UIElement::send_icon(const Icon&, Point<std::int16_t>)
{
}

void UIElement::double_click(Point<std::int16_t>)
{
}

bool UIElement::is_in_range(Point<std::int16_t> cursor_pos) const
{
    const Rectangle<std::int16_t> bounds{position, position + dimension};
    return bounds.contains(cursor_pos);
}

bool UIElement::remove_cursor(bool, Point<std::int16_t>)
{
    for (auto& [_, button] : buttons) {
        switch (button->get_state()) {
        case Button::MOUSE_OVER:
            button->set_state(Button::NORMAL);
            break;
        default:
            break;
        }
    }
    return false;
}

Cursor::State UIElement::send_cursor(bool down, Point<std::int16_t> cursor_pos)
{
    Cursor::State ret = down ? Cursor::CLICKING : Cursor::IDLE;

    for (auto& [button_id, button] : buttons) {
        if (button->is_active()
            && button->bounds(position).contains(cursor_pos)) {
            if (button->get_state() == Button::NORMAL) {
                Sound{Sound::BUTTON_OVER}.play();

                button->set_state(Button::MOUSE_OVER);
                ret = Cursor::CAN_CLICK;
            } else if (button->get_state() == Button::MOUSE_OVER) {
                if (down) {
                    Sound{Sound::BUTTON_CLICK}.play();

                    button->set_state(button_pressed(button_id));

                    ret = Cursor::IDLE;
                } else {
                    ret = Cursor::CAN_CLICK;
                }
            }
        } else if (button->get_state() == Button::MOUSE_OVER) {
            button->set_state(Button::NORMAL);
        }
    }

    return ret;
}
} // namespace jrc

```

`IO/UIElement.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Graphics/Sprite.h"
#include "Components/Button.h"
#include "Components/Icon.h"
#include "Cursor.h"

#include <memory>
#include <unordered_map>
#include <vector>

namespace jrc
{
//! Base class for all types of user interfaces on screen.
class UIElement
{
public:
    using UPtr = std::unique_ptr<UIElement>;

    enum Type {
        NONE,
        LOGIN,
        LOGIN_WAIT,
        WORLD_SELECT,
        CHAR_SELECT,
        CHAR_CREATION,
        SOFT_KEYBOARD,
        STATUS_MESSENGER,
        STATUS_BAR,
        BUFF_LIST,
        NOTICE,
        NPC_TALK,
        SHOP,
        STATS_INFO,
        ITEM_INVENTORY,
        EQUIP_INVENTORY,
        SKILLBOOK,
        KEY_CONFIG,
        SYSTEM_MENU,
        CHANGE_CHANNEL,
        GAME_SETTINGS,
        SYSTEM_SETTINGS,
        LOGIN_NOTICE,

        NUM_TYPES
    };

    virtual ~UIElement() = default;

    virtual void draw(float inter) const;
    virtual void update();

    void make_active() noexcept;
    void deactivate() noexcept;
    bool is_active() const noexcept;

    virtual void toggle_active();
    virtual Button::State button_pressed(std::uint16_t button_id);
    virtual void send_icon(const Icon& icon, Point<std::int16_t> cursor_pos);

    virtual void double_click(Point<std::int16_t> cursor_pos);
    virtual bool is_in_range(Point<std::int16_t> cursor_pos) const;
    virtual bool remove_cursor(bool clicked, Point<std::int16_t> cursor_pos);
    virtual Cursor::State send_cursor(bool clicked,
                                      Point<std::int16_t> cursor_pos);

protected:
    UIElement(Point<std::int16_t> position,
              Point<std::int16_t> dimension,
              bool active);
    UIElement(Point<std::int16_t> position, Point<std::int16_t> dimension);
    UIElement();

    void draw_sprites(float alpha) const;
    void draw_buttons(float alpha) const;

    std::unordered_map<std::uint16_t, std::unique_ptr<Button>> buttons;
    std::vector<Sprite> sprites;
    Point<std::int16_t> position;
    Point<std::int16_t> dimension;
    bool active;
};
} // namespace jrc

```

`IO/UIState.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"
#include "Components/Icon.h"
#include "Components/Tooltip.h"
#include "Keyboard.h"
#include "UIElement.h"

#include <memory>

namespace jrc
{
class UIState
{
public:
    using Iterator = EnumMap<UIElement::Type,
                             std::unique_ptr<UIElement>,
                             UIElement::NUM_TYPES>::iterator;

    virtual ~UIState() = default;

    virtual void draw(float inter, Point<std::int16_t> cursor) const = 0;
    virtual void update() = 0;

    virtual void double_click(Point<std::int16_t> pos) = 0;
    virtual void send_key(KeyType::Id type, std::int32_t action, bool pressed)
        = 0;
    virtual Cursor::State send_cursor(Cursor::State mst,
                                      Point<std::int16_t> pos)
        = 0;

    virtual void drag_icon(Icon* icon) = 0;
    virtual void clear_tooltip(Tooltip::Parent parent) = 0;
    virtual void show_equip(Tooltip::Parent parent, std::int16_t slot) = 0;
    virtual void show_item(Tooltip::Parent parent, std::int32_t itemid) = 0;
    virtual void show_skill(Tooltip::Parent parent,
                            std::int32_t skill_id,
                            std::int32_t level,
                            std::int32_t masterlevel,
                            std::int64_t expiration)
        = 0;

    virtual Iterator pre_add(UIElement::Type type, bool toggled, bool focused)
        = 0;
    virtual void remove(UIElement::Type type) = 0;
    virtual UIElement* get(UIElement::Type type) = 0;
    virtual UIElement* get_front(Point<std::int16_t> pos) = 0;
};

class UIStateNull : public UIState
{
    void draw(float, Point<std::int16_t>) const override
    {
    }
    void update() override
    {
    }
    void double_click(Point<std::int16_t>) override
    {
    }
    void send_key(KeyType::Id, std::int32_t, bool) override
    {
    }
    Cursor::State send_cursor(Cursor::State, Point<std::int16_t>) override
    {
        return Cursor::IDLE;
    }
    void drag_icon(Icon*) override
    {
    }
    void clear_tooltip(Tooltip::Parent) override
    {
    }
    void show_equip(Tooltip::Parent, std::int16_t) override
    {
    }
    void show_item(Tooltip::Parent, std::int32_t) override
    {
    }
    void show_skill(Tooltip::Parent,
                    std::int32_t,
                    std::int32_t,
                    std::int32_t,
                    std::int64_t) override
    {
    }
    Iterator pre_add(UIElement::Type, bool, bool) override
    {
        return {nullptr, UIElement::NUM_TYPES};
    }
    void remove(UIElement::Type) override
    {
    }
    UIElement* get(UIElement::Type) override
    {
        return nullptr;
    }
    UIElement* get_front(Point<std::int16_t>) override
    {
        return nullptr;
    }
};
} // namespace jrc

```

`IO/UIStateGame.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIStateGame.h"

#include "../Gameplay/Stage.h"
#include "UI.h"
#include "UITypes/UIBuffList.h"
#include "UITypes/UIEquipInventory.h"
#include "UITypes/UIItemInventory.h"
#include "UITypes/UIKeyConfig.h"
#include "UITypes/UINpcTalk.h"
#include "UITypes/UIShop.h"
#include "UITypes/UISkillBook.h"
#include "UITypes/UIStatsInfo.h"
#include "UITypes/UIStatusBar.h"
#include "UITypes/UIStatusMessenger.h"
#include "UITypes/UISystemMenu.h"
#include "Window.h"

#include <cmath>

namespace jrc
{
UIStateGame::UIStateGame()
    : focused(UIElement::NONE), tooltip_parent(Tooltip::NONE)
{
    const CharLook& look = Stage::get().get_player().get_look();
    const CharStats& stats = Stage::get().get_player().get_stats();
    const Inventory& inventory = Stage::get().get_player().get_inventory();

    emplace<UIStatusMessenger>();
    emplace<UIStatusbar>(stats);
    emplace<UIBuffList>();
    emplace<UINpcTalk>();
    emplace<UIShop>(look, inventory);
}

void UIStateGame::draw(float inter, Point<std::int16_t> cursor) const
{
    for (const auto& type : element_order) {
        auto& element = elements[type];
        if (element && element->is_active()) {
            element->draw(inter);
        }
    }

    if (tooltip) {
        tooltip->draw(cursor);
    }

    if (dragged_icon) {
        dragged_icon->dragdraw(cursor);
    }
}

void UIStateGame::update()
{
    for (const auto& type : element_order) {
        auto& element = elements[type];
        if (element && element->is_active()) {
            element->update();
        }
    }
}

void UIStateGame::drop_icon(const Icon& icon, Point<std::int16_t> pos)
{
    if (UIElement* front = get_front(pos)) {
        front->send_icon(icon, pos);
    } else {
        icon.drop_on_stage();
    }
}

void UIStateGame::double_click(Point<std::int16_t> pos)
{
    if (UIElement* front = get_front(pos)) {
        front->double_click(pos);
    }
}

void UIStateGame::send_key(KeyType::Id type, std::int32_t action, bool pressed)
{
    switch (type) {
    case KeyType::MENU:
        if (pressed) {
            switch (action) {
            case KeyAction::CHAR_STATS:
                emplace<UIStatsinfo>(Stage::get().get_player().get_stats());
                break;
            case KeyAction::INVENTORY:
                emplace<UIItemInventory>(
                    Stage::get().get_player().get_inventory());
                break;
            case KeyAction::EQUIPMENT_TAB:
                emplace<UIEquipInventory>(
                    Stage::get().get_player().get_inventory());
                break;
            case KeyAction::SKILL_TAB:
                emplace<UISkillbook>(Stage::get().get_player().get_stats(),
                                     Stage::get().get_player().get_skills());
                break;
            case KeyAction::KEY_CONFIG:
                emplace<UIKeyConfig>();
                break;
            case KeyAction::MAIN_MENU:
                emplace<UISystemMenu>();
                break;
            default:
                break;
            }
        }
        break;
    case KeyType::ACTION:
    case KeyType::FACE:
    case KeyType::ITEM:
        Stage::get().send_key(type, action, pressed);
        break;
    case KeyType::SKILL:
        Stage::get().send_key(type, -action, pressed);
        break;
    default:
        break;
    }
}

Cursor::State UIStateGame::send_cursor(Cursor::State mst,
                                       Point<std::int16_t> pos)
{
    if (dragged_icon) {
        switch (mst) {
        case Cursor::IDLE:
            drop_icon(*dragged_icon, pos);
            dragged_icon->reset();
            dragged_icon = {};
            return mst;
        default:
            return Cursor::GRABBING;
        }
    } else {
        bool clicked = mst == Cursor::CLICKING;
        if (UIElement* focused_element = get(focused); focused_element) {
            if (focused_element->is_active()) {
                return focused_element->send_cursor(clicked, pos);
            } else {
                focused = UIElement::NONE;
                return mst;
            }
        } else {
            UIElement* front = nullptr;
            UIElement::Type front_type = UIElement::NONE;

            for (const auto& type : element_order) {
                auto& element = elements[type];
                if (element && element->is_active()) {
                    bool found = element->is_in_range(pos)
                                     ? true
                                     : element->remove_cursor(clicked, pos);
                    if (found) {
                        if (front) {
                            front->remove_cursor(false, pos);
                        }

                        front = element.get();
                        front_type = type;
                    }
                }
            }

            if (Tooltip::same_ui_type(tooltip_parent, front_type)) {
                clear_tooltip(tooltip_parent);
            }

            if (front) {
                if (clicked) {
                    element_order.erase(
                        std::remove_if(
                            element_order.begin(),
                            element_order.end(),
                            [front_type](auto t) { return t == front_type; }),
                        element_order.end());

                    element_order.push_back(front_type);
                }

                return front->send_cursor(clicked, pos);
            } else {
                return Stage::get().send_cursor(clicked, pos);
            }
        }
    }
}

void UIStateGame::drag_icon(Icon* drg_ic)
{
    dragged_icon = drg_ic;
}

void UIStateGame::clear_tooltip(Tooltip::Parent parent)
{
    if (parent == tooltip_parent) {
        eq_tooltip.set_equip(Tooltip::NONE, 0);
        it_tooltip.set_item(0);
        tooltip = {};
        tooltip_parent = Tooltip::NONE;
    }
}

void UIStateGame::show_equip(Tooltip::Parent parent, std::int16_t slot)
{
    eq_tooltip.set_equip(parent, slot);

    if (slot) {
        tooltip = eq_tooltip;
        tooltip_parent = parent;
    }
}

void UIStateGame::show_item(Tooltip::Parent parent, std::int32_t item_id)
{
    it_tooltip.set_item(item_id);

    if (item_id) {
        tooltip = it_tooltip;
        tooltip_parent = parent;
    }
}

void UIStateGame::show_skill(Tooltip::Parent parent,
                             std::int32_t skill_id,
                             std::int32_t level,
                             std::int32_t master_level,
                             std::int64_t expiration)
{
    skill_tooltip.set_skill(skill_id, level, master_level, expiration);

    if (skill_id) {
        tooltip = skill_tooltip;
        tooltip_parent = parent;
    }
}

template<class T, typename... Args>
void UIStateGame::emplace(Args&&... args)
{
    if (auto iter = pre_add(T::TYPE, T::TOGGLED, T::FOCUSED)) {
        (*iter).second = std::make_unique<T>(std::forward<Args>(args)...);
    }
}

UIState::Iterator
UIStateGame::pre_add(UIElement::Type type, bool is_toggled, bool is_focused)
{
    auto& element = elements[type];
    if (element && is_toggled) {
        element_order.erase(
            std::remove_if(element_order.begin(),
                           element_order.end(),
                           [type](auto t) { return t == type; }),
            element_order.end());
        element_order.push_back(type);
        element->toggle_active();
        return elements.end();
    } else {
        remove(type);
        element_order.push_back(type);

        if (is_focused) {
            focused = type;
        }

        return elements.find(type);
    }
}

void UIStateGame::remove(UIElement::Type type)
{
    if (type == focused) {
        focused = UIElement::NONE;
    }

    if (Tooltip::same_ui_type(tooltip_parent, type)) {
        clear_tooltip(tooltip_parent);
    }

    element_order.erase(std::remove_if(element_order.begin(),
                                       element_order.end(),
                                       [type](auto t) { return t == type; }),
                        element_order.end());

    if (auto& element = elements[type]) {
        element->deactivate();
        element.release();
    }
}

UIElement* UIStateGame::get(UIElement::Type type)
{
    return elements[type].get();
}

UIElement* UIStateGame::get_front(Point<std::int16_t> pos)
{
    auto begin = element_order.rbegin();
    auto end = element_order.rend();
    for (auto iter = begin; iter != end; ++iter) {
        const auto& element = elements[*iter];
        if (element && element->is_active() && element->is_in_range(pos)) {
            return element.get();
        }
    }

    return nullptr;
}
} // namespace jrc

```

`IO/UIStateGame.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"
#include "../Template/nullable_ptr.h"
#include "Components/EquipTooltip.h"
#include "Components/ItemTooltip.h"
#include "Components/SkillTooltip.h"
#include "UIState.h"

#include <memory>
#include <vector>

namespace jrc
{
class UIStateGame : public UIState
{
public:
    UIStateGame();

    void draw(float inter, Point<std::int16_t> cursor) const override;
    void update() override;

    void double_click(Point<std::int16_t> pos) override;
    void
    send_key(KeyType::Id type, std::int32_t action, bool pressed) override;
    Cursor::State send_cursor(Cursor::State mst,
                              Point<std::int16_t> pos) override;

    void drag_icon(Icon* drg_ic) override;
    void clear_tooltip(Tooltip::Parent parent) override;
    void show_equip(Tooltip::Parent parent, std::int16_t slot) override;
    void show_item(Tooltip::Parent parent, std::int32_t item_id) override;
    void show_skill(Tooltip::Parent parent,
                    std::int32_t skill_id,
                    std::int32_t level,
                    std::int32_t master_level,
                    std::int64_t expiration) override;

    Iterator
    pre_add(UIElement::Type type, bool toggled, bool focused) override;
    void remove(UIElement::Type type) override;
    UIElement* get(UIElement::Type type) override;
    UIElement* get_front(Point<std::int16_t> pos) override;

private:
    void drop_icon(const Icon& icon, Point<std::int16_t> pos);
    template<class T, typename... Args>
    void emplace(Args&&... args);

    EnumMap<UIElement::Type, UIElement::UPtr, UIElement::NUM_TYPES> elements;
    std::vector<UIElement::Type> element_order;
    UIElement::Type focused;

    EquipTooltip eq_tooltip;
    ItemTooltip it_tooltip;
    SkillTooltip skill_tooltip;
    nullable_ptr<Tooltip> tooltip;
    Tooltip::Parent tooltip_parent;

    nullable_ptr<Icon> dragged_icon;
};
} // namespace jrc

```

`IO/UIStateLogin.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIStateLogin.h"

#include "UITypes/UILogin.h"

namespace jrc
{
UIStateLogin::UIStateLogin()
{
    focused = UIElement::NONE;

    emplace<UILogin>();
}

void UIStateLogin::draw(float inter, Point<std::int16_t>) const
{
    for (auto iter : elements) {
        UIElement* element = iter.second.get();
        if (element && element->is_active()) {
            element->draw(inter);
        }
    }
}

void UIStateLogin::update()
{
    for (auto iter : elements) {
        UIElement* element = iter.second.get();
        if (element && element->is_active()) {
            element->update();
        }
    }
}

void UIStateLogin::double_click(Point<std::int16_t>)
{
}

void UIStateLogin::send_key(KeyType::Id, std::int32_t, bool)
{
}

Cursor::State UIStateLogin::send_cursor(Cursor::State mst,
                                        Point<std::int16_t> pos)
{
    if (UIElement* focused_element = get(focused); focused_element) {
        if (focused_element->is_active()) {
            return focused_element->send_cursor(mst == Cursor::CLICKING, pos);
        } else {
            focused = UIElement::NONE;
            return mst;
        }
    } else {
        UIElement* front = nullptr;
        UIElement::Type fronttype = UIElement::NONE;

        for (auto iter : elements) {
            auto& element = iter.second;
            if (element && element->is_active()) {
                if (element->is_in_range(pos)) {
                    if (front) {
                        element->remove_cursor(false, pos);
                    }

                    front = element.get();
                    fronttype = iter.first;
                } else {
                    element->remove_cursor(false, pos);
                }
            }
        }

        if (front) {
            return front->send_cursor(mst == Cursor::CLICKING, pos);
        } else {
            return Cursor::IDLE;
        }
    }
}

void UIStateLogin::drag_icon(Icon*)
{
}

void UIStateLogin::clear_tooltip(Tooltip::Parent)
{
}

void UIStateLogin::show_equip(Tooltip::Parent, std::int16_t)
{
}

void UIStateLogin::show_item(Tooltip::Parent, std::int32_t)
{
}

void UIStateLogin::show_skill(
    Tooltip::Parent, std::int32_t, std::int32_t, std::int32_t, std::int64_t)
{
}

template<class T, typename... Args>
void UIStateLogin::emplace(Args&&... args)
{
    if (auto iter = pre_add(T::TYPE, T::TOGGLED, T::FOCUSED); iter) {
        (*iter).second = std::make_unique<T>(std::forward<Args>(args)...);
    }
}

UIState::Iterator
UIStateLogin::pre_add(UIElement::Type type, bool, bool is_focused)
{
    remove(type);

    if (is_focused) {
        focused = type;
    }

    return elements.find(type);
}

void UIStateLogin::remove(UIElement::Type type)
{
    if (focused == type) {
        focused = UIElement::NONE;
    }

    if (auto& element = elements[type]) {
        element->deactivate();
        element.release();
    }
}

UIElement* UIStateLogin::get(UIElement::Type type)
{
    return elements[type].get();
}

UIElement* UIStateLogin::get_front(Point<std::int16_t> pos)
{
    auto begin = elements.values().rbegin();
    auto end = elements.values().rend();
    for (auto iter = begin; iter != end; ++iter) {
        auto& element = *iter;
        if (element && element->is_active() && element->is_in_range(pos)) {
            return element.get();
        }
    }
    return nullptr;
}
} // namespace jrc

```

`IO/UIStateLogin.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/EnumMap.h"
#include "UIState.h"

#include <memory>

namespace jrc
{
class UIStateLogin : public UIState
{
public:
    UIStateLogin();

    void draw(float inter, Point<std::int16_t> cursor) const override;
    void update() override;

    void double_click(Point<std::int16_t> pos) override;
    void
    send_key(KeyType::Id type, std::int32_t action, bool pressed) override;
    Cursor::State send_cursor(Cursor::State mst,
                              Point<std::int16_t> pos) override;

    void drag_icon(Icon* icon) override;
    void clear_tooltip(Tooltip::Parent parent) override;
    void show_equip(Tooltip::Parent parent, std::int16_t slot) override;
    void show_item(Tooltip::Parent parent, std::int32_t itemid) override;
    void show_skill(Tooltip::Parent parent,
                    std::int32_t skill_id,
                    std::int32_t level,
                    std::int32_t masterlevel,
                    std::int64_t expiration) override;

    Iterator
    pre_add(UIElement::Type type, bool toggled, bool focused) override;
    void remove(UIElement::Type type) override;
    UIElement* get(UIElement::Type type) override;
    UIElement* get_front(Point<std::int16_t> pos) override;

private:
    template<class T, typename... Args>
    void emplace(Args&&... args);

    EnumMap<UIElement::Type, UIElement::UPtr, UIElement::NUM_TYPES> elements;
    UIElement::Type focused;
};
} // namespace jrc

```

`IO/UITypes/UIBuffList.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIBuffList.h"

#include "../../Data/ItemData.h"
#include "../../Util/Misc.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <cstring>

namespace jrc
{
BuffIcon::BuffIcon(std::int32_t buff, std::int32_t dur)
    : cover{IconCover::BUFF, dur - FLASH_TIME}
{
    buffid = buff;
    duration = dur;
    opacity.set(1.0f);
    opcstep = -0.05f;

    if (buffid >= 0) {
        std::string str_id = string_format::extend_id(buffid, 7);
        char str_id_buf[7];
        std::memcpy(str_id_buf, str_id.data(), 3);
        std::memcpy(str_id_buf + 3, ".img", 4);
        nl::node src
            = nl::nx::skill[std::string_view{str_id_buf, 7}]["skill"][str_id];
        icon = src["icon"];
    } else {
        icon = ItemData::get(-buffid).get_icon(true);
    }
}

void BuffIcon::draw(Point<std::int16_t> position, float alpha) const
{
    icon.draw({position, opacity.get(alpha)});
    cover.draw(position + Point<std::int16_t>(1, -31), alpha);
}

bool BuffIcon::update()
{
    if (duration <= FLASH_TIME) {
        opacity += opcstep;

        bool fadedout = opcstep < 0.0f && opacity.last() <= 0.0f;
        bool fadedin = opcstep > 0.0f && opacity.last() >= 1.0f;
        if (fadedout || fadedin) {
            opcstep = -opcstep;
        }
    }

    cover.update();

    duration -= Constants::TIMESTEP;
    return duration < Constants::TIMESTEP;
}

UIBuffList::UIBuffList()
{
    position = {750, 40};
    active = true;
}

void UIBuffList::draw(float alpha) const
{
    Point<std::int16_t> ic_pos = position;
    for (auto& [_, icon] : icons) {
        icon.draw(ic_pos, alpha);
        ic_pos.shift_x(-32);
    }
}

void UIBuffList::update()
{
    for (auto iter = icons.begin(); iter != icons.end();) {
        bool expired = iter->second.update();
        if (expired) {
            iter = icons.erase(iter);
        } else {
            ++iter;
        }
    }
}

Cursor::State UIBuffList::send_cursor(bool pressed,
                                      Point<std::int16_t> cursor_position)
{
    return UIElement::send_cursor(pressed, cursor_position);
}

void UIBuffList::add_buff(std::int32_t buff_id, std::int32_t duration)
{
    icons.emplace(std::piecewise_construct,
                  std::forward_as_tuple(buff_id),
                  std::forward_as_tuple(buff_id, duration));
}
} // namespace jrc

```

`IO/UITypes/UIBuffList.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Constants.h"
#include "../../Graphics/Texture.h"
#include "../Components/IconCover.h"
#include "../UIElement.h"

#include <unordered_map>

namespace jrc
{
class BuffIcon
{
public:
    BuffIcon(std::int32_t buff, std::int32_t dur);

    void draw(Point<std::int16_t> position, float alpha) const;
    bool update();

private:
    static const std::uint16_t FLASH_TIME = 3'000;

    Texture icon;
    IconCover cover;
    std::int32_t buffid;
    std::int32_t duration;
    Linear<float> opacity;
    float opcstep;
};

class UIBuffList : public UIElement
{
public:
    static constexpr Type TYPE = BUFF_LIST;
    static constexpr bool FOCUSED = false;
    static constexpr bool TOGGLED = false;

    UIBuffList();

    void draw(float inter) const override;
    void update() override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursor_position) override;

    void add_buff(std::int32_t buff_id, std::int32_t duration);

private:
    std::unordered_map<std::int32_t, BuffIcon> icons;
};
} // namespace jrc

```

`IO/UITypes/UIChangeChannel.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIChangeChannel.h"

#include "../../Gameplay/Stage.h"
#include "../../Net/Packets/GameplayPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIChangeChannel::UIChangeChannel()
    : UIDragElement<Configuration::PositionOf::CHANGE_CHANNEL>{DRAG_AREA},
      selected_channel{Stage::get().get_channel()}
{
    nl::node source = nl::nx::ui["UIWindow2.img"]["Channel"];

    sprites.emplace_back(source["backgrnd"]);
    sprites.emplace_back(source["backgrnd2"]);
    sprites.emplace_back(source["backgrnd3"]);
    sprites.emplace_back(source["world"][Stage::get().get_world()],
                         DrawArgument{WORLD_BADGE_OFFSET});

    nl::node ch_src = source["ch"];
    const std::uint8_t num_channels = Stage::get().get_channel_count();
    auto ch_pos = CH_SPRITE_OFFSET;
    for (unsigned row = 0; row < ROWS; ++row) {
        bool finished_ch_sprites = false;
        for (unsigned col = 0; col < COLS; ++col) {
            unsigned n = row * COLS + col;
            ch_sprites.emplace_back(ch_src[n], DrawArgument{ch_pos});
            ch_pos += {STRIDE_HORIZ, 0};

            if (n == num_channels - 1) {
                finished_ch_sprites = true;
                break;
            }
        }
        if (finished_ch_sprites) {
            break;
        }

        ch_pos.set_x(CH_SPRITE_OFFSET.x());
        ch_pos += {0, STRIDE_VERT};
    }

    buttons[BT_CANCEL] = std::make_unique<MapleButton>(source["BtCancel"]);
    buttons[BT_CHANGE] = std::make_unique<MapleButton>(source["BtChange"]);

    channel_cover[false] = source["channel0"];
    channel_cover[true] = source["channel1"];

    dimension = {WIDTH, HEIGHT};
    active = true;
}

void UIChangeChannel::draw(float alpha) const
{
    UIElement::draw(alpha);

    const auto base_pos = COVER_TEXTURE_OFFSET + position;
    std::uint8_t curr_ch = Stage::get().get_channel();
    auto curr_pos = base_pos
                    + Point<std::int16_t>{curr_ch % COLS * STRIDE_HORIZ,
                                          curr_ch / COLS * STRIDE_VERT};

    channel_cover[false].draw({curr_pos});
    if (curr_ch != selected_channel) {
        auto selected_pos
            = base_pos
              + Point<std::int16_t>{selected_channel % COLS * STRIDE_HORIZ,
                                    selected_channel / COLS * STRIDE_VERT};

        channel_cover[true].draw({selected_pos});
    }

    for (const auto& ch_sprite : ch_sprites) {
        ch_sprite.draw(position, alpha);
    }
}

void UIChangeChannel::toggle_active()
{
    UIElement::toggle_active();
}

Cursor::State UIChangeChannel::send_cursor(bool pressed,
                                           Point<std::int16_t> cursor_pos)
{
    Cursor::State drag_state = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        return drag_state;
    }

    if (pressed) {
        if (auto clicked_ch = channel_by_pos(cursor_pos);
            clicked_ch && *clicked_ch < ch_sprites.size()) {
            selected_channel = *clicked_ch;
        }
    }

    return Cursor::IDLE;
}

void UIChangeChannel::double_click(Point<std::int16_t> cursor_pos)
{
    UIDragElement::double_click(cursor_pos);

    if (auto clicked_ch = channel_by_pos(cursor_pos);
        clicked_ch && *clicked_ch < ch_sprites.size()) {
        selected_channel = *clicked_ch;
        change_channel();
    }
}

void UIChangeChannel::send_key(SentKey key) noexcept
{
    switch (key) {
    case SentKey::UP:
        if (selected_channel < COLS) {
            selected_channel += COLS * ROWS;
        }
        do {
            selected_channel -= COLS;
        } while (selected_channel >= ch_sprites.size());
        break;
    case SentKey::DOWN:
        selected_channel += COLS;
        if (selected_channel >= ch_sprites.size()) {
            selected_channel %= COLS;
        }
        break;
    case SentKey::LEFT:
        if (selected_channel % COLS == 0) {
            selected_channel += COLS - 1;
            while (selected_channel >= ch_sprites.size()) {
                --selected_channel;
            }
        } else {
            --selected_channel;
        }
        break;
    case SentKey::RIGHT:
        if (selected_channel % COLS == COLS - 1) {
            selected_channel -= COLS - 1;
        } else if (selected_channel == ch_sprites.size() - 1) {
            selected_channel -= selected_channel % COLS;
        } else {
            ++selected_channel;
        }
        break;
    case SentKey::ENTER:
        change_channel();
        break;
    default:
        break;
    }
}

Button::State UIChangeChannel::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case BT_CANCEL:
        active = false;
        return Button::NORMAL;
    case BT_CHANGE:
        change_channel();
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

std::optional<std::uint8_t>
UIChangeChannel::channel_by_pos(Point<std::int16_t> cursor_pos) const noexcept
{
    auto p = cursor_pos - position;
    if (!COVER_AREA.contains(p)) {
        return {};
    }

    p -= COVER_TEXTURE_OFFSET;
    std::int16_t col = p.x() / STRIDE_HORIZ;
    std::int16_t row = p.y() / STRIDE_VERT;

    return {row * COLS + col};
}

void UIChangeChannel::change_channel() noexcept
{
    active = false;

    if (selected_channel != Stage::get().get_channel()) {
        UI::get().disable();
        ChangeChannelPacket{selected_channel}.dispatch();
    }
}
} // namespace jrc

```

`IO/UITypes/UIChangeChannel.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../../Template/BoolPair.h"
#include "../UIDragElement.h"
#include "boost/container/static_vector.hpp"

#include <optional>

namespace jrc
{
//! UI popup for changing channels.
class UIChangeChannel
    : public UIDragElement<Configuration::PositionOf::CHANGE_CHANNEL>
{
public:
    static constexpr const Type TYPE = CHANGE_CHANNEL;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UIChangeChannel();

    void draw(float inter) const override;
    void toggle_active() override;

    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursor_pos) override;
    void double_click(Point<std::int16_t> cursor_pos) override;

    enum class SentKey { NONE, UP, DOWN, LEFT, RIGHT, ENTER };

    void send_key(SentKey key) noexcept;

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    std::optional<std::uint8_t>
    channel_by_pos(Point<std::int16_t> cursor_pos) const noexcept;

    void change_channel() noexcept;

    enum Buttons : std::uint16_t { BT_CANCEL, BT_CHANGE };

    static constexpr const std::int16_t WIDTH = 370;
    static constexpr const std::uint8_t COLS = 5;
    static constexpr const std::int16_t STRIDE_HORIZ = 70;

    static constexpr const std::int16_t HEIGHT = 168;
    static constexpr const std::uint8_t ROWS = 4;
    static constexpr const std::int16_t STRIDE_VERT = 20;
    static constexpr const std::int16_t DRAG_HEIGHT = 20;

    static constexpr const Point<std::int16_t> DRAG_AREA{WIDTH, DRAG_HEIGHT};
    static constexpr const Point<std::int16_t> CH_SPRITE_OFFSET{21, 61};
    static constexpr const Point<std::int16_t> COVER_TEXTURE_OFFSET{12, 56};
    static constexpr const Point<std::int16_t> WORLD_BADGE_OFFSET{16, 30};

    static constexpr const Rectangle<std::int16_t> COVER_AREA{
        COVER_TEXTURE_OFFSET,
        COVER_TEXTURE_OFFSET
            + Point<std::int16_t>{COLS * STRIDE_HORIZ, ROWS* STRIDE_VERT}};

    boost::container::static_vector<Sprite, COLS * ROWS> ch_sprites;
    BoolPair<Texture> channel_cover;
    std::uint8_t selected_channel;
};
} // namespace jrc

```

`IO/UITypes/UICharCreation.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UICharCreation.h"

#include "../../Constants.h"
#include "../../Data/ItemData.h"
#include "../../Net/Packets/CharCreationPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "../UITypes/UICharSelect.h"
#include "../UITypes/UILoginNotice.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UICharCreation::UICharCreation()
{
    nl::node src = nl::nx::ui["Login.img"];
    nl::node bg_src = nl::nx::map["Back"]["login.img"]["back"];
    nl::node cr_src = src["NewChar"];

    sky = bg_src["2"];
    cloud = bg_src["27"];

    sprites.emplace_back(bg_src["15"], Point<std::int16_t>{153, 685});
    sprites.emplace_back(bg_src["16"], Point<std::int16_t>{200, 400});
    sprites.emplace_back(bg_src["17"], Point<std::int16_t>{160, 263});
    sprites.emplace_back(bg_src["18"], Point<std::int16_t>{349, 1220});
    sprites.emplace_back(src["Common"]["frame"],
                         Point<std::int16_t>{400, 290});

    name_board = cr_src["charName"];

    sprites_look_board.emplace_back(cr_src["charSet"],
                                    Point<std::int16_t>{450, 115});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["0"]["normal"],
                                    Point<std::int16_t>{461, 217});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["1"]["normal"],
                                    Point<std::int16_t>{461, 236});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["2"]["normal"],
                                    Point<std::int16_t>{461, 255});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["3"]["normal"],
                                    Point<std::int16_t>{461, 274});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["4"]["normal"],
                                    Point<std::int16_t>{461, 293});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["5"]["normal"],
                                    Point<std::int16_t>{461, 312});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["6"]["normal"],
                                    Point<std::int16_t>{461, 331});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["7"]["normal"],
                                    Point<std::int16_t>{461, 350});
    sprites_look_board.emplace_back(cr_src["avatarSel"]["8"]["normal"],
                                    Point<std::int16_t>{461, 369});

    buttons[BT_CHARC_OK] = std::make_unique<MapleButton>(
        cr_src["BtYes"], Point<std::int16_t>{482, 292});
    buttons[BT_CHARC_CANCEL] = std::make_unique<MapleButton>(
        cr_src["BtNo"], Point<std::int16_t>{555, 292});
    buttons[BT_CHARC_FACEL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 216});
    buttons[BT_CHARC_FACER] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 216});
    buttons[BT_CHARC_HAIRL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 235});
    buttons[BT_CHARC_HAIRR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 235});
    buttons[BT_CHARC_HAIRCL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 254});
    buttons[BT_CHARC_HAIRCR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 254});
    buttons[BT_CHARC_SKINL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 273});
    buttons[BT_CHARC_SKINR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 273});
    buttons[BT_CHARC_TOPL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 292});
    buttons[BT_CHARC_TOPR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 292});
    buttons[BT_CHARC_BOTL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 311});
    buttons[BT_CHARC_BOTR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 311});
    buttons[BT_CHARC_SHOESL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 330});
    buttons[BT_CHARC_SHOESR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 330});
    buttons[BT_CHARC_WEPL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 349});
    buttons[BT_CHARC_WEPR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 348});
    buttons[BT_CHARC_GENDERL] = std::make_unique<MapleButton>(
        cr_src["BtLeft"], Point<std::int16_t>{521, 368});
    buttons[BT_CHARC_GENDERR] = std::make_unique<MapleButton>(
        cr_src["BtRight"], Point<std::int16_t>{645, 368});

    buttons[BT_CHARC_FACEL]->set_active(false);
    buttons[BT_CHARC_FACER]->set_active(false);
    buttons[BT_CHARC_HAIRL]->set_active(false);
    buttons[BT_CHARC_HAIRR]->set_active(false);
    buttons[BT_CHARC_HAIRCL]->set_active(false);
    buttons[BT_CHARC_HAIRCR]->set_active(false);
    buttons[BT_CHARC_SKINL]->set_active(false);
    buttons[BT_CHARC_SKINR]->set_active(false);
    buttons[BT_CHARC_TOPL]->set_active(false);
    buttons[BT_CHARC_TOPR]->set_active(false);
    buttons[BT_CHARC_BOTL]->set_active(false);
    buttons[BT_CHARC_BOTR]->set_active(false);
    buttons[BT_CHARC_SHOESL]->set_active(false);
    buttons[BT_CHARC_SHOESR]->set_active(false);
    buttons[BT_CHARC_WEPL]->set_active(false);
    buttons[BT_CHARC_WEPR]->set_active(false);
    buttons[BT_CHARC_GENDERL]->set_active(false);
    buttons[BT_CHARC_GENDERR]->set_active(false);

    name_char
        = {Text::A13M, Text::LEFT, Text::WHITE, {{490, 219}, {630, 243}}, 12};
    name_char.set_state(Textfield::FOCUSED);

    face_name = {Text::A11M, Text::CENTER, Text::BLACK};
    hair_name = {Text::A11M, Text::CENTER, Text::BLACK};
    hair_cname = {Text::A11M, Text::CENTER, Text::BLACK};
    body_name = {Text::A11M, Text::CENTER, Text::BLACK};
    top_name = {Text::A11M, Text::CENTER, Text::BLACK};
    bottom_name = {Text::A11M, Text::CENTER, Text::BLACK};
    shoe_name = {Text::A11M, Text::CENTER, Text::BLACK};
    weapon_name = {Text::A11M, Text::CENTER, Text::BLACK};
    gender_name = {Text::A11M, Text::CENTER, Text::BLACK};

    nl::node mkinfo = nl::nx::etc["MakeCharInfo.img"]["Info"];
    for (auto i = 0; i < 2; ++i) {
        bool f;
        nl::node mk_n;
        if (i == 0) {
            f = true;
            mk_n = mkinfo["CharFemale"];
        } else {
            f = false;
            mk_n = mkinfo["CharMale"];
        }

        for (auto sub_node : mk_n) {
            int num = stoi(sub_node.name());
            for (auto id_node : sub_node) {
                int value = id_node;
                switch (num) {
                case 0:
                    faces[f].push_back(value);
                    break;
                case 1:
                    hairs[f].push_back(value);
                    break;
                case 2:
                    hair_colors[f].push_back(static_cast<std::uint8_t>(value));
                    break;
                case 3:
                    skins[f].push_back(static_cast<std::uint8_t>(value));
                    break;
                case 4:
                    tops[f].push_back(value);
                    break;
                case 5:
                    bots[f].push_back(value);
                    break;
                case 6:
                    shoes[f].push_back(value);
                    break;
                case 7:
                    weapons[f].push_back(value);
                    break;
                }
            }
        }
    }

    named = false;
    female = false;
    randomize_look();

    new_char.set_direction(true);

    position = {0, 0};
    dimension = {Constants::VIEW_WIDTH, Constants::VIEW_HEIGHT};
    active = true;
    cloud_fx = 200;
}

void UICharCreation::randomize_look()
{
    hair = Randomizer::next_int(hairs[female].size());
    face = Randomizer::next_int(faces[female].size());
    skin = Randomizer::next_int(skins[female].size());
    hair_color = Randomizer::next_int(hair_colors[female].size());
    top = Randomizer::next_int(tops[female].size());
    bottom = Randomizer::next_int(bots[female].size());
    shoe = Randomizer::next_int(shoes[female].size());
    weapon = Randomizer::next_int(weapons[female].size());

    new_char.set_body(skins[female][skin]);
    new_char.set_face(faces[female][face]);
    new_char.set_hair(hairs[female][hair] + hair_colors[female][hair_color]);
    new_char.add_equip(tops[female][top]);
    new_char.add_equip(bots[female][bottom]);
    new_char.add_equip(shoes[female][shoe]);
    new_char.add_equip(weapons[female][weapon]);

    body_name.change_text(std::string{new_char.get_body()->get_name()});
    face_name.change_text(std::string{new_char.get_face()->get_name()});
    hair_name.change_text(std::string{new_char.get_hair()->get_name()});
    hair_cname.change_text(std::string{new_char.get_hair()->get_color()});

    top_name.change_text(std::string{get_equip_name(Equipslot::TOP)});
    bottom_name.change_text(std::string{get_equip_name(Equipslot::PANTS)});
    shoe_name.change_text(std::string{get_equip_name(Equipslot::SHOES)});
    weapon_name.change_text(std::string{get_equip_name(Equipslot::WEAPON)});
    gender_name.change_text(female ? "Female" : "Male");
}

Button::State UICharCreation::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_CHARC_OK:
        if (named) {
            std::string cname = name_char.get_text();
            std::uint16_t cjob = 1;
            std::int32_t cface = faces[female][face];
            std::int32_t chair = hairs[female][hair];
            std::uint8_t chairc = hair_colors[female][hair_color];
            std::uint8_t cskin = skins[female][skin];
            std::int32_t ctop = tops[female][top];
            std::int32_t cbot = bots[female][bottom];
            std::int32_t cshoe = shoes[female][shoe];
            std::int32_t cwep = weapons[female][weapon];
            CreateCharPacket{cname,
                             cjob,
                             cface,
                             chair,
                             chairc,
                             cskin,
                             ctop,
                             cbot,
                             cshoe,
                             cwep,
                             female}
                .dispatch();
            return Button::PRESSED;
        } else {
            std::string name = name_char.get_text();
            if (name.size() >= 4) {
                name_char.set_state(Textfield::NORMAL);

                UI::get().disable();
                UI::get().focus_text_field(nullptr);
                NameCharPacket{name}.dispatch();
                return Button::PRESSED;
            } else {
                Console::get().print("empLacing");
                UI::get().emplace<UILoginNotice>(UILoginNotice::ILLEGAL_NAME);
                return Button::NORMAL;
            }
        }
    case BT_CHARC_CANCEL:
        if (named) {
            buttons[BT_CHARC_OK]->set_position({482, 292});
            buttons[BT_CHARC_CANCEL]->set_position({555, 292});
            buttons[BT_CHARC_FACEL]->set_active(false);
            buttons[BT_CHARC_FACER]->set_active(false);
            buttons[BT_CHARC_HAIRL]->set_active(false);
            buttons[BT_CHARC_HAIRR]->set_active(false);
            buttons[BT_CHARC_HAIRCL]->set_active(false);
            buttons[BT_CHARC_HAIRCR]->set_active(false);
            buttons[BT_CHARC_SKINL]->set_active(false);
            buttons[BT_CHARC_SKINR]->set_active(false);
            buttons[BT_CHARC_TOPL]->set_active(false);
            buttons[BT_CHARC_TOPR]->set_active(false);
            buttons[BT_CHARC_BOTL]->set_active(false);
            buttons[BT_CHARC_BOTR]->set_active(false);
            buttons[BT_CHARC_SHOESL]->set_active(false);
            buttons[BT_CHARC_SHOESR]->set_active(false);
            buttons[BT_CHARC_WEPL]->set_active(false);
            buttons[BT_CHARC_WEPR]->set_active(false);
            buttons[BT_CHARC_GENDERL]->set_active(false);
            buttons[BT_CHARC_GENDERR]->set_active(false);
            buttons[BT_CHARC_CANCEL]->set_state(Button::NORMAL);
            name_char.set_state(Textfield::NORMAL);
            named = false;
            return Button::NORMAL;
        } else {
            active = false;
            if (auto char_select = UI::get().get_element<UICharSelect>();
                char_select) {
                char_select->make_active();
            }
            return Button::PRESSED;
        }
    }

    if (id >= BT_CHARC_FACEL && id <= BT_CHARC_GENDERR) {
        switch (id) {
        case BT_CHARC_FACEL:
            face = face > 0 ? face - 1 : faces[female].size() - 1;
            new_char.set_face(faces[female][face]);
            face_name.change_text(
                std::string{new_char.get_face()->get_name()});
            break;
        case BT_CHARC_FACER:
            face = (face < faces[female].size() - 1) ? face + 1 : 0;
            new_char.set_face(faces[female][face]);
            face_name.change_text(
                std::string{new_char.get_face()->get_name()});
            break;
        case BT_CHARC_HAIRL:
            hair = (hair > 0) ? hair - 1 : hairs[female].size() - 1;
            new_char.set_hair(hairs[female][hair]
                              + hair_colors[female][hair_color]);
            hair_name.change_text(
                std::string{new_char.get_hair()->get_name()});
            break;
        case BT_CHARC_HAIRR:
            hair = (hair < hairs[female].size() - 1) ? hair + 1 : 0;
            new_char.set_hair(hairs[female][hair]
                              + hair_colors[female][hair_color]);
            hair_name.change_text(
                std::string{new_char.get_hair()->get_name()});
            break;
        case BT_CHARC_HAIRCL:
            hair_color = (hair_color > 0) ? hair_color - 1
                                          : hair_colors[female].size() - 1;
            new_char.set_hair(hairs[female][hair]
                              + hair_colors[female][hair_color]);
            hair_cname.change_text(
                std::string{new_char.get_hair()->get_color()});
            break;
        case BT_CHARC_HAIRCR:
            hair_color = (hair_color < hair_colors[female].size() - 1)
                             ? hair_color + 1
                             : 0;
            new_char.set_hair(hairs[female][hair]
                              + hair_colors[female][hair_color]);
            hair_cname.change_text(
                std::string{new_char.get_hair()->get_color()});
            break;
        case BT_CHARC_SKINL:
            skin = (skin > 0) ? skin - 1 : skins[female].size() - 1;
            new_char.set_body(skins[female][skin]);
            body_name.change_text(
                std::string{new_char.get_body()->get_name()});
            break;
        case BT_CHARC_SKINR:
            skin = (skin < skins[female].size() - 1) ? skin + 1 : 0;
            new_char.set_body(skins[female][skin]);
            body_name.change_text(
                std::string{new_char.get_body()->get_name()});
            break;
        case BT_CHARC_TOPL:
            top = (top > 0) ? top - 1 : tops[female].size() - 1;
            new_char.add_equip(tops[female][top]);
            top_name.change_text(std::string{get_equip_name(Equipslot::TOP)});
            break;
        case BT_CHARC_TOPR:
            top = (top < tops[female].size() - 1) ? top + 1 : 0;
            new_char.add_equip(tops[female][top]);
            top_name.change_text(std::string{get_equip_name(Equipslot::TOP)});
            break;
        case BT_CHARC_BOTL:
            bottom = (bottom > 0) ? bottom - 1 : bots[female].size() - 1;
            new_char.add_equip(bots[female][bottom]);
            bottom_name.change_text(
                std::string{get_equip_name(Equipslot::PANTS)});
            break;
        case BT_CHARC_BOTR:
            bottom = (bottom < bots[female].size() - 1) ? bottom + 1 : 0;
            new_char.add_equip(bots[female][bottom]);
            bottom_name.change_text(
                std::string{get_equip_name(Equipslot::PANTS)});
            break;
        case BT_CHARC_SHOESL:
            shoe = (shoe > 0) ? shoe - 1 : shoes[female].size() - 1;
            new_char.add_equip(shoes[female][shoe]);
            shoe_name.change_text(
                std::string{get_equip_name(Equipslot::SHOES)});
            break;
        case BT_CHARC_SHOESR:
            shoe = (shoe < shoes[female].size() - 1) ? shoe + 1 : 0;
            new_char.add_equip(shoes[female][shoe]);
            shoe_name.change_text(
                std::string{get_equip_name(Equipslot::SHOES)});
            break;
        case BT_CHARC_WEPL:
            weapon = (weapon > 0) ? weapon - 1 : weapons[female].size() - 1;
            new_char.add_equip(weapons[female][weapon]);
            weapon_name.change_text(
                std::string{get_equip_name(Equipslot::WEAPON)});
            break;
        case BT_CHARC_WEPR:
            weapon = (weapon < weapons[female].size() - 1) ? weapon + 1 : 0;
            new_char.add_equip(weapons[female][weapon]);
            weapon_name.change_text(
                std::string{get_equip_name(Equipslot::WEAPON)});
            break;
        case BT_CHARC_GENDERL:
        case BT_CHARC_GENDERR:
            female = !female;
            randomize_look();
            break;
        }
        return Button::MOUSE_OVER;
    }
    return Button::PRESSED;
}

Cursor::State UICharCreation::send_cursor(bool clicked,
                                          Point<std::int16_t> cursorpos)
{
    if (Cursor::State new_state = name_char.send_cursor(cursorpos, clicked)) {
        return new_state;
    }

    return UIElement::send_cursor(clicked, cursorpos);
}

void UICharCreation::send_naming_result(bool name_used)
{
    if (!named) {
        if (name_used) {
            name_char.change_text("");
        } else {
            named = true;
            buttons[BT_CHARC_OK]->set_position(Point<std::int16_t>{486, 445});
            buttons[BT_CHARC_CANCEL]->set_position(
                Point<std::int16_t>{560, 445});
            buttons[BT_CHARC_FACEL]->set_active(true);
            buttons[BT_CHARC_FACER]->set_active(true);
            buttons[BT_CHARC_HAIRL]->set_active(true);
            buttons[BT_CHARC_HAIRR]->set_active(true);
            buttons[BT_CHARC_HAIRCL]->set_active(true);
            buttons[BT_CHARC_HAIRCR]->set_active(true);
            buttons[BT_CHARC_SKINL]->set_active(true);
            buttons[BT_CHARC_SKINR]->set_active(true);
            buttons[BT_CHARC_TOPL]->set_active(true);
            buttons[BT_CHARC_TOPR]->set_active(true);
            buttons[BT_CHARC_BOTL]->set_active(true);
            buttons[BT_CHARC_BOTR]->set_active(true);
            buttons[BT_CHARC_SHOESL]->set_active(true);
            buttons[BT_CHARC_SHOESR]->set_active(true);
            buttons[BT_CHARC_WEPL]->set_active(true);
            buttons[BT_CHARC_WEPR]->set_active(true);
            buttons[BT_CHARC_GENDERL]->set_active(true);
            buttons[BT_CHARC_GENDERR]->set_active(true);
            name_char.set_state(Textfield::DISABLED);
        }
        buttons[BT_CHARC_OK]->set_state(Button::NORMAL);
    }
}

void UICharCreation::draw(float alpha) const
{
    for (std::int16_t i = 0; i < 2; ++i) {
        for (std::int16_t k = 0; k < Constants::VIEW_WIDTH; k += sky.width()) {
            sky.draw(Point<std::int16_t>{
                k, static_cast<std::int16_t>(400 * i - 100)});
        }
    }

    std::int16_t cloud_x = static_cast<std::int16_t>(
        cloud_fx / 4u % static_cast<std::uint32_t>(Constants::VIEW_WIDTH));
    cloud.draw(Point<std::int16_t>{cloud_x - cloud.width(), 300});
    cloud.draw(Point<std::int16_t>{cloud_x, 300});
    cloud.draw(Point<std::int16_t>{cloud_x + cloud.width(), 300});

    if (!named) {
        name_board.draw(Point<std::int16_t>{455, 115});
        name_char.draw(position);
    } else {
        for (auto& sprite : sprites_look_board) {
            sprite.draw(position, alpha);
        }
    }

    UIElement::draw(alpha);

    new_char.draw({360, 348}, alpha);

    if (named) {
        face_name.draw(Point<std::int16_t>{591, 214});
        hair_name.draw(Point<std::int16_t>{591, 233});
        hair_cname.draw(Point<std::int16_t>{591, 252});
        body_name.draw(Point<std::int16_t>{591, 271});
        top_name.draw(Point<std::int16_t>{591, 290});
        bottom_name.draw(Point<std::int16_t>{591, 309});
        shoe_name.draw(Point<std::int16_t>{591, 328});
        weapon_name.draw(Point<std::int16_t>{591, 347});
        gender_name.draw(Point<std::int16_t>{591, 366});
    }
}

void UICharCreation::update()
{
    UIElement::update();

    if (named) {
        for (auto& sprite : sprites_look_board) {
            sprite.update();
        }
    }

    new_char.update(Constants::TIMESTEP);
    name_char.update(position);

    ++cloud_fx;
}

std::string_view UICharCreation::get_equip_name(Equipslot::Id slot) const
    noexcept
{
    if (std::int32_t item_id = new_char.get_equips().get_equip(slot);
        item_id) {
        return ItemData::get(item_id).get_name();
    } else {
        return "Missing name.";
    }
}
} // namespace jrc

```

`IO/UITypes/UICharCreation.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Look/CharLook.h"
#include "../../Graphics/Text.h"
#include "../../Graphics/Texture.h"
#include "../../Template/BoolPair.h"
#include "../../Util/Randomizer.h"
#include "../Components/Textfield.h"
#include "../UIElement.h"

namespace jrc
{
//! Character creation screen.
class UICharCreation : public UIElement
{
public:
    static constexpr const Type TYPE = CHAR_CREATION;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = false;

    UICharCreation();

    void draw(float) const override;
    void update() override;

    Cursor::State send_cursor(bool, Point<std::int16_t>) override;

    void send_naming_result(bool success);

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void randomize_look();
    [[nodiscard]] std::string_view get_equip_name(Equipslot::Id slot) const
        noexcept;

    enum Buttons {
        BT_CHARC_OK,
        BT_CHARC_CANCEL,
        BT_CHARC_FACEL,
        BT_CHARC_FACER,
        BT_CHARC_HAIRL,
        BT_CHARC_HAIRR,
        BT_CHARC_HAIRCL,
        BT_CHARC_HAIRCR,
        BT_CHARC_SKINL,
        BT_CHARC_SKINR,
        BT_CHARC_TOPL,
        BT_CHARC_TOPR,
        BT_CHARC_BOTL,
        BT_CHARC_BOTR,
        BT_CHARC_SHOESL,
        BT_CHARC_SHOESR,
        BT_CHARC_WEPL,
        BT_CHARC_WEPR,
        BT_CHARC_GENDERL,
        BT_CHARC_GENDERR,
    };

    std::vector<Sprite> sprites_look_board;
    Texture sky;
    Texture cloud;
    //! Measured in quarters of a pixel.
    std::uint32_t cloud_fx;
    Texture name_board;
    Textfield name_char;
    CharLook new_char;

    BoolPair<std::vector<std::uint8_t>> skins;
    BoolPair<std::vector<std::uint8_t>> hair_colors;
    BoolPair<std::vector<std::int32_t>> faces;
    BoolPair<std::vector<std::int32_t>> hairs;
    BoolPair<std::vector<std::int32_t>> tops;
    BoolPair<std::vector<std::int32_t>> bots;
    BoolPair<std::vector<std::int32_t>> shoes;
    BoolPair<std::vector<std::int32_t>> weapons;

    bool named;
    bool female;
    std::size_t skin;
    std::size_t hair_color;
    std::size_t face;
    std::size_t hair;
    std::size_t top;
    std::size_t bottom;
    std::size_t shoe;
    std::size_t weapon;
    Text face_name;
    Text hair_name;
    Text hair_cname;
    Text body_name;
    Text top_name;
    Text bottom_name;
    Text shoe_name;
    Text weapon_name;
    Text gender_name;
};
} // namespace jrc

```

`IO/UITypes/UICharSelect.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UICharSelect.h"

#include "../../Audio/Audio.h"
#include "../../Character/Job.h"
#include "../../Configuration.h"
#include "../../Constants.h"
#include "../../Net/Packets/SelectCharPackets.h"
#include "../Components/AreaButton.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "UICharCreation.h"
#include "UISoftKey.h"
#include "nlnx/nx.hpp"

#include <string_view>

namespace jrc
{
UICharSelect::UICharSelect(std::vector<CharEntry> cs,
                           std::uint8_t c,
                           std::uint8_t s,
                           std::uint8_t channel_id,
                           std::int8_t p)
    : characters(cs), require_pic(p), char_count_absolute(c), slots_absolute(s)
{
    selected_absolute = Configuration::get().account.character;
    selected_relative = selected_absolute % PAGE_SIZE;
    page = selected_absolute / PAGE_SIZE;

    // nl::node title = nl::nx::ui["Login.img"]["Title"];
    nl::node common = nl::nx::ui["Login.img"]["Common"];
    nl::node char_select = nl::nx::ui["Login.img"]["CharSelect"];

    sprites.emplace_back(
        nl::nx::ui["Login.img"]["RaceSelect_new"]["Back"]["1"]);
    sprites.emplace_back(common["frame"], Point<std::int16_t>{400, 290});

    // Post BB
    /*
    sel_world_pos = Point<std::int16_t>(578, 42);
    char_info_pos = Point<std::int16_t>(662, 355);
    buttons[BT_ARBEIT] = std::make_unique<MapleButton>(charsel["arbeit"],
    Point<std::int16_t>(580, 115))); buttons[BT_CARDS] =
    std::make_unique<MapleButton>(charsel["characterCard"],
    Point<std::int16_t>(665, 115)));
    */

    // Pre BB
    char_info_pos = {662, 305};
    sel_world_pos = {578, 112};

    sprites.emplace_back(char_select["charInfo"], char_info_pos);
    sprites.emplace_back(common["selectWorld"], sel_world_pos);
    sprites.emplace_back(char_select["selectedWorld"]["icon"]["15"],
                         sel_world_pos);
    sprites.emplace_back(char_select["selectedWorld"]["name"]["15"],
                         sel_world_pos);
    sprites.emplace_back(char_select["selectedWorld"]["ch"][channel_id],
                         sel_world_pos);

    empty_slot = char_select["buyCharacter"];
    name_tag = char_select["nameTag"];

    buttons[BT_SELECTCHAR] = std::make_unique<MapleButton>(
        char_select["BtSelect"], char_info_pos + Point<std::int16_t>{-76, 72});
    buttons[BT_CREATECHAR] = std::make_unique<MapleButton>(
        char_select["BtNew"], Point<std::int16_t>{200, 495});
    buttons[BT_DELETECHAR] = std::make_unique<MapleButton>(
        char_select["BtDelete"], Point<std::int16_t>{320, 495});
    buttons[BT_PAGELEFT] = std::make_unique<MapleButton>(
        char_select["pageL"], Point<std::int16_t>{100, 490});
    buttons[BT_PAGERIGHT] = std::make_unique<MapleButton>(
        char_select["pageR"], Point<std::int16_t>{490, 490});

    for (std::uint8_t i = 0; i < PAGE_SIZE; ++i) {
        buttons[BT_CHAR0 + i] = std::make_unique<AreaButton>(
            Point<std::int16_t>{105 + 120 * (i % 4), 170 + 200 * (i > 3)},
            Point<std::int16_t>{50, 80});
    }

    level_set = {char_select["lv"], Charset::CENTER};

    name_label = {Text::A18M, Text::CENTER};
    for (std::size_t i = 0; i < NUM_LABELS; ++i) {
        info_labels[i] = {Text::A11M, Text::RIGHT};
    }

    for (const auto& entry : characters) {
        char_looks.emplace_back(entry.look);
        name_tags.emplace_back(
            name_tag, Text::A13M, Text::WHITE, std::string{entry.stats.name});
    }

    update_counts();
    update_selection();

    position = {0, 0};
    dimension = {Constants::VIEW_WIDTH, Constants::VIEW_HEIGHT};
    active = true;
}

void UICharSelect::draw(float alpha) const
{
    UIElement::draw(alpha);

    for (std::uint8_t i = 0; i < char_count_relative; ++i) {
        Point<std::int16_t> charpos = get_char_pos(i);
        std::uint8_t index = i + page * PAGE_SIZE;
        char_looks[index].draw(charpos, alpha);
        name_tags[index].draw(charpos);
    }

    if (selected_relative < char_count_relative) {
        const StatsEntry& stats = characters[selected_relative].stats;

        std::string levelstr = std::to_string(stats.stats[Maplestat::LEVEL]);
        std::int16_t lvx = level_set.draw(
            levelstr, char_info_pos + Point<std::int16_t>(23, -93));
        level_set.draw('l',
                       char_info_pos + Point<std::int16_t>(-7 - lvx / 2, -93));

        name_label.draw(char_info_pos + Point<std::int16_t>(0, -85));

        for (std::size_t i = 0; i < NUM_LABELS; ++i) {
            Point<std::int16_t> labelpos = char_info_pos + get_label_pos(i);
            info_labels[i].draw(labelpos);
        }
    }

    for (std::uint8_t i = char_count_relative; i < slots_relative; ++i) {
        Point<std::int16_t> position_slot(130 + (120 * (i % 4)),
                                          250 + (200 * (i > 3)));
        empty_slot.draw(position_slot, alpha);
    }
}

void UICharSelect::update()
{
    UIElement::update();

    empty_slot.update();

    for (auto& chit : char_looks) {
        chit.update(Constants::TIMESTEP);
    }
}

Button::State UICharSelect::button_pressed(std::uint16_t bid)
{
    if (bid >= BT_CHAR0) {
        name_tags[selected_absolute].set_selected(false);
        char_looks[selected_absolute].set_stance(Stance::STAND1);
        buttons[BT_CHAR0 + selected_relative]->set_state(Button::NORMAL);

        selected_relative = static_cast<std::uint8_t>(bid - BT_CHAR0);
        selected_absolute = selected_relative + page * PAGE_SIZE;
        update_selection();

        return Button::IDENTITY;
    } else {
        switch (bid) {
        case BT_SELECTCHAR:
            send_selection();
            return Button::NORMAL;
        case BT_CREATECHAR:
            active = false;
            UI::get().emplace<UICharCreation>();
            return Button::NORMAL;
        case BT_DELETECHAR:
            send_deletion();
            return Button::PRESSED;
        case BT_PAGERIGHT:
            ++page;
            update_counts();
            update_selection();
            return Button::IDENTITY;
        case BT_PAGELEFT:
            --page;
            update_counts();
            update_selection();
            return Button::IDENTITY;
        default:
            return Button::PRESSED;
        }
    }
}

void UICharSelect::update_selection()
{
    if (selected_relative >= char_count_relative) {
        return;
    }

    char_looks[selected_absolute].set_stance(Stance::WALK1);
    name_tags[selected_absolute].set_selected(true);

    buttons[BT_CHAR0 + selected_relative]->set_state(Button::PRESSED);
    name_label.change_text(characters[selected_relative].stats.name);

    for (std::size_t i = 0; i < NUM_LABELS; ++i) {
        info_labels[i].change_text(get_label_string(i));
    }
}

void UICharSelect::update_counts()
{
    if (page > 0) {
        buttons[BT_PAGELEFT]->set_state(Button::NORMAL);
    } else {
        buttons[BT_PAGELEFT]->set_state(Button::DISABLED);
    }

    if (page < slots_absolute / PAGE_SIZE) {
        buttons[BT_PAGERIGHT]->set_state(Button::NORMAL);
    } else {
        buttons[BT_PAGERIGHT]->set_state(Button::DISABLED);
    }

    char_count_relative = char_count_absolute;
    if (char_count_relative > (page + 1) * PAGE_SIZE) {
        char_count_relative = PAGE_SIZE;
    } else if (char_count_relative < page * PAGE_SIZE) {
        char_count_relative = 0;
    } else {
        char_count_relative -= page * PAGE_SIZE;
    }

    if (selected_absolute >= char_count_absolute) {
        selected_absolute = 0;
    }

    selected_relative = selected_absolute % PAGE_SIZE;
    if (selected_relative >= char_count_relative) {
        selected_relative = 0;
    }

    slots_relative = slots_absolute - page * PAGE_SIZE;
    if (slots_relative > PAGE_SIZE) {
        slots_relative = PAGE_SIZE;
    }

    if (char_count_relative < slots_relative) {
        buttons[BT_CREATECHAR]->set_state(Button::NORMAL);
    } else {
        buttons[BT_CREATECHAR]->set_state(Button::DISABLED);
    }

    if (char_count_relative > 0) {
        buttons[BT_DELETECHAR]->set_state(Button::NORMAL);
    } else {
        buttons[BT_DELETECHAR]->set_state(Button::DISABLED);
    }

    for (std::uint8_t i = 0; i < PAGE_SIZE; ++i) {
        if (i < char_count_relative) {
            buttons[BT_CHAR0 + i]->set_state(Button::NORMAL);
        } else {
            buttons[BT_CHAR0 + i]->set_state(Button::DISABLED);
        }
    }
}

void UICharSelect::send_selection()
{
    if (selected_relative >= char_count_relative) {
        buttons[BT_SELECTCHAR]->set_state(Button::MOUSE_OVER);
        return;
    }

    Configuration::get().account.character = selected_absolute;
    std::int32_t cid = characters[selected_absolute].cid;
    switch (require_pic) {
    case 0:
        UI::get().emplace<UISoftkey>([cid](std::string_view pic) {
            UI::get().disable();
            RegisterPicPacket(cid, pic).dispatch();
        });
        break;
    case 1:
        UI::get().emplace<UISoftkey>([cid](std::string_view pic) {
            UI::get().disable();
            SelectCharPicPacket(pic, cid).dispatch();
        });
        break;
    case 2:
        UI::get().disable();
        Sound{Sound::SELECT_CHAR}.play();
        SelectCharPacket{cid}.dispatch();
        break;
    default:
        Console::get().print("require_pic = " + std::to_string(require_pic));
        break;
    }
}

void UICharSelect::send_deletion()
{
    if (selected_relative >= char_count_relative) {
        buttons[BT_DELETECHAR]->set_state(Button::MOUSE_OVER);
        return;
    }

    std::int32_t cid = characters[selected_absolute].cid;
    UI::get().emplace<UISoftkey>([cid](std::string_view pic) {
        UI::get().disable();
        DeleteCharPacket{pic, cid}.dispatch();
    });
}

void UICharSelect::add_character(CharEntry character)
{
    char_looks.emplace_back(character.look);
    name_tags.emplace_back(
        name_tag, Text::A13M, Text::WHITE, std::string{character.stats.name});

    characters.emplace_back(std::move(character));

    ++char_count_absolute;
    ++char_count_relative;

    update_counts();
    update_selection();
}

void UICharSelect::remove_char(std::int32_t cid)
{
    std::size_t index = 0;
    for (const auto& character : characters) {
        if (character.cid == cid) {
            break;
        }

        ++index;
    }

    if (index == characters.size()) {
        return;
    }

    characters.erase(characters.begin() + index);
    char_looks.erase(char_looks.begin() + index);
    name_tags.erase(name_tags.begin() + index);

    --char_count_absolute;
    --char_count_relative;
    update_counts();
    update_selection();
}

const CharEntry& UICharSelect::get_character(std::int32_t cid)
{
    for (const auto& character : characters) {
        if (character.cid == cid) {
            return character;
        }
    }

    Console::get().print(
        __func__,
        str::concat("Warning: Invalid CID (", std::to_string(cid), ')'));

    static const CharEntry null_entry{{}, {}, 0};
    return null_entry;
}

std::string UICharSelect::get_label_string(std::size_t label) const
{
    const StatsEntry& stats = characters[selected_relative].stats;
    switch (label) {
    case JOB:
        return std::string{Job(stats.stats[Maplestat::JOB]).get_name()};
    case WORLDRANK:
        return std::to_string(stats.rank.first);
    case JOBRANK:
        return std::to_string(stats.job_rank.first);
    case STR:
        return std::to_string(stats.stats[Maplestat::STR]);
    case DEX:
        return std::to_string(stats.stats[Maplestat::DEX]);
    case INT:
        return std::to_string(stats.stats[Maplestat::INT]);
    case LUK:
        return std::to_string(stats.stats[Maplestat::LUK]);
    default:
        return {};
    }
}

Point<std::int16_t> UICharSelect::get_label_pos(std::size_t label) const
{
    switch (label) {
    case JOB:
        return {72, -48};
    case WORLDRANK:
        return {72, -24};
    case JOBRANK:
        return {72, -4};
    case STR:
        return {-5, 26};
    case DEX:
        return {-5, 48};
    case INT:
        return {72, 26};
    case LUK:
        return {72, 48};
    default:
        return {};
    }
}

Point<std::int16_t> UICharSelect::get_char_pos(std::size_t i) const
{
    std::int16_t x = 130 + 120 * (i % 4);
    std::int16_t y = 250 + 200 * (i > 3);
    return {x, y};
}
} // namespace jrc

```

`IO/UITypes/UICharSelect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Look/CharLook.h"
#include "../../Graphics/Sprite.h"
#include "../../Net/Login.h"
#include "../Components/Charset.h"
#include "../Components/Nametag.h"
#include "../UIElement.h"

namespace jrc
{
//! The character selection screen.
class UICharSelect : public UIElement
{
public:
    static constexpr const Type TYPE = CHAR_SELECT;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = false;

    UICharSelect(std::vector<CharEntry> characters,
                 std::uint8_t count,
                 std::uint8_t slots,
                 std::uint8_t channel_id,
                 std::int8_t pic);

    void draw(float alpha) const override;
    void update() override;
    Button::State button_pressed(std::uint16_t id) override;

    void add_character(CharEntry character);
    void remove_char(std::int32_t cid);

    const CharEntry& get_character(std::int32_t cid);

private:
    void send_selection();
    void send_deletion();
    void update_selection();
    void update_counts();
    std::string get_label_string(std::size_t label) const;
    Point<std::int16_t> get_label_pos(std::size_t label) const;
    Point<std::int16_t> get_char_pos(std::size_t id) const;

    enum Buttons {
        BT_CREATECHAR,
        BT_DELETECHAR,
        BT_SELECTCHAR,
        BT_ARBEIT,
        BT_CARDS,
        BT_PAGELEFT,
        BT_PAGERIGHT,
        BT_CHAR0
    };

    static constexpr const std::uint8_t PAGE_SIZE = 8;

    Sprite empty_slot;
    Charset level_set;
    nl::node name_tag;

    Point<std::int16_t> sel_world_pos;
    Point<std::int16_t> char_info_pos;

    std::vector<CharEntry> characters;
    std::vector<CharLook> char_looks;
    std::vector<Nametag> name_tags;
    std::int8_t require_pic;

    std::uint8_t char_count_absolute;
    std::uint8_t char_count_relative;
    std::uint8_t slots_absolute;
    std::uint8_t slots_relative;
    std::uint8_t selected_absolute;
    std::uint8_t selected_relative;
    std::uint8_t page;

    struct OutlinedText {
        Text inner;
        Text l;
        Text r;
        Text t;
        Text b;

        OutlinedText(Text::Font font, Text::Alignment alignment)
            : inner{font, alignment, Text::WHITE},
              l{font, alignment, Text::DARKGREY},
              r{font, alignment, Text::DARKGREY},
              t{font, alignment, Text::DARKGREY},
              b{font, alignment, Text::DARKGREY}
        {
        }

        OutlinedText() = default;

        void draw(Point<std::int16_t> parentpos) const
        {
            l.draw(parentpos + Point<std::int16_t>{-1, 0});
            r.draw(parentpos + Point<std::int16_t>{1, 0});
            t.draw(parentpos + Point<std::int16_t>{0, -1});
            b.draw(parentpos + Point<std::int16_t>{0, 1});
            inner.draw(parentpos);
        }

        void change_text(std::string_view text)
        {
            inner.change_text(std::string{text});
            l.change_text(std::string{text});
            r.change_text(std::string{text});
            t.change_text(std::string{text});
            b.change_text(std::string{text});
        }
    };
    OutlinedText name_label;

    static constexpr const std::size_t NUM_LABELS = 7;
    enum InfoLabel { JOB, WORLDRANK, JOBRANK, STR, DEX, INT, LUK };
    OutlinedText info_labels[NUM_LABELS];
};
} // namespace jrc

```

`IO/UITypes/UIChatBar.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIChatBar.h"

#include "../../Net/Packets/MessagingPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIChatbar::UIChatbar(Point<std::int16_t> pos)
{
    position = pos;
    dimension = {500, 60};
    chatopen = true;
    drag_chat_top = false;
    chat_rows = 4;
    row_pos = 0;
    row_max = -1;
    lastpos = 0;

    nl::node mainbar = nl::nx::ui["StatusBar2.img"]["mainBar"];
    nl::node chat_target_src = mainbar["chatTarget"];

    buttons[BT_OPENCHAT] = std::make_unique<MapleButton>(mainbar["chatOpen"]);
    buttons[BT_CLOSECHAT]
        = std::make_unique<MapleButton>(mainbar["chatClose"]);
    buttons[BT_SCROLLUP] = std::make_unique<MapleButton>(
        mainbar["scrollUp"], Point<std::int16_t>{-23, 0});
    buttons[BT_SCROLLDOWN] = std::make_unique<MapleButton>(
        mainbar["scrollDown"], Point<std::int16_t>{-23, 0});
    buttons[BT_CHATTARGETS]
        = std::make_unique<MapleButton>(chat_target_src["base"]);

    buttons[chatopen ? BT_OPENCHAT : BT_CLOSECHAT]->set_active(false);
    buttons[BT_CHATTARGETS]->set_active(chatopen);

    chatspace[false] = mainbar["chatSpace"];
    chatspace[true] = mainbar["chatEnter"];
    chatenter = mainbar["chatSpace2"];
    chatcover = mainbar["chatCover"];

    chattargets[CHT_ALL] = chat_target_src["all"];
    chattargets[CHT_BUDDY] = chat_target_src["friend"];
    chattargets[CHT_GUILD] = chat_target_src["guild"];
    chattargets[CHT_ALLIANCE] = chat_target_src["association"];
    chattargets[CHT_PARTY] = chat_target_src["party"];
    chattargets[CHT_SQUAD] = chat_target_src["expedition"];

    chattarget = CHT_ALL; // Default chat target

    nl::node chat = nl::nx::ui["StatusBar2.img"]["chat"];

    tapbar = chat["tapBar"];
    tapbartop = chat["tapBarOver"];

    chat_box = {502, 1 + chat_rows * CHAT_ROW_HEIGHT, Geometry::BLACK, 0.6f};

    chat_field
        = {Text::A11M, Text::LEFT, Text::BLACK, {{-435, -58}, {-40, -35}}, 0};
    chat_field.set_state(chatopen ? Textfield::NORMAL : Textfield::DISABLED);
    chat_field.set_enter_callback([this](const std::string& msg) {
        auto last = msg.find_last_not_of(' ');
        if (last != std::string::npos) {
            std::string m = msg.substr(0, last + 1);

            GeneralChatPacket{m, true}.dispatch();

            last_entered.push_back(std::move(m));
            lastpos = last_entered.size();
        }
    });
    chat_field.set_key_callback(KeyAction::UP, [this] {
        if (lastpos > 0) {
            --lastpos;
            chat_field.change_text(std::string{last_entered[lastpos]});
        }
    });
    chat_field.set_key_callback(KeyAction::DOWN, [this] {
        if (last_entered.size() > 0 && lastpos < last_entered.size() - 1) {
            ++lastpos;
            chat_field.change_text(std::string{last_entered[lastpos]});
        }
    });

    slider = {11,
              Range<std::int16_t>{0, CHAT_ROW_HEIGHT * chat_rows - 14},
              -22,
              chat_rows,
              1,
              [this](bool up) {
                  std::int16_t next = up ? row_pos - 1 : row_pos + 1;
                  if (next >= 0 && next <= row_max) {
                      row_pos = next;
                  }
              }};
}

void UIChatbar::draw(float inter) const
{
    chatspace[chatopen].draw(position);
    chatenter.draw(position);

    UIElement::draw(inter);

    if (chatopen) {
        tapbartop.draw({position.x() - 576, get_chat_top()});
        chat_box.draw({0, get_chat_top() + 2});

        std::int16_t chatheight = CHAT_ROW_HEIGHT * chat_rows;
        std::int16_t yshift = -chatheight;
        for (std::int16_t i = 0; i < chat_rows; ++i) {
            std::int16_t rowid = row_pos - i;
            if (!row_texts.count(rowid)) {
                break;
            }

            std::int16_t textheight
                = row_texts.at(rowid).height() / CHAT_ROW_HEIGHT;
            while (textheight > 0) {
                yshift += CHAT_ROW_HEIGHT;
                --textheight;
            }
            row_texts.at(rowid).draw({4, get_chat_top() - yshift - 1});
        }

        slider.draw({position.x(), get_chat_top() + 5});

        chattargets[chattarget].draw(position + Point<std::int16_t>(0, 2));
        chatcover.draw(position);
        chat_field.draw(position);
    } else if (row_texts.count(row_max)) {
        row_texts.at(row_max).draw(position + Point<std::int16_t>(-500, -60));
    }
}

void UIChatbar::update()
{
    UIElement::update();

    chat_field.update(position);
}

Button::State UIChatbar::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_OPENCHAT:
        chatopen = true;
        buttons[BT_OPENCHAT]->set_active(false);
        buttons[BT_CLOSECHAT]->set_active(true);
        buttons[BT_CHATTARGETS]->set_active(true);
        chat_field.set_state(Textfield::NORMAL);
        break;
    case BT_CLOSECHAT:
        chatopen = false;
        buttons[BT_OPENCHAT]->set_active(true);
        buttons[BT_CLOSECHAT]->set_active(false);
        buttons[BT_CHATTARGETS]->set_active(false);
        chat_field.set_state(Textfield::DISABLED);
        break;
    }

    return Button::NORMAL;
}

bool UIChatbar::is_in_range(Point<std::int16_t> cursor_pos) const
{
    Point<std::int16_t> absp{0, get_chat_top() - 16};
    Point<std::int16_t> dim{500,
                            chat_rows * CHAT_ROW_HEIGHT + CHAT_Y_OFFSET + 16};
    return Rectangle<std::int16_t>{absp, absp + dim}.contains(cursor_pos);
}

bool UIChatbar::remove_cursor(bool clicked, Point<std::int16_t> cursor_pos)
{
    if (slider.remove_cursor(clicked)) {
        return true;
    }

    return UIElement::remove_cursor(clicked, cursor_pos);
}

Cursor::State UIChatbar::send_cursor(bool clicking,
                                     Point<std::int16_t> cursorpos)
{
    if (slider.is_enabled()) {
        auto cursoroffset
            = cursorpos
              - Point<std::int16_t>(position.x(), get_chat_top() + 5);
        Cursor::State sstate = slider.send_cursor(cursoroffset, clicking);
        if (sstate != Cursor::IDLE) {
            return sstate;
        }
    }

    if (chat_field.get_state() == Textfield::NORMAL) {
        Cursor::State tstate = chat_field.send_cursor(cursorpos, clicking);
        if (tstate != Cursor::IDLE) {
            return tstate;
        }
    }

    auto chattop
        = Rectangle<std::int16_t>{0, 502, get_chat_top(), get_chat_top() + 6};
    bool contains = chattop.contains(cursorpos);
    if (drag_chat_top) {
        if (clicking) {
            std::int16_t ydelta = cursorpos.y() - get_chat_top();
            while (ydelta > 0 && chat_rows > MINCHATROWS) {
                --chat_rows;
                ydelta -= CHAT_ROW_HEIGHT;
            }
            while (ydelta < 0 && chat_rows < MAXCHATROWS) {
                ++chat_rows;
                ydelta += CHAT_ROW_HEIGHT;
            }
            chat_box.setheight(1 + chat_rows * CHAT_ROW_HEIGHT);
            slider.set_rows(row_pos, chat_rows, row_max);
            slider.set_vertical({0, CHAT_ROW_HEIGHT * chat_rows - 14});
            return Cursor::CLICKING;
        } else {
            drag_chat_top = false;
        }
    } else if (contains) {
        if (clicking) {
            drag_chat_top = true;
            return Cursor::CLICKING;
        } else {
            return Cursor::CAN_CLICK;
        }
    }

    return UIElement::send_cursor(clicking, cursorpos);
}

void UIChatbar::send_line(std::string&& line, LineType type)
{
    ++row_max;
    row_pos = row_max;

    slider.set_rows(row_pos, chat_rows, row_max);

    row_texts.emplace(std::piecewise_construct,
                      std::forward_as_tuple(row_max),
                      std::forward_as_tuple(Text::A12M,
                                            Text::LEFT,
                                            [](auto type) {
                                                switch (type) {
                                                case RED:
                                                    return Text::DARKRED;
                                                case BLUE:
                                                    return Text::MEDIUMBLUE;
                                                case YELLOW:
                                                    return Text::YELLOW;
                                                default:
                                                    return Text::WHITE;
                                                }
                                            }(type),
                                            std::move(line),
                                            480));
}

std::int16_t UIChatbar::get_chat_top() const
{
    return position.y() - chat_rows * CHAT_ROW_HEIGHT - CHAT_Y_OFFSET;
}
} // namespace jrc

```

`IO/UITypes/UIChatBar.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Geometry.h"
#include "../../Graphics/Texture.h"
#include "../Components/Slider.h"
#include "../Components/Textfield.h"
#include "../UIElement.h"

#include <unordered_map>
#include <vector>

namespace jrc
{
class UIChatbar : public UIElement
{
public:
    enum ChatTarget {
        CHT_ALL,
        CHT_BUDDY,
        CHT_GUILD,
        CHT_ALLIANCE,
        CHT_PARTY,
        CHT_SQUAD,
        NUM_TARGETS
    };

    enum LineType { UNK0, WHITE, RED, BLUE, YELLOW };

    UIChatbar(Point<std::int16_t> position);

    void draw(float inter) const override;
    void update() override;

    bool is_in_range(Point<std::int16_t> cursor_pos) const override;
    bool remove_cursor(bool clicked, Point<std::int16_t> cursor_pos) override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursorpos) override;

    void send_line(std::string&& line, LineType type);

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    std::int16_t get_chat_top() const;

    enum Buttons : std::uint16_t {
        BT_OPENCHAT,
        BT_CLOSECHAT,
        BT_SCROLLUP,
        BT_SCROLLDOWN,
        BT_CHATTARGETS
    };

    static constexpr const std::int16_t CHAT_Y_OFFSET = 65;
    static constexpr const std::int16_t CHAT_ROW_HEIGHT = 16;
    static constexpr const std::int16_t MAXCHATROWS = 16;
    static constexpr const std::int16_t MINCHATROWS = 1;

    Textfield chat_field;
    Texture chatspace[2];
    Texture chattargets[NUM_TARGETS];
    Texture chatenter;
    Texture chatcover;
    Texture tapbar;
    Texture tapbartop;

    bool chatopen;
    ChatTarget chattarget;

    std::vector<std::string> last_entered;
    std::size_t lastpos;

    std::unordered_map<std::int16_t, Text> row_texts;
    ColorBox chat_box;
    std::int16_t chat_rows;
    std::int16_t row_pos;
    std::int16_t row_max;
    Slider slider;
    bool drag_chat_top;
};
} // namespace jrc

```

`IO/UITypes/UIEquipInventory.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIEquipInventory.h"

#include "../../Data/ItemData.h"
#include "../../Net/Packets/InventoryPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIEquipInventory::UIEquipInventory(const Inventory& invent)
    : UIDragElement<Configuration::PositionOf::EQUIP_INVENTORY>{{184, 20}},
      inventory{invent}
{
    icon_positions[Equipslot::CAP] = {43, 25};
    icon_positions[Equipslot::FACEACC] = {43, 91};
    icon_positions[Equipslot::EYEACC] = {43, 68};
    icon_positions[Equipslot::EARRINGS] = {109, 91};
    icon_positions[Equipslot::TOP] = {43, 124};
    icon_positions[Equipslot::PANTS] = {43, 157};
    icon_positions[Equipslot::SHOES] = {76, 190};
    icon_positions[Equipslot::GLOVES] = {10, 157};
    icon_positions[Equipslot::CAPE] = {10, 124};
    icon_positions[Equipslot::SHIELD] = {142, 124};
    icon_positions[Equipslot::WEAPON] = {109, 124};
    icon_positions[Equipslot::RING] = {109, 157};
    icon_positions[Equipslot::RING2] = {142, 157};
    icon_positions[Equipslot::RING3] = {109, 91};
    icon_positions[Equipslot::RING4] = {142, 91};
    icon_positions[Equipslot::PENDANT] = {76, 124};
    icon_positions[Equipslot::TAMEDMOB] = {142, 91};
    icon_positions[Equipslot::SADDLE] = {76, 124};
    icon_positions[Equipslot::MEDAL] = {10, 58};
    icon_positions[Equipslot::BELT] = {76, 157};

    nl::node base_source = nl::nx::ui["UIWindow2.img"]["Equip"];
    nl::node source = base_source["character"];
    nl::node pet_source = base_source["pet"];

    sprites.emplace_back(source["backgrnd"]);
    sprites.emplace_back(source["backgrnd2"]);
    sprites.emplace_back(source["backgrnd3_Kanna"]);
    sprites.emplace_back(source["cashPendant"]);
    sprites.emplace_back(source["charmPocket"]);
    sprites.emplace_back(source["emblem"]);

    buttons[BT_TOGGLEPETS] = std::make_unique<MapleButton>(source["BtPet"]);

    textures_pet.emplace_back(pet_source["backgrnd"]);
    textures_pet.emplace_back(pet_source["backgrnd2"]);
    textures_pet.emplace_back(pet_source["backgrnd3"]);

    load_icons();

    dimension = {184, 290};
    active = true;
    show_pet_equips = false;
}

void UIEquipInventory::draw(float alpha) const
{
    UIElement::draw(alpha);

    for (auto [equip_slot, icon] : icons) {
        if (icon) {
            icon->draw(position + icon_positions[equip_slot]);
        }
    }

    if (show_pet_equips) {
        auto position_pet = position + Point<std::int16_t>{184, 0};
        for (const auto& texture : textures_pet) {
            texture.draw(position_pet);
        }
    }
}

Button::State UIEquipInventory::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case BT_TOGGLEPETS:
        show_pet_equips = !show_pet_equips;
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

void UIEquipInventory::update_slot(Equipslot::Id slot)
{
    if (std::int32_t item_id
        = inventory.get_item_id(InventoryType::EQUIPPED, slot);
        item_id) {
        const Texture& texture = ItemData::get(item_id).get_icon(false);
        icons[slot] = std::make_unique<Icon>(
            std::make_unique<EquipIcon>(item_id, slot), texture, -1);
    } else if (icons[slot]) {
        icons[slot].release();
    }

    clear_tooltip();
}

void UIEquipInventory::load_icons()
{
    icons.clear();

    for (auto slot_id : Equipslot::values) {
        update_slot(slot_id);
    }
}

Cursor::State UIEquipInventory::send_cursor(bool pressed,
                                            Point<std::int16_t> cursor_pos)
{
    Cursor::State dstate = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        clear_tooltip();
        return dstate;
    }

    Equipslot::Id slot = slot_by_position(cursor_pos);
    if (auto icon = icons[slot].get(); icon) {
        if (pressed) {
            icon->start_drag(cursor_pos - position - icon_positions[slot]);
            UI::get().drag_icon(icon);

            clear_tooltip();
            return Cursor::GRABBING;
        } else {
            show_equip(slot);
            return Cursor::CAN_GRAB;
        }
    } else {
        clear_tooltip();
        return Cursor::IDLE;
    }
}

void UIEquipInventory::double_click(Point<std::int16_t> cursor_pos)
{
    Equipslot::Id slot = slot_by_position(cursor_pos);
    if (icons[slot]) {
        if (std::int16_t free_slot
            = inventory.find_free_slot(InventoryType::EQUIP);
            free_slot) {
            UnequipItemPacket{slot, free_slot}.dispatch();
        }
    }
}

void UIEquipInventory::send_icon(const Icon& icon,
                                 Point<std::int16_t> cursor_pos)
{
    if (Equipslot::Id slot = slot_by_position(cursor_pos); slot) {
        icon.drop_on_equips(slot);
    }
}

void UIEquipInventory::toggle_active()
{
    clear_tooltip();
    UIElement::toggle_active();
}

void UIEquipInventory::modify(std::int16_t pos,
                              std::int8_t mode,
                              std::int16_t arg)
{
    Equipslot::Id eq_pos = Equipslot::by_id(pos);
    Equipslot::Id eq_arg = Equipslot::by_id(arg);
    switch (mode) {
    case 0:
    case 3:
        update_slot(eq_pos);
        break;
    case 2:
        update_slot(eq_pos);
        update_slot(eq_arg);
        break;
    }
}

void UIEquipInventory::show_equip(Equipslot::Id slot)
{
    UI::get().show_equip(Tooltip::EQUIP_INVENTORY, slot);
}

void UIEquipInventory::clear_tooltip()
{
    UI::get().clear_tooltip(Tooltip::EQUIP_INVENTORY);
}

Equipslot::Id
UIEquipInventory::slot_by_position(Point<std::int16_t> cursor_pos) const
{
    for (auto [slot, slot_pos] : icon_positions) {
        Rectangle<std::int16_t> icon_rect{position + slot_pos,
                                          position + slot_pos + 32};
        if (icon_rect.contains(cursor_pos)) {
            return slot;
        }
    }
    return Equipslot::NONE;
}

UIEquipInventory::EquipIcon::EquipIcon(std::int32_t iid,
                                       std::int16_t s) noexcept
    : item_id{iid}, source{s}
{
}

void UIEquipInventory::EquipIcon::drop_on_stage() const
{
    UnequipItemPacket{source, 0}.dispatch();
}

void UIEquipInventory::EquipIcon::drop_on_items(InventoryType::Id tab,
                                                Equipslot::Id eqslot,
                                                std::int16_t slot,
                                                bool equip) const
{
    if (tab != InventoryType::EQUIP) {
        return;
    }

    if (equip) {
        if (eqslot == source) {
            EquipItemPacket{slot, eqslot}.dispatch();
        }
    } else {
        UnequipItemPacket{source, slot}.dispatch();
    }
}

std::int32_t UIEquipInventory::EquipIcon::get_action_id() const noexcept
{
    return item_id;
}
} // namespace jrc

```

`IO/UITypes/UIEquipInventory.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Inventory.h"
#include "../../Template/EnumMap.h"
#include "../Components/EquipTooltip.h"
#include "../Components/Icon.h"
#include "../UIDragElement.h"

namespace jrc
{
//! The Equip inventory UI.
class UIEquipInventory
    : public UIDragElement<Configuration::PositionOf::EQUIP_INVENTORY>
{
public:
    static constexpr Type TYPE = EQUIP_INVENTORY;
    static constexpr bool FOCUSED = false;
    static constexpr bool TOGGLED = true;

    UIEquipInventory(const Inventory& inventory);

    void draw(float inter) const override;

    void toggle_active() override;
    void double_click(Point<std::int16_t> position) override;
    void send_icon(const Icon& icon, Point<std::int16_t> position) override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> position) override;

    void modify(std::int16_t pos, std::int8_t mode, std::int16_t arg);

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void show_equip(Equipslot::Id slot);
    void clear_tooltip();
    void load_icons();
    void update_slot(Equipslot::Id slot);
    Equipslot::Id slot_by_position(Point<std::int16_t> cursor_pos) const;

    class EquipIcon : public Icon::Type
    {
    public:
        EquipIcon(std::int32_t item_id_, std::int16_t source_) noexcept;

        void drop_on_stage() const override;
        void drop_on_equips(Equipslot::Id) const override
        {
        }
        void drop_on_items(InventoryType::Id tab,
                           Equipslot::Id eqslot,
                           std::int16_t slot,
                           bool equip) const override;

        std::int32_t get_action_id() const noexcept override;

    private:
        std::int32_t item_id;
        std::int16_t source;
    };

    enum Buttons { BT_TOGGLEPETS };

    const Inventory& inventory;

    std::vector<Texture> textures_pet;
    EnumMap<Equipslot::Id, Point<std::int16_t>> icon_positions;
    EnumMap<Equipslot::Id, std::unique_ptr<Icon>> icons;

    bool show_pet_equips;
};
} // namespace jrc

```

`IO/UITypes/UIGameSettings.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIGameSettings.h"

#include "../../Configuration.h"
#include "../../Gameplay/Stage.h"
#include "../../Net/Packets/GameplayPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIGameSettings::UIGameSettings()
    : UIDragElement<Configuration::PositionOf::GAME_SETTINGS>{DRAG_AREA}
{
    nl::node source = nl::nx::ui["UIWindow2.img"]["GameOpt"];

    sprites.emplace_back(source["backgrnd"]);
    sprites.emplace_back(source["backgrnd2"]);
    sprites.emplace_back(source["backgrnd3"]);

    buttons[BT_CANCEL]
        = std::make_unique<MapleButton>(source["BtCancle" /* [sic] */]);
    buttons[BT_OK] = std::make_unique<MapleButton>(source["BtOK"]);

    check_texture = source["check"];

    load_settings();

    dimension = {WIDTH, HEIGHT};
    active = true;
}

void UIGameSettings::draw(float inter) const
{
    UIElement::draw(inter);

    auto check_pos = position + CHECKS_OFFSET;
    for (std::uint16_t check = 0; check < NUM_CHECKS; ++check) {
        bool checked = checks_state & static_cast<std::uint16_t>(1 << check);
        check_texture.draw({check_pos, checked ? 1.0f : 0.1f});
        check_pos += {0, STRIDE_VERT};
    }
}

Cursor::State UIGameSettings::send_cursor(bool pressed,
                                          Point<std::int16_t> cursor_pos)
{
    Cursor::State drag_state = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        return drag_state;
    }

    auto [normal_x, normal_y] = cursor_pos - position - CHECKS_OFFSET;
    if (normal_x < 0 || normal_x > CHECK_SIDE_LEN || normal_y < 0) {
        return Cursor::IDLE;
    }

    std::uint16_t button_ix = normal_y / STRIDE_VERT;
    if (button_ix >= NUM_CHECKS
        || STRIDE_VERT * button_ix + CHECK_SIDE_LEN < normal_y) {
        return Cursor::IDLE;
    }

    if (pressed) {
        checks_state ^= static_cast<std::uint16_t>(1 << button_ix);
    }

    return Cursor::CAN_CLICK;
}

Button::State UIGameSettings::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case BT_CANCEL:
        active = false;
        load_settings();
        return Button::NORMAL;
    case BT_OK:
        commit();
        active = false;
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

void UIGameSettings::load_settings() noexcept
{
    checks_state
        = Configuration::get()
              .get_character(std::string{Stage::get().get_player().get_name()})
              .game_settings.flags;
}

void UIGameSettings::commit() const noexcept
{
    Configuration::get()
        .get_character(std::string{Stage::get().get_player().get_name()})
        .game_settings.flags
        = checks_state;
}
} // namespace jrc

```

`IO/UITypes/UIGameSettings.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Components/TwoSpriteButton.h"
#include "../UIDragElement.h"

namespace jrc
{
//! UI popup for changing in-game settings.
class UIGameSettings
    : public UIDragElement<Configuration::PositionOf::GAME_SETTINGS>
{
public:
    static constexpr const Type TYPE = GAME_SETTINGS;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UIGameSettings();

    void draw(float inter) const override;
    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> cursor_pos) override;

    enum Checks : std::uint16_t {
        WHISPERS,
        FRIEND_INVITES,
        CHAT_INVITES,
        TRADE_REQUESTS,
        PARTY_INVITES,
        SIDEKICK_INVITES,
        EXPEDITION_INVITES,
        GUILD_CHAT,
        GUILD_INVITES,
        ALLIANCE_CHAT,
        ALLIANCE_INVITES,
        FAMILY_INVITES,
        FOLLOW,

        NUM_CHECKS
    };

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void load_settings() noexcept;
    void commit() const noexcept;

    Texture check_texture;
    std::uint16_t checks_state;

    enum Buttons : std::uint16_t { BT_CANCEL, BT_OK };

    static constexpr const std::int16_t WIDTH = 119;

    static constexpr const std::int16_t HEIGHT = 287;
    static constexpr const std::int16_t STRIDE_VERT = 18;
    static constexpr const std::int16_t DRAG_HEIGHT = 17;

    static constexpr const std::int16_t CHECK_SIDE_LEN = 6;

    static constexpr const Point<std::int16_t> DRAG_AREA{WIDTH, DRAG_HEIGHT};
    static constexpr const Point<std::int16_t> CHECKS_OFFSET{WIDTH - 20, 28};
};
} // namespace jrc

```

`IO/UITypes/UIItemInventory.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIItemInventory.h"

#include "../../Data/ItemData.h"
#include "../../Net/Packets/InventoryPackets.h"
#include "../../Util/Misc.h"
#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIItemInventory::UIItemInventory(const Inventory& invent)
    : UIDragElement<Configuration::PositionOf::INVENTORY>{Point<std::int16_t>{
          172, 20}},
      inventory{invent}
{
    nl::node src = nl::nx::ui["UIWindow2.img"]["Item"];

    sprites.emplace_back(src["backgrnd"]);
    sprites.emplace_back(src["backgrnd2"]);
    sprites.emplace_back(src["backgrnd3"]);

    auto new_src = src["New"];
    new_item_slot = new_src["inventory"];
    new_item_tab = new_src["Tab0"];
    projectile = src["activeIcon"];

    auto tab_src = src["Tab"];
    nl::node tab_en = tab_src["enabled"];
    nl::node tab_dis = tab_src["disabled"];

    buttons[BT_TAB_EQUIP] = std::make_unique<TwoSpriteButton>(
        tab_dis["0"], tab_en["0"], Point<std::int16_t>{-1, -4});
    buttons[BT_TAB_USE] = std::make_unique<TwoSpriteButton>(
        tab_dis["1"], tab_en["1"], Point<std::int16_t>{-1, -4});
    buttons[BT_TAB_ETC] = std::make_unique<TwoSpriteButton>(
        tab_dis["2"], tab_en["2"], Point<std::int16_t>{0, -4});
    buttons[BT_TAB_SETUP] = std::make_unique<TwoSpriteButton>(
        tab_dis["3"], tab_en["3"], Point<std::int16_t>{-1, -4});
    buttons[BT_TAB_CASH] = std::make_unique<TwoSpriteButton>(
        tab_dis["4"], tab_en["4"], Point<std::int16_t>{-1, -4});

    buttons[BT_DROPMESO] = std::make_unique<MapleButton>(src["BtCoin"]);
    buttons[BT_POINTS] = std::make_unique<MapleButton>(src["BtPoint0"]);
    buttons[BT_GATHER] = std::make_unique<MapleButton>(src["BtGather"]);
    buttons[BT_SORT] = std::make_unique<MapleButton>(src["BtSort"]);
    buttons[BT_EXPAND] = std::make_unique<MapleButton>(src["BtFull"]);
    buttons[BT_ITEMPOT] = std::make_unique<MapleButton>(src["BtPot3"]);
    buttons[BT_UPGRADE] = std::make_unique<MapleButton>(src["BtUpgrade3"]);
    buttons[BT_MAGNIFY] = std::make_unique<MapleButton>(src["BtAppraise3"]);
    buttons[BT_BITCASE] = std::make_unique<MapleButton>(src["BtBits3"]);

    tab = InventoryType::EQUIP;
    slot_range.first = 1;
    slot_range.second = 24;
    new_tab = InventoryType::NONE;
    new_slot = 0;

    buttons[BT_SORT]->set_active(false);
    buttons[button_by_tab(tab)]->set_state(Button::PRESSED);

    meso_label = {Text::A11M, Text::RIGHT, Text::LIGHTGREY};

    slider = {11,
              {50, 248},
              152,
              6,
              1 + inventory.get_slotmax(tab) / 4,
              [this](bool upwards) {
                  auto shift = static_cast<std::int16_t>(upwards ? -4 : 4);
                  bool above = slot_range.first + shift > 0;
                  bool below = slot_range.second + shift
                               < inventory.get_slotmax(tab) + 1 + 4;
                  if (above && below) {
                      slot_range.first += shift;
                      slot_range.second += shift;
                  }
              }};

    dimension = {172, 335};
    active = true;

    load_icons();
}

void UIItemInventory::draw(float alpha) const
{
    UIElement::draw(alpha);

    slider.draw(position);

    for (auto& [slot, icon] : icons) {
        if (icon && slot >= slot_range.first && slot <= slot_range.second) {
            Point<std::int16_t> slot_pos = get_slot_pos(slot);
            icon->draw(position + slot_pos);
        }
    }

    std::int16_t bullet_slot = inventory.get_bullet_slot();
    if (tab == InventoryType::USE && is_visible(bullet_slot)) {
        projectile.draw({position + get_slot_pos(bullet_slot)});
    } else if (new_tab == tab && is_visible(new_slot)) {
        Point<std::int16_t> new_slot_pos = position + get_slot_pos(new_slot);
        new_slot_pos.shift_y(1);
        new_item_slot.draw({new_slot_pos}, alpha);
    }

    if (new_tab != tab && new_tab != InventoryType::NONE) {
        Point<std::int16_t> new_tab_pos = position + get_tab_pos(new_tab);
        new_item_tab.draw({new_tab_pos}, alpha);
    }

    auto meso_pos = position + Point<std::int16_t>{124, 264};
    meso_label.draw(meso_pos);
}

void UIItemInventory::update()
{
    UIElement::update();

    new_item_tab.update(6);
    new_item_slot.update(6);

    std::int64_t meso = inventory.get_meso();
    std::string meso_str = std::to_string(meso);
    string_format::split_number(meso_str);
    meso_label.change_text(std::move(meso_str));
}

void UIItemInventory::update_slot(std::int16_t slot)
{
    if (std::int32_t item_id = inventory.get_item_id(tab, slot); item_id) {
        std::int16_t count = tab == InventoryType::EQUIP
                                 ? -1
                                 : inventory.get_item_count(tab, slot);

        const Texture& texture = ItemData::get(item_id).get_icon(false);
        Equipslot::Id eq_slot = inventory.find_equip_slot(item_id);
        icons[slot] = std::make_unique<Icon>(
            std::make_unique<ItemIcon>(item_id, tab, eq_slot, slot),
            texture,
            count);
    } else if (icons.count(slot)) {
        icons.erase(slot);
    }
}

void UIItemInventory::load_icons()
{
    icons.clear();

    std::uint8_t num_slots = inventory.get_slotmax(tab);
    for (std::uint8_t i = 1; i < num_slots; ++i) {
        update_slot(i);
    }
}

Button::State UIItemInventory::button_pressed(std::uint16_t button_id)
{
    InventoryType::Id old_tab = tab;
    switch (button_id) {
    case BT_TAB_EQUIP:
        tab = InventoryType::EQUIP;
        break;
    case BT_TAB_USE:
        tab = InventoryType::USE;
        break;
    case BT_TAB_SETUP:
        tab = InventoryType::SETUP;
        break;
    case BT_TAB_ETC:
        tab = InventoryType::ETC;
        break;
    case BT_TAB_CASH:
        tab = InventoryType::CASH;
        break;
    case BT_GATHER:
        GatherItemsPacket{tab}.dispatch();
        break;
    case BT_SORT:
        SortItemsPacket{tab}.dispatch();
        break;
    }

    if (tab != old_tab) {
        slot_range.first = 1;
        slot_range.second = 24;

        slider.set_rows(
            6, static_cast<std::int16_t>(1 + inventory.get_slotmax(tab) / 4));

        buttons[button_by_tab(old_tab)]->set_state(Button::NORMAL);

        load_icons();
        enable_gather();
    }

    return Button::PRESSED;
}

void UIItemInventory::double_click(Point<std::int16_t> cursor_pos)
{
    std::int16_t slot = slot_by_position(cursor_pos - position);
    if (icons.count(slot) && is_visible(slot)) {
        if (std::int32_t item_id = inventory.get_item_id(tab, slot); item_id) {
            switch (tab) {
            case InventoryType::EQUIP:
                EquipItemPacket{slot, inventory.find_equip_slot(item_id)}
                    .dispatch();
                break;
            case InventoryType::USE:
                if (item_id / 10'000 != 204 && item_id / 10'000 != 206
                    && item_id / 10'000 != 207) {
                    UseItemPacket{slot, item_id}.dispatch();
                }
                break;
            default:
                break;
            }
        }
    }
}

void UIItemInventory::send_icon(const Icon& icon,
                                Point<std::int16_t> cursor_pos)
{
    std::int16_t slot = slot_by_position(cursor_pos - position);
    if (slot > 0) {
        std::int32_t item_id = inventory.get_item_id(tab, slot);
        Equipslot::Id eqslot;
        bool equip;
        if (item_id && tab == InventoryType::EQUIP) {
            eqslot = inventory.find_equip_slot(item_id);
            equip = true;
        } else {
            eqslot = Equipslot::NONE;
            equip = false;
        }
        icon.drop_on_items(tab, eqslot, slot, equip);
    }
}

Cursor::State UIItemInventory::send_cursor(bool pressed,
                                           Point<std::int16_t> cursor_pos)
{
    Cursor::State dstate = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        clear_tooltip();
        return dstate;
    }

    Point<std::int16_t> cursor_relative = cursor_pos - position;
    if (slider.is_enabled()) {
        Cursor::State sstate = slider.send_cursor(cursor_relative, pressed);
        if (sstate != Cursor::IDLE) {
            clear_tooltip();
            return sstate;
        }
    }

    std::int16_t slot = slot_by_position(cursor_relative);
    Icon* icon = get_icon(slot);
    if (icon && is_visible(slot)) {
        if (pressed) {
            Point<std::int16_t> slotpos = get_slot_pos(slot);
            icon->start_drag(cursor_relative - slotpos);
            UI::get().drag_icon(icon);

            clear_tooltip();
            return Cursor::GRABBING;
        } else {
            show_item(slot);
            return Cursor::CAN_GRAB;
        }
    } else {
        clear_tooltip();
        return Cursor::IDLE;
    }
}

void UIItemInventory::modify(InventoryType::Id type,
                             std::int16_t slot,
                             std::int8_t mode,
                             std::int16_t arg)
{
    if (slot <= 0) {
        return;
    }

    if (type == tab) {
        switch (mode) {
        case Inventory::ADD:
            update_slot(slot);
            new_tab = type;
            new_slot = slot;
            break;
        case Inventory::CHANGE_COUNT:
        case Inventory::ADD_COUNT:
            if (auto icon = get_icon(slot)) {
                icon->set_count(arg);
            }
            break;
        case Inventory::SWAP:
            if (arg != slot) {
                update_slot(slot);
                update_slot(arg);
            }
            break;
        case Inventory::REMOVE:
            update_slot(slot);
            break;
        }
    }

    switch (mode) {
    case Inventory::ADD:
    case Inventory::ADD_COUNT:
        new_tab = type;
        new_slot = slot;
        break;
    case Inventory::CHANGE_COUNT:
    case Inventory::SWAP:
    case Inventory::REMOVE:
        if (new_slot == slot && new_tab == type) {
            new_slot = 0;
            new_tab = InventoryType::NONE;
        }
        break;
    }
}

void UIItemInventory::enable_sort()
{
    buttons[BT_GATHER]->set_active(false);
    buttons[BT_SORT]->set_active(true);
    buttons[BT_SORT]->set_state(Button::NORMAL);
}

void UIItemInventory::enable_gather()
{
    buttons[BT_SORT]->set_active(false);
    buttons[BT_GATHER]->set_active(true);
    buttons[BT_GATHER]->set_state(Button::NORMAL);
}

void UIItemInventory::toggle_active()
{
    clear_tooltip();
    UIElement::toggle_active();
}

bool UIItemInventory::remove_cursor(bool clicked,
                                    Point<std::int16_t> cursor_pos)
{
    if (UIDragElement::remove_cursor(clicked, cursor_pos)) {
        return true;
    }

    return slider.remove_cursor(clicked);
}

void UIItemInventory::show_item(std::int16_t slot)
{
    if (tab == InventoryType::EQUIP) {
        UI::get().show_equip(Tooltip::ITEM_INVENTORY, slot);
    } else {
        std::int32_t item_id = inventory.get_item_id(tab, slot);
        UI::get().show_item(Tooltip::ITEM_INVENTORY, item_id);
    }
}

void UIItemInventory::clear_tooltip()
{
    UI::get().clear_tooltip(Tooltip::ITEM_INVENTORY);
}

bool UIItemInventory::is_visible(std::int16_t slot) const
{
    return !is_not_visible(slot);
}

bool UIItemInventory::is_not_visible(std::int16_t slot) const
{
    return slot < slot_range.first || slot > slot_range.second;
}

std::int16_t
UIItemInventory::slot_by_position(Point<std::int16_t> cursor_pos) const
{
    auto xoff = cursor_pos.x() - 11;
    auto yoff = cursor_pos.y() - 51;
    if (xoff < 1 || xoff > 143 || yoff < 1) {
        return 0;
    }

    auto slot = slot_range.first + xoff / 36 + 4 * (yoff / 35);
    return is_visible(slot) ? slot : 0;
}

Point<std::int16_t> UIItemInventory::get_slot_pos(std::int16_t slot) const
{
    std::int16_t abs_slot = slot - slot_range.first;
    return {11 + (abs_slot % 4) * 36, 51 + (abs_slot / 4) * 35};
}

Point<std::int16_t> UIItemInventory::get_tab_pos(InventoryType::Id tb) const
{
    switch (tb) {
    case InventoryType::EQUIP:
        return {10, 28};
    case InventoryType::USE:
        return {42, 28};
    case InventoryType::SETUP:
        return {74, 28};
    case InventoryType::ETC:
        return {105, 28};
    case InventoryType::CASH:
        return {138, 28};
    default:
        return {};
    }
}

std::uint16_t UIItemInventory::button_by_tab(InventoryType::Id tb) const
{
    switch (tb) {
    case InventoryType::EQUIP:
        return BT_TAB_EQUIP;
    case InventoryType::USE:
        return BT_TAB_USE;
    case InventoryType::SETUP:
        return BT_TAB_SETUP;
    case InventoryType::ETC:
        return BT_TAB_ETC;
    default:
        return BT_TAB_CASH;
    }
}

Icon* UIItemInventory::get_icon(std::int16_t slot)
{
    if (auto iter = icons.find(slot); iter != icons.end()) {
        return iter->second.get();
    } else {
        return nullptr;
    }
}

UIItemInventory::ItemIcon::ItemIcon(std::int32_t iid,
                                    InventoryType::Id st,
                                    Equipslot::Id eqs,
                                    std::int16_t s) noexcept
    : item_id{iid}, source_tab{st}, eq_source{eqs}, source{s}
{
}

void UIItemInventory::ItemIcon::drop_on_stage() const
{
    MoveItemPacket{source_tab, source, 0, 1}.dispatch();
}

void UIItemInventory::ItemIcon::drop_on_equips(Equipslot::Id eq_slot) const
{
    switch (source_tab) {
    case InventoryType::EQUIP:
        if (eq_source == eq_slot) {
            EquipItemPacket{source, eq_slot}.dispatch();
        }
        break;
    case InventoryType::USE:
        ScrollEquipPacket{source, eq_slot}.dispatch();
        break;
    default:
        break;
    }
}

void UIItemInventory::ItemIcon::drop_on_items(InventoryType::Id tab_id,
                                              Equipslot::Id,
                                              std::int16_t slot,
                                              bool) const
{
    if (tab_id != source_tab || slot == source) {
        return;
    }

    MoveItemPacket{tab_id, source, slot, 1}.dispatch();
}

std::int32_t UIItemInventory::ItemIcon::get_action_id() const noexcept
{
    return item_id;
}
} // namespace jrc

```

`IO/UITypes/UIItemInventory.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Inventory.h"
#include "../../Graphics/Text.h"
#include "../Components/Icon.h"
#include "../Components/Slider.h"
#include "../UIDragElement.h"

#include <unordered_map>

namespace jrc
{
//! The Item inventory.
class UIItemInventory
    : public UIDragElement<Configuration::PositionOf::INVENTORY>
{
public:
    static constexpr const Type TYPE = ITEM_INVENTORY;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UIItemInventory(const Inventory& inventory);

    void draw(float inter) const override;
    void update() override;

    void double_click(Point<std::int16_t> cursor_pos) override;
    void send_icon(const Icon& icon, Point<std::int16_t> cursor_pos) override;
    void toggle_active() override;
    bool remove_cursor(bool clicked, Point<std::int16_t> cursor_pos) override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursor_pos) override;

    void modify(InventoryType::Id type,
                std::int16_t pos,
                std::int8_t mode,
                std::int16_t arg);
    void enable_sort();
    void enable_gather();

    class ItemIcon : public Icon::Type
    {
    public:
        ItemIcon(std::int32_t item_id_,
                 InventoryType::Id source_tab_,
                 Equipslot::Id eq_source_,
                 std::int16_t source_) noexcept;

        void drop_on_stage() const override;
        void drop_on_equips(Equipslot::Id eq_slot) const override;
        void drop_on_items(InventoryType::Id tab,
                           Equipslot::Id,
                           std::int16_t slot,
                           bool) const override;

        std::int32_t get_action_id() const noexcept override;

    private:
        std::int32_t item_id;
        InventoryType::Id source_tab;
        Equipslot::Id eq_source;
        std::int16_t source;
    };

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    void show_item(std::int16_t slot);
    void clear_tooltip();
    void load_icons();
    void update_slot(std::int16_t slot);
    bool is_visible(std::int16_t slot) const;
    bool is_not_visible(std::int16_t slot) const;
    std::int16_t slot_by_position(Point<std::int16_t> cursor_pos) const;
    std::uint16_t button_by_tab(InventoryType::Id tab) const;
    Point<std::int16_t> get_slot_pos(std::int16_t slot) const;
    Point<std::int16_t> get_tab_pos(InventoryType::Id tab) const;
    Icon* get_icon(std::int16_t slot);

    enum Buttons {
        BT_TAB_EQUIP,
        BT_TAB_USE,
        BT_TAB_ETC,
        BT_TAB_SETUP,
        BT_TAB_CASH,
        BT_DROPMESO,
        BT_POINTS,
        BT_GATHER,
        BT_SORT,
        BT_EXPAND,
        BT_ITEMPOT,
        BT_UPGRADE,
        BT_MAGNIFY,
        BT_BITCASE
    };

    const Inventory& inventory;

    Animation new_item_slot;
    Animation new_item_tab;
    Texture projectile;
    Text meso_label;
    Slider slider;

    std::unordered_map<std::int16_t, std::unique_ptr<Icon>> icons;

    InventoryType::Id tab;
    std::pair<std::int16_t, std::int16_t> slot_range;
    InventoryType::Id new_tab;
    std::int16_t new_slot;
};
} // namespace jrc

```

`IO/UITypes/UIKeyConfig.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIKeyConfig.h"

#include "../../Character/Inventory/InventoryType.h"
#include "../../Data/ItemData.h"
#include "../../Data/SkillData.h"
#include "../Components/MapleButton.h"
#include "../KeyAction.h"
#include "../UI.h"
#include "UIItemInventory.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIKeyConfig::UIKeyConfig()
    : UIDragElement<Configuration::PositionOf::KEY_CONFIG>{{622, 20}}
{
    nl::node source = nl::nx::ui["UIWindow2.img"]["KeyConfig"];

    sprites.emplace_back(source["backgrnd"]);
    sprites.emplace_back(source["backgrnd2"]);
    sprites.emplace_back(source["backgrnd3"]);

    buttons[BT_CANCEL] = std::make_unique<MapleButton>(source["BtCancel"]);
    buttons[BT_DEFAULT] = std::make_unique<MapleButton>(source["BtDefault"]);
    buttons[BT_DELETE] = std::make_unique<MapleButton>(source["BtDelete"]);
    buttons[BT_OK] = std::make_unique<MapleButton>(source["BtOK"]);
    buttons[BT_QUICKSLOT]
        = std::make_unique<MapleButton>(source["BtQuickSlot"]);

    nl::node icon_data = source["icon"];

    icons[KeyAction::Id::EQUIPMENT_TAB] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::EQUIPMENT_TAB),
        icon_data[0],
        -1);
    icons[KeyAction::Id::INVENTORY] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::INVENTORY), icon_data[1], -1);
    icons[KeyAction::Id::CHAR_STATS] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::CHAR_STATS),
        icon_data[2],
        -1);
    icons[KeyAction::Id::SKILL_TAB] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::SKILL_TAB), icon_data[3], -1);
    icons[KeyAction::Id::BUDDY_TAB] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::BUDDY_TAB), icon_data[4], -1);
    icons[KeyAction::Id::WORLD_MAP] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::WORLD_MAP), icon_data[5], -1);
    icons[KeyAction::Id::MESSENGER] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::MESSENGER), icon_data[6], -1);
    icons[KeyAction::Id::MINI_MAP] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::MINI_MAP), icon_data[7], -1);
    icons[KeyAction::Id::QUEST_LOG] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::QUEST_LOG), icon_data[8], -1);
    icons[KeyAction::Id::KEY_CONFIG] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::KEY_CONFIG),
        icon_data[9],
        -1);
    icons[KeyAction::Id::TO_ALL] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_ALL), icon_data[10], -1);
    icons[KeyAction::Id::WHISPER] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::WHISPER), icon_data[11], -1);
    icons[KeyAction::Id::TO_PARTY] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_PARTY), icon_data[12], -1);
    icons[KeyAction::Id::TO_FRIEND] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_FRIEND),
        icon_data[13],
        -1);
    icons[KeyAction::Id::MAIN_MENU] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::MAIN_MENU),
        icon_data[14],
        -1);
    icons[KeyAction::Id::TOGGLE_QUICK_SLOT] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TOGGLE_QUICK_SLOT),
        icon_data[15],
        -1);
    icons[KeyAction::Id::CHAT_WINDOW] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::CHAT_WINDOW),
        icon_data[16],
        -1);
    icons[KeyAction::Id::GUILD_TAB] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::GUILD_TAB),
        icon_data[17],
        -1);
    icons[KeyAction::Id::TO_GUILD] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_GUILD), icon_data[18], -1);
    icons[KeyAction::Id::PARTY_TAB] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::PARTY_TAB),
        icon_data[19],
        -1);
    icons[KeyAction::Id::HELPER] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::HELPER), icon_data[20], -1);
    icons[KeyAction::Id::MONSTER_BOOK] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::MONSTER_BOOK),
        icon_data[21],
        -1);
    icons[KeyAction::Id::CASH_SHOP] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::CASH_SHOP),
        icon_data[22],
        -1);
    icons[KeyAction::Id::TO_ALLIANCE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_ALLIANCE),
        icon_data[23],
        -1);
    icons[KeyAction::Id::PARTY_SEARCH] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::PARTY_SEARCH),
        icon_data[24],
        -1);
    icons[KeyAction::Id::TO_TALK] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_TALK), icon_data[25], -1);
    icons[KeyAction::Id::MEDALS] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::MEDALS), icon_data[26], -1);
    icons[KeyAction::Id::BOSS] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::BOSS), icon_data[27], -1);
    icons[KeyAction::Id::TO_EXPED] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_EXPED), icon_data[28], -1);
    icons[KeyAction::Id::PROFESSION] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::PROFESSION),
        icon_data[29],
        -1);
    icons[KeyAction::Id::ITEM_POT] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::ITEM_POT), icon_data[30], -1);
    icons[KeyAction::Id::EVENT] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::EVENT), icon_data[31], -1);
    icons[KeyAction::Id::LEVEL_UP_GUIDE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::LEVEL_UP_GUIDE),
        icon_data[32],
        -1);
    icons[KeyAction::Id::SILENT_CRUSADE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::SILENT_CRUSADE),
        icon_data[33],
        -1);
    icons[KeyAction::Id::BITS] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::BITS), icon_data[34], -1);
    icons[KeyAction::Id::CHECK_NEW_TALK] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::CHECK_NEW_TALK),
        icon_data[35],
        -1);
    icons[KeyAction::Id::TOTS_KNOWHOW] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TOTS_KNOWHOW),
        icon_data[36],
        -1);
    icons[KeyAction::Id::EPISODE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::EPISODE), icon_data[37], -1);
    // icons[KeyAction::Id::HELPER_2] =
    //     std::make_unique<Icon>(
    //         std::make_unique<KeyIcon>(KeyAction::Id::HELPER_2),
    //         icon_data["38_"],
    //         -1);
    icons[KeyAction::Id::GUIDE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::GUIDE), icon_data[39], -1);
    icons[KeyAction::Id::TO_SPOUSE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::TO_SPOUSE),
        icon_data[40],
        -1);
    icons[KeyAction::Id::EQUIP_ENHANCE] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::EQUIP_ENHANCE),
        icon_data[41],
        -1);
    icons[KeyAction::Id::PICK_UP] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::PICK_UP), icon_data[50], -1);
    icons[KeyAction::Id::SIT] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::SIT), icon_data[51], -1);
    icons[KeyAction::Id::ATTACK] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::ATTACK), icon_data[52], -1);
    icons[KeyAction::Id::JUMP] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::JUMP), icon_data[53], -1);
    icons[KeyAction::Id::NPC_CHAT] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::NPC_CHAT), icon_data[54], -1);
    icons[KeyAction::Id::FACE_1] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_1), icon_data[100], -1);
    icons[KeyAction::Id::FACE_2] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_2), icon_data[101], -1);
    icons[KeyAction::Id::FACE_3] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_3), icon_data[102], -1);
    icons[KeyAction::Id::FACE_4] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_4), icon_data[103], -1);
    icons[KeyAction::Id::FACE_5] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_5), icon_data[104], -1);
    icons[KeyAction::Id::FACE_6] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_6), icon_data[105], -1);
    icons[KeyAction::Id::FACE_7] = std::make_unique<Icon>(
        std::make_unique<KeyIcon>(KeyAction::Id::FACE_7), icon_data[106], -1);

    dimension = {622, 374};
    reload_mappings();
    active = true;
}

void UIKeyConfig::draw(float alpha) const
{
    UIElement::draw(alpha);

    for (auto [slot_id, action_id] : slot_mappings.left) {
        if (auto icon_iter = icons.find(action_id); icon_iter != icons.end()) {
            icon_iter->second->draw(position
                                    + slot_pos({slot_id, SlotType::KEY_SLOT}));
        }
    }

    for (auto [slot_id, action_id] : palette_slots.left) {
        if (auto icon_iter = icons.find(action_id); icon_iter != icons.end()) {
            icon_iter->second->draw(
                position + slot_pos({slot_id, SlotType::PALETTE_SLOT}));
        }
    }
}

void UIKeyConfig::toggle_active()
{
    UIElement::toggle_active();
}

void UIKeyConfig::double_click(Point<std::int16_t>)
{
}

void UIKeyConfig::send_icon(const Icon& icon, Point<std::int16_t> cursor_pos)
{
    /*
    Console::get().print("sending icon at "
                         + (cursor_pos - position).to_string());
    */
    if (auto slot = slot_by_position(cursor_pos); slot) {
        /*
        std::cout << "icon.get_action_id(): " << icon.get_action_id() << '\n'
                  << std::flush;
        */
        adjust_mapping(*slot, icon.get_action_id());
    }

    dragged_from = {0, SlotType::OTHER_SLOT};
}

Cursor::State UIKeyConfig::send_cursor(bool pressed,
                                       Point<std::int16_t> cursor_pos)
{
    Cursor::State drag_state = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        return drag_state;
    }

    auto slot_ = slot_by_position(cursor_pos);
    if (!slot_) {
        return Cursor::IDLE;
    }
    auto slot = *slot_;

    if (slot.second == SlotType::KEY_SLOT) {
        if (auto action_iter = slot_mappings.left.find(slot.first);
            action_iter != slot_mappings.left.end()) {
            if (auto icon_ptr = get_icon(action_iter->second); icon_ptr) {
                if (pressed) {
                    icon_ptr->start_drag(cursor_pos - position
                                         - slot_pos(slot));
                    UI::get().drag_icon(icon_ptr.get());

                    dragged_from = slot;

                    return Cursor::GRABBING;
                } else {
                    return Cursor::CAN_GRAB;
                }
            }
        }
    } else {
        if (auto action_iter = palette_slots.left.find(slot.first);
            action_iter != palette_slots.left.end()) {
            if (auto icon_ptr = get_icon(action_iter->second); icon_ptr) {
                if (pressed) {
                    icon_ptr->start_drag(cursor_pos - position
                                         - slot_pos(slot));
                    UI::get().drag_icon(icon_ptr.get());

                    dragged_from = slot;

                    return Cursor::GRABBING;
                } else {
                    return Cursor::CAN_GRAB;
                }
            }
        }
    }

    return Cursor::IDLE;
}

Button::State UIKeyConfig::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case Buttons::BT_DEFAULT:
        UI::get().emplace<UIKeyConfigNotice>(
            UIKeyConfigNotice::RESET_TO_DEFAULT,
            [this](bool ok) {
                if (ok) {
                    reset_to_default();
                }
            },
            position,
            dimension,
            true);
        return Button::NORMAL;
    case Buttons::BT_CANCEL:
        if (dirty) {
            UI::get().emplace<UIKeyConfigNotice>(
                UIKeyConfigNotice::SAVE_CHANGES,
                [this](bool yes) {
                    if (yes) {
                        commit_mappings();
                    }
                    UIElement::deactivate();
                    reload_mappings();
                },
                position,
                dimension,
                false);
        } else {
            UIElement::deactivate();
        }
        return Button::NORMAL;
    case Buttons::BT_OK:
        commit_mappings();
        UIElement::deactivate();
        return Button::NORMAL;
    case Buttons::BT_DELETE:
        UI::get().emplace<UIKeyConfigNotice>(
            UIKeyConfigNotice::CLEAR_ALL_SHORTCUTS,
            [this](bool yes) {
                if (yes) {
                    clear_mappings();
                }
            },
            position,
            dimension,
            false);
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

void UIKeyConfig::reload_mappings() noexcept
{
    clear();

    for (auto [slot_id, mapping] : UI::get().get_keyboard().get_maplekeys()) {
        std::int32_t action_id = mapping.action;

        slot_mappings.insert({slot_id, action_id});
        get_icon(action_id);
    }

    refresh_palette();

    dirty = false;
}

void UIKeyConfig::reset_to_default() noexcept
{
    clear();

    for (auto [key_id, action_id] : DEFAULT_MAPPINGS) {
        slot_mappings.insert({key_id, action_id});
    }

    refresh_palette();

    dirty = true;
}

void UIKeyConfig::clear_mappings() noexcept
{
    std::uint8_t first_empty = 0;
    for (auto [_, action_id] : slot_mappings.left) {
        if (!KeyAction::is_key_action(action_id)) {
            continue;
        }

        if (icons.count(action_id)) {
            auto palette_iter = palette_slots.left.find(first_empty);
            while (first_empty < PALETTE_COLS * PALETTE_ROWS
                   && palette_iter != palette_slots.left.end()) {
                ++first_empty;
                palette_iter = palette_slots.left.find(first_empty);
            }
            if (first_empty >= PALETTE_COLS * PALETTE_ROWS) {
                break;
            }

            palette_slots.insert({first_empty, action_id});
            ++first_empty;
        }
    }

    slot_mappings.left.clear();

    dirty = true;
}

bool UIKeyConfig::commit_mappings() noexcept
{
    auto& keyboard = UI::get().get_keyboard_mut();
    keyboard.clear_mappings();

    for (auto [key, action] : slot_mappings.left) {
        keyboard.assign(key, KeyType::type_by_action(action), action);
    }

    dirty = false;

    return keyboard.send_mappings();
}

void UIKeyConfig::clear() noexcept
{
    slot_mappings.left.clear();
    palette_slots.left.clear();
}

void UIKeyConfig::refresh_palette() noexcept
{
    std::uint8_t i = 0;
    for (const auto& [action_id, _] : icons) {
        if (KeyAction::is_key_action(action_id)
            && !slot_mappings.right.count(action_id)) {
            bimap::assign(palette_slots, i, action_id);
            ++i;
        }
    }
}

void UIKeyConfig::adjust_mapping(Slot slot, std::int32_t action) noexcept
{
    auto [from_slot, from_type] = dragged_from;
    auto [to_slot, to_type] = slot;

    if (to_type == SlotType::OTHER_SLOT) {
        return;
    }

    if (from_type == SlotType::OTHER_SLOT) {
        if (to_type == SlotType::KEY_SLOT) {
            if (auto to_iter = slot_mappings.left.find(to_slot);
                to_iter != slot_mappings.left.end()) {
                if (KeyAction::is_key_action(to_iter->second)) {
                    if (auto empty_palette = empty_palette_slot();
                        empty_palette) {
                        bimap::assign(
                            palette_slots, *empty_palette, to_iter->second);
                    }
                }

                slot_mappings.left.replace_data(to_iter, action);
            } else {
                bimap::assign(slot_mappings, to_slot, action);
            }

            add_icon(action);
            dirty = true;
        }

        return;
    }

    bool is_to_key = to_type == SlotType::KEY_SLOT;
    bool is_from_key = from_type == SlotType::KEY_SLOT;

    auto& to_map = is_to_key ? slot_mappings : palette_slots;
    auto& from_map = is_from_key ? slot_mappings : palette_slots;

    if (is_from_key == is_to_key) {
        if (auto to_iter = to_map.left.find(to_slot);
            to_iter != to_map.left.end()) {
            std::int32_t temp = to_iter->second;
            to_map.left.replace_data(to_iter, action);
            bimap::assign(to_map, from_slot, temp);
        } else {
            bimap::assign(to_map, to_slot, action);
        }
    } else {
        if (auto to_iter = to_map.left.find(to_slot);
            to_iter != to_map.left.end()) {
            std::int32_t temp = to_iter->second;
            if (is_to_key || KeyAction::is_key_action(action)) {
                to_map.left.replace_data(to_iter, action);
                dirty = true;
            }
            if (is_from_key || KeyAction::is_key_action(temp)) {
                bimap::assign(from_map, from_slot, temp);
                dirty = true;
            }

            return;
        } else {
            from_map.left.erase(from_slot);
            if (is_to_key || KeyAction::is_key_action(action)) {
                bimap::assign(to_map, to_slot, action);
            }
        }
    }

    dirty = true;
}

std::optional<UIKeyConfig::Slot>
UIKeyConfig::slot_by_position(Point<std::int16_t> cursor_pos_) const noexcept
{
    auto cursor_pos = cursor_pos_ - position;

    if (PALETTE_AREA.contains(cursor_pos)) {
        auto normalized = cursor_pos - PALETTE_POSITION;
        auto col = normalized.x() / PALETTE_STRIDE;
        auto row = normalized.y() / PALETTE_STRIDE;

        return {{row * PALETTE_COLS + col, SlotType::PALETTE_SLOT}};
    }

    // Special-casing the top-left 32x32 rect since [0, 0] is the default
    // "position" for non-existent slots.
    if (Rectangle<std::int16_t>{{0, 0}, {32, 32}}.contains(cursor_pos)) {
        return {};
    }

    std::uint8_t slot_ix = 0;
    for (auto slot_pos : SLOT_POSITIONS) {
        Rectangle<std::int16_t> slot_rect{slot_pos, slot_pos + 32};
        if (slot_rect.contains(cursor_pos)) {
            return {{slot_ix, SlotType::KEY_SLOT}};
        }

        ++slot_ix;
    }

    return {};
}

std::optional<std::uint8_t> UIKeyConfig::empty_palette_slot() const noexcept
{
    std::uint8_t first_empty = 0;
    auto palette_iter = palette_slots.left.find(first_empty);
    while (first_empty < PALETTE_COLS * PALETTE_ROWS
           && palette_iter != palette_slots.left.end()) {
        ++first_empty;
        palette_iter = palette_slots.left.find(first_empty);
    }

    if (first_empty < PALETTE_COLS * PALETTE_ROWS) {
        return {first_empty};
    } else {
        return {};
    }
}

nullable_ptr<Icon> UIKeyConfig::get_icon(KeyAction::Id action_id) noexcept
{
    if (auto icon_iter = icons.find(action_id); icon_iter != icons.end()) {
        return icon_iter->second.get();
    }

    return nullptr;
}

nullable_ptr<Icon> UIKeyConfig::get_icon(std::int32_t action_id) noexcept
{
    if (auto icon_iter = icons.find(action_id); icon_iter != icons.end()) {
        return icon_iter->second.get();
    }

    return add_icon(action_id);
}

nullable_ptr<Icon> UIKeyConfig::add_icon(std::int32_t action_id) noexcept
{
    if (KeyAction::is_skill(action_id)) {
        return (icons[action_id] = std::make_unique<Icon>(
                    std::make_unique<SkillIcon>(action_id),
                    SkillData::get(-action_id).get_icon(SkillData::NORMAL),
                    -1))
            .get();
    } else if (KeyAction::is_item(action_id)) {
        return (icons[action_id] = std::make_unique<Icon>(
                    std::make_unique<UIItemInventory::ItemIcon>(
                        action_id,
                        InventoryType::by_item_id(action_id),
                        Equipslot::Id::NONE,
                        0),
                    ItemData::get(action_id).get_icon(false),
                    -1))
            .get();
    }

    return nullptr;
}

Point<std::int16_t> UIKeyConfig::slot_pos(Slot slot) noexcept
{
    switch (auto [s, key_slot] = slot; key_slot) {
    case SlotType::KEY_SLOT:
        return SLOT_POSITIONS[s];
    case SlotType::PALETTE_SLOT:
        return PALETTE_POSITION
               + Point<std::int16_t>{s % PALETTE_COLS * PALETTE_STRIDE,
                                     s / PALETTE_COLS * PALETTE_STRIDE};
    default:
        return {};
    }
}

UIKeyConfig::KeyIcon::KeyIcon(KeyAction::Id a_id) noexcept : action_id{a_id}
{
}

std::int32_t UIKeyConfig::KeyIcon::get_action_id() const noexcept
{
    return action_id;
}

UIKeyConfig::SkillIcon::SkillIcon(std::int32_t a_id) noexcept : action_id{a_id}
{
}

std::int32_t UIKeyConfig::SkillIcon::get_action_id() const noexcept
{
    return action_id;
}

UIKeyConfig::UIKeyConfigNotice::UIKeyConfigNotice(
    NoticeType type,
    std::function<void(bool)> yn_handler,
    Point<std::int16_t> parent_pos,
    Point<std::int16_t> parent_dim,
    bool ok_cancel)
    : yes_no_handler(yn_handler)
{
    nl::node src = nl::nx::ui["UIWindow2.img"]["KeyConfig"]["notice"];

    sprites.emplace_back(src[static_cast<std::uint16_t>(type)]);

    nl::node button_src = nl::nx::ui["Basic.img"];

    if (ok_cancel) {
        buttons[OK] = std::make_unique<MapleButton>(
            button_src["BtOK4"], Point<std::int16_t>{152, 53});
        buttons[CANCEL] = std::make_unique<MapleButton>(
            button_src["BtCancel4"], Point<std::int16_t>{202, 53});
    } else {
        buttons[OK] = std::make_unique<MapleButton>(
            button_src["BtYes2"], Point<std::int16_t>{145, 52});
        buttons[CANCEL] = std::make_unique<MapleButton>(
            button_src["BtNo2"], Point<std::int16_t>{200, 52});
    }

    dimension = {260, 84};
    // Centering the child notice on top of the parent.
    position = parent_pos + parent_dim / 2 - dimension / 2;

    active = true;
}

void UIKeyConfig::UIKeyConfigNotice::draw(float inter) const
{
    UIElement::draw(inter);
}

Button::State
UIKeyConfig::UIKeyConfigNotice::button_pressed(std::uint16_t button_id)
{
    switch (static_cast<ButtonType>(button_id)) {
    case ButtonType::OK:
        yes_no_handler(true);
        break;
    case ButtonType::CANCEL:
        yes_no_handler(false);
        break;
    }

    active = false;

    return Button::PRESSED;
}
} // namespace jrc

```

`IO/UITypes/UIKeyConfig.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "../../Util/Misc.h"
#include "../Components/Icon.h"
#include "../Keyboard.h"
#include "../UIDragElement.h"
#include "UINotice.h"

#include <algorithm>

namespace jrc
{
//! The in-game keybinding configuration UI.
class UIKeyConfig : public UIDragElement<Configuration::PositionOf::KEY_CONFIG>
{
public:
    static constexpr const Type TYPE = KEY_CONFIG;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    enum class SlotType : std::uint8_t { OTHER_SLOT, PALETTE_SLOT, KEY_SLOT };

    using Slot = std::pair<std::uint8_t, SlotType>;

    UIKeyConfig();

    void draw(float inter) const override;

    void toggle_active() override;
    void double_click(Point<std::int16_t> cursor_pos) override;
    void send_icon(const Icon& icon, Point<std::int16_t> cursor_pos) override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursor_pos) override;

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void reload_mappings() noexcept;
    void reset_to_default() noexcept;
    void clear_mappings() noexcept;
    bool commit_mappings() noexcept;
    void clear() noexcept;
    void refresh_palette() noexcept;
    void adjust_mapping(Slot slot, std::int32_t action) noexcept;
    std::optional<Slot> slot_by_position(Point<std::int16_t> p) const noexcept;
    std::optional<std::uint8_t> empty_palette_slot() const noexcept;
    nullable_ptr<Icon> get_icon(KeyAction::Id action_id) noexcept;
    nullable_ptr<Icon> get_icon(std::int32_t action_id) noexcept;
    nullable_ptr<Icon> add_icon(std::int32_t action_id) noexcept;
    static Point<std::int16_t> slot_pos(Slot slot) noexcept;

    class KeyIcon : public Icon::Type
    {
    public:
        KeyIcon(KeyAction::Id action_id) noexcept;

        void drop_on_stage() const override
        {
        }
        void drop_on_equips(Equipslot::Id) const override
        {
        }
        void drop_on_items(InventoryType::Id,
                           Equipslot::Id,
                           std::int16_t,
                           bool) const override
        {
        }
        std::int32_t get_action_id() const noexcept override;

    private:
        KeyAction::Id action_id;
    };

    //! Dummy `Icon::Type` for skills to avoid using the heavier-weight
    //! `UISkillBook::SkillIcon`.
    class SkillIcon : public Icon::Type
    {
    public:
        SkillIcon(std::int32_t action_id) noexcept;

        void drop_on_stage() const override
        {
        }
        void drop_on_equips(Equipslot::Id) const override
        {
        }
        void drop_on_items(InventoryType::Id,
                           Equipslot::Id,
                           std::int16_t,
                           bool) const override
        {
        }
        std::int32_t get_action_id() const noexcept override;

    private:
        std::int32_t action_id;
    };

    enum Buttons : std::uint16_t {
        BT_CANCEL,
        BT_DEFAULT,
        BT_DELETE,
        BT_OK,
        BT_QUICKSLOT
    };

    bimap::unordered_bimap<std::uint8_t, std::int32_t> slot_mappings;
    bimap::unordered_bimap<std::uint8_t, std::int32_t> palette_slots;
    std::unordered_map<std::int32_t, std::unique_ptr<Icon>> icons;
    Slot dragged_from;
    bool dirty;

    class UIKeyConfigNotice : public UIElement
    {
    public:
        static constexpr const Type TYPE = NOTICE;
        static constexpr const bool FOCUSED = true;
        static constexpr const bool TOGGLED = false;

        enum NoticeType : std::uint16_t {
            RESET_TO_DEFAULT,
            CLEAR_ALL_SHORTCUTS,
            SAVE_CHANGES
        };

        UIKeyConfigNotice(NoticeType type,
                          std::function<void(bool)> yn_handler,
                          Point<std::int16_t> parent_pos,
                          Point<std::int16_t> parent_dim,
                          bool ok_cancel);

        void draw(float inter) const override;

    protected:
        Button::State button_pressed(std::uint16_t button_id) override;

    private:
        std::function<void(bool)> yes_no_handler;

        enum ButtonType : std::uint16_t { OK, CANCEL };
    };

    //! The `n`th element of this array represents the position (relative to
    //! the position of the `UIKeyConfig`) of the key slot for the key with
    //! an ID of `n`.
    static constexpr const std::array<Point<std::int16_t>, 90> SLOT_POSITIONS{
        {{0, 0},     {0, 0},     {351, 65},  {45, 65},   {79, 65},
         {113, 65},  {147, 65},  {181, 65},  {215, 65},  {249, 65},
         {283, 65},  {317, 65},  {385, 65},  {419, 65},  {0, 0},
         {0, 0},     {61, 99},   {95, 99},   {129, 99},  {163, 99},
         {197, 99},  {231, 99},  {265, 99},  {299, 99},  {333, 99},
         {367, 99},  {401, 99},  {435, 99},  {0, 0},     {19, 198},
         {78, 132},  {112, 132}, {146, 132}, {180, 132}, {214, 132},
         {248, 132}, {282, 132}, {316, 132}, {350, 132}, {384, 132},
         {418, 132}, {11, 65},   {36, 165},  {469, 99},  {95, 165},
         {129, 165}, {163, 165}, {197, 165}, {231, 165}, {265, 165},
         {299, 165}, {333, 165}, {367, 165}, {0, 0},     {0, 0},
         {0, 0},     {120, 198}, {231, 198}, {0, 0},     {79, 28},
         {113, 28},  {147, 28},  {181, 28},  {223, 28},  {257, 28},
         {291, 28},  {325, 28},  {367, 28},  {401, 28},  {435, 28},
         {469, 28},  {545, 65},  {0, 0},     {579, 65},  {0, 0},
         {0, 0},     {0, 0},     {0, 0},     {0, 0},     {545, 99},
         {0, 0},     {579, 99},  {511, 65},  {511, 99},  {0, 0},
         {0, 0},     {0, 0},     {0, 0},     {0, 0},     {0, 0}}};

    static constexpr const std::int16_t PALETTE_ROWS = 3, PALETTE_COLS = 18;
    //! The position (relative to the position of the `UIKeyConfig`) of the
    //! upper-left-most palette slot.
    static constexpr const Point<std::int16_t> PALETTE_POSITION{5, 267};
    //! x-axis and y-axis spacing (i.e., square) between palette slots.
    static constexpr const std::int16_t PALETTE_STRIDE = 34;
    //! Full area that the palette takes up.
    static constexpr const Rectangle<std::int16_t> PALETTE_AREA{
        PALETTE_POSITION,
        PALETTE_POSITION
            + Point<std::int16_t>{PALETTE_STRIDE * PALETTE_COLS,
                                  PALETTE_STRIDE* PALETTE_ROWS}};

    //! Each element of this array represents a mapping from key ID (on the
    //! left) to action ID (on the right). This particular set of mappings
    //! is the default for GMS v83.
    static constexpr const std::array<std::pair<std::uint8_t, std::int32_t>,
                                      40>
        DEFAULT_MAPPINGS{
            {{18, 0},   {65, 106}, {2, 10},   {23, 1},   {3, 12},   {4, 13},
             {5, 18},   {6, 24},   {16, 8},   {17, 5},   {19, 4},   {25, 19},
             {26, 14},  {27, 15},  {31, 2},   {34, 17},  {35, 11},  {37, 3},
             {38, 20},  {40, 16},  {43, 9},   {44, 50},  {45, 51},  {46, 6},
             {50, 7},   {56, 53},  {59, 100}, {60, 101}, {61, 102}, {62, 103},
             {63, 104}, {64, 105}, {57, 54},  {48, 22},  {29, 52},  {7, 21},
             {24, 25},  {33, 26},  {41, 23},  {39, 27}}};
};
} // namespace jrc

```

`IO/UITypes/UILogin.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UILogin.h"

#include "../../Audio/Audio.h"
#include "../../Configuration.h"
#include "../../Constants.h"
#include "../../Graphics/Sprite.h"
#include "../../Net/Packets/LoginPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "UILoginWait.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UILogin::UILogin()
{
    if (auto mus_err = Music::play("BgmUI.img/Title"); mus_err) {
        Console::get().print("Error playing music BgmUI.img/Title");
    }

    nl::node title = nl::nx::ui["Login.img"]["Title"];
    nl::node common = nl::nx::ui["Login.img"]["Common"];

    sprites.emplace_back(nl::nx::map["Back"]["login.img"]["back"]["11"],
                         Point<std::int16_t>{370, 300});
    // sprites.emplace_back(title["35"], Point<std::int16_t>{410, 260});
    sprites.emplace_back(nl::nx::map["Obj"]["login.img"]["Title"]["logo"]["0"],
                         Point<std::int16_t>{410, 130});
    sprites.emplace_back(title["signboard"], Point<std::int16_t>{410, 300});
    sprites.emplace_back(common["frame"], Point<std::int16_t>{400, 290});

    // I prefer the title without this.
    /*auto effectpos = Point<std::int16_t>{420, -50};
    node effect = title["effect"];
    for (node sub : effect)
    {
        auto sprite = Sprite(sub, DrawArgument(effectpos, true, 0.5f));
        sprites.push_back(sprite);
    }*/

    buttons[BT_LOGIN] = std::make_unique<MapleButton>(
        title["BtLogin"], Point<std::int16_t>{475, 248});
    buttons[BT_REGISTER] = std::make_unique<MapleButton>(
        title["BtNew"], Point<std::int16_t>{309, 320});
    buttons[BT_HOME_PAGE] = std::make_unique<MapleButton>(
        title["BtHomePage"], Point<std::int16_t>{382, 320});
    buttons[BT_PASS_LOST] = std::make_unique<MapleButton>(
        title["BtPasswdLost"], Point<std::int16_t>{470, 300});
    buttons[BT_QUIT] = std::make_unique<MapleButton>(
        title["BtQuit"], Point<std::int16_t>{455, 320});
    buttons[BT_ID_LOST] = std::make_unique<MapleButton>(
        title["BtLoginIDLost"], Point<std::int16_t>{395, 300});
    buttons[BT_SAVE_ID] = std::make_unique<MapleButton>(
        title["BtLoginIDSave"], Point<std::int16_t>{325, 300});

    checkbox[false] = title["check"]["0"];
    checkbox[true] = title["check"]["1"];

    account
        = {Text::A13M, Text::LEFT, Text::WHITE, {{315, 249}, {465, 273}}, 12};
    account.set_key_callback(KeyAction::TAB, [this] {
        account.set_state(Textfield::NORMAL);
        password.set_state(Textfield::FOCUSED);
    });
    account.set_enter_callback([this](const std::string&) { login(); });
    account_bg = title["ID"];

    password
        = {Text::A13M, Text::LEFT, Text::WHITE, {{315, 275}, {465, 299}}, 12};
    password.set_key_callback(KeyAction::TAB, [this] {
        password.set_state(Textfield::NORMAL);
        account.set_state(Textfield::FOCUSED);
    });
    password.set_enter_callback([this](const std::string&) { login(); });
    password.set_crypt_char('*');
    password_bg = title["PW"];

    save_id = Configuration::get().account.save_login;
    if (save_id) {
        account.change_text(
            std::string{Configuration::get().account.account_name});
        password.set_state(Textfield::FOCUSED);
    } else {
        account.set_state(Textfield::FOCUSED);
    }

    position = {0, 0};
    dimension = {Constants::VIEW_WIDTH, Constants::VIEW_HEIGHT};
    active = true;
}

void UILogin::draw(float alpha) const
{
    UIElement::draw(alpha);

    account.draw(position);
    password.draw(position);

    if (account.get_state() == Textfield::NORMAL && account.empty()) {
        account_bg.draw({position + Point<std::int16_t>{310, 249}});
    }

    if (password.get_state() == Textfield::NORMAL && password.empty()) {
        password_bg.draw({position + Point<std::int16_t>{310, 275}});
    }

    checkbox[save_id].draw({position + Point<std::int16_t>{313, 304}});
}

void UILogin::update()
{
    UIElement::update();

    account.update(position);
    password.update(position);
}

void UILogin::login()
{
    UI::get().disable();
    UI::get().emplace<UILoginWait>();

    account.set_state(Textfield::NORMAL);
    password.set_state(Textfield::NORMAL);

    LoginPacket{account.get_text(), password.get_text()}.dispatch();
}

Button::State UILogin::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_LOGIN:
        login();
        return Button::NORMAL;
    case BT_QUIT:
        UI::get().quit();
        return Button::PRESSED;
    case BT_SAVE_ID:
        save_id = !save_id;
        Configuration::get().account.save_login = save_id;
        return Button::MOUSE_OVER;
    default:
        return Button::PRESSED;
    }
}

Cursor::State UILogin::send_cursor(bool clicked,
                                   Point<std::int16_t> cursor_pos)
{
    if (Cursor::State new_state = account.send_cursor(cursor_pos, clicked)) {
        return new_state;
    }

    if (Cursor::State new_state = password.send_cursor(cursor_pos, clicked)) {
        return new_state;
    }

    return UIElement::send_cursor(clicked, cursor_pos);
}
} // namespace jrc

```

`IO/UITypes/UILogin.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/BoolPair.h"
#include "../Components/Textfield.h"
#include "../UIElement.h"

namespace jrc
{
class UILogin : public UIElement
{
public:
    static constexpr const Type TYPE = LOGIN;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = false;

    UILogin();

    void draw(float alpha) const override;
    void update() override;

    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> cursor_pos) override;

protected:
    Button::State button_pressed(std::uint16_t id) override;

private:
    void login();

    enum Buttons {
        BT_LOGIN,
        BT_REGISTER,
        BT_HOME_PAGE,
        BT_PASS_LOST,
        BT_ID_LOST,
        BT_SAVE_ID,
        BT_QUIT,
        NUM_BUTTONS
    };

    Textfield account;
    Textfield password;
    Texture account_bg;
    Texture password_bg;
    BoolPair<Texture> checkbox;

    bool save_id;
};
} // namespace jrc

```

`IO/UITypes/UILoginNotice.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UILoginNotice.h"

#include "../../Graphics/Sprite.h"
#include "../Components/MapleButton.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UILoginNotice::UILoginNotice(Message id)
{
    nl::node notice = nl::nx::ui["Login.img"]["Notice"];

    background = notice["backgrnd"][id == BLOCKED_ID ? "1" : "0"];
    text = {notice["text"][id], {17, 13}};

    buttons[BT_OK] = std::make_unique<MapleButton>(
        notice["BtYes"], Point<std::int16_t>{100, 100});

    position = {292, 200};
    dimension = {362, 219};
    active = true;

    Console::get().print("conStructed");
}

void UILoginNotice::draw(float alpha) const
{
    Console::get().print("draWering");
    background.draw(position);
    text.draw(position, alpha);

    UIElement::draw(alpha);
}

Button::State UILoginNotice::button_pressed(std::uint16_t)
{
    active = false;
    return Button::PRESSED;
}
} // namespace jrc

```

`IO/UITypes/UILoginNotice.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Sprite.h"
#include "../../Graphics/Texture.h"
#include "../UIElement.h"

namespace jrc
{
class UILoginNotice : public UIElement
{
public:
    static constexpr const Type TYPE = LOGIN_NOTICE;
    static constexpr const bool FOCUSED = true;
    static constexpr const bool TOGGLED = false;

    enum Message : std::int8_t {
        VULGAR_NAME,
        DELETE_CHAR_ENTER_BIRTHDAY,
        WRONG_EMAIL,
        WRONG_PASSWORD,
        INCORRECT_EMAIL,
        NAME_IN_USE,
        NAME_OK,
        RETURN_TO_FIRST_PAGE,
        NAME_IN_USE2,
        FULL_CHARACTER_SLOTS,
        ILLEGAL_NAME,
        BIRTHDAY_INCORRECT,
        PRESS_CHECK_BUTTON,
        DELETE_CONFIRMATION,
        MATURE_CHANNEL,
        TROUBLE_LOGGING_IN,
        BLOCKED_ID,
        ALREADY_LOGGED_IN,
        UNKNOWN_ERROR,
        TOO_MANY_REQUESTS,
        NOT_REGISTERED,
        UNABLE_TO_LOGIN_WITH_IP,
        UNABLE_TO_LOGIN,
        UNABLE_TO_CONNECT,
        AN_ERROR_OCCURED,
        AN_ERROR_OCCURED_DETAILED,
        CANNOT_ACCESS_ACCOUNT,
        WRONG_GATEWAY,
        INCORRECT_LOGINID,
        INCORRECT_FORM,
        VERIFICATION_NOTICE_7,
        VERIFICATION_NOTICE_30,
        KOREAN,
        VERIFY_EMAIL,
        CANNOT_DELETE_GUILD_LEADER,
        SUSPICIOUS_PROGRAMS,
        POPULATION_TOO_HIGH,
        SELECT_A_CHANNEL,
        GAME_GUARD_UPDATED,
        CANNOT_DELETE_ENGAGED,
        PLEASE_SIGN_UP,
        PASSWORD_IS_INCORRECT,
        SECOND_PASSWORD_INCORRECT,
        TEMPORARY_IP_BAN,
        DISABLE_SAFETY_MEASURE,
        SECOND_PASSWORD_NOT_DIFFERENT,
        CANNOT_DELETE_ENGAGED2,
        KOREAN2,
        KOREAN3,
        KOREAN4,
        KOREAN5,
        KOREAN6,
        KOREAN7,
        CONFIRM_EXIT,
        CANNOT_DELETE_FAMILY_LEADER,
        CASH_ITEMS_CONFIRM_DELETION,
        KOREAN8,
        FAMILY_CONFIRM_DELETION,
        FAMILY_AND_CASH_ITEMS_CONFIRM_DELETION
    };

    UILoginNotice(Message message);

    void draw(float alpha) const override;

protected:
    Button::State button_pressed(std::uint16_t id) override;

private:
    enum Buttons { BT_OK };

    Texture background;
    Sprite text;
    bool saveid;
};
} // namespace jrc

```

`IO/UITypes/UILoginWait.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
//#pragma once
#include "UILoginWait.h"

#include "../../Graphics/Sprite.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UILoginWait::UILoginWait()
{
    nl::node src = nl::nx::ui["Login.img"]["Notice"]["Loading"];

    background = src["backgrnd"];
    circle = {src["circle"], {125, 72}};

    position = {292, 200};
    dimension = {282, 144};
    active = true;
}

void UILoginWait::draw(float alpha) const
{
    background.draw({position});
    circle.draw(position, alpha);
}

void UILoginWait::update()
{
    circle.update();
}
} // namespace jrc

```

`IO/UITypes/UILoginWait.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Sprite.h"
#include "../../Graphics/Texture.h"
#include "../UIElement.h"

namespace jrc
{
class UILoginWait : public UIElement
{
public:
    static constexpr const Type TYPE = LOGIN_WAIT;
    static constexpr const bool FOCUSED = true;
    static constexpr const bool TOGGLED = false;

    UILoginWait();

    void draw(float alpha) const override;
    void update() override;

private:
    Texture background;
    Sprite circle;
};
} // namespace jrc

```

`IO/UITypes/UINotice.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UINotice.h"

#include "../Components/MapleButton.h"
#include "nlnx/nx.hpp"

#include <limits>

namespace jrc
{
UINotice::UINotice(std::string&& q)
{
    nl::node src = nl::nx::ui["Basic.img"]["Notice6"];

    top = src["t"];
    center = src["c"];
    center_box = src["c_box"];
    box = src["box"];
    box2 = src["box2"];
    bottom = src["s"];
    bottom_box = src["s_box"];

    question = {Text::A11M, Text::CENTER, Text::DARKGREY, std::move(q), 200};

    height = question.height();
    dimension = {top.width(), top.height() + height + bottom.height()};
    position = {Constants::GAME_VIEW_WIDTH / 2 - dimension.x() / 2,
                Constants::GAME_VIEW_HEIGHT / 2 - dimension.y() / 2};
}

void UINotice::draw_notice(bool text_field) const
{
    Point<std::int16_t> start = position;

    top.draw(start);
    start.shift_y(top.height());
    center_box.draw(start);
    start.shift_y(center_box.height());

    Point<std::int16_t> text_pos = start;
    box.draw(DrawArgument(text_pos, Point<std::int16_t>{0, height}));
    start.shift_y(box.height() * (height / box.height()));
    box.draw(start);
    start.shift_y(box.height());
    question.draw(text_pos + Point<std::int16_t>{130, -3});

    if (text_field) {
        box2.draw(start);
        start.shift_y(box2.height());
    }

    box.draw(start);
    start.shift_y(box.height());
    bottom_box.draw(start);
}

std::int16_t UINotice::box2offset() const
{
    return top.height() + center_box.height()
           + box.height()
                 * (static_cast<std::int16_t>(1) + height / box.height());
}

UIYesNo::UIYesNo(std::string&& q, std::function<void(bool)> yh)
    : UINotice{std::move(q)}, yes_no_handler{yh}
{
    std::int16_t below_text = UINotice::box2offset();

    nl::node src = nl::nx::ui["Basic.img"];

    buttons[YES] = std::make_unique<MapleButton>(
        src["BtOK4"], Point<std::int16_t>{90, below_text + 1});
    buttons[NO] = std::make_unique<MapleButton>(
        src["BtCancel4"], Point<std::int16_t>{132, below_text + 1});
}

void UIYesNo::draw(float alpha) const
{
    UINotice::draw_notice(false);
    UIElement::draw(alpha);
}

Button::State UIYesNo::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case YES:
        yes_no_handler(true);
        break;
    case NO:
        yes_no_handler(false);
        break;
    }

    active = false;

    return Button::PRESSED;
}

UIEnterNumber::UIEnterNumber(std::string&& q,
                             std::function<void(std::int32_t)> n_handler,
                             std::int32_t mi,
                             std::int32_t ma,
                             std::int32_t de)
    : UINotice(std::move(q))
{
    num_handler = n_handler;
    min = mi;
    max = ma;

    std::int16_t below_text = UINotice::box2offset();

    nl::node src = nl::nx::ui["Basic.img"];

    buttons[OK] = std::make_unique<MapleButton>(
        src["BtOK4"], Point<std::int16_t>{90, below_text + 21});
    buttons[CANCEL] = std::make_unique<MapleButton>(
        src["BtCancel4"], Point<std::int16_t>{132, below_text + 21});

    Rectangle<std::int16_t> area{26, 232, below_text, below_text + 20};
    num_field = {Text::A11M, Text::LEFT, Text::LIGHTGREY, area, 9};
    num_field.set_state(Textfield::FOCUSED);
    num_field.change_text(std::to_string(de));
    num_field.set_enter_callback(
        [this](const std::string& num_str) { handle_string(num_str); });
}

void UIEnterNumber::draw(float alpha) const
{
    UINotice::draw_notice(true);
    UIElement::draw(alpha);

    num_field.draw(position);
}

void UIEnterNumber::update()
{
    UIElement::update();

    num_field.update(position);
}

Cursor::State UIEnterNumber::send_cursor(bool clicked,
                                         Point<std::int16_t> cursor_pos)
{
    if (num_field.get_state() == Textfield::NORMAL) {
        Cursor::State n_state = num_field.send_cursor(cursor_pos, clicked);
        if (n_state != Cursor::IDLE) {
            return n_state;
        }
    }
    return UIElement::send_cursor(clicked, cursor_pos);
}

Button::State UIEnterNumber::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case OK:
        handle_string(num_field.get_text());
        break;
    }

    active = false;

    return Button::PRESSED;
}

void UIEnterNumber::handle_string(const std::string& num_str)
{
    if (!num_str.empty()) {
        const auto num = [&num_str] {
            try {
                return std::stoi(num_str);
            } catch (const std::logic_error&) {
            }
            return std::numeric_limits<std::int32_t>::lowest();
        }();

        if (num >= min && num <= max) {
            num_handler(num);
            active = false;
        }
    }

    buttons[OK]->set_state(Button::NORMAL);
}
} // namespace jrc

```

`IO/UITypes/UINotice.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../Components/Textfield.h"
#include "../UIElement.h"

#include <functional>

namespace jrc
{
class UINotice : public UIElement
{
public:
    static constexpr const Type TYPE = NOTICE;
    static constexpr const bool FOCUSED = true;
    static constexpr const bool TOGGLED = false;

protected:
    UINotice(std::string&& question);

    void draw_notice(bool text_field) const;

    std::int16_t box2offset() const;

private:
    Texture top;
    Texture center;
    Texture center_box;
    Texture box;
    Texture box2;
    Texture bottom;
    Texture bottom_box;
    Text question;
    std::int16_t height;
};

class UIYesNo : public UINotice
{
public:
    UIYesNo(std::string&& question,
            std::function<void(bool yes)> yes_no_handler);

    void draw(float alpha) const override;

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    enum Buttons : std::int16_t { YES, NO };

    std::function<void(bool yes)> yes_no_handler;
};

class UIEnterNumber : public UINotice
{
public:
    UIEnterNumber(std::string&& question,
                  std::function<void(std::int32_t number)> n_handler,
                  std::int32_t min,
                  std::int32_t max,
                  std::int32_t def);

    void draw(float alpha) const override;
    void update() override;

    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursor_pos) override;

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void handle_string(const std::string& num_str);

    enum Buttons : std::int16_t { OK, CANCEL };

    std::function<void(std::int32_t number)> num_handler;
    Textfield num_field;
    std::int32_t min;
    std::int32_t max;
};
} // namespace jrc

```

`IO/UITypes/UINpcTalk.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UINpcTalk.h"

#include "../../Net/Packets/NpcInteractionPackets.h"
#include "../Components/MapleButton.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

namespace jrc
{
UINpcTalk::UINpcTalk()
{
    nl::node src = nl::nx::ui["UIWindow2.img"]["UtilDlgEx"];

    top = src["t"];
    fill = src["c"];
    bottom = src["s"];
    nametag = src["bar"];

    buttons[OK] = std::make_unique<MapleButton>(src["BtOK"]);
    buttons[NEXT] = std::make_unique<MapleButton>(src["BtNext"]);
    buttons[PREV] = std::make_unique<MapleButton>(src["BtPrev"]);
    buttons[END] = std::make_unique<MapleButton>(src["BtClose"]);
    buttons[YES] = std::make_unique<MapleButton>(src["BtYes"]);
    buttons[NO] = std::make_unique<MapleButton>(src["BtNo"]);

    active = false;
}

void UINpcTalk::draw(float inter) const
{
    Point<std::int16_t> drawpos = position;
    top.draw(drawpos);
    drawpos.shift_y(top.height());
    fill.draw({drawpos, Point<std::int16_t>(0, vtile) * fill.height()});
    drawpos.shift_y(vtile * fill.height());
    bottom.draw(drawpos);

    UIElement::draw(inter);

    speaker.draw({position + Point<std::int16_t>(80, 100), true});
    nametag.draw(position + Point<std::int16_t>(25, 100));
    name.draw(position + Point<std::int16_t>(80, 99));
    text.draw(position
              + Point<std::int16_t>(
                    156, 16 + ((vtile * fill.height() - text.height()) / 2)));
}

Button::State UINpcTalk::button_pressed(std::uint16_t buttonid)
{
    switch (buttonid) {
    case END:
        NpcTalkMorePacket(type, 0).dispatch();
        active = false;
        break;
    }
    return Button::PRESSED;
}

void UINpcTalk::change_text(std::int32_t npc_id,
                            std::int8_t msg_type,
                            std::int16_t,
                            std::int8_t speaker_byte,
                            std::string&& tx)
{
    text = {Text::A12M, Text::LEFT, Text::DARKGREY, std::move(tx), 320};

    if (speaker_byte == 0) {
        std::string str_id = std::to_string(npc_id);
        name = {Text::A11M,
                Text::CENTER,
                Text::WHITE,
                nl::nx::string["Npc.img"][str_id]["name"]};

        str_id.insert(0, 7 - str_id.length(), '0');
        str_id += ".img";
        speaker = nl::nx::npc[str_id]["stand"]["0"];
    } else {
        speaker = {};
        name.change_text("");
    }

    vtile = 8;
    height = vtile * fill.height();

    for (auto& button : buttons) {
        button.second->set_active(false);
        button.second->set_state(Button::NORMAL);
    }
    buttons[END]->set_position({20, height + 48});
    buttons[END]->set_active(true);
    switch (msg_type) {
    case 0:
        buttons[OK]->set_position({220, height + 48});
        buttons[OK]->set_active(true);
        break;
    }
    type = msg_type;

    position = {400 - top.width() / 2, 240 - height / 2};
    dimension = {top.width(), height + 120};
}
} // namespace jrc

```

`IO/UITypes/UINpcTalk.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "../../Graphics/Texture.h"
#include "../UIElement.h"

namespace jrc
{
class UINpcTalk : public UIElement
{
public:
    static constexpr Type TYPE = NPC_TALK;
    static constexpr bool FOCUSED = false;
    static constexpr bool TOGGLED = true;

    UINpcTalk();

    void draw(float inter) const override;

    void change_text(std::int32_t npcid,
                     std::int8_t msgtype,
                     std::int16_t style,
                     std::int8_t speaker,
                     std::string&& text);

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    enum Buttons { OK, NEXT, PREV, END, YES, NO };

    Texture top;
    Texture fill;
    Texture bottom;
    Texture nametag;

    Text text;
    Texture speaker;
    Text name;
    std::int16_t height;
    std::int16_t vtile;
    bool slider;

    std::int8_t type;
};
} // namespace jrc

```

`IO/UITypes/UIShop.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIShop.h"

#include "../../Data/ItemData.h"
#include "../../Net/Packets/NpcInteractionPackets.h"
#include "../../Util/Misc.h"
#include "../Components/AreaButton.h"
#include "../Components/Charset.h"
#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"
#include "../UI.h"
#include "UINotice.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIShop::UIShop(const CharLook& in_charlook, const Inventory& in_inventory)
    : char_look(in_charlook), inventory(in_inventory)
{
    nl::node src = nl::nx::ui["UIWindow2.img"]["Shop"];
    nl::node src2 = nl::nx::ui["UIWindow2.img"]["Shop2"];

    sprites.emplace_back(src["backgrnd"]);
    sprites.emplace_back(src["backgrnd2"]);
    sprites.emplace_back(src["backgrnd3"]);

    buttons[BUY_ITEM] = std::make_unique<MapleButton>(src["BtBuy"]);
    buttons[SELL_ITEM] = std::make_unique<MapleButton>(src["BtSell"]);
    buttons[EXIT] = std::make_unique<MapleButton>(src["BtExit"]);

    nl::node sellen = src2["TabSell"]["enabled"];
    nl::node selldis = src2["TabSell"]["disabled"];

    constexpr Point<std::int16_t> stshift{-43, -9};
    for (std::uint16_t i = EQUIP; i <= CASH; ++i) {
        std::string tabnum = std::to_string(i - EQUIP);
        buttons[i] = std::make_unique<TwoSpriteButton>(
            selldis[tabnum], sellen[tabnum], stshift);
    }

    for (std::uint16_t i = BUY0; i <= BUY4; ++i) {
        Point<std::int16_t> pos(8, 116 + 42 * (i - BUY0));
        Point<std::int16_t> dim(200, 36);
        buttons[i] = std::make_unique<AreaButton>(pos, dim);
    }
    for (std::uint16_t i = SELL0; i <= SELL4; ++i) {
        Point<std::int16_t> pos(242, 116 + 42 * (i - SELL0));
        Point<std::int16_t> dim(200, 36);
        buttons[i] = std::make_unique<AreaButton>(pos, dim);
    }

    selection = src["select"];
    impossible = src["ShopSpecial"]["impossible"];
    meso = src["meso"];

    meso_label = {Text::A11M, Text::RIGHT, Text::LIGHTGREY};

    buy_slider = {11, {115, 308}, 214, 5, 1, [&](bool upwards) {
                      std::int16_t shift = upwards ? -1 : 1;
                      bool above = buystate.offset + shift >= 0;
                      bool below
                          = buystate.offset + shift <= buystate.last_slot - 5;
                      if (above && below) {
                          buystate.offset += shift;
                      }
                  }};
    sell_slider = {11, {115, 308}, 445, 5, 1, [&](bool upwards) {
                       std::int16_t shift = upwards ? -1 : 1;
                       bool above = sellstate.offset + shift >= 0;
                       bool below = sellstate.offset + shift
                                    <= sellstate.last_slot - 5;
                       if (above && below) {
                           sellstate.offset += shift;
                       }
                   }};

    active = false;
    dimension = Texture(src["backgrnd"]).get_dimensions();
    position = {400 - dimension.x() / 2, 240 - dimension.y() / 2};
}

void UIShop::draw(float alpha) const
{
    UIElement::draw(alpha);

    npc.draw({position + Point<std::int16_t>{64, 76}, true});
    char_look.draw(position + Point<std::int16_t>{294, 76},
                   false,
                   Stance::STAND1,
                   Expression::DEFAULT);

    meso_label.draw(position + Point<std::int16_t>{450, 62});

    buystate.draw(position, selection);
    sellstate.draw(position, selection);

    buy_slider.draw(position);
    sell_slider.draw(position);
}

void UIShop::update()
{
    std::string meso_str = std::to_string(inventory.get_meso());
    string_format::split_number(meso_str);
    meso_label.change_text(std::move(meso_str));
}

Button::State UIShop::button_pressed(std::uint16_t buttonid)
{
    clear_tooltip();

    constexpr Range<std::uint16_t> buy{BUY0, BUY4};
    constexpr Range<std::uint16_t> sell{SELL0, SELL4};
    if (buy.contains(buttonid)) {
        std::int16_t selected = buttonid - BUY0;
        buystate.select(selected);

        return Button::NORMAL;
    } else if (sell.contains(buttonid)) {
        std::int16_t selected = buttonid - SELL0;
        sellstate.select(selected);

        return Button::NORMAL;
    } else {
        switch (buttonid) {
        case BUY_ITEM:
            buystate.buy();
            return Button::NORMAL;
        case SELL_ITEM:
            sellstate.sell();
            return Button::NORMAL;
        case EXIT:
            active = false;
            NpcShopActionPacket().dispatch();
            return Button::PRESSED;
        case EQUIP:
            change_sell_tab(InventoryType::EQUIP);
            return Button::IDENTITY;
        case USE:
            change_sell_tab(InventoryType::USE);
            return Button::IDENTITY;
        case ETC:
            change_sell_tab(InventoryType::ETC);
            return Button::IDENTITY;
        case SETUP:
            change_sell_tab(InventoryType::SETUP);
            return Button::IDENTITY;
        case CASH:
            change_sell_tab(InventoryType::CASH);
            return Button::IDENTITY;
        default:
            break;
        }
    }
    return Button::PRESSED;
}

bool UIShop::remove_cursor(bool clicked, Point<std::int16_t> cursorpos)
{
    if (buy_slider.remove_cursor(clicked)) {
        return true;
    }

    if (sell_slider.remove_cursor(clicked)) {
        return true;
    }

    return UIElement::remove_cursor(clicked, cursorpos);
}

Cursor::State UIShop::send_cursor(bool clicked, Point<std::int16_t> cursorpos)
{
    Point<std::int16_t> cursoroffset = cursorpos - position;
    if (buy_slider.is_enabled()) {
        Cursor::State bstate = buy_slider.send_cursor(cursoroffset, clicked);
        if (bstate != Cursor::IDLE) {
            clear_tooltip();
            return bstate;
        }
    }

    if (sell_slider.is_enabled()) {
        Cursor::State sstate = sell_slider.send_cursor(cursoroffset, clicked);
        if (sstate != Cursor::IDLE) {
            clear_tooltip();
            return sstate;
        }
    }

    std::int16_t xoff = cursoroffset.x();
    std::int16_t yoff = cursoroffset.y();
    std::int16_t slot = slot_by_position(yoff);
    if (slot >= 0 && slot <= 4) {
        if (xoff > 7 && xoff < 209) {
            show_item(slot, true);
        } else if (xoff > 241 && xoff < 443) {
            show_item(slot, false);
        } else {
            clear_tooltip();
        }
    } else {
        clear_tooltip();
    }
    return UIElement::send_cursor(clicked, cursorpos);
}

void UIShop::clear_tooltip()
{
    UI::get().clear_tooltip(Tooltip::SHOP);
}

void UIShop::show_item(std::int16_t slot, bool buy)
{
    if (buy) {
        buystate.show_item(slot);
    } else {
        sellstate.show_item(slot);
    }
}

void UIShop::change_sell_tab(InventoryType::Id type)
{
    std::uint16_t oldtab = tab_by_inventory(sellstate.tab);
    if (oldtab > 0) {
        buttons[oldtab]->set_state(Button::NORMAL);
    }

    std::uint16_t newtab = tab_by_inventory(type);
    if (newtab > 0) {
        buttons[newtab]->set_state(Button::PRESSED);
    }

    sellstate.change_tab(inventory, type, meso);

    sell_slider.set_rows(5, sellstate.last_slot);
}

void UIShop::reset(std::int32_t npc_id)
{
    std::string str_id = string_format::extend_id(npc_id, 7);
    str_id += ".img";
    npc = nl::nx::npc[str_id]["stand"]["0"];

    for (auto& [_, button] : buttons) {
        button->set_state(Button::NORMAL);
    }
    buttons[EQUIP]->set_state(Button::PRESSED);

    buystate.reset();
    sellstate.reset();

    change_sell_tab(InventoryType::EQUIP);

    active = true;
}

void UIShop::modify(InventoryType::Id type)
{
    if (type == sellstate.tab) {
        change_sell_tab(type);
    }
}

void UIShop::add_item(std::int32_t id,
                      std::int32_t price,
                      std::int32_t pitch,
                      std::int32_t time,
                      std::int16_t buyable)
{
    add_rechargable(id, price, pitch, time, 0, buyable);
}

void UIShop::add_rechargable(std::int32_t id,
                             std::int32_t price,
                             std::int32_t pitch,
                             std::int32_t time,
                             std::int16_t chargeprice,
                             std::int16_t buyable)
{
    auto buyitem = BuyItem(meso, id, price, pitch, time, chargeprice, buyable);
    buystate.add(buyitem);

    buy_slider.set_rows(5, buystate.last_slot);
}

std::int16_t UIShop::slot_by_position(std::int16_t y)
{
    std::int16_t yoff = y - 115;
    if (yoff > 0 && yoff < 38) {
        return 0;
    } else if (yoff > 42 && yoff < 80) {
        return 1;
    } else if (yoff > 84 && yoff < 122) {
        return 2;
    } else if (yoff > 126 && yoff < 164) {
        return 3;
    } else if (yoff > 168 && yoff < 206) {
        return 4;
    } else {
        return -1;
    }
}

std::uint16_t UIShop::tab_by_inventory(InventoryType::Id type)
{
    switch (type) {
    case InventoryType::EQUIP:
        return EQUIP;
    case InventoryType::USE:
        return USE;
    case InventoryType::ETC:
        return ETC;
    case InventoryType::SETUP:
        return SETUP;
    case InventoryType::CASH:
        return CASH;
    default:
        return 0;
    }
}

UIShop::BuyItem::BuyItem(Texture cur,
                         std::int32_t i,
                         std::int32_t p,
                         std::int32_t pt,
                         std::int32_t t,
                         std::int16_t cp,
                         std::int16_t b)
    : currency(cur),
      id(i),
      price(p),
      pitch(pt),
      time(t),
      charge_price(cp),
      buyable(b)
{
    name_label = {Text::A11M, Text::LEFT, Text::DARKGREY};
    price_label = {Text::A11M, Text::LEFT, Text::DARKGREY};

    const ItemData& item = ItemData::get(id);
    if (item.is_valid()) {
        icon = item.get_icon(false);
        name_label.change_text(std::string{item.get_name()});
    }

    std::string meso_str = std::to_string(price);
    string_format::split_number(meso_str);
    meso_str += " Mesos";
    price_label.change_text(std::move(meso_str));
}

void UIShop::BuyItem::draw(Point<std::int16_t> pos) const
{
    icon.draw(pos + Point<std::int16_t>{0, 32});
    name_label.draw(pos + Point<std::int16_t>{40, -1});
    currency.draw(pos + Point<std::int16_t>{38, 20});
    price_label.draw(pos + Point<std::int16_t>{53, 17});
}

std::int32_t UIShop::BuyItem::get_id() const
{
    return id;
}

std::int16_t UIShop::BuyItem::get_buyable() const
{
    return buyable;
}

UIShop::SellItem::SellItem(std::int32_t item_id,
                           std::int16_t count,
                           std::int16_t s,
                           bool sc,
                           Texture cur)
{
    const ItemData& idata = ItemData::get(item_id);

    icon = idata.get_icon(false);
    id = item_id;
    sellable = count;
    slot = s;
    show_count = sc;
    currency = cur;

    name_label = {Text::A11M, Text::LEFT, Text::DARKGREY};
    price_label = {Text::A11M, Text::LEFT, Text::DARKGREY};

    name_label.change_text(std::string{idata.get_name()});

    std::string meso_str = std::to_string(idata.get_price());
    string_format::split_number(meso_str);
    meso_str += " Mesos";
    price_label.change_text(std::move(meso_str));
}

void UIShop::SellItem::draw(Point<std::int16_t> pos) const
{
    icon.draw(pos + Point<std::int16_t>{0, 32});
    if (show_count) {
        static const Charset countset
            = {nl::nx::ui["Basic.img"]["ItemNo"], Charset::LEFT};
        countset.draw(std::to_string(sellable),
                      pos + Point<std::int16_t>{0, 20});
    }
    name_label.draw(pos + Point<std::int16_t>{40, -1});
    currency.draw(pos + Point<std::int16_t>{38, 20});
    price_label.draw(pos + Point<std::int16_t>{53, 17});
}

std::int32_t UIShop::SellItem::get_id() const
{
    return id;
}

std::int16_t UIShop::SellItem::get_slot() const
{
    return slot;
}

std::int16_t UIShop::SellItem::get_sellable() const
{
    return sellable;
}

void UIShop::BuyState::reset()
{
    items.clear();

    offset = 0;
    last_slot = 0;
    selection = -1;
}

void UIShop::BuyState::draw(Point<std::int16_t> parent_pos,
                            const Texture& selected) const
{
    for (std::int16_t i = 0; i < 5; ++i) {
        std::int16_t slot = i + offset;
        if (slot >= last_slot) {
            break;
        }

        auto itempos = Point<std::int16_t>{12, 116 + 42 * i};
        if (slot == selection) {
            selected.draw(parent_pos + itempos + Point<std::int16_t>{35, -1});
        }
        items[slot].draw(parent_pos + itempos);
    }
}

void UIShop::BuyState::show_item(std::int16_t slot)
{
    std::int16_t abs_slot = slot + offset;
    if (abs_slot < 0 || abs_slot >= last_slot) {
        return;
    }

    std::int32_t itemid = items[abs_slot].get_id();
    UI::get().show_item(Tooltip::SHOP, itemid);
}

void UIShop::BuyState::add(BuyItem item)
{
    items.push_back(item);

    ++last_slot;
}

void UIShop::BuyState::buy() const
{
    if (selection < 0 || selection >= last_slot) {
        return;
    }

    const BuyItem& item = items[selection];
    std::int16_t buyable = item.get_buyable();
    std::int16_t slot = selection;
    std::int32_t item_id = item.get_id();
    if (buyable > 1) {
        constexpr auto question = "How many would you like to buy?";
        auto on_enter = [slot, item_id](std::int32_t qty) {
            auto short_qty = static_cast<std::int16_t>(qty);

            NpcShopActionPacket(slot, item_id, short_qty, true).dispatch();
        };
        UI::get().emplace<UIEnterNumber>(question, on_enter, 1, buyable, 1);
    } else if (buyable > 0) {
        constexpr auto question = "Would you like to buy the item?";
        auto on_decide = [slot, item_id](bool yes) {
            if (yes) {
                NpcShopActionPacket(slot, item_id, 1, true).dispatch();
            }
        };
        UI::get().emplace<UIYesNo>(question, on_decide);
    }
}

void UIShop::BuyState::select(std::int16_t selected)
{
    std::int16_t slot = selected + offset;
    if (slot == selection) {
        buy();
    } else {
        selection = slot;
    }
}

void UIShop::SellState::reset()
{
    items.clear();

    offset = 0;
    last_slot = 0;
    selection = -1;
    tab = InventoryType::NONE;
}

void UIShop::SellState::change_tab(const Inventory& inv,
                                   InventoryType::Id newtab,
                                   Texture meso_texture)
{
    tab = newtab;

    offset = 0;
    selection = -1;

    items.clear();

    std::int16_t slots = inv.get_slotmax(tab);
    for (std::int16_t i = 1; i <= slots; ++i) {
        if (std::int32_t item_id = inv.get_item_id(tab, i)) {
            std::int16_t count = inv.get_item_count(tab, i);
            items.emplace_back(
                item_id, count, i, tab != InventoryType::EQUIP, meso_texture);
        }
    }

    last_slot = static_cast<std::int16_t>(items.size());
}

void UIShop::SellState::draw(Point<std::int16_t> parent_pos,
                             const Texture& selected) const
{
    for (std::int16_t i = 0; i < 5; ++i) {
        std::int16_t slot = i + offset;
        if (slot >= last_slot) {
            break;
        }

        Point<std::int16_t> itempos(243, 116 + 42 * i);
        if (slot == selection) {
            selected.draw(parent_pos + itempos + Point<std::int16_t>{35, -1});
        }
        items[slot].draw(parent_pos + itempos);
    }
}

void UIShop::SellState::show_item(std::int16_t slot)
{
    std::int16_t abs_slot = slot + offset;
    if (abs_slot < 0 || abs_slot >= last_slot) {
        return;
    }

    if (tab == InventoryType::EQUIP) {
        std::int16_t realslot = items[abs_slot].get_slot();
        UI::get().show_equip(Tooltip::SHOP, realslot);
    } else {
        std::int32_t itemid = items[abs_slot].get_id();
        UI::get().show_item(Tooltip::SHOP, itemid);
    }
}

void UIShop::SellState::sell() const
{
    if (selection < 0 || selection >= last_slot) {
        return;
    }

    const SellItem& item = items[selection];
    std::int32_t item_id = item.get_id();
    std::int16_t sellable = item.get_sellable();
    std::int16_t slot = item.get_slot();
    if (sellable > 1) {
        UI::get().emplace<UIEnterNumber>(
            "How many would you like to sell?",
            [item_id, slot](std::int32_t qty) {
                NpcShopActionPacket{
                    slot, item_id, static_cast<std::int16_t>(qty), false}
                    .dispatch();
            },
            1,
            sellable,
            1);
    } else if (sellable > 0) {
        UI::get().emplace<UIYesNo>(
            "Would you like to sell the item?", [item_id, slot](bool yes) {
                if (yes) {
                    NpcShopActionPacket{slot, item_id, 1, false}.dispatch();
                }
            });
    }
}

void UIShop::SellState::select(std::int16_t selected)
{
    std::int16_t slot = selected + offset;
    if (slot == selection) {
        sell();
    } else {
        selection = slot;
    }
}
} // namespace jrc

```

`IO/UITypes/UIShop.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Inventory.h"
#include "../../Character/Look/CharLook.h"
#include "../../Graphics/Text.h"
#include "../../Graphics/Texture.h"
#include "../Components/Slider.h"
#include "../UIElement.h"

namespace jrc
{
class UIShop : public UIElement
{
public:
    static constexpr Type TYPE = SHOP;
    static constexpr bool FOCUSED = true;
    static constexpr bool TOGGLED = true;

    UIShop(const CharLook& charlook, const Inventory& inventory);

    void draw(float alpha) const override;
    void update() override;

    bool remove_cursor(bool clicked, Point<std::int16_t> cursorpos) override;
    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> position) override;

    void reset(std::int32_t npc_id);
    void add_item(std::int32_t id,
                  std::int32_t price,
                  std::int32_t pitch,
                  std::int32_t time,
                  std::int16_t buyable);
    void add_rechargable(std::int32_t id,
                         std::int32_t price,
                         std::int32_t pitch,
                         std::int32_t time,
                         std::int16_t chargeprice,
                         std::int16_t buyable);

    void modify(InventoryType::Id type);

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    void clear_tooltip();
    void show_item(std::int16_t slot, bool sale);
    void change_sell_tab(InventoryType::Id tab);
    std::int16_t slot_by_position(std::int16_t y);
    std::uint16_t tab_by_inventory(InventoryType::Id type);

    enum Buttons : std::int16_t {
        BUY_ITEM = 0,
        SELL_ITEM = 1,
        EXIT = 2,
        EQUIP = 3,
        USE = 4,
        ETC = 5,
        SETUP = 6,
        CASH = 7,
        BUY0 = 8,
        BUY4 = 12,
        SELL0 = 13,
        SELL4 = 17
    };

    const CharLook& char_look;
    const Inventory& inventory;

    Texture npc;
    Texture selection;
    Texture impossible;
    Texture meso;
    Text meso_label;

    Slider buy_slider;
    Slider sell_slider;

    class BuyItem
    {
    public:
        BuyItem(Texture cur,
                std::int32_t i,
                std::int32_t p,
                std::int32_t pt,
                std::int32_t t,
                std::int16_t cp,
                std::int16_t b);

        void draw(Point<std::int16_t> position) const;

        std::int32_t get_id() const;
        std::int16_t get_buyable() const;

    private:
        Texture icon;
        Texture currency;
        std::int32_t id;
        std::int32_t price;
        std::int32_t pitch;
        std::int32_t time;
        std::int16_t charge_price;
        std::int16_t buyable;
        Text name_label;
        Text price_label;
    };

    class SellItem
    {
    public:
        SellItem(std::int32_t item_id,
                 std::int16_t count,
                 std::int16_t slot,
                 bool showcount,
                 Texture cur);

        void draw(Point<std::int16_t> position) const;

        std::int32_t get_id() const;
        std::int16_t get_slot() const;
        std::int16_t get_sellable() const;

    private:
        Texture icon;
        Texture currency;
        std::int32_t id;
        std::int16_t slot;
        std::int16_t sellable;
        bool show_count;
        Text name_label;
        Text price_label;
    };

    struct BuyState {
        std::vector<BuyItem> items;
        std::int16_t offset;
        std::int16_t last_slot;
        std::int16_t selection;

        void reset();
        void draw(Point<std::int16_t> position, const Texture& selected) const;
        void show_item(std::int16_t slot);
        void add(BuyItem item);
        void buy() const;
        void select(std::int16_t selected);
    };
    BuyState buystate;

    struct SellState {
        std::vector<SellItem> items;
        std::int16_t offset;
        InventoryType::Id tab;
        std::int16_t last_slot;
        std::int16_t selection;

        void reset();
        void change_tab(const Inventory& inventory,
                        InventoryType::Id type,
                        Texture meso);
        void draw(Point<std::int16_t> position, const Texture& selected) const;
        void show_item(std::int16_t slot);
        void sell() const;
        void select(std::int16_t selected);
    };
    SellState sellstate;
};
} // namespace jrc

```

`IO/UITypes/UISkillBook.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UISkillBook.h"

#include "../../Character/SkillId.h"
#include "../../Data/JobData.h"
#include "../../Data/SkillData.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"
#include "../../Net/Packets/PlayerPackets.h"
#include "../../Util/Misc.h"
#include "../Components/MapleButton.h"
#include "../Components/TwoSpriteButton.h"
#include "nlnx/nx.hpp"

namespace jrc
{
constexpr Point<std::int16_t> UISkillbook::SKILL_OFFSET;
constexpr Point<std::int16_t> UISkillbook::ICON_OFFSET;
constexpr Point<std::int16_t> UISkillbook::LINE_OFFSET;

SkillIcon::SkillIcon(std::int32_t i, std::int32_t lv) : id{i}
{
    const SkillData& data = SkillData::get(id);

    normal = data.get_icon(SkillData::NORMAL);
    mouse_over = data.get_icon(SkillData::MOUSEOVER);
    disabled = data.get_icon(SkillData::DISABLED);

    std::string name_str{data.get_name()};

    name = {Text::A11L, Text::LEFT, Text::DARKGREY, std::string{name_str}};
    level = {Text::A11L, Text::LEFT, Text::DARKGREY, std::to_string(lv)};
    state = NORMAL;

    static constexpr const std::uint16_t MAX_NAME_WIDTH = 96;
    std::size_t overhang = 3;
    while (name.width() > MAX_NAME_WIDTH) {
        name_str.replace(name_str.end() - overhang, name_str.end(), "...", 3);
        ++overhang;

        name.change_text(std::string{name_str});
    }
}

std::int32_t SkillIcon::get_action_id() const noexcept
{
    return -id;
}

void SkillIcon::draw(const DrawArgument& args) const
{
    switch (state) {
    case NORMAL:
        normal.draw(args);
        break;
    case DISABLED:
        disabled.draw(args);
        break;
    case MOUSE_OVER:
        mouse_over.draw(args);
        break;
    }

    name.draw(args + Point<std::int16_t>{38, -34});
    level.draw(args + Point<std::int16_t>{38, -16});
}

Cursor::State SkillIcon::send_cursor(Point<std::int16_t> cursor_pos,
                                     bool clicked)
{
    static constexpr const Rectangle<std::int16_t> bounds{0, 32, 0, 32};
    bool in_range = bounds.contains(cursor_pos);

    switch (state) {
    case NORMAL:
    case DISABLED:
        if (in_range) {
            if (clicked) {
                state = MOUSE_OVER;
                return Cursor::GRABBING;
            } else {
                state = MOUSE_OVER;
                return Cursor::CAN_GRAB;
            }
        } else {
            return Cursor::IDLE;
        }
    case MOUSE_OVER:
        if (in_range) {
            if (clicked) {
                state = MOUSE_OVER;
                return Cursor::GRABBING;
            } else {
                state = MOUSE_OVER;
                return Cursor::CAN_GRAB;
            }
        } else {
            state = NORMAL;
            return Cursor::IDLE;
        }
    default:
        return Cursor::IDLE;
    }
}

std::int32_t SkillIcon::get_id() const noexcept
{
    return id;
}

UISkillbook::UISkillbook(const CharStats& in_stats,
                         const Skillbook& in_skillbook)
    : UIDragElement{{174, 20}},
      stats{in_stats},
      skillbook{in_skillbook},
      tab{0}
{
    nl::node main = nl::nx::ui["UIWindow2.img"]["Skill"]["main"];

    sprites.emplace_back(main["backgrnd"]);
    sprites.emplace_back(main["backgrnd2"]);
    sprites.emplace_back(main["backgrnd3"]);

    skill_d = main["skill0"];
    skill_e = main["skill1"];
    line = main["line"];

    auto tab_src = main["Tab"];
    nl::node tab_e = tab_src["enabled"];
    nl::node tab_d = tab_src["disabled"];

    for (std::uint16_t i = BT_TAB0; i <= BT_TAB4; ++i) {
        std::uint16_t tab_id = i - BT_TAB0;
        buttons[i]
            = std::make_unique<TwoSpriteButton>(tab_d[tab_id], tab_e[tab_id]);
    }
    for (std::uint16_t i = BT_SPUP0; i <= BT_SPUP3; ++i) {
        std::uint16_t spup_id = i - BT_SPUP0;
        Point<std::int16_t> spup_position
            = SKILL_OFFSET
              + Point<std::int16_t>{124, 20 + spup_id * ROW_HEIGHT};
        buttons[i]
            = std::make_unique<MapleButton>(main["BtSpUp"], spup_position);
    }

    book_text = {Text::A12M, Text::CENTER, Text::WHITE, "", 100};
    sp_label = {Text::A11M, Text::RIGHT, Text::LIGHTGREY};

    slider = {11, {92, 236}, 154, ROWS, 1, [this](bool upwards) {
                  std::int16_t shift = upwards ? -1 : 1;
                  bool above = offset + shift >= 0;
                  bool below = offset + 4 + shift <= skill_count;
                  if (above && below) {
                      change_offset(offset + shift);
                  }
              }};

    change_job(stats.get_stat(Maplestat::JOB));
    change_sp(stats.get_stat(Maplestat::SP));

    dimension = {174, 299};
}

void UISkillbook::draw(float alpha) const
{
    draw_sprites(alpha);

    book_icon.draw(position + Point<std::int16_t>{12, 85});
    book_text.draw(position + Point<std::int16_t>{100, 49});
    sp_label.draw(position + Point<std::int16_t>{162, 254});

    auto begin = icons.begin();
    if (icons.size() > offset) {
        begin = begin + offset;
    }

    auto end = icons.end();
    if (icons.size() > ROWS + offset) {
        end = begin + ROWS;
    }

    Point<std::int16_t> skill_position = position + SKILL_OFFSET;
    for (auto iter = begin; iter != end; ++iter) {
        skill_e.draw(skill_position);
        iter->first->draw(skill_position + ICON_OFFSET);
        if (iter != end - 1) {
            line.draw(skill_position + LINE_OFFSET);
        }

        skill_position.shift_y(ROW_HEIGHT);
    }

    draw_buttons(alpha);

    slider.draw(position);
}

Button::State UISkillbook::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_TAB0:
    case BT_TAB1:
    case BT_TAB2:
    case BT_TAB3:
    case BT_TAB4:
        change_tab(id - BT_TAB0);
        return Button::PRESSED;
    case BT_SPUP0:
    case BT_SPUP1:
    case BT_SPUP2:
    case BT_SPUP3:
        send_spup(id - BT_SPUP0 + offset);
        return Button::PRESSED;
    default:
        return Button::PRESSED;
    }
}

void UISkillbook::double_click(Point<std::int16_t> cursor_pos)
{
    if (const SkillIcon* icon = icon_by_position(cursor_pos - position);
        icon) {
        std::int32_t skill_id = icon->get_id();
        std::int32_t skill_level = skillbook.get_level(skill_id);
        if (skill_level > 0) {
            Stage::get().get_combat().use_move(skill_id);
        }
    }
}

bool UISkillbook::remove_cursor(bool clicked, Point<std::int16_t> cursor_pos)
{
    if (UIDragElement::remove_cursor(clicked, cursor_pos)) {
        return true;
    }

    return slider.remove_cursor(clicked);
}

Cursor::State UISkillbook::send_cursor(bool clicked,
                                       Point<std::int16_t> cursor_pos)
{
    Cursor::State dstate = UIDragElement::send_cursor(clicked, cursor_pos);
    if (dragged) {
        return dstate;
    }

    Point<std::int16_t> cursor_relative = cursor_pos - position;
    if (slider.is_enabled()) {
        if (Cursor::State new_state
            = slider.send_cursor(cursor_relative, clicked);
            new_state) {
            clear_tooltip();
            return new_state;
        }
    }

    auto begin = icons.begin();
    if (icons.size() > offset) {
        begin = begin + offset;
    }

    auto end = icons.end();
    if (icons.size() > ROWS + offset) {
        end = begin + ROWS;
    }

    Point<std::int16_t> skill_position = position + SKILL_OFFSET;
    for (auto iter = begin; iter != end; ++iter) {
        auto normalized = cursor_pos - skill_position;
        if (Cursor::State state
            = iter->first->send_cursor(normalized, clicked);
            state) {
            switch (state) {
            case Cursor::GRABBING:
                clear_tooltip();
                iter->second->start_drag(normalized);
                UI::get().drag_icon(iter->second.get());
                break;
            case Cursor::CAN_GRAB:
                show_skill(iter->first->get_id());
                break;
            default:
                break;
            }
            return state;
        }

        skill_position.shift_y(ROW_HEIGHT);
    }

    clear_tooltip();
    return Cursor::IDLE;
}

void UISkillbook::update_stat(Maplestat::Id stat, std::int16_t value)
{
    switch (stat) {
    case Maplestat::JOB:
        change_job(value);
        break;
    case Maplestat::SP:
        change_sp(value);
        break;
    default:
        return;
    }
}

void UISkillbook::update_skills(std::int32_t skill_id)
{
    if (skill_id / 10'000 == job.get_id()) {
        change_tab(tab);
    }
}

void UISkillbook::change_job(std::uint16_t id)
{
    job.change_job(id);

    Job::Level level = job.get_level();
    for (std::uint16_t i = 0; i <= Job::FOURTH; ++i) {
        buttons[BT_TAB0 + i]->set_active(i <= level);
    }

    change_tab(level - Job::BEGINNER);
}

void UISkillbook::change_sp(std::int16_t s)
{
    sp = s;
    sp_label.change_text(std::to_string(sp));

    change_offset(offset);
}

void UISkillbook::change_tab(std::uint16_t new_tab)
{
    buttons[BT_TAB0 + tab]->set_state(Button::NORMAL);
    buttons[BT_TAB0 + new_tab]->set_state(Button::PRESSED);
    tab = new_tab;

    icons.clear();
    skill_count = 0;

    Job::Level job_level = job_level_by_tab(tab);
    std::uint16_t sub_id = job.get_subjob(job_level);

    const JobData& data = JobData::get(sub_id);

    book_icon = data.get_icon();
    book_text.change_text(std::string{data.get_name()});

    for (std::int32_t skill_id : data.get_skills()) {
        std::int32_t level = skillbook.get_level(skill_id);
        std::int32_t master_level = skillbook.get_master_level(skill_id);

        bool invisible = SkillData::get(skill_id).is_invisible();
        if (invisible && master_level == 0) {
            continue;
        }

        auto skill_icon = std::make_unique<SkillIcon>(skill_id, level);
        icons.emplace_back(
            skill_icon.get(),
            std::make_unique<Icon>(
                std::move(skill_icon),
                SkillData::get(skill_id).get_icon(SkillData::NORMAL),
                -1));

        ++skill_count;
    }

    slider.set_rows(ROWS, skill_count);
    change_offset(0);
}

void UISkillbook::change_offset(std::uint16_t new_offset)
{
    offset = new_offset;

    for (std::int16_t i = 0; i < ROWS; ++i) {
        std::uint16_t index = BT_SPUP0 + i;
        std::uint16_t row = offset + i;
        buttons[index]->set_active(row < skill_count);
        if (row < icons.size()) {
            std::int32_t skill_id = icons[row].first->get_id();
            buttons[index]->set_state(can_raise(skill_id) ? Button::NORMAL
                                                          : Button::DISABLED);
        }
    }
}

void UISkillbook::show_skill(std::int32_t id)
{
    std::int32_t skill_id = id;
    std::int32_t level = skillbook.get_level(id);
    std::int32_t master_level = skillbook.get_master_level(id);
    std::int64_t expiration = skillbook.get_expiration(id);

    UI::get().show_skill(
        Tooltip::SKILL_BOOK, skill_id, level, master_level, expiration);
}

void UISkillbook::clear_tooltip()
{
    UI::get().clear_tooltip(Tooltip::SKILL_BOOK);
}

bool UISkillbook::can_raise(std::int32_t skill_id) const
{
    if (sp <= 0) {
        return false;
    }

    std::int32_t level = skillbook.get_level(skill_id);
    std::int32_t masterlevel = skillbook.get_master_level(skill_id);
    if (masterlevel == 0) {
        masterlevel = SkillData::get(skill_id).get_master_level();
    }

    if (level >= masterlevel) {
        return false;
    }

    switch (skill_id) {
    case SkillId::ANGEL_BLESSING:
        return false;
    default:
        return true;
    }
}

void UISkillbook::send_spup(std::uint16_t row)
{
    if (row >= icons.size()) {
        return;
    }

    std::int32_t skill_id = icons[row].first->get_id();

    SpendSpPacket{skill_id}.dispatch();
    UI::get().disable();
}

Job::Level UISkillbook::job_level_by_tab(std::uint16_t t) const
{
    switch (t) {
    case 1:
        return Job::FIRST;
    case 2:
        return Job::SECOND;
    case 3:
        return Job::THIRD;
    case 4:
        return Job::FOURTH;
    default:
        return Job::BEGINNER;
    }
}

SkillIcon* UISkillbook::icon_by_position(Point<std::int16_t> cursor_pos)
{
    std::int16_t x = cursor_pos.x();
    if (x < SKILL_OFFSET.x() || x > 148) {
        return nullptr;
    }

    std::int16_t y = cursor_pos.y();
    if (y < SKILL_OFFSET.y()) {
        return nullptr;
    }

    std::uint16_t row = (y - SKILL_OFFSET.y()) / ROW_HEIGHT;
    if (row < 0 || row >= ROWS) {
        return nullptr;
    }

    std::uint16_t abs_row = offset + row;
    if (icons.size() <= abs_row) {
        return nullptr;
    }

    // auto iter = icons.begin() + abs_row;
    // return icons.data() + (iter - icons.begin());
    return icons[abs_row].first;
}
} // namespace jrc

```

`IO/UITypes/UISkillBook.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/CharStats.h"
#include "../../Character/SkillBook.h"
#include "../../Graphics/Text.h"
#include "../Components/Icon.h"
#include "../Components/Slider.h"
#include "../UIDragElement.h"
#include "../UIElement.h"

#include <utility>
#include <vector>

namespace jrc
{
class SkillIcon : public Icon::Type
{
public:
    SkillIcon(std::int32_t id, std::int32_t level);

    void drop_on_stage() const override
    {
    }
    void drop_on_equips(Equipslot::Id) const override
    {
    }
    void drop_on_items(InventoryType::Id,
                       Equipslot::Id,
                       std::int16_t,
                       bool) const override
    {
    }

    std::int32_t get_action_id() const noexcept override;

    void draw(const DrawArgument& args) const;

    Cursor::State send_cursor(Point<std::int16_t> cursor_pos, bool clicked);

    std::int32_t get_id() const noexcept;

private:
    enum State : std::uint8_t { NORMAL, DISABLED, MOUSE_OVER };

    Text name;
    Text level;

    Texture normal;
    Texture disabled;
    Texture mouse_over;

    std::int32_t id;

    State state;
    bool enabled;
};

class UISkillbook : public UIDragElement<Configuration::PositionOf::SKILLBOOK>
{
public:
    static constexpr const Type TYPE = SKILLBOOK;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UISkillbook(const CharStats& stats, const Skillbook& skillbook);

    void draw(float alpha) const override;

    void double_click(Point<std::int16_t> cursorpos) override;
    bool remove_cursor(bool clicked, Point<std::int16_t> cursorpos) override;
    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> cursorpos) override;

    void update_stat(Maplestat::Id stat, std::int16_t value);
    void update_skills(std::int32_t skill_id);

protected:
    Button::State button_pressed(std::uint16_t id) override;

private:
    void change_job(std::uint16_t id);
    void change_sp(std::int16_t value);
    void change_tab(std::uint16_t new_tab);
    void change_offset(std::uint16_t new_offset);

    void show_skill(std::int32_t skill_id);
    void clear_tooltip();

    bool can_raise(std::int32_t skill_id) const;
    void send_spup(std::uint16_t row);

    Job::Level job_level_by_tab(std::uint16_t tab) const;
    SkillIcon* icon_by_position(Point<std::int16_t> cursor_pos);

    enum Buttons : std::uint16_t {
        BT_GUILD,
        BT_HYPER,
        BT_TAB0,
        BT_TAB1,
        BT_TAB2,
        BT_TAB3,
        BT_TAB4,
        BT_SPUP0,
        BT_SPUP1,
        BT_SPUP2,
        BT_SPUP3
    };

    static constexpr const std::int16_t ROWS = 4;
    static constexpr const std::int16_t ROW_HEIGHT = 40;
    static constexpr const Point<std::int16_t> SKILL_OFFSET{11, 93};
    static constexpr const Point<std::int16_t> ICON_OFFSET{2, 34};
    static constexpr const Point<std::int16_t> LINE_OFFSET{2, 37};

    const CharStats& stats;
    const Skillbook& skillbook;

    Slider slider;
    Texture skill_e;
    Texture skill_d;
    Texture line;
    Texture book_icon;
    Text book_text;
    Text sp_label;

    Job job;
    std::int16_t sp;

    std::uint16_t tab;
    std::uint16_t skill_count;
    std::uint16_t offset;

    std::vector<std::pair<SkillIcon*, std::unique_ptr<Icon>>> icons;
};
} // namespace jrc

```

`IO/UITypes/UISoftKey.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UISoftKey.h"

#include "../../Net/Packets/SelectCharPackets.h"
#include "../Components/MapleButton.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UISoftkey::UISoftkey(Callback c) : callback{c}
{
    nl::node src = nl::nx::ui["Login.img"]["Common"]["SoftKey"];

    sprites.emplace_back(src["backgrnd"]);
    sprites.emplace_back(src["backgrnd2"]);
    sprites.emplace_back(src["backgrnd3"]);

    buttons[BT_NEXT] = std::make_unique<MapleButton>(src["BtNext"]);
    buttons[BT_BACK] = std::make_unique<MapleButton>(src["BtDel"]);
    buttons[BT_OK] = std::make_unique<MapleButton>(
        src["BtOK"], Point<std::int16_t>(72, 235));
    buttons[BT_CANCEL] = std::make_unique<MapleButton>(
        src["BtCancel"], Point<std::int16_t>(13, 235));

    nl::node keys = src["BtNum"];

    buttons[BT_0] = std::make_unique<MapleButton>(keys["0"]);
    buttons[BT_1] = std::make_unique<MapleButton>(keys["1"]);
    buttons[BT_2] = std::make_unique<MapleButton>(keys["2"]);
    buttons[BT_3] = std::make_unique<MapleButton>(keys["3"]);
    buttons[BT_4] = std::make_unique<MapleButton>(keys["4"]);
    buttons[BT_5] = std::make_unique<MapleButton>(keys["5"]);
    buttons[BT_6] = std::make_unique<MapleButton>(keys["6"]);
    buttons[BT_7] = std::make_unique<MapleButton>(keys["7"]);
    buttons[BT_8] = std::make_unique<MapleButton>(keys["8"]);
    buttons[BT_9] = std::make_unique<MapleButton>(keys["9"]);

    buttons[BT_OK]->set_state(Button::DISABLED);

    entry = {Text::A11M, Text::LEFT, Text::BLACK};

    shufflekeys();

    position = {330, 160};
    dimension = {140, 280};
    active = true;
}

void UISoftkey::draw(float alpha) const
{
    UIElement::draw(alpha);

    entry.draw(position + Point<std::int16_t>{15, 43});
}

Button::State UISoftkey::button_pressed(std::uint16_t id)
{
    std::string entered{entry.get_text()};

    switch (id) {
    case BT_0:
    case BT_1:
    case BT_2:
    case BT_3:
    case BT_4:
    case BT_5:
    case BT_6:
    case BT_7:
    case BT_8:
    case BT_9:
        if (entered.size() <= MAX_SIZE) {
            entered.append(std::to_string(id));
            shufflekeys();
        }
        buttons[id]->set_state(Button::NORMAL);
        break;
    case BT_BACK:
        if (entered.size() > 0) {
            entered.pop_back();
        }
        buttons[id]->set_state(Button::NORMAL);
        break;
    case BT_CANCEL:
        active = false;
        break;
    case BT_OK:
        if (entered.size() >= MIN_SIZE && callback) {
            callback(entered);
            active = false;
        }
        break;
    }

    switch (entered.size()) {
    case MIN_SIZE - 1:
        buttons[BT_OK]->set_state(Button::DISABLED);
        break;
    case MIN_SIZE:
        buttons[BT_OK]->set_state(Button::NORMAL);
        break;
    case MAX_SIZE - 1:
        for (std::uint8_t i = 0; i < NUM_KEYS; ++i) {
            buttons[i]->set_state(Button::NORMAL);
        }
        break;
    case MAX_SIZE:
        for (std::uint8_t i = 0; i < NUM_KEYS; ++i) {
            buttons[i]->set_state(Button::DISABLED);
        }
        break;
    }

    entry.change_text(std::move(entered));

    return Button::IDENTITY;
}

void UISoftkey::shufflekeys()
{
    std::vector<std::uint8_t> reserve;
    for (std::uint8_t i = 0; i < NUM_KEYS; ++i) {
        reserve.push_back(i);
    }
    for (std::uint8_t i = 0; i < NUM_KEYS; ++i) {
        std::size_t rand = Randomizer::next_int(reserve.size());
        Point<std::int16_t> pos = key_pos(reserve[rand]);
        buttons[BT_0 + i]->set_position(pos);
        reserve.erase(reserve.begin() + rand);
    }
}

Point<std::int16_t> UISoftkey::key_pos(std::uint8_t num) const
{
    return {12 + (num % 3) * 39, 94 + (num / 3) * 35};
}
} // namespace jrc

```

`IO/UITypes/UISoftKey.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "../../Util/Randomizer.h"
#include "../UIElement.h"

#include <functional>
#include <string_view>

namespace jrc
{
//! Keyboard which is used via the mouse. The game uses this for pic/pin input.
class UISoftkey : public UIElement
{
public:
    using Callback = std::function<void(std::string_view)>;

    static constexpr Type TYPE = SOFT_KEYBOARD;
    static constexpr bool FOCUSED = true;
    static constexpr bool TOGGLED = false;

    UISoftkey(Callback callback);

    void draw(float alpha) const override;

protected:
    Button::State button_pressed(std::uint16_t) override;

private:
    void shufflekeys();
    Point<std::int16_t> key_pos(std::uint8_t) const;

    enum Buttons {
        BT_0,
        BT_1,
        BT_2,
        BT_3,
        BT_4,
        BT_5,
        BT_6,
        BT_7,
        BT_8,
        BT_9,
        BT_NEXT,
        BT_BACK,
        BT_CANCEL,
        BT_OK
    };

    static constexpr const std::size_t MIN_SIZE = 6;
    static constexpr const std::size_t MAX_SIZE = 12;
    static constexpr const std::uint8_t NUM_KEYS = 10;

    Callback callback;
    Text entry;
};
} // namespace jrc

```

`IO/UITypes/UIStatsInfo.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIStatsInfo.h"

#include "../../Net/Packets/PlayerPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

#include <cstdlib>

namespace jrc
{
UIStatsinfo::UIStatsinfo(const CharStats& st)
    : UIDragElement<Configuration::PositionOf::STATS>{{212, 20}}, stats{st}
{
    nl::node base_src = nl::nx::ui["UIWindow4.img"]["Stat"];
    nl::node src = base_src["main"];
    nl::node detail = base_src["detail"];

    sprites.emplace_back(src["backgrnd"]);
    sprites.emplace_back(src["backgrnd2"]);
    sprites.emplace_back(src["backgrnd3"]);

    textures_detail.emplace_back(detail["backgrnd"]);
    textures_detail.emplace_back(detail["backgrnd2"]);
    textures_detail.emplace_back(detail["backgrnd3"]);

    auto ability_title_src = detail["abilityTitle"];
    abilities[RARE] = ability_title_src["rare"]["0"];
    abilities[EPIC] = ability_title_src["epic"]["0"];
    abilities[UNIQUE] = ability_title_src["unique"]["0"];
    abilities[LEGENDARY] = ability_title_src["legendary"]["0"];
    abilities[NONE] = ability_title_src["normal"]["0"];

    buttons[BT_HP] = std::make_unique<MapleButton>(src["BtHpUp"]);
    buttons[BT_MP] = std::make_unique<MapleButton>(src["BtMpUp"]);
    buttons[BT_STR] = std::make_unique<MapleButton>(src["BtStrUp"]);
    buttons[BT_DEX] = std::make_unique<MapleButton>(src["BtDexUp"]);
    buttons[BT_LUK] = std::make_unique<MapleButton>(src["BtLukUp"]);
    buttons[BT_INT] = std::make_unique<MapleButton>(src["BtIntUp"]);

    buttons[BT_DETAILOPEN]
        = std::make_unique<MapleButton>(src["BtDetailOpen"]);
    buttons[BT_DETAILCLOSE]
        = std::make_unique<MapleButton>(src["BtDetailClose"]);
    buttons[BT_DETAILCLOSE]->set_active(false);

    update_ap();

    for (std::size_t i = 0; i < NUMLABELS; ++i) {
        statlabels[i] = {Text::A11M, Text::LEFT, Text::LIGHTGREY};
    }
    statoffsets[NAME] = {73, 27};
    statoffsets[JOB] = {73, 45};
    statoffsets[GUILD] = {73, 63};
    statoffsets[FAME] = {73, 81};
    statoffsets[DAMAGE] = {73, 99};
    statoffsets[HP] = {73, 117};
    statoffsets[MP] = {73, 135};
    statoffsets[AP] = {70, 177};
    statoffsets[STR] = {73, 204};
    statoffsets[DEX] = {73, 222};
    statoffsets[INT] = {73, 240};
    statoffsets[LUK] = {73, 258};
    statoffsets[ATTACK] = {73, 37};
    statoffsets[CRIT] = {73, 55};
    statoffsets[MINCRIT] = {73, 73};
    statoffsets[MAXCRIT] = {168, 73};
    statoffsets[BDM] = {73, 91};
    statoffsets[IGNOREDEF] = {168, 91};
    statoffsets[RESIST] = {73, 109};
    statoffsets[STANCE] = {168, 109};
    statoffsets[WDEF] = {73, 127};
    statoffsets[MDEF] = {73, 145};
    statoffsets[ACCURACY] = {73, 163};
    statoffsets[AVOID] = {73, 199};
    statoffsets[SPEED] = {73, 235};
    statoffsets[JUMP] = {168, 235};
    statoffsets[HONOR] = {73, 353};

    update_all_stats();
    update_stat(Maplestat::JOB);
    update_stat(Maplestat::FAME);

    dimension = {212, 318};
    showdetail = false;
}

void UIStatsinfo::draw(float alpha) const
{
    UIElement::draw(alpha);

    if (showdetail) {
        auto detail_pos = position + Point<std::int16_t>{213, 0};
        for (auto& texture : textures_detail) {
            texture.draw(detail_pos);
        }
        abilities[NONE].draw({detail_pos});
    }

    std::size_t last = showdetail ? NUMLABELS : NUMNORMAL;
    for (std::size_t i = 0; i < last; ++i) {
        auto labelpos = position + statoffsets[i];
        if (i >= NUMNORMAL) {
            labelpos.shift_x(213);
        }

        statlabels[i].draw(labelpos);
    }
}

void UIStatsinfo::update_all_stats()
{
    update_simple(AP, Maplestat::AP);
    if (hasap ^ (stats.get_stat(Maplestat::AP) > 0)) {
        update_ap();
    }

    statlabels[NAME].change_text(std::string(stats.get_name()));
    statlabels[GUILD].change_text("");

    statlabels[HP].change_text(
        str::concat(std::to_string(stats.get_stat(Maplestat::HP)),
                    " / ",
                    std::to_string(stats.get_total(Equipstat::HP))));
    statlabels[MP].change_text(
        str::concat(std::to_string(stats.get_stat(Maplestat::MP)),
                    " / ",
                    std::to_string(stats.get_total(Equipstat::MP))));

    update_basevstotal(STR, Maplestat::STR, Equipstat::STR);
    update_basevstotal(DEX, Maplestat::DEX, Equipstat::DEX);
    update_basevstotal(INT, Maplestat::INT, Equipstat::INT);
    update_basevstotal(LUK, Maplestat::LUK, Equipstat::LUK);

    statlabels[DAMAGE].change_text(
        str::concat(std::to_string(stats.get_min_damage()),
                    " ~ ",
                    std::to_string(stats.get_max_damage())));
    if (stats.is_damage_buffed()) {
        statlabels[DAMAGE].change_color(Text::RED);
    } else {
        statlabels[DAMAGE].change_color(Text::LIGHTGREY);
    }

    update_buffed(ATTACK, Equipstat::WATK);
    update_buffed(WDEF, Equipstat::WDEF);
    update_buffed(MDEF, Equipstat::MDEF);
    update_buffed(ACCURACY, Equipstat::ACC);
    update_buffed(AVOID, Equipstat::AVOID);

    statlabels[CRIT].change_text(str::concat(
        std::to_string(static_cast<std::int32_t>(stats.get_critical() * 100)),
        '%'));
    statlabels[MINCRIT].change_text(str::concat(
        std::to_string(static_cast<std::int32_t>(stats.get_min_crit() * 100)),
        '%'));
    statlabels[MAXCRIT].change_text(str::concat(
        std::to_string(static_cast<std::int32_t>(stats.get_max_crit() * 100)),
        '%'));
    statlabels[BDM].change_text(str::concat(
        std::to_string(static_cast<std::int32_t>(stats.get_boss_dmg() * 100)),
        '%'));
    statlabels[IGNOREDEF].change_text(
        str::concat(std::to_string(static_cast<std::int32_t>(
                        stats.get_ignore_def() * 100)),
                    '%'));
    statlabels[RESIST].change_text(
        str::concat(std::to_string(static_cast<std::int32_t>(
                        stats.get_resistance() * 100)),
                    '%'));
    statlabels[STANCE].change_text(str::concat(
        std::to_string(static_cast<std::int32_t>(stats.get_stance() * 100)),
        '%'));
    statlabels[SPEED].change_text(
        str::concat(std::to_string(stats.get_total(Equipstat::SPEED)), '%'));
    statlabels[JUMP].change_text(
        str::concat(std::to_string(stats.get_total(Equipstat::JUMP)), '%'));
    statlabels[HONOR].change_text(std::to_string(stats.get_honor()));
}

void UIStatsinfo::update_stat(Maplestat::Id stat)
{
    switch (stat) {
    case Maplestat::JOB:
        statlabels[JOB].change_text(std::string(stats.get_job_name()));
        break;
    case Maplestat::FAME:
        update_simple(FAME, Maplestat::FAME);
        break;
    default:
        break;
    }
}

Button::State UIStatsinfo::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_DETAILOPEN:
        showdetail = true;
        buttons[BT_DETAILOPEN]->set_active(false);
        buttons[BT_DETAILCLOSE]->set_active(true);
        break;
    case BT_DETAILCLOSE:
        showdetail = false;
        buttons[BT_DETAILCLOSE]->set_active(false);
        buttons[BT_DETAILOPEN]->set_active(true);
        break;
    case BT_HP:
        send_apup(Maplestat::HP);
        break;
    case BT_MP:
        send_apup(Maplestat::MP);
        break;
    case BT_STR:
        send_apup(Maplestat::STR);
        break;
    case BT_DEX:
        send_apup(Maplestat::DEX);
        break;
    case BT_INT:
        send_apup(Maplestat::INT);
        break;
    case BT_LUK:
        send_apup(Maplestat::LUK);
        break;
    default:
        break;
    }
    return Button::NORMAL;
}

void UIStatsinfo::send_apup(Maplestat::Id stat) const
{
    SpendApPacket{stat}.dispatch();
    UI::get().disable();
}

void UIStatsinfo::update_ap()
{
    const bool now_ap = stats.get_stat(Maplestat::AP) > 0;
    const Button::State new_state = now_ap ? Button::NORMAL : Button::DISABLED;

    buttons[BT_HP]->set_state(new_state);
    buttons[BT_MP]->set_state(new_state);
    buttons[BT_STR]->set_state(new_state);
    buttons[BT_DEX]->set_state(new_state);
    buttons[BT_LUK]->set_state(new_state);
    buttons[BT_INT]->set_state(new_state);

    hasap = now_ap;
}

void UIStatsinfo::update_simple(StatLabel label, Maplestat::Id stat)
{
    statlabels[label].change_text(std::to_string(stats.get_stat(stat)));
}

void UIStatsinfo::update_basevstotal(StatLabel label,
                                     Maplestat::Id bstat,
                                     Equipstat::Id tstat)
{
    std::int32_t base = stats.get_stat(bstat);
    std::int32_t total = stats.get_total(tstat);
    std::int32_t delta = total - base;

    statlabels[label].change_text(
        delta ? str::concat(std::to_string(total),
                            " (",
                            std::to_string(base),
                            delta > 0 ? " + " : " - ",
                            std::to_string(std::abs(delta)),
                            ')')
              : std::to_string(total));
}

void UIStatsinfo::update_buffed(StatLabel label, Equipstat::Id stat)
{
    std::int32_t total = stats.get_total(stat);
    std::int32_t delta = stats.get_buff_delta(stat);

    statlabels[label].change_text(
        delta ? str::concat(std::to_string(total),
                            " (",
                            std::to_string(total - delta),
                            delta > 0 ? " + " : " - ",
                            std::to_string(std::abs(delta)),
                            ')')
              : std::to_string(total));

    if (delta > 0) {
        statlabels[label].change_color(Text::RED);
    } else if (delta < 0) {
        statlabels[label].change_color(Text::BLUE);
    }
}
} // namespace jrc

```

`IO/UITypes/UIStatsInfo.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/CharStats.h"
#include "../../Graphics/Text.h"
#include "../UIDragElement.h"

namespace jrc
{
class UIStatsinfo : public UIDragElement<Configuration::PositionOf::STATS>
{
public:
    static constexpr const Type TYPE = STATS_INFO;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UIStatsinfo(const CharStats& stats);

    void draw(float alpha) const override;

    void update_all_stats();
    void update_stat(Maplestat::Id stat);

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    static constexpr const std::size_t NUMLABELS = 27;
    static constexpr const std::size_t NUMNORMAL = 12;
    static constexpr const std::size_t NUMDETAIL = 15;

    enum StatLabel {
        // Normal
        NAME,
        JOB,
        GUILD,
        FAME,
        DAMAGE,
        HP,
        MP,
        AP,
        STR,
        DEX,
        INT,
        LUK,
        // Detailed
        ATTACK,
        CRIT,
        MINCRIT,
        MAXCRIT,
        BDM,
        IGNOREDEF,
        RESIST,
        STANCE,
        WDEF,
        MDEF,
        ACCURACY,
        AVOID,
        SPEED,
        JUMP,
        HONOR
    };

    void update_ap();
    void update_simple(StatLabel label, Maplestat::Id stat);
    void update_basevstotal(StatLabel label,
                            Maplestat::Id bstat,
                            Equipstat::Id tstat);
    void update_buffed(StatLabel label, Equipstat::Id stat);
    void send_apup(Maplestat::Id stat) const;

    enum Buttons {
        BT_HP,
        BT_MP,
        BT_STR,
        BT_DEX,
        BT_INT,
        BT_LUK,
        BT_DETAILOPEN,
        BT_DETAILCLOSE,
        NUM_BUTTONS
    };

    const CharStats& stats;

    enum Ability { RARE, EPIC, UNIQUE, LEGENDARY, NONE, NUM_ABILITIES };

    std::array<Texture, NUM_ABILITIES> abilities;

    std::vector<Texture> textures_detail;
    bool showdetail;

    bool hasap;

    Text statlabels[NUMLABELS];
    Point<std::int16_t> statoffsets[NUMLABELS];
};
} // namespace jrc

```

`IO/UITypes/UIStatusBar.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIStatusBar.h"

#include "../../Character/ExpTable.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "UIChangeChannel.h"
#include "UISystemSettings.h"
#include "nlnx/nx.hpp"

#include <string_view>

namespace jrc
{
constexpr Point<std::int16_t> UIStatusbar::POSITION;
constexpr Point<std::int16_t> UIStatusbar::DIMENSION;

UIStatusbar::UIStatusbar(const CharStats& st)
    : UIElement{POSITION, DIMENSION}, stats{st}, chatbar{POSITION}
{
    nl::node mainbar = nl::nx::ui["StatusBar2.img"]["mainBar"];

    sprites.emplace_back(mainbar["backgrnd"]);
    sprites.emplace_back(mainbar["gaugeBackgrd"]);
    sprites.emplace_back(mainbar["notice"]);
    sprites.emplace_back(mainbar["lvBacktrnd"]);
    sprites.emplace_back(mainbar["lvCover"]);

    auto gauge_src = mainbar["gauge"];

    auto exp_bar_src = gauge_src["exp"];
    expbar = {exp_bar_src["0"], exp_bar_src["1"], exp_bar_src["2"], 308, 0.0f};
    auto hp_bar_src = gauge_src["hp"];
    hpbar = {hp_bar_src["0"], hp_bar_src["1"], hp_bar_src["2"], 137, 0.0f};
    auto mp_bar_src = gauge_src["mp"];
    mpbar = {mp_bar_src["0"], mp_bar_src["1"], mp_bar_src["2"], 137, 0.0f};

    statset = {gauge_src["number"], Charset::RIGHT};
    levelset = {mainbar["lvNumber"], Charset::LEFT};

    joblabel = {Text::A11M, Text::LEFT, Text::YELLOW};
    namelabel = {Text::A13M, Text::LEFT, Text::WHITE};

    buttons[BT_WHISPER] = std::make_unique<MapleButton>(mainbar["BtChat"]);
    buttons[BT_CALL_GM] = std::make_unique<MapleButton>(mainbar["BtClaim"]);
    buttons[BT_NOTICE] = std::make_unique<MapleButton>(mainbar["BtNotice"]);
    buttons[BT_MAPLE_TALK]
        = std::make_unique<MapleButton>(mainbar["BtMapleTalk"]);

    buttons[BT_CASHSHOP]
        = std::make_unique<MapleButton>(mainbar["BtCashShop"]);
    buttons[BT_TRADE] = std::make_unique<MapleButton>(mainbar["BtMTS"]);
    buttons[BT_MENU] = std::make_unique<MapleButton>(mainbar["BtMenu"]);
    buttons[BT_OPTIONS] = std::make_unique<MapleButton>(mainbar["BtSystem"]);

    buttons[BT_CHARACTER]
        = std::make_unique<MapleButton>(mainbar["BtCharacter"]);
    buttons[BT_STATS] = std::make_unique<MapleButton>(mainbar["BtStat"]);
    buttons[BT_QUEST] = std::make_unique<MapleButton>(mainbar["BtQuest"]);
    buttons[BT_INVENTORY] = std::make_unique<MapleButton>(mainbar["BtInven"]);
    buttons[BT_EQUIPS] = std::make_unique<MapleButton>(mainbar["BtEquip"]);
    buttons[BT_SKILL] = std::make_unique<MapleButton>(mainbar["BtSkill"]);

    buttons[BT_KEYSETTING]
        = std::make_unique<MapleButton>(mainbar["BtKeysetting"]);
    buttons[BT_CHANNEL] = std::make_unique<MapleButton>(mainbar["BtChannel"]);
    buttons[BT_HOME] = std::make_unique<MapleButton>(mainbar["BtFarm"]);
}

void UIStatusbar::draw(float alpha) const
{
    UIElement::draw(alpha);

    expbar.draw(position + Point<std::int16_t>{-261, -15});
    hpbar.draw(position + Point<std::int16_t>{-261, -31});
    mpbar.draw(position + Point<std::int16_t>{-90, -31});

    std::int16_t level = stats.get_stat(Maplestat::LEVEL);
    std::int16_t hp = stats.get_stat(Maplestat::HP);
    std::int16_t mp = stats.get_stat(Maplestat::MP);
    std::int32_t max_hp = stats.get_total(Equipstat::HP);
    std::int32_t max_mp = stats.get_total(Equipstat::MP);
    std::int64_t exp = stats.get_exp();

    std::string exp_string = std::to_string(100.0f * get_exp_percent());
    statset.draw(
        str::concat(
            std::to_string(exp),
            '[',
            std::string_view(exp_string).substr(0, exp_string.find('.') + 3),
            "%]"),
        position + Point<std::int16_t>{47, -13});
    statset.draw(
        str::concat('[', std::to_string(hp), '/', std::to_string(max_hp), ']'),
        position + Point<std::int16_t>{-124, -29});
    statset.draw(
        str::concat('[', std::to_string(mp), '/', std::to_string(max_mp), ']'),
        position + Point<std::int16_t>{47, -29});
    levelset.draw(std::to_string(level),
                  position + Point<std::int16_t>{-480, -24});

    joblabel.draw(position + Point<std::int16_t>{-435, -21});
    namelabel.draw(position + Point<std::int16_t>{-435, -36});

    chatbar.draw(alpha);
}

void UIStatusbar::update()
{
    UIElement::update();

    chatbar.update();

    expbar.update(get_exp_percent());
    hpbar.update(get_hp_percent());
    mpbar.update(get_mp_percent());

    namelabel.change_text(std::string{stats.get_name()});
    joblabel.change_text(std::string{stats.get_job_name()});

    for (auto iter : message_cooldowns) {
        iter.second -= Constants::TIMESTEP;
    }
}

Button::State UIStatusbar::button_pressed(std::uint16_t id)
{
    switch (id) {
    case BT_STATS:
        UI::get().send_menu(KeyAction::CHAR_STATS);
        return Button::NORMAL;
    case BT_INVENTORY:
        UI::get().send_menu(KeyAction::INVENTORY);
        return Button::NORMAL;
    case BT_EQUIPS:
        UI::get().send_menu(KeyAction::EQUIPMENT_TAB);
        return Button::NORMAL;
    case BT_SKILL:
        UI::get().send_menu(KeyAction::SKILL_TAB);
        return Button::NORMAL;
    case BT_KEYSETTING:
        UI::get().send_menu(KeyAction::KEY_CONFIG);
        return Button::NORMAL;
    case BT_MENU:
        UI::get().send_menu(KeyAction::MAIN_MENU);
        return Button::NORMAL;
    case BT_OPTIONS:
        UI::get().emplace<UISystemSettings>();
        return Button::NORMAL;
    case BT_CHANNEL:
        UI::get().emplace<UIChangeChannel>();
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

bool UIStatusbar::is_in_range(Point<std::int16_t> cursorpos) const
{
    Rectangle<std::int16_t> bounds(position - Point<std::int16_t>{512, 84},
                                   position - Point<std::int16_t>{512, 84}
                                       + dimension);

    return bounds.contains(cursorpos) || chatbar.is_in_range(cursorpos);
}

bool UIStatusbar::remove_cursor(bool clicked, Point<std::int16_t> cursorpos)
{
    if (chatbar.remove_cursor(clicked, cursorpos)) {
        return true;
    }

    return UIElement::remove_cursor(clicked, cursorpos);
}

Cursor::State UIStatusbar::send_cursor(bool pressed,
                                       Point<std::int16_t> cursorpos)
{
    if (chatbar.is_in_range(cursorpos)) {
        UIElement::send_cursor(pressed, cursorpos);
        return chatbar.send_cursor(pressed, cursorpos);
    } else {
        chatbar.send_cursor(pressed, cursorpos);
        return UIElement::send_cursor(pressed, cursorpos);
    }
}

void UIStatusbar::send_chatline(std::string&& line, UIChatbar::LineType type)
{
    chatbar.send_line(std::move(line), type);
}

void UIStatusbar::display_message(Messages::Type line,
                                  UIChatbar::LineType type)
{
    if (message_cooldowns[line] > 0) {
        return;
    }

    chatbar.send_line(std::string{Messages::messages[line]}, type);

    message_cooldowns[line] = MESSAGE_COOLDOWN;
}

float UIStatusbar::get_exp_percent() const
{
    std::size_t level = stats.get_stat(Maplestat::LEVEL);
    if (level >= ExpTable::LEVELCAP) {
        return 0.0f;
    }

    return static_cast<float>(stats.get_exp())
           / static_cast<float>(ExpTable::values[level]);
}

float UIStatusbar::get_hp_percent() const
{
    std::int16_t hp = stats.get_stat(Maplestat::HP);
    std::int32_t max_hp = stats.get_total(Equipstat::HP);

    return static_cast<float>(hp) / max_hp;
}

float UIStatusbar::get_mp_percent() const
{
    std::int16_t mp = stats.get_stat(Maplestat::MP);
    std::int32_t max_mp = stats.get_total(Equipstat::MP);

    return static_cast<float>(mp) / max_mp;
}
} // namespace jrc

```

`IO/UITypes/UIStatusBar.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/CharStats.h"
#include "../../Character/Inventory/Inventory.h"
#include "../../Character/Job.h"
#include "../../Graphics/Animation.h"
#include "../../Graphics/Text.h"
#include "../Components/Charset.h"
#include "../Components/Gauge.h"
#include "../Components/Textfield.h"
#include "../Messages.h"
#include "../UIElement.h"
#include "UIChatBar.h"

namespace jrc
{
class UIStatusbar : public UIElement
{
public:
    static constexpr const Type TYPE = STATUS_BAR;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UIStatusbar(const CharStats& stats);

    void draw(float alpha) const override;
    void update() override;

    bool is_in_range(Point<std::int16_t> cursorpos) const override;
    bool remove_cursor(bool clicked, Point<std::int16_t> cursorpos) override;
    Cursor::State send_cursor(bool pressed,
                              Point<std::int16_t> cursorpos) override;

    void send_chatline(std::string&& line, UIChatbar::LineType type);
    void display_message(Messages::Type line, UIChatbar::LineType type);

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    float get_exp_percent() const;
    float get_hp_percent() const;
    float get_mp_percent() const;

    enum Buttons : std::uint16_t {
        BT_WHISPER,
        BT_CALL_GM,
        BT_NOTICE,
        BT_MAPLE_TALK,
        BT_CASHSHOP,
        BT_TRADE,
        BT_MENU,
        BT_OPTIONS,
        BT_CHARACTER,
        BT_STATS,
        BT_QUEST,
        BT_INVENTORY,
        BT_EQUIPS,
        BT_SKILL,
        BT_KEYSETTING,
        BT_CHANNEL,
        BT_HOME
    };

    static constexpr const Point<std::int16_t> POSITION
        = {512, 758}; // {512, 590}
    static constexpr const Point<std::int16_t> DIMENSION = {1366, 80};
    static constexpr const time_t MESSAGE_COOLDOWN = 1'000;

    const CharStats& stats;

    EnumMap<Messages::Type, time_t> message_cooldowns;

    UIChatbar chatbar;
    Gauge expbar;
    Gauge hpbar;
    Gauge mpbar;
    Charset statset;
    Charset levelset;
    Text namelabel;
    Text joblabel;
    Animation hpanimation;
    Animation mpanimation;
};
} // namespace jrc

```

`IO/UITypes/UIStatusMessenger.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIStatusMessenger.h"

#include "../../Constants.h"

namespace jrc
{
StatusInfo::StatusInfo(std::string&& str, Text::Color color)
{
    text = {Text::A12M, Text::RIGHT, color, std::string{str}};
    shadow = {Text::A12M, Text::RIGHT, Text::BLACK, std::move(str)};
    opacity.set(1.0f);
}

void StatusInfo::draw(Point<std::int16_t> position, float alpha) const
{
    float inter_opc = opacity.get(alpha);
    shadow.draw({position + 1, inter_opc});
    text.draw({position, inter_opc});
}

bool StatusInfo::update()
{
    static constexpr const float FADE_STEP
        = Constants::TIMESTEP * 1.0f / FADE_DURATION;

    opacity -= FADE_STEP;
    return opacity.last() < FADE_STEP;
}

UIStatusMessenger::UIStatusMessenger() noexcept
{
    position = {1020, 660};
}

void UIStatusMessenger::draw(float inter) const
{
    Point<std::int16_t> info_pos = {position.x(), position.y()};
    for (const StatusInfo& info : status_infos) {
        info.draw(info_pos, inter);
        info_pos.shift_y(-16);
    }
}

void UIStatusMessenger::update()
{
    for (StatusInfo& info : status_infos) {
        info.update();
    }
}

void UIStatusMessenger::show_status(Text::Color color, std::string&& message)
{
    status_infos.emplace_front(std::move(message), color);

    if (status_infos.size() > MAX_MESSAGES) {
        status_infos.pop_back();
    }
}
} // namespace jrc

```

`IO/UITypes/UIStatusMessenger.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "../../Template/Interpolated.h"
#include "../UIElement.h"

#include <deque>

namespace jrc
{
class StatusInfo
{
public:
    StatusInfo(std::string&& str, Text::Color color);

    void draw(Point<std::int16_t> position, float alpha) const;
    bool update();

private:
    Text text;
    Text shadow;
    Linear<float> opacity;

    //! 8 seconds.
    static constexpr std::int64_t FADE_DURATION = 8'000;
};

class UIStatusMessenger : public UIElement
{
public:
    static constexpr Type TYPE = STATUS_MESSENGER;
    static constexpr bool FOCUSED = false;
    static constexpr bool TOGGLED = false;

    UIStatusMessenger() noexcept;

    void draw(float alpha) const override;
    void update() override;

    void show_status(Text::Color color, std::string&& message);

private:
    static constexpr const std::size_t MAX_MESSAGES = 5;

    std::deque<StatusInfo> status_infos;
};
} // namespace jrc

```

`IO/UITypes/UISystemMenu.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UISystemMenu.h"

#include "../UI.h"
#include "UIChangeChannel.h"
#include "UIGameSettings.h"
#include "UINotice.h"
#include "UISystemSettings.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UISystemMenu::UISystemMenu() : UIElement{POSITION, {WIDTH, HEIGHT}, true}
{
    nl::node source = nl::nx::ui["StatusBar2.img"]["mainBar"]["System"];

    nl::node background = source["backgrnd"];
    top = background["0"];
    mid = background["1"];
    bottom = background["2"];

    std::int16_t y_offset = PADDING_TOP;
    for (std::uint16_t i = 0; i < NUM_BUTTONS; ++i) {
        buttons[i] = std::make_unique<MapleButton>(
            source[BUTTON_SRC_NAMES[i]],
            Point<std::int16_t>{BUTTON_PADDING_HORIZ, y_offset});
        y_offset += STRIDE_VERT;
    }
}

void UISystemMenu::draw(float inter) const
{
    Point<std::int16_t> bg_pos{POSITION};

    top.draw({bg_pos});
    bg_pos += {0, top.height()};

    std::int16_t mid_height = HEIGHT - top.height() - bottom.height();
    mid.draw({bg_pos, {0, mid_height}});
    bg_pos += {0, mid_height};

    bottom.draw({bg_pos});

    UIElement::draw_buttons(inter);
}

bool UISystemMenu::remove_cursor(bool clicked, Point<std::int16_t> cursor_pos)
{
    if (clicked) {
        if (!ACTIVATION_BUTTON_AREA.contains(cursor_pos)) {
            active = false;
        }
    }

    return UIElement::remove_cursor(clicked, cursor_pos);
}

Button::State UISystemMenu::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case BT_CHANNEL:
        UI::get().emplace<UIChangeChannel>();
        break;
    case BT_FARM:
        // Domiciles???
        break;
    case BT_KEY_SETTING:
        UI::get().send_menu(KeyAction::KEY_CONFIG);
        break;
    case BT_GAME_OPTION:
        UI::get().emplace<UIGameSettings>();
        break;
    case BT_SYSTEM_OPTION:
        UI::get().emplace<UISystemSettings>();
        break;
    case BT_QUIT:
        UI::get().emplace<UIYesNo>("Are you sure you want to exit the game?",
                                   [](bool yes) {
                                       if (yes) {
                                           UI::get().quit();
                                       }
                                   });
        break;
    }

    active = false;

    return Button::NORMAL;
}
} // namespace jrc

```

`IO/UITypes/UISystemMenu.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Texture.h"
#include "../Components/MapleButton.h"
#include "../UIElement.h"

#include <string_view>

namespace jrc
{
class UISystemMenu : public UIElement
{
public:
    static constexpr const Type TYPE = SYSTEM_MENU;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UISystemMenu();

    void draw(float inter) const override;
    bool remove_cursor(bool clicked, Point<std::int16_t> cursor_pos) override;

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    Texture top;
    Texture mid;
    Texture bottom;

    enum Buttons : std::uint16_t {
        BT_CHANNEL,
        BT_FARM,
        BT_KEY_SETTING,
        BT_GAME_OPTION,
        BT_SYSTEM_OPTION,
        BT_QUIT,
        NUM_BUTTONS
    };

    static constexpr const std::array<std::string_view, NUM_BUTTONS>
        BUTTON_SRC_NAMES{{"BtChannel",
                          "BtMonsterLife",
                          "BtKeySetting",
                          "BtGameOption",
                          "BtSystemOption",
                          "BtGameQuit"}};

    static constexpr const std::int16_t WIDTH = 79;
    static constexpr const std::int16_t BUTTON_PADDING_HORIZ = 8;

    static constexpr const std::int16_t PADDING_TOP = 20;
    static constexpr const std::int16_t STRIDE_VERT = 27;
    static constexpr const std::int16_t PADDING_BOTTOM = 12;
    static constexpr const std::int16_t HEIGHT
        = PADDING_TOP + STRIDE_VERT * NUM_BUTTONS + PADDING_BOTTOM;

    static constexpr const Point<std::int16_t> POSITION{673, 527};

    static constexpr const std::int16_t ACTIVATION_BUTTON_WIDTH = 55;
    static constexpr const std::int16_t ACTIVATION_BUTTON_HEIGHT = 35;
    static constexpr const Rectangle<std::int16_t> ACTIVATION_BUTTON_AREA{
        POSITION + Point<std::int16_t>{WIDTH / 2, HEIGHT}
            + Point<std::int16_t>{-ACTIVATION_BUTTON_WIDTH / 2, 0},
        POSITION + Point<std::int16_t>{WIDTH / 2, HEIGHT}
            + Point<std::int16_t>{ACTIVATION_BUTTON_WIDTH / 2,
                                  ACTIVATION_BUTTON_HEIGHT}};
};
} // namespace jrc

```

`IO/UITypes/UISystemSettings.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UISystemSettings.h"

#include "../../Configuration.h"
#include "../../Gameplay/Stage.h"
#include "../../Net/Packets/GameplayPackets.h"
#include "../Components/MapleButton.h"
#include "../UI.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UISystemSettings::UISystemSettings()
    : UIDragElement<Configuration::PositionOf::SYSTEM_SETTINGS>{DRAG_AREA}
{
    nl::node source = nl::nx::ui["UIWindow2.img"]["SysOpt"];

    sprites.emplace_back(source["backgrnd"]);
    sprites.emplace_back(source["backgrnd2"]);

    buttons[BT_CANCEL]
        = std::make_unique<MapleButton>(source["BtCancle" /* [sic] */]);
    buttons[BT_OK] = std::make_unique<MapleButton>(source["BtOK"]);

    nl::node scroll_src = source["scroll"];
    sliders[PIC_QUALITY] = {scroll_src,
                            {SLIDER_LEFT, SLIDER_RIGHT},
                            SLIDER_Y_OFFSET,
                            0,
                            1,
                            [](std::int16_t, bool) {}};
    sliders[BGM_VOL] = {scroll_src,
                        {SLIDER_LEFT, SLIDER_RIGHT_SHORT},
                        SLIDER_Y_OFFSET + SLIDER_STRIDE * 2,
                        0,
                        50,
                        [](std::int16_t new_col, bool) {
                            Music::set_bgm_volume(new_col * 2);
                        }};
    sliders[SFX_VOL] = {scroll_src,
                        {SLIDER_LEFT, SLIDER_RIGHT_SHORT},
                        SLIDER_Y_OFFSET + SLIDER_STRIDE * 3,
                        0,
                        50,
                        [](std::int16_t new_col, bool) {
                            Sound::set_sfx_volume(new_col * 2);
                        }};
    sliders[CURSOR_SPEED] = {scroll_src,
                             {SLIDER_LEFT, SLIDER_RIGHT},
                             SLIDER_Y_OFFSET + SLIDER_STRIDE * 5,
                             0,
                             2,
                             [](std::int16_t, bool) {}};
    sliders[HP_ALERT] = {scroll_src,
                         {SLIDER_LEFT, SLIDER_RIGHT},
                         SLIDER_Y_OFFSET + SLIDER_STRIDE * 6,
                         0,
                         50,
                         [](std::int16_t, bool) {}};
    sliders[MP_ALERT] = {scroll_src,
                         {SLIDER_LEFT, SLIDER_RIGHT},
                         SLIDER_Y_OFFSET + SLIDER_STRIDE * 7,
                         0,
                         50,
                         [](std::int16_t, bool) {}};

    check_texture = source["check"];

    load_settings();

    dimension = {WIDTH, HEIGHT};
    active = true;
}

void UISystemSettings::draw(float inter) const
{
    UIElement::draw(inter);

    for (std::uint16_t check = 0; check < NUM_CHECKS; ++check) {
        bool checked = checks_state & static_cast<std::uint16_t>(1 << check);
        check_texture.draw(
            {position + CHECK_POSITIONS[check], checked ? 1.0f : 0.1f});
    }

    for (const auto slider_iter : sliders) {
        slider_iter.second.draw(position);
    }
}

Cursor::State UISystemSettings::send_cursor(bool pressed,
                                            Point<std::int16_t> cursor_pos)
{
    Cursor::State drag_state = UIDragElement::send_cursor(pressed, cursor_pos);
    if (dragged) {
        return drag_state;
    }

    const auto normalized = cursor_pos - position;
    for (auto slider_iter : sliders) {
        if (Cursor::State slider_state
            = slider_iter.second.send_cursor(normalized, pressed);
            slider_state != Cursor::IDLE) {
            return slider_state;
        }
    }

    if (auto check = check_by_pos(normalized); check) {
        if (pressed) {
            switch (auto c = *check; c) {
            case RESOLUTION_800_600:
                checks_state
                    |= static_cast<std::uint16_t>(1 << RESOLUTION_800_600);
                checks_state
                    &= ~static_cast<std::uint16_t>(1 << RESOLUTION_1024_768);
                break;
            case RESOLUTION_1024_768:
                checks_state
                    |= static_cast<std::uint16_t>(1 << RESOLUTION_1024_768);
                checks_state
                    &= ~static_cast<std::uint16_t>(1 << RESOLUTION_800_600);
                break;
            case WINDOWED:
                checks_state |= static_cast<std::uint16_t>(1 << WINDOWED);
                checks_state &= ~static_cast<std::uint16_t>(1 << FULL_SCREEN);
                break;
            case FULL_SCREEN:
                checks_state |= static_cast<std::uint16_t>(1 << FULL_SCREEN);
                checks_state &= ~static_cast<std::uint16_t>(1 << WINDOWED);
                break;
            case MINIMAP_NORMAL:
                checks_state
                    |= static_cast<std::uint16_t>(1 << MINIMAP_NORMAL);
                checks_state
                    &= ~static_cast<std::uint16_t>(1 << MINIMAP_SIMPLE);
                break;
            case MINIMAP_SIMPLE:
                checks_state
                    |= static_cast<std::uint16_t>(1 << MINIMAP_SIMPLE);
                checks_state
                    &= ~static_cast<std::uint16_t>(1 << MINIMAP_NORMAL);
                break;
            default:
                checks_state ^= static_cast<std::uint16_t>(1 << c);
                break;
            }
        }
        return Cursor::CAN_CLICK;
    }

    return Cursor::IDLE;
}

Button::State UISystemSettings::button_pressed(std::uint16_t button_id)
{
    switch (button_id) {
    case BT_CANCEL:
        active = false;
        load_settings();
        return Button::NORMAL;
    case BT_OK:
        commit();
        active = false;
        return Button::NORMAL;
    default:
        return Button::PRESSED;
    }
}

void UISystemSettings::load_settings() noexcept
{
    checks_state = 0b00000000'00000000;

    sliders[PIC_QUALITY].set_cols(
        Configuration::get().video.low_quality ? 0 : 1, 0, 1);
    checks_state |= 1 << RESOLUTION_1024_768;
    sliders[BGM_VOL].set_cols(
        Configuration::get().audio.volume.music / 2, 0, 50);
    Music::set_bgm_volume(Configuration::get().audio.volume.music);
    if (!Configuration::get().audio.music) {
        checks_state |= 1 << BGM_MUTE;
    }
    sliders[SFX_VOL].set_cols(
        Configuration::get().audio.volume.sound_effects / 2, 0, 50);
    Sound::set_sfx_volume(Configuration::get().audio.volume.sound_effects);
    if (!Configuration::get().audio.sound_effects) {
        checks_state |= 1 << SFX_MUTE;
    }
    sliders[CURSOR_SPEED].set_cols(1, 0, 2);
    sliders[CURSOR_SPEED].set_enabled(false);
    sliders[HP_ALERT].set_cols(Configuration::get().ui.hp_alert / 2, 0, 50);
    sliders[MP_ALERT].set_cols(Configuration::get().ui.mp_alert / 2, 0, 50);
    if (Configuration::get().ui.shake_screen) {
        checks_state |= 1 << SHAKE_SCREEN;
    }
    if (Configuration::get().video.fullscreen) {
        checks_state |= 1 << FULL_SCREEN;
    } else {
        checks_state |= 1 << WINDOWED;
    }
    if (Configuration::get().ui.simple_minimap) {
        checks_state |= 1 << MINIMAP_SIMPLE;
    } else {
        checks_state |= 1 << MINIMAP_NORMAL;
    }
}

void UISystemSettings::commit() const noexcept
{
    Configuration::get().video.low_quality
        = sliders[PIC_QUALITY].get_col() == 0;
    Configuration::get().audio.volume.music = sliders[BGM_VOL].get_col() * 2;
    Music::set_bgm_volume(Configuration::get().audio.volume.music);
    Configuration::get().audio.music = !(checks_state & (1 << BGM_MUTE));
    Configuration::get().audio.volume.sound_effects
        = sliders[SFX_VOL].get_col() * 2;
    Sound::set_sfx_volume(Configuration::get().audio.volume.sound_effects);
    Configuration::get().audio.sound_effects
        = !(checks_state & (1 << SFX_MUTE));
    Configuration::get().ui.hp_alert = sliders[HP_ALERT].get_col() * 2;
    Configuration::get().ui.mp_alert = sliders[MP_ALERT].get_col() * 2;
    Configuration::get().ui.shake_screen = checks_state & (1 << SHAKE_SCREEN);
    Configuration::get().video.fullscreen = checks_state & (1 << FULL_SCREEN);
    Configuration::get().ui.simple_minimap
        = checks_state & (1 << MINIMAP_SIMPLE);
}

std::optional<UISystemSettings::Checks>
UISystemSettings::check_by_pos(Point<std::int16_t> pos) noexcept
{
    if (auto check_pos_iter = std::find_if(
            CHECK_POSITIONS.begin(),
            CHECK_POSITIONS.end(),
            [pos](auto p) {
                return Rectangle<std::int16_t>{p, p + CHECK_SIDE_LEN}.contains(
                    pos);
            });
        check_pos_iter != CHECK_POSITIONS.end()) {
        return {static_cast<Checks>(check_pos_iter - CHECK_POSITIONS.begin())};
    }

    return {};
}
} // namespace jrc

```

`IO/UITypes/UISystemSettings.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2018-2019 LibreMaple Team                                    //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Template/EnumMap.h"
#include "../Components/SliderHoriz.h"
#include "../UIDragElement.h"

#include <algorithm>
#include <optional>

namespace jrc
{
//! UI popup for changing game system settings.
class UISystemSettings
    : public UIDragElement<Configuration::PositionOf::SYSTEM_SETTINGS>
{
public:
    static constexpr const Type TYPE = SYSTEM_SETTINGS;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = true;

    UISystemSettings();

    void draw(float inter) const override;
    Cursor::State send_cursor(bool clicked,
                              Point<std::int16_t> cursor_pos) override;

    enum Checks : std::uint16_t {
        RESOLUTION_800_600,
        RESOLUTION_1024_768,
        BGM_MUTE,
        SFX_MUTE,
        SHAKE_SCREEN,
        WINDOWED,
        FULL_SCREEN,
        MINIMAP_NORMAL,
        MINIMAP_SIMPLE,

        NUM_CHECKS
    };

protected:
    Button::State button_pressed(std::uint16_t button_id) override;

private:
    void load_settings() noexcept;
    void commit() const noexcept;
    //! Takes a normalized position.
    [[nodiscard]] static std::optional<Checks>
    check_by_pos(Point<std::int16_t> pos) noexcept;

    enum Slider : std::uint8_t {
        PIC_QUALITY,
        BGM_VOL,
        SFX_VOL,
        CURSOR_SPEED,
        HP_ALERT,
        MP_ALERT,

        NUM_SLIDERS
    };

    EnumMap<Slider, SliderHoriz, NUM_SLIDERS> sliders;

    Texture check_texture;
    std::uint16_t checks_state;

    enum Buttons : std::uint16_t { BT_CANCEL, BT_OK };

    static constexpr const std::int16_t WIDTH = 283;
    static constexpr const std::int16_t SLIDER_LEFT = 96;
    static constexpr const std::int16_t SLIDER_RIGHT = 206;
    static constexpr const std::int16_t SLIDER_RIGHT_SHORT = 160;

    static constexpr const std::int16_t HEIGHT = 419;
    static constexpr const std::int16_t DRAG_HEIGHT = 17;
    static constexpr const std::int16_t SLIDER_Y_OFFSET = 31;
    static constexpr const std::int16_t SLIDER_STRIDE = 30;

    static constexpr const std::int16_t CHECK_SIDE_LEN = 6;

    static constexpr const Point<std::int16_t> DRAG_AREA{WIDTH, DRAG_HEIGHT};
    static constexpr const std::array<Point<std::int16_t>, NUM_CHECKS>
        CHECK_POSITIONS{{{69, 64},
                         {169, 64},
                         {227, 94},
                         {227, 124},
                         {69, 274},
                         {69, 327},
                         {69, 340},
                         {69, 365},
                         {151, 365}}};
};
} // namespace jrc

```

`IO/UITypes/UIWorldSelect.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "UIWorldSelect.h"

#include "../../Configuration.h"
#include "../../Constants.h"
#include "../../Gameplay/Stage.h"
#include "../../Graphics/Sprite.h"
#include "../../IO/Components/MapleButton.h"
#include "../../IO/Components/TwoSpriteButton.h"
#include "../../IO/UI.h"
#include "../../Net/Packets/LoginPackets.h"
#include "nlnx/nx.hpp"

namespace jrc
{
UIWorldSelect::UIWorldSelect(std::vector<World>&& worlds_)
    : UIElement({0, 0}, {Constants::VIEW_WIDTH, Constants::VIEW_HEIGHT}),
      worlds(std::move(worlds_))
{
    world_id = Configuration::get().account.world;
    channel_id = Configuration::get().account.channel;

    nl::node back = nl::nx::map["Back"]["login.img"]["back"];
    nl::node world_src
        = nl::nx::ui["Login.img"]["WorldSelect"]["BtWorld"]["release"];
    nl::node channel_src = nl::nx::ui["Login.img"]["WorldSelect"]["BtChannel"];
    nl::node frame = nl::nx::ui["Login.img"]["Common"]["frame"];

    sprites.emplace_back(back["11"], Point<std::int16_t>{370, 300});
    sprites.emplace_back(world_src["layer:bg"], Point<std::int16_t>{650, 45});
    sprites.emplace_back(frame, Point<std::int16_t>{400, 290});

    buttons[BT_ENTERWORLD] = std::make_unique<MapleButton>(
        channel_src["button:GoWorld"], Point<std::int16_t>{200, 170});

    if (worlds.size() <= 0) {
        return;
    }

    const World& world = worlds.front();

    buttons[BT_WORLD0] = std::make_unique<MapleButton>(
        world_src["button:15"], Point<std::int16_t>{650, 20});
    buttons[BT_WORLD0]->set_state(Button::PRESSED);

    sprites.emplace_back(channel_src["layer:bg"],
                         Point<std::int16_t>{200, 170});
    sprites.emplace_back(channel_src["release"]["layer:15"],
                         Point<std::int16_t>{200, 170});

    if (channel_id >= world.channel_count) {
        channel_id = 0;
    }

    for (std::uint8_t i = 0; i < world.channel_count; ++i) {
        nl::node ch_node = channel_src["button:" + std::to_string(i)];
        buttons[BT_CHANNEL0 + i]
            = std::make_unique<TwoSpriteButton>(ch_node["normal"]["0"],
                                                ch_node["keyFocused"]["0"],
                                                Point<std::int16_t>{200, 170});
        if (i == channel_id) {
            buttons[BT_CHANNEL0 + i]->set_state(Button::PRESSED);
        }
    }
}

void UIWorldSelect::draw(float alpha) const
{
    UIElement::draw(alpha);
}

std::uint8_t UIWorldSelect::get_world_id() const
{
    return world_id;
}

std::uint8_t UIWorldSelect::get_channel_id() const
{
    return channel_id;
}

Button::State UIWorldSelect::button_pressed(std::uint16_t id)
{
    if (id == BT_ENTERWORLD) {
        UI::get().disable();

        Stage::get().set_world(world_id);
        Stage::get().set_channel(channel_id);
        Stage::get().set_channel_count(worlds.at(world_id).channel_count);
        CharlistRequestPacket{world_id, channel_id}.dispatch();

        return Button::PRESSED;
    } else if (id >= BT_WORLD0 && id < BT_CHANNEL0) {
        buttons[BT_WORLD0 + world_id]->set_state(Button::NORMAL);
        world_id = static_cast<std::uint8_t>(id - BT_WORLD0);
        return Button::PRESSED;
    } else {
        buttons[BT_CHANNEL0 + channel_id]->set_state(Button::NORMAL);
        channel_id = static_cast<std::uint8_t>(id - BT_CHANNEL0);
        return Button::PRESSED;
    }
}
} // namespace jrc

```

`IO/UITypes/UIWorldSelect.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Net/Login.h"
#include "../UIElement.h"

namespace jrc
{
class UIWorldSelect : public UIElement
{
public:
    static constexpr const Type TYPE = WORLD_SELECT;
    static constexpr const bool FOCUSED = false;
    static constexpr const bool TOGGLED = false;

    UIWorldSelect(std::vector<World>&& worlds_);

    void draw(float alpha) const override;

    std::uint8_t get_world_id() const;
    std::uint8_t get_channel_id() const;

protected:
    Button::State button_pressed(std::uint16_t buttonid) override;

private:
    enum Buttons { BT_ENTERWORLD = 0, BT_WORLD0 = 1, BT_CHANNEL0 = 17 };

    std::vector<World> worlds;
    std::uint8_t world_id;
    std::uint8_t channel_id;
};
} // namespace jrc

```

`IO/Window.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Window.h"

#include "../Configuration.h"
#include "../Console.h"
#include "../Constants.h"
#include "../Graphics/GraphicsGL.h"
#include "../Util/Misc.h"
#include "UI.h"

#include <string_view>

namespace jrc
{
Window::Window()
    : glwnd{nullptr},
      context{nullptr},
      opacity{1.0f},
      opcstep{0.0f},
      width{Constants::VIEW_WIDTH},
      height{Constants::VIEW_HEIGHT}
{
}

Window::~Window()
{
    glfwTerminate();
}

Error Window::init()
{
    full_screen = Configuration::get().video.fullscreen;

    if (!glfwInit()) {
        return Error::GLFW;
    }

    glfwWindowHint(GLFW_VISIBLE, GL_FALSE);
    context = glfwCreateWindow(1, 1, "", nullptr, nullptr);
    glfwMakeContextCurrent(context);
    glfwSetErrorCallback([](int no, const char* description) noexcept {
        Console::get().print(str::concat("GLFW error: ",
                                         std::string_view{description},
                                         " (",
                                         std::to_string(no),
                                         ')'));
    });
    glfwWindowHint(GLFW_VISIBLE, GL_TRUE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

    if (Error error = GraphicsGL::get().init()) {
        return error;
    }

    return init_window();
}

Error Window::init_window()
{
    if (glwnd) {
        glfwDestroyWindow(glwnd);
    }

    glwnd = glfwCreateWindow(Constants::VIEW_WIDTH,
                             Constants::VIEW_HEIGHT,
                             "LibreMaple",
                             full_screen ? glfwGetPrimaryMonitor() : nullptr,
                             context);

    if (!glwnd) {
        return Error::WINDOW;
    }

    glfwMakeContextCurrent(glwnd);

    glfwSwapInterval(Configuration::get().video.vsync ? 1 : 0);

    glViewport(0, 0, Constants::VIEW_WIDTH, Constants::VIEW_HEIGHT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glfwSetInputMode(glwnd, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
    // glfwSetInputMode(glwnd, GLFW_STICKY_KEYS, 1);
    glfwSetKeyCallback(glwnd, [](GLFWwindow*, int key, int, int action, int) {
        UI::get().send_key(key, action != GLFW_RELEASE);
    });
    glfwSetMouseButtonCallback(glwnd,
                               [](GLFWwindow*, int button, int action, int) {
                                   switch (button) {
                                   case GLFW_MOUSE_BUTTON_LEFT:
                                       switch (action) {
                                       case GLFW_PRESS:
                                           UI::get().send_cursor(true);
                                           break;
                                       case GLFW_RELEASE:
                                           UI::get().send_cursor(false);
                                           break;
                                       default:
                                           break;
                                       }
                                       break;
                                   case GLFW_MOUSE_BUTTON_RIGHT:
                                       switch (action) {
                                       case GLFW_PRESS:
                                           UI::get().doubleclick();
                                           break;
                                       default:
                                           break;
                                       }
                                       break;
                                   default:
                                       break;
                                   }
                               });
    glfwSetCursorPosCallback(glwnd, [](GLFWwindow*, double xpos, double ypos) {
        UI::get().send_cursor({static_cast<std::int16_t>(xpos),
                               static_cast<std::int16_t>(ypos)});
    });

    GraphicsGL::get().reinit();

    return Error::NONE;
}

bool Window::not_closed() const
{
    return glfwWindowShouldClose(glwnd) == 0;
}

void Window::update()
{
    update_opc();
}

void Window::update_opc()
{
    if (opcstep != 0.0f) {
        opacity += opcstep;

        if (opacity >= 1.0f) {
            opacity = 1.0f;
            opcstep = 0.0f;
        } else if (opacity <= 0.0f) {
            opacity = 0.0f;
            opcstep = -opcstep;

            fade_procedure();
        }
    }
}

void Window::check_events()
{
    std::int32_t tabstate = glfwGetKey(glwnd, GLFW_KEY_F11);
    if (tabstate == GLFW_PRESS) {
        full_screen = !full_screen;
        init_window();
    }
    glfwPollEvents();
}

void Window::begin() const
{
    GraphicsGL::get().clearscene();
}

void Window::end() const
{
    GraphicsGL::get().flush(opacity);
    glfwSwapBuffers(glwnd);
}

void Window::fadeout(float step, std::function<void()> fade_proc)
{
    opcstep = -step;
    fade_procedure = std::move(fade_proc);
}

void Window::set_clipboard(const char* text) const
{
    glfwSetClipboardString(glwnd, text);
}
void Window::set_clipboard(const std::string& text) const
{
    glfwSetClipboardString(glwnd, text.c_str());
}

const char* Window::get_clipboard() const
{
    const char* text = glfwGetClipboardString(glwnd);
    return text ? text : "";
}

void Window::resize(bool in_game) noexcept
{
    if (in_game) {
        width = Constants::GAME_VIEW_WIDTH;
        height = Constants::GAME_VIEW_HEIGHT;
    } else {
        width = Constants::VIEW_WIDTH;
        height = Constants::VIEW_HEIGHT;
    }

    glfwSetWindowSize(glwnd, width, height);
    glViewport(0, 0, width, height);
    GraphicsGL::set_screen(0,
                           width,
                           -Constants::VIEW_Y_OFFSET,
                           -Constants::VIEW_Y_OFFSET + height);

    GraphicsGL::get().reinit();
}

std::int16_t Window::get_width() const noexcept
{
    return width;
}

std::int16_t Window::get_height() const noexcept
{
    return height;
}
} // namespace jrc

```

`IO/Window.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Error.h"
#include "../Template/Singleton.h"

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <functional>
#include <string>

namespace jrc
{
class Window : public Singleton<Window>
{
public:
    Window();
    ~Window() override;

    Error init();
    Error init_window();

    bool not_closed() const;
    void update();
    void begin() const;
    void end() const;
    void fadeout(float step, std::function<void()> fade_proc);
    void check_events();

    void set_clipboard(const char* text) const;
    void set_clipboard(const std::string& text) const;
    const char* get_clipboard() const;

    void resize(bool in_game) noexcept;
    std::int16_t get_width() const noexcept;
    std::int16_t get_height() const noexcept;

private:
    void update_opc();

    GLFWwindow* glwnd;
    GLFWwindow* context;
    bool full_screen;
    float opacity;
    float opcstep;
    std::function<void()> fade_procedure;

    std::int16_t width;
    std::int16_t height;
};
} // namespace jrc

```

`Journey.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Audio/Audio.h"
#include "Character/Char.h"
#include "Configuration.h"
#include "Constants.h"
#include "Error.h"
#include "Gameplay/Combat/DamageNumber.h"
#include "Gameplay/Stage.h"
#include "IO/UI.h"
#include "IO/Window.h"
#include "Net/Session.h"
#include "Timer.h"
#include "Util/NxFiles.h"

#include <iostream>

namespace jrc
{
Error init()
{
    if (Error error = Session::get().init(); error) {
        return error;
    }

    if (Error error = NxFiles::init(); error) {
        return error;
    }

    if (Error error = Window::get().init(); error) {
        return error;
    }

    if (Configuration::get().audio.sound_effects
        || Configuration::get().audio.music) {
        if (Error error = Sound::init(); error) {
            return error;
        }
    }

    if (Configuration::get().audio.sound_effects) {
        Sound::init_sfx();
    }
    if (Configuration::get().audio.music) {
        Music::init();
    }
    Char::init();
    DamageNumber::init();
    MapPortals::init();
    Stage::get().init();
    UI::get().init();

    return Error::NONE;
}

void update()
{
    Window::get().check_events();
    Window::get().update();
    Stage::get().update();
    UI::get().update();
    Session::get().read();
}

void draw(float alpha)
{
    Window::get().begin();
    Stage::get().draw(alpha);
    UI::get().draw(alpha);
    Window::get().end();
}

bool running()
{
    return Session::get().is_connected() && UI::get().not_quitted()
           && Window::get().not_closed();
}

void loop()
{
    Timer::get().start();
    std::int64_t timestep = Constants::TIMESTEP * 1'000;
    std::int64_t accumulator = timestep;

    std::int64_t period = 0;
    std::int32_t samples = 0;

    while (running()) {
        std::int64_t elapsed = Timer::get().stop();

        // Update game with constant timestep as many times as possible.
        for (accumulator += elapsed; accumulator >= timestep;
             accumulator -= timestep) {
            update();
        }

        // Draw the game. Interpolate to account for remaining time.
        float alpha = static_cast<float>(accumulator) / timestep;
        draw(alpha);

        if (samples < 100) {
            period += elapsed;
            ++samples;
        } else if (period) {
            // std::int64_t fps = (samples * 1000000) / period;
            // std::cout << "FPS: " << fps << '\n';

            period = 0;
            samples = 0;
        }
    }

    Sound::close();
}

void start()
{
    // Unsynchronize `std::cout`/`std::cin`/etc. with C stdio for performance
    // reasons.
    std::ios::sync_with_stdio(false);

    // Initialize and check for errors.
    if (Error error = init()) {
        const char* message = error.get_message();
        const char* args = error.get_args();
        const bool can_retry = error.can_retry();

        std::cout << "Error: " << message << args << '\n' << std::flush;

        std::string command;
        std::cin >> command;

        if (can_retry && command == "retry") {
            start();
        }
    } else {
        loop();
    }
}
} // namespace jrc

int main()
{
    jrc::start();
    return 0;
}

```

`Journey.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////

// Define things here.

//! JOURNEY_USE_ASIO : Use asio for networking, if not defined use Winsock.
#define JOURNEY_USE_ASIO

//! JOURNEY_USE_XXHASH : Use xxhash for file check (additional dependency)
//#define JOURNEY_USE_XXHASH

//! JOURNEY_USE_CRYPTO : Use cryptography for communication with the server.
#define JOURNEY_USE_CRYPTO

//! JOURNEY_PRINT_WARNINGS : Print warnings and minor errors to the console.
#define JOURNEY_PRINT_WARNINGS

```

`LICENSE`:

```
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<http://www.gnu.org/licenses/>.


```

`Net/Cryptography.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Cryptography.h"

namespace jrc
{
Cryptography::Cryptography(const std::int8_t* handshake)
{
#ifdef JOURNEY_USE_CRYPTO
    for (std::size_t i = 0; i < HEADER_LENGTH; ++i) {
        sendiv[i] = handshake[i + 7];
    }

    for (std::size_t i = 0; i < HEADER_LENGTH; ++i) {
        recviv[i] = handshake[i + 11];
    }
#endif
}

Cryptography::Cryptography() = default;

Cryptography::~Cryptography() = default;

void Cryptography::encrypt(std::int8_t* bytes, std::size_t length) noexcept
{
#ifdef JOURNEY_USE_CRYPTO
    mapleencrypt(bytes, length);
    aesofb(bytes, length, sendiv);
#endif
}

void Cryptography::decrypt(std::int8_t* bytes, std::size_t length)
{
#ifdef JOURNEY_USE_CRYPTO
    aesofb(bytes, length, recviv);
    mapledecrypt(bytes, length);
#endif
}

void Cryptography::create_header(std::int8_t* buffer, std::size_t length) const
    noexcept
{
#ifdef JOURNEY_USE_CRYPTO
    static constexpr const std::uint8_t MAPLE_VERSION = 83;

    std::size_t a = ((sendiv[3] << 8) | sendiv[2]) ^ MAPLE_VERSION;
    std::size_t b = a ^ length;
    buffer[0] = static_cast<std::int8_t>(a % 0x100);
    buffer[1] = static_cast<std::int8_t>(a / 0x100);
    buffer[2] = static_cast<std::int8_t>(b % 0x100);
    buffer[3] = static_cast<std::int8_t>(b / 0x100);
#else
    std::int32_t slength = static_cast<std::int32_t>(length);

    for (std::int32_t i = 0; i < HEADER_LENGTH; ++i) // HEADERLEN
    {
        buffer[i] = static_cast<std::int8_t>(slength);
        slength = slength >> 8;
    }
#endif
}

std::size_t Cryptography::check_length(const std::int8_t* bytes) const
{
#ifdef JOURNEY_USE_CRYPTO
    std::uint32_t headermask = 0;

    for (std::size_t i = 0; i < 4; ++i) {
        headermask |= static_cast<std::uint8_t>(bytes[i]) << (8 * i);
    }

    return static_cast<std::int16_t>((headermask >> 16)
                                     ^ (headermask & 0xFFFF));
#else
    std::size_t length = 0;

    for (std::int32_t i = 0; i < HEADER_LENGTH; ++i) // HEADERLEN
    {
        length += static_cast<std::uint8_t>(bytes[i]) << (8 * i);
    }

    return length;
#endif
}

void Cryptography::mapleencrypt(std::int8_t* bytes, std::size_t length) const
    noexcept
{
    for (std::size_t j = 0; j < 3; ++j) {
        std::int8_t remember = 0;
        std::int8_t datalen = static_cast<std::int8_t>(length & 0xFF);

        for (std::size_t i = 0; i < length; ++i) {
            std::int8_t cur = (rollleft(bytes[i], 3) + datalen) ^ remember;
            remember = cur;
            cur = rollright(cur, static_cast<std::int32_t>(datalen) & 0xFF);
            bytes[i] = static_cast<std::int8_t>((~cur) & 0xFF) + 0x48;
            --datalen;
        }

        remember = 0;
        datalen = static_cast<std::int8_t>(length & 0xFF);

        for (std::size_t i = length; i--;) {
            std::int8_t cur = (rollleft(bytes[i], 4) + datalen) ^ remember;
            remember = cur;
            bytes[i] = rollright(cur ^ 0x13, 3);
            --datalen;
        }
    }
}

void Cryptography::mapledecrypt(std::int8_t* bytes, std::size_t length) const
{
    for (std::size_t i = 0; i < 3; ++i) {
        std::uint8_t remember = 0;
        std::uint8_t datalen = static_cast<std::uint8_t>(length & 0xFF);

        for (std::size_t j = length; j--;) {
            std::uint8_t cur = rollleft(bytes[j], 3) ^ 0x13;
            bytes[j] = rollright((cur ^ remember) - datalen, 4);
            remember = cur;
            --datalen;
        }

        remember = 0;
        datalen = static_cast<std::uint8_t>(length & 0xFF);

        for (std::size_t j = 0; j < length; ++j) {
            std::uint8_t cur = (~(bytes[j] - 0x48)) & 0xFF;
            cur = rollleft(cur, static_cast<std::int32_t>(datalen) & 0xFF);
            bytes[j] = rollright((cur ^ remember) - datalen, 3);
            remember = cur;
            --datalen;
        }
    }
}

void Cryptography::updateiv(std::uint8_t* iv) const noexcept
{
    static const std::uint8_t maplebytes[256] = // This is called `funnyBytes`
                                                // in OdinMS-based sources.
        {0xEC, 0x3F, 0x77, 0xA4, 0x45, 0xD0, 0x71, 0xBF, 0xB7, 0x98, 0x20,
         0xFC, 0x4B, 0xE9, 0xB3, 0xE1, 0x5C, 0x22, 0xF7, 0x0C, 0x44, 0x1B,
         0x81, 0xBD, 0x63, 0x8D, 0xD4, 0xC3, 0xF2, 0x10, 0x19, 0xE0, 0xFB,
         0xA1, 0x6E, 0x66, 0xEA, 0xAE, 0xD6, 0xCE, 0x06, 0x18, 0x4E, 0xEB,
         0x78, 0x95, 0xDB, 0xBA, 0xB6, 0x42, 0x7A, 0x2A, 0x83, 0x0B, 0x54,
         0x67, 0x6D, 0xE8, 0x65, 0xE7, 0x2F, 0x07, 0xF3, 0xAA, 0x27, 0x7B,
         0x85, 0xB0, 0x26, 0xFD, 0x8B, 0xA9, 0xFA, 0xBE, 0xA8, 0xD7, 0xCB,
         0xCC, 0x92, 0xDA, 0xF9, 0x93, 0x60, 0x2D, 0xDD, 0xD2, 0xA2, 0x9B,
         0x39, 0x5F, 0x82, 0x21, 0x4C, 0x69, 0xF8, 0x31, 0x87, 0xEE, 0x8E,
         0xAD, 0x8C, 0x6A, 0xBC, 0xB5, 0x6B, 0x59, 0x13, 0xF1, 0x04, 0x00,
         0xF6, 0x5A, 0x35, 0x79, 0x48, 0x8F, 0x15, 0xCD, 0x97, 0x57, 0x12,
         0x3E, 0x37, 0xFF, 0x9D, 0x4F, 0x51, 0xF5, 0xA3, 0x70, 0xBB, 0x14,
         0x75, 0xC2, 0xB8, 0x72, 0xC0, 0xED, 0x7D, 0x68, 0xC9, 0x2E, 0x0D,
         0x62, 0x46, 0x17, 0x11, 0x4D, 0x6C, 0xC4, 0x7E, 0x53, 0xC1, 0x25,
         0xC7, 0x9A, 0x1C, 0x88, 0x58, 0x2C, 0x89, 0xDC, 0x02, 0x64, 0x40,
         0x01, 0x5D, 0x38, 0xA5, 0xE2, 0xAF, 0x55, 0xD5, 0xEF, 0x1A, 0x7C,
         0xA7, 0x5B, 0xA6, 0x6F, 0x86, 0x9F, 0x73, 0xE6, 0x0A, 0xDE, 0x2B,
         0x99, 0x4A, 0x47, 0x9C, 0xDF, 0x09, 0x76, 0x9E, 0x30, 0x0E, 0xE4,
         0xB2, 0x94, 0xA0, 0x3B, 0x34, 0x1D, 0x28, 0x0F, 0x36, 0xE3, 0x23,
         0xB4, 0x03, 0xD8, 0x90, 0xC8, 0x3C, 0xFE, 0x5E, 0x32, 0x24, 0x50,
         0x1F, 0x3A, 0x43, 0x8A, 0x96, 0x41, 0x74, 0xAC, 0x52, 0x33, 0xF0,
         0xD9, 0x29, 0x80, 0xB1, 0x16, 0xD3, 0xAB, 0x91, 0xB9, 0x84, 0x7F,
         0x61, 0x1E, 0xCF, 0xC5, 0xD1, 0x56, 0x3D, 0xCA, 0xF4, 0x05, 0xC6,
         0xE5, 0x08, 0x49};

    std::uint8_t mbytes[4] = // Called `in` in OdinMS-based sources. Local to
                             // the `getNewIv` method or similar.
        {0xF2, 0x53, 0x50, 0xC6};

    for (std::size_t i = 0; i < 4; ++i) {
        // `funnyShit` method/routine.
        std::uint8_t ivbyte = iv[i];
        mbytes[0] += maplebytes[mbytes[1] & 0xFF] - ivbyte;
        mbytes[1] -= mbytes[2] ^ (maplebytes[ivbyte & 0xFF] & 0xFF);
        mbytes[2] ^= maplebytes[mbytes[3] & 0xFF] + ivbyte;
        mbytes[3] += (maplebytes[ivbyte & 0xFF] & 0xFF) - (mbytes[0] & 0xFF);

        std::size_t mask = 0;
        mask |= (mbytes[0]) & 0xFF;
        mask |= (mbytes[1] << 8) & 0xFF00;
        mask |= (mbytes[2] << 16) & 0xFF0000;
        mask |= (mbytes[3] << 24) & 0xFF000000;

        mask = (mask >> 0x1D) | (mask << 3);

        for (std::size_t j = 0; j < 4; ++j) {
            std::size_t value = mask >> (8 * j);
            mbytes[j] = static_cast<std::uint8_t>(value & 0xFF);
        }
    }

    for (std::size_t i = 0; i < 4; ++i) {
        iv[i] = mbytes[i];
    }
}

std::int8_t Cryptography::rollleft(std::int8_t data, std::size_t count) const
{
    std::int32_t mask = (data & 0xFF) << (count % 8);
    return static_cast<std::int8_t>((mask & 0xFF) | (mask >> 8));
}

std::int8_t Cryptography::rollright(std::int8_t data, std::size_t count) const
{
    std::int32_t mask = ((data & 0xFF) << 8) >> (count % 8);
    return static_cast<std::int8_t>((mask & 0xFF) | (mask >> 8));
}

void Cryptography::aesofb(std::int8_t* bytes,
                          std::size_t length,
                          std::uint8_t* iv) const noexcept
{
    std::size_t blocklength = 0x5B0;
    std::size_t offset = 0;

    while (offset < length) {
        std::uint8_t miv[16];

        for (std::size_t i = 0; i < 16; ++i) {
            miv[i] = iv[i % 4];
        }

        std::size_t remaining = length - offset;

        if (remaining > blocklength) {
            remaining = blocklength;
        }

        for (std::size_t x = 0; x < remaining; ++x) {
            std::size_t relpos = x % 16;

            if (relpos == 0) {
                aesencrypt(miv);
            }

            bytes[x + offset] ^= miv[relpos];
        }

        offset += blocklength;
        blocklength = 0x5B4;
    }

    updateiv(iv);
}

void Cryptography::aesencrypt(std::uint8_t* bytes) const
{
    std::uint8_t round = 0;
    addroundkey(bytes, round);

    for (round = 1; round < 14; ++round) {
        subbytes(bytes);
        shiftrows(bytes);
        mixcolumns(bytes);
        addroundkey(bytes, round);
    }

    subbytes(bytes);
    shiftrows(bytes);
    addroundkey(bytes, round);
}

void Cryptography::addroundkey(std::uint8_t* bytes, std::uint8_t round) const
{
    // This key is pre-expanded. Works only for lower versions.
    static const std::uint8_t maplekey[256] = {
        0x13, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xB4, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
        0x33, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0x71, 0x63, 0x63, 0x00,
        0x79, 0x63, 0x63, 0x00, 0x7F, 0x63, 0x63, 0x00, 0xCB, 0x63, 0x63, 0x00,
        0x04, 0xFB, 0xFB, 0x63, 0x0B, 0xFB, 0xFB, 0x63, 0x38, 0xFB, 0xFB, 0x63,
        0x6A, 0xFB, 0xFB, 0x63, 0x7C, 0x6C, 0x98, 0x02, 0x05, 0x0F, 0xFB, 0x02,
        0x7A, 0x6C, 0x98, 0x02, 0xB1, 0x0F, 0xFB, 0x02, 0xCC, 0x8D, 0xF4, 0x14,
        0xC7, 0x76, 0x0F, 0x77, 0xFF, 0x8D, 0xF4, 0x14, 0x95, 0x76, 0x0F, 0x77,
        0x40, 0x1A, 0x6D, 0x28, 0x45, 0x15, 0x96, 0x2A, 0x3F, 0x79, 0x0E, 0x28,
        0x8E, 0x76, 0xF5, 0x2A, 0xD5, 0xB5, 0x12, 0xF1, 0x12, 0xC3, 0x1D, 0x86,
        0xED, 0x4E, 0xE9, 0x92, 0x78, 0x38, 0xE6, 0xE5, 0x4F, 0x94, 0xB4, 0x94,
        0x0A, 0x81, 0x22, 0xBE, 0x35, 0xF8, 0x2C, 0x96, 0xBB, 0x8E, 0xD9, 0xBC,
        0x3F, 0xAC, 0x27, 0x94, 0x2D, 0x6F, 0x3A, 0x12, 0xC0, 0x21, 0xD3, 0x80,
        0xB8, 0x19, 0x35, 0x65, 0x8B, 0x02, 0xF9, 0xF8, 0x81, 0x83, 0xDB, 0x46,
        0xB4, 0x7B, 0xF7, 0xD0, 0x0F, 0xF5, 0x2E, 0x6C, 0x49, 0x4A, 0x16, 0xC4,
        0x64, 0x25, 0x2C, 0xD6, 0xA4, 0x04, 0xFF, 0x56, 0x1C, 0x1D, 0xCA, 0x33,
        0x0F, 0x76, 0x3A, 0x64, 0x8E, 0xF5, 0xE1, 0x22, 0x3A, 0x8E, 0x16, 0xF2,
        0x35, 0x7B, 0x38, 0x9E, 0xDF, 0x6B, 0x11, 0xCF, 0xBB, 0x4E, 0x3D, 0x19,
        0x1F, 0x4A, 0xC2, 0x4F, 0x03, 0x57, 0x08, 0x7C, 0x14, 0x46, 0x2A, 0x1F,
        0x9A, 0xB3, 0xCB, 0x3D, 0xA0, 0x3D, 0xDD, 0xCF, 0x95, 0x46, 0xE5, 0x51,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00};

    std::uint8_t offset = round * static_cast<uint8_t>(16u);
    for (std::uint8_t i = 0; i < 16; ++i) {
        bytes[i] ^= maplekey[i + offset];
    }
}

void Cryptography::subbytes(std::uint8_t* bytes) const
{
    // Rijndael substitution box.
    static const std::uint8_t subbox[256] = {
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B,
        0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
        0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26,
        0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,
        0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
        0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED,
        0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F,
        0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
        0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC,
        0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14,
        0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
        0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,
        0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F,
        0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
        0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11,
        0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F,
        0xB0, 0x54, 0xBB, 0x16};

    for (std::uint8_t i = 0; i < 16; ++i) {
        bytes[i] = subbox[bytes[i]];
    }
}

void Cryptography::shiftrows(std::uint8_t* bytes) const
{
    std::uint8_t remember = bytes[1];
    bytes[1] = bytes[5];
    bytes[5] = bytes[9];
    bytes[9] = bytes[13];
    bytes[13] = remember;

    remember = bytes[10];
    bytes[10] = bytes[2];
    bytes[2] = remember;

    remember = bytes[3];
    bytes[3] = bytes[15];
    bytes[15] = bytes[11];
    bytes[11] = bytes[7];
    bytes[7] = remember;

    remember = bytes[14];
    bytes[14] = bytes[6];
    bytes[6] = remember;
}

std::uint8_t Cryptography::gmul(std::uint8_t x) const
{
    return (x << 1)
           ^ (static_cast<std::uint8_t>(0x1Bu)
              & (std::uint8_t)((std::int8_t)x >> 7));
}

void Cryptography::mixcolumns(std::uint8_t* bytes) const
{
    for (std::uint8_t i = 0; i < 16; i += 4) {
        std::uint8_t cpy0 = bytes[i];
        std::uint8_t cpy1 = bytes[i + 1];
        std::uint8_t cpy2 = bytes[i + 2];
        std::uint8_t cpy3 = bytes[i + 3];

        std::uint8_t mul0 = gmul(bytes[i]);
        std::uint8_t mul1 = gmul(bytes[i + 1]);
        std::uint8_t mul2 = gmul(bytes[i + 2]);
        std::uint8_t mul3 = gmul(bytes[i + 3]);

        bytes[i] = mul0 ^ cpy3 ^ cpy2 ^ mul1 ^ cpy1;
        bytes[i + 1] = mul1 ^ cpy0 ^ cpy3 ^ mul2 ^ cpy2;
        bytes[i + 2] = mul2 ^ cpy1 ^ cpy0 ^ mul3 ^ cpy3;
        bytes[i + 3] = mul3 ^ cpy2 ^ cpy1 ^ mul0 ^ cpy0;
    }
}
} // namespace jrc

```

`Net/Cryptography.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Journey.h"
#include "NetConstants.h"

#include <cstdint>

namespace jrc
{
//! Used to encrypt and decrypt packets for communication with the server.
class Cryptography
{
public:
    //! Obtain the initialization vector from the handshake.
    Cryptography(const std::int8_t* handshake);
    Cryptography();
    ~Cryptography();

    //! Encrypt a byte array with the given length and iv.
    void encrypt(std::int8_t* bytes, std::size_t length) noexcept;
    //! Decrypt a byte array with the given length and iv.
    void decrypt(std::int8_t* bytes, std::size_t length);
    //! Generate a header for the specified length and key.
    void create_header(std::int8_t* buffer, std::size_t length) const noexcept;
    //! Use the 4-byte header of a received packet to determine its length.
    std::size_t check_length(const std::int8_t* header) const;

private:
    //! Add the maple custom encryption.
    void mapleencrypt(std::int8_t* bytes, std::size_t length) const noexcept;
    //! Remove the maple custom encryption.
    void mapledecrypt(std::int8_t* bytes, std::size_t length) const;
    //! Update a key.
    void updateiv(std::uint8_t* iv) const noexcept;
    //! Perform a roll-left operation.
    std::int8_t rollleft(std::int8_t byte, std::size_t count) const;
    //! Perform a roll-right operation.
    std::int8_t rollright(std::int8_t byte, std::size_t count) const;

    //! Apply aesofb to a byte array.
    void aesofb(std::int8_t* bytes, std::size_t length, std::uint8_t* iv) const
        noexcept;
    //! Encrypt a byte array with AES.
    void aesencrypt(std::uint8_t* bytes) const;
    //! AES addroundkey step.
    void addroundkey(std::uint8_t* bytes, std::uint8_t round) const;
    //! AES subbytes step.
    void subbytes(std::uint8_t* bytes) const;
    //! AES shiftrows step.
    void shiftrows(std::uint8_t* bytes) const;
    //! AES mixcolumns step.
    void mixcolumns(std::uint8_t* bytes) const;
    //! Perform a gauloise multiplication.
    std::uint8_t gmul(std::uint8_t byte) const;

#ifdef JOURNEY_USE_CRYPTO
    std::uint8_t sendiv[HEADER_LENGTH];
    std::uint8_t recviv[HEADER_LENGTH];
#endif
};
} // namespace jrc

```

`Net/Handlers/AttackHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "AttackHandlers.h"

#include "../../Character/SkillId.h"
#include "../../Gameplay/Stage.h"

#include <unordered_map>
#include <vector>

namespace jrc
{
AttackHandler::AttackHandler(Attack::Type t) noexcept : type{t}
{
}

void AttackHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    std::uint8_t count = recv.read_byte();

    recv.skip(1);

    AttackResult attack;
    attack.type = type;
    attack.attacker = cid;

    attack.level = recv.read_byte();
    attack.skill = (attack.level > 0) ? recv.read_int() : 0;

    attack.display = recv.read_byte();
    attack.to_left = recv.read_bool();
    attack.stance = recv.read_byte();
    attack.speed = recv.read_byte();

    recv.skip(1);

    attack.bullet = recv.read_int();

    attack.mob_count = (count >> 4) & 0x0F;
    attack.hit_count = count & 0x0F;
    for (std::uint8_t i = 0; i < attack.mob_count; ++i) {
        std::int32_t oid = recv.read_int();

        recv.skip(1);

        std::uint8_t length = attack.skill == SkillId::MESO_EXPLOSION
                                  ? recv.read_byte()
                                  : attack.hit_count;
        for (std::uint8_t j = 0; j < length; ++j) {
            std::int32_t damage = recv.read_int();
            bool critical = false; // TODO
            attack.damage_lines[oid].emplace_back(damage, critical);
        }
    }

    Stage::get().get_combat().push_attack(attack);
}
} // namespace jrc

```

`Net/Handlers/AttackHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Gameplay/Combat/Attack.h"
#include "../PacketHandler.h"

namespace jrc
{
class AttackHandler : public PacketHandler
{
public:
    void handle(InPacket& recv) const override;

protected:
    AttackHandler(Attack::Type type) noexcept;

private:
    Attack::Type type;
};

class CloseAttackHandler : public AttackHandler
{
public:
    CloseAttackHandler() : AttackHandler(Attack::CLOSE)
    {
    }
};

class RangedAttackHandler : public AttackHandler
{
public:
    RangedAttackHandler() : AttackHandler(Attack::RANGED)
    {
    }
};

class MagicAttackHandler : public AttackHandler
{
public:
    MagicAttackHandler() : AttackHandler(Attack::MAGIC)
    {
    }
};
} // namespace jrc

```

`Net/Handlers/CommonHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "CommonHandlers.h"

#include "../Packets/CommonPackets.h"

namespace jrc
{
void PingHandler::handle(InPacket&) const
{
    PongPacket().dispatch();
}
} // namespace jrc

```

`Net/Handlers/CommonHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
class PingHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

class NullHandler : public PacketHandler
{
    void handle(InPacket&) const override
    {
    }
};
} // namespace jrc

```

`Net/Handlers/CustomHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "CustomHandlers.h"

#include "../Packets/CustomPackets.h"

namespace jrc
{
#ifdef JOURNEY_USE_XXHASH
void NxCheckRequestHandler::handle(InPacket& recv) const
{
    std::uint64_t seed = recv.read_long();
    NxCheckPacket(seed).dispatch();
}
#endif
} // namespace jrc

```

`Net/Handlers/CustomHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
#ifdef JOURNEY_USE_XXHASH
class NxCheckRequestHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
#endif
} // namespace jrc

```

`Net/Handlers/Helpers/ItemParser.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "ItemParser.h"

namespace jrc
{
namespace ItemParser
{
// Parse a normal item from a packet.
void add_item(InPacket& recv,
              InventoryType::Id invtype,
              std::int16_t slot,
              std::int32_t id,
              Inventory& inventory)
{
    // Read all item stats.
    bool cash = recv.read_bool();
    if (cash) {
        recv.skip(8); // unique id
    }
    std::int64_t expire = recv.read_long();
    std::int16_t count = recv.read_short();
    std::string owner = recv.read_string();
    std::int16_t flag = recv.read_short();

    // If the item is a rechargable projectile, some additional bytes are sent.
    if ((id / 10000 == 233) || (id / 10000 == 207)) {
        recv.skip(8);
    }

    inventory.add_item(invtype, slot, id, cash, expire, count, owner, flag);
}

// Parse a pet from a packet.
void add_pet(InPacket& recv,
             InventoryType::Id invtype,
             std::int16_t slot,
             std::int32_t id,
             Inventory& inventory)
{
    // Read all pet stats.
    bool cash = recv.read_bool();
    if (cash) {
        recv.skip(8); // unique id
    }
    std::int64_t expire = recv.read_long();
    std::string petname = recv.read_padded_string(13);
    std::int8_t petlevel = recv.read_byte();
    std::int16_t closeness = recv.read_short();
    std::int8_t fullness = recv.read_byte();

    // Some unused bytes.
    recv.skip(18);

    inventory.add_pet(invtype,
                      slot,
                      id,
                      cash,
                      expire,
                      petname,
                      petlevel,
                      closeness,
                      fullness);
}

// Parse an equip from a packet.
void add_equip(InPacket& recv,
               InventoryType::Id invtype,
               std::int16_t slot,
               std::int32_t id,
               Inventory& inventory)
{
    // Read equip information.
    bool cash = recv.read_bool();
    if (cash) {
        recv.skip(8); // unique id
    }
    std::int64_t expire = recv.read_long();
    std::uint8_t slots = recv.read_byte();
    std::uint8_t level = recv.read_byte();

    // Read equip stats.
    EnumMap<Equipstat::Id, std::uint16_t> stats;
    for (auto iter : stats) {
        iter.second = recv.read_short();
    }

    // Some more information.
    std::string owner = recv.read_string();
    std::int16_t flag = recv.read_short();
    std::uint8_t itemlevel = 0;
    std::uint16_t itemexp = 0;
    std::int32_t vicious = 0;
    if (cash) {
        // Some unused bytes.
        recv.skip(10);
    } else {
        recv.read_byte();
        itemlevel = recv.read_byte();
        recv.read_short();
        itemexp = recv.read_short();
        vicious = recv.read_int();
        recv.read_long();
    }

    recv.skip(12);

    if (slot < 0) {
        invtype = InventoryType::EQUIPPED;
        slot = -slot;
    }

    inventory.add_equip(invtype,
                        slot,
                        id,
                        cash,
                        expire,
                        slots,
                        level,
                        stats,
                        owner,
                        flag,
                        itemlevel,
                        itemexp,
                        vicious);
}

void parse_item(InPacket& recv,
                InventoryType::Id invtype,
                std::int16_t slot,
                Inventory& inventory)
{
    // Read type and item id.
    recv.read_byte(); // 'type' byte
    std::int32_t iid = recv.read_int();

    if (invtype == InventoryType::EQUIP
        || invtype == InventoryType::EQUIPPED) {
        // Parse an equip.
        add_equip(recv, invtype, slot, iid, inventory);
    } else if (iid >= 5000000 && iid <= 5000102) {
        // Parse a pet.
        add_pet(recv, invtype, slot, iid, inventory);
    } else {
        // Parse a normal item.
        add_item(recv, invtype, slot, iid, inventory);
    }
}
} // namespace ItemParser
} // namespace jrc

```

`Net/Handlers/Helpers/ItemParser.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../../Character/Inventory/Inventory.h"
#include "../../InPacket.h"

namespace jrc
{
namespace ItemParser
{
void parse_item(InPacket& recv,
                InventoryType::Id invtype,
                std::int16_t slot,
                Inventory& inventory);
}
} // namespace jrc

```

`Net/Handlers/Helpers/LoginParser.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "LoginParser.h"

namespace jrc
{
Account LoginParser::parse_account(InPacket& recv)
{
    Account account;

    recv.skip(2);
    account.acc_id = recv.read_int();
    account.female = recv.read_bool();
    recv.read_bool(); // is admin
    account.gm_level = recv.read_byte();
    recv.skip(1);
    account.name = recv.read_string();
    recv.skip(1);
    account.muted = recv.read_bool();
    recv.read_long(); // muted until
    recv.read_long(); // creation date
    recv.skip(4);
    account.pin = recv.read_short();

    return account;
}

World LoginParser::parse_world(InPacket& recv)
{
    std::int8_t wid = recv.read_byte();
    if (wid == -1) {
        return {{}, {}, {}, 0, 0, wid};
    }

    std::string name = recv.read_string();
    std::uint8_t flag = recv.read_byte();
    std::string message = recv.read_string();

    recv.skip(5);

    std::vector<std::int32_t> chloads;
    std::uint8_t channelcount = recv.read_byte();

    for (std::uint8_t i = 0; i < channelcount; ++i) {
        recv.read_string(); // channel name
        chloads.push_back(recv.read_int());
        recv.skip(1);
        recv.skip(2);
    }

    recv.skip(2);

    return {name, message, chloads, channelcount, flag, wid};
}

CharEntry LoginParser::parse_charentry(InPacket& recv)
{
    std::int32_t cid = recv.read_int();
    StatsEntry stats = parse_stats(recv);
    LookEntry look = parse_look(recv);

    recv.read_bool(); // 'rankinfo' bool

    if (recv.read_bool()) {
        std::int32_t currank = recv.read_int();
        std::int32_t rankmv = recv.read_int();
        std::int32_t curjobrank = recv.read_int();
        std::int32_t jobrankmv = recv.read_int();
        std::int8_t rankmc = (rankmv > 0) ? '+' : (rankmv < 0) ? '-' : '=';
        std::int8_t jobrankmc
            = (jobrankmv > 0) ? '+' : (jobrankmv < 0) ? '-' : '=';

        stats.rank = std::make_pair(currank, rankmc);
        stats.job_rank = std::make_pair(curjobrank, jobrankmc);
    }

    return {stats, look, cid};
}

StatsEntry LoginParser::parse_stats(InPacket& recv)
{
    StatsEntry statsentry;

    statsentry.name = recv.read_padded_string(13);

    recv.read_bool(); // gender
    recv.read_byte(); // skin
    recv.read_int();  // face
    recv.read_int();  // hair

    for (std::size_t i = 0; i < 3; ++i) {
        statsentry.pet_ids.push_back(recv.read_long());
    }

    statsentry.stats[Maplestat::LEVEL] = recv.read_byte();
    statsentry.stats[Maplestat::JOB] = recv.read_short();
    statsentry.stats[Maplestat::STR] = recv.read_short();
    statsentry.stats[Maplestat::DEX] = recv.read_short();
    statsentry.stats[Maplestat::INT] = recv.read_short();
    statsentry.stats[Maplestat::LUK] = recv.read_short();
    statsentry.stats[Maplestat::HP] = recv.read_short();
    statsentry.stats[Maplestat::MAXHP] = recv.read_short();
    statsentry.stats[Maplestat::MP] = recv.read_short();
    statsentry.stats[Maplestat::MAXMP] = recv.read_short();
    statsentry.stats[Maplestat::AP] = recv.read_short();
    statsentry.stats[Maplestat::SP] = recv.read_short();
    statsentry.exp = recv.read_int();
    statsentry.stats[Maplestat::FAME] = recv.read_short();

    recv.skip(4); // gachaexp
    statsentry.map_id = recv.read_int();
    statsentry.portal = recv.read_byte();
    recv.skip(4); // timestamp

    return statsentry;
}

LookEntry LoginParser::parse_look(InPacket& recv)
{
    LookEntry look;

    look.female = recv.read_bool();
    look.skin = recv.read_byte();
    look.face_id = recv.read_int();
    recv.read_bool(); // megaphone
    look.hair_id = recv.read_int();

    std::uint8_t eqslot = recv.read_byte();

    while (eqslot != 0xFF) {
        look.equips[eqslot] = recv.read_int();
        eqslot = recv.read_byte();
    }

    std::uint8_t mskeqslot = recv.read_byte();

    while (mskeqslot != 0xFF) {
        look.masked_equips[mskeqslot] = recv.read_int();
        mskeqslot = recv.read_byte();
    }

    look.masked_equips[-111] = recv.read_int();

    for (std::uint8_t i = 0; i < 3; ++i) {
        look.pet_ids.push_back(recv.read_int());
    }

    return look;
}
} // namespace jrc

```

`Net/Handlers/Helpers/LoginParser.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../InPacket.h"
#include "../../Login.h"

namespace jrc::LoginParser
{
Account parse_account(InPacket& recv);
World parse_world(InPacket& recv);
CharEntry parse_charentry(InPacket& recv);
StatsEntry parse_stats(InPacket& recv);
LookEntry parse_look(InPacket& recv);
} // namespace jrc::LoginParser

```

`Net/Handlers/Helpers/MovementParser.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MovementParser.h"

namespace jrc
{
std::vector<Movement> MovementParser::parse_movements(InPacket& recv)
{
    std::vector<Movement> movements;
    std::uint8_t length = recv.read_byte();
    for (std::uint8_t i = 0; i < length; ++i) {
        Movement fragment;
        fragment.command = recv.read_byte();
        switch (fragment.command) {
        case 0:
        case 5:
        case 17:
            fragment.type = Movement::_ABSOLUTE;
            fragment.xpos = recv.read_short();
            fragment.ypos = recv.read_short();
            fragment.lastx = recv.read_short();
            fragment.lasty = recv.read_short();
            fragment.fh = recv.read_short();
            fragment.newstate = recv.read_byte();
            fragment.duration = recv.read_short();
            break;
        case 1:
        case 2:
        case 6:
        case 12:
        case 13:
        case 16:
            fragment.type = Movement::_RELATIVE;
            fragment.xpos = recv.read_short();
            fragment.ypos = recv.read_short();
            fragment.newstate = recv.read_byte();
            fragment.duration = recv.read_short();
            break;
        case 11:
            fragment.type = Movement::CHAIR;
            fragment.xpos = recv.read_short();
            fragment.ypos = recv.read_short();
            recv.skip(2);
            fragment.newstate = recv.read_byte();
            fragment.duration = recv.read_short();
            break;
        case 15:
            fragment.type = Movement::JUMPDOWN;
            fragment.xpos = recv.read_short();
            fragment.ypos = recv.read_short();
            fragment.lastx = recv.read_short();
            fragment.lasty = recv.read_short();
            recv.skip(2);
            fragment.fh = recv.read_short();
            fragment.newstate = recv.read_byte();
            fragment.duration = recv.read_short();
            break;
        case 3:
        case 4:
        case 7:
        case 8:
        case 9:
        case 14:
            fragment.type = Movement::NONE;
            break;
        case 10:
            fragment.type = Movement::NONE;
            // change equip
            break;
        }
        movements.push_back(fragment);
    }
    return movements;
}
} // namespace jrc

```

`Net/Handlers/Helpers/MovementParser.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../../Gameplay/Movement.h"
#include "../../InPacket.h"

#include <vector>

namespace jrc
{
namespace MovementParser
{
std::vector<Movement> parse_movements(InPacket& recv);
}
} // namespace jrc

```

`Net/Handlers/InventoryHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "InventoryHandlers.h"

#include "../../Character/Inventory/Inventory.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/Messages.h"
#include "../../IO/UI.h"
#include "../../IO/UITypes/UIEquipInventory.h"
#include "../../IO/UITypes/UIItemInventory.h"
#include "../../IO/UITypes/UIShop.h"
#include "Helpers/ItemParser.h"

namespace jrc
{
void GatherResultHandler::handle(InPacket&) const
{
    if (auto iteminventory = UI::get().get_element<UIItemInventory>()) {
        iteminventory->enable_sort();
    }
}

void SortResultHandler::handle(InPacket&) const
{
    if (auto iteminventory = UI::get().get_element<UIItemInventory>()) {
        iteminventory->enable_gather();
    }
}

void ModifyInventoryHandler::handle(InPacket& recv) const
{
    recv.read_bool(); // 'updatetick'

    Inventory& inventory = Stage::get().get_player().get_inventory();

    struct Mod {
        std::int8_t mode;
        InventoryType::Id type;
        std::int16_t pos;
        std::int16_t arg;
    };
    std::vector<Mod> mods;

    std::int8_t size = recv.read_byte();
    for (std::int8_t i = 0; i < size; ++i) {
        Mod mod;
        mod.mode = recv.read_byte();
        mod.type = InventoryType::by_value(recv.read_byte());
        mod.pos = recv.read_short();
        mod.arg = 0;

        switch (mod.mode) {
        case Inventory::ADD:
            ItemParser::parse_item(recv, mod.type, mod.pos, inventory);
            break;
        case Inventory::CHANGE_COUNT: {
            mod.arg = recv.read_short();

            std::int16_t count_before
                = inventory.get_item_count(mod.type, mod.pos);
            std::int16_t count_now = mod.arg;

            inventory.modify(
                mod.type, mod.pos, mod.mode, mod.arg, Inventory::MOVE_NONE);

            if (count_before < count_now) {
                mod.mode = Inventory::ADD_COUNT;
            }
        } break;
        case Inventory::SWAP:
            mod.arg = recv.read_short();
            break;
        case Inventory::REMOVE:
            inventory.modify(mod.type,
                             mod.pos,
                             mod.mode,
                             mod.arg,
                             Inventory::MOVE_INTERNAL);
            break;
        }

        mods.push_back(mod);
    }

    Inventory::Movement move
        = (recv.length() > 0) ? Inventory::movement_by_value(recv.read_byte())
                              : Inventory::MOVE_INTERNAL;

    for (const Mod& mod : mods) {
        if (mod.mode == 2) {
            inventory.modify(mod.type, mod.pos, mod.mode, mod.arg, move);
        }

        if (auto shop = UI::get().get_element<UIShop>()) {
            shop->modify(mod.type);
        }

        auto eqinvent = UI::get().get_element<UIEquipInventory>();
        auto itinvent = UI::get().get_element<UIItemInventory>();
        switch (move) {
        case Inventory::MOVE_INTERNAL:
            switch (mod.type) {
            case InventoryType::EQUIPPED:
                if (eqinvent) {
                    eqinvent->modify(mod.pos, mod.mode, mod.arg);
                }

                Stage::get().get_player().change_equip(-mod.pos);
                Stage::get().get_player().change_equip(-mod.arg);
                break;
            case InventoryType::EQUIP:
            case InventoryType::USE:
            case InventoryType::SETUP:
            case InventoryType::ETC:
            case InventoryType::CASH:
                if (itinvent) {
                    itinvent->modify(mod.type, mod.pos, mod.mode, mod.arg);
                }
                break;
            case InventoryType::LENGTH:
            case InventoryType::NONE:
            default:
                break;
            }
            break;
        case Inventory::MOVE_EQUIP:
        case Inventory::MOVE_UNEQUIP:
            if (mod.pos < 0) {
                if (eqinvent) {
                    eqinvent->modify(-mod.pos, 3, 0);
                }

                if (itinvent) {
                    itinvent->modify(InventoryType::EQUIP, mod.arg, 0, 0);
                }

                Stage::get().get_player().change_equip(-mod.pos);
            } else if (mod.arg < 0) {
                if (eqinvent) {
                    eqinvent->modify(-mod.arg, 0, 0);
                }

                if (itinvent) {
                    itinvent->modify(InventoryType::EQUIP, mod.pos, 3, 0);
                }

                Stage::get().get_player().change_equip(-mod.arg);
            }
            break;
        case Inventory::MOVE_NONE:
        default:
            break;
        }
    }

    Stage::get().get_player().recalc_stats(true);
    UI::get().enable();
}
} // namespace jrc

```

`Net/Handlers/InventoryHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
// Handler for a packet which signifies that inventory items were gathered.
class GatherResultHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Handler for a packet which signifies that inventory items were sorted.
class SortResultHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Handler for a packet which modifies the player's inventory.
class ModifyInventoryHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/LoginHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "LoginHandlers.h"

#include "../../Configuration.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"
#include "../../IO/UITypes/UICharCreation.h"
#include "../../IO/UITypes/UICharSelect.h"
#include "../../IO/UITypes/UILogin.h"
#include "../../IO/UITypes/UILoginNotice.h"
#include "../../IO/UITypes/UIWorldSelect.h"
#include "../Packets/LoginPackets.h"
#include "../Session.h"
#include "Helpers/LoginParser.h"

namespace jrc
{
void LoginResultHandler::handle(InPacket& recv) const
{
    // Remove previous UIs.
    UI::get().remove(UIElement::LOGIN_NOTICE);
    UI::get().remove(UIElement::LOGIN_WAIT);

    // The packet should contain a 'reason' integer which can signify various
    // things.
    if (std::int32_t reason = recv.read_int(); reason) {
        // Login unsuccessful. The LoginNotice displayed will contain the
        // specific information.
        switch (reason) {
        case 2:
            UI::get().emplace<UILoginNotice>(UILoginNotice::BLOCKED_ID);
            break;
        case 7:
            UI::get().emplace<UILoginNotice>(UILoginNotice::ALREADY_LOGGED_IN);
            break;
        case 23:
            // The server sends a request to accept the terms of service. For
            // convenience, just auto-accept.
            TOSPacket{}.dispatch();
            break;
        default:
            // Other reasons.
            if (reason > 0) {
                auto reason_byte = static_cast<std::int8_t>(reason - 1);
                UI::get().emplace<UILoginNotice>(
                    static_cast<UILoginNotice::Message>(reason_byte));
            }
        }

        UI::get().enable();
    } else {
        Console::get().print("Login successful.");
        // Login successful. The packet contains information on the account, so
        // we initialise the account with it.
        Account account = LoginParser::parse_account(recv);

        // Save the Login ID if the box for it on the login panel is checked.
        if (Configuration::get().account.save_login) {
            Configuration::get().account.account_name
                = std::move(account.name);
        }

        // Request the list of worlds and channels online.
        ServerRequestPacket{}.dispatch();
    }
}

void ServerlistHandler::handle(InPacket& recv) const
{
    // Parse all worlds.
    std::vector<World> worlds;
    while (recv.available()) {
        if (World world = LoginParser::parse_world(recv); world.wid != -1) {
            worlds.push_back(std::move(world));
        } else {
            // "End of serverlist" packet.
            return;
        }
    }

    // Remove previous UIs.
    UI::get().remove(UIElement::LOGIN);
    UI::get().remove(UIElement::CHAR_SELECT);

    // Add the world selection screen to the UI.
    UI::get().emplace<UIWorldSelect>(std::move(worlds));
    UI::get().enable();
}

void CharlistHandler::handle(InPacket& recv) const
{
    auto channel_id = static_cast<std::uint8_t>(recv.read_byte());

    // Parse all characters.
    std::vector<CharEntry> characters;
    auto charcount = static_cast<std::uint8_t>(recv.read_byte());
    for (std::uint8_t i = 0; i < charcount; ++i) {
        characters.emplace_back(LoginParser::parse_charentry(recv));
    }
    std::int8_t pic = recv.read_byte();
    auto slots = static_cast<std::uint8_t>(recv.read_int());

    // Remove previous UIs.
    UI::get().remove(UIElement::WORLD_SELECT);
    UI::get().remove(UIElement::CHAR_CREATION);

    // Add the character selection screen.
    UI::get().emplace<UICharSelect>(
        characters, charcount, slots, channel_id, pic);
    UI::get().enable();
}

void CharnameResponseHandler::handle(InPacket& recv) const
{
    // Read the name and if it is already in use.
    std::string name = recv.read_string();
    bool used = recv.read_bool();

    if (used) {
        UI::get().emplace<UILoginNotice>(UILoginNotice::NAME_IN_USE);
    }

    // Notify the character creation screen.
    if (auto charcreation = UI::get().get_element<UICharCreation>()) {
        charcreation->send_naming_result(used);
    }

    UI::get().enable();
}

void AddNewCharEntryHandler::handle(InPacket& recv) const
{
    recv.skip(1);

    // Parse info on the new character.
    CharEntry character = LoginParser::parse_charentry(recv);

    // Remove the character creation ui.
    UI::get().remove(UIElement::CHAR_CREATION);

    // Read the updated character selection.
    if (auto char_select = UI::get().get_element<UICharSelect>();
        char_select) {
        char_select->add_character(std::move(character));
        char_select->make_active();
    }

    UI::get().enable();
}

void DeleteCharResponseHandler::handle(InPacket& recv) const
{
    // Read the character ID and if deletion was successful (PIC was correct).
    std::int32_t cid = recv.read_int();
    auto state = static_cast<std::uint8_t>(recv.read_byte());

    // Extract information from the state byte.
    if (state) {
        UILoginNotice::Message message;
        switch (state) {
        case 10:
            message = UILoginNotice::BIRTHDAY_INCORRECT;
            break;
        case 20:
            message = UILoginNotice::SECOND_PASSWORD_INCORRECT;
            break;
        default:
            message = UILoginNotice::UNKNOWN_ERROR;
            break;
        }

        UI::get().emplace<UILoginNotice>(message);
    } else {
        if (auto char_select = UI::get().get_element<UICharSelect>();
            char_select) {
            char_select->remove_char(cid);
        }
    }

    UI::get().enable();
}

void ChannelChangeHandler::handle(InPacket& recv) const
{
    recv.skip(1);

    // Read the IPv4 address into a character buffer.
    std::uint8_t addr_buf[4];
    for (auto i = 0; i < 4; ++i) {
        addr_buf[i] = static_cast<std::uint8_t>(recv.read_byte());
    }
    char addr_str[16];
    std::snprintf(addr_str,
                  16,
                  "%hhu.%hhu.%hhu.%hhu",
                  addr_buf[0],
                  addr_buf[1],
                  addr_buf[2],
                  addr_buf[3]);

    // Read the port number in a string.
    const auto port_str = std::to_string(recv.read_short());

    // Attempt to reconnect to the server, and if successful, relog into the
    // game in the new channel.
    Session::get().reconnect(addr_str, port_str.c_str());
    auto cid = Stage::get().get_player().get_oid();
    PlayerLoginPacket{cid}.dispatch();
}

void ServerIPHandler::handle(InPacket& recv) const
{
    recv.skip(2);

    // Read the IPv4 address into a character buffer.
    std::uint8_t addr_buf[4];
    for (auto i = 0; i < 4; ++i) {
        addr_buf[i] = static_cast<std::uint8_t>(recv.read_byte());
    }
    char addr_str[16];
    std::snprintf(addr_str,
                  16,
                  "%hhu.%hhu.%hhu.%hhu",
                  addr_buf[0],
                  addr_buf[1],
                  addr_buf[2],
                  addr_buf[3]);

    // Read the port number in a string.
    const auto port_str = std::to_string(recv.read_short());

    auto cid = recv.read_int();

    // Attempt to reconnect to the server, and if successful, log into the
    // game.
    Session::get().reconnect(addr_str, port_str.c_str());
    PlayerLoginPacket{cid}.dispatch();
}
} // namespace jrc

```

`Net/Handlers/LoginHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
//! Handler for a packet that contains the response to an attempt at logging
//! in.
class LoginResultHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handles the packet that contains information on worlds and channels.
class ServerlistHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handler for a packet that contains information on all characters on this
//! world.
class CharlistHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handler for a packet which responds to the request for a character name.
class CharnameResponseHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handler for the packet that notifies that a char was successfully created.
class AddNewCharEntryHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handler for a packet that responds to the request to the delete a
//! character.
class DeleteCharResponseHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handler for a packet that responds to the request to change channels.
class ChannelChangeHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Handles the packet which contains the IP of a channel server to connect to.
class ServerIPHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/MapObjectHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MapObjectHandlers.h"

#include "../../Audio/Audio.h"
#include "../../Gameplay/Spawn.h"
#include "../../Gameplay/Stage.h"
#include "Helpers/LoginParser.h"
#include "Helpers/MovementParser.h"

namespace jrc
{
void SpawnCharHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    std::uint8_t level = recv.read_byte();
    std::string name = recv.read_string();

    recv.read_string(); // guildname
    recv.read_short();  // guildlogobg
    recv.read_byte();   // guildlogobgcolor
    recv.read_short();  // guildlogo
    recv.read_byte();   // guildlogocolor

    recv.skip(8);

    bool morphed = recv.read_int() == 2;
    std::int32_t buffmask1 = recv.read_int();
    std::int16_t buffvalue = 0;
    if (buffmask1 != 0) {
        buffvalue = morphed ? recv.read_short() : recv.read_byte();
    }
    recv.read_int(); // buffmask 2

    recv.skip(43);

    recv.read_int(); // 'mount'

    recv.skip(61);

    std::int16_t job = recv.read_short();
    LookEntry look = LoginParser::parse_look(recv);

    recv.read_int(); // count of 5110000
    recv.read_int(); // 'itemeffect'
    recv.read_int(); // 'chair'

    Point<std::int16_t> position = recv.read_point();
    std::int8_t stance = recv.read_byte();

    recv.skip(3);

    for (std::size_t i = 0; i < 3; ++i) {
        std::int8_t available = recv.read_byte();
        if (available == 1) {
            recv.read_byte();   // 'byte2'
            recv.read_int();    // petid
            recv.read_string(); // name
            recv.read_int();    // unique id
            recv.read_int();
            recv.read_point(); // pos
            recv.read_byte();  // stance
            recv.read_int();   // fh_id
        } else {
            break;
        }
    }

    recv.read_int(); // mountlevel
    recv.read_int(); // mountexp
    recv.read_int(); // mounttiredness

    // shop stuff, TO DO
    recv.read_byte();
    // shop stuff end

    bool chalkboard = recv.read_bool();
    std::string chalktext = chalkboard ? recv.read_string() : "";

    recv.skip(3);
    recv.read_byte(); // team

    Stage::get().get_chars().spawn(
        {cid, look, level, job, name, stance, position});
}

void RemoveCharHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();

    Stage::get().get_chars().remove(cid);
}

void SpawnPetHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    nullable_ptr<Char> character = Stage::get().get_character(cid);
    if (!character) {
        return;
    }

    std::uint8_t pet_index = recv.read_byte();
    std::int8_t mode = recv.read_byte();

    if (mode == 1) {
        recv.skip(1);

        std::int32_t item_id = recv.read_int();
        std::string name = recv.read_string();
        std::int32_t unique_id = recv.read_int();

        recv.skip(4);

        Point<std::int16_t> pos = recv.read_point();
        std::uint8_t stance = recv.read_byte();
        std::int32_t fhid = recv.read_int();

        character->add_pet(
            pet_index, item_id, std::move(name), unique_id, pos, stance, fhid);
    } else if (mode == 0) {
        bool hunger = recv.read_bool();

        character->remove_pet(pet_index, hunger);
    }
}

void CharMovedHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    recv.skip(4);
    std::vector<Movement> movements = MovementParser::parse_movements(recv);

    Stage::get().get_chars().send_movement(cid, movements);
}

void UpdateCharLookHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    recv.read_byte();
    LookEntry look = LoginParser::parse_look(recv);

    Stage::get().get_chars().update_look(cid, look);
}

void ShowForeignEffectHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    std::int8_t effect = recv.read_byte();
    if (effect == 10) // recovery
    {
        recv.read_byte();    // 'amount'
    } else if (effect == 13) // card effect
    {
        Stage::get().show_character_effect(cid, CharEffect::MONSTER_CARD);
    } else if (recv.available()) // skill
    {
        std::int32_t skillid = recv.read_int();
        recv.read_byte(); // 'direction'
        // 9 more bytes after this

        Stage::get().get_combat().show_buff(cid, skillid, effect);
    } else {
        // todo
    }
}

void SpawnMobHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    recv.read_byte(); // 5 if controller == null
    std::int32_t id = recv.read_int();

    recv.skip(22);

    Point<std::int16_t> position = recv.read_point();
    std::int8_t stance = recv.read_byte();

    recv.skip(2);

    std::uint16_t fh = recv.read_short();
    std::int8_t effect = recv.read_byte();

    if (effect > 0) {
        recv.read_byte();
        recv.read_short();
        if (effect == 15) {
            recv.read_byte();
        }
    }

    std::int8_t team = recv.read_byte();

    recv.skip(4);

    Stage::get().get_mobs().spawn(
        {oid, id, 0, stance, fh, effect == -2, team, position});
}

void KillMobHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    std::int8_t animation = recv.read_byte();

    Stage::get().get_mobs().remove(oid, animation);
}

void SpawnMobControllerHandler::handle(InPacket& recv) const
{
    std::int8_t mode = recv.read_byte();
    std::int32_t oid = recv.read_int();
    if (mode == 0) {
        Stage::get().get_mobs().set_control(oid, false);
    } else {
        if (recv.available()) {
            recv.skip(1);

            std::int32_t id = recv.read_int();

            recv.skip(22);

            Point<std::int16_t> position = recv.read_point();
            std::int8_t stance = recv.read_byte();

            recv.skip(2);

            std::uint16_t fh = recv.read_short();
            std::int8_t effect = recv.read_byte();

            if (effect > 0) {
                recv.read_byte();
                recv.read_short();
                if (effect == 15) {
                    recv.read_byte();
                }
            }

            std::int8_t team = recv.read_byte();

            recv.skip(4);

            Stage::get().get_mobs().spawn(
                {oid, id, mode, stance, fh, effect == -2, team, position});
        } else {
            // remove monster invisibility, not used in moopledev or solaxia
            // (maybe in an event script?)
        }
    }
}

void MobMovedHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();

    recv.read_byte();
    recv.read_byte(); // useskill
    recv.read_byte(); // skill
    recv.read_byte(); // skill 1
    recv.read_byte(); // skill 2
    recv.read_byte(); // skill 3
    recv.read_byte(); // skill 4

    Point<std::int16_t> position = recv.read_point();
    std::vector<Movement> movements = MovementParser::parse_movements(recv);

    Stage::get().get_mobs().send_movement(oid, position, std::move(movements));
}

void ShowMobHpHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    std::int8_t hppercent = recv.read_byte();
    std::uint16_t playerlevel
        = Stage::get().get_player().get_stats().get_stat(Maplestat::LEVEL);

    Stage::get().get_mobs().send_mobhp(oid, hppercent, playerlevel);
}

void SpawnNpcHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    std::int32_t id = recv.read_int();
    Point<std::int16_t> position = recv.read_point();
    bool flip = recv.read_bool();
    std::uint16_t fh = recv.read_short();

    recv.read_short(); // 'rx'
    recv.read_short(); // 'ry'

    Stage::get().get_npcs().spawn({oid, id, position, flip, fh});
}

void SpawnNpcControllerHandler::handle(InPacket& recv) const
{
    std::int8_t mode = recv.read_byte();
    std::int32_t oid = recv.read_int();

    if (mode == 0) {
        Stage::get().get_npcs().remove(oid);
    } else {
        std::int32_t id = recv.read_int();
        Point<std::int16_t> position = recv.read_point();
        bool flip = recv.read_bool();
        std::uint16_t fh = recv.read_short();

        recv.read_short(); // 'rx'
        recv.read_short(); // 'ry'
        recv.read_bool();  // 'minimap'

        Stage::get().get_npcs().spawn({oid, id, position, flip, fh});
    }
}

void DropLootHandler::handle(InPacket& recv) const
{
    std::int8_t mode = recv.read_byte();
    std::int32_t oid = recv.read_int();
    bool meso = recv.read_bool();
    std::int32_t itemid = recv.read_int();
    std::int32_t owner = recv.read_int();
    std::int8_t pickuptype = recv.read_byte();
    Point<std::int16_t> dropto = recv.read_point();

    recv.skip(4);

    Point<std::int16_t> dropfrom;
    if (mode != 2) {
        dropfrom = recv.read_point();

        recv.skip(2);
    } else {
        dropfrom = dropto;
    }

    if (!meso) {
        recv.skip(8);
    }
    bool playerdrop = !recv.read_bool();

    Stage::get().get_drops().spawn({oid,
                                    itemid,
                                    meso,
                                    owner,
                                    dropfrom,
                                    dropto,
                                    pickuptype,
                                    mode,
                                    playerdrop});
}

void RemoveLootHandler::handle(InPacket& recv) const
{
    std::int8_t mode = recv.read_byte();
    std::int32_t oid = recv.read_int();

    nullable_ptr<PhysicsObject> looter;
    if (mode > 1) {
        std::int32_t cid = recv.read_int();
        if (recv.length() > 0) {
            recv.read_byte(); // pet
        } else if (auto character = Stage::get().get_character(cid)) {
            looter = character->get_phobj();
        }

        Sound(Sound::PICK_UP).play();
    }

    Stage::get().get_drops().remove(oid, mode, looter.get());
}

void SpawnReactorHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    std::int32_t rid = recv.read_int();
    std::int8_t state = recv.read_byte();
    Point<std::int16_t> point = recv.read_point();

    // Unused in Solaxia
    // std::uint16_t fh_id = recv.read_short();
    // recv.read_byte()

    Stage::get().get_reactors().spawn({oid, rid, state, point});
}

void RemoveReactorHandler::handle(InPacket& recv) const
{
    std::int32_t oid = recv.read_int();
    std::int8_t state = recv.read_byte();
    Point<std::int16_t> point = recv.read_point();

    Stage::get().get_reactors().remove(oid, state, point);
}
} // namespace jrc

```

`Net/Handlers/MapObjectHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
// Spawn a character on the stage.
// Opcode: SPAWN_CHAR(160)
class SpawnCharHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Remove a character from the stage.
// Opcode: REMOVE_CHAR(161)
class RemoveCharHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Spawn a pet on the stage.
// Opcode: SPAWN_PET(168)
class SpawnPetHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Move a character.
// Opcode: CHAR_MOVED(185)
class CharMovedHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Update the look of a character.
// Opcode: UPDATE_CHARLOOK(197)
class UpdateCharLookHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Display an effect on a character.
// Opcode: SHOW_FOREIGN_EFFECT(198)
class ShowForeignEffectHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Spawn a mob on the stage.
// Opcode: SPAWN_MOB(236)
class SpawnMobHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Remove a map from the stage, either by killing it or making it invisible.
// Opcode: KILL_MOB(237)
class KillMobHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Spawn a mob on the stage and take control of it.
// Opcode: SPAWN_MOB_C(238)
class SpawnMobControllerHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Update mob state and position with the client.
// Opcode: MOB_MOVED(239)
class MobMovedHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Updates a mob's hp with the client.
// Opcode: SHOW_MOB_HP(250)
class ShowMobHpHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Spawn an npc on the current stage.
// Opcode: SPAWN_NPC(257)
class SpawnNpcHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Spawn an npc on the current stage and take control of it.
// Opcode: SPAWN_NPC_C(259)
class SpawnNpcControllerHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Drop a lootable item on the stage.
// Opcode: DROP_LOOT(268)
class DropLootHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Remove an item from the stage.
// Opcode: REMOVE_LOOT(269)
class RemoveLootHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Parse a ReactorSpawn and send it to the Stage spawn queue.
// Opcode: SPAWN_REACTOR(279)
class SpawnReactorHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Remove a reactor from the stage.
// Opcode: REMOVE_REACTOR(280)
class RemoveReactorHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/MessagingHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "MessagingHandlers.h"

#include "../../Character/Char.h"
#include "../../Data/ItemData.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/Messages.h"
#include "../../IO/UI.h"
#include "../../IO/UITypes/UIStatusBar.h"
#include "../../IO/UITypes/UIStatusMessenger.h"

namespace jrc
{
//! ## Modes:
//!
//! - 0 : Item(0) or Meso(1)
//! - 3 : EXP gain
//! - 4 : Fame
//! - 5 : Mesos
//! - 6 : Guild points
void ShowStatusInfoHandler::handle(InPacket& recv) const
{
    std::int8_t mode = recv.read_byte();
    if (mode == 0) {
        std::int8_t mode2 = recv.read_byte();
        if (mode2 == 0) {
            std::int32_t itemid = recv.read_int();
            std::int32_t qty = recv.read_int();

            const ItemData& idata = ItemData::get(itemid);
            if (!idata.is_valid()) {
                return;
            }

            show_status(Text::WHITE,
                        str::concat("Gained an item: ",
                                    idata.get_name(),
                                    " (",
                                    qty < 0 ? '-' : '+',
                                    std::to_string(qty),
                                    ')'));
        } else if (mode2 == 1) {
            recv.skip(1);

            std::int32_t gain = recv.read_int();

            show_status(Text::WHITE,
                        str::concat("Received mesos (",
                                    gain < 0 ? '-' : '+',
                                    std::to_string(gain),
                                    ')'));
        }
    } else if (mode == 3) {
        bool white = recv.read_bool();
        std::int32_t gain = recv.read_int();
        bool inchat = recv.read_bool();
        std::int32_t bonus1 = recv.read_int();

        recv.read_short();
        recv.read_int();  // bonus 2
        recv.read_bool(); // 'event or party'
        recv.read_int();  // bonus 3
        recv.read_int();  // bonus 4
        recv.read_int();  // bonus 5

        if (inchat) {
            // TODO ?
        } else {
            show_status(white ? Text::WHITE : Text::YELLOW,
                        str::concat("You have gained experience (+",
                                    std::to_string(gain),
                                    ')'));
            if (bonus1 > 0) {
                show_status(Text::YELLOW,
                            str::concat("+ Bonus EXP (+",
                                        std::to_string(bonus1),
                                        ')'));
            }
        }
    } else if (mode == 4) {
        std::int32_t gain = recv.read_int();

        show_status(Text::WHITE,
                    str::concat("Received fame (",
                                gain < 0 ? '-' : '+',
                                std::to_string(gain),
                                ')'));
    } else if (mode == 5) {
        // TODO ?
    }
}

void ShowStatusInfoHandler::show_status(Text::Color color,
                                        std::string&& message) const
{
    if (auto messenger = UI::get().get_element<UIStatusMessenger>()) {
        messenger->show_status(color, std::move(message));
    }
}

void ServerMessageHandler::handle(InPacket& recv) const
{
    std::int8_t type = recv.read_byte();
    bool servermessage = recv.inspect_bool();
    if (servermessage) {
        recv.skip(1);
    }
    std::string message = recv.read_string();

    if (type == 3) {
        recv.read_byte(); // channel
        recv.read_bool(); // megaphone
    } else if (type == 4) {
        UI::get().set_scroll_notice(std::move(message));
    } else if (type == 7) {
        recv.read_int(); // npc_id
    }
}

void WeekEventMessageHandler::handle(InPacket& recv) const
{
    recv.read_byte(); // always 0xFF in solaxia and moople
    std::string message = recv.read_string();

    static constexpr const std::string_view MAPLETIP = "[MapleTip]";
    if (std::string_view(message)
            .substr(0, MAPLETIP.length())
            .compare(MAPLETIP)) {
        message.insert(0, "[Notice] ", 9);
    }

    UI::get().get_element<UIStatusbar>()->send_chatline(std::move(message),
                                                        UIChatbar::YELLOW);
}

void ChatReceivedHandler::handle(InPacket& recv) const
{
    std::int32_t charid = recv.read_int();
    recv.read_bool(); // 'gm'
    std::string message = recv.read_string();
    std::int8_t type = recv.read_byte();

    if (auto character = Stage::get().get_character(charid)) {
        auto char_name = character->get_name();
        message.reserve(message.capacity() + char_name.length() + 2);
        message.insert(0, char_name);
        message.insert(char_name.length(), ": ");
        character->speak(std::string{message});
    }

    auto linetype = static_cast<UIChatbar::LineType>(type);
    if (auto statusbar = UI::get().get_element<UIStatusbar>()) {
        statusbar->send_chatline(std::move(message), linetype);
    }
}

void ScrollResultHandler::handle(InPacket& recv) const
{
    std::int32_t cid = recv.read_int();
    bool success = recv.read_bool();
    bool destroyed = recv.read_bool();
    recv.read_short(); // Legendary Spirit, if `1`.

    CharEffect::Id effect;
    Messages::Type message;
    if (success) {
        effect = CharEffect::SCROLL_SUCCESS;
        message = Messages::SCROLL_SUCCESS;
    } else {
        effect = CharEffect::SCROLL_FAILURE;
        if (destroyed) {
            message = Messages::SCROLL_DESTROYED;
        } else {
            message = Messages::SCROLL_FAILURE;
        }
    }

    Stage::get().show_character_effect(cid, effect);

    if (Stage::get().is_player(cid)) {
        if (auto statusbar = UI::get().get_element<UIStatusbar>()) {
            statusbar->display_message(message, UIChatbar::RED);
        }

        UI::get().enable();
    }
}

void ShowItemGainInChatHandler::handle(InPacket& recv) const
{
    switch (recv.read_byte()) {
    case 3: {
        std::int8_t mode = recv.read_byte();
        if (mode == 1) { // This is _actually_ "item gain in chat".
            std::int32_t itemid = recv.read_int();
            std::int32_t qty = recv.read_int();

            const ItemData& idata = ItemData::get(itemid);
            if (!idata.is_valid()) {
                return;
            }

            if (auto statusbar = UI::get().get_element<UIStatusbar>()) {
                statusbar->send_chatline(str::concat("Gained an item: ",
                                                     idata.get_name(),
                                                     " (",
                                                     qty < 0 ? '-' : '+',
                                                     std::to_string(qty),
                                                     ')'),
                                         UIChatbar::BLUE);
            }
        } else {
            std::cout << "ShowItemGainInChatHandler: mode != 1\n"
                      << std::flush;
        }
        break;
    }
    case 4: {             // pet levelup
        recv.read_byte(); // dummy byte
        [[maybe_unused]] auto pet_index
            = static_cast<std::size_t>(recv.read_byte());
        std::cout << "ShowItemGainInChatHandler: pet levelup\n" << std::flush;
        break;
    }
    case 7: // portal sound
        std::cout << "ShowItemGainInChatHandler: portal sound\n" << std::flush;
        break;
    case 9: // quest complete effect
        std::cout << "ShowItemGainInChatHandler: quest complete effect\n"
                  << std::flush;
        break;
    case 10: { // "show own recovery", used for e.g. chairs
        [[maybe_unused]] std::int8_t amount = recv.read_byte();
        std::cout << "ShowItemGainInChatHandler: show own recovery\n"
                  << std::flush;
        break;
    }
    case 13: // card effect/"show gain card"
        Stage::get().get_player().show_effect_id(CharEffect::MONSTER_CARD);
        break;
    case 14: // monster book pickup effect
        std::cout << "ShowItemGainInChatHandler: monster book pickup effect\n"
                  << std::flush;
        break;
    case 15: // item/equip levelup effect
        std::cout << "ShowItemGainInChatHandler: item/equip levelup effect\n"
                  << std::flush;
        break;
    case 16: { // maker effect
        [[maybe_unused]] bool success = recv.read_int() == 0;
        std::cout << "ShowItemGainInChatHandler: maker effect\n" << std::flush;
        break;
    }
    case 18:                // intro effect
        recv.read_string(); // path
        std::cout << "ShowItemGainInChatHandler: intro effect\n" << std::flush;
        break;
    case 21: { // "show wheels left"
        [[maybe_unused]] auto wheels_left = recv.read_byte();
        std::cout << "ShowItemGainInChatHandler: show wheels left\n"
                  << std::flush;
        break;
    }
    case 23:                // show info
        recv.read_string(); // path
        recv.read_int();    // dummy int
        std::cout << "ShowItemGainInChatHandler: show info\n" << std::flush;
        break;
    default: { // buff effect/"show own buff effect"
        std::int32_t skillid = recv.read_int();
        // More bytes, but we don't need them.
        Stage::get().get_combat().show_player_buff(skillid);
        break;
    }
    }
}
} // namespace jrc

```

`Net/Handlers/MessagingHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Graphics/Text.h"
#include "../PacketHandler.h"

namespace jrc
{
//! Show a status message.
//! Opcode: SHOW_STATUS_INFO(39)
class ShowStatusInfoHandler : public PacketHandler
{
public:
    void handle(InPacket& recv) const override;

private:
    void show_status(Text::Color color, std::string&& message) const;
};

//! Show a server message.
//! Opcode: SERVER_MESSAGE(68)
class ServerMessageHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Show another type of server message.
//! Opcode: WEEK_EVENT_MESSAGE(77)
class WeekEventMessageHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Show a chat message.
//! CHAT_RECEIVED(162)
class ChatReceivedHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Shows the effect of a scroll.
//! Opcode: SCROLL_RESULT(167)
class ScrollResultHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Can contain numerous different effects and messages.
//! Opcode: SHOW_ITEM_GAIN_INCHAT(206)
class ShowItemGainInChatHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/NpcInteractionHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "NpcInteractionHandlers.h"

#include "../../IO/UI.h"
#include "../../IO/UITypes/UINpcTalk.h"
#include "../../IO/UITypes/UIShop.h"

namespace jrc
{
void NpcDialogueHandler::handle(InPacket& recv) const
{
    recv.skip(1);

    std::int32_t npcid = recv.read_int();

    // 0  : Text only.
    // 1  : Yes/no.
    // 4  : Selection.
    // 12 : Accept/decline.
    std::int8_t msgtype = recv.read_byte();

    std::int8_t speaker = recv.read_byte();
    std::string text = recv.read_string();

    std::int16_t style = 0;
    if (msgtype == 0 && recv.length() > 0) {
        style = recv.read_short();
    }

    UI::get().emplace<UINpcTalk>();
    UI::get().enable();

    if (auto npctalk = UI::get().get_element<UINpcTalk>()) {
        npctalk->change_text(npcid, msgtype, style, speaker, std::move(text));
    }
}

void OpenNpcShopHandler::handle(InPacket& recv) const
{
    std::int32_t npcid = recv.read_int();
    auto oshop = UI::get().get_element<UIShop>();

    if (!oshop)
        return;

    UIShop& shop = *oshop;

    shop.reset(npcid);

    std::int16_t size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int32_t itemid = recv.read_int();
        std::int32_t price = recv.read_int();
        std::int32_t pitch = recv.read_int();
        std::int32_t time = recv.read_int();

        recv.skip(4);

        bool norecharge = recv.read_short() == 1;
        if (norecharge) {
            std::int16_t buyable = recv.read_short();

            shop.add_item(itemid, price, pitch, time, buyable);
        } else {
            recv.skip(4);

            std::int16_t rechargeprice = recv.read_short();
            std::int16_t slotmax = recv.read_short();

            shop.add_rechargable(
                itemid, price, pitch, time, rechargeprice, slotmax);
        }
    }
}
} // namespace jrc

```

`Net/Handlers/NpcInteractionHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../PacketHandler.h"

namespace jrc
{
// Handler for a packet which contains npc dialogue.
class NpcDialogueHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

// Opens an npc shop defined by the packet's contents.
class OpenNpcShopHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/PlayerHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "PlayerHandlers.h"

#include "../../Character/Buff.h"
#include "../../Gameplay/Stage.h"
#include "../../IO/UI.h"
#include "../../IO/UITypes/UIBuffList.h"
#include "../../IO/UITypes/UISkillBook.h"
#include "../../IO/UITypes/UIStatsInfo.h"

#include <cstdint>

namespace jrc
{
void KeymapHandler::handle(InPacket& recv) const
{
    recv.skip(1);

    for (std::uint8_t i = 0; i < 90; ++i) {
        auto type = static_cast<std::uint8_t>(recv.read_byte());
        auto action = recv.read_int();

        UI::get().add_keymapping(i, type, action);
    }
}

void SkillMacrosHandler::handle(InPacket& recv) const
{
    auto size = static_cast<std::uint8_t>(recv.read_byte());
    for (std::uint8_t i = 0; i < size; ++i) {
        recv.read_string(); // name
        recv.read_byte();   // 'shout' byte
        recv.read_int();    // skill 1
        recv.read_int();    // skill 2
        recv.read_int();    // skill 3
    }
}

void ChangeStatsHandler::handle(InPacket& recv) const
{
    recv.read_bool(); // 'itemreaction'
    std::int32_t updatemask = recv.read_int();

    bool recalculate = false;
    for (auto iter : Maplestat::codes) {
        if (updatemask & iter.second) {
            recalculate |= handle_stat(iter.first, recv);
        }
    }

    if (recalculate) {
        Stage::get().get_player().recalc_stats(false);
    }

    UI::get().enable();
}

bool ChangeStatsHandler::handle_stat(Maplestat::Id stat, InPacket& recv) const
{
    Player& player = Stage::get().get_player();

    bool recalculate = false;

    switch (stat) {
    case Maplestat::SKIN:
        player.change_look(stat, recv.read_short());
        break;
    case Maplestat::FACE:
    case Maplestat::HAIR:
        player.change_look(stat, recv.read_int());
        break;
    case Maplestat::LEVEL:
        player.change_level(recv.read_byte());
        break;
    case Maplestat::JOB:
        player.change_job(recv.read_short());
        break;
    case Maplestat::EXP:
        player.get_stats().set_exp(recv.read_int());
        break;
    case Maplestat::MESO:
        player.get_inventory().set_meso(recv.read_int());
        break;
    default:
        player.get_stats().set_stat(stat, recv.read_short());
        recalculate = true;
        break;
    }

    bool update_statsinfo = need_statsinfo_update(stat);
    if (update_statsinfo && !recalculate) {
        if (auto stats_info = UI::get().get_element<UIStatsinfo>();
            stats_info) {
            stats_info->update_stat(stat);
        }
    }

    bool update_skillbook = need_skillbook_update(stat);
    if (update_skillbook) {
        std::int16_t value = player.get_stats().get_stat(stat);
        if (auto skillbook = UI::get().get_element<UISkillbook>(); skillbook) {
            skillbook->update_stat(stat, value);
        }
    }

    return recalculate;
}

bool ChangeStatsHandler::need_statsinfo_update(Maplestat::Id stat) const
{
    switch (stat) {
    case Maplestat::JOB:
    case Maplestat::STR:
    case Maplestat::DEX:
    case Maplestat::INT:
    case Maplestat::LUK:
    case Maplestat::HP:
    case Maplestat::MAXHP:
    case Maplestat::MP:
    case Maplestat::MAXMP:
    case Maplestat::AP:
        return true;
    default:
        return false;
    }
}

bool ChangeStatsHandler::need_skillbook_update(Maplestat::Id stat) const
{
    switch (stat) {
    case Maplestat::JOB:
    case Maplestat::SP:
        return true;
    default:
        return false;
    }
}

void BuffHandler::handle(InPacket& recv) const
{
    std::uint64_t firstmask = recv.read_long();
    std::uint64_t secondmask = recv.read_long();

    switch (secondmask) {
    case Buffstat::BATTLESHIP:
        handle_buff(recv, Buffstat::BATTLESHIP);
        return;
    }

    for (auto& iter : Buffstat::first_codes) {
        if (firstmask & iter.second) {
            handle_buff(recv, iter.first);
        }
    }
    for (auto& iter : Buffstat::second_codes) {
        if (secondmask & iter.second) {
            handle_buff(recv, iter.first);
        }
    }

    Stage::get().get_player().recalc_stats(false);
}

void ApplyBuffHandler::handle_buff(InPacket& recv, Buffstat::Id bs) const
{
    std::int16_t value = recv.read_short();
    std::int32_t skillid = recv.read_int();
    std::int32_t duration = recv.read_int();

    Stage::get().get_player().give_buff({bs, value, skillid, duration});

    if (auto bufflist = UI::get().get_element<UIBuffList>()) {
        bufflist->add_buff(skillid, duration);
    }
}

void CancelBuffHandler::handle_buff(InPacket&, Buffstat::Id bs) const
{
    Stage::get().get_player().cancel_buff(bs);
}

void RecalculateStatsHandler::handle(InPacket&) const
{
    Stage::get().get_player().recalc_stats(false);
}

void UpdateSkillHandler::handle(InPacket& recv) const
{
    recv.skip(3);

    std::int32_t skillid = recv.read_int();
    std::int32_t level = recv.read_int();
    std::int32_t masterlevel = recv.read_int();
    std::int64_t expire = recv.read_long();

    Stage::get().get_player().change_skill(
        skillid, level, masterlevel, expire);

    if (auto skillbook = UI::get().get_element<UISkillbook>()) {
        skillbook->update_skills(skillid);
    }

    UI::get().enable();
}

void AddCooldownHandler::handle(InPacket& recv) const
{
    std::int32_t skill_id = recv.read_int();
    std::int16_t cooltime = recv.read_short();

    Stage::get().get_player().add_cooldown(skill_id, cooltime);
}
} // namespace jrc

```

`Net/Handlers/PlayerHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Buff.h"
#include "../../Character/MapleStat.h"
#include "../PacketHandler.h"

namespace jrc
{
//! Parses keymappings and sends them to the Keyboard.
class KeymapHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Parses skill macros.
class SkillMacrosHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Notifies the client of changes in character stats.
//! Opcode: CHANGE_STATS(31)
class ChangeStatsHandler : public PacketHandler
{
public:
    void handle(InPacket& recv) const override;

private:
    bool handle_stat(Maplestat::Id stat, InPacket& recv) const;
    bool need_statsinfo_update(Maplestat::Id stat) const;
    bool need_skillbook_update(Maplestat::Id stat) const;
};

//! Base class for packets which need to parse buffstats.
class BuffHandler : public PacketHandler
{
public:
    void handle(InPacket& recv) const override;

protected:
    virtual void handle_buff(InPacket& recv, Buffstat::Id stat) const = 0;
};

//! Notifies the client that a buff was applied to the player.
//! Opcode: GIVE_BUFF(32)
class ApplyBuffHandler : public BuffHandler
{
protected:
    void handle_buff(InPacket& recv, Buffstat::Id stat) const override;
};

//! Notifies the client that a buff was cancelled.
//! Opcode: CANCEL_BUFF(33)
class CancelBuffHandler : public BuffHandler
{
protected:
    void handle_buff(InPacket& recv, Buffstat::Id stat) const override;
};

//! Force a stats recalculation.
//! Opcode: RECALCULATE_STATS(35)
class RecalculateStatsHandler : public PacketHandler
{
    void handle(InPacket&) const override;
};

//! Updates the player's skills with the client.
//! Opcode: UPDATE_SKILL(36)
class UpdateSkillHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};

//! Notifies the client that a skill is on cooldown.
//! Opcode: ADD_COOLDOWN(234)
class AddCooldownHandler : public PacketHandler
{
    void handle(InPacket& recv) const override;
};
} // namespace jrc

```

`Net/Handlers/SetfieldHandlers.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SetfieldHandlers.h"

#include "../../Audio/Audio.h"
#include "../../Configuration.h"
#include "../../Console.h"
#include "../../Constants.h"
#include "../../Gameplay/Stage.h"
#include "../../Graphics/GraphicsGL.h"
#include "../../IO/UI.h"
#include "../../IO/UITypes/UICharSelect.h"
#include "../../IO/Window.h"
#include "../../Timer.h"
#include "../Packets/GameplayPackets.h"
#include "Helpers/ItemParser.h"
#include "Helpers/LoginParser.h"

namespace jrc
{
void SetfieldHandler::transition(std::int32_t map_id,
                                 std::uint8_t portal_id) const
{
    static constexpr const float fade_step = 0.025f;

    Window::get().fadeout(fade_step, [map_id, portal_id] {
        GraphicsGL::get().clear();
        Stage::get().load(map_id, portal_id);
        UI::get().enable();
        Timer::get().start();
        GraphicsGL::get().unlock();
    });

    GraphicsGL::get().lock();
    Stage::get().clear();
    Timer::get().start();
}

void SetfieldHandler::handle(InPacket& recv) const
{
    std::int32_t channel = recv.read_int();
    Stage::get().set_channel(static_cast<std::uint8_t>(channel));
    std::int8_t mode1 = recv.read_byte();
    std::int8_t mode2 = recv.read_byte();
    if (mode1 == 0 && mode2 == 0) {
        change_map(recv, channel);
    } else {
        set_field(recv);
    }
}

void SetfieldHandler::change_map(InPacket& recv, std::int32_t) const
{
    recv.skip(3);

    std::int32_t map_id = recv.read_int();
    auto portal_id = static_cast<std::uint8_t>(recv.read_byte());

    transition(map_id, portal_id);

    PlayerUpdatePacket{}.dispatch();
}

void SetfieldHandler::set_field(InPacket& recv) const
{
    recv.skip(23);

    std::int32_t cid = recv.read_int();

    auto charselect = UI::get().get_element<UICharSelect>();
    if (charselect) {
        const CharEntry& player_entry = charselect->get_character(cid);
        if (player_entry.cid != cid) {
            return;
        }

        Stage::get().loadplayer(player_entry);
    }

    LoginParser::parse_stats(recv);

    Player& player = Stage::get().get_player();

    recv.read_byte(); // 'buddycap'
    if (recv.read_bool()) {
        recv.read_string(); // 'linkedname'
    }

    parse_inventory(recv, player.get_inventory());
    parse_skillbook(recv, player.get_skills());
    parse_cooldowns(recv, player);
    parse_questlog(recv, player.get_quests());
    parse_minigame(recv);
    parse_ring1(recv);
    parse_ring2(recv);
    parse_ring3(recv);
    parse_telerock(recv, player.get_telerock());
    parse_monsterbook(recv, player.get_monsterbook());
    parse_nyinfo(recv);
    parse_areainfo(recv);

    player.recalc_stats(true);

    std::uint8_t portal_id = player.get_stats().get_portal();
    std::int32_t map_id = player.get_stats().get_map_id();

    transition(map_id, portal_id);

    PlayerUpdatePacket{}.dispatch();

    Sound{Sound::GAME_START}.play();

    UI::get().change_state(UI::GAME);
}

void SetfieldHandler::parse_inventory(InPacket& recv, Inventory& invent) const
{
    invent.set_meso(recv.read_int());
    invent.set_slotmax(InventoryType::EQUIP,
                       static_cast<std::uint8_t>(recv.read_byte()));
    invent.set_slotmax(InventoryType::USE,
                       static_cast<std::uint8_t>(recv.read_byte()));
    invent.set_slotmax(InventoryType::SETUP,
                       static_cast<std::uint8_t>(recv.read_byte()));
    invent.set_slotmax(InventoryType::ETC,
                       static_cast<std::uint8_t>(recv.read_byte()));
    invent.set_slotmax(InventoryType::CASH,
                       static_cast<std::uint8_t>(recv.read_byte()));

    recv.skip(8);

    for (std::size_t i = 0; i < 3; ++i) {
        InventoryType::Id inv
            = i == 0 ? InventoryType::EQUIPPED : InventoryType::EQUIP;
        std::int16_t pos = recv.read_short();
        while (pos != 0) {
            std::int16_t slot = i == 1 ? -pos : pos;
            ItemParser::parse_item(recv, inv, slot, invent);
            pos = recv.read_short();
        }
    }

    recv.skip(2);

    InventoryType::Id toparse[4] = {InventoryType::USE,
                                    InventoryType::SETUP,
                                    InventoryType::ETC,
                                    InventoryType::CASH};

    for (auto inv : toparse) {
        std::int8_t pos = recv.read_byte();
        while (pos != 0) {
            ItemParser::parse_item(recv, inv, pos, invent);
            pos = recv.read_byte();
        }
    }
}

void SetfieldHandler::parse_skillbook(InPacket& recv, Skillbook& skills) const
{
    std::int16_t size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int32_t skill_id = recv.read_int();
        std::int32_t level = recv.read_int();
        std::int64_t expiration = recv.read_long();
        bool fourthtjob = ((skill_id % 100000) / 10000 == 2);
        std::int32_t masterlevel = fourthtjob ? recv.read_int() : 0;
        skills.set_skill(skill_id, level, masterlevel, expiration);
    }
}

void SetfieldHandler::parse_cooldowns(InPacket& recv, Player& player) const
{
    std::int16_t size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int32_t skill_id = recv.read_int();
        std::int32_t cooltime = recv.read_short();
        player.add_cooldown(skill_id, cooltime);
    }
}

void SetfieldHandler::parse_questlog(InPacket& recv, Questlog& quests) const
{
    std::int16_t size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int16_t qid = recv.read_short();
        if (quests.is_started(qid)) {
            std::int16_t qidl = quests.get_last_started();
            quests.add_in_progress(qidl, qid, recv.read_string());
            --i;
        } else {
            quests.add_started(qid, recv.read_string());
        }
    }

    size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int16_t qid = recv.read_short();
        std::int64_t time = recv.read_long();
        quests.add_completed(qid, time);
    }
}

void SetfieldHandler::parse_ring1(InPacket& recv) const
{
    std::int16_t rsize = recv.read_short();
    for (std::int16_t i = 0; i < rsize; ++i) {
        recv.read_int();
        recv.read_padded_string(13);
        recv.read_int();
        recv.read_int();
        recv.read_int();
        recv.read_int();
    }
}

void SetfieldHandler::parse_ring2(InPacket& recv) const
{
    std::int16_t rsize = recv.read_short();
    for (std::int16_t i = 0; i < rsize; ++i) {
        recv.read_int();
        recv.read_padded_string(13);
        recv.read_int();
        recv.read_int();
        recv.read_int();
        recv.read_int();
        recv.read_int();
    }
}

void SetfieldHandler::parse_ring3(InPacket& recv) const
{
    std::int16_t rsize = recv.read_short();
    for (std::int16_t i = 0; i < rsize; ++i) {
        recv.read_int();
        recv.read_int();
        recv.read_int();
        recv.read_short();
        recv.read_int();
        recv.read_int();
        recv.read_padded_string(13);
        recv.read_padded_string(13);
    }
}

void SetfieldHandler::parse_minigame(InPacket& recv) const
{
    std::int16_t mgsize = recv.read_short();
    for (std::int16_t i = 0; i < mgsize; ++i) {
        // TODO
    }
}

void SetfieldHandler::parse_monsterbook(InPacket& recv,
                                        Monsterbook& monsterbook) const
{
    monsterbook.set_cover(recv.read_int());

    recv.skip(1);

    std::int16_t size = recv.read_short();
    for (std::int16_t i = 0; i < size; ++i) {
        std::int16_t cid = recv.read_short();
        std::int8_t mblv = recv.read_byte();

        monsterbook.add_card(cid, mblv);
    }
}

void SetfieldHandler::parse_telerock(InPacket& recv, Telerock& trock) const
{
    for (std::size_t i = 0; i < 5; ++i) {
        trock.addlocation(recv.read_int());
    }

    for (std::size_t i = 0; i < 10; ++i) {
        trock.addviplocation(recv.read_int());
    }
}

void SetfieldHandler::parse_nyinfo(InPacket& recv) const
{
    std::int16_t nysize = recv.read_short();
    for (std::int16_t i = 0; i < nysize; ++i) {
        // TODO
    }
}

void SetfieldHandler::parse_areainfo(InPacket& recv) const
{
    // std::unordered_map<std::int16_t, std::string> area_info;
    std::int16_t ar_size = recv.read_short();
    for (std::int16_t i = 0; i < ar_size; ++i) {
        [[maybe_unused]] std::int16_t area = recv.read_short();
        recv.read_string(); // area_info[area] = recv.read_string();
    }
}
} // namespace jrc

```

`Net/Handlers/SetfieldHandlers.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Player.h"
#include "../PacketHandler.h"

#include <unordered_map>

namespace jrc
{
//! Handler for a packet which contains all character information on first
//! login or warps the player to a different map.
class SetfieldHandler : public PacketHandler
{
public:
    void handle(InPacket& recv) const override;

private:
    void transition(std::int32_t map_id, std::uint8_t portal_id) const;
    void change_map(InPacket& recv, std::int32_t map_id) const;
    void set_field(InPacket& recv) const;

    void parse_inventory(InPacket& recv, Inventory& inventory) const;
    void parse_skillbook(InPacket& recv, Skillbook& skills) const;
    void parse_cooldowns(InPacket& recv, Player& player) const;
    void parse_questlog(InPacket& recv, Questlog& quests) const;
    void parse_ring1(InPacket& recv) const;
    void parse_ring2(InPacket& recv) const;
    void parse_ring3(InPacket& recv) const;
    void parse_minigame(InPacket& recv) const;
    void parse_monsterbook(InPacket& recv, Monsterbook& monsterbook) const;
    void parse_telerock(InPacket& recv, Telerock& telerock) const;
    void parse_nyinfo(InPacket& recv) const;
    void parse_areainfo(InPacket& recv) const;
};
} // namespace jrc

```

`Net/InPacket.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "InPacket.h"

namespace jrc
{
InPacket::InPacket(const std::int8_t* recv, std::size_t length) noexcept
    : bytes(recv), top(length), pos(0)
{
}

bool InPacket::available() const
{
    return length() > 0;
}

std::size_t InPacket::length() const
{
    return top - pos;
}

void InPacket::skip(std::size_t count) noexcept(false)
{
    if (count > length()) {
        throw PacketError("Stack underflow at " + std::to_string(pos));
    }

    pos += count;
}

bool InPacket::read_bool()
{
    return read_byte() == 1;
}

std::int8_t InPacket::read_byte()
{
    return read<std::int8_t>();
}

std::int16_t InPacket::read_short()
{
    return read<std::int16_t>();
}

std::int32_t InPacket::read_int()
{
    return read<std::int32_t>();
}

std::int64_t InPacket::read_long()
{
    return read<std::int64_t>();
}

Point<std::int16_t> InPacket::read_point()
{
    auto x = read<std::int16_t>();
    auto y = read<std::int16_t>();
    return {x, y};
}

std::string InPacket::read_string()
{
    auto length = read<std::uint16_t>();
    return read_padded_string(length);
}

std::string InPacket::read_padded_string(std::uint16_t count)
{
    std::string ret;

    for (std::int16_t i = 0; i < count; ++i) {
        char letter = read_byte();
        if (letter != '\0') {
            ret.push_back(letter);
        }
    }

    return ret;
}

bool InPacket::inspect_bool()
{
    return inspect_byte() == 1;
}

std::int8_t InPacket::inspect_byte()
{
    return inspect<std::int8_t>();
}

std::int16_t InPacket::inspect_short()
{
    return inspect<std::int16_t>();
}

std::int32_t InPacket::inspect_int()
{
    return inspect<std::int32_t>();
}

std::int64_t InPacket::inspect_long()
{
    return inspect<std::int64_t>();
}
} // namespace jrc

```

`Net/InPacket.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Point.h"
#include "PacketError.h"

#include <cstdint>
#include <optional>

namespace jrc
{
//! A packet received from the server.
//! Contains reading functions.
class InPacket
{
public:
    //! Construct a packet from an array of bytes.
    InPacket(const std::int8_t* bytes, std::size_t length) noexcept;

    //! Check if there are more bytes available.
    bool available() const;
    //! Return the remaining length in bytes.
    std::size_t length() const;
    //! Skip a number of bytes (by increasing the offset).
    //!
    //! Throws a `PacketError` if `count > length()`.
    void skip(std::size_t count) noexcept(false);

    //! Read a byte and check if it is 1.
    //!
    //! Throws a `PacketError` on stack underflow.
    bool read_bool() noexcept(false);
    //! Read a byte.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::int8_t read_byte() noexcept(false);
    //! Read a short.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::int16_t read_short() noexcept(false);
    //! Read an int.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::int32_t read_int() noexcept(false);
    //! Read a long.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::int64_t read_long() noexcept(false);

    //! Read a point.
    //!
    //! Throws a `PacketError` on stack underflow.
    Point<std::int16_t> read_point() noexcept(false);

    //! Read a string.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::string read_string() noexcept(false);
    //! Read a fixed-length string.
    //!
    //! Throws a `PacketError` on stack underflow.
    std::string read_padded_string(std::uint16_t length) noexcept(false);

    //! Inspect a byte and check if it is 1. Does not advance the buffer
    //! position.
    bool inspect_bool();
    //! Inspect a byte. Does not advance the buffer position.
    std::int8_t inspect_byte();
    //! Inspect a short. Does not advance the buffer position.
    std::int16_t inspect_short();
    //! Inspect an int. Does not advance the buffer position.
    std::int32_t inspect_int();
    //! Inspect a long. Does not advance the buffer position.
    std::int64_t inspect_long();

private:
    template<typename T>
    //! Read a number and advance the buffer position.
    //!
    //! Throws a `PacketError` on stack underflow.
    T read() noexcept(false)
    {
        constexpr const std::size_t count = sizeof(T);
        T all = 0;
        for (std::size_t i = 0; i < count; ++i) {
            T val = static_cast<std::uint8_t>(bytes[pos]);
            all += val << (8 * i);

            skip(1);
        }

        return all;
    }

    template<typename T>
    //! Read without advancing the buffer position.
    T inspect()
    {
        std::size_t before = pos;
        T value = read<T>();
        pos = before;
        return value;
    }

    const std::int8_t* bytes;
    std::size_t top;
    std::size_t pos;
};
} // namespace jrc

```

`Net/Login.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Character/MapleStat.h"
#include "../Template/EnumMap.h"

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace jrc
{
struct Account {
    std::string name;
    std::int32_t acc_id;
    bool female;
    bool muted;
    std::int16_t pin;
    std::int8_t gm_level;
};

struct World {
    std::string name;
    std::string message;
    std::vector<std::int32_t> channel_loads;
    std::uint8_t channel_count;
    std::uint8_t flag;
    std::int8_t wid;
};

struct StatsEntry {
    std::string name;
    std::vector<std::int64_t> pet_ids;
    EnumMap<Maplestat::Id, std::uint16_t> stats;
    std::int64_t exp;
    std::int32_t map_id;
    std::uint8_t portal;
    std::pair<std::int32_t, std::int8_t> rank;
    std::pair<std::int32_t, std::int8_t> job_rank;
};

struct LookEntry {
    bool female;
    std::uint8_t skin;
    std::int32_t face_id;
    std::int32_t hair_id;
    std::unordered_map<std::int8_t, std::int32_t> equips;
    std::unordered_map<std::int8_t, std::int32_t> masked_equips;
    std::vector<std::int32_t> pet_ids;
};

struct CharEntry {
    StatsEntry stats;
    LookEntry look;
    std::int32_t cid;
};
} // namespace jrc

```

`Net/NetConstants.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstddef>

namespace jrc
{
constexpr const std::size_t HEADER_LENGTH = 4;

constexpr const std::size_t OPCODE_LENGTH = 2;

constexpr const std::size_t MIN_PACKET_LENGTH = HEADER_LENGTH + OPCODE_LENGTH;

constexpr const std::size_t MAX_PACKET_LENGTH = 131072;
} // namespace jrc

```

`Net/OutPacket.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "OutPacket.h"

#include "Session.h"

#include <chrono>

namespace jrc
{
OutPacket::OutPacket(std::int16_t opcode)
{
    write_short(opcode);
}

bool OutPacket::dispatch() noexcept
{
    return Session::get().write(bytes.data(), bytes.size());
}

void OutPacket::skip(std::size_t count)
{
    for (std::size_t i = 0; i < count; ++i) {
        bytes.push_back(0);
    }
}

void OutPacket::write_byte(std::int8_t ch)
{
    bytes.push_back(ch);
}

void OutPacket::write_short(std::int16_t sh)
{
    for (std::size_t i = 0; i < 2; ++i) {
        write_byte(static_cast<std::int8_t>(sh));
        sh >>= 8;
    }
}

void OutPacket::write_int(std::int32_t in)
{
    for (std::size_t i = 0; i < 4; ++i) {
        write_byte(static_cast<std::int8_t>(in));
        in >>= 8;
    }
}

void OutPacket::write_long(std::int64_t lg)
{
    for (std::size_t i = 0; i < 8; ++i) {
        write_byte(static_cast<std::int8_t>(lg));
        lg >>= 8;
    }
}

void OutPacket::write_time()
{
    auto duration = std::chrono::steady_clock::now().time_since_epoch();
    auto since_epoch
        = std::chrono::duration_cast<std::chrono::milliseconds>(duration);
    auto timestamp = static_cast<std::int32_t>(since_epoch.count());
    write_int(timestamp);
}

void OutPacket::write_point(Point<std::int16_t> position)
{
    write_short(position.x());
    write_short(position.y());
}

void OutPacket::write_string(std::string_view str)
{
    std::int16_t length = static_cast<std::int16_t>(str.length());
    write_short(length);

    for (std::int16_t i = 0; i < length; ++i) {
        write_byte(str[i]);
    }
}
} // namespace jrc

```

`Net/OutPacket.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Template/Point.h"

#include <cstdint>
#include <string>
#include <vector>

namespace jrc
{
//! A packet to be sent to the server. Used as a base class to create specific
//! packets.
class OutPacket
{
public:
    enum Opcode : std::uint16_t;

    //! Construct a packet by writing its opcode.
    OutPacket(std::int16_t opcode);

    bool dispatch() noexcept;

protected:
    //! Skip a number of bytes (filled with zeroes).
    void skip(std::size_t count);
    //! Write a byte.
    void write_byte(std::int8_t ch);
    //! Write a short.
    void write_short(std::int16_t sh);
    //! Write an int.
    void write_int(std::int32_t in);
    //! Write a long.
    void write_long(std::int64_t lg);

    //! Write a point, one short for x and one for y.
    void write_point(Point<std::int16_t> point);
    //! Write a timestamp as an integer.
    void write_time();
    //! Write a string. Writes the length as a short
    //! and then each individual character as a byte.
    void write_string(std::string_view str);

private:
    std::vector<std::int8_t> bytes;
};

//! Opcodes for `OutPacket`s associated with version 83 of the game.
enum OutPacket::Opcode : std::uint16_t {
    // Login
    LOGIN = 0x01,
    SERVERLIST_REREQUEST = 0x04,
    CHARLIST_REQUEST = 0x05,
    STATUS_REQUEST = 0x06,
    ACCEPT_TOS = 0x07,
    SET_GENDER = 0x08,
    AFTER_LOGIN = 0x09,
    REGISTER_PIN = 0x0A,
    SERVERLIST_REQUEST = 0x0B,
    SELECT_CHAR = 0x13,
    PLAYER_LOGIN = 0x14,
    NAME_CHAR = 0x15,
    CREATE_CHAR = 0x16,
    DELETE_CHAR = 0x17,
    PONG = 0x18,
    REGISTER_PIC = 0x1D,
    SELECT_CHAR_PIC = 0x1E,

    // Gameplay 1
    CHANGE_MAP = 0x26,
    CHANGE_CHANNEL = 0x27,
    MOVE_PLAYER = 0x29,
    CLOSE_ATTACK = 0x2C,
    RANGED_ATTACK = 0x2D,
    MAGIC_ATTACK = 0x2E,
    TAKE_DAMAGE = 0x30,

    // Messaging
    GENERAL_CHAT = 0x31,

    // NPC interaction
    TALK_TO_NPC = 0x3A,
    NPC_TALK_MORE = 0x3C,
    NPC_SHOP_ACTION = 0x3D,

    // Inventory
    GATHER_ITEMS = 0x45,
    SORT_ITEMS = 0x46,
    MOVE_ITEM = 0x47,
    USE_ITEM = 0x48,
    SCROLL_EQUIP = 0x56,

    // Player
    SPEND_AP = 0x57,
    SPEND_SP = 0x5A,

    // Skill
    USE_SKILL = 0x5B,

    // Gameplay 2
    PARTY_OPERATION = 0x7C,
    CHANGE_KEYMAP = 0x87,
    MOVE_MONSTER = 0xBC,
    PICKUP_ITEM = 0xCA,
    PLAYER_UPDATE = 0xDF,

    // Custom
    HASH_CHECK = 0x7530
};
} // namespace jrc

```

`Net/PacketError.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Util/Str.h"

#include <stdexcept>
#include <string>
#include <string_view>

namespace jrc
{
//! Error which is thrown by packet handling functions.
class PacketError : public std::runtime_error
{
public:
    explicit PacketError(std::string_view msg) noexcept
        : std::runtime_error(str::concat(PREFIX, msg))
    {
    }

    //! Explicit copy constructor so that we can assure the compiler that
    //! it does not throw (because doing so results in UB).
    PacketError(const PacketError& other) noexcept = default;

private:
    static constexpr const std::string_view PREFIX = "[Packet error] ";
};
} // namespace jrc

```

`Net/PacketHandler.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "InPacket.h"

namespace jrc
{
//! Interface for classes that handle `InPacket`s.
class PacketHandler
{
public:
    virtual ~PacketHandler() = default;

    virtual void handle(InPacket& recv) const = 0;
};
} // namespace jrc

```

`Net/PacketSwitch.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "PacketSwitch.h"

#include "../Console.h"
#include "Handlers/AttackHandlers.h"
#include "Handlers/CommonHandlers.h"
#include "Handlers/InventoryHandlers.h"
#include "Handlers/LoginHandlers.h"
#include "Handlers/MapObjectHandlers.h"
#include "Handlers/MessagingHandlers.h"
#include "Handlers/NpcInteractionHandlers.h"
#include "Handlers/PlayerHandlers.h"
#include "Handlers/SetfieldHandlers.h"

#include <cstdint>

namespace jrc
{
//! Opcodes for InPackets.
enum PacketSwitch::Opcode : std::uint16_t {
    // Login 1
    LOGIN_RESULT = 0x00,
    SERVERLIST = 0x0A,
    CHARLIST = 0x0B,
    SERVER_IP = 0x0C,
    CHARNAME_RESPONSE = 0x0D,
    ADD_NEWCHAR_ENTRY = 0x0E,
    DELCHAR_RESPONSE = 0x0F,
    CHANNEL_CHANGE = 0x10,
    PING = 0x11,

    // Player 1
    APPLY_BUFF = 0x14,

    // Login 2
    SELECT_WORLD = 0x1A,
    RECOMMENDED_WORLDS = 0x1B,

    // Inventory 1
    MODIFY_INVENTORY = 0x1D,

    // Player 2
    CHANGE_STATS = 0x1F,
    GIVE_BUFF = 0x20,
    CANCEL_BUFF = 0x21,
    RECALCULATE_STATS = 0x23,
    UPDATE_SKILL = 0x24,

    // Messaging 1
    SHOW_STATUS_INFO = 0x27,
    MEMO_RESULT = 0x29,
    ENABLE_REPORT = 0x2F,

    // Inventory 2
    GATHER_RESULT = 0x34,
    SORT_RESULT = 0x35,

    // Player 3
    UPDATE_GENDER = 0x3A,
    BUDDY_LIST = 0x3F,
    GUILD_OPERATION = 0x41,

    // Messaging 2
    SERVER_MESSAGE = 0x44,
    WEEK_EVENT_MESSAGE = 0x4D,

    FIELD_SET_VARIABLE = 0x5C,
    FAMILY_PRIV_LIST = 0x64,
    CANCEL_RENAME_BY_OTHER = 0x78,
    SCRIPT_PROGRESS_MESSAGE = 0x7A,
    RECEIVE_POLICE = 0x7B,
    SKILL_MACROS = 0x7C,
    SET_FIELD = 0x7D,
    FIELD_EFFECT = 0x8A,
    CLOCK = 0x93,

    // Mapobject
    SPAWN_CHAR = 0xA0,
    REMOVE_CHAR = 0xA1,

    // Messaging
    CHAT_RECEIVED = 0xA2,
    SCROLL_RESULT = 0xA7,

    // Mapobject
    SPAWN_PET = 0xA8,
    CHAR_MOVED = 0xB9,

    // Attack
    ATTACKED_CLOSE = 0xBA,
    ATTACKED_RANGED = 0xBB,
    ATTACKED_MAGIC = 0xBC,

    SHOW_ITEM_EFFECT = 0xC2,
    SHOW_CHAIR = 0xC4,
    UPDATE_CHARLOOK = 0xC5,
    SHOW_FOREIGN_EFFECT = 0xC6,
    SHOW_ITEM_GAIN_INCHAT = 0xCE, // This is terribly named.
    LOCK_UI = 0xDD,
    TOGGLE_UI = 0xDE,

    // Player
    ADD_COOLDOWN = 0xEA,

    // Mapobject
    SPAWN_MOB = 0xEC,
    KILL_MOB = 0xED,
    SPAWN_MOB_C = 0xEE,
    MOB_MOVED = 0xEF,
    MOVE_MOB_RESPONSE = 0xF0,
    SHOW_MOB_HP = 0xFA,
    SPAWN_NPC = 0x0101,
    SPAWN_NPC_C = 0x0103,
    MAKE_NPC_SCRIPTED = 0x0107,
    DROP_LOOT = 0x010C,
    REMOVE_LOOT = 0x010D,
    SPAWN_REACTOR = 0x0117,
    REMOVE_REACTOR = 0x0118,

    // NPC Interaction
    NPC_DIALOGUE = 0x0130,
    OPEN_NPC_SHOP = 0x0131,

    KEYMAP = 0x014F
};

PacketSwitch::PacketSwitch()
{
    // Common handlers
    emplace<PING, PingHandler>();

    // Login handlers
    emplace<LOGIN_RESULT, LoginResultHandler>();
    emplace<SERVERLIST, ServerlistHandler>();
    emplace<CHARLIST, CharlistHandler>();
    emplace<CHARNAME_RESPONSE, CharnameResponseHandler>();
    emplace<ADD_NEWCHAR_ENTRY, AddNewCharEntryHandler>();
    emplace<DELCHAR_RESPONSE, DeleteCharResponseHandler>();
    emplace<CHANNEL_CHANGE, ChannelChangeHandler>();
    emplace<SERVER_IP, ServerIPHandler>();

    // 'Setfield' handlers
    emplace<SET_FIELD, SetfieldHandler>();

    // MapObject handlers
    emplace<SPAWN_CHAR, SpawnCharHandler>();
    emplace<CHAR_MOVED, CharMovedHandler>();
    emplace<UPDATE_CHARLOOK, UpdateCharLookHandler>();
    emplace<SHOW_FOREIGN_EFFECT, ShowForeignEffectHandler>();
    emplace<REMOVE_CHAR, RemoveCharHandler>();
    emplace<SPAWN_PET, SpawnPetHandler>();
    emplace<SPAWN_NPC, SpawnNpcHandler>();
    emplace<SPAWN_NPC_C, SpawnNpcControllerHandler>();
    emplace<SPAWN_MOB, SpawnMobHandler>();
    emplace<SPAWN_MOB_C, SpawnMobControllerHandler>();
    emplace<MOB_MOVED, MobMovedHandler>();
    emplace<SHOW_MOB_HP, ShowMobHpHandler>();
    emplace<KILL_MOB, KillMobHandler>();
    emplace<DROP_LOOT, DropLootHandler>();
    emplace<REMOVE_LOOT, RemoveLootHandler>();
    emplace<SPAWN_REACTOR, SpawnReactorHandler>();
    emplace<REMOVE_REACTOR, RemoveReactorHandler>();

    // Attack handlers
    emplace<ATTACKED_CLOSE, CloseAttackHandler>();
    emplace<ATTACKED_RANGED, RangedAttackHandler>();
    emplace<ATTACKED_MAGIC, MagicAttackHandler>();

    // Player handlers
    emplace<KEYMAP, KeymapHandler>();
    emplace<SKILL_MACROS, SkillMacrosHandler>();
    emplace<CHANGE_STATS, ChangeStatsHandler>();
    emplace<GIVE_BUFF, ApplyBuffHandler>();
    emplace<CANCEL_BUFF, CancelBuffHandler>();
    emplace<RECALCULATE_STATS, RecalculateStatsHandler>();
    emplace<UPDATE_SKILL, UpdateSkillHandler>();
    emplace<ADD_COOLDOWN, AddCooldownHandler>();

    // Messaging handlers
    emplace<SHOW_STATUS_INFO, ShowStatusInfoHandler>();
    emplace<CHAT_RECEIVED, ChatReceivedHandler>();
    emplace<SCROLL_RESULT, ScrollResultHandler>();
    emplace<SERVER_MESSAGE, ServerMessageHandler>();
    emplace<WEEK_EVENT_MESSAGE, WeekEventMessageHandler>();
    emplace<SHOW_ITEM_GAIN_INCHAT, ShowItemGainInChatHandler>();

    // Inventory Handlers
    emplace<MODIFY_INVENTORY, ModifyInventoryHandler>();
    emplace<GATHER_RESULT, GatherResultHandler>();
    emplace<SORT_RESULT, SortResultHandler>();

    // Npc Interaction Handlers
    emplace<NPC_DIALOGUE, NpcDialogueHandler>();
    emplace<OPEN_NPC_SHOP, OpenNpcShopHandler>();

    // TODO
    emplace<MOVE_MOB_RESPONSE, NullHandler>();
    emplace<MEMO_RESULT, NullHandler>();
    emplace<ENABLE_REPORT, NullHandler>();
    emplace<BUDDY_LIST, NullHandler>();
    emplace<GUILD_OPERATION, NullHandler>();
    emplace<FAMILY_PRIV_LIST, NullHandler>();
    emplace<SCRIPT_PROGRESS_MESSAGE, NullHandler>();
    emplace<RECEIVE_POLICE, NullHandler>();
    emplace<MAKE_NPC_SCRIPTED, NullHandler>();

    // Ignored
    emplace<SELECT_WORLD, NullHandler>();
    emplace<RECOMMENDED_WORLDS, NullHandler>();
    emplace<UPDATE_GENDER, NullHandler>();
}

void PacketSwitch::forward(const std::int8_t* bytes, std::size_t length) const
{
    // Wrap the bytes with a parser.
    InPacket recv{bytes, length};
    // Read the opcode to determine handler responsible.
    auto opcode = static_cast<std::uint16_t>(recv.read_short());

    if (opcode < NUM_HANDLERS) {
        if (auto& handler = handlers[opcode]) {
            // Handler ok. Packet is passed on.
            try {
                handler->handle(recv);
            } catch (const PacketError& err) {
                // Notice about an error.
                warn(err.what(), opcode);
            }
        } else {
            // Warn about an unhandled packet.
            warn(MSG_UNHANDLED, opcode);
        }
    } else {
        // Warn about a packet with opcode out of bounds.
        warn(MSG_OUT_OF_BOUNDS, opcode);
    }
}

void PacketSwitch::warn(std::string_view message, std::size_t opcode) const
    noexcept
{
    Console::get().print(
        str::concat(message, ", Opcode: ", str::to_hex(opcode)));
}
} // namespace jrc

```

`Net/PacketSwitch.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "PacketHandler.h"

#include <array>
#include <memory>
#include <type_traits>

namespace jrc
{
//! Class which contains the array of handler classes to use.
class PacketSwitch
{
public:
    //! Register all handlers.
    PacketSwitch();

    //! Forward a packet to the correct handler.
    void forward(const std::int8_t* bytes, std::size_t length) const;

private:
    //! Print a warning to the console about something strange or amiss in
    //! the packet switcher.
    void warn(std::string_view message, std::size_t opcode) const noexcept;

    //! Opcodes for which handlers can be registered.
    enum Opcode : std::uint16_t;

    //! Message when an unhandled packet is received.
    static constexpr const char* MSG_UNHANDLED = "Unhandled packet detected";
    //! Message when a packet with a larger opcode than the array size is
    //! received.
    static constexpr const char* MSG_OUT_OF_BOUNDS = "Large opcode detected";
    //! Message when a handler is registered more than once.
    static constexpr const char* MSG_REREGISTER
        = "Handler was registered twice";
    //! Maximum number of handlers needed.
    static constexpr const std::size_t NUM_HANDLERS = 500;

    std::array<std::unique_ptr<PacketHandler>, NUM_HANDLERS> handlers;

    //! Register a handler for the specified opcode.
    template<std::size_t O, typename T, typename... Args>
    void emplace(Args&&... args)
    {
        static_assert(O < NUM_HANDLERS,
                      "PacketSwitch::emplace - Opcode out of array bounds.");
        static_assert(
            std::is_base_of<PacketHandler, T>::value,
            "Error: Packet handlers must derive from PacketHandler.");

        if (handlers[O]) {
            warn(MSG_REREGISTER, O);
        }

        handlers[O] = std::make_unique<T>(std::forward<Args>(args)...);
    }
};
} // namespace jrc

```

`Net/Packets/AttackAndSkillPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Gameplay/Combat/Attack.h"
#include "../OutPacket.h"

namespace jrc
{
//! Notifies the server of an attack. The opcode is determined by the attack
//! type. Attack::CLOSE = CLOSE_ATTACK(44) Attack::RANGED = RANGED_ATTACK(45)
//! Attack::MAGIC = MAGIC_ATTACK(46)
class AttackPacket : public OutPacket
{
public:
    AttackPacket(const AttackResult& attack)
        : OutPacket(opcodefor(attack.type))
    {
        skip(1);

        write_byte((attack.mob_count << 4) | attack.hit_count);
        write_int(attack.skill);
        if (attack.charge > 0) {
            write_int(attack.charge);
        }

        skip(8);

        write_byte(attack.display);
        write_byte(attack.to_left);
        write_byte(attack.stance);

        skip(1);

        write_byte(attack.speed);

        if (attack.type == Attack::RANGED) {
            skip(1);
            write_byte(attack.to_left);
            skip(7);
            // skip(4); if hurricane, piercing arrow or rapidfire
        } else {
            skip(4);
        }

        for (auto& damagetomob : attack.damage_lines) {
            write_int(damagetomob.first);

            skip(14);

            for (auto& singledamage : damagetomob.second) {
                write_int(singledamage.first);
                // add critical here
            }

            if (attack.skill != 5221004) {
                skip(4);
            }
        }
    }

private:
    static OutPacket::Opcode opcodefor(Attack::Type type)
    {
        switch (type) {
        case Attack::CLOSE:
            return CLOSE_ATTACK;
        case Attack::RANGED:
            return RANGED_ATTACK;
        default:
            return MAGIC_ATTACK;
        }
    }
};

//! Tells the server that the player took damage.
//! Opcode: TAKE_DAMAGE(48)
class TakeDamagePacket : public OutPacket
{
public:
    enum From : std::int8_t { TOUCH = -1 };

    TakeDamagePacket(std::int8_t from,
                     std::uint8_t element,
                     std::int32_t damage,
                     std::int32_t mobid,
                     std::int32_t oid,
                     std::uint8_t direction)
        : OutPacket(TAKE_DAMAGE)
    {
        write_time();
        write_byte(from);
        write_byte(element);
        write_int(damage);
        write_int(mobid);
        write_int(oid);
        write_byte(direction);
    }

    //! From mob attack result.
    TakeDamagePacket(const MobAttackResult& result, From from)
        : TakeDamagePacket{from,
                           0,
                           result.damage,
                           result.mob_id,
                           result.oid,
                           result.direction}
    {
    }
};

//! Packet which notifies the server of a skill usage.
//! Opcode: USE_SKILL(91)
class UseSkillPacket : public OutPacket
{
public:
    UseSkillPacket(std::int32_t skillid, std::int32_t level)
        : OutPacket(USE_SKILL)
    {
        write_time();
        write_int(skillid);
        write_byte(static_cast<std::uint8_t>(level));

        // if monster magnet : some more bytes

        if (skillid % 10000000 == 1004) {
            skip(2); // no idea what this could be
        }

        // a point (4 bytes) could be added at the end
    }
};
} // namespace jrc

```

`Net/Packets/CharCreationPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

#include <string_view>

namespace jrc
{
//! Reserve a name for the character to be created.
//! Opcode: NAME_CHAR(21)
class NameCharPacket : public OutPacket
{
public:
    NameCharPacket(std::string_view name) : OutPacket(NAME_CHAR)
    {
        write_string(name);
    }
};

//! Requests creation of a character with the specified stats.
//! Opcode: CREATE_CHAR(22)
class CreateCharPacket : public OutPacket
{
public:
    CreateCharPacket(std::string_view name,
                     std::uint16_t job,
                     std::int32_t face,
                     std::int32_t hair,
                     std::uint8_t hairc,
                     std::uint8_t skin,
                     std::int32_t top,
                     std::int32_t bot,
                     std::int32_t shoes,
                     std::int32_t weapon,
                     bool female)
        : OutPacket(CREATE_CHAR)
    {
        write_string(name);
        write_int(job);
        write_int(face);
        write_int(hair);
        write_int(hairc);
        write_int(skin);
        write_int(top);
        write_int(bot);
        write_int(shoes);
        write_int(weapon);
        write_byte(female);
    }
};
} // namespace jrc

```

`Net/Packets/CommonPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

namespace jrc
{
//! Packet which notifies the server that the connection is still alive.
//! Opcode: PONG(24)
class PongPacket : public OutPacket
{
public:
    PongPacket() : OutPacket(PONG)
    {
    }
};
} // namespace jrc

```

`Net/Packets/CustomPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

#ifdef JOURNEY_USE_XXHASH
#    include "../../Util/HashUtility.h"
#    include "../../Util/NxFiles.h"
#endif

namespace jrc
{
#ifdef JOURNEY_USE_XXHASH
// Packet which sends the hash values of all game files to the server.
// Opcode: HASH_CHECK(30000)
class NxCheckPacket : public OutPacket
{
public:
    NxCheckPacket(std::uint64_t seed) : OutPacket(HASH_CHECK)
    {
        write_byte(NxFiles::NUM_FILES);
        for (auto filename : NxFiles::filenames) {
            write_string(HashUtility::get_filehash(filename, seed));
        }
    }
};
#endif
} // namespace jrc

```

`Net/Packets/GameplayPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "MovementPacket.h"

#include <string_view>
#include <unordered_map>

namespace jrc
{
//! Requests the server to warp the player to a different map.
//! Opcode: CHANGE_MAP(0x26)
class ChangeMapPacket : public OutPacket
{
public:
    ChangeMapPacket(bool died,
                    std::int32_t target_id,
                    std::string_view target_p,
                    bool use_wheel)
        : OutPacket(CHANGE_MAP)
    {
        write_byte(died);
        write_int(target_id);
        write_string(target_p);
        skip(1);
        write_short(static_cast<std::int16_t>(use_wheel ? 1 : 0));
    }
};

//! Requests a channel change from the server.
//! `channel` is 0-indexed.
//! Opcode: CHANGE_CHANNEL(0x27)
class ChangeChannelPacket : public OutPacket
{
public:
    ChangeChannelPacket(std::uint8_t channel) : OutPacket(CHANGE_CHANNEL)
    {
        write_byte(channel);
        write_time();
    }
};

//! Updates the player's position with the server.
//! Opcode: MOVE_PLAYER(41)
class MovePlayerPacket : public MovementPacket
{
public:
    MovePlayerPacket(const Movement& movement) : MovementPacket(MOVE_PLAYER)
    {
        skip(9);
        write_byte(1);
        writemovement(movement);
    }
};

//! Requests one or more new keybindings to be registered.
//! Opcode: CHANGE_KEYMAP(0x87)
class ChangeKeymapPacket : public OutPacket
{
public:
    template<typename KeyboardMapping>
    ChangeKeymapPacket(
        const std::unordered_map<std::uint8_t, KeyboardMapping>& maplekeys)
        : OutPacket{CHANGE_KEYMAP}
    {
        // Mode
        write_int(0);

        // Number of changes
        write_int(static_cast<std::int32_t>(maplekeys.size()));

        for (const auto& [key, mapping] : maplekeys) {
            const auto [type, action] = mapping;

            write_int(key);
            write_byte(static_cast<std::int8_t>(type));
            write_int(action);
        }
    }
};

//! Requests various party-related things.
//! Opcode: PARTY_OPERATION(124)
class PartyOperationPacket : public OutPacket
{
public:
    enum Operation : std::int8_t {
        CREATE = 1,
        LEAVE = 2,
        JOIN = 3,
        INVITE = 4,
        EXPEL = 5,
        PASS_LEADER = 6
    };

protected:
    PartyOperationPacket(Operation op) : OutPacket(PARTY_OPERATION)
    {
        write_byte(op);
    }
};

//! Creates a new party.
//! Operation: CREATE(1)
class CreatePartyPacket : public PartyOperationPacket
{
public:
    CreatePartyPacket() : PartyOperationPacket(CREATE)
    {
    }
};

//! Leaves a party.
//! Operation: LEAVE(2)
class LeavePartyPacket : public PartyOperationPacket
{
public:
    LeavePartyPacket() : PartyOperationPacket(LEAVE)
    {
    }
};

//! Joins a party.
//! Operation: JOIN(3)
class JoinPartyPacket : public PartyOperationPacket
{
public:
    JoinPartyPacket(std::int32_t party_id) : PartyOperationPacket(JOIN)
    {
        write_int(party_id);
    }
};

//! Invites a player to a party.
//! Operation: INVITE(4)
class InviteToPartyPacket : public PartyOperationPacket
{
public:
    InviteToPartyPacket(std::string_view name) : PartyOperationPacket(INVITE)
    {
        write_string(name);
    }
};

//! Expels someone from a party.
//! Operation: EXPEL(5)
class ExpelFromPartyPacket : public PartyOperationPacket
{
public:
    ExpelFromPartyPacket(std::int32_t cid) : PartyOperationPacket(EXPEL)
    {
        write_int(cid);
    }
};

//! Passes party leadership to another character.
//! Operation: PASS_LEADER(6)
class ChangePartyLeaderPacket : public PartyOperationPacket
{
public:
    ChangePartyLeaderPacket(std::int32_t cid)
        : PartyOperationPacket(PASS_LEADER)
    {
        write_int(cid);
    }
};

//! Updates a mob's position with the server.
//! Opcode: MOVE_MONSTER(188)
class MoveMobPacket : public MovementPacket
{
public:
    MoveMobPacket(std::int32_t oid,
                  std::int16_t type,
                  std::int8_t skillb,
                  std::int8_t skill0,
                  std::int8_t skill1,
                  std::int8_t skill2,
                  std::int8_t skill3,
                  std::int8_t skill4,
                  Point<std::int16_t> startpos,
                  const Movement& movement)
        : MovementPacket(MOVE_MONSTER)
    {
        write_int(oid);
        write_short(type);
        write_byte(skillb);
        write_byte(skill0);
        write_byte(skill1);
        write_byte(skill2);
        write_byte(skill3);
        write_byte(skill4);

        skip(13);

        write_point(startpos);

        write_byte(1);
        writemovement(movement);
    }
};

//! Requests picking up an item.
//! Opcode: PICKUP_ITEM(202)
class PickupItemPacket : public OutPacket
{
public:
    PickupItemPacket(std::int32_t oid, Point<std::int16_t> position)
        : OutPacket(PICKUP_ITEM)
    {
        write_int(0);
        write_byte(0);
        write_point(position);
        write_int(oid);
    }
};

//! Tells the server that we're no longer transitioning between maps,
//! including initial login.
//! Opcode: PLAYER_UPDATE(0xDF)
class PlayerUpdatePacket : public OutPacket
{
public:
    PlayerUpdatePacket() : OutPacket(PLAYER_UPDATE)
    {
    }
};
} // namespace jrc

```

`Net/Packets/InventoryPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/Inventory/Inventory.h"
#include "../OutPacket.h"

namespace jrc
{
//! Packet which requests that the inventory is sorted.
//! Opcode: GATHER_ITEMS(69)
class GatherItemsPacket : public OutPacket
{
public:
    GatherItemsPacket(InventoryType::Id type) : OutPacket(GATHER_ITEMS)
    {
        write_time();
        write_byte(type);
    }
};

//! Packet which requests that the inventory is sorted.
//! Opcode: SORT_ITEMS(70)
class SortItemsPacket : public OutPacket
{
public:
    SortItemsPacket(InventoryType::Id type) : OutPacket(SORT_ITEMS)
    {
        write_time();
        write_byte(type);
    }
};

//! Packet which requests that an item is moved.
//! Opcode: MOVE_ITEM(71)
class MoveItemPacket : public OutPacket
{
public:
    MoveItemPacket(InventoryType::Id type,
                   std::int16_t slot,
                   std::int16_t action,
                   std::int16_t qty)
        : OutPacket(MOVE_ITEM)
    {
        write_time();
        write_byte(type);
        write_short(slot);
        write_short(action);
        write_short(qty);
    }
};

//! Packet which requests that an item is equipped.
//! Opcode: MOVE_ITEM(71)
class EquipItemPacket : public MoveItemPacket
{
public:
    EquipItemPacket(std::int16_t src, Equipslot::Id dest)
        : MoveItemPacket(InventoryType::EQUIP, src, -dest, 1)
    {
    }
};

//! Packet which requests that an item is unequipped.
//! Opcode: MOVE_ITEM(71)
class UnequipItemPacket : public MoveItemPacket
{
public:
    UnequipItemPacket(std::int16_t src, std::int16_t dest)
        : MoveItemPacket(InventoryType::EQUIPPED, -src, dest, 1)
    {
    }
};

//! A packet which requests that an 'USE' item is used.
//! Opcode: USE_ITEM(72)
class UseItemPacket : public OutPacket
{
public:
    UseItemPacket(std::int16_t slot, std::int32_t item_id)
        : OutPacket{USE_ITEM}
    {
        // write_time(); // HeavenMS does not read this int.
        write_int(0);
        write_short(slot);
        write_int(item_id);
    }
};

//! Requests using a scroll on an equip.
//! Opcode: SCROLL_EQUIP(86)
class ScrollEquipPacket : public OutPacket
{
public:
    enum Flag : std::uint8_t {
        NONE = 0b00000000,
        UNKNOWN = 0b00000001,
        WHITESCROLL = 0b00000010
    };

    ScrollEquipPacket(std::int16_t source,
                      Equipslot::Id target,
                      std::uint8_t flags)
        : OutPacket(SCROLL_EQUIP)
    {
        write_time();
        write_short(source);
        write_short(-target);
        write_short(flags);
    }

    ScrollEquipPacket(std::int16_t source, Equipslot::Id target)
        : ScrollEquipPacket(source, target, 0)
    {
    }
};
} // namespace jrc

```

`Net/Packets/LoginPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

#include <string_view>

namespace jrc
{
//! Accept the Terms of Service.
//! Opcode: ACCEPT_TOS(0x07)
class TOSPacket : public OutPacket
{
public:
    TOSPacket() : OutPacket(ACCEPT_TOS)
    {
        write_byte(1);
    }
};

//! Request to be logged-in to an account.
//! Opcode: LOGIN(0x01) [LOGIN_PASSWORD(0x01) for OdinMS-based sources]
class LoginPacket : public OutPacket
{
public:
    LoginPacket(std::string_view acc, std::string_view pass) : OutPacket(LOGIN)
    {
        write_string(acc);
        write_string(pass);
    }
};

//! Requests the list of worlds and channels.
//! Opcode: SERVERLIST_REQUEST(0x0B)
class ServerRequestPacket : public OutPacket
{
public:
    ServerRequestPacket() : OutPacket(SERVERLIST_REQUEST)
    {
    }
};

//! Requests the list of characters on a world.
//! Opcode: CHARLIST_REQUEST(0x05)
class CharlistRequestPacket : public OutPacket
{
public:
    CharlistRequestPacket(std::uint8_t world, std::uint8_t channel)
        : OutPacket(CHARLIST_REQUEST)
    {
        write_byte(0);
        write_byte(world);
        write_byte(channel);
    }
};

//! Requests being logged-in to a channel server with the specified character.
//! Opcode: PLAYER_LOGIN(0x14) [PLAYER_LOGGEDIN(0x14) for OdinMS-based sources]
class PlayerLoginPacket : public OutPacket
{
public:
    PlayerLoginPacket(std::int32_t cid) : OutPacket(PLAYER_LOGIN)
    {
        write_int(cid);
    }
};
} // namespace jrc

```

`Net/Packets/MessagingPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

namespace jrc
{
//! Packet which sends a message to general chat.
//! Opcode: GENERAL_CHAT(49)
class GeneralChatPacket : public OutPacket
{
public:
    GeneralChatPacket(std::string_view message, bool show)
        : OutPacket(GENERAL_CHAT)
    {
        write_string(message);
        write_byte(show);
    }
};
} // namespace jrc

```

`Net/Packets/MovementPacket.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Gameplay/Movement.h"
#include "../OutPacket.h"

namespace jrc
{
//! Base class for packets which update object movements with the server.
class MovementPacket : public OutPacket
{
public:
    MovementPacket(OutPacket::Opcode opc) : OutPacket(opc)
    {
    }

protected:
    void writemovement(const Movement& movement)
    {
        write_byte(movement.command);
        write_short(movement.xpos);
        write_short(movement.ypos);
        write_short(movement.lastx);
        write_short(movement.lasty);
        write_short(movement.fh);
        write_byte(movement.newstate);
        write_short(movement.duration);
    }
};
} // namespace jrc

```

`Net/Packets/NpcInteractionPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

namespace jrc
{
//! Packet which requests a dialogue with a server-sided npc.
//! Opcode: TALK_TO_NPC(58)
class TalkToNPCPacket : public OutPacket
{
public:
    TalkToNPCPacket(std::int32_t oid) : OutPacket(TALK_TO_NPC)
    {
        write_int(oid);
    }
};

//! Packet which sends a response to an npc dialogue to the server.
//! Opcode: NPC_TALK_MORE(60)
class NpcTalkMorePacket : public OutPacket
{
public:
    NpcTalkMorePacket(std::int8_t last_msg, std::int8_t response)
        : OutPacket(NPC_TALK_MORE)
    {
        write_byte(last_msg);
        write_byte(response);
    }

    NpcTalkMorePacket(std::string_view response) : NpcTalkMorePacket(2, 1)
    {
        write_string(response);
    }

    NpcTalkMorePacket(std::int32_t selection) : NpcTalkMorePacket(4, 1)
    {
        write_int(selection);
    }
};

//! Packet which tells the server of an interaction with an npc shop.
//! Opcode: NPC_SHOP_ACTION(61)
class NpcShopActionPacket : public OutPacket
{
public:
    //! Requests that an item should be bought from or sold to a npc shop.
    NpcShopActionPacket(std::int16_t slot,
                        std::int32_t itemid,
                        std::int16_t qty,
                        bool buy)
        : NpcShopActionPacket(buy ? BUY : SELL)
    {
        write_short(slot);
        write_int(itemid);
        write_short(qty);
    }

    //! Requests that an item should be recharged at a npc shop.
    NpcShopActionPacket(std::int16_t slot) : NpcShopActionPacket(RECHARGE)
    {
        write_short(slot);
    }

    //! Requests exiting from a npc shop.
    NpcShopActionPacket() : NpcShopActionPacket(LEAVE)
    {
    }

protected:
    enum Mode : std::int8_t { BUY, SELL, RECHARGE, LEAVE };

    NpcShopActionPacket(Mode mode) : OutPacket(NPC_SHOP_ACTION)
    {
        write_byte(mode);
    }
};
} // namespace jrc

```

`Net/Packets/PlayerPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../../Character/MapleStat.h"
#include "../OutPacket.h"

namespace jrc
{
//! Requests a stat increase by spending ap.
//! Opcode: SPEND_AP(87)
class SpendApPacket : public OutPacket
{
public:
    SpendApPacket(Maplestat::Id stat) : OutPacket(SPEND_AP)
    {
        write_time();
        write_int(Maplestat::codes[stat]);
    }
};

//! Requests a skill level increase by spending sp.
//! Opcode: SPEND_SP(90)
class SpendSpPacket : public OutPacket
{
public:
    SpendSpPacket(std::int32_t skill_id) : OutPacket(SPEND_SP)
    {
        write_time();
        write_int(skill_id);
    }
};
} // namespace jrc

```

`Net/Packets/SelectCharPackets.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../OutPacket.h"

#include <string_view>

namespace jrc
{
constexpr std::string_view MACS = "68-5D-43-F8-B8-6C, 7A-79-19-8B-31-3F";
constexpr std::string_view HWID = "685D43F8_B86C7A79";

//! Tell the server which character was picked.
//! Opcode: SELECT_CHAR(19)
class SelectCharPacket : public OutPacket
{
public:
    SelectCharPacket(std::int32_t cid) : OutPacket(SELECT_CHAR)
    {
        write_int(cid);
        write_string(MACS);
        write_string(HWID);
    }
};

//! Registers a pic and tells the server which character was picked.
//! Opcode: REGISTER_PIC(29)
class RegisterPicPacket : public OutPacket
{
public:
    RegisterPicPacket(std::int32_t cid, std::string_view pic)
        : OutPacket(REGISTER_PIC)
    {
        skip(1);

        write_int(cid);
        write_string(MACS);
        write_string(HWID);
        write_string(pic);
    }
};

//! Requests using the specified character with the specified pic.
//! Opcode: SELECT_CHAR_PIC(30)
class SelectCharPicPacket : public OutPacket
{
public:
    SelectCharPicPacket(std::string_view pic, std::int32_t cid)
        : OutPacket(SELECT_CHAR_PIC)
    {
        write_string(pic);
        write_int(cid);
        write_string(MACS);
        write_string(HWID);
    }
};

//! Requests deleting the specified character with the specified pic.
//! Opcode: DELETE_PIC(23)
class DeleteCharPacket : public OutPacket
{
public:
    DeleteCharPacket(std::string_view pic, std::int32_t cid)
        : OutPacket(DELETE_CHAR)
    {
        write_string(pic);
        write_int(cid);
    }
};
} // namespace jrc

```

`Net/Session.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Session.h"

#include "../Configuration.h"

namespace jrc
{
Session::Session() noexcept : length(0), pos(0), connected(false)
{
}

Session::~Session() noexcept
{
    if (connected) {
        socket.close();
    }
}

bool Session::init(const char* host, const char* port)
{
    // Connect to the server.
    connected = socket.open(host, port);

    if (connected) {
        // Read keys neccessary for communicating with the server.
        cryptography = {socket.get_buffer()};
    }

    return connected;
}

Error Session::init()
{
    const std::string& host = Configuration::get().network.ip;
    if (host.empty()) {
        Console::get().print("No host IP was found in the settings file.");
        return Error::CONNECTION;
    }

    static std::string port
        = std::to_string(Configuration::get().network.port);

    if (!init(host.data(), port.data())) {
        return Error::CONNECTION;
    }

    return Error::NONE;
}

void Session::reconnect(const char* address, const char* port)
{
    // Close the current connection and open a new one.
    bool success = socket.close();

    if (success) {
        init(address, port);
    } else {
        connected = false;
    }
}

void Session::process(const std::int8_t* bytes, std::size_t available)
{
    if (pos == 0) {
        // Pos is 0, meaning this is the start of a new packet.
        // Start by determining length.
        length = cryptography.check_length(bytes);
        // Reading the length means we processed the header.
        // Move forward by the header length.
        bytes = bytes + HEADER_LENGTH;
        available -= HEADER_LENGTH;
    }

    // Determine how much we can write. Write data into the buffer.
    std::size_t towrite = length - pos;

    if (towrite > available) {
        towrite = available;
    }

    memcpy(buffer + pos, bytes, towrite);
    pos += towrite;

    // Check if the current packet has been fully processed.
    if (pos >= length) {
        cryptography.decrypt(buffer, length);

        try {
            packet_switch.forward(buffer, length);
        } catch (const PacketError& err) {
            Console::get().print(err.what());
        }

        pos = 0;
        length = 0;

        // Check if there is more available.
        const std::size_t remaining = available - towrite;

        if (remaining >= MIN_PACKET_LENGTH) {
            // More packets are available, so we start over.
            process(bytes + towrite, remaining);
        }
    }
}

bool Session::write(std::int8_t* packet_bytes,
                    std::size_t packet_length) noexcept
{
    if (!connected) {
        return false;
    }

    std::int8_t header[HEADER_LENGTH];
    cryptography.create_header(header, packet_length);
    cryptography.encrypt(packet_bytes, packet_length);

    if (!socket.dispatch(header, HEADER_LENGTH)) {
        return false;
    }
    return socket.dispatch(packet_bytes, packet_length);
}

void Session::read()
{
    // Check if a packet has arrived. Handle if data is sufficient:
    //     4 bytes(header) + 2 bytes(opcode) = 6.
    std::size_t result = socket.receive(&connected);

    if (result >= MIN_PACKET_LENGTH || length > 0) {
        // Retrieve buffer from the socket and process it.
        const std::int8_t* bytes = socket.get_buffer();
        process(bytes, result);
    }
}

bool Session::is_connected() const noexcept
{
    return connected;
}
} // namespace jrc

```

`Net/Session.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Error.h"
#include "../Journey.h"
#include "../Template/Singleton.h"
#include "Cryptography.h"
#include "PacketSwitch.h"
#ifdef JOURNEY_USE_ASIO
#    include "SocketAsio.h"
#else
#    include "SocketWinsock.h"
#endif

namespace jrc
{
class Session : public Singleton<Session>
{
public:
    Session() noexcept;
    ~Session() noexcept override;

    //! Connect using host and port from the configuration file.
    Error init();
    //! Send a packet to the server.
    bool write(std::int8_t* bytes, std::size_t length) noexcept;
    //! Check for incoming packets and handle them.
    void read();
    //! Closes the current connection and opens a new one.
    void reconnect(const char* address, const char* port);
    //! Check if the connection is alive.
    bool is_connected() const noexcept;

private:
    bool init(const char* host, const char* port);
    void process(const std::int8_t* bytes, std::size_t available);

    Cryptography cryptography;
    PacketSwitch packet_switch;

    std::int8_t buffer[MAX_PACKET_LENGTH];
    std::size_t length;
    std::size_t pos;
    bool connected;

#ifdef JOURNEY_USE_ASIO
    SocketAsio socket;
#else
    SocketWinsock socket;
#endif
};
} // namespace jrc

```

`Net/SocketAsio.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SocketAsio.h"
#ifdef JOURNEY_USE_ASIO

namespace jrc
{
SocketAsio::SocketAsio() : resolver(ioservice), socket(ioservice)
{
}

SocketAsio::~SocketAsio()
{
    if (socket.is_open()) {
        error_code error;
        socket.close(error);
    }
}

bool SocketAsio::open(const char* address, const char* port)
{
    tcp::resolver::query query(address, port);
    tcp::resolver::iterator endpoint_iter = resolver.resolve(query);
    error_code error;
    asio::connect(socket, endpoint_iter, error);
    if (!error) {
        std::size_t result = socket.read_some(asio::buffer(buffer), error);
        return !error && result == HANDSHAKE_LEN;
    }
    return !error;
}

bool SocketAsio::close() noexcept
{
    error_code error;
    socket.shutdown(tcp::socket::shutdown_both, error);
    socket.close(error);
    return !error;
}

std::size_t SocketAsio::receive(bool* recvok)
{
    if (socket.available() > 0) {
        error_code error;
        std::size_t result = socket.read_some(asio::buffer(buffer), error);
        *recvok = !error;
        return result;
    }
    return 0;
}

const std::int8_t* SocketAsio::get_buffer() const
{
    return buffer;
}

bool SocketAsio::dispatch(const std::int8_t* bytes,
                          std::size_t length) noexcept
{
    error_code error;
    std::size_t result
        = asio::write(socket, asio::buffer(bytes, length), error);
    return !error && (result == length);
}
} // namespace jrc
#endif

```

`Net/SocketAsio.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Journey.h"
#ifdef JOURNEY_USE_ASIO
#    include "NetConstants.h"

#    define BOOST_DATE_TIME_NO_LIB
#    define BOOST_REGEX_NO_LIB
#    include "asio.hpp"

#    include <cstdint>

namespace jrc
{
#    ifndef JOURNEY_USE_CRYPTO
constexpr const std::size_t HANDSHAKE_LEN = 2;
#    else
constexpr const std::size_t HANDSHAKE_LEN = 16;
#    endif

using asio::error_code;
using asio::io_service;
using asio::ip::tcp;

//! Class that wraps an ASIO socket.
class SocketAsio
{
public:
    SocketAsio();
    ~SocketAsio();

    bool open(const char* address, const char* port);
    bool close() noexcept;
    std::size_t receive(bool* connected);
    const std::int8_t* get_buffer() const;
    bool dispatch(const std::int8_t* bytes, std::size_t length) noexcept;

private:
    io_service ioservice;
    tcp::resolver resolver;
    tcp::socket socket;
    std::int8_t buffer[MAX_PACKET_LENGTH];
};
} // namespace jrc
#endif

```

`Net/SocketWinsock.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "SocketWinsock.h"
#ifndef JOURNEY_USE_ASIO
#    include <WinSock2.h>
#    include <ws2tcpip.h>

#    pragma comment(lib, "Ws2_32.lib")
#    pragma comment(lib, "Mswsock.lib")
#    pragma comment(lib, "AdvApi32.lib")

namespace jrc
{
bool SocketWinsock::open(const char* iaddr, const char* port)
{
    WSADATA wsa_info;
    sock = INVALID_SOCKET;

    struct addrinfo* addr_info = NULL;
    struct addrinfo* ptr = NULL;
    struct addrinfo hints;

    int result = WSAStartup(MAKEWORD(2, 2), &wsa_info);
    if (result != 0) {
        return false;
    }

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    result = getaddrinfo(iaddr, port, &hints, &addr_info);
    if (result != 0) {
        WSACleanup();
        return false;
    }

    for (ptr = addr_info; ptr != NULL; ptr = ptr->ai_next) {
        sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (sock == INVALID_SOCKET) {
            WSACleanup();
            return false;
        }
        result = connect(sock, ptr->ai_addr, (int)ptr->ai_addrlen);
        if (result == SOCKET_ERROR) {
            closesocket(sock);
            sock = INVALID_SOCKET;
            continue;
        }
        break;
    }

    freeaddrinfo(addr_info);

    if (sock == INVALID_SOCKET) {
        WSACleanup();
        return false;
    }

    result = recv(sock, (char*)buffer, 32, 0);
    if (result == HANDSHAKE_LEN) {
        return true;
    } else {
        WSACleanup();
        return false;
    }
}

bool SocketWinsock::close()
{
    int error = closesocket(sock);
    WSACleanup();
    return error != SOCKET_ERROR;
}

bool SocketWinsock::dispatch(const std::int8_t* bytes,
                             std::size_t length) const
{
    return send(sock, (char*)bytes, static_cast<int>(length), 0)
           != SOCKET_ERROR;
}

std::size_t SocketWinsock::receive(bool* success)
{
    timeval timeout = {0, 0};
    fd_set sockset = {0};
    FD_SET(sock, &sockset);
    int result = select(0, &sockset, 0, 0, &timeout);
    if (result > 0) {
        result = recv(sock, (char*)buffer, MAX_PACKET_LENGTH, 0);
    }
    if (result == SOCKET_ERROR) {
        *success = false;
        return 0;
    } else {
        return result;
    }
}

const std::int8_t* SocketWinsock::get_buffer() const
{
    return buffer;
}
} // namespace jrc
#endif

```

`Net/SocketWinsock.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Journey.h"
#ifndef JOURNEY_USE_ASIO
#    include "NetConstants.h"

#    include <cstdint>
#    include <cstdlib>

namespace jrc
{
#    ifdef JOURNEY_USE_CRYPTO
const std::size_t HANDSHAKE_LEN = 16;
#    else
const std::size_t HANDSHAKE_LEN = 2;
#    endif

class SocketWinsock
{
public:
    bool open(const char* adress, const char* port);
    bool close();

    bool dispatch(const std::int8_t* bytes, std::size_t length) const;
    std::size_t receive(bool* connected);
    const std::int8_t* get_buffer() const;

private:
    std::uint64_t sock;
    std::int8_t buffer[MAX_PACKET_LENGTH];
};
} // namespace jrc
#endif

```

`README.md`:

```md
# [LibreMaple](https://libremaple.org/) Client: a fork/continuation of JourneyClient

[![License](https://img.shields.io/badge/license-AGPL%20v3.0%2B-brightgreen.svg)](https://www.gnu.org/licenses/agpl-3.0.html)
[![C++ standard](https://img.shields.io/badge/C%2B%2B-17-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B17)
[![clang++ version](https://img.shields.io/badge/clang%2B%2B-6.0.1+-dd66aa.svg)](http://clang.llvm.org/)
[![Maplestory version](https://img.shields.io/badge/Maplestory-GMS_v83-orange.svg)](https://en.wikipedia.org/wiki/MapleStory)

## JourneyClient

JourneyClient is a custom, made-from-scratch game client for
[Maplestory](https://en.wikipedia.org/wiki/MapleStory).
JourneyClient is written in [C++](https://en.wikipedia.org/wiki/C%2B%2B) and
was created by Daniel Allendorf in 2015.

The [LibreMaple](https://libremaple.org/) project aims to make a version of
Maplestory that is
[100% free and open](https://www.fsf.org/about/what-is-free-software) on both
the server and client sides, to preserve the freedom of its users and enable
creativity and collaboration around the game. As such, the LibreMaple project
takes the JourneyClient as a starting point.

LibreMaple aims to make the client
[cross-platform](https://en.wikipedia.org/wiki/Cross-platform)
([GNU+Linux](https://en.wikipedia.org/wiki/Linux)/[macOS](https://en.wikipedia.org/wiki/MacOS)/[Windows NT](https://en.wikipedia.org/wiki/Windows_NT)/[FreeBSD](https://en.wikipedia.org/wiki/FreeBSD)/etc.)
as well, so decisions are made with a cross-platform mindset as well as a free
software one.

## Supported versions

The client is currently compatible with GMS version 83 servers. For the UI file
(UI.nx), one from GMS version 154+ should be used.

## How to compile/install

### [Unix-like systems](https://en.wikipedia.org/wiki/Unix-like) excluding macOS (GNU+Linux, FreeBSD, etc.) (may also work for Unix-like Windows subsystems like [Cygwin](https://en.wikipedia.org/wiki/Cygwin), [MinGW](https://en.wikipedia.org/wiki/MinGW), or [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux))

#### Dependencies

* [clang](http://clang.llvm.org/) (version 6+)
* [lld](https://lld.llvm.org/) (version 6+)
* [llvm](https://llvm.org/) (version 6+, including any "tools" or "runtime")
* [cmake](https://cmake.org/) (version 3.10+)
* [make](https://www.gnu.org/software/make/) (GNU Make version 4+)
* [git](https://git-scm.com/)
* [wget](https://www.gnu.org/software/wget/)
* [tar](https://www.gnu.org/software/tar/)
* unzip
* [autoconf](https://www.gnu.org/software/autoconf/autoconf.html)
* [libtool](https://www.gnu.org/software/libtool/)
* [sh or bash](https://en.wikipedia.org/wiki/Bourne_shell)
* [SDL2](https://www.libsdl.org/) / sdl2 / sdl2-dev / libsdl2 / libsdl2-dev
* [SDL2_mixer](https://www.libsdl.org/projects/SDL_mixer/) / sdl2_mixer /
  libsdl2-mixer / libsdl2-mixer-dev
* [glut](http://freeglut.sourceforge.net/) / freeglut / freeglut3,
  freeglut3-dev (an implementation of GLUT, including development files,
  version 3)
* libXmu / libxmu (including the "development" version, if that's separate)
* libXi / libxi (including the "development" version)
* libgl-dev / libgl1-mesa-dev / libgl / mesa / libGL-devel (implementation of
  OpenGL with development files)
* libosmesa-dev / libosmesa / osmesa (skip this if your package manager doesn't
  have it)
* xorg / xorg-dev / xorg-server-devel (Xorg development libraries)
* build-essential (for users of Debian-based distibutions only)
* [ninja](https://ninja-build.org/) (technically optional, you can simply *not*
  pass `-GNinja` to cmake to use Make instead)
* [ccache](https://ccache.samba.org/) (optional, for faster build times)

(**Note for [Solus](https://solus-project.com/) users:**
`sudo eopkg it -c system.devel`)

Most of these dependencies should be available from your package manager
(`pacman`, `apt`, `dnf`, `zypper`, `pkg`, `xbps-install`, `eopkg`, `yum`,
etc.), but for all dependencies listed with a version number, **make sure
to check that the version your package manager gives you is high enough**.
If your package manager doesn't have something or doesn't have a high enough
version, you may have to install it using instructions from the relevant
website and/or use auxilliary package management (`yaourt`, PPAs, `copr`,
etc.).

#### Instructions

```bash
$ git clone https://github.com/Libre-Maple/LibreMaple-Client.git
$ git clone https://github.com/NoLifeDev/NoLifeNx.git nlnx

# The next command is probably best replaced by navigating to
# https://sourceforge.net/projects/asio/files/latest/download
# and downloading from there to get the latest stable version of ASIO.
$ wget https://downloads.sourceforge.net/project/asio/asio/1.12.1%20%28Stable%29/asio-1.12.1.tar.bz2
$ mkdir asio
$ tar xf asio-* --strip-components=1 -C asio/
$ rm asio-*

$ git clone https://github.com/glfw/glfw.git

# Again, the following command can be replaced by just going to
# https://sourceforge.net/projects/glew/files/glew
# and downloading the latest version of GLEW.
$ wget https://downloads.sourceforge.net/project/glew/glew/2.1.0/glew-2.1.0.tgz
$ mkdir glew
$ tar xf glew-* --strip-components=1 -C glew/
$ rm glew-*

$ git clone git://git.sv.nongnu.org/freetype/freetype2.git freetype

$ git clone https://github.com/lz4/lz4.git

# Again, the following command can be replaced by just going to
# https://www.boost.org/users/download/
# and downloading the latest version of Boost.
$ wget https://dl.bintray.com/boostorg/release/1.67.0/source/boost_1_67_0.tar.gz
$ tar xf boost*
$ rm boost*.tar.gz
$ mv boost*/ boost/

$ git clone https://github.com/skystrife/cpptoml.git

$ git clone https://github.com/imneme/pcg-cpp.git

$ export CC='/usr/bin/clang'
$ export CXX='/usr/bin/clang++'

$ cd freetype
$ sh autogen.sh
$ ./configure
$ make
$ cd ..

$ cd glew
$ make
$ cd ..

$ cd glfw
$ mkdir build
$ cd build
$ cmake ..
$ make
$ cd ../..

$ cd lz4
$ make
$ cd ..

$ cd LibreMaple-Client
$ mkdir build
$ cd build
# Build type may also be `Release`, `RelWithDebInfo`, or `MinSizeRel`.
# Additionally, pass in the argument `-DNATIVE_BUILD=1` if you desire a native-
# only build (`-march=native`).
#
# Specify `-DCMAKE_CXX_COMPILER_LAUNCHER=ccache` if you are using ccache.
$ cmake -DCMAKE_BUILD_TYPE=Debug -GNinja ..
# Or `ninja -jN` with N being the number of CPU cores you wish to utilize.
$ ninja
# For `Release` and `MinSizeRel` builds only:
$ strip JourneyClient
```

If all this is successful, you should have the executable in your current
directory (`LibreMaple-Client/build`).

### macOS

#### Dependencies

* macOS Command Line Tools (can be installed using `xcode-select --install`,
  includes clang, git, make, and some things needed for basic clang
  functionality)
* [Homebrew](https://brew.sh/)
* [llvm](https://llvm.org/) (`brew install llvm`)
* [cmake](https://cmake.org/) (`brew install cmake`)
* [wget](https://www.gnu.org/software/wget/) (`brew install wget`)
* [autoconf](https://www.gnu.org/software/autoconf/autoconf.html)
  (`brew install autoconf`)
* [libtool](https://www.gnu.org/software/libtool/) (`brew install libtool`; the
  macOS CL tools come with a libtool, but this installs the GNU version with
  'g' prefix e.g. `glibtoolize`)
* [SDL2](https://www.libsdl.org/) (`brew install sdl2`)
* [SDL2_mixer](https://www.libsdl.org/projects/SDL_mixer/)
  (`brew install sdl2_mixer`)
* [freeglut](http://freeglut.sourceforge.net/) (`brew install freeglut`; may
  require you to separately install XQuartz, one way to do this is
  `brew cask install xquartz`)
* [freetype](https://www.freetype.org/) (`brew install freetype`)
* [ninja](https://ninja-build.org/) (`brew install ninja`; technically
  optional, you can simply *not* pass `-GNinja` to cmake to use Make instead)
* [ccache](https://ccache.samba.org/) (optional, for faster build times;
  `brew install ccache`)

#### Instructions

```bash
$ git clone https://github.com/Libre-Maple/LibreMaple-Client.git
$ git clone https://github.com/NoLifeDev/NoLifeNx.git nlnx

# The next command is probably best replaced by navigating to
# https://sourceforge.net/projects/asio/files/latest/download
# and downloading from there to get the latest stable version of ASIO.
$ wget https://downloads.sourceforge.net/project/asio/asio/1.12.1%20%28Stable%29/asio-1.12.1.tar.bz2
$ mkdir asio
$ tar xf asio-* --strip-components=1 -C asio/
$ rm asio-*

$ git clone https://github.com/glfw/glfw.git

# Again, the following command can be replaced by just going to
# https://sourceforge.net/projects/glew/files/glew
# and downloading the latest version of GLEW.
$ wget https://downloads.sourceforge.net/project/glew/glew/2.1.0/glew-2.1.0.tgz
$ mkdir glew
$ tar xf glew-* --strip-components=1 -C glew/
$ rm glew-*

$ git clone https://github.com/lz4/lz4.git

# Again, the following command can be replaced by just going to
# https://www.boost.org/users/download/
# and downloading the latest version of Boost.
$ wget https://dl.bintray.com/boostorg/release/1.67.0/source/boost_1_67_0.tar.gz
$ tar xf boost*
$ rm boost*.tar.gz
$ mv boost*/ boost/

$ git clone https://github.com/skystrife/cpptoml.git

$ git clone https://github.com/imneme/pcg-cpp.git

$ export CC='clang'
$ export CXX='clang++'

$ cd glew
$ make
$ cd ..

$ cd glfw
$ mkdir build
$ cd build
$ cmake ..
$ make
$ cd ../..

$ cd lz4
$ make
$ cd ..

$ cd LibreMaple-Client
$ mkdir build
$ cd build
# Build type may also be `Release`, `RelWithDebInfo`, or `MinSizeRel`.
# Additionally, pass in the argument `-DNATIVE_BUILD=1` if you desire a native-
# only build (`-march=native`).
#
# Specify `-DCMAKE_CXX_COMPILER_LAUNCHER=ccache` if you are using ccache.
$ cmake -DCMAKE_BUILD_TYPE=Debug -GNinja..
# Or `ninja -jN` with N being the number of CPU cores you wish to utilize.
$ ninja
# For `Release` and `MinSizeRel` builds only:
$ strip JourneyClient
```

If all this is successful, you should have the executable in your current
directory (`LibreMaple-Client/build`). However, it probably will not run right
away, since the paths that the executable looks for dylibs on will be wrong.

In order to fix this, gather up the following files, copying them to wherever
you find most appropriate if desired (you may want to put them all into the
same directory as the executable for ease of use). All paths shown here are
relative to the base directory where you cloned all of the repos and extracted
the tarballs:

* `libGLEW.dylib` (found as `glew/lib/libGLEW.dylib`, this should be a symlink
  to `libGLEW.2.1.0.dylib` or something like that, so be aware)
* `liblz4.dylib` (found as `lz4/lib/liblz4.dylib`, this should be a symlink to
  `liblz4.1.8.2.dylib` or something like that, so be aware)

Now that you have the locations of these dylibs, you can change the executable
to point to them. Like this, for example:

```bash
$ install_name_tool -change /usr/local/lib/libGLEW.2.1.0.dylib ./libGLEW.2.1.0.dylib JourneyClient
$ install_name_tool -change /usr/local/lib/liblz4.1.dylib ./liblz4.1.8.2.dylib JourneyClient
```

### Windows NT (Windows 7, 8, 10+) (64-bit only, i.e. amd64/x86_64)

#### Dependencies

* [Visual Studio 2017](https://www.visualstudio.com/downloads/) (the Community Edition works just fine, make sure to enable Visual C++ development when installing)
* [.NET Framework 4](https://www.microsoft.com/en-us/download/details.aspx?id=17718) (hopefully already installed, but just in case)
* [Visual C++ Redistributable for Visual Studio 2017](https://go.microsoft.com/fwlink/?LinkId=746572) (probably already installed, but again, just in case)
* [clang for windows](https://releases.llvm.org/download.html) (version 6+; download and install **Pre-Built Binaries:** -> Clang for Windows (64-bit))
* [cmake](https://cmake.org/download/) (latest version, 3.11.X as of this writing)
* [git](https://git-scm.com/)
* [7-Zip](https://www.7-zip.org/)

#### Instructions

```bat
$ git clone https://github.com/Libre-Maple/LibreMaple-Client.git
$ git clone https://github.com/NoLifeDev/NoLifeNx.git nlnx

$ git clone https://github.com/ubawurinna/freetype-windows-binaries.git freetype

$ git clone https://github.com/skystrife/cpptoml.git

$ git clone https://github.com/imneme/pcg-cpp.git
```

Navigate to
[https://sourceforge.net/projects/asio/files/latest/download](https://sourceforge.net/projects/asio/files/latest/download)
and download `asio-X.Y.Z.zip`, whatever the latest version is
(`asio-1.12.1.zip` as of this writing).

Use 7-Zip to extract the contents of the asio ZIP file to a directory called
`asio`.

Navigate to
[http://www.glfw.org/download.html](http://www.glfw.org/download.html) and
download the 64-bit Windows binaries (called `glfw-3.2.1.bin.WIN64.zip` as of
this writing).

Use 7-Zip to extract the contents of the glfw ZIP file into a directory called
`glfw`.

Navigate to [http://glew.sourceforge.net/](http://glew.sourceforge.net/) and
download the "Binaries: Windows 32-bit and 64-bit" ZIP file (called
`glew-2.1.0-win32.zip` as of this writing).

Use 7-Zip to extract the contents of the glew ZIP file into a directory called
`glew` (make sure that the contents are at the top level of `glew`, you want
`glew\bin`, not `glew\glew-2.1.0\bin`).

Navigate to
[https://github.com/lz4/lz4/releases](https://github.com/lz4/lz4/releases) and
download the latest version of LZ4 for "win64" (called `lz4_v1_8_2_win64.zip`
as of this writing).

Use 7-Zip to extract the contents of the LZ4 ZIP file into a directory called
`lz4`.

Navigate to
[https://www.boost.org/users/download/](https://www.boost.org/users/download/)
and download the latest version of Boost for Windows (called `boost_1_67_0.7z`
as of this writing).

Use 7-Zip to extract the contents of the Boost 7z file into a directory called
`boost`.

Notice here that we assume the installation directory of LLVM is the default
one. If you don't use the default installation directory, you will have to
tweak `CMakeLists.txt` yourself:

```bat
$ SET CC="C:\Program Files\LLVM\bin\clang.exe"
$ SET CXX="C:\Program Files\LLVM\bin\clang++.exe"

$ cd LibreMaple-Client
$ md build
$ cd build
```

Use the following two commands if `CMAKE_BUILD_TYPE` is to be `Debug` (you may
wish to add an additional `/mN` flag, with `N` being the number of CPU cores
you wish to utilize for compilation):

```bat
$ cmake -G "Visual Studio 15 2017 Win64" -T "LLVM-vs2017" -D CMAKE_C_COMPILER="C:/Program Files/LLVM/bin/clang.exe" -D CMAKE_CXX_COMPILER="C:/Program Files/LLVM/bin/clang++.exe" -D CMAKE_BUILD_TYPE=Debug ..
$ cmake --build . -- /v:d /property:Configuration=Debug /property:Platform=x64
```

`CMAKE_BUILD_TYPE` here may also be `Release`, `RelWithDebInfo`, or
`MinSizeRel`. If you want to use one of these build types, use these commands
instead, setting `CMAKE_BUILD_TYPE` to the desired value (we use `Release`
here as an example):

```bat
$ cmake -G "Visual Studio 15 2017 Win64" -T "LLVM-vs2017" -D CMAKE_C_COMPILER="C:/Program Files/LLVM/bin/clang.exe" -D CMAKE_CXX_COMPILER="C:/Program Files/LLVM/bin/clang++.exe" -D CMAKE_BUILD_TYPE=Release ..
$ cmake --build . -- /v:d /property:Configuration=Release /property:Platform=x64
```

If all this is successful, you should have the executable (`JourneyClient.exe`)
in `LibreMaple-Client\build\Debug` for debug builds, or
`LibreMaple-Client\build\Release` for release build types. However, it
probably will not run right away, since the paths that the executable looks
for DLLs on will be wrong.

In order to fix this, gather up the following files, copying them to be right
next to the executable. All paths shown here are relative to the base directory
where you cloned all of the repos and extracted the ZIP files:

* `freetype.dll` (found as `freetype\win64\freetype.dll`)
* `glew32.dll` (found as `glew\bin\Release\x64\glew32.dll`)
* `liblz4.dll` (found as `lz4\dll\liblz4.so.1.8.2.dll`, the version number may
  be different and you will have to rename your copied version to `liblz4.dll`)

## Compiler

LibreMaple is built against the latest version of
[Clang](http://clang.llvm.org/) (6.0.X as of this writing), again for
cross-platform considerations and efficiency. [The GCC](https://gcc.gnu.org/)
(version 8.1.X as of this writing) is another excellent choice, especially for
those on GNU+Linux operating systems (or other OSs which default to GCC), but
GCC is **not** officially supported by LibreMaple.

That being said, don't be shy to file issues involving GCC or to make PRs to
improve ease of use/compatibility with it.

## C++ details

JourneyClient was originally developed under
[the C++14 standard](https://en.wikipedia.org/wiki/C%2B%2B14). However,
**LibreMaple strictly uses**
**[the C++17 standard](https://en.wikipedia.org/wiki/C%2B%2B17) and makes use**
**of C++17 features**.

In addition, this project (sort of) follows
[the ISO C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines).
[A complete copy of the guidelines is available here](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md).

More specific guidelines can be found in "code-guidelines.md".

## Configuration

The build can be configured by editing the Journey.h file.
The following options are available:

* `JOURNEY_USE_CRYPTO` : Use cryptography when communicating for the server.
* `JOURNEY_USE_XXHASH` : Use xxhash for file check (additional dependency)
* `JOURNEY_USE_ASIO`   : Use Asio for networking (additional dependency)

LibreMaple uses crypto (`JOURNEY_USE_CRYPTO`), and also uses ASIO
(`JOURNEY_USE_ASIO`) to maintain cross-platform compatibility.

## Dependencies

| **Category**      | **Dependency**                                             | **License**         | **Depends on** | **Header only?** | **Optional?** |
|-------------------|------------------------------------------------------------|---------------------|----------------|------------------|---------------|
| (De)compression   | [LZ4](https://github.com/lz4/lz4)                          | BSD 2-Clause        | -              | No               | No            |
| Error checking    | [xxHash](https://github.com/Cyan4973/xxHash)               | BSD 2-Clause        | -              | No               | Yes           |
| NX library        | [NoLifeNX](https://github.com/NoLifeDev/NoLifeNx)          | AGPL v3+            | LZ4            | No               | No            |
| Graphics          | [GLFW3](http://www.glfw.org/download.html)                 | zlib/libpng         | OpenGL support | No               | No            |
| Graphics          | [GLEW](http://glew.sourceforge.net/)                       | Modified BSD/MIT    | OpenGL support | No               | No            |
| Graphics          | [FreeType](http://www.freetype.org/)                       | FreeType            | -              | No               | No            |
| Audio             | [SDL2_mixer](https://www.libsdl.org/projects/SDL_mixer/)   | zlib/libpng         | SDL2           | No               | No            |
| Networking        | [Asio](http://think-async.com/) (standalone; no Boost)     | Boost               | -              | Yes              | No            |
| PRNG              | [PCG](http://www.pcg-random.org/) (C++ implementation)     | Apache 2.0/MIT      | -              | Yes              | No            |
| Config            | [cpptoml](https://github.com/skystrife/cpptoml)            | MIT                 | -              | Yes              | No            |
| General           | [Boost](https://www.boost.org/) (Bimap, Container)         | Boost               | -              | Yes              | No            |

## Licensing

[![GNU AGPL v3+](https://www.gnu.org/graphics/agplv3-155x51.png)](https://www.gnu.org/licenses/agpl-3.0.en.html)

All LibreMaple/JourneyClient code is © 2015-2016 Daniel Allendorf, 2018-2019
LibreMaple Team, licensed under the
[GNU Affero General Public License version 3 or higher](https://www.gnu.org/licenses/agpl-3.0.en.html)
(GNU AGPL). See "LICENSE" for the full text.

That implies a few things. For one, that makes this work a work of **free**
**software**, including both the source code *and any binaries created from*
*it*. According to the Free Software Foundation:

> A program is free software if the program's users have the four essential
> freedoms:
>
> * The freedom to run the program as you wish, for any purpose (freedom 0).
> * The freedom to study how the program works, and change it so it does your
>   computing as you wish (freedom 1). Access to the source code is a
>   precondition for this.
> * The freedom to redistribute copies so you can help others (freedom 2).
> * The freedom to distribute copies of your modified versions to others
>   (freedom 3). By doing this you can give the whole community a chance to
>   benefit from your changes. Access to the source code is a precondition for
>   this.

As the above text implies, *derived/modified works are encouraged*, and due to
the nature of the GNU AGPL, all such works are free software as well (also
licensed under the GNU AGPL).

```

`Template/BoolPair.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <utility>

namespace jrc
{
template<typename T>
class BoolPair
{
public:
    template<typename... Args>
    BoolPair(Args&&... args_f, Args&&... args_s) noexcept(
        noexcept(T(std::forward<Args>(args_f)...)))
        : first(std::forward<Args>(args_f)...),
          second(std::forward<Args>(args_s)...)
    {
    }

    BoolPair(T f, T s) noexcept(noexcept(T(f))) : first(f), second(s)
    {
    }

    BoolPair() = default;

    template<typename... Args>
    void set(bool b,
             Args&&... args) noexcept(noexcept(T(std::forward<Args>(args)...)))
    {
        if (b) {
            first = T(std::forward<Args>(args)...);
        } else {
            second = T(std::forward<Args>(args)...);
        }
    }

    T& operator[](bool b) noexcept
    {
        return b ? first : second;
    }

    const T& operator[](bool b) const noexcept
    {
        return b ? first : second;
    }

private:
    T first;
    T second;
};
} // namespace jrc

```

`Template/Cache.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <cstdint>
#include <unordered_map>

namespace jrc
{
template<typename T>
//! Template for a cache of game objects which can be constructed from an
//! identifier.
//!
//! The `get()` factory method is `static`.
class Cache
{
public:
    virtual ~Cache() = default;

    //! Return a reference to the game object with the specified ID.
    //!
    //! If the object is not in cache, it is created.
    static const T& get(std::int32_t id)
    {
        auto iter = cache.find(id);
        if (iter == cache.end()) {
            iter = cache.emplace(id, T{id}).first;
        }
        return iter->second;
    }

private:
    static std::unordered_map<std::int32_t, T> cache;
};

template<typename T>
std::unordered_map<std::int32_t, T> Cache<T>::cache;
} // namespace jrc

```

`Template/EnumMap.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <array>
#include <type_traits>
#include <utility>

namespace jrc
{
template<typename K,
         typename V,
         K LENGTH = K::LENGTH,
         typename = std::enable_if_t<std::is_enum_v<K>>>
//! Wraps an array so that it is addressable by `enum [class]` values.
class EnumMap
{
public:
    using array_size_t = typename std::array<V, LENGTH>::size_type;

    //! Default constructor.
    EnumMap() = default;
    template<typename... Args,
             typename = std::enable_if_t<
                 std::conjunction_v<std::is_same<Args, std::pair<K, V>>...>>>
    //! Initialize with a varargs initialization list.
    constexpr EnumMap(Args&&... args) noexcept : m_values{}
    {
        ((m_values[static_cast<array_size_t>(args.first)]
          = std::forward<V>(args.second)),
         ...);
    }
    template<typename... Args>
    //! Initialize with a varargs initialization list, taking one value for
    //! every possible enumeration key.
    constexpr EnumMap(Args&&... args) noexcept
        : m_values{{std::forward<Args>(args)...}}
    {
    }
    //! Initialize with a `std::initializer_list`.
    constexpr EnumMap(std::initializer_list<std::pair<K, V>> init) noexcept
        : m_values{}
    {
        for (auto [k, v] : init) {
            m_values[static_cast<array_size_t>(k)] = v;
        }
    }

    constexpr void clear() noexcept
    {
        for (std::size_t i = 0; i < LENGTH; ++i) {
            m_values[i] = V();
        }
    }

    constexpr void erase(K key) noexcept
    {
        if (key >= 0 && key < LENGTH) {
            m_values[static_cast<array_size_t>(key)] = V();
        }
    }

    template<typename... Args>
    constexpr void emplace(K key, Args&&... args) noexcept
    {
        m_values[static_cast<array_size_t>(key)]
            = {std::forward<Args>(args)...};
    }

    constexpr V& operator[](K key) noexcept
    {
        return m_values[static_cast<array_size_t>(key)];
    }

    constexpr const V& operator[](K key) const noexcept
    {
        return m_values[static_cast<array_size_t>(key)];
    }

    template<typename T>
    class base_iterator : public std::iterator<std::forward_iterator_tag, V>
    {
    public:
        using index_type = typename std::underlying_type<K>::type;

        constexpr base_iterator(T* p, index_type i) noexcept
            : value(p), index(i)
        {
        }

        struct node {
            K first;
            T& second;

            constexpr node(K f, T& s) noexcept : first(f), second(s)
            {
            }

            constexpr node& operator=(const node&) = delete;

            constexpr void set(const T& t) noexcept
            {
                second = t;
            }
        };

        constexpr node operator*() noexcept
        {
            return node{first(), second()};
        }

        constexpr explicit operator bool() const noexcept
        {
            return index >= 0 && index < LENGTH;
        }

        constexpr K first() const noexcept
        {
            return static_cast<K>(index);
        }

        constexpr T& second() noexcept
        {
            return *(value + index);
        }

        constexpr base_iterator& operator++() noexcept
        {
            ++index;
            return *this;
        }

        constexpr bool operator!=(const base_iterator& other) const noexcept
        {
            return index != other.index;
        }

        constexpr bool operator==(const base_iterator& other) const noexcept
        {
            return index == other.index;
        }

    private:
        T* value;
        index_type index;
    };

    using iterator = base_iterator<V>;
    using const_iterator = base_iterator<const V>;
    using node = typename iterator::node;
    using cnode = typename const_iterator::node;

    constexpr iterator find(K key) noexcept
    {
        return {m_values.data(), key};
    }

    constexpr const_iterator find(K key) const noexcept
    {
        return {m_values.data(), key};
    }

    constexpr iterator begin() noexcept
    {
        return {m_values.data(), 0};
    }

    constexpr iterator end() noexcept
    {
        return {m_values.data(), LENGTH};
    }

    constexpr const_iterator begin() const noexcept
    {
        return {m_values.data(), 0};
    }

    constexpr const_iterator end() const noexcept
    {
        return {m_values.data(), LENGTH};
    }

    constexpr std::array<V, LENGTH>& values() noexcept
    {
        return m_values;
    }

    constexpr const std::array<V, LENGTH>& values() const noexcept
    {
        return m_values;
    }

private:
    std::array<V, LENGTH> m_values;
};
} // namespace jrc

```

`Template/Enumeration.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <array>
#include <type_traits>

namespace jrc
{
template<typename E, E LENGTH = E::LENGTH>
//! Makes contiguous `enum`s iterable.
class Enumeration
{
public:
    using underlying_t = typename std::array<E, LENGTH>;

    template<std::size_t... VS>
    constexpr Enumeration(std::index_sequence<VS...>) noexcept
        : values{{static_cast<E>(VS)...}}
    {
    }

    constexpr Enumeration() noexcept
        : Enumeration(std::make_index_sequence<LENGTH>{})
    {
        static_assert(std::is_enum<E>::value,
                      "Template parameter E for Enumeration must be an enum");
    }

    auto begin() const noexcept
    {
        return values.begin();
    }

    auto end() const noexcept
    {
        return values.end();
    }

    auto cbegin() const noexcept
    {
        return values.cbegin();
    }

    auto cend() const noexcept
    {
        return values.cend();
    }

private:
    underlying_t values;
};
} // namespace jrc

```

`Template/Interpolated.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Util/Lerp.h"

namespace jrc
{
template<typename T>
class Nominal
{
public:
    constexpr Nominal() : now(T()), before(T()), threshold(0.0f)
    {
    }

    T get() const
    {
        return now;
    }

    T get(float alpha) const
    {
        return alpha >= threshold ? now : before;
    }

    T last() const
    {
        return before;
    }

    void set(T value)
    {
        now = value;
        before = value;
    }

    void normalize()
    {
        before = now;
    }

    bool normalized() const
    {
        return before == now;
    }

    void next(T value, float thrs)
    {
        before = now;
        now = value;
        threshold = thrs;
    }

    bool operator==(T value) const
    {
        return now == value;
    }

    bool operator!=(T value) const
    {
        return now != value;
    }

    T operator+(T value) const
    {
        return now + value;
    }

    T operator-(T value) const
    {
        return now - value;
    }

    T operator*(T value) const
    {
        return now * value;
    }

    T operator/(T value) const
    {
        return now / value;
    }

private:
    T now;
    T before;
    float threshold;
};

template<typename T>
class Linear
{
public:
    T get() const
    {
        return now;
    }

    T get(float alpha) const
    {
        return lerp<T>(before, now, alpha);
    }

    T last() const
    {
        return before;
    }

    void set(T value)
    {
        now = value;
        before = value;
    }

    void normalize()
    {
        before = now;
    }

    bool normalized() const
    {
        return before == now;
    }

    void operator=(T value)
    {
        before = now;
        now = value;
    }

    void operator+=(T value)
    {
        before = now;
        now += value;
    }

    void operator-=(T value)
    {
        before = now;
        now -= value;
    }

    bool operator==(T value) const
    {
        return now == value;
    }

    bool operator!=(T value) const
    {
        return now != value;
    }

    bool operator<(T value) const
    {
        return now < value;
    }

    bool operator<=(T value) const
    {
        return now <= value;
    }

    bool operator>(T value) const
    {
        return now > value;
    }

    bool operator>=(T value) const
    {
        return now >= value;
    }

    T operator+(T value) const
    {
        return now + value;
    }

    T operator-(T value) const
    {
        return now - value;
    }

    T operator*(T value) const
    {
        return now * value;
    }

    T operator/(T value) const
    {
        return now / value;
    }

    T operator+(Linear<T> value) const
    {
        return now + value.get();
    }

    T operator-(Linear<T> value) const
    {
        return now - value.get();
    }

    T operator*(Linear<T> value) const
    {
        return now * value.get();
    }

    T operator/(Linear<T> value) const
    {
        return now / value.get();
    }

private:
    T now;
    T before;
};
} // namespace jrc

```

`Template/Point.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Util/Misc.h"
#include "nlnx/node.hpp"

#include <cmath>
#include <limits>
#include <string>

namespace jrc
{
//! Represents a point in two-dimensional space, or possibly a displacement,
//! vector, etc.
template<class T>
class Point
{
public:
    //! Construct a point from a vector property.
    Point(const nl::node& src) noexcept
    {
        a = static_cast<T>(src.x());
        b = static_cast<T>(src.y());
    }

    //! Construct a point from the specified coordinates.
    constexpr Point(T first, T second) noexcept : a(first), b(second)
    {
    }

    //! Construct a point at the origin.
    constexpr Point() noexcept : Point(0, 0)
    {
    }

    //! Return the x-coordinate.
    constexpr T x() const noexcept
    {
        return a;
    }

    //! Return the y-coordinate.
    constexpr T y() const noexcept
    {
        return b;
    }

    //! For structured bindings.
    template<int I>
    constexpr T get() const noexcept
    {
        static_assert(
            I == 0 || I == 1,
            "Cannot `jrc::Point<_>::get<I>()` for `I != 0 && I != 1`");

        if constexpr (I == 0) {
            return a;
        } else {
            return b;
        }
    }

    //! Return the quadrance, i.e. the squared norm.
    //!
    //! Satisifies `static_cast<T>(std::sqrt(p.quadrance())) == p.norm()`.
    constexpr T quadrance() const noexcept
    {
        return a * a + b * b;
    }

    //! Return the Euclidian norm.
    constexpr T norm() const noexcept
    {
        return static_cast<T>(std::sqrt(quadrance()));
    }

    //! Check whether the x- and y-coordinates are equal.
    constexpr bool straight() const noexcept
    {
        return a == b;
    }

    //! Return a string representation of the point.
    std::string to_string() const noexcept
    {
        return str::concat(
            '[', std::to_string(a), ", ", std::to_string(b), ']');
    }

    //! Return the displacement from another point.
    constexpr T disp(Point<T> v) const noexcept
    {
        return Point<T>{a - v.a, b - v.b}.norm();
    }

    //! Set the x-coordinate.
    constexpr void set_x(T v) noexcept
    {
        a = v;
    }

    //! Set the y-coordinate.
    constexpr void set_y(T v) noexcept
    {
        b = v;
    }

    //! Shift the x-coordinate by the specified amount.
    constexpr void shift_x(T v) noexcept
    {
        a += v;
    }

    //! Shift the y-coordinate by the specified amount.
    constexpr void shift_y(T v) noexcept
    {
        b += v;
    }

    //! Shift the coordinates by the specified amounts.
    constexpr void shift(T x, T y) noexcept
    {
        a += x;
        b += y;
    }

    //! Shift the this point by the amounts defined by another point.
    //! Equivalent to `operator +=`.
    constexpr void shift(Point<T> v) noexcept
    {
        a += v.a;
        b += v.b;
    }

    //! Check whether this point is equivalent to the other specified point.
    constexpr bool operator==(const Point<T>& v) const noexcept
    {
        return a == v.a && b == v.b;
    }

    //! Check whether this point is not equivalent to the other specified
    //! point.
    constexpr bool operator!=(const Point<T>& v) const noexcept
    {
        return !(*this == v);
    }

    //! `false` if equal to the origin, `true` otherwise.
    constexpr explicit operator bool() const noexcept
    {
        return a != 0 || b != 0;
    }

    //! Shift this point by the amounts defined by another point.
    constexpr void operator+=(Point<T> v) noexcept
    {
        a += v.a;
        b += v.b;
    }

    //! Shift this point by the opposite of the amounts defined by another
    //! point.
    constexpr void operator-=(Point<T> v) noexcept
    {
        a -= v.a;
        b -= v.b;
    }

    //! Return a point whose coordinates are the negation of this point's
    //! coordinates.
    constexpr Point<T> operator-() const noexcept
    {
        return {-a, -b};
    }

    //! Return a point whose coordinates are this point's coordinates, after
    //! having added the specified amount to both.
    constexpr Point<T> operator+(T v) const noexcept
    {
        return {a + v, b + v};
    }

    //! Return a point whose coordinates are this point's coordinates, after
    //! having subtracted the specified amount from both.
    constexpr Point<T> operator-(T v) const noexcept
    {
        return {a - v, b - v};
    }

    //! Return a point whose coordinates are this point's coordinates, after
    //! having multiplied both by the specified amount.
    constexpr Point<T> operator*(T v) const noexcept
    {
        return {a * v, b * v};
    }

    //! Return a point whose coordinates are this point's coordinates, after
    //! having divided both by the specified amount.
    constexpr Point<T> operator/(T v) const noexcept
    {
        return {a / v, b / v};
    }

    //! Return a point whose coordinates are the sum of this and another
    //! point's coordinates.
    constexpr Point<T> operator+(Point<T> v) const noexcept
    {
        return {a + v.a, b + v.b};
    }

    //! Return a point whose coordinates are the difference of this and
    //! another point's coordinates.
    constexpr Point<T> operator-(Point<T> v) const noexcept
    {
        return {a - v.a, b - v.b};
    }

    //! Return the Euclidian inner product of this point and the specified
    //! other point.
    constexpr T operator*(Point<T> v) const noexcept
    {
        return a * v.a + b * v.b;
    }

    //! Return a point representing the Hadamard product of this point and the
    //! specified other point.
    constexpr Point<T> hadamard(Point<T> v) const noexcept
    {
        return {a * v.a, b * v.b};
    }

    //! Return the Euclidian inner product of this point and the specified
    //! other point's reciprocal (interpreting reciprocal as reciprocating each
    //! coordinate individually, and for non-floating-point types, division by
    //! a coordinate of `0` is treated as division by `1`).
    constexpr T operator/(Point<T> v) const noexcept
    {
        if constexpr (std::numeric_limits<T>::is_iec559) {
            return a / v.a + b / v.b;
        } else {
            return a / (v.a == 0 ? 1 : v.a) + b / (v.b == 0 ? 1 : v.b);
        }
    }

    //! Return a point representing the Hadamard division of this point by the
    //! specified other point. For non-floating-point types, division by a
    //! coordinate of `0` is treated as division by `1`.
    constexpr Point<T> hadamard_div(Point<T> v) const noexcept
    {
        if constexpr (std::numeric_limits<T>::is_iec559) {
            return {a / v.a, b / v.b};
        } else {
            return {a / (v.a == 0 ? 1 : v.a), b / (v.b == 0 ? 1 : v.b)};
        }
    }

private:
    T a;
    T b;
};

//! `constexpr` way of determining if something is a specialization of `Point`.
template<typename T>
struct is_point : std::false_type {
};
//! `constexpr` way of determining if something is a specialization of `Point`.
template<typename T>
struct is_point<Point<T>> : std::true_type {
};
} // namespace jrc

namespace std
{
template<typename T>
struct tuple_size<jrc::Point<T>> : std::integral_constant<std::size_t, 2> {
};

template<typename T>
struct tuple_element<0, jrc::Point<T>> {
    using type = T;
};

template<typename T>
struct tuple_element<1, jrc::Point<T>> {
    using type = T;
};
} // namespace std

```

`Template/Range.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <string>

namespace jrc
{
template<class T>
//! Representation of an inclusive numeric range, e.g. [3, 17].
class Range
{
public:
    //! Construct a range from the specified values.
    constexpr Range(const T& first, const T& second) : a(first), b(second)
    {
    }

    //! Construct a range of (0, 0).
    constexpr Range() : Range(0, 0)
    {
    }

    //! Return the first value.
    constexpr const T& first() const
    {
        return a;
    }

    //! Return the second value.
    constexpr const T& second() const
    {
        return b;
    }

    //! Return the greater value.
    constexpr const T& greater() const
    {
        return a > b ? a : b;
    }

    //! Return the smaller value.
    constexpr const T& smaller() const
    {
        return a < b ? a : b;
    }

    //! Return the difference between the values.
    constexpr T delta() const
    {
        return b - a;
    }

    //! Return the absolute difference between the values.
    constexpr T length() const
    {
        return greater() - smaller();
    }

    //! Return the mean of both values.
    constexpr T center() const
    {
        return (a + b) / 2;
    }

    //! Check if both values are equal.
    constexpr bool empty() const
    {
        return a == b;
    }

    //! Check if the range contains a value.
    constexpr bool contains(const T& v) const
    {
        return v >= a && v <= b;
    }

    //! Check if the range contains another range.
    constexpr bool contains(const Range<T>& v) const
    {
        return v.a >= a && v.b <= b;
    }

    //! Check if the ranges overlap.
    constexpr bool overlaps(const Range<T>& v) const
    {
        return contains(v.a) || contains(v.b) || v.contains(a)
               || v.contains(b);
    }

    //! Check wether the range is equivalent to another range.
    constexpr bool operator==(const Range<T>& v) const
    {
        return a == v.a && b == v.b;
    }

    //! Check wether the range is not equivalent to another range.
    constexpr bool operator!=(const Range<T>& v) const
    {
        return !(*this == v);
    }

    //! Shift this range by the amounts defined by another range.
    constexpr Range<T> operator+(const Range<T>& v) const
    {
        return {a + v.a, b + v.b};
    }

    //! Shift this range by the negative amounts defined by another range.
    constexpr Range<T> operator-(const Range<T>& v) const
    {
        return {a - v.a, b - v.b};
    }

    //! Return the negative of this range.
    constexpr Range<T> operator-() const
    {
        return {-a, -b};
    }

    //! Construct a symmetric range around `mid`.
    static constexpr Range<T> symmetric(const T& mid, const T& tail)
    {
        return {mid - tail, mid + tail};
    }

private:
    T a;
    T b;
};
} // namespace jrc

```

`Template/Rectangle.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Point.h"
#include "Range.h"

namespace jrc
{
template<class T>
class Rectangle
{
public:
    Rectangle(nl::node nlt, nl::node nrb) : lt(nlt), rb(nrb)
    {
    }

    Rectangle(nl::node src) : lt(src["lt"]), rb(src["rb"])
    {
    }

    constexpr Rectangle(Point<T> lt, Point<T> rb) : lt(lt), rb(rb)
    {
    }

    constexpr Rectangle(T l, T r, T t, T b) : lt(l, t), rb(r, b)
    {
    }

    constexpr Rectangle()
    {
    }

    constexpr T width() const
    {
        return std::abs(lt.x() - rb.x());
    }

    constexpr T height() const
    {
        return std::abs(lt.y() - rb.y());
    }

    constexpr T l() const
    {
        return lt.x();
    }

    constexpr T t() const
    {
        return lt.y();
    }

    constexpr T r() const
    {
        return rb.x();
    }

    constexpr T b() const
    {
        return rb.y();
    }

    constexpr bool contains(const Point<T>& v) const
    {
        return !straight() && v.x() >= lt.x() && v.x() <= rb.x()
               && v.y() >= lt.y() && v.y() <= rb.y();
    }

    constexpr bool overlaps(const Rectangle<T>& ar) const
    {
        return Range<T>(lt.x(), rb.x())
                   .overlaps(Range<T>(ar.lt.x(), ar.rb.x()))
               && Range<T>(lt.y(), rb.y())
                      .overlaps(Range<T>(ar.lt.y(), ar.rb.y()));
    }

    constexpr bool straight() const
    {
        return lt == rb;
    }

    constexpr bool empty() const
    {
        return lt.straight() && rb.straight() && straight();
    }

    constexpr const Point<T>& get_lt() const
    {
        return lt;
    }

    constexpr const Point<T>& get_rb() const
    {
        return rb;
    }

    constexpr Range<T> get_horizontal() const
    {
        return {lt.x(), rb.x()};
    }

    constexpr Range<T> get_vertical() const
    {
        return {lt.y(), rb.y()};
    }

    constexpr void shift(const Point<T>& v)
    {
        lt = lt + v;
        rb = rb + v;
    }

private:
    Point<T> lt;
    Point<T> rb;
};
} // namespace jrc

```

`Template/Singleton.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once

namespace jrc
{
template<class T>
class Singleton
{
public:
    virtual ~Singleton() = default;

    static T& get() noexcept
    {
        return instance;
    }

    T& operator=(const T&) = delete;

private:
    static T instance;
};

template<class T>
T Singleton<T>::instance;
} // namespace jrc

```

`Template/TimedQueue.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Constants.h"

#include <cstdint>
#include <functional>
#include <queue>

namespace jrc
{
template<typename T>
class TimedQueue
{
public:
    TimedQueue(std::function<void(const T&)> in_action)
        : action(in_action), time(0)
    {
    }

    void push(std::int64_t delay, const T& t)
    {
        queue.emplace(time + delay, t);
    }

    template<typename... Args>
    void emplace(std::int64_t delay, Args&&... args)
    {
        queue.emplace(time + delay, std::move(args)...);
    }

    void update(std::int64_t timestep = Constants::TIMESTEP)
    {
        time += timestep;

        for (; !queue.empty(); queue.pop()) {
            const Timed& top = queue.top();
            if (top.when > time) {
                break;
            }

            action(top.value);
        }
    }

private:
    struct Timed {
        T value;
        std::int64_t when;

        Timed(std::int64_t w, const T& v) : value{v}, when{w}
        {
        }

        template<typename... Args>
        Timed(std::int64_t w, Args&&... args)
            : value{std::forward<Args>(args)...}, when{w}
        {
        }
    };

    struct TimedComparator {
        bool operator()(const Timed& a, const Timed& b) const
        {
            return a.when > b.when;
        }
    };

    std::priority_queue<Timed, std::vector<Timed>, TimedComparator> queue;
    std::function<void(const T&)> action;
    std::int64_t time;
};
} // namespace jrc

```

`Template/TypeMap.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <memory>
#include <typeindex>
#include <unordered_map>

namespace jrc
{
template<typename T>
//! An unordered map which uses the type as key.
class TypeMap
{
public:
    using t_ptr = typename std::unique_ptr<T>;
    using pair = typename std::pair<std::type_index, t_ptr>;
    using cpair = typename std::pair<const std::type_index, t_ptr>;
    using underlying_map = typename std::unordered_map<std::type_index, t_ptr>;

    template<typename D, typename... Args>
    D* emplace(Args&&... args)
    {
        auto* ptr = container.emplace(typeid(D), std::make_unique<D>(args...))
                        .first->second.get();
        return static_cast<D*>(ptr);
    }

    template<typename D>
    void erase()
    {
        container.erase(typeid(D));
    }

    void clear()
    {
        container.clear();
    }

    template<typename D>
    D* get()
    {
        return static_cast<D*>(container[typeid(D)].get());
    }

    template<typename D>
    const D* get() const
    {
        return static_cast<D*>(container[typeid(D)].get());
    }

    typename underlying_map::iterator begin()
    {
        return container.begin();
    }

    typename underlying_map::iterator end()
    {
        return container.end();
    }

    typename underlying_map::const_iterator begin() const
    {
        return container.begin();
    }

    typename underlying_map::const_iterator end() const
    {
        return container.end();
    }

private:
    underlying_map container;
};
} // namespace jrc

```

`Template/nullable_ptr.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include <functional>
#include <type_traits>

namespace jrc
{
template<typename T>
//! Wrapper for a nullable, **non-owning** pointer, i.e. `nullable_ptr<T>` is
//! very similar to `T*`. If you need an owning pointer, use
//! `std::unique_ptr<T>` instead.
class nullable_ptr
{
public:
    template<typename R,
             typename = std::enable_if_t<std::is_base_of<R, T>::value
                                         || std::is_base_of<T, R>::value>>
    constexpr nullable_ptr(R* r_val) : val(static_cast<T*>(r_val))
    {
    }

    template<typename R,
             typename = std::enable_if_t<std::is_base_of<R, T>::value
                                         || std::is_base_of<T, R>::value>>
    constexpr nullable_ptr(nullable_ptr<R> r_opt) : nullable_ptr(r_opt.get())
    {
    }

    constexpr nullable_ptr(T* p) : val(p)
    {
    }

    constexpr nullable_ptr(T& p) : val(&p)
    {
    }

    constexpr nullable_ptr() : val(nullptr)
    {
    }

    explicit operator bool() const
    {
        return val != nullptr;
    }

    T* get() const
    {
        return val;
    }

    T* operator->() const
    {
        return val;
    }

    T& operator*() const
    {
        return *val;
    }

private:
    T* val;
};
} // namespace jrc

```

`Timer.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "Template/Singleton.h"

#include <chrono>
#include <cstdint>

namespace jrc
{
//! Small class for measuring elapsed time between game loops.
class Timer : public Singleton<Timer>
{
public:
    Timer() noexcept
    {
        start();
    }

    //! Start the timer by setting the last measurement to now.
    void start() noexcept
    {
        point = clock::now();
    }

    //! Return time elapsed since the last measurement.
    std::int64_t stop() noexcept
    {
        clock::time_point last = point;
        point = clock::now();

        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(
            point - last);
        return duration.count();
    }

private:
    using clock = std::chrono::high_resolution_clock;

    clock::time_point point;
};
} // namespace jrc

```

`Util/HashUtility.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
//#pragma once
#include "HashUtility.h"

#ifdef JOURNEY_USE_XXHASH
#    include <fstream>
#    include <xxhash.h>

namespace jrc
{
namespace HashUtility
{
// 128 MB.
const std::size_t CHUNK_SIZE = 134217728;

std::string get_filehash(const char* filename, std::uint64_t seed)
{
    // Open file stream.
    std::ifstream file(filename);

    std::uint64_t result;
    if (file.good()) {
        // Get size of file.
        file.seekg(0, std::ios_base::end);
        std::size_t end = file.tellg();
        file.seekg(0, std::ios_base::beg);

        if (end < CHUNK_SIZE) {
            // File size is smaller than chunk size so process all at once.
            char* buffer = new char[end];
            file.read(buffer, end);
            result = XXH64(buffer, end, seed);
            delete[] buffer;
        } else {
            // Read file in chunks instead.
            char* buffer = new char[CHUNK_SIZE];
            XXH64_state_t xxhstate;
            XXH_errorcode error;

            error = XXH64_reset(&xxhstate, seed);
            std::size_t offset = 0;
            while (offset < end && error == XXH_OK) {
                file.read(buffer, CHUNK_SIZE);
                error = XXH64_update(&xxhstate, buffer, CHUNK_SIZE);
                offset += CHUNK_SIZE;
            }
            std::size_t remaining = offset - end;
            if (remaining > 0) {
                file.read(buffer, CHUNK_SIZE);
                error = XXH64_update(&xxhstate, buffer, remaining);
            }

            if (error == XXH_OK) {
                result = XXH64_digest(&xxhstate);
            } else {
                result = 0;
            }
            delete[] buffer;
        }
    } else {
        result = 0;
    }

    file.close();
    return std::to_string(result);
}
} // namespace HashUtility
} // namespace jrc
#endif

```

`Util/HashUtility.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Journey.h"

#ifdef JOURNEY_USE_XXHASH
#    include <cstdint>
#    include <string>

namespace jrc
{
// Uses hashing to calculate the hash value of a game file.
namespace HashUtility
{
// Calculate file hash using the fast xxhash algorithm.
std::string get_filehash(const char* filename, std::uint64_t seed);
} // namespace HashUtility
} // namespace jrc
#endif

```

`Util/Lerp.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once

namespace jrc
{
template<typename T>
constexpr T lerp(T first, T second, float alpha)
{
    return alpha <= 0.0f
               ? first
               : alpha >= 1.0f
                     ? second
                     : first == second ? first
                                       : static_cast<T>((1.0f - alpha) * first
                                                        + alpha * second);
}
} // namespace jrc

```

`Util/Misc.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "Misc.h"

namespace jrc
{
namespace string_format
{
void split_number(std::string& input)
{
    for (auto i = input.length(); i > 3; i -= 3) {
        input.insert(i - 3, 1, ',');
    }
}

std::string extend_id(std::int32_t id, std::size_t length)
{
    std::string strid = std::to_string(id);
    if (strid.size() < length) {
        strid.insert(0, length - strid.size(), '0');
    }
    return strid;
}
} // namespace string_format

namespace bytecode
{
bool inline compare(std::int32_t mask, std::int32_t value)
{
    return (mask & value) != 0;
}
} // namespace bytecode
} // namespace jrc

```

`Util/Misc.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Console.h"
#include "boost/bimap.hpp"
#include "boost/bimap/unordered_set_of.hpp"

#include <algorithm>
#include <cstdint>
#include <limits>
#include <string>
#include <type_traits>
#include <utility>

namespace jrc
{
namespace string_conversion
{
template<typename T>
T or_default(const std::string& str, T def) noexcept
{
    try {
        return static_cast<T>(std::stoi(str));
    } catch (const std::exception& ex) {
        Console::get().print(__func__, ex);
        return def;
    }
}

template<typename T>
T or_zero(const std::string& str) noexcept(noexcept(T(0)))
{
    return or_default<T>(str, T(0));
}
}; // namespace string_conversion

namespace string_format
{
//! Format a number string so that each 3 decimal points
//! are seperated by a ',' character.
void split_number(std::string& input);

//! Prefix an id with zeroes so that it has the minimum specified length.
[[nodiscard]] std::string extend_id(std::int32_t id, std::size_t length);
}; // namespace string_format

namespace bytecode
{
//! Check if a bit mask contains the specified value.
bool compare(std::int32_t mask, std::int32_t value);
} // namespace bytecode

namespace math
{
template<typename T, typename U>
T saturating_cast(U u)
{
    static_assert(std::numeric_limits<T>::is_specialized);
    static_assert(std::numeric_limits<U>::is_specialized);

    if constexpr (std::numeric_limits<T>::is_integer) {
        if constexpr (std::numeric_limits<U>::is_integer) {
            if constexpr (sizeof(T) > sizeof(U)) {
                return static_cast<T>(u);
            } else if constexpr (sizeof(T) == sizeof(U)) {
                if constexpr (std::numeric_limits<T>::is_signed
                              == std::numeric_limits<U>::is_signed) {
                    return static_cast<T>(u);
                } else if constexpr (std::numeric_limits<T>::is_signed) {
                    return static_cast<T>(std::min(
                        u, static_cast<U>(std::numeric_limits<T>::max())));
                } else {
                    return static_cast<T>(std::max(
                        u, static_cast<U>(std::numeric_limits<T>::lowest())));
                }
            } else {
                return static_cast<T>(std::min(
                    std::max(u,
                             static_cast<U>(std::numeric_limits<T>::lowest())),
                    static_cast<U>(std::numeric_limits<T>::max())));
            }
        } else {
            return static_cast<T>(std::min(
                std::max(u, static_cast<U>(std::numeric_limits<T>::lowest())),
                static_cast<U>(std::numeric_limits<T>::max())));
        }
    } else {
        if constexpr (std::numeric_limits<U>::is_integer) {
            return static_cast<T>(u);
        } else {
            if constexpr (sizeof(T) >= sizeof(U)) {
                return static_cast<T>(u);
            } else {
                return static_cast<T>(std::min(
                    std::max(u,
                             static_cast<U>(std::numeric_limits<T>::lowest())),
                    static_cast<U>(std::numeric_limits<T>::max())));
            }
        }
    }
}
} // namespace math

namespace bimap
{
template<typename L, typename R>
using unordered_bimap = boost::bimap<boost::bimaps::unordered_set_of<L>,
                                     boost::bimaps::unordered_set_of<R>>;

template<typename L, typename R>
bool assign(unordered_bimap<L, R>& bm, const L& l, const R& r) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto left_iter = bm.left.find(l); left_iter != bm.left.end()) {
        bm.left.replace_data(left_iter, r);
        return false;
    }

    if (auto right_iter = bm.right.find(r); right_iter != bm.right.end()) {
        bm.right.replace_data(right_iter, l);
        return false;
    }

    bm.insert(std::move(val_type{l, r}));
    return true;
}
template<typename L, typename R>
bool assign(unordered_bimap<L, R>& bm, L&& l, R&& r) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto left_iter = bm.left.find(l); left_iter != bm.left.end()) {
        bm.left.replace_data(left_iter, std::forward<R>(r));
        return false;
    }

    if (auto right_iter = bm.right.find(r); right_iter != bm.right.end()) {
        bm.right.replace_data(right_iter, std::forward<L>(l));
        return false;
    }

    bm.insert(std::move(val_type{std::forward<L>(l), std::forward<R>(r)}));
    return true;
}

template<typename L, typename R>
bool left_assign(unordered_bimap<L, R>& bm, const L& l, const R& r) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto left_iter = bm.left.find(l); left_iter != bm.left.end()) {
        bm.left.replace_data(left_iter, r);
        return false;
    }

    bm.insert(std::move(val_type{l, r}));
    return true;
}
template<typename L, typename R>
bool left_assign(unordered_bimap<L, R>& bm, L&& l, R&& r) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto left_iter = bm.left.find(l); left_iter != bm.left.end()) {
        bm.left.replace_data(left_iter, std::forward<R>(r));
        return false;
    }

    bm.insert(std::move(val_type{std::forward<L>(l), std::forward<R>(r)}));
    return true;
}

template<typename L, typename R>
bool right_assign(unordered_bimap<L, R>& bm, const R& r, const L& l) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto right_iter = bm.right.find(r); right_iter != bm.right.end()) {
        bm.right.replace_data(right_iter, l);
        return false;
    }

    bm.insert(std::move(val_type{l, r}));
    return true;
}
template<typename L, typename R>
bool right_assign(unordered_bimap<L, R>& bm, R&& r, L&& l) noexcept
{
    using val_type = typename unordered_bimap<L, R>::value_type;

    if (auto right_iter = bm.right.find(r); right_iter != bm.right.end()) {
        bm.right.replace_data(right_iter, std::forward<L>(l));
        return false;
    }

    bm.insert(std::move(val_type{std::forward<L>(l), std::forward<R>(r)}));
    return true;
}
} // namespace bimap
} // namespace jrc

```

`Util/NxFiles.cpp`:

```cpp
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#include "NxFiles.h"

#include "../Console.h"
#include "nlnx/node.hpp"
#include "nlnx/nx.hpp"

#include <cstdio>
#include <fstream>
#ifndef _WIN32
#    include <unistd.h>
#else
#    include <io.h>
#endif

namespace jrc
{
Error NxFiles::init()
{
    for (auto filename : NxFiles::filenames) {
        if (!std::ifstream{filename}.good()) {
            return {Error::MISSING_FILE, filename};
        }
    }

    try {
        nl::nx::load_all();
    } catch (const std::exception& ex) {
        static const std::string message = ex.what();

        return {Error::NLNX, message.c_str()};
    }

    constexpr const std::string_view POSTCHAOS_BITMAP
        = "Login.img/WorldSelect/BtChannel/layer:bg";
    auto postChaosBitmapType
        = nl::nx::ui.resolve(POSTCHAOS_BITMAP).data_type();

    if (postChaosBitmapType != nl::node::type::bitmap) {
        return Error::WRONG_UI_FILE;
    }

    return Error::NONE;
}
} // namespace jrc

```

`Util/NxFiles.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Error.h"

#include <array>
#include <cstdint>

namespace jrc
{
namespace NxFiles
{
/// Number of needed files.
constexpr std::uint8_t NUM_FILES = 14;
/// Names of the needed game files.
constexpr std::array<const char*, NUM_FILES> filenames = {{"Character.nx",
                                                           "Effect.nx",
                                                           "Etc.nx",
                                                           "Item.nx",
                                                           "Map.nx",
                                                           "Mob.nx",
                                                           "Npc.nx",
                                                           "Quest.nx",
                                                           "Reactor.nx",
                                                           "Skill.nx",
                                                           "Sound.nx",
                                                           "String.nx",
                                                           "TamingMob.nx",
                                                           "UI.nx"}};

/// Initialize nlnx.
/// When successful, also tests if the UI file contains valid images.
///
/// This also tests that the UI.nx file has a post-chaos image in it
/// as a proxy for requiring a v154+ Ui.nx.
Error init();
}; // namespace NxFiles
} // namespace jrc

```

`Util/QuadTree.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include "boost/container/static_vector.hpp"

#include <cstdint>
#include <functional>
#include <unordered_map>
#include <utility>
#include <vector>

namespace jrc
{
template<typename K, typename V>
class QuadTree
{
public:
    enum Direction { LEFT, RIGHT, UP, DOWN };

    QuadTree(std::function<Direction(const V&, const V&)> c)
        : comparator(c), root(0)
    {
    }

    QuadTree() : QuadTree(nullptr)
    {
    }

    void clear()
    {
        nodes.clear();

        root = 0;
    }

    void add(K key, V value)
    {
        K parent = 0;
        if (root) {
            K current = root;
            while (current) {
                parent = current;
                current = nodes[parent].add_or_next(key, value, comparator);
            }
        } else {
            root = key;
        }

        nodes.emplace(std::piecewise_construct,
                      std::forward_as_tuple(key),
                      std::forward_as_tuple(value, parent, 0, 0, 0, 0));
    }

    void erase(K key)
    {
        if (!nodes.count(key)) {
            return;
        }

        Node& to_erase = nodes[key];

        boost::container::static_vector<K, 4> leaves;
        for (std::size_t i = LEFT; i <= DOWN; ++i) {
            if (K leaf_key = to_erase[i]; leaf_key) {
                leaves.push_back(std::move(leaf_key));
            }
        }

        K parent = to_erase.parent;
        if (root == key) {
            root = 0;
        } else if (nodes.count(parent)) {
            nodes[parent].erase(key);
        }

        nodes.erase(key);

        for (auto& leaf : leaves) {
            re_add(parent, leaf);
        }
    }

    K find_node(const V& value,
                std::function<bool(const V&, const V&)> predicate)
    {
        if (root) {
            K key = find_from(root, value, predicate);
            return predicate(value, nodes[key].value) ? key : 0;
        } else {
            return 0;
        }
    }

    V& operator[](K key)
    {
        return nodes[key].value;
    }

    const V& operator[](K key) const
    {
        return nodes.at(key).value;
    }

private:
    K find_from(K start,
                const V& value,
                std::function<bool(const V&, const V&)> predicate)
    {
        if (!start) {
            return 0;
        }

        bool fulfilled = predicate(value, nodes[start].value);
        Direction dir = comparator(value, nodes[start].value);
        if (dir == RIGHT) {
            K right = find_from(nodes[start].right, value, predicate);
            if (right && predicate(value, nodes[right].value)) {
                return right;
            } else {
                return start;
            }
        } else if (dir == DOWN) {
            K bottom = find_from(nodes[start].bottom, value, predicate);
            if (bottom && predicate(value, nodes[bottom].value)) {
                return bottom;
            } else if (fulfilled) {
                return start;
            } else {
                K right = find_from(nodes[start].right, value, predicate);
                if (right && predicate(value, nodes[right].value)) {
                    return right;
                } else {
                    return start;
                }
            }
        } else if (dir == UP) {
            K top = find_from(nodes[start].top, value, predicate);
            if (top && predicate(value, nodes[top].value)) {
                return top;
            } else if (fulfilled) {
                return start;
            } else {
                K right = find_from(nodes[start].right, value, predicate);
                if (right && predicate(value, nodes[right].value)) {
                    return right;
                } else {
                    return start;
                }
            }
        } else {
            K left = find_from(nodes[start].left, value, predicate);
            if (left && predicate(value, nodes[left].value)) {
                return left;
            } else if (fulfilled) {
                return start;
            }

            K bottom = find_from(nodes[start].bottom, value, predicate);
            if (bottom && predicate(value, nodes[bottom].value)) {
                return bottom;
            }

            K top = find_from(nodes[start].top, value, predicate);
            if (top && predicate(value, nodes[top].value)) {
                return top;
            }

            K right = find_from(nodes[start].right, value, predicate);
            if (right && predicate(value, nodes[right].value)) {
                return right;
            } else {
                return start;
            }
        }
    }

    void re_add(K start, K key)
    {
        if (start) {
            K parent = 0;
            K current = start;
            while (current) {
                parent = current;
                current = nodes[parent].add_or_next(
                    key, nodes[key].value, comparator);
            }

            nodes[key].parent = parent;
        } else if (start == root) {
            root = key;

            nodes[key].parent = 0;
        } else if (root) {
            re_add(root, key);
        }
    }

    struct Node {
        V value;
        K parent;
        K left;
        K right;
        K top;
        K bottom;

        Node(const V& v, K p, K l, K r, K t, K b)
            : value(v), parent(p), left(l), right(r), top(t), bottom(b)
        {
        }

        Node() : Node(V(), 0, 0, 0, 0, 0)
        {
        }

        void erase(K key)
        {
            if (left == key) {
                left = 0;
            } else if (right == key) {
                right = 0;
            } else if (top == key) {
                top = 0;
            } else if (bottom == key) {
                bottom = 0;
            }
        }

        K add_or_next(K key,
                      V val,
                      std::function<Direction(const V&, const V&)> cmptor)
        {
            Direction dir = cmptor(val, value);
            K dirkey = leaf(dir);
            if (!dirkey) {
                switch (dir) {
                case LEFT:
                    left = key;
                    break;
                case RIGHT:
                    right = key;
                    break;
                case UP:
                    top = key;
                    break;
                case DOWN:
                    bottom = key;
                    break;
                }
            }
            return dirkey;
        }

        K leaf(Direction dir)
        {
            switch (dir) {
            case LEFT:
                return left;
            case RIGHT:
                return right;
            case UP:
                return top;
            case DOWN:
                return bottom;
            default:
                return 0;
            }
        }

        K operator[](std::size_t d)
        {
            auto dir = static_cast<Direction>(d);
            return leaf(dir);
        }
    };

    std::function<Direction(const V&, const V&)> comparator;
    std::unordered_map<K, Node> nodes;
    K root;
};
} // namespace jrc

```

`Util/Randomizer.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "pcg_random.hpp"

#include <cstdint>
#include <random>

namespace jrc
{
//! Can be used to generate random numbers.
class Randomizer
{
public:
    static bool next_bool() noexcept
    {
        return next_int(2) == 1;
    }

    static bool below(float percent) noexcept
    {
        return next_real(1.0f) < percent;
    }

    static bool above(float percent) noexcept
    {
        return next_real(1.0f) > percent;
    }

    template<class T>
    static T next_real(T to) noexcept
    {
        return next_real<T>(static_cast<T>(0), to);
    }

    template<class T>
    static T next_real(T from, T to) noexcept
    {
        if (from >= to) {
            return from;
        }

        std::uniform_real_distribution<T> range{from, to};
        return range(state.rng);
    }

    template<class T>
    static T next_int(T to) noexcept
    {
        return next_int<T>(static_cast<T>(0), to);
    }

    template<class T>
    static T next_int(T from, T to) noexcept
    {
        if (from >= to) {
            return from;
        }

        std::uniform_int_distribution<T> range{from, to - 1};
        return range(state.rng);
    }

    template<class E>
    static E next_enum(E to = E::LENGTH) noexcept
    {
        return next_enum(E(), to);
    }

    template<class E>
    static E next_enum(E from, E to) noexcept
    {
        return static_cast<E>(next_int<std::underlying_type_t<E>>(from, to));
    }

private:
    struct RandomizerState {
        RandomizerState()
            : rng{pcg_extras::seed_seq_from<std::random_device>{}}
        {
        }
        RandomizerState(const RandomizerState&) = delete;
        RandomizerState(RandomizerState&&) = delete;

        ~RandomizerState() noexcept = default;

        RandomizerState& operator=(const RandomizerState&) = delete;
        RandomizerState& operator=(RandomizerState&&) = delete;

        pcg64 rng;
    };

    inline static thread_local RandomizerState state;
};
} // namespace jrc

```

`Util/Str.h`:

```h
//          Copyright LibreMaple Team 2018 - 2019.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          https://www.boost.org/LICENSE_1_0.txt)
#pragma once

#include <cstdio>
#include <string>
#include <type_traits>
#include <utility>

namespace jrc::str
{
template<typename N, typename = std::enable_if_t<std::is_integral_v<N>>>
[[nodiscard]] std::string to_hex(N n) noexcept
{
    static_assert(sizeof(N) == sizeof(unsigned char)
                      || sizeof(N) == sizeof(unsigned short)
                      || sizeof(N) == sizeof(unsigned)
                      || sizeof(N) == sizeof(unsigned long)
                      || sizeof(N) == sizeof(unsigned long long),
                  "Unrecognized integral type.");

    char ch_buf[19];
    int len;

    if constexpr (sizeof(N) == sizeof(unsigned char)) {
        len = std::snprintf(
            ch_buf, 19, "0x%.2hhX", reinterpret_cast<unsigned char>(n));
    } else if constexpr (sizeof(N) == sizeof(unsigned short)) {
        len = std::snprintf(
            ch_buf, 19, "0x%.2hX", reinterpret_cast<unsigned short>(n));
    } else if constexpr (sizeof(N) == sizeof(unsigned)) {
        len = std::snprintf(
            ch_buf, 19, "0x%.2X", reinterpret_cast<unsigned>(n));
    } else if constexpr (sizeof(N) == sizeof(unsigned long)) {
        len = std::snprintf(
            ch_buf, 19, "0x%.2lX", reinterpret_cast<unsigned long>(n));
    } else {
        len = std::snprintf(
            ch_buf, 19, "0x%.2llX", reinterpret_cast<unsigned long long>(n));
    }

    return std::string(ch_buf, static_cast<std::string::size_type>(len));
}

template<typename T>
[[nodiscard]] std::string::size_type get_len(const T& t) noexcept
{
    using no_cv_t = std::remove_cv_t<T>;

    static_assert(
        !std::is_same_v<no_cv_t,
                        const char*> && !std::is_same_v<no_cv_t, char*>,
        "Don't try to `concat()` together `char*`s. If needed, call "
        "`strlen()` yourself by convering your `char*` to a "
        "`std::string_view`. `char` arrays with compile-time size "
        "work fine.");

    if constexpr (std::is_same_v<std::remove_reference_t<no_cv_t>, char>) {
        return 1;
    } else if constexpr (std::is_array_v<T> && std::rank_v<T> == 1
                         && std::extent_v<T>> 0) {
        static_assert(
            std::is_same_v<std::decay_t<std::remove_extent_t<no_cv_t>>, char>,
            "Got an array, expected it to be of `char`.");

        return std::extent_v<T> - 1;
    } else {
        return t.length();
    }
}

template<typename... Args>
[[nodiscard]] std::string concat(Args&&... args) noexcept
{
    std::string::size_type total_len = (0 + ... + get_len(args));

    std::string s;
    s.reserve(total_len);

    ((s += std::forward<Args>(args)), ...);
    return s;
}
} // namespace jrc::str

```

`Util/TimedBool.h`:

```h
//////////////////////////////////////////////////////////////////////////////
// This file is part of the LibreMaple MMORPG client                        //
// Copyright © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple Team        //
//                                                                          //
// This program is free software: you can redistribute it and/or modify     //
// it under the terms of the GNU Affero General Public License as           //
// published by the Free Software Foundation, either version 3 of the       //
// License, or (at your option) any later version.                          //
//                                                                          //
// This program is distributed in the hope that it will be useful,          //
// but WITHOUT ANY WARRANTY; without even the implied warranty of           //
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            //
// GNU Affero General Public License for more details.                      //
//                                                                          //
// You should have received a copy of the GNU Affero General Public License //
// along with this program.  If not, see <http://www.gnu.org/licenses/>.    //
//////////////////////////////////////////////////////////////////////////////
#pragma once
#include "../Constants.h"

#include <cstdint>

namespace jrc
{
class TimedBool
{
public:
    TimedBool()
    {
        value = false;
        delay = 0;
        last = 0;
    }

    explicit operator bool() const
    {
        return value;
    }

    void set_for(std::int64_t millis)
    {
        last = millis;
        delay = millis;
        value = true;
    }

    void update()
    {
        update(Constants::TIMESTEP);
    }

    void update(std::uint16_t timestep)
    {
        if (value) {
            if (timestep >= delay) {
                value = false;
                delay = 0;
            } else {
                delay -= timestep;
            }
        }
    }

    void operator=(bool b)
    {
        value = b;
        delay = 0;
        last = 0;
    }

    bool operator==(bool b) const
    {
        return value == b;
    }

    bool operator!=(bool b) const
    {
        return value != b;
    }

    float alpha() const
    {
        return 1.0f - static_cast<float>(delay) / static_cast<float>(last);
    }

private:
    std::int64_t last;
    std::int64_t delay;
    bool value;
};
} // namespace jrc

```

`clang-format.py`:

```py
#!/usr/bin/env python3

import os

EXCLUDE_DIRS = [".git", "build", "gsl", ".vscode"]


for dirpath, _, filenames in os.walk("."):
    excluded = False
    for exl_dir in EXCLUDE_DIRS:
        if exl_dir in dirpath:
            excluded = True
            break

    if excluded:
        continue

    for filename in filenames:
        if not filename.endswith(".h") and not filename.endswith(".cpp"):
            continue

        fullname = os.path.join(dirpath, filename)
        os.system(f"clang-format -verbose -i {fullname}")

```

`code-guidelines.md`:

```md
# C++ coding style

## Syntax

* **Just use clang-format**. There is a provided `.clang-format` file which
  will provide all of the information needed for clang-format to prettify any
  C++ code. clang-format won't fix omitted curly braces for you, though.
* Don't omit curly braces, even when they are optional (clang-format
  unfortunately cannot do this for you):
    * Bad:

        ```cpp
        if (condition)
            do_this;
        else
            do_this_instead;
        ```

    * Good:

        ```cpp
        if (condition) {
            do_this;
        } else {
            do_this_instead;
        }
        ```

* Tabs are 4 characters, and thus indentations are also 4 characters. There are
  heretic movements that try to make indentations 8 (or even 2!) characters
  deep, and that is akin to trying to define the value of PI to be 3.
* Use spaces. Never tabs.
* The preferred way to ease multiple indentation levels in a `switch` statement
  is to align the `switch` and its subordinate `case` labels in the same column
  instead of double-indenting the `case` labels:

    ```cpp
    switch (suffix) {
    case 'G':
    case 'g':
        mem <<= 30;
        break;
    case 'M':
    case 'm':
        mem <<= 20;
        break;
    case 'K':
    case 'k':
        mem <<= 10;
        /* fall through */
    default:
        break;
    }
    ```

* Don't put multiple statements on a single line unless you have something to
  hide:
    * Bad:

        ```cpp
        if (condition) do_this;
            do_something_everytime;
        ```

    * Good:

        ```cpp
        if (condition) {
            do_this;
        }

        do_something_everytime;
        ```

* Don't put multiple assignments on a single line either. Keep your coding
  style super simple. Avoid tricky expressions.
* Get a decent editor and don't leave whitespace at the end of lines.
* Use spaces. Never tabs.
* The maximum length (in terms of character widths) for each line is 79, and
  this is a strongly preferred limit.
* Statements longer than 79 columns will be broken into sensible chunks, unless
  exceeding 79 columns **significantly** increases readability and does not
  hide information. Descendants are indented an additional 4 spaces to the
  right. The same applies to function headers with a long argument list.
  However, never break user-visible strings, because that breaks the ability
  to grep for them.
* The other issue that always comes up in C++/C styling is the placement of
  braces. Unlike the indent size, there are few technical reasons to choose one
  placement strategy over the other, but the preferred way, as shown to us by
  the prophets Kernighan and Ritchie, is to put the opening brace last on the
  line, and put the closing brace first, thusly:

    ```cpp
    if (x) {
        do_y();
    }
    ```

  This applies to all non-function statement blocks (`if`, `switch`, `for`,
  `while`, `do`, `try`, `catch`):

    ```cpp
    switch (action) {
    case KOBJ_ADD:
        return "add";
    case KOBJ_REMOVE:
        return "remove";
    case KOBJ_CHANGE:
        return "change";
    default:
        return "none";
    }
    ```

  However, there is one special case, namely functions: they have the opening
  brace at the beginning of the next line, thus:

    ```cpp
    int function(int x)
    {
        // body of function
    }
    ```

  Heretic people all over the world have claimed that this inconsistency is
  ...well... inconsistent, but all right-thinking people know that (a) K&R are
  right and (b) K&R are right. Besides, functions are special anyway (you can't
  nest them in C++/C).

  Note that the closing brace is empty on a line of its own, except in the
  cases where it is followed by a continuation of the same statement, i.e. a
  `while` in a `do`-statement or an `else` in an `if`-statement, like this:

    ```cpp
    do {
        // body of do-loop
    } while (condition);

    // and

    if (x == y) {
        // ...
    } else if (x > y) {
        // ...
    } else {
        // ...
    }
    ```

  Also, note that this brace-placement also minimizes the number of empty (or
  almost empty) lines, without any loss of readability. Thus, as the supply of
  new-lines on your screen is not a renewable resource (think 25-line terminal
  screens here), you have more empty lines to put comments on.
* Use a space after these keywords: `if`, `switch`, `case`, `for`, `do`,
  `while`, `try`, `catch`, but **not** with `sizeof`, `typeid`, or `alignof`.
  E.g.,

    ```cpp
    s = sizeof(struct file);
    ```

  Do not add spaces around (inside) parenthesized expressions. This example is
  **bad**:

    ```cpp
    s = sizeof( struct file );
    ```

* When declaring reference/pointer data or a function that returns a
  reference/pointer type, the preferred use of `&`/`*` is adjacent to the type
  name and not adjacent to the data name or function name. Examples:

    ```cpp
    char* linux_banner;
    std::uint64_t memparse(std::string& ptr, std::string&& retptr);
    char* match_strdup(substring_t* s);
    ```

* Use one space around (on each side of) most binary and ternary operators,
  such as any of these:

    ```cpp
    =  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :
    ```

  but no space after unary operators:

    ```cpp
    &  *  +  -  ~  !  sizeof  typeid  alignof
    ```

  no space before **nor** after the postfix increment and decrement unary
  operators:

    ```cpp
    ++  --
    ```

  and no space around the `.` and `->` structure member operators.

* For naming local variables, fields, functions/methods, `enum class` variants,
  etc., generally stick to all-lowercase snake case (underscores). Encoding the
  type of a function or variable into the name (so-called Hungarian notation)
  is brain damaged --- the compiler knows the types anyway and can check those,
  and it only confuses the programmer. No wonder Microsoft makes buggy
  programs.
* For naming `struct`ures and `class`es, use CamelCase.
* Comments are good, but there is also a danger of over-commenting. **Never**
  try to explain **how** your code works in a comment: it's much better to
  write the code so that the working is obvious, and it's a waste of time to
  explain badly written code.
* Generally, you want your comments to tell **what** your code does, not
  **how**. Also, try to avoid putting comments inside a function body: if the
  function is so complex that you need to separately comment parts of it, you
  should probably reduce its complexity by refactoring. You can make small
  comments to note or warn about something particularly clever (or ugly), but
  try to avoid excess. Instead, put the comments at the head of the function,
  telling people what it does, and possibly **why** it does it.
* Single-line comments are written in plain english, starting with two forward
  slashes and a space, and contain proper capitalization and punctuation.
* Multi-line comments are similar, and look like this:

    ```cpp
    /*
     * This is a multi-line comment.
     * It's got multiple lines.
     * It's readable.
     */
    ```

* Documentation comments (which should, with very few exceptions, be at the
  direct top of every function declaration and every `class`/`struct`
  definition) follow [Doxygen](https://www.stack.nl/~dimitri/doxygen/) style.
  That means starting the first line of a multiline comment with `/*!` or
  `/**`, or using a tight stack of single-line comments that start with `//!`.
  Additionally, such comments are written in
  [Markdown](https://daringfireball.net/projects/markdown/) syntax:

    ```cpp
    /*!
     * This function does X, Y, and then Z.
     *
     * # Arguments
     *
     * - `foo` : Should satisfy `!foo.isBarred()`.
     * - `baz` : Byte to add to the end of the new `foo`.
     */
    void some_function(const Foo& foo, std::uint8_t baz) {
        // ...
    }
    ```

* Doc comments (which are on every function and method declaration) should
  indicate both what the function does, and also indicate if the function is
  pure or not.
* Try to avoid the use of macros (`constexpr` and templates should eliminate
  the need for them), but when you do have to use them, make sure that their
  names are in SHOUTING\_SNAKE\_CASE:

    ```cpp
    #define MY_MACRO "don't use macros, ya silly goose."
    ```

* Use brace initialization and initializer lists, and use them like array
  literals:

    ```cpp
    std::tuple<std::uint64_t, std::string, bool> my_tuple{137, "1/137"s, true};
    ```

* When writing lambda expressions, if the lambda takes zero parameters then the
  parameter list should be omitted. Additionally, if it is possible to omit the
  return type, then that should be omitted too:

    ```cpp
    auto my_lambda = [captured_int] {
        return captured_int + 1;
    };
    ```

* Use `auto`. Unless the type name is *particularly* short, or the type matters
  a **lot** to readers of the code and is non-obvious, `auto` should be
  preferred:

    ```cpp
    for (auto&& [k, v] : consumable_map) {
        do_thing(k);
    }
    ```

## Method

### General

* [The ISO C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines)
  are a good starting place.
* **Use static analysis tools**. These include things like Cppcheck,
  clang-tidy, Oink, etc.
* Heed compiler warnings, including all those generated by the warning flags
  passed in automatically at compile time.
* **Use runtime analysis tools**. These include things like AddressSanitizer,
  LeakSanitizer, ThreadSanitizer, MemorySanitizer, UndefinedBehaviorSanitizer,
  valgrind/cachegrind/callgrind, etc.
* Performance matters.
* Be tidy with resources (memory, file handles, ...). Always clean up after
  yourself, and do so as soon as is applicable. Make sure that you do this
  automatically as often as possible through the use of destructors, so that
  no one can forget.
* RAII.
* Don't give the compiler things that are *specifically* "optimization hints".
  This includes compiler built-ins, as well as use of the `inline` keyword in
  an attempt to get the compiler to inline a function (other, legitimate uses
  of `inline` are acceptable). The compiler knows how to optimize things.
* What cannot be checked at compile time should be checkable at run time.
* A function should perform a single logical operation. Keep functions short
  and simple.
* Don't use `std::endl`. Use `'\n'` instead, and call `.flush()` if necessary.

### Memory and ownership

* In general, don't use bare pointers (`*`). Instead, use one of the following,
  preferrably the closest one to the top of the list:
    * References (an r-value reference `&&` if it makes sense at all to use,
      otherwise just an ordinary l-value reference `&`).
    * Optionals, viz. `std::optional<T>`. This is for when you may or may *not*
      have a value, **strongly** preferable to using a nullable pointer.
    * Spans, viz. `gsl::span<T>`. This only makes sense when you have a pointer
      into some data *and* a length associated with it.
    * Unique pointers, viz. `std::unique_ptr<T>`.
    * Shared pointers, viz. `std::shared_ptr<T>` (or `std::weak_ptr<T>`, as the
      case may be). Only use these if you are definitely sharing this pointer
      and *require* the reference counting, since it comes with considerable
      overhead.
    * `jrc::nullable_ptr<T>`, which is a glorified `T*` that explicitly can be
      null (similar to `std::optional<T*>` but with less syntactic overhead).
      This kind of pointer is, like `T*`, **non-owning**.
    * Actual raw pointers `*`, only if you really have to and you know
      what you're doing. In the case that you resort to this, use
      `gsl::not_null<T>` and `gsl::owner<T>` whenever appropriate. Generally
      you should expect to not be using `gsl::owner<T*>` at all, since `T*` are
      for non-owning pointers, *unlike* `std::shared_ptr<T>`.
* Bare pointers are appropriate for implementing iterators, returning
  non-owning pointers, and for passing around a pointer that represents a
  position.
* Do not use bare invocations of `new` and `delete`. Like, no, really, *don't*.
  See the guidelines above on the use of pointer-like objects.
* Never use `malloc` or `free` (unless some archaic API forces your hand, in
  which case you can encapsulate it).
* When working with movable types (e.g. `std::string`), parameters should be
  `T&&` any time that the function needs to own the value anyways. Then the
  parameter can be `std::move`d wherever it needs to be. No need to make
  unnecessary copies by making the parameter a `const T&` or a bare `T`. If
  needed, the caller can make their own copy, and pass it as a (prvalue)
  temporary directly at the call-site.
* Minimize allocations in general. Use the stack (don't overflow it, though,
  of course).
* When using "smart pointers" (`std::unique_ptr<T>`, `std::shared_ptr<T>`, and
  `std::weak_ptr<T>`), wrap them as being guaranteed non-null
  (e.g. `gsl::not_null<std::unique_ptr<T>>`) when appropriate.
* If you require the use of bare null pointers (you shouldn't since you
  shouldn't be using raw pointers at all, and even if you had a reason, you
  should use `nullable_ptr<T>`, but it's possible that you're interfacing with
  someone else's code that uses nasty raw nullable pointers), use `nullptr`.
* When dealing with values that you may or may not actually have (especially
  when returning such things from functions), prefer the use of
  `std::optional<T>`. If you are returning a pointer that doesn't transfer
  ownership (i.e. a non-owning pointer), then `jrc::nullable_ptr<T>` is
  appropriate.
* Use `gsl::span<T>` (respectively, `gsl::span<const T>`) instead of a
  free-standing `T*` (respectively `const T*`) for which you have the length
  value. So, replace functions like:

    ```cpp
    void read_into(int* buffer, size_t buffer_size);
    ```

  with:

    ```cpp
    void read_into(gsl::span<int> buffer);
    ```

* Use these diagrams when considering how to pass parameters (the first is just
  a simplified version of the second):

    ![Param passing (simple)](https://raw.githubusercontent.com/isocpp/CppCoreGuidelines/master/param-passing-normal.png)

    ![Param passing (advanced)](https://raw.githubusercontent.com/isocpp/CppCoreGuidelines/master/param-passing-advanced.png)

* Do not transfer ownership using references or --- god forbid --- raw
  pointers. This most often applies when returning something from a
  function/method. Instead, transfer *by value* (forcing move semantics using
  `std::move` when necessary), or use smart pointers for that purpose:

    ```cpp
    // BAD!!!
    &vector<double> compute(/* args... */)
    {
        vector<double> res(10000);
        // ...
        return res;
    }

    // Ok.
    vector<double> compute(/* args... */)
    {
        vector<double> res(10000);
        // ...
        return res;
    }
    ```

* Never return a `T&&`.

### Strings

* **Avoid using C-style strings**. Use `std::string`, and `std::string_view`
  when appropriate.
* **Use `std::string_view` for non-owning views into string data** (i.e. what
  you might normally use `const std::string&` for) whenever possible. This is,
  however, not always possible due to holes in the way the standard library
  types work together:
    * Don't fall into the trap of using `std::string_view` in situations where
      C-style strings need to be exposed. Calling `.data()` on a
      `std::string_view` only gets you the string data that the
      `std::string_view` happens to be pointing at, **which is not**
      **necessarily null-terminated**. If you are forced to expose a C-style
      string from a `std::string_view`, you can use
      `std::string{my_string_view}.c_str()`. However this could potentially be
      unnecessarily pricey and may warrant using `const std::string&` instead,
      *if* that would prevent an unnecessary copy.
    * `std::string_view`s are averse to being used in "live" (i.e. not
      `constexpr`) containers, since they are non-owning. It is, of course,
      possible to do, but you *must* be quite careful about the lifetimes of
      the data you're pointing to. As a result, maps (i.e.
      `std::unordered_map`) that map strings to some values generally store the
      keys as `std::string`s, which means that lookups will require access to a
      `const std::string&` instead of a `std::string_view`. Again, it's
      possible to do `std::string{my_string_view}` at the call-site, but
      depending on the situation, this is *probably* an unnecessary copy.
* Use the `s` suffix for string literals that are meant to be `std::string`s,
  whenever this might be ambiguous:

    ```cpp
    using namespace std::literals;

    // Unless you really meant `const char[19]`, this is wrong:
    auto my_string = "string-a-ring-ding";
    // Good, assuming you wanted a `std::string`:
    auto my_string = "string-a-ring-ding"s;
    ```

* Also feel free to use the `sv` suffix for `std::string_view` literals.
* Use `gsl::string_span` for when you need something *like* a
  `std::string_view`, but want to mutate the string being viewed.
* When concatenating together multiple items including `std::string`s,
  `std::string_view`s, `char`s, `bool`s, and `const char[N]`s
  (string literals), use `jrc::str::concat(...)`. Integral and floating-point
  types can be included too, just call `std::to_string` at the call-site of
  `jrc::str::concat(...)`.

### Data structures

* Use `std::array` for sequences of data. If not (because you need a
  vector-like interface that allows pushing and popping), use
  `boost::container::static_vector`. If not (because you need dynamic unbounded
  growth), use `std::vector`. *Under no circumstances* should you resort to the
  use of `std::forward_list` or `std::list`, unless you **REALLY** know what
  you're doing.
* **Use the `unordered_` versions of set/map/multiset/multimap containers**,
  unless you need to persist a sorted order. In that case, use
  `boost::container::flat_` versions of set/map/multiset/multimap. Only if you
  **both** need to persist a sorted order **and** consistently have a lot of
  elements (upwards of a few thousand or so) should you use `std::set`,
  `std::map`, etc.
* Use `std::variant`, not `union`s. NOTE: It may be wise to adopt the scelta
  library, [from here](https://github.com/SuperV1234/scelta).

### Side-effects and compile-time computation

* Make things [pure](https://en.wikipedia.org/wiki/Pure_function) whenever
  possible, and when a function/method is pure, it should (in the case that it
  is a member function) be `constexpr` (or just `const` if necessary), and also
  (in all cases) indicate that it is pure within its doc comment.
  Functions/methods that are not pure should indicate that they are not pure in
  their doc comments.
* **Use `const`**. Use it. Use it again. Wherever you can. Of course only use
  it when applicable, and **respect const-correctness**. Additionally make sure
  you're **not accidentally preventing possible moves** (when those moves would
  be desirable).
* Use `constexpr` *wherever applicable*, including on functions.
* Compile-time constants (say, for example, that the type of a given constant
  is `T`) should almost always be qualified as
  `static constexpr const T NAME_OF_CONSTANT ...`.
* Try to avoid the use of macros; `constexpr` and templates should eliminate
  the need for them.
* Use `if constexpr` for conditional compilation when applicable.
* Pure functions should have the `[[nodiscard]]` attribute. Other functions may
  have a use for the attribute as well; use your judgement.

### Exceptions

* All functions/methods that are incapable of throwing an exception should be
  marked as `noexcept`, and even more importantly, *functions/methods that*
  *make use of exceptions for error handling at all must be marked*
  `noexcept(false)`.
* Do **not** use exceptions in situations where you know that the
  exception-throwing case is actually not that rare (i.e. it is not an
  exceptional case at all).
* Avoid using exceptions, just in general. If you are forced to interface with
  code that *does* use exceptions, there are three approaches that can be
  suitable depending on the context:
    1. Check all preconditions of the exception-throwing function(s) that you
       are calling and make sure that none can be violated before you call the
       function(s). This is usually(?) an acceptable approach so long as the
       preconditions are more than rarely violated and the
       precondition-checking is relatively cheap. This has the advantage of
       allowing your function to be `noexcept` while also not using any `try`
       machinery yourself.
    2. Wrap exception-throwing functions with `try` blocks and handle the
       exceptions yourself. This is acceptable whenever you expect that you
       will rarely or never actually have to `catch` anything (as the catching
       is rather expensive). Such an approach also allows for `noexcept` to be
       specified for your function, assuming of course that you do not
       re-throw or anything like that.
    3. Consider the exceptions (possibly) thrown by the exception-throwing
       interface to be part of the exception contract of your function. Such
       an approach requires your function to be `noexcept(false)`, and
       description of exception-throwing contracts should of course appear in
       the doc comment of your function.
* Instead of using exceptions, you can implement "failure modes" for your
  functions/methods. Things that make this easy are `std::optional<T>` and
  `std::variant<T...>`. NOTE: It may be wise to adopt the `Boost.Outcome`
  library [as seen here](https://ned14.github.io/outcome/) once it is added to
  Boost. `std::optional`s can represent a success (useful value) or failure
  (nothing at all). Variants can be used to represent a success (the first type
  parameter, a useful value) or failure (the second type parameter, a useful
  bit of info about what went wrong). However, due to `std::expected` not
  making it into the C++17 standard library, we should probably wait for
  Boost.Outcome to be added to Boost before adopting this latter technique. Use
  of `std::optional` can look like so:

    ```cpp
    std::optional<Foo> get_foo_maybe() const noexcept
    {
        const auto foo = // ...
        // ...
        if (getting_foo_failed) {
            return {};
        } else {
            return {foo};
        }
    }
    ```

### Declarations

* Avoid using bare `for` and `while` blocks; use iterator-style `for` blocks
  (`for (const auto item : container) { ... }`) instead, or *even better*, use
  standard algorithms and container methods like `for_each`, `find_if`, etc.
* Use structured bindings, when applicable.
* Limit the scope of your variables to be *as small as possible*. Even better,
  don't declare variables at all and simply place the value where it's needed
  (when applicable).
* Use `if`-statement init statements, when applicable, to limit the scope of
  your variables as much as possible (also applies to `switch`):

    ```cpp
    if (auto foo = get_foo(); foo.isBarred()) {
        // ...
    }
    ```

* In general, avoid out params. Use `std::pair`, `std::tuple`, etc. or your own
  structure/class instead. If you *do* use out params, refer to the relevant
  diagrams for parameter passing.
* Generally, use `enum class`, *not* `enum`. If you use an `enum`, it should be
  for the purpose of using the variants as integral types, and should be both
  namespaced (e.g. defined inside of a `class`/`struct` definition) and have
  the underlying type specified (e.g. `enum MyEnum : std::uint16_t { ... }`).
* Keep the number of function/method parameters low. If you find yourself
  writing a function with lots of parameters, you probably just need some kind
  of abstraction (a structure/class, perhaps?).
* Where there is a choice, prefer default arguments over overloading.
* Use `struct` whenever all members are `public`. Otherwise, use `class`.
* `int` is the return type for `main()`. Not `void`. Not anything else. `int`.
* Return `T&` from assignment operators.
* Don't use var-args for parameters. Instead, use overloading, or variadic
  templates, or variant arguments, or `initializer_list` (for homogeneous
  args).

### Typing

* Keep all code as type-safe as possible, and when forced to interact with
  poor/weak typing in some other code, try to encapsulate it so that you don't
  shoot anyone (including yourself) in the foot.
* Avoid using casts. This is part of type-safety. Templates can help.
* To convert from one numeric type to another that doesn't lose precision, use
  brace initialization like so (`static_cast` is also acceptable):

    ```cpp
    const std::int32_t x = 15;
    const std::int64_t y{x};
    ```

* To convert from one numeric type to another that possibly loses
  precision, consider using `gsl::narrow_cast`, or even
  `math::saturating_cast` if saturation is the appropriate semantics for
  "overflow".
* If you *have* to use a cast that is not one of the aforementioned, use
  `static_cast`, but be wary of possible undefined behavior when using it on
  numeric types.
* **Do not use `const_cast` to cast away const-ness**.
* Do not use `reinterpret_cast` nor C-style casts (e.g. `(int) some_float`)
  unless you are a super wizard whom'st knows **exactly** what they are doing.
* When dealing with integral types, prefer to use fixed width integer types
  like `std::uint64_t`, `std::int32_t`, etc.
* If you find that for some reason you need some kind of class
  hierarchy/subtyping, **keep hierarchies as shallow as you possibly can**, and
  **use pure virtual/abstract classes as interfaces rather than extending**
  **other, less general kinds of classes**. Use pure virt class/interfaces as
  if they are typeclasses/traits.
* If you do find yourself writing a pure virt/abstract class, include a
  (not-pure-)virtual destructor, and then do *not* include a virtual destructor
  in implementing/derived classes; those classes should inherit the virtual
  destructor. Also, make sure that as many of the other methods as possible are
  *pure* virtual, not just virtual.

### Lambdas

* Avoid using `std::function` for lambdas unless you have a need for the
  "voldemort" type of the lambda to be erased.
* When giving a name to a lambda (i.e. assigning it to a variable), use `auto`
  for its type.
* Use lambdas for complex initialization, especially of `const` variables (this
  is sometimes called an "IIFE", immediately invoked function expression, due
  to Javascript). This allows more liberal use of `const`, allows for shorter
  lifetimes of variables, and can generate more efficient code:

    ```cpp
    // Bad!
    widget x;  // Should be const, but:
    for (auto i = 2; i <= N; ++i) {          // This could be some
        x += some_obj.do_something_with(i);  // arbitrarily long code
    }                                        // needed to initialize `x`.
    // From here onward, `x` *should* be `const`, but we can't say so in code
    // in this style.

    // Good.
    const widget x = [&] {
        widget val;                               // Assuming that widget has a default constructor.
        for (auto i = 2; i <= N; ++i) {           // This could be some
            val += some_obj.do_something_with(i); // arbitrarily long code
        }                                         // needed to initialize `x`.
        return val;
    }();
    ```

* Use a lambda when a function won't do (to capture local variables, or to
  write a local function).
* **Explicitly list exactly those and only those captures that your lambda**
  **needs**, when possible. I.e., generally avoid `[&]` and `[=]`.
* Prefer capturing by reference in lambdas that will be used locally.
* Avoid capturing by reference in lambdas that will be used nonlocally,
  including returned, stored on the heap, or passed to another thread.
* Generic lambdas are acceptable, and can be achieved using `auto` in parameter
  types, as well as clever use of the `decltype` keyword.
* Mark lambdas as `noexcept` whenever applicable.

### Libraries

* **Use the standard library!** Use the standard algorithms. Use the standard
  data structures. Use the standard... etc. Also use the GSL.
* `std::regex` is good, but please don't use regex for simple things or when
  you really just need a more complex hand-written parser or a parser library.
* When working with time, use `std::chrono`.
* `using namespace std;` is bad, and you should feel bad. "Use" as needed.
  Things that originate from the standard library should have the marker
  `std::`, and likewise for other foreign namespaces.

```

`fonts/Roboto/LICENSE.txt`:

```txt

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`gen_header_filter.py`:

```py
#!/usr/bin/env python3

import os

EXCLUDE_DIRS = [".git", "build", "gsl", ".vscode"]


print(".*(", end="")

for dirpath, _, filenames in os.walk("."):
    excluded = False
    for exl_dir in EXCLUDE_DIRS:
        if exl_dir in dirpath:
            excluded = True
            break

    if excluded:
        continue

    for filename in filenames:
        if not filename.endswith(".h") and not filename.endswith(".cpp"):
            continue

        print(filename.replace(".", r"\.") + "|", end="")

print(r"Journey\.cpp)", end="")

```

`libremaple.doxygen.in`:

```in
# Doxyfile 1.8.14

# This file describes the settings to be used by the documentation system
# doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the config file
# that follow. The default is UTF-8 which is also the encoding used for all text
# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
# built into libc) for the transcoding. See
# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = "LibreMaple"

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         =

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewer a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "FLOSS client for Maplestory"

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           = "logo.png"

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = "doxygen"

# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
# directories (in 2 levels) under the output directory of each output format and
# will distribute the generated files over these directories. Enabling this
# option can be useful when feeding doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise causes
# performance problems for the file system.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
# Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
# less readable) file names. This can be useful is your file systems doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
# first line (until the first dot) of a Javadoc-style comment as the brief
# description. If set to NO, the Javadoc-style will behave just like regular Qt-
# style comments (thus requiring an explicit @brief command for a brief
# description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
# line (until the first dot) of a Qt-style comment as the brief description. If
# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
# requiring an explicit \brief command for a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:\n"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". You can put \n's in the value part of an alias to insert
# newlines (in the resulting output). You can put ^^ in the value part of an
# alias to insert a newline as if a physical newline was in the original file.

ALIASES                =

# This tag can be used to specify a number of word-keyword mappings (TCL only).
# A mapping has the form "name=value". For example adding "class=itcl::class"
# will allow you to use the command class in the itcl::class meaning.

TCL_SUBST              =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
# Fortran. In the later case the parser tries to guess whether the code is fixed
# or free formatted code, this is the default for Fortran type files), VHDL. For
# instance to make doxygen treat .inc files as Fortran files (default is PHP),
# and .f files as C (default is Fortran), use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by doxygen.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See http://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by doxygen, so you can
# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 0.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 0

# When enabled doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also make the inheritance and collaboration
# diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# https://www.riverbankcomputing.com/software/sip/intro) sources only. Doxygen
# will parse them like normal C++ but will assume all classes use public instead
# of private inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = NO

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = NO

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = NO

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = NO

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
# (class|struct|union) declarations. If set to NO, these declarations will be
# included in the documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = NO

# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
# names in lower-case letters. If set to YES, upper-case letters are also
# allowed. This is useful if you have classes or files whose names only differ
# in case and if your file system supports case sensitive file names. Windows
# and Mac users are advised to set this option to NO.
# The default value is: system dependent.

CASE_SENSE_NAMES       = YES

# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents doxygen's defaults, run doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file.
#
# Note that if you run doxygen from a directory containing a file called
# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
# potential errors in the documentation, such as not documenting some parameters
# in a documented function, or documenting parameters that don't exist or using
# markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, doxygen will only warn about wrong or incomplete
# parameter documentation, but not about the absence of documentation.
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
# a warning is encountered.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = "."

# This tag can be used to specify the character encoding of the source files
# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see: https://www.gnu.org/software/libiconv/) for the list of
# possible encodings.
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by doxygen.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cpp \
                         *.c++ \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.markdown \
                         *.md

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# AClass::ANamespace, ANamespace::*Test
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories use the pattern */test/*

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the doxygen output.

USE_MDFILE_AS_MAINPAGE =

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = NO

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# classes and enums directly into the documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# function all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see https://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
# which the alphabetical index list will be split.
# Minimum value: 1, maximum value: 20, default value: 5.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

COLS_IN_ALPHA_INDEX    = 5

# In case all classes in a project start with a common prefix, all classes will
# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
# can be used to specify a prefix (or a list of prefixes) that should be ignored
# while generating the index headers.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list). For an example see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a colorwheel, see
# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use grayscales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
# page will contain the date and time when the page was generated. Setting this
# to YES can help to show when doxygen was last run and thus if the
# documentation is up to date.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_TIMESTAMP         = NO

# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
# documentation will contain a main index with vertical navigation menus that
# are dynamically created via Javascript. If disabled, the navigation index will
# consists of multiple levels of tabs that are statically embedded in every HTML
# page. Disable this option to support browsers that do not have Javascript,
# like the Qt help browser.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_MENUS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see: https://developer.apple.com/tools/xcode/), introduced with
# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
# Makefile in the HTML output directory. Running make will produce the docset in
# that directory and running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See https://developer.apple.com/tools/creatingdocsetswithdoxygen.html
# for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
# Windows.
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the master .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see: http://doc.qt.io/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see: http://doc.qt.io/qt-4.8/qthelpproject.html#virtual-folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# http://doc.qt.io/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location of Qt's
# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
# generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine-tune the look of the index. As an example, the default style
# sheet generated by doxygen has an example that shows how to put an image at
# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
# the same information as the tab index, you could consider setting
# DISABLE_INDEX to YES when enabling this option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# Use the FORMULA_TRANSPARENT tag to determine whether or not the images
# generated for formulas are transparent PNGs. Transparent PNGs are not
# supported properly for IE 6.0, but are supported on all modern browsers.
#
# Note that when changing this option you need to delete any form_*.png files in
# the HTML output directory before the changes have effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_TRANSPARENT    = YES

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# https://www.mathjax.org) which uses client side Javascript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. See the MathJax site (see:
# http://docs.mathjax.org/en/latest/output.html) for more details.
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility), NativeMML (i.e. MathML) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. The destination directory
# should contain the MathJax.js script. For instance, if the mathjax directory
# is located at the same level as the HTML output directory, then
# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
# Content Delivery Network so you can quickly see the result without installing
# MathJax. However, it is strongly recommended to install a local copy of
# MathJax from https://www.mathjax.org before deployment.
# The default value is: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        = https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
# of code that will be used on startup of the MathJax code. See the MathJax site
# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
# example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
# the HTML output. The underlying search engine uses javascript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the javascript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using Javascript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: https://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see: https://xapian.org/). See the section "External Indexing and
# Searching" for details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = YES

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when enabling USE_PDFLATEX this option is only used for generating
# bitmaps for formulas in the HTML output, but not in the Makefile that is
# written to the output directory.
# The default file is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         = latex

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
# generated LaTeX document. The header should contain everything until the first
# chapter. If it is left blank doxygen will generate a standard header. See
# section "Doxygen usage" for information on how to let doxygen write the
# default header to a separate file.
#
# Note: Only use a user-defined header if you know what you are doing! The
# following commands have a special meaning inside the header: $title,
# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
# string, for the replacement values of the other commands the user is referred
# to HTML_HEADER.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
# generated LaTeX document. The footer should contain everything after the last
# chapter. If it is left blank doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer.
#
# Note: Only use a user-defined footer if you know what you are doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
# the PDF file directly from the LaTeX files. Set this option to YES, to get a
# higher quality PDF documentation.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
# command to the generated LaTeX files. This will instruct LaTeX to keep running
# if errors occur, instead of asking the user for help. This option is also used
# when generating formulas in HTML.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
# code with syntax highlighting in the LaTeX output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_SOURCE_CODE      = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plain.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plain

# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
# page will contain the date and time when the page was generated. Setting this
# to NO can help when comparing the output of multiple runs.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_TIMESTAMP        = NO

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to doxygen's config
# file, i.e. a series of assignments. You only have to provide replacements,
# missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to doxygen's config file. A template extensions file can be generated
# using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
# with syntax highlighting in the RTF output.
#
# Note that which sources are shown also depends on other settings such as
# SOURCE_BROWSER.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_SOURCE_CODE        = NO

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = NO

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = man

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
# program listings (including syntax highlighting and cross-referencing
# information) to the DOCBOOK output. Note that enabling this will significantly
# increase the size of the DOCBOOK output.
# The default value is: NO.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_PROGRAMLISTING = NO

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
# AutoGen Definitions (see http://autogen.sourceforge.net/) file that captures
# the structure of the code including all documentation. Note that this feature
# is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
# the class index. If set to NO, only the inherited external classes will be
# listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the modules index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

# The PERL_PATH should be the absolute path and name of the perl script
# interpreter (i.e. the result of 'which perl').
# The default file (with absolute path) is: /usr/bin/perl.

PERL_PATH              = /usr/bin/perl

#---------------------------------------------------------------------------
# Configuration options related to the dot tool
#---------------------------------------------------------------------------

# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
# NO turns the diagrams off. Note that this option also works with HAVE_DOT
# disabled, but it is recommended to install and use dot, since it yields more
# powerful graphs.
# The default value is: YES.

CLASS_DIAGRAMS         = YES

# You can define message sequence charts within doxygen comments using the \msc
# command. Doxygen will then run the mscgen tool (see:
# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
# documentation. The MSCGEN_PATH tag allows you to specify the directory where
# the mscgen tool resides. If left empty the tool is assumed to be found in the
# default search path.

MSCGEN_PATH            =

# You can include diagrams made with dia in doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = NO

# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
# to run in parallel. When set to 0 doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 32, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 0

# When you want a differently looking font in the dot files that doxygen
# generates you can specify the font name using DOT_FONTNAME. You need to make
# sure dot is able to find the font, which can be done by putting it in a
# standard location or by setting the DOTFONTPATH environment variable or by
# setting DOT_FONTPATH to the directory containing the font.
# The default value is: Helvetica.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTNAME           = Helvetica

# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
# dot graphs.
# Minimum value: 4, maximum value: 24, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTSIZE           = 10

# By default doxygen will tell dot to use the default font as specified with
# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
# the path where dot can find it using this tag.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
# each documented class showing the direct and indirect inheritance relations.
# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
# groups, showing the direct groups dependencies.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = NO

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = NO

# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = NO

# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# http://www.graphviz.org/)).
# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
# to make the SVG files visible in IE 9+ (other browsers do not have this
# requirement).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
# png:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = png

# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
# enable generation of interactive SVG images that allow zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
# the SVG files visible. Older versions of IE do not have SVG support.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = NO

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file. If left blank, it is assumed
# PlantUML is not used or called during a preprocessing step. Doxygen will
# generate a warning when it encounters a \startuml command in this case and
# will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for plantuml.

PLANTUML_CFG_FILE      =

# When using plantuml, the specified paths are searched for files specified by
# the !include statement in a plantuml block.

PLANTUML_INCLUDE_PATH  =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that doxygen if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 50

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 0

# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
# background. This is disabled by default, because dot on Windows does not seem
# to support this out of the box.
#
# Warning: Depending on the platform used, enabling this option may lead to
# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
# read).
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_TRANSPARENT        = NO

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
# files that are used to generate the various graphs.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_CLEANUP            = YES

```

`settings.toml`:

```toml
# Settings for the LibreMaple client.
#
# LibreMaple client code is © 2015-2016 Daniel Allendorf, 2018-2019 LibreMaple
# Team, licensed under the GNU Affero General Public License version 3 or
# higher.

[network]
ip = "127.0.0.1"
port = 8484

[video]
fullscreen = false
vsync = true
low_quality = false

[fonts]
normal = "../fonts/Roboto/Roboto-Regular.ttf"
bold = "../fonts/Roboto/Roboto-Bold.ttf"

[audio]
sound_effects = true
music = true
    [audio.volume]  # Volumes are in percentages.
    sound_effects = 50
    music = 50

[account]
save_login = false
account_name = ""
world = 0
channel = 0
character = 0

[ui]
hp_alert = 20
mp_alert = 20
shake_screen = true
simple_minimap = false
    [ui.position]
    key_config = [150, 150]
    stats = [100, 150]
    inventory = [300, 150]
    equip_inventory = [250, 150]
    skillbook = [50, 150]
    change_channel = [350, 300]
    game_settings = [450, 250]
    system_settings = [350, 150]

[[character]]
name = ""
    [character.game_settings]
    whispers = true
    friend_invites = true
    chat_invites = true
    trade_requests = true
    party_invites = true
    sidekick_invites = true
    expedition_invites = true
    guild_chat = true
    guild_invites = true
    alliance_chat = true
    alliance_invites = true
    family_invites = true
    follow = true

```

`tidy.sh`:

```sh
#!/usr/bin/env bash
clang-tidy -analyze-temporary-dtors -checks=-*,cppcoreguidelines-*,clang-analyzer-*,-clang-analyzer-osx*,-clang-analyzer-optin.osx*,bugprone-*,modernize-*,performance-*,portability-*,readability-braces-around-statements -header-filter=$(./gen_header_filter.py) -p ./build "$@"

```