Project Path: arc_gmh5225_Hook-HvlSwitchVirtualAddressSpace__7uyv6oy

Source Tree:

```txt
arc_gmh5225_Hook-HvlSwitchVirtualAddressSpace__7uyv6oy
├── DriverEntry.c
├── Helper.asm
├── HideMemory.c
├── HideMemory.h
└── README.md

```

`DriverEntry.c`:

```c
#include "HideMemory.h"
#include "Memory.h"

#define MAKE_TYPE_ADD(type,point,add)((type)((ULONG64)(point) + ((ULONG64)(add))))

NTKERNELAPI CHAR* PsGetProcessImageFileName(PEPROCESS);

static ULONG64 g_ProcetCr3 = 0;

static ULONG64 g_FakerCr3  = 0;

static ULONG64 Fution[3][2] = { 0,0 };

NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(__in PEPROCESS Process);

//0xc bytes (sizeof)
typedef struct _RUNTIME_FUNCTION
{
	ULONG BeginAddress;                                                     //0x0
	ULONG EndAddress;                                                       //0x4
	union
	{
		ULONG UnwindInfoAddress;                                            //0x8
		ULONG UnwindData;                                                   //0x8
	};
}RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

PRUNTIME_FUNCTION RtlLookupFunctionEntry(
	DWORD64  ControlPc,
	PDWORD64 ImageBase,
	PVOID	 HistoryTable
);

PVOID KeLookupFunctionInfo(PVOID Address, PVOID* BeginAddress, PVOID* EndAddress, SIZE_T* BodySize)
{
	PVOID ImageBase = NULL;
	PRUNTIME_FUNCTION EntryTable;
	if (EntryTable =  RtlLookupFunctionEntry((DWORD64)Address, (PDWORD64)&ImageBase, NULL))
	{
		while (TRUE) {
			if (FALSE == MmIsAddressValid(ImageBase) || FALSE ==  MmIsAddressValid(EntryTable) || FALSE ==  MmIsAddressValid(&EntryTable->UnwindData))
				break;
			PVOID BegiAddress = MAKE_TYPE_ADD(PVOID, ImageBase, EntryTable->BeginAddress);
			PVOID EndpAddress = MAKE_TYPE_ADD(PVOID, ImageBase, EntryTable->EndAddress);
			if (FALSE == MmIsAddressValid(BegiAddress) || FALSE ==  MmIsAddressValid(EndpAddress))
				break;
			if (Address < BegiAddress || Address > EndpAddress)
				break;
			if (BeginAddress)
				*BeginAddress = BegiAddress;
			if (EndAddress)
				*EndAddress = EndpAddress;
			if (BodySize)
				*BodySize = EntryTable->EndAddress - EntryTable->BeginAddress;
			return EndpAddress;
		}
	}
	return BeginAddress;
}
 
 
void HvPreCall(ULONG64 HvType, ULONG64 NewCr3, ULONG64 UnKnow_1, PETHREAD OldThread)
{
	ULONG64 Ret[12] = {0};

	BOOLEAN  IsReadProcess = FALSE;
 
	RtlWalkFrameChain((PVOID*)Ret,12,0);

	if (HvType == HV_TYPE_SWAP_PT && NewCr3)
	{
		if (FALSE == BitTest64((LONG64*)&NewCr3, 1))
		{
			__writecr4(__readcr4() ^ 0x80ull);
			__writecr4(__readcr4() ^ 0x80ull);
		}
 

		for (ULONG64 Index = 0; Index < 12; Index++)
		{
			if (Ret[Index] > Fution[0][0] && Ret[Index] < Fution[0][1])
			{
				IsReadProcess = TRUE;
				break;
			}

			if (Ret[Index] > Fution[1][0] && Ret[Index] < Fution[1][1])
			{
				IsReadProcess = TRUE;
				break;
			}
		}
 
		if (IsReadProcess = FALSE)
		{
			__writecr3(NewCr3);
			goto $EXIT;
		}


		if (g_ProcetCr3 == NewCr3)
		{
			CHAR* Name = PsGetProcessImageFileName(PsGetThreadProcess(PsGetCurrentThread()));
			if (strcmp(Name, "Hacking.exe") == 0)
			{
				//DbgPrintEx(77, 0, "Read\n");
 
				__writecr3(g_FakerCr3);
				goto $EXIT; 
			 
			}
		}

 
		__writecr3(NewCr3);
	}
 

$EXIT:
	return;
}

 
PVOID GetProcAddress(PCWSTR name)
{
	UNICODE_STRING Uname;
	RtlInitUnicodeString(&Uname, name);
	return MmGetSystemRoutineAddress(&Uname);
}
 

NTSTATUS DriverEntry(PDRIVER_OBJECT ObjDrv, PUNICODE_STRING PathDrv)
{

	PEPROCESS Eprocess = GetProcessEprocess(ProcessNameGetProcressId(L"*DWM.EXE"), FALSE);

	g_ProcetCr3 = *(ULONG64 *)((ULONG64)Eprocess + 0X28);

	KeAttachProcess(Eprocess);
	g_FakerCr3 = RebuildPageDirectory(__readcr3());
 
	ClreaAddressPTE(g_FakerCr3, (PVOID)PsGetProcessSectionBaseAddress(Eprocess));
	KeDetachProcess();
 




	//HvRegisterPageMonitoring(HvPreCall);

	return STATUS_SUCCESS;
}
```

`Helper.asm`:

```asm
.DATA
EXTERN g_FuncPointer:QWORD;

.CODE

__asm_hv_dispatcher_handler PROC

mov r9,rdi
mov rax,112233344556677h
jmp rax

__asm_hv_dispatcher_handler ENDP

__asm_set_hv_handler PROC

mov g_FuncPointer,rcx
ret

__asm_set_hv_handler ENDP



__asm_dispatch_iCall PROC FRAME

sub rsp, 0128h
.allocstack 0128h
.endprolog
mov qword ptr[rsp + 0120h],00h
mov [rsp + 0118h],r15
mov [rsp + 0110h],r14
mov [rsp + 0108h],r13
mov [rsp + 0100h],r12
mov [rsp + 00F8h],r11
mov [rsp + 00F0h],r10
mov [rsp + 00E8h],r9
mov [rsp + 00E0h],r8
mov [rsp + 00D8h],rdi
mov [rsp + 00D0h],rsi
mov [rsp + 00C8h],rbp
mov [rsp + 00C0h],rsp
mov [rsp + 00B8h],rbx
mov [rsp + 00B0h],rdx
mov [rsp + 00A8h],rcx
mov [rsp + 00A0h],rax

lea rsi,[rsp + 0150h]
lea rdi,[rsp + 028h]
mov rcx,0Eh
rep movsq
mov [rsp + 020h],r9
mov r9,r8
mov r8,rdx
mov rdx,[rsp + 00A8h] ; get rcx value
lea rcx,[rsp+0A0h]

call rax

mov r15,[rsp + 0118h]
mov r14,[rsp + 0110h]
mov r13,[rsp + 0108h]
mov r12,[rsp + 0100h]
mov r11,[rsp + 00F8h]
mov r10,[rsp + 00F0h]
mov r9,[rsp + 00E8h]
mov r8,[rsp + 00E0h]
mov rdi,[rsp + 00D8h]
mov rsi,[rsp + 00D0h]
mov rbp,[rsp + 00C8h]
mov rbx,[rsp + 00B8h]
mov rdx,[rsp + 00B0h]
mov rcx,[rsp + 00A8h]
mov rax,[rsp + 00A0h]

cmp qword ptr[rsp + 0120h],00h
je $_no_fix_rip
lea rsp, [rsp + 0120h]
ret

$_no_fix_rip:
add rsp, 0128h
ret

__asm_dispatch_iCall ENDP

End
```

`HideMemory.c`:

```c
#include "HideMemory.h"
#include "search.h"
#include "Memory.h"
NTKERNELAPI void HvlInvokeHypercall();

NTKERNELAPI void KeFlushEntireTb();

ULONG64 g_FuncPointer = 0;

void __asm_set_hv_handler(PVOID);

void __asm_hv_dispatcher_handler();

ULONG64(*Ori_HvlSwapGuestVirtualSpace)(ULONG64, ULONG64, ULONG64) = NULL;
 
static HV_CALL_BACK CallBack = NULL;

PVOID RtlGetHypervHvcallCodeVa()
{
	PVOID pHvCallpCodeVaStub = NULL;

	PVOID KernelBase = GetKernelBase(NULL);
 
	unsigned char *tmp = Scan_Pattem_Image(KernelBase, "0F 10 6A 60 0F 10 62  50 0F 10 5A 40 0F 10 52  30 0F 10 4A 20 0F 10 42 10 4C 8B 42 08 48 8B 12", "*");
	if (!tmp)
	{
		KeBugCheck(0x1942B);
	}

	while (tmp++)
	{
		if (*(USHORT*)tmp == 0x15FF)
		{
			pHvCallpCodeVaStub = RELOC(tmp, 2);
			break;
		}
		if (tmp[0] == 0x48 && tmp[1] == 0x8B && tmp[2] == 0x05)
		{
			pHvCallpCodeVaStub =  RELOC(tmp, 3);
			break;
		}
	}
 
//	UCHAR* ControlPC = (UCHAR*)((ULONG64)HvlInvokeHypercall + 0x07);
//	return RVA_VA(ControlPC);

	return pHvCallpCodeVaStub;
}

PVOID RtlGetHypervlEnlightenments()
{ 
 
	PVOID KernelBase = GetKernelBase(NULL);

	unsigned char *tmp = Scan_Pattem_Image(KernelBase, "F7 05 ? ? ? ? 01 00 00 00 74 07 E8 ? ? ? ? EB ? 0F 22 D9", "*");
	DbgPrintEx(77, 0, "%p\n", tmp);
	UCHAR *Enlightenments = RELOC(tmp, 2);
	DbgPrintEx(77, 0, "%p\n", Enlightenments);
	return (PVOID)((ULONG64)Enlightenments + 4);

}


ULONG64  HvlSwapGuestVirtualSpaceCallBack(ULONG64 HvType, ULONG64 NewCr3, ULONG64 UnKnow_1, PETHREAD OldThread)
{
 
	CallBack(HvType, NewCr3, UnKnow_1, OldThread);
	return  2;
}

 __int64 WPOFFx64() {
	__int64 irql = -1;
	if (KeGetCurrentIrql() < DISPATCH_LEVEL)
	{
		irql = KeRaiseIrqlToDpcLevel();
	}
	UINT64 cr0 = __readcr0();
	cr0 &= 0xfffffffffffeffff;
	__writecr0(cr0);
	_disable();
	return irql;
}
 void WPONx64(__int64 irql) {
	UINT64 cr0 = __readcr0();
	cr0 |= 0x10000;
	_enable();
	__writecr0(cr0);
	if (irql >= 0 && KeGetCurrentIrql() > irql)
	{
		KeLowerIrql((KIRQL)irql);
	}
}
BOOLEAN HvRegisterPageMonitoring(HV_CALL_BACK PreCall)
{
	PHYSICAL_ADDRESS PA;
	PA.QuadPart = 0xFFFFFFFFFFFFFFFF;
	PVOID HookCode = MmAllocateContiguousMemory(0x1000, PA);
 
	PVOID HvcallCode  =  *(PVOID *)RtlGetHypervHvcallCodeVa();

	PVOID HvlEnlightenments =  RtlGetHypervlEnlightenments();

	RtlZeroMemory(HookCode, 0);

	RtlCopyMemory(HookCode, __asm_hv_dispatcher_handler, 0x100);

	for (ULONG Index = 0; Index < 0x100; Index++)
	{
		ULONG64 Tag = ((ULONG64)HookCode + Index);
		if (*(ULONG64 *)Tag == 0x112233344556677)
		{
			*(ULONG64 *)Tag = (ULONG64)HvlSwapGuestVirtualSpaceCallBack;
			break;
		}
	}

	CallBack = PreCall;

	//Ori_HvlSwapGuestVirtualSpace =  *HvcallCode;

	//*HvcallCode = __asm_hv_dispatcher_handler;

	  
	__asm_set_hv_handler(HvlSwapGuestVirtualSpaceCallBack);
 
	ULONG64 PTE = SetGetAddressPTE(__readcr3(), HookCode, 0);

	SetGetAddressPTE(__readcr3(),HvcallCode, PTE);


	 *(ULONG32*)HvlEnlightenments = TRUE;

	return TRUE;
}




```

`HideMemory.h`:

```h
#pragma once
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
 
#include <intrin.h>
#include <ntstrsafe.h>

#define HV_TYPE_SWAP_PT 0x10001ull

typedef void (*HV_CALL_BACK)(ULONG64 HvType, ULONG64 NewCr3, ULONG64 UnKnow_1, PETHREAD OldThread);

#define RVA_VA(p) ((PVOID)((PCHAR)(ULONG_PTR)(p) + *(PLONG)(ULONG_PTR)(p) + sizeof(LONG)))

PVOID  RtlGetHypervHvcallCodeVa();

PVOID  RtlGetHypervlEnlightenments();

BOOLEAN  HvRegisterPageMonitoring(HV_CALL_BACK PreCall);
```

`README.md`:

```md
# Hook-HvlSwitchVirtualAddressSpace
Not mine. Only for saving

```