Project Path: arc_gmh5225_external-esp-hack-assaultcube_a3w3fkdf

Source Tree:

```txt
arc_gmh5225_external-esp-hack-assaultcube_a3w3fkdf
├── External
│   ├── Entities.cpp
│   ├── Entities.h
│   ├── Entity.cpp
│   ├── Entity.h
│   ├── External.vcxproj
│   ├── External.vcxproj.filters
│   ├── GDI_drawing.cpp
│   ├── GDI_drawing.h
│   ├── Main.cpp
│   ├── Mathematics.cpp
│   ├── Mathematics.h
│   ├── Offsets.h
│   ├── Player.cpp
│   ├── Player.h
│   ├── Structs.h
│   ├── WinFunctions.cpp
│   └── WinFunctions.h
├── External.sln
└── README.md

```

`External.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30002.166
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "External", "External\External.vcxproj", "{88135322-3D80-4400-BBC0-3F28197B143F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{88135322-3D80-4400-BBC0-3F28197B143F}.Debug|x64.ActiveCfg = Debug|x64
		{88135322-3D80-4400-BBC0-3F28197B143F}.Debug|x64.Build.0 = Debug|x64
		{88135322-3D80-4400-BBC0-3F28197B143F}.Debug|x86.ActiveCfg = Debug|Win32
		{88135322-3D80-4400-BBC0-3F28197B143F}.Debug|x86.Build.0 = Debug|Win32
		{88135322-3D80-4400-BBC0-3F28197B143F}.Release|x64.ActiveCfg = Release|x64
		{88135322-3D80-4400-BBC0-3F28197B143F}.Release|x64.Build.0 = Release|x64
		{88135322-3D80-4400-BBC0-3F28197B143F}.Release|x86.ActiveCfg = Release|Win32
		{88135322-3D80-4400-BBC0-3F28197B143F}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {CA48D503-5A63-4D8C-91B2-9F6F59D2D99E}
	EndGlobalSection
EndGlobal

```

`External/Entities.cpp`:

```cpp
#include <Windows.h>
#include <vector>
#include <iostream>
#include "Entities.h"
#include "WinFunctions.h"
#include "Offsets.h"

// ENTITIES
void Entities::GetEntityAmount()
{	
	amount = winFunc.Read<int>(LPCVOID(players_in_map));
}

void Entities::GetInfo()
{
	list.resize(amount);
	for (int i = 1; i < amount; i++)
	{
		ReadProcessMemory(winFunc.processHandle, LPCVOID(entity_base), &list[i].base, sizeof(list[i].base), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + (0x4 * i)), &list[i].base, sizeof(list[i].base), nullptr);
		ReadProcessMemory(winFunc.processHandle, (PBYTE*)(list[i].base + of_name), &list[i].name, sizeof(list[i].name), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_health), &list[i].health, sizeof(list[i].health), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posx), &list[i].position_head.x, sizeof(list[i].position_head.x), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posy), &list[i].position_head.y, sizeof(list[i].position_head.y), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posz), &list[i].position_head.z, sizeof(list[i].position_head.z), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_team), &list[i].team, sizeof(list[i].team), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posx_normal), &list[i].position_feet.x, sizeof(list[i].position_feet.x), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posy_normal), &list[i].position_feet.y, sizeof(list[i].position_feet.y), nullptr);
		ReadProcessMemory(winFunc.processHandle, LPCVOID(list[i].base + of_posz_normal), &list[i].position_feet.z, sizeof(list[i].position_feet.z), nullptr);
	}
}

void Entities::Print()
{
	std::cout << "=============================" << "\n";
	std::cout << "========= Entities ==========" << "\n";
	std::cout << "=============================" << "\n\n";
	
	for (int i = 1; i < amount; i++)
	{
		list[i].Print();
	}
	
	std::cout << "\n\n";
}
```

`External/Entities.h`:

```h
#pragma once
#include <vector>
#include "WinFunctions.h"
#include "Entity.h"


class Entities {

private:
	WinFunc winFunc;

public:
	int amount;
	std::vector<Entity> list { amount };

	void GetEntityAmount();
	
	Entities(WinFunc wFunc)
	{
		winFunc = wFunc;
		GetEntityAmount(); // Need to init with knowing how many entities there are.
	}

	void GetInfo();
	void Print();
};

```

`External/Entity.cpp`:

```cpp
#include <iostream>
#include "Entity.h"

void Entity::Print()
{
	std::cout << "Name: " << name << "\n";
	std::cout << "Health: " << health << "\n";
	std::cout << "Position (head): (" << position_head.x << ", " << position_head.y << ", " << position_head.z << ")\n";
	std::cout << "Position (feet): (" << position_feet.x << ", " << position_feet.y << ", " << position_feet.z << ")\n";
	std::cout << "Team: " << team << "\n";
	
	std::cout << "\n\n";
}
```

`External/Entity.h`:

```h
#pragma once
#include "Structs.h"

class Entity {

public:

	char name[20];
	int base;
	int health;
	vec3d_f position_head;
	vec3d_f position_feet;
	int team;

	void Print();
};
```

`External/External.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{88135322-3D80-4400-BBC0-3F28197B143F}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>External</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Entities.cpp" />
    <ClCompile Include="Entity.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="GDI_drawing.cpp" />
    <ClCompile Include="Mathematics.cpp" />
    <ClCompile Include="Player.cpp" />
    <ClCompile Include="WinFunctions.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Entities.h" />
    <ClInclude Include="Entity.h" />
    <ClInclude Include="GDI_drawing.h" />
    <ClInclude Include="Mathematics.h" />
    <ClInclude Include="Offsets.h" />
    <ClInclude Include="Player.h" />
    <ClInclude Include="Structs.h" />
    <ClInclude Include="WinFunctions.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`External/External.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Entities.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Entity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="GDI_drawing.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Mathematics.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Player.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinFunctions.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Entities.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Entity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="GDI_drawing.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Mathematics.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Structs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="WinFunctions.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`External/GDI_drawing.cpp`:

```cpp
#include "GDI_drawing.h"
#include <sstream>
#include <iostream>

#pragma warning(disable : 4996) // disable strcopy (overflow)
#pragma warning(disable : 4244) // disable loss of data conversion

void GDI_drawing::SetupDrawing(HDC hDesktop, HWND handle)
{
	GDI_drawing::HDC_Desktop = hDesktop;
	GDI_drawing::Handle = handle;
	TextCOLOR = RGB(0, 255, 0);
}

void GDI_drawing::DrawFilledRect(int x, int y, int w, int h, HBRUSH brushColor)
{
	RECT rect = { x,y,x + w,y + h };
	FillRect(GDI_drawing::HDC_Desktop, &rect, brushColor);
}

void GDI_drawing::DrawBorderBox(int x, int y, int w, int h, int thickness, HBRUSH brushColor)
{
	DrawFilledRect(x, y, w, thickness, brushColor);
	DrawFilledRect(x, y, thickness, h, brushColor);
	DrawFilledRect((x + w), y, thickness, h, brushColor);
	DrawFilledRect(x, y + h, w + thickness, thickness, brushColor);
}

void GDI_drawing::DrawString(int x, int y, COLORREF color, const char* text)
{
	SetTextAlign(GDI_drawing::HDC_Desktop, TA_CENTER | TA_NOUPDATECP);
	SetBkColor(GDI_drawing::HDC_Desktop, RGB(0, 0, 0));
	SetBkMode(GDI_drawing::HDC_Desktop, TRANSPARENT);
	SetTextColor(GDI_drawing::HDC_Desktop, color);
	SelectObject(GDI_drawing::HDC_Desktop, GDI_drawing::Font);
	TextOutA(GDI_drawing::HDC_Desktop, x, y, text, strlen(text));
	DeleteObject(Font);
}

void GDI_drawing::DrawESP(int x, int y, float distance, int health, char name[20], HBRUSH hBrush, COLORREF Pen)
{
	int width = 1100 / distance;	//18100

	int height = 2000 / distance;	//36000

	DrawBorderBox(x - (width / 2), y - height, width, height, 1, hBrush);

	std::stringstream ss;
	ss << std::to_string((int)distance) + " meters";

	std::stringstream dd;
	dd << std::to_string(health) + " HP";

	std::stringstream nn;
	nn << name;

	char* distanceInfo = new char[ss.str().size() + 1];
	strcpy(distanceInfo, ss.str().c_str());

	char* healthInfo = new char[dd.str().size() + 3];
	strcpy(healthInfo, dd.str().c_str());

	char* nameInfo = new char[nn.str().size() + 3];
	strcpy(nameInfo, nn.str().c_str());

	DrawString(x, y, GDI_drawing::TextCOLOR, nameInfo);
	DrawString(x, y + 15, GDI_drawing::TextCOLOR, distanceInfo);
	DrawString(x, y + 30, GDI_drawing::TextCOLOR, healthInfo);

	delete[] distanceInfo;
	delete[] healthInfo;
}


DWORD WINAPI GDI_drawing::esp(Entities entities, Player player, Mathematics math)
{
	GetWindowRect(FindWindow(NULL, "AssaultCube"), &m_Rect);
	
	while (true)
	{
		player.GetInfo();
		entities.GetInfo();

		for (int i = 0; i < entities.amount; i++)
		{
			if (math.WorldToScreen(entities.list[i].position_feet, math.screen, player.matrix, 800, 600) && entities.list[i].health > 0)
			{
				if (entities.list[i].team != player.team)
				{
					GDI_drawing::DrawESP(math.screen.x, math.screen.y, math.GetDistance3D(player.position_feet, entities.list[i].position_feet), entities.list[i].health, entities.list[i].name, GDI_drawing::hBrushEnemy, GDI_drawing::enemyColor);
				}
			}
		}
	}
} 
```

`External/GDI_drawing.h`:

```h
//#pragma once
#include "WinFunctions.h"
#include "Structs.h"
#include "Entities.h"
#include "Player.h"
#include "Mathematics.h"

class GDI_drawing {

private:
	WinFunc winFunc;

public:

	GDI_drawing(WinFunc wFunc)
	{
		winFunc = wFunc;
	}

	HBRUSH hBrushEnemy = CreateSolidBrush(RGB(255, 0, 0));
	HBRUSH hBrushTeam = CreateSolidBrush(RGB(0, 0, 255));
	HBRUSH hBrushNeutral = CreateSolidBrush(RGB(255, 255, 255));
	COLORREF enemyColor = RGB(255, 0, 0);
	COLORREF teamColor = RGB(0, 0, 255);
	COLORREF neutralColor = RGB(255, 255, 255);
	
	//ESP
	HDC HDC_Desktop;
	HFONT Font;
	HWND TargetWnd;
	HWND Handle;
	COLORREF TextCOLOR;
	RECT m_Rect;

	void SetupDrawing(HDC hDesktop, HWND handle);

	void DrawFilledRect(int x, int y, int w, int h, HBRUSH brushColor);

	void DrawBorderBox(int x, int y, int w, int h, int thickness, HBRUSH brushColor);
	
	void DrawString(int x, int y, COLORREF color, const char* text);

	void DrawESP(int x, int y, float distance, int health, char name[20], HBRUSH hBrush, COLORREF Pen);

	DWORD WINAPI esp(Entities entities, Player player, Mathematics math);
};

```

`External/Main.cpp`:

```cpp
#include <iostream>
#include "WinFunctions.h"
#include "Player.h"
#include "Entities.h"
#include "Mathematics.h"
#include "GDI_drawing.h"

int main()
{
	WinFunc win;
	win.GetInfo("AssaultCube");
	win.Print();

	Player player(win);
	player.GetInfo();
	player.Print();


	Entities entities(win);
	entities.GetInfo();
	entities.Print();

	Mathematics math(win);

	GDI_drawing draw(win);

	ShowWindow(FindWindowA("ConsoleWindowClass", NULL), true);
	draw.TargetWnd = FindWindow(0, "AssaultCube");
	draw.HDC_Desktop = GetDC(draw.TargetWnd);
	draw.SetupDrawing(draw.HDC_Desktop, draw.TargetWnd);

	draw.esp(entities, player, math);

	std::cout << "sup";

	return 0;
}


```

`External/Mathematics.cpp`:

```cpp
#include "Mathematics.h"
#include <cmath>
#include <iostream>

bool Mathematics::WorldToScreen(vec3d_f pos, vec3d_f& screen, float matrix[16], int windowWidth, int windowHeight)
{
	
	Mathematics::clipCoords.x = pos.x * matrix[0] + pos.y * matrix[4] + pos.z * matrix[8] + matrix[12];
	Mathematics::clipCoords.y = pos.x * matrix[1] + pos.y * matrix[5] + pos.z * matrix[9] + matrix[13];
	Mathematics::clipCoords.z = pos.x * matrix[2] + pos.y * matrix[6] + pos.z * matrix[10] + matrix[14];
	Mathematics::clipCoords.w = pos.x * matrix[3] + pos.y * matrix[7] + pos.z * matrix[11] + matrix[15];

	if (clipCoords.w < 0.1f)
	{
		return false;
	}

	Mathematics::NDC.x = clipCoords.x / clipCoords.w;
	Mathematics::NDC.y = clipCoords.y / clipCoords.w;
	Mathematics::NDC.z = clipCoords.z / clipCoords.w;

	Mathematics::screen.x = (windowWidth / 2 * NDC.x) + (NDC.x + windowWidth / 2);
	Mathematics::screen.y = -(windowHeight / 2 * NDC.y) + (NDC.y + windowHeight / 2);
	
	return true;
}

float Mathematics::GetDistance3D(vec3d_f m_pos, vec3d_f en_pos)
{
	return (float)(sqrt(((en_pos.x - m_pos.x) * (en_pos.x - m_pos.x)) + ((en_pos.y - m_pos.y) * (en_pos.y - m_pos.y)) + ((en_pos.z - m_pos.z) * (en_pos.z - m_pos.z))));
}

float Mathematics::GetDistance2D(vec3d_f m_pos, vec3d_f en_pos)
{
	return { (float)(sqrt(
	((en_pos.x - m_pos.x) * (en_pos.x - m_pos.x))
	+ ((en_pos.z - m_pos.z) * (en_pos.z - m_pos.z))
	)) };
}

vec3d_f Mathematics::CalculateAngles(vec3d_f m_pos, vec3d_f en_pos)
{

	vec3d_f values;

	float aTriangle = en_pos.x - m_pos.x;
	float bTriangle = en_pos.z - m_pos.z;
	float yTriangle = en_pos.y - m_pos.y;

	float triangleHyp = Mathematics::GetDistance2D(m_pos, en_pos);

	float yaw = -(float)(atan2(aTriangle, bTriangle) * (HALF_CIRCLE / MATH_PI) + HALF_CIRCLE);
	float pitch = (float)((atan2(yTriangle, triangleHyp)) * (HALF_CIRCLE / MATH_PI));

	values.x = yaw;
	values.y = pitch;
	values.z = 0;
	return values;
}
```

`External/Mathematics.h`:

```h
#pragma once
#include "WinFunctions.h"
#include "Structs.h"

class Mathematics {

private:
	WinFunc winFunc;
	const double MATH_PI = 3.14159265359f;
	const int HALF_CIRCLE = 180;

public:

	vec3d_f screen;
	vec4d_f clipCoords;
	vec4d_f NDC;

	Mathematics(WinFunc wFunc)
	{
		winFunc = wFunc;
	}

	bool WorldToScreen(vec3d_f pos, vec3d_f& screen, float matrix[16], int windowWidth, int windowHeight);

	float GetDistance3D(vec3d_f m_pos, vec3d_f en_pos);
	float GetDistance2D(vec3d_f m_pos, vec3d_f en_pos);

	vec3d_f CalculateAngles(vec3d_f m_pos, vec3d_f en_pos);
	
	void GetInfo();
	void Print();
};

```

`External/Offsets.h`:

```h
#pragma once
#include <vector>

static int base_address = 0x00400000;
static int of_base_address = 0x0010F4F4;
static int player_base = base_address + of_base_address;

// Direct reading
static int entity_base = player_base + 0x4;
static int players_in_map = player_base + 0xC;

// Player / Entities
static int of_health = 0xF8;
static int of_name = { 0x225 };
static int of_posx = { 0x4 };
static int of_posy = { 0x8 };
static int of_posz = { 0xC };
static int of_ang_left_right = { 0x40 };
static int of_ang_up_down = { 0x44 };
static int of_team = 0x32C;
static int of_viewmatrix = 0x501AE8;
static int of_posx_normal = 0x34;
static int of_posy_normal = 0x38;
static int of_posz_normal = 0x3C;
```

`External/Player.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "Player.h"
#include "WinFunctions.h"
#include "Offsets.h"

void Player::GetInfo()
{
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(player_base), &base, sizeof(base), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_health), &health, sizeof(health), nullptr);
	ReadProcessMemory(winFunc.processHandle, (PBYTE*)(base + of_name), &name, sizeof(name), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posx), &position_head.x, sizeof(position_head.x), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posy), &position_head.y, sizeof(position_head.y), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posz), &position_head.z, sizeof(position_head.z), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_team), &team, sizeof(team), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posx_normal), &position_feet.x, sizeof(position_feet.x), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posy_normal), &position_feet.y, sizeof(position_feet.y), nullptr);
	ReadProcessMemory(winFunc.processHandle, (LPCVOID)(base + of_posz_normal), &position_feet.z, sizeof(position_feet.z), nullptr);
	ReadProcessMemory(winFunc.processHandle, (PBYTE*) (of_viewmatrix), &matrix, sizeof(matrix), nullptr);

}

void Player::Print()
{
	std::cout << "=============================" << "\n";
	std::cout << "========== Player ===========" << "\n";
	std::cout << "=============================" << "\n\n";
	
	std::cout << "Name (me): " << health << "\n";
	std::cout << "Health: " << health << "\n";
	std::cout << "Position (head): (" << position_head.x << ", " << position_head.y << ", " << position_head.z << ")\n";
	std::cout << "Position (feet): (" << position_feet.x << ", " << position_feet.y << ", " << position_feet.z << ")\n";
	std::cout << "Team: " << team << "\n";
	
	std::cout << "\n\n";
}

```

`External/Player.h`:

```h
#pragma once
#include "WinFunctions.h"
#include "Structs.h"

class Player {

private:
	WinFunc winFunc;
	
public:

	char name[20];
	int base;
	int health;
	float matrix[16];
	vec2d_f screen;
	vec3d_f position_head;
	vec3d_f position_feet;
	int team;
	
	Player(WinFunc wFunc)
	{
		winFunc = wFunc;
	}

	void GetInfo();
	void Print();
};

```

`External/Structs.h`:

```h
#pragma once

typedef struct
{
	float x, y;
} vec2d_f;

typedef struct
{
	float x, y, z;	
} vec3d_f;

typedef struct
{
	float x, y, z, w;
} vec4d_f;


```

`External/WinFunctions.cpp`:

```cpp
#include "WinFunctions.h"
#include <iostream>

DWORD WinFunc::GetPID(LPCSTR process_name) {

	DWORD processID;
	HWND windowHandle = FindWindowA(nullptr, process_name);
	GetWindowThreadProcessId(windowHandle, &processID);

	return processID;
}

HANDLE WinFunc::GetHandle(DWORD pid) {
	return OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE, false, pid);
}


void WinFunc::GetInfo(LPCSTR process_name)
{
	processID = GetPID(process_name);
	processHandle = GetHandle(processID);
}

void WinFunc::Print()
{
	std::cout << "=============================" << "\n";
	std::cout << "=========== Game ============" << "\n";
	std::cout << "=============================" << "\n\n";

	std::cout << "PID:    " << processID << "\n";
	std::cout << "Handle: " << processHandle << "\n";

	std::cout <<"\n\n";
}
```

`External/WinFunctions.h`:

```h
#pragma once
#include <windows.h>

class WinFunc
{

public:

	DWORD processID;
	HANDLE processHandle;
	//static HWND windowHandle;
	
	static DWORD GetPID(LPCSTR process_name);

	static HANDLE GetHandle(DWORD pid);

	void GetInfo(LPCSTR process_name);
	void Print();

	template <class T>
	T Read(LPCVOID address)
	{
		T VALUE;
		ReadProcessMemory(processHandle, (LPCVOID)(address), &VALUE, sizeof(T), 0);
		return VALUE;
	}
};
```

`README.md`:

```md
# AssaultCube-External-ESP-Hack

Simple proof of concept on how to draw to an overlay through the use of GDI in Assault Cube.

- WHAT IS THIS:
  - This small hack finds players on the game map and draws a distance from one self to the enemy.
    ![alt text](https://github.com/Ctrl-Alt-1337/AssaultCube-GDI-ESP-Overlay/blob/master/screenshot.jpg)

- HOW TO RUN THE HACK:
  - If using Visual Studio then Right Click on the project -> Properties
    - -> Advanced -> Character Set -> Make sure you use 'Use Multi-Byte Character Set'
  - Build the hack (platform: Win32)
  - Enter AssaultCube
  - Start the hack
  
- OTHER RELEVANT INFO:
	- Base address and offsets for entities (names, positions, health etc.) are found through OllyDbg and Cheat Engine.
  - Relevant WinAPI functions: ```FindWindowA```, ```GetWindowThreadProcessId```, ```OpenProcess```, ```ReadProcessMemory```

- CREDITS:
	- WorldToScreen: Guidedhacking.com
  
- DISCLAIMER:
  - Run this in singleplayer mode ONLY. This hack should never be used to ruin the game for other players. This serves solely as a purpose for learning and to better understand the workings of memory forensics and the WinAPI.


```