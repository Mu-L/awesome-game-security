Project Path: arc_gmh5225_osu-aac_6_9scn49

Source Tree:

```txt
arc_gmh5225_osu-aac_6_9scn49
├── README.md
├── some-csharp-function-to-work-with-dlls
│   ├── Program.cs
│   ├── README.md
│   └── dothack.csproj
├── symbols.md
└── token.md

```

`README.md`:

```md
# OSU(lazer) Anti Anti Cheat Project

Recently, ppy emerged a spyware called "Osu anticheat" into osu lazer.

## Warning for osu lazer player

DO NOT RUN any executable provided by ppy/osu repository as `release`.
These binaries contain spyware and may potentialy be malware.

**PEPPY is known for screeshoting player desktop..**
[a similar reddit post, not a proof](https://www.reddit.com/r/osugame/comments/4ky41w/osu_source_code_leaked_confirms_ppy_and_devs_are/)

If anyone has a dump of the other thread with proofs, please pull request.

## Warning for cheaters/h0xx1rs

Please don't cheat and don't use this code to cheat =].

## Therefore

A OSU-AAC is a project that aims to completely disable osu-lazer client-side anticheat and let people play osu lazer online with self-hosted binaries.

If you want to participate, please look at the `token.md` and `symbols.md` file;

## Anticheat structure

Anticheat is located in `Osu.Game.Auth.dll`, that can be found nearby the `osu!` binary.
It loads as a dynamic library and links a `sign` into `ApiAccess` and `HubClientConnector`.

Please note, that `Osu.Game` is also infected. Offical osu repo does not contain `sign` delegate, while binary release code does.

Peppy obviously has a patch that is applied manually every single release.

After doing that, a secret set of tokens are extracted/imported into both server and client anticheat.
The tokens are used for signing **secured** methods like score submitting.
Whats a shame, is that without a signature (`x-token` header) YOU CANNOT play multiplayer.

```

`some-csharp-function-to-work-with-dlls/Program.cs`:

```cs
using System;
using System.Text;
using System.Reflection;
using Microsoft.AspNetCore.Http.Connections.Client;

Assembly assembly = Assembly.LoadFrom("./auth.dll");

void getMapValue(int index) {
  String cname = "\u000f\u0010\u0002";
  Type t = assembly.GetType(cname);
  if (t == null) {
    Console.WriteLine("type not found");
    Environment.Exit(0);
  }
  
  Console.WriteLine("type found");
  MethodInfo method = null;
  foreach (MethodInfo m in t.GetMethods(BindingFlags.Static | BindingFlags.NonPublic)) {
    ParameterInfo[] pms = m.GetParameters();
    if (pms.Length == 1 && pms[0].ParameterType == typeof(int)) {
      method = m;
    }
  }
  if (method == null) {
    Console.WriteLine("method (int) not found");
    Environment.Exit(0);
  }
  Console.WriteLine("method found");
  
  Console.WriteLine("value: " + method.Invoke(null, new object[] { index }));
}

void getValue() {
  String cname = "\u0005\u0015\u0002";
  Type t = assembly.GetType(cname);
  if (t == null) {
    Console.WriteLine("type not found");
    Environment.Exit(0);
  }
  
  Console.WriteLine("type found");
  MethodInfo method = null;
  foreach (MethodInfo m in t.GetMethods(BindingFlags.Static | BindingFlags.Public)) {
    if (m.ReturnType == typeof(Stream)) {
      method = m;
    }
  }
  if (method == null) {
    Console.WriteLine("method (int) not found");
    Environment.Exit(0);
  }
  Console.WriteLine("method found");
  
  //HttpConnectionOptions opts = new HttpConnectionOptions();
  Stream SS = (Stream) method.Invoke(null, new object[] {});
  StreamReader reader = new StreamReader(SS);
  string MSG = reader.ReadLine();
  byte[] ba = Encoding.Default.GetBytes(MSG);
  Console.WriteLine(BitConverter.ToString(ba).Replace("-", ""));
}
getMapValue(-1506375197);

```

`some-csharp-function-to-work-with-dlls/README.md`:

```md
# some-...

- Change the code
- Run `dotnet run`

## Also

Yes, the dlls like `osu.Game`, `osu.Game.Auth` must be here, look on the `csproj` file..

```

`some-csharp-function-to-work-with-dlls/dothack.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
	  <EnableDynamicLoading>true</EnableDynamicLoading>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore" Version="2.2.0" />
    <PackageReference Include="Microsoft.AspNetCore.Http.Connections.Client" Version="8.0.1" />
    <PackageReference Include="System.Text.Json" Version="8.0.1" />
    <Reference Include="osu.Framework">
      <HintPath>.\osu.Framework.dll</HintPath>
    </Reference>
    <Reference Include="Realm">
      <HintPath>.\Realm.dll</HintPath>
    </Reference>
    <Reference Include="osuTK">
      <HintPath>.\osuTK.dll</HintPath>
    </Reference>
    <Reference Include="osu.Game">
      <HintPath>.\osu.Game.dll</HintPath>
    </Reference>
  </ItemGroup>

</Project>

```

`symbols.md`:

```md
```csharp
// \u000e\u000f\u0002
private static void \u0002(WebRequest \u0002)
{
	object[] array = new object[1] { \u0002 };
	\u0005\u0015\u0002.b().\u0002(\u0005\u0015\u0002.\u000e\u0015\u0002(), "H@'o.IXcKg", array);
}

private static void \u0002(HttpConnectionOptions \u0002)
{
	object[] array = new object[1] { \u0002 };
	\u0005\u0015\u0002.b().\u0002(\u0005\u0015\u0002.\u000e\u0015\u0002(), "H@'mQIXc<b", array);
}

private static string \u0002(byte[] \u0002)
{
	object[] array = new object[1] { \u0002 };
	return (string)\u0005\u0015\u0002.b().\u0002(\u0005\u0015\u0002.\u000e\u0015\u0002(), "H@'nNIXbsX", array);
}
```

```csharp
// osu.Game.Auth.Loader
private void \u0002()
	{
		object[] array = new object[1] { this };
		\u0005\u0015\u0002.b().\u0002(\u0005\u0015\u0002.\u000e\u0015\u0002(), "H@'nkIXcfp", array);
	}

	public void Dispose()
	{
		object[] array = new object[1] { this };
		\u0005\u0015\u0002.b().\u0002(\u0005\u0015\u0002.\u000e\u0015\u0002(), "H@'m]IXciq", array);
	}
```

```csharp
// \u000e\u000f\u0002
using System.Reflection;
using osu.Framework.IO.Network;
using osu.Game.Online;
using osu.Game.Online.API;

private bool \u0002()
{
	try
	{
		\u000e\u000f\u0002.\u0002 = typeof(WebRequest).GetField(\u000f\u0010\u0002.\u0002(-1506375722), BindingFlags.Instance | BindingFlags.NonPublic);
		\u0005.OnLoadComplete += \u0002;
		APIRequest.Sign = \u0002;
		HubClientConnector.Sign = \u0002;
		\u0008.BindValueChanged(\u0002);
		return true;
	}
	catch
	{
		return false;
	}
```

```csharp
// osu.Game.Online.HubClientConnector
using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http.Connections.Client;
using Microsoft.AspNetCore.SignalR;
using Microsoft.AspNetCore.SignalR.Client;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using osu.Framework;

protected override Task<PersistentEndpointClient> BuildConnectionAsync(CancellationToken cancellationToken)
{
	IHubConnectionBuilder builder = ((IHubConnectionBuilder)new HubConnectionBuilder()).WithUrl(endpoint, (Action<HttpConnectionOptions>)delegate(HttpConnectionOptions options)
	{
		if (RuntimeInfo.OS != RuntimeInfo.Platform.iOS)
		{
			options.Proxy = WebRequest.DefaultWebProxy;
			if (options.Proxy != null)
			{
				options.Proxy!.Credentials = CredentialCache.DefaultCredentials;
			}
		}
		options.Headers.Add("Authorization", "Bearer " + API.AccessToken);
		options.Headers.Add("OsuVersionHash", versionHash);
		Sign(options);
	});
```

```

`token.md`:

```md
# Definition

Token is a `x-token` header sent by the client to the server every time you submit ascore.

# Format

A string consisting of [0-N characters][82 bytes of token data];
Token data is

```
[0      32           40                       80  82]
[       ==============                              ] -  ClientTimeHex
[=====================                              ] -  ClientData
[========                                           ] -  ClientHash
[                    ===========================    ] -  Expected
[                                             ======] -  Version
```

Notes:
ClientData is a set of ClientTimeHex + ClientHash

Based on this data, the "expected" value is calculated as

```php
$build = Build::firstWhere([
    'hash' => $input['clientHash'],
    'allow_ranking' => true,
]);

$computed = hash_hmac(
    'sha1',
    $input['clientData'],
    static::getKey($build),
    true,
);
```

After that, the check is done.

Notes:

- ClientTime check is `if (abs($now - $input['clientTime']) > $GLOBALS['cfg']['osu']['client']['token_lifetime']) {`
  So, better set it to nearby the end of the universe.
  (LIKELY) Client version is not used

Data needed to complete the test:

- ClientHash
- BuildID

Notes:
(LIKELY) ClientHash is _NOT_ the `File.OpenRead(typeof(OsuGameBase).Assembly.Location))`!

# Source

https://github.com/ppy/osu-web/blob/3103311c07f05a4f0287e7500dccf11e17aad3c8/app/Http/Controllers/ScoreTokensController.php#L50

```php
$buildId = ClientCheck::parseToken($request)['buildId'];
```

https://github.com/ppy/osu-web/blob/master/app/Libraries/ClientCheck.php#L16

```php
if ($token === null) {
    throw new ClientCheckParseTokenException('missing token header');
}

$input = static::splitToken($token);

$build = Build::firstWhere([
    'hash' => $input['clientHash'],
    'allow_ranking' => true,
]);

if ($build === null) {
    throw new ClientCheckParseTokenException('invalid client hash');
}

$ret['buildId'] = $build->getKey();

$computed = hash_hmac(
    'sha1',
    $input['clientData'],
    static::getKey($build),
    true,
);
```

https://github.com/ppy/osu-web/blob/master/app/Libraries/ClientCheck.php#L91

```php
private static function splitToken(string $token): array
{
    $data = substr($token, -82);
    $clientTimeHex = substr($data, 32, 8);
    $clientTime = strlen($clientTimeHex) === 8
        ? unpack('V', hex2bin($clientTimeHex))[1]
        : 0;

    return [
        'clientData' => substr($data, 0, 40),
        'clientHash' => hex2bin(substr($data, 0, 32)),
        'clientTime' => $clientTime,
        'expected' => hex2bin(substr($data, 40, 40)),
        'version' => substr($data, 80, 2),
    ];
}
```

```