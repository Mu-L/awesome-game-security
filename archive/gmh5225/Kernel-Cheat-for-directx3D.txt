Project Path: arc_gmh5225_Kernel-Cheat-for-directx3D_ky7vfdol

Source Tree:

```txt
arc_gmh5225_Kernel-Cheat-for-directx3D_ky7vfdol
├── KernelDX3DDriver
│   ├── KernelDX3DDriver.vcxproj
│   ├── KernelDX3DDriver.vcxproj.filters
│   ├── define.h
│   ├── driver.cpp
│   ├── function.cpp
│   ├── function.h
│   ├── hook.cpp
│   └── hook.h
├── KernelDX3DDriver.sln
├── README.md
└── UMProject
    ├── UMProject.cpp
    ├── UMProject.vcxproj
    └── UMProject.vcxproj.filters

```

`KernelDX3DDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.5.33627.172
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KernelDX3DDriver", "KernelDX3DDriver\KernelDX3DDriver.vcxproj", "{D108864B-37C9-49EC-9C41-05C504E7F55E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UMProject", "UMProject\UMProject.vcxproj", "{3A22D52C-412A-4F61-8B0C-838D99F661CF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|ARM64.Build.0 = Debug|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x64.ActiveCfg = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x64.Build.0 = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x64.Deploy.0 = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x86.ActiveCfg = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x86.Build.0 = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Debug|x86.Deploy.0 = Debug|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|ARM64.ActiveCfg = Release|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|ARM64.Build.0 = Release|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|ARM64.Deploy.0 = Release|ARM64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x64.ActiveCfg = Release|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x64.Build.0 = Release|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x64.Deploy.0 = Release|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x86.ActiveCfg = Release|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x86.Build.0 = Release|x64
		{D108864B-37C9-49EC-9C41-05C504E7F55E}.Release|x86.Deploy.0 = Release|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|ARM64.ActiveCfg = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|ARM64.Build.0 = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|x64.ActiveCfg = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|x64.Build.0 = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|x86.ActiveCfg = Debug|Win32
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Debug|x86.Build.0 = Debug|Win32
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|ARM64.ActiveCfg = Release|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|ARM64.Build.0 = Release|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|x64.ActiveCfg = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|x64.Build.0 = Debug|x64
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|x86.ActiveCfg = Release|Win32
		{3A22D52C-412A-4F61-8B0C-838D99F661CF}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {917BBD23-6402-4C49-8BCA-D380960AF64F}
	EndGlobalSection
EndGlobal

```

`KernelDX3DDriver/KernelDX3DDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{D108864B-37C9-49EC-9C41-05C504E7F55E}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>KernelDX3DDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
    <Link>
      <EntryPointSymbol>EntryPoint</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp" />
    <ClCompile Include="hook.cpp" />
    <ClCompile Include="function.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="function.h" />
    <ClInclude Include="define.h" />
    <ClInclude Include="hook.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KernelDX3DDriver/KernelDX3DDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="function.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="define.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="function.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KernelDX3DDriver/define.h`:

```h
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <windef.h>
#include <ntstrsafe.h>
#include <wdm.h>
#include <wingdi.h>

#pragma comment(lib, "ntoskrnl.lib")

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation,
	SystemProcessorInformation,
	SystemPerformanceInformation,
	SystemTimeOfDayInformation,
	SystemPathInformation,
	SystemProcessInformation,
	SystemCallCountInformation,
	SystemDeviceInformation,
	SystemProcessorPerformanceInformation,
	SystemFlagsInformation,
	SystemCallTimeInformation,
	SystemModuleInformation = 0x0B
} SYSTEM_INFORMATION_CLASS,
* PSYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _PEB_LDR_DATA {
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandle;
	LIST_ENTRY ModuleListLoadOrder;
	LIST_ENTRY ModuleListMemoryOrder;
	LIST_ENTRY ModuleListInitOrder;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;  // in bytes
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;  // LDR_*
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	ULONG CheckSum;
	ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
	BYTE Reserved1[16];
	PVOID Reserved2[10];
	UNICODE_STRING ImagePathName;
	UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef void(__stdcall* PPS_POST_PROCESS_INIT_ROUTINE)(void); // not exported

typedef struct _PEB {
	BYTE Reserved1[2];
	BYTE BeingDebugged;
	BYTE Reserved2[1];
	PVOID Reserved3[2];
	PPEB_LDR_DATA Ldr;
	PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
	PVOID Reserved4[3];
	PVOID AtlThunkSListPtr;
	PVOID Reserved5;
	ULONG Reserved6;
	PVOID Reserved7;
	ULONG Reserved8;
	ULONG AtlThunkSListPtr32;
	PVOID Reserved9[45];
	BYTE Reserved10[96];
	PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
	BYTE Reserved11[128];
	PVOID Reserved12[1];
	ULONG SessionId;
} PEB, * PPEB;

extern "C" __declspec(dllimport)
NTSTATUS NTAPI ZwProtectVirtualMemory(
	HANDLE ProcessHandle,
	PVOID * BaseAddress,
	PULONG ProtectSize,
	ULONG NewProtect,
	PULONG OldProtect
);

extern "C" NTKERNELAPI
PVOID
NTAPI
RtlFindExportedRoutineByName(
	_In_ PVOID ImageBase,
	_In_ PCCH RoutineNam
);

extern "C" NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

extern "C" NTKERNELAPI
PPEB
PsGetProcessPeb(
	IN PEPROCESS Process
);

extern "C" NTSTATUS NTAPI MmCopyVirtualMemory
(
	PEPROCESS SourceProcess,
	PVOID SourceAddress,
	PEPROCESS TargetProcess,
	PVOID TargetAddress,
	SIZE_T BufferSize,
	KPROCESSOR_MODE PreviousMode,
	PSIZE_T ReturnSize
);
```

`KernelDX3DDriver/driver.cpp`:

```cpp
#include "hook.h"

extern "C" NTSTATUS EntryPoint(PDRIVER_OBJECT driverObj,PUNICODE_STRING registryPath)
{
	UNREFERENCED_PARAMETER(driverObj);
	UNREFERENCED_PARAMETER(registryPath);

	bool fatched =CallKernelFunction(&HookHandler);

	DbgPrint("Driver Loaded %d\n",fatched);
	return STATUS_SUCCESS;
}
```

`KernelDX3DDriver/function.cpp`:

```cpp
#include "function.h"

PVOID GetSystemModuleBase(const char* moduleName)
{
	ULONG bytes = 0; 
	NTSTATUS status = ZwQuerySystemInformation(SystemModuleInformation, NULL, bytes, &bytes); 

	if (!bytes) 
		return NULL;

	PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePool2(POOL_FLAG_NON_PAGED, bytes, 0x4e554c4c);

	status = ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes); 
	
	if (!NT_SUCCESS(status))
		return NULL;
	PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
	PVOID moduleBase = 0, moduleSize = 0;

	for (ULONG i = 0; i < modules->NumberOfModules; i++)
	{
		if (strcmp((char*)module[i].FullPathName, moduleName)==0)
		{
			moduleBase = module[i].ImageBase;
			moduleSize =(PVOID) module[i].ImageSize;
			break;
		}
	}

	if (modules)
		ExFreePool(modules);
	if (moduleBase <= NULL)
		return NULL;

	return moduleBase;
}

PVOID GetSystemModuleExport(const char* moduleName, LPCSTR routineName)
{

	PVOID lpModule = GetSystemModuleBase(moduleName);
	if (!lpModule)
		return NULL;
	return RtlFindExportedRoutineByName(lpModule, routineName);
}


PVOID GetSystemModuleExport(LPCWSTR moduleName, LPCSTR routineName)
{
	PLIST_ENTRY moduleList = reinterpret_cast<PLIST_ENTRY>(GetSystemRoutineAddress(L"PsLoadedModuleList"));
	if (!moduleList)
		return NULL;

	for (PLIST_ENTRY link = moduleList->Flink; link != moduleList; link = link->Flink)
	{
		LDR_DATA_TABLE_ENTRY * entry = CONTAINING_RECORD(link, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);
		UNICODE_STRING name;
		RtlInitUnicodeString(&name, moduleName);

		if (RtlEqualUnicodeString(&entry->BaseDllName, &name, TRUE))
		{
			// Check if the module base address is valid
			if (entry->DllBase == NULL || entry->SizeOfImage == 0)
				continue;

			// Check if the routine name is provided
			if (routineName != NULL)
			{
			
				PVOID routineAddress = RtlFindExportedRoutineByName(entry->DllBase, routineName);
				if (routineAddress != NULL)
					return routineAddress;
			}
			else
			{
				// No routine name provided, return the module base address
				return entry->DllBase;
			}
		}
	}

	return NULL;
}
bool WriteMemory(void* address, void* buffer, size_t size)
{
	if (!RtlCopyMemory(address, buffer, size))
	{
		return false;
	}
	else {
		return true;
	}
}

bool WriteToReadOnlyMemory(void* address, void* buffer, size_t size)
{
	PMDL mdl = IoAllocateMdl(address, (ULONG)size, false, false, NULL);//mdl이 가상주소 페이지의 설명 메모리 할당
	if (!mdl)
		return false;
	MmProbeAndLockPages(mdl, KernelMode, IoReadAccess); //할당된 메모리를 인자값에 해당하는 페이지 조사,mdl이 물리적 페이지를 descript하도록 변경 후lock
	PVOID Mapping = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);//할당한 메모리를 매핑
	MmProtectMdlSystemAddress(mdl, PAGE_READWRITE);//매핑된 메모리 권한 설정
	WriteMemory(Mapping, buffer, size);
	MmUnmapLockedPages(Mapping, mdl);// 언매핑
	IoFreeMdl(mdl);//mdl 할당 해지
	return true;
}

ULONG64 GetModuleBaseX64(PEPROCESS proc, UNICODE_STRING moduleName)
{
	PPEB pPeb = PsGetProcessPeb(proc);
	if (!pPeb)
		return NULL;
	KAPC_STATE state;
	KeStackAttachProcess(proc, &state);

	PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)pPeb->Ldr;
	if (!pLdr)
	{
		KeUnstackDetachProcess(&state);
		return NULL;
	}

	for (PLIST_ENTRY list = (PLIST_ENTRY)pLdr->ModuleListLoadOrder.Flink; list != &pLdr->ModuleListLoadOrder; list = (PLIST_ENTRY)list->Flink)
	{
		PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(list, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);

		if (RtlCompareUnicodeString(&pEntry->BaseDllName, &moduleName, TRUE) == NULL)
		{
			ULONG64 baseAddr = (ULONG64)pEntry->DllBase;
			KeUnstackDetachProcess(&state);
			return baseAddr;
		}
	}

	KeUnstackDetachProcess(&state);
	return NULL;


}

bool ReadKernelMemory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size)
{
	if (!address || !buffer || !size) 
		return false;

	SIZE_T bytes = 0; 
	NTSTATUS status = STATUS_SUCCESS; 
	PEPROCESS process; 

	if ((HANDLE)pid == 0) return false;
	PsLookupProcessByProcessId((HANDLE)pid, &process); 
	status = MmCopyVirtualMemory(process, (void*)address, (PEPROCESS)PsGetCurrentProcess(), (void*)buffer, size, KernelMode, &bytes); 

	if (!NT_SUCCESS(status))
	{
		return false;
	}
	else
	{
		return true;
	}
}

bool WriteKernelMemory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size)
{
	KAPC_STATE state;
	NTSTATUS status = STATUS_SUCCESS; 
	PEPROCESS process;
	
	if(!address||!buffer||!size)
		return false;
	
	if ((HANDLE)pid == 0) 
		return false;

	PsLookupProcessByProcessId((HANDLE)pid, &process); 
	KeStackAttachProcess((PEPROCESS)process, &state);//주소에 타겟 프로세스의 루틴으로 현재 스레드를 attach
	
	MEMORY_BASIC_INFORMATION info;
	status = ZwQueryVirtualMemory(ZwCurrentProcess(), (PVOID)address, MemoryBasicInformation, &info, sizeof(info), NULL);//메모리 주소에 대한 베이스 주소와 보호상태 확인을 위한 INFO 
	

	if (((uintptr_t)info.BaseAddress + info.RegionSize) < (address + size)) 
	{
		KeUnstackDetachProcess(&state);
		return false;
	}

	if (!(info.State & MEM_COMMIT) || (info.Protect & (PAGE_GUARD | PAGE_NOACCESS)))
	{
		KeUnstackDetachProcess(&state);
		return false;
	}

	if ((info.Protect & PAGE_EXECUTE_READWRITE) || (info.Protect & PAGE_EXECUTE_WRITECOPY)
		|| (info.Protect & PAGE_READWRITE) || (info.Protect & PAGE_WRITECOPY))
	{
		RtlCopyMemory((void*)address, buffer, size);
	}
	KeUnstackDetachProcess(&state);
	return true;

}

PVOID GetSystemRoutineAddress(PCWSTR routineName)
{
	UNICODE_STRING name;
	RtlInitUnicodeString(&name, routineName);
	return MmGetSystemRoutineAddress(&name);
}



```

`KernelDX3DDriver/function.h`:

```h
#pragma once
#include "define.h"

PVOID GetSystemModuleBase(const char* moduleName);
PVOID GetSystemModuleExport(const char* moduleName, LPCSTR routineName);
bool WriteMemory(void* address, void* buffer, size_t size);
bool WriteToReadOnlyMemory(void* address, void* buffer, size_t size);
ULONG64 GetModuleBaseX64(PEPROCESS proc, UNICODE_STRING moduleName);
bool ReadKernelMemory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size);
bool WriteKernelMemory(HANDLE pid, uintptr_t address, void* buffer, SIZE_T size);
PVOID GetSystemRoutineAddress(PCWSTR routineName);
PVOID GetSystemModuleExport(LPCWSTR moduleName, LPCSTR routineName);
typedef struct _NULL_MEMORY
{
	void* buffer_address;
	UINT_PTR address;
	ULONGLONG size;
	ULONG pid;
	BOOLEAN write;
	BOOLEAN read;
	BOOLEAN req_base;
	BOOLEAN draw_box;
	int		r, g, b, x, y, w, h, t;
	void* output;
	const char* module_name;
	ULONG64 base_address;
}NULL_MEMORY;
```

`KernelDX3DDriver/hook.cpp`:

```cpp
#include "hook.h"

GdiSelectBrush_t GdiSelectBrush = NULL;
PatBlt_t NtGdiPatBlt = NULL;
NtGdiCreateSolidBrush_t NtGdiCreateSolidBrush = NULL;
NtUserGetDC_t NtUserGetDc = NULL;
RealeaseDC_t ReleaseDc = NULL;
DeleteObjectApp_t DeleteObjectApp = NULL;
NtGdiExtTextOutW_t NtGdiExtTextOutW = NULL;
int (*func)(int a) = NULL;
INT Dx[10] = { 10, -5, 10, 5, 10, -10, 10, 5, 10, 5 };

bool CallKernelFunction(void* kernelFunctionAddress)
{
	
	if (!kernelFunctionAddress)
		return false;
	PVOID* function = reinterpret_cast<PVOID*>(GetSystemModuleExport("\\SystemRoot\\System32\\drivers\\dxgkrnl.sys",
		"NtDxgkGetTrackedWorkloadStatistics"));
	
	if (!function)
		return false;
	BYTE original[] = { 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
	BYTE shellCodeStart[] = { 0x48,0xB8 };// MOV RAX , XXX
	BYTE shellCodeEnd[] = { 0xFF,0xE0 }; //jmp RAX

	RtlSecureZeroMemory(&original, sizeof(original));
	memcpy(original, shellCodeStart, sizeof(shellCodeStart));
	uintptr_t hookAddress = reinterpret_cast<uintptr_t>(kernelFunctionAddress);
	memcpy(original + sizeof(shellCodeStart), &hookAddress, sizeof(void*));
	memcpy(original + sizeof(shellCodeStart) + sizeof(void*), &shellCodeEnd, sizeof(shellCodeEnd));
	WriteToReadOnlyMemory(function, &original, sizeof(original));
	
	
	GdiSelectBrush = (GdiSelectBrush_t)GetSystemModuleExport(L"win32kfull.sys", "NtGdiSelectBrush");
	NtGdiCreateSolidBrush = (NtGdiCreateSolidBrush_t)GetSystemModuleExport(L"win32kfull.sys", "NtGdiCreateSolidBrush");
	NtGdiPatBlt = (PatBlt_t)GetSystemModuleExport(L"win32kfull.sys", "NtGdiPatBlt");
	NtUserGetDc = (NtUserGetDC_t)GetSystemModuleExport(L"win32kbase.sys", "NtUserGetDC");
	ReleaseDc = (RealeaseDC_t)GetSystemModuleExport(L"win32kbase.sys", "NtUserReleaseDC");
	DeleteObjectApp = (DeleteObjectApp_t)GetSystemModuleExport(L"win32kbase.sys", "NtGdiDeleteObjectApp");
	NtGdiExtTextOutW = (NtGdiExtTextOutW_t)GetSystemModuleExport(L"win32kfull.sys", "NtGdiExtTextOutW");
	return true;
}

NTSTATUS HookHandler(PVOID calledParam) //NtOpenSurface ~~ hooked work
{
	NULL_MEMORY* instructions = (NULL_MEMORY*)calledParam;
	if (instructions->draw_box == TRUE)
	{
		HDC hdc = NtUserGetDc(NULL);
		if (!hdc)
			return STATUS_UNSUCCESSFUL;

		HBRUSH brush = NtGdiCreateSolidBrush(RGB(instructions->r, instructions->g, instructions->b), NULL);
		if (!brush)
			return STATUS_UNSUCCESSFUL;

		RECT rect = { instructions->x, instructions->y, instructions->x + instructions->w, instructions->y + instructions->h };
		FrameRect(hdc, &rect, brush, instructions->t);
		
		
		
		
		ReleaseDc(hdc);
		DeleteObjectApp(brush);
	}

	return STATUS_SUCCESS;
}
INT FrameRect(HDC 	hDC,
	CONST RECT* lprc,
	HBRUSH 	hbr,
	int thickness
	)
{
	HBRUSH oldbrush;
	RECT r = *lprc;
	oldbrush = GdiSelectBrush(hDC, hbr);
	if (!oldbrush) return 0;

	NtGdiPatBlt(hDC, r.left, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.right - thickness, r.top, thickness, r.bottom - r.top, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.top, r.right - r.left, thickness, PATCOPY);
	NtGdiPatBlt(hDC, r.left, r.bottom - thickness, r.right - r.left, thickness, PATCOPY);
	
	GdiSelectBrush(hDC, oldbrush);
	return TRUE;
}


```

`KernelDX3DDriver/hook.h`:

```h
#pragma once
#include "function.h"

bool CallKernelFunction(void* kernelFunctionAddress);
NTSTATUS HookHandler(PVOID calledParam);
INT FrameRect(HDC 	hDC,
	CONST RECT* lprc,
	HBRUSH 	hbr,
	int thickness
);

typedef HBRUSH(*GdiSelectBrush_t)(_In_ HDC 	hdc,
	_In_ HBRUSH 	hbr
	);
typedef BOOL(*PatBlt_t)(_In_ 	HDC,
	_In_ int x,
	_In_ int y,
	_In_ int w,
	_In_ int h,
	_In_ 	DWORD
	);
typedef HDC(*NtUserGetDC_t)(HWND hWnd);


typedef HBRUSH (*NtGdiCreateSolidBrush_t)(_In_ COLORREF 	cr,
	_In_opt_ HBRUSH 	hbr
);


typedef int (*RealeaseDC_t)(HDC hdc);
typedef BOOL(*DeleteObjectApp_t)(HANDLE hobj);





typedef BOOL(*NtGdiExtTextOutW_t)(IN HDC 	hDC,
	IN INT 	XStart,
	IN INT 	YStart,
	IN UINT 	fuOptions,
	IN OPTIONAL LPRECT 	UnsafeRect,
	IN LPWSTR 	UnsafeString,
	IN INT 	Count,
	IN OPTIONAL LPINT 	UnsafeDx,
	IN DWORD 	dwCodePage
	);
```

`README.md`:

```md
# Kernel-Cheat-for-directx3D
requires : set custom driverEntry and mannually load this driver compiled < 세션 권한 문제로 접근 위반 문제가 생김

```

`UMProject/UMProject.cpp`:

```cpp
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <memory>
#include <string_view>
#include <cstdint>
#include <vector>

typedef struct _NULL_MEMORY
{
	void* buffer_address;
	UINT_PTR address;
	ULONGLONG size;
	ULONG pid;
	BOOLEAN write;
	BOOLEAN read;
	BOOLEAN req_base;
	BOOLEAN draw_box;
	int		r, g, b, x, y, w, h, t;
	void* output;
	const char* module_name;
	ULONG64 base_address;
}NULL_MEMORY;

uintptr_t base_address = 0;
std::uint32_t process_id = 0;
HDC hdc;

template<typename ... Arg>
uint64_t call_hook(const Arg ... args)
{
	void* hooked_func = GetProcAddress(LoadLibrary("win32u.dll"), "NtDxgkGetTrackedWorkloadStatistics");

	auto func = static_cast<uint64_t(_stdcall*)(Arg...)>(hooked_func);

	return func(args ...);
}

struct HandleDisposer
{
	using pointer = HANDLE;
	void operator()(HANDLE handle) const
	{
		if (handle != NULL || handle != INVALID_HANDLE_VALUE)
		{
			CloseHandle(handle);
		}
	}
};

using unique_handle = std::unique_ptr<HANDLE, HandleDisposer>;

std::uint32_t get_process_id(std::string_view process_name)
{
	PROCESSENTRY32 processentry;
	const unique_handle snapshot_handle(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL));

	if (snapshot_handle.get() == INVALID_HANDLE_VALUE)
		return NULL;

	processentry.dwSize = sizeof(MODULEENTRY32);

	while (Process32Next(snapshot_handle.get(), &processentry) == TRUE)
	{
		if (process_name.compare(processentry.szExeFile) == NULL)
		{
			
			return processentry.th32ProcessID;
		}
	}
	return NULL;
}

static ULONG64 get_module_base_address(const char* module_name)
{
	NULL_MEMORY instructions = { 0 };
	instructions.pid = process_id;
	instructions.req_base = TRUE;
	instructions.read = FALSE;
	instructions.write = FALSE;
	instructions.draw_box = FALSE;
	instructions.module_name = module_name;
	call_hook(&instructions);

	ULONG64 base = NULL;
	base = instructions.base_address;
	return base;
}
template <class T>
T Read(UINT_PTR read_address)
{
	T response{};
	NULL_MEMORY instructions;
	instructions.pid = process_id;
	instructions.size = sizeof(T);
	instructions.address = read_address;
	instructions.read = TRUE;
	instructions.write = FALSE;
	instructions.req_base = FALSE;
	instructions.draw_box = FALSE;
	instructions.output = &response;
	call_hook(&instructions);

	return response;
}

bool write_memory(UINT_PTR write_address, UINT_PTR source_address, SIZE_T write_size)
{
	NULL_MEMORY instructions;
	instructions.address = write_address;
	instructions.pid = process_id;
	instructions.write = TRUE;
	instructions.read = FALSE;
	instructions.req_base = FALSE;
	instructions.draw_box = FALSE;
	instructions.buffer_address = (void*)source_address;
	instructions.size = write_size;

	call_hook(&instructions);

	return true;
}

bool draw_box(int x, int y, int w, int h, int t, int r, int g, int b)
{
	NULL_MEMORY instructions;
	instructions.write = FALSE;
	instructions.read = FALSE;
	instructions.req_base = FALSE;
	instructions.draw_box = TRUE;

	instructions.x = x;
	instructions.y = y;
	instructions.w = w;
	instructions.h = h;
	instructions.t = t;

	instructions.r = r;
	instructions.g = g;
	instructions.b = b;

	call_hook(&instructions);

	return true;
}

template<typename S>
bool write(UINT_PTR write_address, const S& value)
{
	return write_memory(write_address, (UINT_PTR)&value, sizeof(S));
}

int main()
{
	while (true)
	{
		draw_box(50, 50, 50, 50, 2, 255, 0, 0);
	}
	while (1)
	{
		;
	}
}
```

`UMProject/UMProject.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{3a22d52c-412a-4f61-8b0c-838d99f661cf}</ProjectGuid>
    <RootNamespace>UMProject</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>NotSet</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard_C>Default</LanguageStandard_C>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="UMProject.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`UMProject/UMProject.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="소스 파일">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="헤더 파일">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="리소스 파일">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="UMProject.cpp">
      <Filter>소스 파일</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```