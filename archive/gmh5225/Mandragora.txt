Project Path: arc_gmh5225_Mandragora_wvd22256

Source Tree:

```txt
arc_gmh5225_Mandragora_wvd22256
├── Mandragora
│   ├── Mandragora.vcxproj
│   ├── Mandragora.vcxproj.filters
│   ├── src
│   │   ├── anticheat
│   │   │   ├── anticheat.cpp
│   │   │   ├── anticheat.h
│   │   │   ├── callbacks
│   │   │   │   ├── callbacks.cpp
│   │   │   │   ├── callbacks.h
│   │   │   │   └── virtual_protect
│   │   │   │       └── vp_callback.cpp
│   │   │   ├── local_player
│   │   │   │   ├── local_player.cpp
│   │   │   │   └── local_player.h
│   │   │   ├── stub
│   │   │   │   ├── helper
│   │   │   │   │   ├── helper.cpp
│   │   │   │   │   └── helper.h
│   │   │   │   └── vtable
│   │   │   │       ├── vtable.cpp
│   │   │   │       └── vtable.h
│   │   │   └── walker
│   │   │       ├── iat
│   │   │       │   └── iat_walker.cpp
│   │   │       ├── process_list
│   │   │       │   └── process_walker.cpp
│   │   │       ├── rwx
│   │   │       │   └── rwx.cpp
│   │   │       ├── walker.cpp
│   │   │       └── walker.h
│   │   ├── game
│   │   │   ├── game.cpp
│   │   │   ├── game.h
│   │   │   ├── object_manager
│   │   │   │   ├── object_manager.cpp
│   │   │   │   └── object_manager.h
│   │   │   └── offsets
│   │   │       ├── offsets.cpp
│   │   │       └── offsets.h
│   │   ├── globals
│   │   │   ├── globals.cpp
│   │   │   └── globals.h
│   │   ├── initialize
│   │   │   ├── dllmain.cpp
│   │   │   └── initialize.cpp
│   │   ├── pch.cpp
│   │   └── pch.h
│   └── todo.txt
├── Mandragora.sln
└── README.md

```

`Mandragora.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.7.34009.444
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Mandragora", "Mandragora\Mandragora.vcxproj", "{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Debug|x64.ActiveCfg = Debug|x64
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Debug|x64.Build.0 = Debug|x64
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Debug|x86.ActiveCfg = Debug|Win32
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Debug|x86.Build.0 = Debug|Win32
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Release|x64.ActiveCfg = Release|x64
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Release|x64.Build.0 = Release|x64
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Release|x86.ActiveCfg = Release|Win32
		{C22A449D-8BAE-4EBF-B366-9DD2B0478CA0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {B3DC57FD-8E92-4FF3-A626-D684AB7D64AA}
	EndGlobalSection
EndGlobal

```

`Mandragora/Mandragora.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{c22a449d-8bae-4ebf-b366-9dd2b0478ca0}</ProjectGuid>
    <RootNamespace>Mandragora</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IncludePath>$(ProjectDir);$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IncludePath>$(ProjectDir)src;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;MANDRAGORA_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;MANDRAGORA_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;MANDRAGORA_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;MANDRAGORA_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="src\anticheat\callbacks\callbacks.h" />
    <ClInclude Include="src\anticheat\anticheat.h" />
    <ClInclude Include="src\anticheat\local_player\local_player.h" />
    <ClInclude Include="src\anticheat\walker\walker.h" />
    <ClInclude Include="src\game\game.h" />
    <ClInclude Include="src\globals\globals.h" />
    <ClInclude Include="src\game\object_manager\object_manager.h" />
    <ClInclude Include="src\game\offsets\offsets.h" />
    <ClInclude Include="src\pch.h">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
    </ClInclude>
    <ClInclude Include="src\anticheat\stub\helper\helper.h" />
    <ClInclude Include="src\anticheat\stub\vtable\vtable.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\anticheat\callbacks\callbacks.cpp" />
    <ClCompile Include="src\anticheat\callbacks\virtual_protect\vp_callback.cpp" />
    <ClCompile Include="src\anticheat\walker\rwx\rwx.cpp" />
    <ClCompile Include="src\anticheat\anticheat.cpp" />
    <ClCompile Include="src\anticheat\local_player\local_player.cpp" />
    <ClCompile Include="src\anticheat\walker\iat\iat_walker.cpp" />
    <ClCompile Include="src\anticheat\walker\process_list\process_walker.cpp" />
    <ClCompile Include="src\anticheat\walker\walker.cpp" />
    <ClCompile Include="src\initialize\dllmain.cpp" />
    <ClCompile Include="src\game\game.cpp" />
    <ClCompile Include="src\globals\globals.cpp" />
    <ClCompile Include="src\initialize\initialize.cpp" />
    <ClCompile Include="src\game\object_manager\object_manager.cpp" />
    <ClCompile Include="src\game\offsets\offsets.cpp" />
    <ClCompile Include="src\pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="src\anticheat\stub\helper\helper.cpp" />
    <ClCompile Include="src\anticheat\stub\vtable\vtable.cpp" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="todo.txt" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Mandragora/Mandragora.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="src\pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\globals\globals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\stub\helper\helper.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\game\offsets\offsets.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\game\object_manager\object_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\game\game.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\local_player\local_player.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\anticheat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\stub\vtable\vtable.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\walker\walker.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\anticheat\callbacks\callbacks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\initialize\dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\initialize\initialize.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\globals\globals.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\stub\helper\helper.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\game\offsets\offsets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\game\object_manager\object_manager.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\game\game.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\local_player\local_player.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\anticheat.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\stub\vtable\vtable.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\walker\process_list\process_walker.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\walker\iat\iat_walker.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\walker\rwx\rwx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\callbacks\callbacks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\callbacks\virtual_protect\vp_callback.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\anticheat\walker\walker.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Text Include="todo.txt" />
  </ItemGroup>
</Project>
```

`Mandragora/src/anticheat/anticheat.cpp`:

```cpp
#include "pch.h"
#include "anticheat.h"

```

`Mandragora/src/anticheat/anticheat.h`:

```h
#pragma once

namespace ac
{
}

```

`Mandragora/src/anticheat/callbacks/callbacks.cpp`:

```cpp
#include "pch.h"
#include "callbacks.h"

```

`Mandragora/src/anticheat/callbacks/callbacks.h`:

```h
#pragma once

class callbacks
{
private:
	static bool init_virtual_protect_callback();
public:
	static bool init_callbacks();
};


```

`Mandragora/src/anticheat/callbacks/virtual_protect/vp_callback.cpp`:

```cpp
#include "pch.h"
#include "anticheat/callbacks/callbacks.h"

bool callbacks::init_virtual_protect_callback()
{

}
```

`Mandragora/src/anticheat/local_player/local_player.cpp`:

```cpp
#include "pch.h"
#include "local_player.h"

```

`Mandragora/src/anticheat/local_player/local_player.h`:

```h
#pragma once

namespace ac
{
}


```

`Mandragora/src/anticheat/stub/helper/helper.cpp`:

```cpp
#include "pch.h"
#include "helper.h"

bool helper::is_address_in_our_module(PVOID addr)
{
	const auto module_end = globals::module_base + globals::module_size;
	return (uintptr_t)addr >= globals::module_base && (uintptr_t)addr < module_end;
}

bool helper::is_address_in_game_module(PVOID addr)
{
	const auto nt_hdr = (PIMAGE_NT_HEADERS32)(globals::executable_base + ((PIMAGE_DOS_HEADER)globals::executable_base)->e_lfanew);
	const auto module_size = nt_hdr->OptionalHeader.SizeOfImage;

	const auto module_end = globals::executable_base + module_size;

	return (uintptr_t)addr >= globals::executable_base && (uintptr_t)addr < module_end;
}

bool helper::is_address_within_specified_module(PVOID addr, const char* module_name)
{
	const auto module = (uintptr_t)GetModuleHandleA(module_name);
	if (!module) return false;

	const auto nt_hdr = (PIMAGE_NT_HEADERS32)(module + ((PIMAGE_DOS_HEADER)module)->e_lfanew);
	const auto module_size = nt_hdr->OptionalHeader.SizeOfImage;

	const auto module_end = module + module_size;

	return (uintptr_t)addr >= module && (uintptr_t)addr < module_end;
}

std::vector<MODULEENTRY32> helper::get_all_modules()
{
	std::vector<MODULEENTRY32> modules{};

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
	if (snapshot && snapshot != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 me32;
		me32.dwSize = sizeof(MODULEENTRY32);
		if (Module32First(snapshot, &me32))
		{
			do {
				modules.push_back(me32);
			} while (Module32Next(snapshot, &me32));
		}
		CloseHandle(snapshot);
	}
	return modules;
}
```

`Mandragora/src/anticheat/stub/helper/helper.h`:

```h
#pragma once

namespace helper
{
	bool is_address_in_our_module(PVOID addr);
	bool is_address_in_game_module(PVOID addr);
	bool is_address_within_specified_module(PVOID addr, const char* module_name);
	std::vector<MODULEENTRY32> get_all_modules();
}

```

`Mandragora/src/anticheat/stub/vtable/vtable.cpp`:

```cpp
#include "pch.h"
#include "vtable.h"
#include "anticheat/stub/helper/helper.h"


bool stub::vmt::verify_vtable_pointer(void* instance)
{
	if (instance == nullptr)
	{
		return false;
	}

	uintptr_t* p_vtable = *reinterpret_cast<uintptr_t**>(instance);

	return helper::is_address_in_game_module((PVOID)p_vtable);
}

bool stub::vmt::verify_vtable_integrity(void* instance)
{
	if (instance == nullptr)
	{
		return false;
	}

	uintptr_t* p_vtable = *reinterpret_cast<uintptr_t**>(instance);

	for (uintptr_t* p_func = p_vtable; *p_func != NULL; ++p_func)
	{
		if (!helper::is_address_in_game_module((PVOID)(*p_func)))
		{
			std::cout << "Found invalid vmt func at: 0x" << std::hex << *p_func << std::endl;
			return false;
		}
	}

	return true;
}
```

`Mandragora/src/anticheat/stub/vtable/vtable.h`:

```h
#pragma once

namespace stub
{
	namespace vmt
	{
		bool verify_vtable_pointer(void* instance); // checks for shadow vmt
		bool verify_vtable_integrity(void* instance); // checks function pointers within vtable
	}
}


```

`Mandragora/src/anticheat/walker/iat/iat_walker.cpp`:

```cpp
#include "pch.h"
#include "anticheat/walker/walker.h"
#include "anticheat/stub/helper/helper.h"

bool walker::iat_integrity_check()
{
	LPVOID executable_base = GetModuleHandle(nullptr);
	PIMAGE_DOS_HEADER dos_headers = (PIMAGE_DOS_HEADER)executable_base;
	PIMAGE_NT_HEADERS nt_headers = (PIMAGE_NT_HEADERS)((DWORD_PTR)executable_base + dos_headers->e_lfanew);

	IMAGE_DATA_DIRECTORY imports_directory = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	PIMAGE_IMPORT_DESCRIPTOR import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(imports_directory.VirtualAddress + (DWORD_PTR)executable_base);

	while (import_descriptor->Name != NULL)
	{
		LPCSTR library_name = (LPCSTR)import_descriptor->Name + (DWORD_PTR)executable_base;

		PIMAGE_THUNK_DATA original_first_thunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)executable_base + import_descriptor->OriginalFirstThunk);
		PIMAGE_THUNK_DATA first_thunk = (PIMAGE_THUNK_DATA)((DWORD_PTR)executable_base + import_descriptor->FirstThunk);

		while (original_first_thunk->u1.AddressOfData != NULL)
		{
			PIMAGE_IMPORT_BY_NAME import_by_name = (PIMAGE_IMPORT_BY_NAME)((DWORD_PTR)executable_base + original_first_thunk->u1.AddressOfData);
			PROC* function = (PROC*)&first_thunk->u1.Function;

			if (!helper::is_address_within_specified_module((PVOID)*function, library_name))
			{
				std::cout << "[!] IAT Modification found. Modified function: " << import_by_name->Name << " in module: " << library_name << std::endl;
				return false;
			}

			++original_first_thunk;
			++first_thunk;
		}
	}
	return true;
}
```

`Mandragora/src/anticheat/walker/process_list/process_walker.cpp`:

```cpp
#include "pch.h"
#include "anticheat/walker/walker.h"

bool is_suspicious_process(const std::wstring& process_name)
{
	const std::vector<std::wstring> blacklist = {
		L"cheatengine.exe", L"x32dbg.exe", L"reclass.exe", L"reclassex.exe"
	};

	std::wstring lower_case_name = process_name;
	std::transform(lower_case_name.begin(), lower_case_name.end(), lower_case_name.begin(), ::tolower);

	return std::find(blacklist.begin(), blacklist.end(), lower_case_name) != blacklist.end();
}


bool walker::suspicious_process_scan()
{
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (!snapshot || snapshot == INVALID_HANDLE_VALUE)
		return false;

	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(snapshot, &pe32))
	{
		do {
			if (is_suspicious_process(pe32.szExeFile)) {
				std::cout << "[!] Process detected: " << pe32.szExeFile << std::endl;
				return false;
			}
		} while (Process32Next(snapshot, &pe32));
	}

	CloseHandle(snapshot);

	return true;
}

```

`Mandragora/src/anticheat/walker/rwx/rwx.cpp`:

```cpp
#include "pch.h"
#include "anticheat/walker/walker.h"
#include "anticheat/stub/helper/helper.h"

bool is_address_in_peb(LPCVOID address)
{
	std::vector<MODULEENTRY32> modules = helper::get_all_modules();

	uintptr_t addr = reinterpret_cast<uintptr_t>(address);
	for (const auto& module : modules)
	{
		uintptr_t module_start = reinterpret_cast<uintptr_t>(module.modBaseAddr);
		uintptr_t module_end = module_start + module.modBaseSize;
		if (addr >= module_start && addr < module_end)
			return true;
	}

	return false;
}

bool walker::verify_mem_pages()
{
	SYSTEM_INFO sys_info;
	GetSystemInfo(&sys_info);
	LPCVOID max_addr = sys_info.lpMaximumApplicationAddress;
	LPCVOID address = sys_info.lpMinimumApplicationAddress;

	MEMORY_BASIC_INFORMATION mbi{};
	while (address < max_addr)
	{
		if (VirtualQuery(address, &mbi, sizeof(mbi)) == 0)
			break;

		
		if ((mbi.Protect & PAGE_EXECUTE_READWRITE) || (mbi.Protect & PAGE_EXECUTE_READ))
		{
			if (!is_address_in_peb(mbi.BaseAddress))
			{
				std::cout << "Unmapped memory region found at: " << std::hex << mbi.BaseAddress << std::endl;
				return false;
			}
		}

		address = static_cast<const char*>(mbi.BaseAddress) + mbi.RegionSize;
	}

	return true;
}
```

`Mandragora/src/anticheat/walker/walker.cpp`:

```cpp
#include "pch.h"
#include "walker.h"

void walker::initialize_walker()
{
	// todo: implement flag system
	while (true)
	{
		suspicious_process_scan();
		Sleep(1000);

		verify_mem_pages();
		Sleep(1000);

		iat_integrity_check();
		Sleep(1000);
	}
}
```

`Mandragora/src/anticheat/walker/walker.h`:

```h
#pragma once

class walker
{
private:
	bool suspicious_process_scan();
	bool verify_mem_pages();
	bool iat_integrity_check();
public:
	void initialize_walker();
};
```

`Mandragora/src/game/game.cpp`:

```cpp
#include "pch.h"
#include "game.h"

```

`Mandragora/src/game/game.h`:

```h
#pragma once

namespace game
{
    struct player
    {
        void* vtable;          // 0x0000
        char pad_0x0000[0x34]; // 0x0004
        float x_pos;           // 0x0038
        float y_pos;           // 0x003C
        float z_pos;           // 0x0040
        char pad_0x0044[0x2C]; // 0x0044
        bool is_pos_moving;    // 0x0070
        char pad_0x0071[0xF];  // 0x0071
        WORD speed;            // 0x0080
        char pad_0x0082[0x76]; // 0x0082
        int health;            // 0x00F8
        int armor;             // 0X00FC
        char pad_0x0100[0x28]; // 0x0100
        int ammo_mags;         // 0x0128
        char pad_0x012C[0x24]; // 0x012C
        int ammo;              // 0x0150
        char pad_0x0154[0x4];  // 0x0154
        int flashbangs;        // 0x0158
    };
}

```

`Mandragora/src/game/object_manager/object_manager.cpp`:

```cpp
#include "pch.h"
#include "object_manager.h"

```

`Mandragora/src/game/object_manager/object_manager.h`:

```h
#pragma once
class object_manager
{
};


```

`Mandragora/src/game/offsets/offsets.cpp`:

```cpp
#include "pch.h"
#include "offsets.h"

namespace offsets
{
	size_t p_local_player = 0x10F4F4;

	void initialize_offsets()
	{
		// todo
	}
}

```

`Mandragora/src/game/offsets/offsets.h`:

```h
#pragma once

namespace offsets
{
    void initialize_offsets();

    extern size_t p_local_player;
}

```

`Mandragora/src/globals/globals.cpp`:

```cpp
#include "pch.h"
#include "globals.h"

namespace globals
{
	uintptr_t executable_base;
	uintptr_t module_base;
	uintptr_t module_size;

}

```

`Mandragora/src/globals/globals.h`:

```h
#pragma once

namespace globals
{
	extern uintptr_t executable_base;
	extern uintptr_t module_base;
	extern uintptr_t module_size;

}


```

`Mandragora/src/initialize/dllmain.cpp`:

```cpp
#include "pch.h"

extern void initialize(uintptr_t module_base, size_t module_size);

DWORD WINAPI thread_proc_entry(_In_ LPVOID lpParameter)
{
    initialize(reinterpret_cast<uintptr_t>(lpParameter), 0);
    return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        CreateThread(nullptr, 0, thread_proc_entry, hModule, 0, nullptr);
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


```

`Mandragora/src/initialize/initialize.cpp`:

```cpp
#include "pch.h"

void initialize(uintptr_t module_base, size_t module_size)
{
	globals::executable_base = (uintptr_t)GetModuleHandle(nullptr);
	globals::module_base = module_base;
	globals::module_size = ((PIMAGE_NT_HEADERS32)(module_base + ((PIMAGE_DOS_HEADER)module_base)->e_lfanew))->OptionalHeader.SizeOfImage;

#ifdef _DEBUG
	AllocConsole();
	FILE* f;
	freopen_s(&f, "CONOUT$", "w", stdout);

	std::cout << "Initialized" << std::endl;
	std::cout << "Executable Base: 0x" << std::hex << globals::executable_base << std::endl;
	std::cout << "Module Base: 0x" << std::hex << globals::module_base << std::endl;
	std::cout << "Module Size: " << globals::module_size << std::endl;
#endif

	offsets::initialize_offsets();

	game::player* local_player = reinterpret_cast<game::player*>(*(uintptr_t*)(globals::executable_base + offsets::p_local_player));
}

```

`Mandragora/src/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`Mandragora/src/pch.h`:

```h
#pragma once

#define NOMINMAX

#pragma warning(push, 0)
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <Psapi.h>
#include <DbgHelp.h>
#include <tlhelp32.h>
#include <WinSock2.h>
#include <WS2tcpip.h>
#include <cstdint>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#undef  WIN32_LEAN_AND_MEAN

#ifndef PCH_H
#define PCH_H

#include "globals/globals.h"
#include "game/offsets/offsets.h"
#include "game/game.h"
#endif
```

`Mandragora/todo.txt`:

```txt
TODO:

- add function integrity verification for winapi
- unknown rwx scanner
- local player integrity check (health/etc)
- entity list integrity check (iterate thru do similar scans from above ^)
- opengl integrity check
- upper winapi wrapper callbacks (ex: VirtualProtect)
- implement flag system

maybe:
- thread hijack to force game heartbeat
- light obfuscation/virtualization/packing
- allow for users to enable/disable modules of AC for difficulty change
```

`README.md`:

```md
### THIS PROJECT IS NOT FINISHED IT IS A CURRENT WIP

# Mandragora

Mandragora is an educational anti-cheat operating strictly within usermode/ring-3 context. 

The purpose of this project is to help enable new reverse-engineers or game hackers learn how an anti-cheat might work.

The difficulty of this anti-cheat is purposefully weak. Most new hackers will write a cheat for Assault Cube as their first project, this is designed as a follow-up to see if they can think a bit more creatively about the way they most likely accomplished things.

# Usage

Obviously this anti-cheat is open source, however if you are interested in using this, I highly suggest you download the DLL from releases and AVOID looking at the source unless you get very stuck.

As of now the code has not been obfuscated or virtualized whatsoever meaning it's a great opportunity to practice reversing. 

- Download the DLL from the releases tab
- Open Assault Cube and using any injector or even Process Hacker, inject the dll into the game
- Inject your cheat and good luck! The console will let you know if you've been caught.


----------------
#### Contact
If you're interested in contacting me please message me on discord: "__scary".

```