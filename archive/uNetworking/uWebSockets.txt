Project Path: arc_uNetworking_uWebSockets_jm0h_fc2

Source Tree:

```txt
arc_uNetworking_uWebSockets_jm0h_fc2
├── GNUmakefile
├── LICENSE
├── Makefile
├── README.md
├── autobahn
│   ├── fuzzingclient.json
│   └── server-test.js
├── benchmarks
│   ├── Makefile
│   ├── README.md
│   ├── broadcast_test.c
│   ├── load_test.c
│   ├── parser.cpp
│   └── scale_test.c
├── build.c
├── build.h
├── cluster
│   └── README.md
├── examples
│   ├── Broadcast.cpp
│   ├── BroadcastingEchoServer.cpp
│   ├── CachingApp.cpp
│   ├── Client.cpp
│   ├── Crc32.cpp
│   ├── EchoBody.cpp
│   ├── EchoServer.cpp
│   ├── EchoServerThreaded.cpp
│   ├── HelloWorld.cpp
│   ├── HelloWorldThreaded.cpp
│   ├── Http3Server.cpp
│   ├── HttpServer.cpp
│   ├── ParameterRoutes.cpp
│   ├── Precompress.cpp
│   ├── README.md
│   ├── SecureGzipFileServer.cpp
│   ├── ServerName.cpp
│   ├── SmokeTest.cpp
│   ├── UpgradeAsync.cpp
│   ├── UpgradeSync.cpp
│   └── helpers
│       ├── AsyncFileReader.h
│       ├── AsyncFileStreamer.h
│       ├── Middleware.h
│       └── optparse.h
├── fuzzing
│   ├── AsyncEpollHelloWorld.cpp
│   ├── AsyncEpollHelloWorld.dict
│   ├── EpollEchoServer.cpp
│   ├── EpollEchoServer.dict
│   ├── EpollEchoServerPubSub.cpp
│   ├── EpollEchoServerPubSub.dict
│   ├── EpollHelloWorld.cpp
│   ├── EpollHelloWorld.dict
│   ├── Extensions.cpp
│   ├── Http.cpp
│   ├── Makefile
│   ├── MultipartParser.cpp
│   ├── PerMessageDeflate.cpp
│   ├── QueryParser.cpp
│   ├── QueryParser.dict
│   ├── README.md
│   ├── TopicTree.cpp
│   ├── TopicTree.dict
│   ├── WebSocket.cpp
│   ├── helpers.h
│   ├── libEpollFuzzer
│   └── seed-corpus
├── h1spec
├── libEpollBenchmarker
│   ├── Makefile
│   └── epoll_benchmarker.cpp
├── libdeflate
├── misc
│   ├── READMORE.md
│   ├── bigshot_lineup.png
│   ├── cert.pem
│   ├── fastwebsockets.png
│   ├── fastwebsockets_io_uring.png
│   ├── follow.png
│   ├── key.pem
│   ├── logo.svg
│   └── websocket_lineup.png
├── src
│   ├── App.h
│   ├── AsyncSocket.h
│   ├── AsyncSocketData.h
│   ├── BloomFilter.h
│   ├── CachingApp.h
│   ├── ChunkedEncoding.h
│   ├── ClientApp.h
│   ├── Http3App.h
│   ├── Http3Context.h
│   ├── Http3ContextData.h
│   ├── Http3Request.h
│   ├── Http3Response.h
│   ├── Http3ResponseData.h
│   ├── HttpContext.h
│   ├── HttpContextData.h
│   ├── HttpErrors.h
│   ├── HttpParser.h
│   ├── HttpResponse.h
│   ├── HttpResponseData.h
│   ├── HttpRouter.h
│   ├── LocalCluster.h
│   ├── Loop.h
│   ├── LoopData.h
│   ├── MessageParser.h
│   ├── MoveOnlyFunction.h
│   ├── Multipart.h
│   ├── PerMessageDeflate.h
│   ├── ProxyParser.h
│   ├── QueryParser.h
│   ├── TopicTree.h
│   ├── Utilities.h
│   ├── WebSocket.h
│   ├── WebSocketContext.h
│   ├── WebSocketContextData.h
│   ├── WebSocketData.h
│   ├── WebSocketExtensions.h
│   ├── WebSocketHandshake.h
│   └── WebSocketProtocol.h
├── tests
│   ├── BloomFilter.cpp
│   ├── ChunkedEncoding.cpp
│   ├── ExtensionsNegotiator.cpp
│   ├── HttpParser.cpp
│   ├── HttpRouter.cpp
│   ├── Makefile
│   ├── Query.cpp
│   ├── README.md
│   ├── TopicTree.cpp
│   └── smoke.mjs
└── uSockets

```

`GNUmakefile`:

```
# This is the GNU Make shim for Linux and macOS

DESTDIR ?=
prefix ?= /usr/local

examples: default
	./build examples

clean: default
	./build clean

capi: default
	./build capi

install:
	mkdir -p "$(DESTDIR)$(prefix)/include/uWebSockets"
	cp -r src/* "$(DESTDIR)$(prefix)/include/uWebSockets"

all: default
	./build all

default:
	$(MAKE) -C uSockets
	$(CC) -fopenmp build.c -o build || $(CC) build.c -o build

```

`LICENSE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`Makefile`:

```
# This is the NMake shim for Windows (WIP)
# Example: $Env:WITH_ZLIB='0'; $ENV:WITH_LTO='0'; $Env:CC='clang'; $ENV:CFLAGS='-I C:\vcpkg\installed\x64-windows\include'; $ENV:LDFLAGS='-L C:\vcpkg\installed\x64-windows\lib'; $ENV:CXX='clang++'; $ENV:EXEC_SUFFIX='.exe'; $ENV:WITH_LIBUV='1'; nmake

examples: default
	.\build.exe examples || .\a.exe examples

clean: default
	.\build.exe clean || .\a.exe clean

capi: default
	.\build.exe capi || .\a.exe capi

all: default
	.\build.exe all || .\a.exe all

default:
	cd uSockets
	$(CC) $(CFLAGS) -DLIBUS_NO_SSL -std=c11 -Isrc -O3 -c src/*.c src/eventing/*.c src/crypto/*.c
	cd ..
	$(CC) build.c

```

`README.md`:

```md

<div align="center">
<img src="https://raw.githubusercontent.com/uNetworking/uWebSockets/master/misc/logo.svg" height="180" /><br>
<i>Simple, secure</i><sup><a href="https://github.com/uNetworking/uWebSockets/tree/master/fuzzing#fuzz-testing-of-various-parsers-and-mocked-examples">1</a></sup><i> & standards compliant</i><sup><a href="https://unetworking.github.io/uWebSockets.js/report.pdf">2</a></sup><i> web server for the most demanding</i><sup><a href="https://github.com/uNetworking/uWebSockets/tree/master/benchmarks#benchmark-driven-development">3</a></sup><i> of applications.</i> <a href="https://github.com/uNetworking/uWebSockets/blob/master/misc/READMORE.md">Read more...</a>
<br><br>

<a href="https://github.com/uNetworking/uWebSockets/releases"><img src="https://img.shields.io/github/v/release/uNetworking/uWebSockets"></a> <a href="https://osv.dev/list?q=uwebsockets&affected_only=true&page=1&ecosystem=OSS-Fuzz"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/uwebsockets.svg" /></a> <img src="https://img.shields.io/badge/est.-2016-green" />

</div>
<br><br>

### :closed_lock_with_key: Optimized security
Being meticulously optimized for speed and memory footprint, µWebSockets is fast enough to do encrypted TLS 1.3 messaging quicker than most alternative servers can do even unencrypted, cleartext messaging<sup><a href="https://github.com/uNetworking/uWebSockets/tree/master/benchmarks#benchmark-driven-development">3</a></sup>.

Furthermore, we partake in Google's OSS-Fuzz with a ~95% daily fuzzing coverage<sup><a href="https://github.com/uNetworking/uWebSockets/blob/master/misc/Screenshot_20210915-004009.png?raw=true">4</a></sup> with no sanitizer issues. LGTM scores us flawless A+ from having zero CodeQL alerts and we compile with pedantic warning levels.


### :arrow_forward: Rapid scripting
µWebSockets is written entirely in C & C++ but has a seamless integration for Node.js backends. This allows for rapid scripting of powerful apps, using widespread competence. See <a href="https://github.com/uNetworking/uWebSockets.js">µWebSockets.js</a>.

### :crossed_swords: Battle proven
We've been fully standards compliant with a perfect Autobahn|Testsuite score since 2016<sup><a href="https://unetworking.github.io/uWebSockets.js/report.pdf">2</a></sup>. µWebSockets powers many of the biggest crypto exchanges in the world, handling trade volumes of multiple billions of USD every day. If you trade crypto, chances are you do so via µWebSockets.

### :battery: Batteries included
Designed around a convenient URL router with wildcard & parameter support - paired with efficient pub/sub features for WebSockets. µWebSockets should be the obvious, complete starting point for any real-time web project with high demands.

Start building your Http & WebSocket apps in no time; <a href="https://github.com/uNetworking/uWebSockets/blob/master/misc/READMORE.md">read the user manual</a> and <a href="https://github.com/uNetworking/uWebSockets/tree/master/examples">see examples</a>. You can browse our <a href="https://unetworking.github.io/uWebSockets.js/generated/">TypeDoc</a> for a quick overview.

```c++
/* One app per thread; spawn as many as you have CPU-cores and let uWS share the listening port */
uWS::SSLApp({

    /* These are the most common options, fullchain and key. See uSockets for more options. */
    .cert_file_name = "cert.pem",
    .key_file_name = "key.pem"
    
}).get("/hello/:name", [](auto *res, auto *req) {

    /* You can efficiently stream huge files too */
    res->writeStatus("200 OK")
       ->writeHeader("Content-Type", "text/html; charset=utf-8")
       ->write("<h1>Hello ")
       ->write(req->getParameter("name"))
       ->end("!</h1>");
    
}).ws<UserData>("/*", {

    /* Just a few of the available handlers */
    .open = [](auto *ws) {
        ws->subscribe("oh_interesting_subject");
    },
    .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
        ws->send(message, opCode);
    }
    
}).listen(9001, [](auto *listenSocket) {

    if (listenSocket) {
        std::cout << "Listening on port " << 9001 << std::endl;
    } else {
        std::cout << "Failed to load certs or to bind to port" << std::endl;
    }
    
}).run();
```
### :briefcase: Commercially supported
<a href="https://github.com/uNetworking">uNetworking AB</a> is a Swedish consulting & contracting company dealing with anything related to µWebSockets; development, support and customer success.

Don't hesitate <a href="mailto:alexhultman@gmail.com">sending a mail</a> if you're building something large, in need of advice or having other business inquiries in mind. We'll figure out what's best for both parties and make sure you're not falling into common pitfalls.

Special thanks to BitMEX, Bitfinex, Google, Coinbase, Bitwyre, AppDrag and deepstreamHub for allowing the project itself to thrive on GitHub since 2016 - this project would not be possible without these beautiful companies.

### :wrench: Customizable architecture
µWebSockets builds on <a href="https://github.com/uNetworking/uSockets">µSockets</a>, a foundation library implementing eventing, networking and cryptography in three different layers. Every layer has multiple implementations and you control the compiled composition with flags. There are currently five event-loop integrations; libuv, ASIO, GCD and raw epoll/kqueue.

In a nutshell:

* `WITH_WOLFSSL=1 WITH_LIBUV=1 make examples` builds examples utilizing WolfSSL and libuv
* `WITH_OPENSSL=1 make examples` builds examples utilizing OpenSSL and the native kernel

See µSockets for an up-to-date list of flags and a more detailed explanation.

### :handshake: Permissively licensed
Intellectual property, all rights reserved.

Where such explicit notice is given, source code is licensed Apache License 2.0 which is a permissive OSI-approved license with very few limitations. Modified "forks" should be of nothing but licensed source code, and be made available under another product name. If you're uncertain about any of this, please ask before assuming.

```

`autobahn/fuzzingclient.json`:

```json
{
  "outdir": "./reports/servers",
  "servers": [
    {
      "agent": "uWebSockets",
      "url": "ws://localhost:9001"
    }
  ],
  "cases": [
    "1.*",
    "2.*",
    "3.*",
    "4.*",
    "5.*",
    "6.*",
    "7.*",
    "9.*",
    "10.*",
    "11.*",
    "12.*",
    "13.*"
  ],
  "exclude-cases": [
  ],
  "exclude-agent-cases": {}
}

```

`autobahn/server-test.js`:

```js
// Based on https://github.com/denoland/fastwebsockets/blob/main/autobahn/server-test.js

import { $ } from "https://deno.land/x/dax/mod.ts";

const pwd = new URL(".", import.meta.url).pathname;

const AUTOBAHN_TESTSUITE_DOCKER =
  "crossbario/autobahn-testsuite:0.8.2@sha256:519915fb568b04c9383f70a1c405ae3ff44ab9e35835b085239c258b6fac3074";

const server = $`uWebSockets/EchoServer`.spawn();
await $`docker run --name fuzzingserver	-v ${pwd}/fuzzingclient.json:/fuzzingclient.json:ro	-v ${pwd}/reports:/reports -p 9001:9001	--net=host --rm	${AUTOBAHN_TESTSUITE_DOCKER} wstest -m fuzzingclient -s fuzzingclient.json`.cwd(pwd);

const result = Object.values(JSON.parse(Deno.readTextFileSync("./uWebSockets/autobahn/reports/servers/index.json"))["uWebSockets"]);

function failed(name) {
  return name != "OK" && name != "INFORMATIONAL" && name != "NON-STRICT";
}

console.log(JSON.stringify(result, null, 2));

const failedtests = result.filter((outcome) => failed(outcome.behavior) || failed(outcome.behaviorClose));

console.log(
  `%c${result.length - failedtests.length} / ${result.length} tests OK`,
  `color: ${failedtests.length == 0 ? "green" : "red"}`,
);

Deno.exit(failedtests.length == 0 ? 0 : 1);

```

`benchmarks/Makefile`:

```
default:
	g++ -flto -march=native parser.cpp -O3 -I../uSockets/src -o parser
	clang -flto -O3 -DLIBUS_USE_OPENSSL -I../uSockets/src ../uSockets/src/*.c ../uSockets/src/eventing/*.c ../uSockets/src/crypto/*.c broadcast_test.c load_test.c scale_test.c -c
	clang++ -flto -O3 -DLIBUS_USE_OPENSSL -I../uSockets/src ../uSockets/src/crypto/*.cpp -c -std=c++17
	clang++ -flto -O3 -DLIBUS_USE_OPENSSL `ls *.o | grep -Ev "load_test|scale_test"` -lssl -lcrypto -o broadcast_test
	clang++ -flto -O3 -DLIBUS_USE_OPENSSL `ls *.o | grep -Ev "broadcast_test|scale_test"` -lssl -lcrypto -lz -o load_test
	clang++ -flto -O3 -DLIBUS_USE_OPENSSL `ls *.o | grep -Ev "broadcast_test|load_test"` -lssl -lcrypto -o scale_test


```

`benchmarks/README.md`:

```md
# More recent benchmarks
It was a while ago this page was written (and it needs updating), so here are the most recent benchmarks against the top competition we know of:

v20 | v21
--- | ---
![](../misc/fastwebsockets.png) | ![](../misc/fastwebsockets_io_uring.png)


# Benchmark-driven development
Making decisions based on scientific benchmarking **while** you develop can guide you to create very efficient solutions if you have the dicipline to follow through. µWebSockets performs with **98%** the theoretical maximum for any user space Linux process [this was written before io_uring was added to Linux] - if anything would ever be faster, it would only be so by less than 2%. We know of no such project.

Http | WebSockets
--- | ---
![](../misc/bigshot_lineup.png) | ![](../misc/websocket_lineup.png)

Because of the big lead in cleartext performance, it's actually possible to enable TLS 1.3 encryption in µWebSockets and still beat most of the competition in an unfair cleartext-vs-encrypted run. Performance retention of TLS 1.3 encryption with µWebSockets is about 60%, so you do the math.

All of this is possible thanks to extensive benchmarking of many discarded prototypes & designs during development. The very first thing done in this project was to benchmark the Linux kernel against itself, to get a clear idea of expected maximum performance and thus a performance budget on this platform.

From that point every line of code was benchmarked against the budget and thrown away if it failed the vision. Today µWebSockets does WebSocket messaging without any significant overhead, making it very unlikely to ever be outperformed.

Of course, memory usage has always been a big factor in this. The name µWebSockets is meant to signify "small WebSockets" and comes from the memory optimizations made throughout. Holding many WebSockets should not require lots of RAM.

If you're looking for a performant solution, look no further.

## Common benchmarking mistakes
It is very common, extremely common in fact, that people try and benchmark µWebSockets using a scripted Node.js client such as autocannon, ws, or anything similar. It might seem like an okay method but it really isn't. µWebSockets is 12x faster than Node.js, so trying to stress µWebSockets using Node.js is almost impossible. Maybe if you have a 16-core CPU and dedicate 15 cores to Node.js and 1 core to µWebSockets.

So whatever you do, it is of greatest importance that you actually **do check and make sure that µWebSockets is being stressed to 100% CPU-time** before noting the result. If it isn't, then you're not really benchmarking µWebSockets - you're benchmarking your client, trying to stress µWebSockets! Please don't make this mistake.

## Why "hello world" benchmarking?

Contrary to popular belief, "hello world benchmarks" are the most accurate and realistic gauges of performance for the kind of applications µWebSockets is designed for:

* IO-gaming (latency)
* Signalling (memory overhead)
* Trading (latency)
* Finance (latency)
* Chatting (memory overhead)
* Notifications (memory overhead)

Most business applications of the above mentioned categories are implemented without a central on-disk DB, blocking or severely limiting hot-path performance. As such, web IO becomes a significant part of overall bottleneck, if not the only bottleneck. Message echoing of around 1-16 kB or even as small as 512 bytes is a good test of the overall server plumbing (receive -> timeout clear -> emit to app -> timeout set -> send) for these applications.

Of course, if you build an app that *absolutely must* have an on-disk SQL DB central to all hot-paths, then µWebSockets is not the right tool for your app. Keep in mind that, finding a case where µWebSockets makes no difference, does not mean µWebSockets never makes a difference.

```

`benchmarks/broadcast_test.c`:

```c
/* This benchmark establishes _connections_ number of WebSocket
   clients, then iteratively performs the following:

   1. Send one message for every client.
   2. Wait for the quadratic (_connections_^2) amount of responses from the server.
   3. Once received all expected bytes, repeat by going to step 1.

   Every 4 seconds we print the current average "iterations per second".
   */

#include <libusockets.h>
int SSL;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

unsigned char web_socket_request[26] = {130, 128 | 20, 1, 2, 3, 4};

char request[] = "GET / HTTP/1.1\r\n"
                 "Upgrade: websocket\r\n"
                 "Connection: Upgrade\r\n"
                 "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n"
                 "Host: server.example.com\r\n"
                 "Sec-WebSocket-Version: 13\r\n\r\n";
char *host;
int port;
int connections;

int satisfied_sockets;
int iterations;

struct http_socket {
    /* How far we have streamed our websocket request */
    int offset;

    /* How far we have streamed our upgrade request */
    int upgrade_offset;

    /* Are we upgraded? */
    int is_upgraded;

    /* Bytes received */
    int bytes_received;
};

/* We track upgraded websockets */
void **web_sockets;
int num_web_sockets;

/* We don't need any of these */
void noop(struct us_loop_t *loop) {

}

void start_iteration() {
    for (int i = 0; i < num_web_sockets; i++) {
        struct us_socket_t *s = (struct us_socket_t *) web_sockets[i];
        struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

        http_socket->offset = us_socket_write(SSL, s, (char *) web_socket_request, sizeof(web_socket_request), 0);
    }
}

void next_connection(struct us_socket_t *s) {
    /* Add this connection to our array */
    web_sockets[num_web_sockets++] = s;

    /* We could wait with this until properly upgraded */
    if (--connections) {
        us_socket_context_connect(SSL, us_socket_context(SSL, s), host, port, NULL, 0, sizeof(struct http_socket));
    } else {
        printf("Running benchmark now...\n");
        start_iteration();

        us_socket_timeout(SSL, s, LIBUS_TIMEOUT_GRANULARITY);
    }
}

struct us_socket_t *on_http_socket_writable(struct us_socket_t *s) {
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Are we still not upgraded yet? */
    if (http_socket->upgrade_offset < sizeof(request) - 1) {
        http_socket->upgrade_offset += us_socket_write(SSL, s, request + http_socket->upgrade_offset, sizeof(request) - 1 - http_socket->upgrade_offset, 0);
    } else {
        /* Stream whatever is remaining of the request */
        http_socket->offset += us_socket_write(SSL, s, (char *) web_socket_request + http_socket->offset, sizeof(web_socket_request) - http_socket->offset, 0);
    }

    return s;
}

struct us_socket_t *on_http_socket_close(struct us_socket_t *s, int code, void *reason) {

    printf("Client was disconnected, exiting!\n");
    exit(-1);

    return s;
}

struct us_socket_t *on_http_socket_end(struct us_socket_t *s) {
    return us_socket_close(SSL, s, 0, NULL);
}

struct us_socket_t *on_http_socket_data(struct us_socket_t *s, char *data, int length) {
    /* Get socket extension and the socket's context's extension */
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Are we already upgraded? */
    if (http_socket->is_upgraded) {
        http_socket->bytes_received += length;

        if (http_socket->bytes_received == (sizeof(web_socket_request) - 4) * num_web_sockets) {
            satisfied_sockets++;
            http_socket->bytes_received = 0;

            if (satisfied_sockets == num_web_sockets) {
                iterations++;
                satisfied_sockets = 0;

                start_iteration();
            }
        }
    } else {
        /* We assume the server is not sending anything immediately following upgrade and that we get rnrn in one chunk */
        if (length >= 4 && data[length - 1] == '\n' && data[length - 2] == '\r' && data[length - 3] == '\n' && data[length - 4] == '\r') {
            http_socket->is_upgraded = 1;
            next_connection(s);
        }
    }

    return s;
}

struct us_socket_t *on_http_socket_open(struct us_socket_t *s, int is_client, char *ip, int ip_length) {
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Reset offsets */
    http_socket->offset = 0;
    http_socket->is_upgraded = 0;
    http_socket->bytes_received = 0;

    /* Send an upgrade request */
    http_socket->upgrade_offset = us_socket_write(SSL, s, request, sizeof(request) - 1, 0);

    return s;
}

struct us_socket_t *on_http_socket_timeout(struct us_socket_t *s) {
    /* Print current statistics */
    printf("Iterations/second (%d clients): %f\n", num_web_sockets, ((float)iterations) / LIBUS_TIMEOUT_GRANULARITY);

    iterations = 0;
    us_socket_timeout(SSL, s, LIBUS_TIMEOUT_GRANULARITY);

    return s;
}

int main(int argc, char **argv) {

    /* Parse host and port */
    if (argc != 5) {
        printf("Usage: connections host port ssl\n");
        return 0;
    }

    port = atoi(argv[3]);
    host = malloc(strlen(argv[2]) + 1);
    memcpy(host, argv[2], strlen(argv[2]) + 1);
    connections = atoi(argv[1]);
    SSL = atoi(argv[4]);

    /* Allocate room for every socket */
    web_sockets = (void **) malloc(sizeof(void *) * connections);

    /* Create the event loop */
    struct us_loop_t *loop = us_create_loop(0, noop, noop, noop, 0);

    /* Create a socket context for HTTP */
    struct us_socket_context_options_t options = {};
    struct us_socket_context_t *http_context = us_create_socket_context(SSL, loop, 0, options);

    /* Set up event handlers */
    us_socket_context_on_open(SSL, http_context, on_http_socket_open);
    us_socket_context_on_data(SSL, http_context, on_http_socket_data);
    us_socket_context_on_writable(SSL, http_context, on_http_socket_writable);
    us_socket_context_on_close(SSL, http_context, on_http_socket_close);
    us_socket_context_on_timeout(SSL, http_context, on_http_socket_timeout);
    us_socket_context_on_end(SSL, http_context, on_http_socket_end);

    /* Start making HTTP connections */
    us_socket_context_connect(SSL, http_context, host, port, NULL, 0, sizeof(struct http_socket));

    us_loop_run(loop);
}

```

`benchmarks/load_test.c`:

```c
#define _DEFAULT_SOURCE

#ifdef __APPLE__
#include <libkern/OSByteOrder.h>
#define htobe16(x) OSSwapHostToBigInt16(x)
#define htole16(x) OSSwapHostToLittleInt16(x)
#define be16toh(x) OSSwapBigToHostInt16(x)
#define le16toh(x) OSSwapLittleToHostInt16(x)
#define htobe32(x) OSSwapHostToBigInt32(x)
#define htole32(x) OSSwapHostToLittleInt32(x)
#define be32toh(x) OSSwapBigToHostInt32(x)
#define le32toh(x) OSSwapLittleToHostInt32(x)
#define htobe64(x) OSSwapHostToBigInt64(x)
#define htole64(x) OSSwapHostToLittleInt64(x)
#define be64toh(x) OSSwapBigToHostInt64(x)
#define le64toh(x) OSSwapLittleToHostInt64(x)
#else
#include <endian.h>
#endif

#include <stdint.h>
#include <libusockets.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <zlib.h>
#include <time.h>

/** @brief Structure to hold per-socket state */
typedef struct {
    int offset;            // Bytes sent of the WebSocket request
    int upgrade_offset;    // Bytes sent of the upgrade request
    int is_upgraded;       // Whether the socket has been upgraded to WebSocket
    int outstanding_bytes; // Expected bytes to receive for echo completion
} SocketState;

/** @brief Structure to hold benchmark configuration */
typedef struct {
    char *host;                          // Target server host
    int port;                            // Target server port
    int SSL;                             // Whether to use SSL (0 or 1)
    int deflate;                         // Whether to use compression (0 or 1)
    int payload_size;                    // Size of the payload in bytes
    unsigned char *web_socket_request;   // Precomputed WebSocket request frame
    int web_socket_request_size;         // Size of the request frame
    int web_socket_request_response_size;// Expected response size
    char *upgrade_request;               // HTTP upgrade request string
    int upgrade_request_length;          // Length of the upgrade request
} BenchmarkConfig;

// Static variables for configuration and shared state
static BenchmarkConfig config;
static int connections;  // Number of remaining connections to establish
static int responses = 0;// Number of responses received

// Predefined static data
static char request_deflate[] = "GET / HTTP/1.1\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\nSec-WebSocket-Extensions: permessage-deflate\r\nHost: server.example.com\r\nSec-WebSocket-Version: 13\r\n\r\n";
static char request_text[] = "GET / HTTP/1.1\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\nHost: server.example.com\r\nSec-WebSocket-Version: 13\r\n\r\n";

/**
 * @brief Initializes a text WebSocket request
 * @param size Payload size in bytes
 * @param config Pointer to the BenchmarkConfig to populate
 */
void init_text_request(int size, BenchmarkConfig *config) {
    if (size <= 125) {
        config->web_socket_request_size = size + 6;
        config->web_socket_request = malloc(config->web_socket_request_size);
        config->web_socket_request[0] = 130; // FIN + opcode 1 (text)
        config->web_socket_request[1] = 128 | size; // Mask bit + length
        config->web_socket_request[2] = 1;
        config->web_socket_request[3] = 2;
        config->web_socket_request[4] = 3;
        config->web_socket_request[5] = 4;
        memset(config->web_socket_request + 6, 'T', size);
    } else if (size <= 65535) {
        config->web_socket_request_size = size + 8;
        config->web_socket_request = malloc(config->web_socket_request_size);
        config->web_socket_request[0] = 130;
        config->web_socket_request[1] = 128 | 126;
        uint16_t len = htobe16(size);
        memcpy(&config->web_socket_request[2], &len, 2);
        config->web_socket_request[4] = 1;
        config->web_socket_request[5] = 2;
        config->web_socket_request[6] = 3;
        config->web_socket_request[7] = 4;
        memset(config->web_socket_request + 8, 'T', size);
    } else {
        config->web_socket_request_size = size + 14;
        config->web_socket_request = malloc(config->web_socket_request_size);
        config->web_socket_request[0] = 130;
        config->web_socket_request[1] = 128 | 127;
        uint64_t len = htobe64(size);
        memcpy(&config->web_socket_request[2], &len, 8);
        config->web_socket_request[10] = 1;
        config->web_socket_request[11] = 2;
        config->web_socket_request[12] = 3;
        config->web_socket_request[13] = 4;
        memset(config->web_socket_request + 14, 'T', size);
    }
    config->web_socket_request_response_size = config->web_socket_request_size;
}

/**
 * @brief Initializes a deflated WebSocket request
 * @param size Size of the uncompressed payload in bytes
 * @param config Pointer to the BenchmarkConfig to populate
 */
void init_deflated_request(int size, BenchmarkConfig *config) {
    const char placeholder[] = "{\"userId\":12345,\"action\":\"purchase\",\"items\":[{\"id\":\"A1B2C3\",\"name\":\"Wireless Mouse\",\"price\":25.99,\"quantity\":1},{\"id\":\"D4E5F6\",\"name\":\"Mechanical Keyboard\",\"price\":89.99,\"quantity\":1}],\"payment\":{\"method\":\"credit_card\",\"transactionId\":\"XYZ987654321\",\"status\":\"approved\"},\"timestamp\":\"2025-02-20T15:30:00Z\"};";
    char *json_message = malloc(size);
    int placeholder_len = sizeof(placeholder) - 1;
    printf("Using placeholder of %d bytes\n", placeholder_len);
    for (int i = 0; i < size; i += placeholder_len) {
        int copy_len = (i + placeholder_len <= size) ? placeholder_len : size - i;
        memcpy(json_message + i, placeholder, copy_len);
    }

    z_stream defstream;
    defstream.zalloc = Z_NULL;
    defstream.zfree = Z_NULL;
    defstream.opaque = Z_NULL;
    deflateInit2(&defstream, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -MAX_WBITS, 8, Z_DEFAULT_STRATEGY);
    uLongf compressed_max_size = deflateBound(&defstream, (uLong)size);
    Bytef *compressed_data = malloc(compressed_max_size);

    defstream.avail_in = (uInt)size;
    defstream.next_in = (Bytef *)json_message;
    defstream.avail_out = (uInt)compressed_max_size;
    defstream.next_out = compressed_data;
    int res = deflate(&defstream, Z_SYNC_FLUSH);
    if (res != Z_OK) {
        printf("Deflation failed: %d\n", res);
        exit(1);
    }
    uLongf compressed_size = defstream.total_out - 4;
    deflateEnd(&defstream);
    free(json_message);

    unsigned char mask[4] = {0, 0, 0, 0};
    for (uLongf i = 0; i < compressed_size; i++) {
        compressed_data[i] ^= mask[i % 4];
    }

    unsigned char header[14];
    int header_len;
    if (compressed_size <= 125) {
        header_len = 6;
        header[0] = 0xC2; // FIN + RSV1 + Opcode 2
        header[1] = 0x80 | compressed_size;
        memcpy(header + 2, mask, 4);
    } else if (compressed_size <= 65535) {
        header_len = 8;
        header[0] = 0xC2;
        header[1] = 0x80 | 126;
        header[2] = (compressed_size >> 8) & 0xFF;
        header[3] = compressed_size & 0xFF;
        memcpy(header + 4, mask, 4);
    } else {
        header_len = 14;
        header[0] = 0xC2;
        header[1] = 0x80 | 127;
        for (int i = 0; i < 8; i++) {
            header[2 + i] = (compressed_size >> (56 - i * 8)) & 0xFF;
        }
        memcpy(header + 10, mask, 4);
    }

    config->web_socket_request_size = header_len + compressed_size;
    config->web_socket_request = malloc(config->web_socket_request_size);
    memcpy(config->web_socket_request, header, header_len);
    memcpy(config->web_socket_request + header_len, compressed_data, compressed_size);
    free(compressed_data);

    int server_will_compress = 0;
    if (server_will_compress) {
        config->web_socket_request_response_size = config->web_socket_request_size;
    } else {
        if (size <= 125) {
            config->web_socket_request_response_size = 6 + size;
        } else if (size <= 65535) {
            config->web_socket_request_response_size = 8 + size;
        } else {
            config->web_socket_request_response_size = 14 + size;
        }
    }
}

/**
 * @brief Initiates the next connection or starts the benchmark
 * @param s Current socket
 */
void next_connection(struct us_socket_t *s) {
    if (--connections) {
        us_socket_context_connect(config.SSL, us_socket_context(config.SSL, s), config.host, config.port, NULL, 0, sizeof(SocketState));
    } else {
        printf("Running benchmark now...\n");
        us_socket_timeout(config.SSL, s, LIBUS_TIMEOUT_GRANULARITY);
    }
}

/** @brief Handler for when a socket becomes writable */
struct us_socket_t *on_http_socket_writable(struct us_socket_t *s) {
    SocketState *state = (SocketState *)us_socket_ext(config.SSL, s);
    if (state->upgrade_offset < config.upgrade_request_length) {
        state->upgrade_offset += us_socket_write(config.SSL, s, config.upgrade_request + state->upgrade_offset, config.upgrade_request_length - state->upgrade_offset, 0);
        if (state->upgrade_offset == config.upgrade_request_length) {
            next_connection(s);
        }
    } else {
        state->offset += us_socket_write(config.SSL, s, (char *)config.web_socket_request + state->offset, config.web_socket_request_size - state->offset, 0);
    }
    return s;
}

/** @brief Handler for socket closure */
struct us_socket_t *on_http_socket_close(struct us_socket_t *s, int code, void *reason) {
    printf("Closed!\n");
    return s;
}

/** @brief Handler for socket end */
struct us_socket_t *on_http_socket_end(struct us_socket_t *s) {
    return us_socket_close(config.SSL, s, 0, NULL);
}

/** @brief Handler for incoming data */
struct us_socket_t *on_http_socket_data(struct us_socket_t *s, char *data, int length) {
    SocketState *state = (SocketState *)us_socket_ext(config.SSL, s);
    if (state->is_upgraded) {
        state->outstanding_bytes -= length;
        if (state->outstanding_bytes == 0) {
            state->offset = us_socket_write(config.SSL, s, (char *)config.web_socket_request, config.web_socket_request_size, 0);
            state->outstanding_bytes = config.web_socket_request_response_size - 4;
            responses++;
        } else if (state->outstanding_bytes < 0) {
            printf("ERROR: outstanding bytes negative!\n");
            exit(0);
        }
    } else {
        if (length >= 4 && memcmp(data + length - 4, "\r\n\r\n", 4) == 0) {
            printf("Response: %.*s\n", length, data);
            state->offset = us_socket_write(config.SSL, s, (char *)config.web_socket_request, config.web_socket_request_size, 0);
            state->outstanding_bytes = config.web_socket_request_response_size - 4;
            state->is_upgraded = 1;
        }
    }
    return s;
}

/** @brief Handler for socket opening */
struct us_socket_t *on_http_socket_open(struct us_socket_t *s, int is_client, char *ip, int ip_length) {
    SocketState *state = (SocketState *)us_socket_ext(config.SSL, s);
    state->offset = 0;
    state->is_upgraded = 0;
    state->upgrade_offset = us_socket_write(config.SSL, s, config.upgrade_request, config.upgrade_request_length, 0);
    if (state->upgrade_offset == config.upgrade_request_length) {
        next_connection(s);
    }
    return s;
}

/** @brief Handler for socket timeout */
struct us_socket_t *on_http_socket_timeout(struct us_socket_t *s) {
    printf("Msg/sec: %f\n", ((float)responses) / LIBUS_TIMEOUT_GRANULARITY);
    responses = 0;
    us_socket_timeout(config.SSL, s, LIBUS_TIMEOUT_GRANULARITY);
    return s;
}

// Empty loop callbacks required by libusockets
void on_wakeup(struct us_loop_t *loop) {}
void on_pre(struct us_loop_t *loop) {}
void on_post(struct us_loop_t *loop) {}

/**
 * @brief Main entry point for the WebSocket benchmark
 * @param argc Number of command-line arguments
 * @param argv Array of command-line arguments
 * @return Exit status
 */
int main(int argc, char **argv) {
    if (argc != 6 && argc != 7) {
        printf("Usage: connections host port ssl deflate [payload_size_bytes]\n");
        return 0;
    }

    // Initialize configuration
    config.host = malloc(strlen(argv[2]) + 1);
    memcpy(config.host, argv[2], strlen(argv[2]) + 1);
    config.port = atoi(argv[3]);
    connections = atoi(argv[1]);
    config.SSL = atoi(argv[4]);
    config.deflate = atoi(argv[5]);

    // Set up upgrade request and WebSocket request based on deflate option
    if (config.deflate) {
        config.upgrade_request = request_deflate;
        config.upgrade_request_length = sizeof(request_deflate) - 1;
        config.payload_size = (argc == 7) ? atoi(argv[6]) : 5;
        init_deflated_request(config.payload_size, &config);
        printf("Using message size of %d bytes compressed down to %d bytes\n", config.payload_size, config.web_socket_request_size);
    } else {
        config.upgrade_request = request_text;
        config.upgrade_request_length = sizeof(request_text) - 1;
        if (argc == 7) {
            config.payload_size = atoi(argv[6]);
        } else {
            config.payload_size = 20;
        }
        init_text_request(config.payload_size, &config);
        printf("Using message size of %d bytes\n", config.payload_size);
    }

    // Create and run the event loop
    struct us_loop_t *loop = us_create_loop(0, on_wakeup, on_pre, on_post, 0);
    struct us_socket_context_options_t options = {0};
    struct us_socket_context_t *http_context = us_create_socket_context(config.SSL, loop, 0, options);

    // Register event handlers
    us_socket_context_on_open(config.SSL, http_context, on_http_socket_open);
    us_socket_context_on_data(config.SSL, http_context, on_http_socket_data);
    us_socket_context_on_writable(config.SSL, http_context, on_http_socket_writable);
    us_socket_context_on_close(config.SSL, http_context, on_http_socket_close);
    us_socket_context_on_timeout(config.SSL, http_context, on_http_socket_timeout);
    us_socket_context_on_end(config.SSL, http_context, on_http_socket_end);

    // Start the first connection
    us_socket_context_connect(config.SSL, http_context, config.host, config.port, NULL, 0, sizeof(SocketState));
    us_loop_run(loop);

    // Cleanup
    free(config.host);
    free(config.web_socket_request);
    us_socket_context_free(config.SSL, http_context);
    us_loop_free(loop);

    return 0;
}

```

`benchmarks/parser.cpp`:

```cpp
/* This is a fuzz test of the websocket parser */

#define WIN32_EXPORT

/* We test the websocket parser */
#include "../src/WebSocketProtocol.h"

unsigned int messages = 0;

struct Impl {
    static bool refusePayloadLength(uint64_t length, uWS::WebSocketState<true> *wState, void *s) {

        /* We need a limit */
        if (length > 16000) {
            return true;
        }

        /* Return ok */
        return false;
    }

    static bool setCompressed(uWS::WebSocketState<true> *wState, void *s) {
        /* We support it */
        return true;
    }

    static void forceClose(uWS::WebSocketState<true> *wState, void *s, std::string_view reason = {}) {

    }

    static bool handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, uWS::WebSocketState<true> *webSocketState, void *s) {

        if (opCode == uWS::TEXT) {
            if (!uWS::protocol::isValidUtf8((unsigned char *)data, length)) {
                /* Return break */
                return true;
            }
        } else if (opCode == uWS::CLOSE) {
            uWS::protocol::parseClosePayload((char *)data, length);
        }

        messages += 1;

        /* Return ok */
        return false;
    }
};

#include <iostream>

int web_socket_request_text_size;
char *web_socket_request_text;

void init_medium_message(unsigned int size) {
    if (size > 65536) {
        printf("Error: message size must be smaller\n");
        exit(0);
    }

    web_socket_request_text_size = size + 6 + 2; // 8 for big

    web_socket_request_text = ((char *) malloc(32 + web_socket_request_text_size + 32)) + 32;
    memset(web_socket_request_text, 'T', web_socket_request_text_size + 32);
    web_socket_request_text[0] = 130;
    web_socket_request_text[1] = 254;
    uint16_t msg_size = htobe16(size);
    memcpy(&web_socket_request_text[2], &msg_size, 2);
    web_socket_request_text[4] = 1;
    web_socket_request_text[5] = 2;
    web_socket_request_text[6] = 3;
    web_socket_request_text[7] = 4;
}

int main() {

    init_medium_message(1024);

    /* Create the parser state */
    uWS::WebSocketState<true> state;

    unsigned char pre[32];
    unsigned char web_socket_request_text_small[26] = {130, 128 | 20, 1, 2, 3, 4};
    unsigned char post[32];

    uint16_t msg_size = htobe16(1024);

    {
        clock_t start = clock();

        for (unsigned long long i = 0; i < 100000000; i++) {
            
            web_socket_request_text[0] = 130;
            web_socket_request_text[1] = 254;
            memcpy(&web_socket_request_text[2], &msg_size, 2);
            web_socket_request_text[4] = 1;
            web_socket_request_text[5] = 2;
            web_socket_request_text[6] = 3;
            web_socket_request_text[7] = 4;

            // here we can either consume the whole message or consume the whole message minus 1 byte, causing a different path to be taken
            uWS::WebSocketProtocol<true, Impl>::consume((char *) web_socket_request_text, web_socket_request_text_size-1, &state, nullptr);
        }

        clock_t stop = clock();
        float seconds = ((float)(stop-start)/CLOCKS_PER_SEC);

        std::cout << std::fixed << "Parsed incomplete 1 kB messages per second: " << ((float)messages / seconds) << std::endl;
    }

    {
        messages = 0;
        clock_t start = clock();

        for (unsigned long long i = 0; i < 100000000; i++) {
            
            web_socket_request_text[0] = 130;
            web_socket_request_text[1] = 254;
            memcpy(&web_socket_request_text[2], &msg_size, 2);
            web_socket_request_text[4] = 1;
            web_socket_request_text[5] = 2;
            web_socket_request_text[6] = 3;
            web_socket_request_text[7] = 4;

            // here we can either consume the whole message or consume the whole message minus 1 byte, causing a different path to be taken
            uWS::WebSocketProtocol<true, Impl>::consume((char *) web_socket_request_text, web_socket_request_text_size, &state, nullptr);
        }

        clock_t stop = clock();
        float seconds = ((float)(stop-start)/CLOCKS_PER_SEC);

        std::cout << std::fixed << "Parsed complete 1 kB messages per second: " << ((float)messages / seconds) << std::endl;
    }

    return 0;
}


```

`benchmarks/scale_test.c`:

```c
/* This is a scalability test for testing million(s) of pinging connections */

#include <libusockets.h>
int SSL;

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>

unsigned char web_socket_request[26] = {130, 128 | 20, 1, 2, 3, 4};

char request[] = "GET / HTTP/1.1\r\n"
                 "Upgrade: websocket\r\n"
                 "Connection: Upgrade\r\n"
                 "Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n"
                 "Host: server.example.com\r\n"
                 "Sec-WebSocket-Version: 13\r\n\r\n";
char *host;
int port;
int connections;

/* All the ips we as client can use */
char **ips;
int num_ips;

/* Send ping every 16 seconds */
int WEBSOCKET_PING_INTERVAL = 8;

/* We only establish 20k connections per address */
int CONNECTIONS_PER_ADDRESS = 20000;

/* How many connections a time */
int BATCH_CONNECT = 1;

/* Currently open and alive connections */
int opened_connections;
/* Dead connections */
int closed_connections;

struct http_socket {
    /* How far we have streamed our websocket request */
    int offset;

    /* How far we have streamed our upgrade request */
    int upgrade_offset;
};

struct us_socket_t *next_connection_failed = 0;

/* We don't need any of these */
void on_pre(struct us_loop_t *loop) {

}

/* This is not HTTP POST, it is merely an event emitted post loop iteration */
void on_post(struct us_loop_t *loop) {

}

void next_connection(struct us_socket_t *s) {
    /* We could wait with this until properly upgraded */
    if (--connections/* > BATCH_CONNECT*/) {
        /* Swap address */
        int address = opened_connections / CONNECTIONS_PER_ADDRESS;

        if (us_socket_context_connect(SSL, us_socket_context(SSL, s), host, port, ips[address], 0, sizeof(struct http_socket)) == 0) {
            printf("Next connection failed immediately\n");

            /* Try agsin next event loop iteration */
            next_connection_failed = s;
            us_wakeup_loop(us_socket_context_loop(0, us_socket_context(0, s)));

        }
    }
}

void on_wakeup(struct us_loop_t *loop) {
    if (next_connection_failed) {
        struct us_socket_t *s = next_connection_failed;
        next_connection_failed = 0;
        next_connection(s);
    }
}

struct us_socket_t *on_http_socket_writable(struct us_socket_t *s) {
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Are we still not upgraded yet? */
    if (http_socket->upgrade_offset < sizeof(request) - 1) {
        http_socket->upgrade_offset += us_socket_write(SSL, s, request + http_socket->upgrade_offset, sizeof(request) - 1 - http_socket->upgrade_offset, 0);

        /* Now we should be */
        if (http_socket->upgrade_offset == sizeof(request) - 1) {
            next_connection(s);

            /* Make sure to send ping */
            us_socket_timeout(SSL, s, WEBSOCKET_PING_INTERVAL);
        }
    } else {
        /* Stream whatever is remaining of the request */
        http_socket->offset += us_socket_write(SSL, s, (char *) web_socket_request + http_socket->offset, sizeof(web_socket_request) - http_socket->offset, 0);
        if (http_socket->offset == sizeof(web_socket_request)) {
            /* Reset timeout if we managed to */
            us_socket_timeout(SSL, s, WEBSOCKET_PING_INTERVAL);
        }
    }

    return s;
}

struct us_socket_t *on_http_socket_close(struct us_socket_t *s, int code, void *reason) {

    closed_connections++;
    if (closed_connections % 1000 == 0) {
        printf("Alive: %d, dead: %d\n", opened_connections, closed_connections);
    }

    return s;
}

struct us_socket_t *on_http_socket_end(struct us_socket_t *s) {
    return us_socket_close(SSL, s, 0, NULL);
}

// should never get a response!
struct us_socket_t *on_http_socket_data(struct us_socket_t *s, char *data, int length) {

    // is this a broadcasted unix time in millis?
    if (length % 10 == 0) {

        // data sent first will come first, so it is oldest

        struct timespec ts;
        timespec_get(&ts, TIME_UTC);

        int64_t millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;


        int64_t received_millis;
        memcpy(&received_millis, data + 2, 8);

        static int counter;
        static int max_latency;
        static long average_latency;

        int latency = millis - received_millis;

        average_latency += latency;

        if (max_latency < latency) {
            max_latency = latency;
        }

        if (++counter % 10000 == 0) {
            printf("Alive: %d, dead: %d\n", opened_connections, closed_connections);
            printf("Max latency: %d ms\n", max_latency);
            printf("Average latency: %ld ms\n\n", average_latency / 10000);
            max_latency = 0;
            average_latency = 0;
        }



    }



    return s;
}

struct us_socket_t *on_http_socket_open(struct us_socket_t *s, int is_client, char *ip, int ip_length) {
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Display number of opened connections */
    opened_connections++;
    if (opened_connections % 1000 == 0) {
        printf("Alive: %d, dead: %d\n", opened_connections, closed_connections);
    }

    /* Send an upgrade request */
    http_socket->upgrade_offset = us_socket_write(SSL, s, request, sizeof(request) - 1, 0);
    if (http_socket->upgrade_offset == sizeof(request) - 1) {
        next_connection(s);

        /* Make sure to send ping */
        us_socket_timeout(SSL, s, WEBSOCKET_PING_INTERVAL);
    }

    return s;
}

// here we should send a message as ping (part of the test)
struct us_socket_t *on_http_socket_timeout(struct us_socket_t *s) {
    struct http_socket *http_socket = (struct http_socket *) us_socket_ext(SSL, s);

    /* Send ping here */
    http_socket->offset = us_socket_write(SSL, s, (char *) web_socket_request, sizeof(web_socket_request), 0);
    if (http_socket->offset == sizeof(web_socket_request)) {
        /* Reset timeout if we managed to */
        us_socket_timeout(SSL, s, WEBSOCKET_PING_INTERVAL);
    }

    return s;
}

struct us_socket_t *on_http_socket_connect_error(struct us_socket_t *s, int code) {

    printf("Connection failed\n");

    next_connection(s);

    return s;
}

int main(int argc, char **argv) {

    /* Parse host and port */
    if (argc < 5) {
        printf("Usage: connections host port ssl [ip ...]\n");
        return 0;
    }

    port = atoi(argv[3]);
    host = malloc(strlen(argv[2]) + 1);
    memcpy(host, argv[2], strlen(argv[2]) + 1);
    connections = atoi(argv[1]);
    SSL = atoi(argv[4]);

    /* Do we have ip addresses? */
    if (argc > 5) {
        ips = &argv[5];
        num_ips = argc - 5;

        for (int i = 0; i < num_ips; i++) {
            printf("%s\n", ips[i]);
        }
    } else {
        static char *default_ips[] = {""};
        ips = default_ips;
        num_ips = 1;
    }

    /* Check so that we have enough ip addresses */
    if (num_ips <= connections / CONNECTIONS_PER_ADDRESS) {
        printf("You'll need more IP addresses for this run\n");
        return 0;
    }

    /* Create the event loop */
    struct us_loop_t *loop = us_create_loop(0, on_wakeup, on_pre, on_post, 0);

    /* Create a socket context for HTTP */
    struct us_socket_context_options_t options = {};
    struct us_socket_context_t *http_context = us_create_socket_context(SSL, loop, 0, options);

    /* Set up event handlers */
    us_socket_context_on_open(SSL, http_context, on_http_socket_open);
    us_socket_context_on_data(SSL, http_context, on_http_socket_data);
    us_socket_context_on_writable(SSL, http_context, on_http_socket_writable);
    us_socket_context_on_close(SSL, http_context, on_http_socket_close);
    us_socket_context_on_timeout(SSL, http_context, on_http_socket_timeout);
    us_socket_context_on_end(SSL, http_context, on_http_socket_end);
    us_socket_context_on_connect_error(SSL, http_context, on_http_socket_connect_error);

    /* Start making HTTP connections */
    for (int i = 0; i < BATCH_CONNECT; i++) {
        if (us_socket_context_connect(SSL, http_context, host, port, ips[0], 0, sizeof(struct http_socket)) == 0) {
            printf("Connection failed immediately\n");
            return 0;
        }
    }

    us_loop_run(loop);
}

```

`build.c`:

```c
#include "build.h"

int main(int argc, char **argv) {
    /* Some variables we need */
    char *CXXFLAGS = strncpy(calloc(1024, 1), maybe(getenv("CXXFLAGS")), 1024);
    char *CFLAGS = strncpy(calloc(1024, 1), maybe(getenv("CFLAGS")), 1024);
    char *LDFLAGS = strncpy(calloc(1024, 1), maybe(getenv("LDFLAGS")), 1024);
    char *CC = strncpy(calloc(1024, 1), or_else(getenv("CC"), "cc"), 1024);
    char *CXX = strncpy(calloc(1024, 1), or_else(getenv("CXX"), "g++"), 1024);
    char *EXEC_SUFFIX = strncpy(calloc(1024, 1), maybe(getenv("EXEC_SUFFIX")), 1024);

    char *EXAMPLE_FILES[] = {"SecureGzipFileServer", "Precompress", "EchoBody", "HelloWorldThreaded", "Http3Server", "Broadcast", "HelloWorld", "Crc32", "ServerName",
    "EchoServer", "BroadcastingEchoServer", "UpgradeSync", "UpgradeAsync", "ParameterRoutes"};

    strcat(CXXFLAGS, " -march=native -O3 -Wpedantic -Wall -Wextra -Wsign-conversion -Wconversion -std=c++2b -Isrc -IuSockets/src");
    strcat(LDFLAGS, " uSockets/*.o");

    // We can use libdeflate as a fast path to zlib (you need to build it first)
    if (env_is("WITH_LIBDEFLATE", "1")) {
        strcat(LDFLAGS, " libdeflate/libdeflate.a");
        strcat(CXXFLAGS, " -DUWS_USE_LIBDEFLATE -I libdeflate");
    }

    // By default we use LTO, but Windows does not support it
    if (!env_is("WITH_LTO", "0")) {
        strcat(CXXFLAGS, " -flto=auto");
    }

    // By default we use zlib but you can build without it (disables permessage-deflate)
    if (!env_is("WITH_ZLIB", "0")) {
        strcat(LDFLAGS, " -lz");
    } else {
        strcat(CXXFLAGS, " -DUWS_NO_ZLIB");
    }

    // WITH_PROXY enables PROXY Protocol v2 support
    if (env_is("WITH_PROXY", "1")) {
        strcat(CXXFLAGS, " -DUWS_WITH_PROXY");
    }

    // WITH_QUIC enables experimental Http3 examples
    if (env_is("WITH_QUIC", "1")) {
        strcat(CXXFLAGS, " -DLIBUS_USE_QUIC");
        strcat(LDFLAGS, " -pthread -lz -lm uSockets/lsquic/src/liblsquic/liblsquic.a");
    }

    // Heavily prefer boringssl over openssl
    if (env_is("WITH_BORINGSSL", "1")) {
        strcat(CFLAGS, " -I uSockets/boringssl/include -pthread -DLIBUS_USE_OPENSSL");
        strcat(LDFLAGS, " -pthread uSockets/boringssl/build/ssl/libssl.a uSockets/boringssl/build/crypto/libcrypto.a");
    } else {
        // WITH_OPENSSL=1 enables OpenSSL 1.1+ support
        if (env_is("WITH_OPENSSL", "1")) {
            // With problems on macOS, make sure to pass needed LDFLAGS required to find these
            strcat(LDFLAGS, " -lssl -lcrypto");
        } else {
            // WITH_WOLFSSL=1 enables WolfSSL 4.2.0 support (mutually exclusive with OpenSSL)
            if (env_is("WITH_WOLFSSL", "1")) {
                strcat(LDFLAGS, " -L/usr/local/lib -lwolfssl");
            }
        }
    }

    // WITH_LIBUV=1 builds with libuv as event-loop
    if (env_is("WITH_LIBUV", "1")) {
        strcat(LDFLAGS, " -luv");
    }

    // WITH_ASIO=1 builds with ASIO as event-loop
    if (env_is("WITH_ASIO", "1")) {
        strcat(CXXFLAGS, " -pthread");
        strcat(LDFLAGS, " -lpthread");
    }

    // WITH_ASAN builds with sanitizers
    if (env_is("WITH_ASAN", "1")) {
        strcat(CXXFLAGS, " -fsanitize=address -g");
        strcat(LDFLAGS, " -lasan");
    }

    if (!strcmp(argv[1], "examples")) {
        #pragma omp parallel for
        for (int i = 0; i < sizeof(EXAMPLE_FILES) / sizeof(char *); i++) {
            if (run("%s %s examples/%s.cpp %s -o %s%s", CXX, CXXFLAGS, EXAMPLE_FILES[i], LDFLAGS, EXAMPLE_FILES[i], EXEC_SUFFIX)) {
                exit(-1);
            }
        }
    } else if (!strcmp(argv[1], "capi")) {
        printf("capi target does nothing yet\n");
    } else if (!strcmp(argv[1], "clean")) {
        printf("clean target does nothing yet\n");
    } else if (!strcmp(argv[1], "install")) {
        // install target is not even supposed to be cross platform
        printf("install target does nothing yet\n");
    } else if (!strcmp(argv[1], "all")) {
        printf("all target does nothing yet\n");
    }
}

```

`build.h`:

```h
#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

int env_is(char *env, char *target) {
    char *val = getenv(env);
    return val && !strcmp(val, target);
}

char *maybe(char *in) {
    return in ? in : "";
}

char *or_else(char *in, char *otherwise) {
    return in ? in : otherwise;
}

int run(const char *cmd, ...) {
    char buf[2048];
    va_list args;
    va_start(args, cmd);
    vsprintf(buf, cmd, args);
    va_end(args);
    printf("--> %s\n\n", buf);
    return system(buf);
}

```

`cluster/README.md`:

```md
# uWS Cluster

```

`examples/Broadcast.cpp`:

```cpp
/* We simply call the root header file "App.h", giving you uWS::App and uWS::SSLApp */
#include "App.h"
#include <time.h>
#include <iostream>

/* This is a simple WebSocket echo server example.
 * You may compile it with "WITH_OPENSSL=1 make" or with "make" */

uWS::SSLApp *globalApp;

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::SSLApp app = uWS::SSLApp({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    }).ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::SHARED_COMPRESSOR,
        .maxPayloadLength = 16 * 1024 * 1024,
        .idleTimeout = 16,
        .maxBackpressure = 1 * 1024 * 1024,
        .closeOnBackpressureLimit = false,
        .resetIdleTimeoutOnSend = false,
        .sendPingsAutomatically = true,
        /* Handlers */
        .upgrade = nullptr,
        .open = [](auto *ws) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */
            ws->subscribe("broadcast");
        },
        .message = [](auto */*ws*/, std::string_view /*message*/, uWS::OpCode /*opCode*/) {

        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
        },
        .ping = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .pong = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here */
        }
    }).listen(9001, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 9001 << std::endl;
        }
    });

    struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();
    struct us_timer_t *delayTimer = us_create_timer(loop, 0, 0);

    // broadcast the unix time as millis every 8 millis
    us_timer_set(delayTimer, [](struct us_timer_t */*t*/) {

        struct timespec ts;
        timespec_get(&ts, TIME_UTC);

        int64_t millis = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;

        //std::cout << "Broadcasting timestamp: " << millis << std::endl;

        globalApp->publish("broadcast", std::string_view((char *) &millis, sizeof(millis)), uWS::OpCode::BINARY, false);

    }, 8, 8);

    globalApp = &app;

    app.run();
}

```

`examples/BroadcastingEchoServer.cpp`:

```cpp
#include "App.h"

struct us_listen_socket_t *global_listen_socket;

int main() {

    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
        std::vector<std::string> topics;
        int nr = 0;
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::SSLApp *app = new uWS::SSLApp({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    });
    
    app->ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::DISABLED,
        .maxPayloadLength = 16 * 1024 * 1024,
        .idleTimeout = 60,
        .maxBackpressure = 16 * 1024 * 1024,
        .closeOnBackpressureLimit = false,
        .resetIdleTimeoutOnSend = true,
        .sendPingsAutomatically = false,
        /* Handlers */
        .upgrade = nullptr,
        .open = [](auto *ws) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */

            PerSocketData *perSocketData = (PerSocketData *) ws->getUserData();

            for (int i = 0; i < 32; i++) {
                std::string topic = std::to_string((uintptr_t)ws) + "-" + std::to_string(i);
                perSocketData->topics.push_back(topic);
                ws->subscribe(topic);
            }
        },
        .message = [&app](auto *ws, std::string_view message, uWS::OpCode opCode) {
            PerSocketData *perSocketData = (PerSocketData *) ws->getUserData();

            app->publish(perSocketData->topics[(size_t)(++perSocketData->nr % 32)], message, opCode);
            ws->publish(perSocketData->topics[(size_t)(++perSocketData->nr % 32)], message, opCode);
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
            //std::cout << "drain" << std::endl;
        },
        .ping = [](auto */*ws*/, std::string_view ) {
            /* Not implemented yet */
        },
        .pong = [](auto */*ws*/, std::string_view ) {
            /* Not implemented yet */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here */
        }
    }).listen(9001, [](auto *listen_s) {
        if (listen_s) {
            std::cout << "Listening on port " << 9001 << std::endl;
            //listen_socket = listen_s;
        }
    });
    
    app->run();

    delete app;

    uWS::Loop::get()->free();
}

```

`examples/CachingApp.cpp`:

```cpp
#include "App.h"
#include <iostream>

int main() {
    uWS::App app;

    /* Regular, non-cached response */
    app.get("/not-cached", [](auto *res, auto */*req*/) {
        res->end("Responding without a cache");
    }).get("/*", [](auto *res, auto */*req*/) {
        /* A cached response with 5 seconds of lifetime */
        std::cout << "Filling cache now" << std::endl;
        res->end("This is a response");
    }, 5).listen(8080, [](bool success) {
        if (success) {
            std::cout << "Listening on port 8080" << std::endl;
        } else {
            std::cerr << "Failed to listen on port 8080" << std::endl;
        }
    });

    app.run();
}

```

`examples/Client.cpp`:

```cpp
// This example is broken and doesn't do anything. It is a potential interface for a future potential client.
// There is no client support implemented in the library. This example is a placeholder.

#include "ClientApp.h"
#include <iostream>

int main() {
    uWS::ClientApp app({
        .open = [](/*auto *ws*/) {
            std::cout << "Hello and welcome to client" << std::endl;
        },
        .message = [](/*auto *ws, auto message*/) {

        },
        .close = [](/*auto *ws*/) {
            std::cout << "bye" << std::endl;
        }
    });
    
    app.connect("ws://localhost:3000", "protocol");
    
    app.run();
}

```

`examples/Crc32.cpp`:

```cpp
#include "App.h"

/* This is a good example for testing and showing the POST requests.
 * Anything you post (either with content-length or using transfer-encoding: chunked) will
 * be hashed with crc32 and sent back in the response. This example also shows how to deal with
 * aborted requests. */

/* curl -H "Transfer-Encoding: chunked" --data-binary @video.mp4 http://localhost:3000 */
/* curl --data-binary @video.mp4 http://localhost:3000 */
/* crc32 video.mp4 */

/* Note that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support */

#include <sstream>
#include <cstdint>
#include <cstddef>

uint32_t crc32(const char *s, size_t n, uint32_t crc = 0xFFFFFFFF) {

    for (size_t i = 0; i < n; i++) {
        unsigned char ch = static_cast<unsigned char>(s[i]);
        for (size_t j = 0; j < 8; j++) {
            uint32_t b = (ch ^ crc) & 1;
            crc >>= 1;
            if (b) crc = crc ^ 0xEDB88320;
            ch >>= 1;
        }
    }

    return crc;
}

int main() {

    uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).post("/*", [](auto *res, auto *req) {

        /* Display the headers */
        std::cout << " --- " << req->getUrl() << " --- " << std::endl;
        for (auto [key, value] : *req) {
            std::cout << key << ": " << value << std::endl;
        }

        auto isAborted = std::make_shared<bool>(false);
        uint32_t crc = 0xFFFFFFFF;
        res->onData([res, isAborted, crc](std::string_view chunk, bool isFin) mutable {
            if (chunk.length()) {
                crc = crc32(chunk.data(), chunk.length(), crc);
            }

            if (isFin && !*isAborted) {
                std::stringstream s;
                s << std::hex << (~crc) << std::endl;
                res->end(s.str());
            }
        });

        res->onAborted([isAborted]() {
            *isAborted = true;
        });
    }).listen(3000, [](auto *listen_socket) {
        if (listen_socket) {
            std::cerr << "Listening on port " << 3000 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 3000" << std::endl;
}

```

`examples/EchoBody.cpp`:

```cpp
#include "App.h"

/* Takes any method and echoes back the sent body. Can be used to test compliance of HTTP spec. */
/* This example is also a good benchmark for body echoing. */

int main() {

    uWS::App().get("/*", [](auto *res, auto */*req*/) {
        /* Technically the any route could be used likewise, but GET is optimized like this */
        res->end();
    }).any("/*", [](auto *res, auto */*req*/) {
        std::unique_ptr<std::string> buffer;
        res->onData([res, buffer = std::move(buffer)](std::string_view chunk, bool isFin) mutable {
            if (isFin) [[likely]] {
                if (buffer.get()) [[unlikely]] {
                    buffer->append(chunk);
                    res->end(*buffer);
                } else {
                    res->end(chunk);
                }
            } else {
                if (!buffer.get()) {
                    buffer = std::make_unique<std::string>(chunk);
                } else {
                    buffer->append(chunk);
                }
            }
        });

        /* In this particular case we actually don't need to know this, as we only rely on RAII above. */
        res->onAborted([]() {});
    }).listen(3000, [](auto *listen_socket) {
        if (listen_socket) {
            std::cerr << "Listening on port " << 3000 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 3000" << std::endl;
}

```

`examples/EchoServer.cpp`:

```cpp
/* We simply call the root header file "App.h", giving you uWS::App and uWS::SSLApp */
#include "App.h"

/* This is a simple WebSocket echo server example.
 * You may compile it with "WITH_OPENSSL=1 make" or with "make" */

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::App({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    }).ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::CompressOptions(uWS::DEDICATED_COMPRESSOR | uWS::DEDICATED_DECOMPRESSOR),
        .maxPayloadLength = 100 * 1024 * 1024,
        .idleTimeout = 16,
        .maxBackpressure = 100 * 1024 * 1024,
        .closeOnBackpressureLimit = false,
        .resetIdleTimeoutOnSend = false,
        .sendPingsAutomatically = true,
        /* Handlers */
        .upgrade = nullptr,
        .open = [](auto */*ws*/) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */

        },
        .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
            /* This is the opposite of what you probably want; compress if message is LARGER than 16 kb
             * the reason we do the opposite here; compress if SMALLER than 16 kb is to allow for 
             * benchmarking of large message sending without compression */

             /* Never mind, it changed back to never compressing for now */
            ws->send(message, opCode, false);
        },
        .dropped = [](auto */*ws*/, std::string_view /*message*/, uWS::OpCode /*opCode*/) {
            /* A message was dropped due to set maxBackpressure and closeOnBackpressureLimit limit */
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
        },
        .ping = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .pong = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here */
        }
    }).listen(9001, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 9001 << std::endl;
        }
    }).run();
}

```

`examples/EchoServerThreaded.cpp`:

```cpp
#include "App.h"
#include <thread>
#include <algorithm>

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {

    };

    /* Simple echo websocket server, using multiple threads */
    std::vector<std::thread *> threads(std::thread::hardware_concurrency());

    std::transform(threads.begin(), threads.end(), threads.begin(), [](std::thread */*t*/) {
        return new std::thread([]() {

            /* Very simple WebSocket echo server */
            uWS::App().ws<PerSocketData>("/*", {
                /* Settings */
                .compression = uWS::SHARED_COMPRESSOR,
                .maxPayloadLength = 16 * 1024,
                .idleTimeout = 10,
                .maxBackpressure = 1 * 1024 * 1024,
                /* Handlers */
                .upgrade = nullptr,
                .open = [](auto */*ws*/) {

                },
                .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
                    ws->send(message, opCode);
                },
                .drain = [](auto */*ws*/) {
                    /* Check getBufferedAmount here */
                },
                .ping = [](auto */*ws*/, std::string_view) {

                },
                .pong = [](auto */*ws*/, std::string_view) {

                },
                .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {

                }
            }).listen(9001, [](auto *listen_socket) {
                if (listen_socket) {
                    std::cout << "Thread " << std::this_thread::get_id() << " listening on port " << 9001 << std::endl;
                } else {
                    std::cout << "Thread " << std::this_thread::get_id() << " failed to listen on port 9001" << std::endl;
                }
            }).run();

        });
    });

    std::for_each(threads.begin(), threads.end(), [](std::thread *t) {
        t->join();
    });
}

```

`examples/HelloWorld.cpp`:

```cpp
#include "App.h"

/* Note that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support */

int main() {
    /* Overly simple hello world app */
    uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).get("/*", [](auto *res, auto */*req*/) {
        res->end("Hello world!");
    }).listen(3000, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 3000 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 3000" << std::endl;
}

```

`examples/HelloWorldThreaded.cpp`:

```cpp
#include "App.h"
#include "LocalCluster.h"

int main() {
    /* Note that SSL is disabled unless you build with WITH_OPENSSL=1 */
    uWS::LocalCluster({
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    },
    [](uWS::SSLApp &app) {
        /* Here this App instance is defined */
        app.get("/*", [](auto *res, auto * /*req*/) {
            res->end("Hello world!");
        }).listen(3000, [](auto *listen_socket) {
            if (listen_socket) {
                /* Note that us_listen_socket_t is castable to us_socket_t */
                std::cout << "Thread " << std::this_thread::get_id() << " listening on port " << us_socket_local_port(true, (struct us_socket_t *) listen_socket) << std::endl;
            } else {
                std::cout << "Thread " << std::this_thread::get_id() << " failed to listen on port 3000" << std::endl;
            }
        });
    });
}

```

`examples/Http3Server.cpp`:

```cpp
#ifdef LIBUS_USE_QUIC

/* Do not rely on this API, it will change */
#include "Http3App.h"
#include <iostream>
#include <fstream>

/* This is an example serving a video over HTTP3, and echoing posted data back */
/* Todo: use onWritable and tryEnd instead of end */
int main() {

    /* Read video file to memory */
    std::ifstream file("video.mp4", std::ios::binary | std::ios::ate);
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);

    std::vector<char> buffer(size);
    if (!file.read(buffer.data(), size)) {
        std::cout << "Failed to load video.mp4" << std::endl;
        return 0;
    }

    /* We need a bootstrapping server that instructs
     * the web browser to use HTTP3 */
    (*new uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    })).get("/*", [&buffer](auto *res, auto *req) {
        res->writeHeader("Alt-Svc", "h3=\":9004\"");
        res->writeHeader("Alternative-Protocol", "quic:9004");
        res->end("<html><h1>This is not HTTP3! Try refreshing (works in Firefox!)</h1></html>");
    }).listen(9004, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Bootstrapping server Listening on port " << 9004 << std::endl;
        }
    });

    /* And we serve the video over HTTP3 */
    uWS::H3App({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).get("/*", [&buffer](auto *res, auto *req) {
        res->end("<html><h1>Welcome to HTTP3! <a href=\"video.mp4\">Go see a movie</a></html></h1>");
    }).get("/video.mp4", [&buffer](auto *res, auto *req) {
        /* Send back a video */
        res->end({&buffer[0], buffer.size()});
    }).post("/*", [](auto *res, auto *req) {

        std::cout << "Got POST request at " << req->getHeader(":path") << std::endl;

        /* You also need to set onAborted if receiving data */
        res->onData([res, bodyBuffer = (std::string *)nullptr](std::string_view chunk, bool isLast) mutable {
            if (isLast) {
                std::cout << "Sending back posted body now" << std::endl;
                if (bodyBuffer) {
                    /* Send back the (chunked) body we got, as response */
                    bodyBuffer->append(chunk);
                    res->end(*bodyBuffer);
                    delete bodyBuffer;
                } else {
                    /* Send back the body we got, as response (fast path) */
                    res->end(chunk);
                }
            } else {
                /* Slow path */
                if (!bodyBuffer) {
                    bodyBuffer = new std::string;
                }
                /* If we got the body in a chunk, buffer it up until whole */
                bodyBuffer->append(chunk);
            }

        });

        /* If you have pending, asynch work, you should abort such work in this callback */
        res->onAborted([]() {
            /* Again, just printing is not enough, you need to abort any pending work here
             * so that nothing will call res->end, since the request was aborted and deleted */
            printf("Stream was aborted!\n");
        });
    }).listen(9004, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "HTTP/3 server Listening on port " << 9004 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 9004" << std::endl;
}

#else

#include <stdio.h>

int main() {
    printf("Compile with WITH_QUIC=1 WITH_BORINGSSL=1 make in order to build this example\n");
}

#endif
```

`examples/HttpServer.cpp`:

```cpp
/* This is a simple HTTP(S) web server much like Python's SimpleHTTPServer */

#include <App.h>

/* Helpers for this example */
#include "helpers/AsyncFileReader.h"
#include "helpers/AsyncFileStreamer.h"
#include "helpers/Middleware.h"

/* optparse */
#define OPTPARSE_IMPLEMENTATION
#include "helpers/optparse.h"

int main(int argc, char **argv) {

    int option;
    struct optparse options;
    optparse_init(&options, argv);

    struct optparse_long longopts[] = {
        {"port", 'p', OPTPARSE_REQUIRED},
        {"help", 'h', OPTPARSE_NONE},
        {"passphrase", 'a', OPTPARSE_REQUIRED},
        {"key", 'k', OPTPARSE_REQUIRED},
        {"cert", 'c', OPTPARSE_REQUIRED},
        {"dh_params", 'd', OPTPARSE_REQUIRED},
        {0}
    };

    int port = 3000;
    uWS::SocketContextOptions ssl_options = {};

    while ((option = optparse_long(&options, longopts, nullptr)) != -1) {
        switch (option) {
        case 'p':
            port = atoi(options.optarg);
            break;
        case 'a':
            ssl_options.passphrase = options.optarg;
            break;
        case 'c':
            ssl_options.cert_file_name = options.optarg;
            break;
        case 'k':
            ssl_options.key_file_name = options.optarg;
            break;
        case 'd':
            ssl_options.dh_params_file_name = options.optarg;
            break;
        case 'h':
        case '?':
            fail:
            std::cout << "Usage: " << argv[0] << " [--help] [--port <port>] [--key <ssl key>] [--cert <ssl cert>] [--passphrase <ssl key passphrase>] [--dh_params <ssl dh params file>] <public root>" << std::endl;
            return 0;
        }
    }

    char *root = optparse_arg(&options);
    if (!root) {
        goto fail;
    }

    AsyncFileStreamer asyncFileStreamer(root);

    /* Either serve over HTTP or HTTPS */
    uWS::SocketContextOptions empty_ssl_options = {};
    if (memcmp(&ssl_options, &empty_ssl_options, sizeof(empty_ssl_options))) {
        /* HTTPS */
        uWS::SSLApp(ssl_options).get("/*", [&asyncFileStreamer](auto *res, auto *req) {
            serveFile(res, req);
            asyncFileStreamer.streamFile(res, req->getUrl());
        }).listen(port, [port, root](auto *token) {
            if (token) {
                std::cout << "Serving " << root << " over HTTPS a " << port << std::endl;
            }
        }).run();
    } else {
        /* HTTP */
        uWS::App().get("/*", [&asyncFileStreamer](auto *res, auto *req) {
            serveFile(res, req);
            asyncFileStreamer.streamFile(res, req->getUrl());
        }).listen(port, [port, root](auto *token) {
            if (token) {
                std::cout << "Serving " << root << " over HTTP a " << port << std::endl;
            }
        }).run();
    }

    std::cout << "Failed to listen to port " << port << std::endl;
}

```

`examples/ParameterRoutes.cpp`:

```cpp
#include "App.h"

/* Note that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support */

int main() {
    /* Overly simple hello world app */
    uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).get("/:first/static/:second", [](auto *res, auto *req) {

        res->write("<h1>first is: ");
        res->write(req->getParameter("first"));
        res->write("</h1>");

        res->write("<h1>second is: ");
        res->write(req->getParameter("second"));
        res->end("</h1>");

    }).listen(3000, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 3000 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 3000" << std::endl;
}

```

`examples/Precompress.cpp`:

```cpp
#include "App.h"

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
    };

    /* Keeping track of last prepared message */
    uWS::PreparedMessage preparedMessage;
    std::mutex m;

    /* For demo, we create a thread that will update the precompressed message every second */
    std::thread t2([&m, &preparedMessage]() {
        for (int counter = 1; true; counter++) {
            m.lock();
            std::string newMessage = "Hello you are looking at message number " + std::to_string(counter) + " and this text should be precompressed";        
            
            /* Here the current preparedMessage is updated */
            preparedMessage = uWS::Loop::get()->prepareMessage(newMessage, uWS::OpCode::TEXT, true);
            
            m.unlock();
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
    });

    uWS::App app;

    app.ws<PerSocketData>("/*", {
        /* You must only use SHARED_COMPRESSOR with precompression (can't use dedicated_compressor) */
        .compression = uWS::CompressOptions(uWS::SHARED_COMPRESSOR | uWS::DEDICATED_DECOMPRESSOR),
        /* Handlers */
        .upgrade = nullptr,
        .open = [](auto */*ws*/) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */

        },
        .message = [&m, &preparedMessage, &app](auto *ws, std::string_view message, uWS::OpCode opCode) {

            /* First respond by echoing what they send us, without compression */
            ws->send(message, opCode, false);

            /* Send last prepared message */
            m.lock();
            ws->sendPrepared(preparedMessage);

            /* Using publish should also take preparedMessage */
            ws->subscribe("test");
            app.publishPrepared("test", preparedMessage);
            ws->unsubscribe("test");

            m.unlock();
        },
        .dropped = [](auto */*ws*/, std::string_view /*message*/, uWS::OpCode /*opCode*/) {
            /* A message was dropped due to set maxBackpressure and closeOnBackpressureLimit limit */
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
        },
        .ping = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .pong = [](auto */*ws*/, std::string_view) {
            /* Not implemented yet */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here */
        }
    }).listen(9001, [&t2](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 9001 << std::endl;
        }
    }).run();
}

```

`examples/README.md`:

```md
# Examples

Make sure to also check out the JavaScript examples, the TypeDoc documentation browser and the Discussions tab here on GitHub. Much of what is true for the Node.js addon is true also for the C++ library.

```

`examples/SecureGzipFileServer.cpp`:

```cpp
#include <iostream>
#include <unordered_map>
#include <mutex>
#include <thread>
#include <chrono>
#include <filesystem>
#include <fstream>
#include <string>
#include <cstdint>
#include <cstring>
#include "App.h"

#ifndef UWS_NO_ZLIB
#include <zlib.h>
#endif

#if defined(__linux__)
#include <sys/inotify.h>
#include <unistd.h>
#endif

int cooldown = 0; // Seconds to sleep after reloading files (Linux only)

// Custom hasher for transparent lookup with std::string and std::string_view
struct StringViewHasher {
    using is_transparent = void;
    std::size_t operator()(const std::string& s) const { return std::hash<std::string_view>{}(s); }
    std::size_t operator()(std::string_view s) const { return std::hash<std::string_view>{}(s); }
};

// Custom equality comparator for transparent lookup
struct StringViewEqual {
    using is_transparent = void;
    bool operator()(std::string_view lhs, std::string_view rhs) const { return lhs == rhs; }
};

// Global variables
std::unordered_map<std::string, std::pair<std::string, bool>, StringViewHasher, StringViewEqual> file_map;
std::mutex map_mutex;
#if defined(__linux__)
int inotify_fd;
#endif
unsigned long fileSizes = 0;

// Loads file content; compresses with zlib if UWS_NO_ZLIB is not defined and compression is beneficial
std::pair<std::string, bool> load_file_content(const std::filesystem::path& path) {
    std::ifstream file(path, std::ios::binary);
    if (!file) {
        std::cerr << "Failed to open file: " << path << std::endl;
        return {"", false};
    }
    file.seekg(0, std::ios::end);
    size_t size = file.tellg();
    file.seekg(0, std::ios::beg);
    std::string content(size, 0);
    file.read(&content[0], size);

#ifndef UWS_NO_ZLIB
    z_stream zs = {};
    if (deflateInit2(&zs, Z_BEST_COMPRESSION, Z_DEFLATED, 15 + 16, 8, Z_DEFAULT_STRATEGY) == Z_OK) {
        zs.next_in = reinterpret_cast<Bytef*>(content.data());
        zs.avail_in = content.size();
        size_t bound = deflateBound(&zs, content.size());
        std::string compressed(bound, 0);
        zs.next_out = reinterpret_cast<Bytef*>(&compressed[0]);
        zs.avail_out = bound;
        int ret = deflate(&zs, Z_FINISH);
        if (ret == Z_STREAM_END) {
            size_t compressed_size = zs.total_out;
            deflateEnd(&zs);
            compressed.resize(compressed_size);
            if (compressed_size < size) {
                fileSizes += compressed_size;
                return {compressed, true};
            }
        } else {
            deflateEnd(&zs);
        }
    }
#endif
    fileSizes += size;
    return {content, false};
}

// Loads all files from the root folder into the map; adds inotify watches on Linux if inotify_fd >= 0
void load_files(const std::string& root, int inotify_fd = -1) {
    fileSizes = 0;
    std::unordered_map<std::string, std::pair<std::string, bool>, StringViewHasher, StringViewEqual> new_map;
    for (const auto& entry : std::filesystem::recursive_directory_iterator(root)) {
        if (entry.is_regular_file() && !entry.path().filename().string().starts_with(".")) {
            std::string relative_path = "/" + std::filesystem::relative(entry.path(), root).generic_string();
            auto [content, compressed] = load_file_content(entry.path());
            new_map[relative_path] = {content, compressed};
#if defined(__linux__)
            if (inotify_fd >= 0) {
                inotify_add_watch(inotify_fd, entry.path().c_str(), IN_MODIFY);
            }
#endif
        } else if (entry.is_directory()) {
#if defined(__linux__)
            if (inotify_fd >= 0) {
                inotify_add_watch(inotify_fd, entry.path().c_str(), IN_CREATE | IN_DELETE | IN_MOVE);
            }
#endif
        }
    }
    {
        std::lock_guard<std::mutex> lock(map_mutex);
        file_map = std::move(new_map);
        std::cout << "Loaded " << (fileSizes / 1024 / 1024) << " MB of files into RAM" << std::endl;
    }
}

#if defined(__linux__)
// Background thread to monitor inotify events and reload files on changes (Linux only)
void inotify_reloader_function(const std::string& root, int inotify_fd) {
    char buffer[4096];
    while (true) {
        int length = read(inotify_fd, buffer, sizeof(buffer));
        if (length < 0) {
            std::cerr << "Error reading inotify events: " << strerror(errno) << std::endl;
            break;
        }
        load_files(root, inotify_fd);
        if (cooldown) {
            std::cout << "Sleeping for " << cooldown << " seconds after reload" << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(cooldown));
        }
    }
}
#endif

int main(int argc, char** argv) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <root_folder> <cooldown>" << std::endl;
        return 1;
    }
    std::string root = argv[1];
    cooldown = std::stoi(argv[2]);
    if (cooldown < 0) {
        std::cerr << "Cooldown must be a non-negative integer" << std::endl;
        return 1;
    }

#if defined(__linux__)
    inotify_fd = inotify_init();
    if (inotify_fd < 0) {
        std::cerr << "Failed to initialize inotify: " << strerror(errno) << std::endl;
        return 1;
    }
    load_files(root, inotify_fd);
    std::thread inotify_reloader(inotify_reloader_function, root, inotify_fd);
#else
    load_files(root); // Load once at startup on macOS and Windows
#endif

    uWS::App app;

    // Static key for uWS handlers
    static char handler_key;

    // Add post and pre handlers to lock the mutex around event loop iterations
    uWS::Loop::get()->addPostHandler(&handler_key, [](uWS::Loop* /*loop*/) {
        std::lock_guard<std::mutex> lock(map_mutex);
    });
    uWS::Loop::get()->addPreHandler(&handler_key, [](uWS::Loop* /*loop*/) {
        std::lock_guard<std::mutex> lock(map_mutex);
    });

    app.get("/", [](auto* res, auto* req) {
        auto it = file_map.find(std::string_view("/index.html", 11));
        if (it != file_map.end()) {
            if (it->second.second) {
                res->writeHeader("Content-Encoding", "gzip");
            }
            res->end(it->second.first);
        } else {
            res->writeStatus("404 Not Found");
            res->end("Not Found");
        }
    });

    app.get("/*", [](auto* res, auto* req) {
        auto it = file_map.find(req->getUrl());
        if (it != file_map.end()) {
            if (it->second.second) {
                res->writeHeader("Content-Encoding", "gzip");
            }
            res->end(it->second.first);
        } else {
            res->writeStatus("404 Not Found");
            res->end("Not Found");
        }
    });

    app.listen(8000, [](auto* token) {
        if (token) {
            std::cout << "Listening on port 8000" << std::endl;
        }
    });

    app.run();

#if defined(__linux__)
    inotify_reloader.join();
    close(inotify_fd);
#endif

    return 0;
}
```

`examples/ServerName.cpp`:

```cpp
#include "App.h"

/* Note that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support */

int main() {
    /* The SSL context given in SSLApp constructor is the default / catch-all context */
    uWS::SSLApp app = uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).get("/*", [](auto *res, auto */*req*/) {
        res->end("Hello from catch-all context!");
    }).addServerName("*.google.*", {
      /* Following is the context for *.google.* domain */
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).domain("*.google.*").get("/*", [](auto *res, auto */*req*/) {
        res->end("Hello from *.google.* context!");
    }).listen(3000, [](auto *listenSocket) {
        if (listenSocket) {
            std::cout << "Listening on port " << 3000 << std::endl;
        } else {
            std::cout << "Failed to listen on port 3000" << std::endl;
        }
    }).run();
}

```

`examples/SmokeTest.cpp`:

```cpp
#include "App.h"

/* This is not an example; it is a smoke test used in CI testing */

struct Stream {
    int offset;
    bool aborted;
};

std::string constantChunk;

void streamData(auto *res, auto stream, int chunk) {

  if (stream->aborted) {
    return;
  }

  if (chunk < 1600) {
    res->cork([res, stream, chunk]() {
      auto ok = res->write(constantChunk);
      if (ok) {
        streamData(res, stream, chunk + 1);
        return;
      }

      uWS::Loop::get()->defer([res, stream, chunk]() {
        streamData(res, stream, chunk + 1);
      });
    });
  } else {
    res->cork([res]() {
      res->end();
    });
  }
}

int main() {

    for (int i = 0; i < 65536; i++) {
        constantChunk.append("a", 1);
    }

    uWS::SSLApp({
      .key_file_name = "misc/key.pem",
      .cert_file_name = "misc/cert.pem",
      .passphrase = "1234"
    }).get("/*", [](auto *res, auto */*req*/) {

        auto stream = std::make_shared<Stream>(0, false);
        streamData(res, stream, 0);

        res->onAborted([stream]() {
            stream->aborted = true;
        });
    }).listen(3000, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 3000 << std::endl;
        }
    }).run();

    std::cout << "Failed to listen on port 3000" << std::endl;
}

```

`examples/UpgradeAsync.cpp`:

```cpp
/* We simply call the root header file "App.h", giving you uWS::App and uWS::SSLApp */
#include "App.h"

/* This is a simple WebSocket "async" upgrade example.
 * You may compile it with "WITH_OPENSSL=1 make" or with "make" */

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Define your user data */
        int something;
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::SSLApp({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    }).ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::SHARED_COMPRESSOR,
        .maxPayloadLength = 16 * 1024,
        .idleTimeout = 10,
        .maxBackpressure = 1 * 1024 * 1024,
        /* Handlers */
        .upgrade = [](auto *res, auto *req, auto *context) {

            /* HttpRequest (req) is only valid in this very callback, so we must COPY the headers
             * we need later on while upgrading to WebSocket. You must not access req after first return.
             * Here we create a heap allocated struct holding everything we will need later on. */

            struct UpgradeData {
                std::string secWebSocketKey;
                std::string secWebSocketProtocol;
                std::string secWebSocketExtensions;
                struct us_socket_context_t *context;
                decltype(res) httpRes;
                bool aborted = false;
            } *upgradeData = new UpgradeData {
                std::string(req->getHeader("sec-websocket-key")),
                std::string(req->getHeader("sec-websocket-protocol")),
                std::string(req->getHeader("sec-websocket-extensions")),
                context,
                res
            };

            /* We have to attach an abort handler for us to be aware
             * of disconnections while we perform async tasks */
            res->onAborted([=]() {
                /* We don't implement any kind of cancellation here,
                 * so simply flag us as aborted */
                upgradeData->aborted = true;
                std::cout << "HTTP socket was closed before we upgraded it!" << std::endl;
            });

            /* Simulate checking auth for 5 seconds. This looks like crap, never write
             * code that utilize us_timer_t like this; they are high-cost and should
             * not be created and destroyed more than rarely!
             *
             * Also note that the code would be a lot simpler with capturing lambdas, maybe your
             * database client has such a nice interface? Either way, here we go!*/
            struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();
            struct us_timer_t *delayTimer = us_create_timer(loop, 0, sizeof(UpgradeData *));
            memcpy(us_timer_ext(delayTimer), &upgradeData, sizeof(UpgradeData *));
            us_timer_set(delayTimer, [](struct us_timer_t *t) {
                /* We wrote the upgradeData pointer to the timer's extension */
                UpgradeData *upgradeData;
                memcpy(&upgradeData, us_timer_ext(t), sizeof(UpgradeData *));

                /* Were'nt we aborted before our async task finished? Okay, upgrade then! */
                if (!upgradeData->aborted) {
                    std::cout << "Async task done, upgrading to WebSocket now!" << std::endl;

                    /* If you don't want to upgrade you can instead respond with custom HTTP here,
                    * such as res->writeStatus(...)->writeHeader(...)->end(...); or similar.*/

                    /* This call will immediately emit .open event */
                    upgradeData->httpRes->cork([upgradeData]() {
                        upgradeData->httpRes->template upgrade<PerSocketData>({
                            /* We initialize PerSocketData struct here */
                            .something = 13
                        }, upgradeData->secWebSocketKey,
                            upgradeData->secWebSocketProtocol,
                            upgradeData->secWebSocketExtensions,
                            upgradeData->context);
                    });
                } else {
                    std::cout << "Async task done, but the HTTP socket was closed. Skipping upgrade to WebSocket!" << std::endl;
                }

                delete upgradeData;

                us_timer_close(t);
            }, 5000, 0);

        },
        .open = [](auto *ws) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct.
             * Here we simply validate that indeed, something == 13 as set in upgrade handler. */
            std::cout << "Something is: " << static_cast<PerSocketData *>(ws->getUserData())->something << std::endl;
        },
        .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
            /* We simply echo whatever data we get */
            ws->send(message, opCode);
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
        },
        .ping = [](auto */*ws*/, std::string_view) {
            /* You don't need to handle this one, we automatically respond to pings as per standard */
        },
        .pong = [](auto */*ws*/, std::string_view) {
            /* You don't need to handle this one either */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here, but sending or
             * doing any kind of I/O with the socket is not valid. */
        }
    }).listen(9001, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 9001 << std::endl;
        }
    }).run();
}

```

`examples/UpgradeSync.cpp`:

```cpp
/* We simply call the root header file "App.h", giving you uWS::App and uWS::SSLApp */
#include "App.h"

/* This is a simple WebSocket "sync" upgrade example.
 * You may compile it with "WITH_OPENSSL=1 make" or with "make" */

int main() {
    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Define your user data */
        int something;
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::SSLApp({
        /* There are example certificates in uWebSockets.js repo */
        .key_file_name = "misc/key.pem",
        .cert_file_name = "misc/cert.pem",
        .passphrase = "1234"
    }).ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::SHARED_COMPRESSOR,
        .maxPayloadLength = 16 * 1024,
        .idleTimeout = 10,
        .maxBackpressure = 1 * 1024 * 1024,
        /* Handlers */
        .upgrade = [](auto *res, auto *req, auto *context) {

            /* You may read from req only here, and COPY whatever you need into your PerSocketData.
             * PerSocketData is valid from .open to .close event, accessed with ws->getUserData().
             * HttpRequest (req) is ONLY valid in this very callback, so any data you will need later
             * has to be COPIED into PerSocketData here. */

            /* Immediately upgrading without doing anything "async" before, is simple */
            res->template upgrade<PerSocketData>({
                /* We initialize PerSocketData struct here */
                .something = 13
            }, req->getHeader("sec-websocket-key"),
                req->getHeader("sec-websocket-protocol"),
                req->getHeader("sec-websocket-extensions"),
                context);

            /* If you don't want to upgrade you can instead respond with custom HTTP here,
             * such as res->writeStatus(...)->writeHeader(...)->end(...); or similar.*/

            /* Performing async upgrade, such as checking with a database is a little more complex;
             * see UpgradeAsync example instead. */
        },
        .open = [](auto *ws) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct.
             * Here we simply validate that indeed, something == 13 as set in upgrade handler. */
            std::cout << "Something is: " << static_cast<PerSocketData *>(ws->getUserData())->something << std::endl;
        },
        .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
            /* We simply echo whatever data we get */
            ws->send(message, opCode);
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
        },
        .ping = [](auto */*ws*/, std::string_view) {
            /* You don't need to handle this one, we automatically respond to pings as per standard */
        },
        .pong = [](auto */*ws*/, std::string_view) {
            /* You don't need to handle this one either */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here, but sending or
             * doing any kind of I/O with the socket is not valid. */
        }
    }).listen(9001, [](auto *listen_socket) {
        if (listen_socket) {
            std::cout << "Listening on port " << 9001 << std::endl;
        }
    }).run();
}

```

`examples/helpers/AsyncFileReader.h`:

```h
#include <map>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <future>

/* This is just a very simple and inefficient demo of async responses,
 * please do roll your own variant or use a database or Node.js's async
 * features instead of this really bad demo */
struct AsyncFileReader {
private:
    /* The cache we have in memory for this file */
    std::string cache;
    int cacheOffset;
    bool hasCache;

    /* The pending async file read (yes we only support one pending read) */
    std::function<void(std::string_view)> pendingReadCb;

    int fileSize;
    std::string fileName;
    std::ifstream fin;
    uWS::Loop *loop;

public:
    /* Construct a demo async. file reader for fileName */
    AsyncFileReader(std::string fileName) : fileName(fileName) {
        fin.open(fileName, std::ios::binary);

        // get fileSize
        fin.seekg(0, fin.end);
        fileSize = fin.tellg();

        //std::cout << "File size is: " << fileSize << std::endl;

        // cache up 1 mb!
        cache.resize(1024 * 1024);

        //std::cout << "Caching 1 MB at offset = " << 0 << std::endl;
        fin.seekg(0, fin.beg);
        fin.read(cache.data(), cache.length());
        cacheOffset = 0;
        hasCache = true;

        // get loop for thread

        loop = uWS::Loop::get();
    }

    /* Returns any data already cached for this offset */
    std::string_view peek(int offset) {
        /* Did we hit the cache? */
        if (hasCache && offset >= cacheOffset && ((offset - cacheOffset) < cache.length())) {
            /* Cache hit */
            //std::cout << "Cache hit!" << std::endl;

            /*if (fileSize - offset < cache.length()) {
                std::cout << "LESS THAN WHAT WE HAVE!" << std::endl;
            }*/

            int chunkSize = std::min<int>(fileSize - offset, cache.length() - offset + cacheOffset);

            return std::string_view(cache.data() + offset - cacheOffset, chunkSize);
        } else {
            /* Cache miss */
            //std::cout << "Cache miss!" << std::endl;
            return std::string_view(nullptr, 0);
        }
    }

    /* Asynchronously request more data at offset */
    void request(int offset, std::function<void(std::string_view)> cb) {

        // in this case, what do we do?
        // we need to queue up this chunk request and callback!
        // if queue is full, either block or close the connection via abort!
        if (!hasCache) {
            // already requesting a chunk!
            std::cout << "ERROR: already requesting a chunk!" << std::endl;
            return;
        }

        // disable cache
        hasCache = false;

        std::async(std::launch::async, [this, cb, offset]() {
            //std::cout << "ASYNC Caching 1 MB at offset = " << offset << std::endl;



            // den har stängts! öppna igen!
            if (!fin.good()) {
                fin.close();
                //std::cout << "Reopening fin!" << std::endl;
                fin.open(fileName, std::ios::binary);
            }
            fin.seekg(offset, fin.beg);
            fin.read(cache.data(), cache.length());

            cacheOffset = offset;

            loop->defer([this, cb, offset]() {

                int chunkSize = std::min<int>(cache.length(), fileSize - offset);

                // båda dessa sker, wtf?
                if (chunkSize == 0) {
                    std::cout << "Zero size!?" << std::endl;
                }

                if (chunkSize != cache.length()) {
                    std::cout << "LESS THAN A CACHE 1 MB!" << std::endl;
                }

                hasCache = true;
                cb(std::string_view(cache.data(), chunkSize));
            });
        });
    }

    /* Abort any pending async. request */
    void abort() {

    }

    int getFileSize() {
        return fileSize;
    }
};

```

`examples/helpers/AsyncFileStreamer.h`:

```h
#include <filesystem>

struct AsyncFileStreamer {

    std::map<std::string_view, AsyncFileReader *> asyncFileReaders;
    std::string root;

    AsyncFileStreamer(std::string root) : root(root) {
        // for all files in this path, init the map of AsyncFileReaders
        updateRootCache();
    }

    void updateRootCache() {
        // todo: if the root folder changes, we want to reload the cache
        for(auto &p : std::filesystem::recursive_directory_iterator(root)) {
            std::string url = p.path().string().substr(root.length());
            if (url == "/index.html") {
                url = "/";
            }

            char *key = new char[url.length()];
            memcpy(key, url.data(), url.length());
            asyncFileReaders[std::string_view(key, url.length())] = new AsyncFileReader(p.path().string());
        }
    }

    template <bool SSL>
    void streamFile(uWS::HttpResponse<SSL> *res, std::string_view url) {
        auto it = asyncFileReaders.find(url);
        if (it == asyncFileReaders.end()) {
            std::cout << "Did not find file: " << url << std::endl;
        } else {
            streamFile(res, it->second);
        }
    }

    template <bool SSL>
    static void streamFile(uWS::HttpResponse<SSL> *res, AsyncFileReader *asyncFileReader) {
        /* Peek from cache */
        std::string_view chunk = asyncFileReader->peek(res->getWriteOffset());
        auto remaining_data = asyncFileReader->getFileSize() - res->getWriteOffset();
        if (!chunk.length() || res->tryEnd(chunk, remaining_data).first) {
            /* Request new chunk */
            // todo: we need to abort this callback if peer closed!
            // this also means Loop::defer needs to support aborting (functions should embedd an atomic boolean abort or something)

            // Loop::defer(f) -> integer
            // Loop::abort(integer)

            // hmm? no?

            // us_socket_up_ref eftersom vi delar ägandeskapet

            if (chunk.length() < remaining_data) {
                asyncFileReader->request(res->getWriteOffset(), [res, asyncFileReader](std::string_view chunk) {
                    // check if we were closed in the mean time
                    //if (us_socket_is_closed()) {
                        // free it here
                        //return;
                    //}

                    /* We were aborted for some reason */
                    if (!chunk.length()) {
                        // todo: make sure to check for is_closed internally after all callbacks!
                        res->close();
                    } else {
                        AsyncFileStreamer::streamFile(res, asyncFileReader);
                    }
                });
            }
        } else {
            /* We failed writing everything, so let's continue when we can */
            res->onWritable([res, asyncFileReader](int offset) {

                // här kan skiten avbrytas!

                AsyncFileStreamer::streamFile(res, asyncFileReader);
                // todo: I don't really know what this is supposed to mean?
                return false;
            })->onAborted([]() {
                std::cout << "ABORTED!" << std::endl;
            });
        }
    }
};

```

`examples/helpers/Middleware.h`:

```h
/* Middleware to fill out content-type */
inline bool hasExt(std::string_view file, std::string_view ext) {
    if (ext.size() > file.size()) {
        return false;
    }
    return std::equal(ext.rbegin(), ext.rend(), file.rbegin());
}

/* This should be a filter / middleware like app.use(handler) */
template <bool SSL>
uWS::HttpResponse<SSL> *serveFile(uWS::HttpResponse<SSL> *res, uWS::HttpRequest *req) {
    res->writeStatus(uWS::HTTP_200_OK);

    if (hasExt(req->getUrl(), ".svg")) {
        res->writeHeader("Content-Type", "image/svg+xml");
    }

    return res;
}

```

`examples/helpers/optparse.h`:

```h
/* Nicked from third-party https://github.com/skeeto/optparse 2018-09-24 */
/* µWebSockets is not the origin of this software file */
/* ------------------------------------------------------ */

/* Optparse --- portable, reentrant, embeddable, getopt-like option parser
 *
 * This is free and unencumbered software released into the public domain.
 *
 * To get the implementation, define OPTPARSE_IMPLEMENTATION.
 * Optionally define OPTPARSE_API to control the API's visibility
 * and/or linkage (static, __attribute__, __declspec).
 *
 * The POSIX getopt() option parser has three fatal flaws. These flaws
 * are solved by Optparse.
 *
 * 1) Parser state is stored entirely in global variables, some of
 * which are static and inaccessible. This means only one thread can
 * use getopt(). It also means it's not possible to recursively parse
 * nested sub-arguments while in the middle of argument parsing.
 * Optparse fixes this by storing all state on a local struct.
 *
 * 2) The POSIX standard provides no way to properly reset the parser.
 * This means for portable code that getopt() is only good for one
 * run, over one argv with one option string. It also means subcommand
 * options cannot be processed with getopt(). Most implementations
 * provide a method to reset the parser, but it's not portable.
 * Optparse provides an optparse_arg() function for stepping over
 * subcommands and continuing parsing of options with another option
 * string. The Optparse struct itself can be passed around to
 * subcommand handlers for additional subcommand option parsing. A
 * full reset can be achieved by with an additional optparse_init().
 *
 * 3) Error messages are printed to stderr. This can be disabled with
 * opterr, but the messages themselves are still inaccessible.
 * Optparse solves this by writing an error message in its errmsg
 * field. The downside to Optparse is that this error message will
 * always be in English rather than the current locale.
 *
 * Optparse should be familiar with anyone accustomed to getopt(), and
 * it could be a nearly drop-in replacement. The option string is the
 * same and the fields have the same names as the getopt() global
 * variables (optarg, optind, optopt).
 *
 * Optparse also supports GNU-style long options with optparse_long().
 * The interface is slightly different and simpler than getopt_long().
 *
 * By default, argv is permuted as it is parsed, moving non-option
 * arguments to the end. This can be disabled by setting the `permute`
 * field to 0 after initialization.
 */
#ifndef OPTPARSE_H
#define OPTPARSE_H

#ifndef OPTPARSE_API
#  define OPTPARSE_API
#endif

struct optparse {
    char **argv;
    int permute;
    int optind;
    int optopt;
    char *optarg;
    char errmsg[64];
    int subopt;
};

enum optparse_argtype {
    OPTPARSE_NONE,
    OPTPARSE_REQUIRED,
    OPTPARSE_OPTIONAL
};

struct optparse_long {
    const char *longname;
    int shortname;
    enum optparse_argtype argtype;
};

/**
 * Initializes the parser state.
 */
OPTPARSE_API
void optparse_init(struct optparse *options, char **argv);

/**
 * Read the next option in the argv array.
 * @param optstring a getopt()-formatted option string.
 * @return the next option character, -1 for done, or '?' for error
 *
 * Just like getopt(), a character followed by no colons means no
 * argument. One colon means the option has a required argument. Two
 * colons means the option takes an optional argument.
 */
OPTPARSE_API
int optparse(struct optparse *options, const char *optstring);

/**
 * Handles GNU-style long options in addition to getopt() options.
 * This works a lot like GNU's getopt_long(). The last option in
 * longopts must be all zeros, marking the end of the array. The
 * longindex argument may be NULL.
 */
OPTPARSE_API
int optparse_long(struct optparse *options,
                  const struct optparse_long *longopts,
                  int *longindex);

/**
 * Used for stepping over non-option arguments.
 * @return the next non-option argument, or NULL for no more arguments
 *
 * Argument parsing can continue with optparse() after using this
 * function. That would be used to parse the options for the
 * subcommand returned by optparse_arg(). This function allows you to
 * ignore the value of optind.
 */
OPTPARSE_API
char *optparse_arg(struct optparse *options);

/* Implementation */
#ifdef OPTPARSE_IMPLEMENTATION

#define OPTPARSE_MSG_INVALID "invalid option"
#define OPTPARSE_MSG_MISSING "option requires an argument"
#define OPTPARSE_MSG_TOOMANY "option takes no arguments"

static int
optparse_error(struct optparse *options, const char *msg, const char *data)
{
    unsigned p = 0;
    const char *sep = " -- '";
    while (*msg)
        options->errmsg[p++] = *msg++;
    while (*sep)
        options->errmsg[p++] = *sep++;
    while (p < sizeof(options->errmsg) - 2 && *data)
        options->errmsg[p++] = *data++;
    options->errmsg[p++] = '\'';
    options->errmsg[p++] = '\0';
    return '?';
}

OPTPARSE_API
void
optparse_init(struct optparse *options, char **argv)
{
    options->argv = argv;
    options->permute = 1;
    options->optind = 1;
    options->subopt = 0;
    options->optarg = 0;
    options->errmsg[0] = '\0';
}

static int
optparse_is_dashdash(const char *arg)
{
    return arg != 0 && arg[0] == '-' && arg[1] == '-' && arg[2] == '\0';
}

static int
optparse_is_shortopt(const char *arg)
{
    return arg != 0 && arg[0] == '-' && arg[1] != '-' && arg[1] != '\0';
}

static int
optparse_is_longopt(const char *arg)
{
    return arg != 0 && arg[0] == '-' && arg[1] == '-' && arg[2] != '\0';
}

static void
optparse_permute(struct optparse *options, int index)
{
    char *nonoption = options->argv[index];
    int i;
    for (i = index; i < options->optind - 1; i++)
        options->argv[i] = options->argv[i + 1];
    options->argv[options->optind - 1] = nonoption;
}

static int
optparse_argtype(const char *optstring, char c)
{
    int count = OPTPARSE_NONE;
    if (c == ':')
        return -1;
    for (; *optstring && c != *optstring; optstring++);
    if (!*optstring)
        return -1;
    if (optstring[1] == ':')
        count += optstring[2] == ':' ? 2 : 1;
    return count;
}

OPTPARSE_API
int
optparse(struct optparse *options, const char *optstring)
{
    int type;
    char *next;
    char *option = options->argv[options->optind];
    options->errmsg[0] = '\0';
    options->optopt = 0;
    options->optarg = 0;
    if (option == 0) {
        return -1;
    } else if (optparse_is_dashdash(option)) {
        options->optind++; /* consume "--" */
        return -1;
    } else if (!optparse_is_shortopt(option)) {
        if (options->permute) {
            int index = options->optind++;
            int r = optparse(options, optstring);
            optparse_permute(options, index);
            options->optind--;
            return r;
        } else {
            return -1;
        }
    }
    option += options->subopt + 1;
    options->optopt = option[0];
    type = optparse_argtype(optstring, option[0]);
    next = options->argv[options->optind + 1];
    switch (type) {
    case -1: {
        char str[2] = {0, 0};
        str[0] = option[0];
        options->optind++;
        return optparse_error(options, OPTPARSE_MSG_INVALID, str);
    }
    case OPTPARSE_NONE:
        if (option[1]) {
            options->subopt++;
        } else {
            options->subopt = 0;
            options->optind++;
        }
        return option[0];
    case OPTPARSE_REQUIRED:
        options->subopt = 0;
        options->optind++;
        if (option[1]) {
            options->optarg = option + 1;
        } else if (next != 0) {
            options->optarg = next;
            options->optind++;
        } else {
            char str[2] = {0, 0};
            str[0] = option[0];
            options->optarg = 0;
            return optparse_error(options, OPTPARSE_MSG_MISSING, str);
        }
        return option[0];
    case OPTPARSE_OPTIONAL:
        options->subopt = 0;
        options->optind++;
        if (option[1])
            options->optarg = option + 1;
        else
            options->optarg = 0;
        return option[0];
    }
    return 0;
}

OPTPARSE_API
char *
optparse_arg(struct optparse *options)
{
    char *option = options->argv[options->optind];
    options->subopt = 0;
    if (option != 0)
        options->optind++;
    return option;
}

static int
optparse_longopts_end(const struct optparse_long *longopts, int i)
{
    return !longopts[i].longname && !longopts[i].shortname;
}

static void
optparse_from_long(const struct optparse_long *longopts, char *optstring)
{
    char *p = optstring;
    int i;
    for (i = 0; !optparse_longopts_end(longopts, i); i++) {
        if (longopts[i].shortname) {
            int a;
            *p++ = longopts[i].shortname;
            for (a = 0; a < (int)longopts[i].argtype; a++)
                *p++ = ':';
        }
    }
    *p = '\0';
}

/* Unlike strcmp(), handles options containing "=". */
static int
optparse_longopts_match(const char *longname, const char *option)
{
    const char *a = option, *n = longname;
    if (longname == 0)
        return 0;
    for (; *a && *n && *a != '='; a++, n++)
        if (*a != *n)
            return 0;
    return *n == '\0' && (*a == '\0' || *a == '=');
}

/* Return the part after "=", or NULL. */
static char *
optparse_longopts_arg(char *option)
{
    for (; *option && *option != '='; option++);
    if (*option == '=')
        return option + 1;
    else
        return 0;
}

static int
optparse_long_fallback(struct optparse *options,
                       const struct optparse_long *longopts,
                       int *longindex)
{
    int result;
    char optstring[96 * 3 + 1]; /* 96 ASCII printable characters */
    optparse_from_long(longopts, optstring);
    result = optparse(options, optstring);
    if (longindex != 0) {
        *longindex = -1;
        if (result != -1) {
            int i;
            for (i = 0; !optparse_longopts_end(longopts, i); i++)
                if (longopts[i].shortname == options->optopt)
                    *longindex = i;
        }
    }
    return result;
}

OPTPARSE_API
int
optparse_long(struct optparse *options,
              const struct optparse_long *longopts,
              int *longindex)
{
    int i;
    char *option = options->argv[options->optind];
    if (option == 0) {
        return -1;
    } else if (optparse_is_dashdash(option)) {
        options->optind++; /* consume "--" */
        return -1;
    } else if (optparse_is_shortopt(option)) {
        return optparse_long_fallback(options, longopts, longindex);
    } else if (!optparse_is_longopt(option)) {
        if (options->permute) {
            int index = options->optind++;
            int r = optparse_long(options, longopts, longindex);
            optparse_permute(options, index);
            options->optind--;
            return r;
        } else {
            return -1;
        }
    }

    /* Parse as long option. */
    options->errmsg[0] = '\0';
    options->optopt = 0;
    options->optarg = 0;
    option += 2; /* skip "--" */
    options->optind++;
    for (i = 0; !optparse_longopts_end(longopts, i); i++) {
        const char *name = longopts[i].longname;
        if (optparse_longopts_match(name, option)) {
            char *arg;
            if (longindex)
                *longindex = i;
            options->optopt = longopts[i].shortname;
            arg = optparse_longopts_arg(option);
            if (longopts[i].argtype == OPTPARSE_NONE && arg != 0) {
                return optparse_error(options, OPTPARSE_MSG_TOOMANY, name);
            } if (arg != 0) {
                options->optarg = arg;
            } else if (longopts[i].argtype == OPTPARSE_REQUIRED) {
                options->optarg = options->argv[options->optind];
                if (options->optarg == 0)
                    return optparse_error(options, OPTPARSE_MSG_MISSING, name);
                else
                    options->optind++;
            }
            return options->optopt;
        }
    }
    return optparse_error(options, OPTPARSE_MSG_INVALID, option);
}

#endif /* OPTPARSE_IMPLEMENTATION */
#endif /* OPTPARSE_H */

```

`fuzzing/AsyncEpollHelloWorld.cpp`:

```cpp
/* We rely on wrapped syscalls */
#include "libEpollFuzzer/epoll_fuzzer.h"

#include "App.h"

/* We keep this one for teardown later on */
struct us_listen_socket_t *listen_socket;

/* This test is run by libEpollFuzzer */
void test() {

    {
        /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
        * You may swap to using uWS:App() if you don't need SSL */
        auto app = uWS::App({
            /* There are example certificates in uWebSockets.js repo */
            .key_file_name = "../misc/key.pem",
            .cert_file_name = "../misc/cert.pem",
            .passphrase = "1234"
        }).get("/*", [](auto *res, auto *req) {
            auto aborted = std::make_shared<bool>();
            *aborted = false;
            res->onAborted([aborted]() {
                *aborted = true;
            });

            uWS::Loop::get()->defer([res, aborted]() {
                if (!*aborted) {
                    res->cork([res, aborted]() {
                        // Todo: also test upgrade to websocket here
                        res->end("Hello async!");
                    });
                }
            });
        }).listen(9001, [](auto *listenSocket) {
            listen_socket = listenSocket;
        });

        app.run();
    }
    uWS::Loop::get()->free();
}

/* Thus function should shutdown the event-loop and let the test fall through */
void teardown() {
	/* If we are called twice there's a bug (it potentially could if
	 * all open sockets cannot be error-closed in one epoll_wait call).
	 * But we only allow 1k FDs and we have a buffer of 1024 from epoll_wait */
	if (!listen_socket) {
		exit(-1);
	}

	/* We might have open sockets still, and these will be error-closed by epoll_wait */
	// us_socket_context_close - close all open sockets created with this socket context
    if (listen_socket) {
        us_listen_socket_close(0, listen_socket);
        listen_socket = NULL;
    }
}

```

`fuzzing/AsyncEpollHelloWorld.dict`:

```dict
"get"
"post"
"get /"
"http/1.1"
"upgrade: websocket"
"\x0D\x0A"
"sec-websocket-key: dGhlIHNhbXBsZSBub25jZQ=="
"sec-websocket-version: 13"
"get / http/1.1"
"sec-websocket-extensions: permessage-deflate"
"sec-websocket-protocol: "
" "
```

`fuzzing/EpollEchoServer.cpp`:

```cpp
/* We rely on wrapped syscalls */
#include "libEpollFuzzer/epoll_fuzzer.h"

#include "App.h"

/* We keep this one for teardown later on */
struct us_listen_socket_t *listen_socket;

/* This test is run by libEpollFuzzer */
void test() {

    struct PerSocketData {
        int nothing;
        std::shared_ptr<bool> valid;
    };

    /* First byte determines what compressor to use */
    unsigned char compressorByte;
    if (consume_byte(&compressorByte)) {
        //uWS::Loop::get()->free();
        return;
    }

    uWS::CompressOptions compressors[] = {
        uWS::DISABLED,
        uWS::SHARED_COMPRESSOR,
        uWS::DEDICATED_COMPRESSOR_3KB,
        uWS::DEDICATED_COMPRESSOR_4KB,
        uWS::DEDICATED_COMPRESSOR_8KB,
        uWS::DEDICATED_COMPRESSOR_16KB,
        uWS::DEDICATED_COMPRESSOR_32KB,
        uWS::DEDICATED_COMPRESSOR_64KB,
        uWS::DEDICATED_COMPRESSOR_128KB,
        uWS::DEDICATED_COMPRESSOR_256KB
    };

    uWS::CompressOptions compressor = compressors[compressorByte % 10];

    {
        auto app = uWS::App().ws<PerSocketData>("/broadcast", {
            /* Settings */
            .compression = compressor,
            /* We want this to be low so that we can hit it, yet bigger than 256 */
            .maxPayloadLength = 300,
            .idleTimeout = 12,
            /* Handlers */
            .open = [](auto *ws) {
                /* Subscribe to anything */
                ws->subscribe(/*req->getHeader(*/"topic"/*)*/);
            },
            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
                if (message.length() && message[0] == 'C') {
                    ws->close();
                } else if (message.length() && message[0] == 'E') {
                    ws->end(1006);
                } else {
                    /* Publish to topic sent by message */
                    ws->publish(message, message, opCode, true);

                    if (message.length() && message[0] == 'U') {
                        ws->unsubscribe(message);
                    }
                }
            },
            .drain = [](auto *ws) {
                /* Check getBufferedAmount here */
            },
            .ping = [](auto *ws, std::string_view) {

            },
            .pong = [](auto *ws, std::string_view) {

            },
            .close = [](auto *ws, int code, std::string_view message) {
                /* Cause reported crash */
                ws->close();
            }
        }).ws<PerSocketData>("/*", {
            /* Settings */
            .compression = compressor,
            /* We want this to be low so that we can hit it, yet bigger than 256 */
            .maxPayloadLength = 300,
            .idleTimeout = 12,
            /* Handlers */
            .open = [](auto *ws) {

                ws->getUserData()->valid.reset(new bool{true});

                //if (req->getHeader("close_me").length()) {
                //    ws->close();
                //} else if (req->getHeader("end_me").length()) {
                //    ws->end(1006);
                //}
            },
            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
                if (message.length() > 300) {
                    /* Inform the sanitizer of the fault */
                    fprintf(stderr, "Too long message passed\n");
                    free((void *) -1);
                }

                if (message.length() && message[0] == 'C') {
                    ws->close();
                } else if (message.length() && message[0] == 'E') {
                    ws->end(1006);
                } else {
                    ws->send(message, opCode, true);
                }
            },
            .drain = [](auto *ws) {
                /* Check getBufferedAmount here */
            },
            .ping = [](auto *ws, std::string_view) {
                /* Here we test send and end while uncorked, by having them send from deferred */
                PerSocketData *psd = (PerSocketData *) ws->getUserData();

                uWS::Loop::get()->defer([ws, valid = psd->valid]() {
                    if (*valid.get()) {
                        /* We haven't been closed */
                        ws->send("Hello!", uWS::TEXT, false);
                        ws->end(1000);
                    }
                });
            },
            .pong = [](auto *ws, std::string_view) {

            },
            .close = [](auto *ws, int code, std::string_view message) {
                (*ws->getUserData()->valid.get()) = false;
            }
        }).listen(9001, [](us_listen_socket_t *listenSocket) {
            listen_socket = listenSocket;
        });

        app.run();
    }

    uWS::Loop::get()->free();
}

/* Thus function should shutdown the event-loop and let the test fall through */
void teardown() {
	/* If we are called twice there's a bug (it potentially could if
	 * all open sockets cannot be error-closed in one epoll_wait call).
	 * But we only allow 1k FDs and we have a buffer of 1024 from epoll_wait */
	if (!listen_socket) {
		exit(-1);
	}

	/* We might have open sockets still, and these will be error-closed by epoll_wait */
	// us_socket_context_close - close all open sockets created with this socket context
    if (listen_socket) {
        us_listen_socket_close(0, listen_socket);
        listen_socket = NULL;
    }
}

```

`fuzzing/EpollEchoServer.dict`:

```dict
"get"
"post"
"get /"
"http/1.1"
"upgrade: websocket"
"\x0D\x0A"
"sec-websocket-key: dGhlIHNhbXBsZSBub25jZQ=="
"sec-websocket-version: 13"
"get / http/1.1"
"sec-websocket-extensions: permessage-deflate"
"sec-websocket-protocol: "
" "
```

`fuzzing/EpollEchoServerPubSub.cpp`:

```cpp
/* We rely on wrapped syscalls */
#include "libEpollFuzzer/epoll_fuzzer.h"

#include "App.h"
#include <vector>

/* We keep this one for teardown later on */
struct us_listen_socket_t *listen_socket;

/* This test is run by libEpollFuzzer */
void test() {

    /* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
        std::vector<std::string> topics;
        int nr = 0;
    };

    /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
     * You may swap to using uWS:App() if you don't need SSL */
    uWS::SSLApp *app = new uWS::SSLApp({
        /* There are example certificates in uWebSockets.js repo */
	    .key_file_name = "../misc/key.pem",
	    .cert_file_name = "../misc/cert.pem",
	    .passphrase = "1234"
	});
    
    app->ws<PerSocketData>("/*", {
        /* Settings */
        .compression = uWS::DISABLED,
        .maxPayloadLength = 512, // also have a low value here for fuzzing
        .idleTimeout = 60,
        .maxBackpressure = 128, // we want a low number so that we can reach this in fuzzing
        .closeOnBackpressureLimit = false, // this one could be tested as well
        .resetIdleTimeoutOnSend = true, // and this
        .sendPingsAutomatically = false, // and this
        /* Handlers */
        .upgrade = nullptr,
        .open = [](auto *ws) {
            /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */

            PerSocketData *perSocketData = (PerSocketData *) ws->getUserData();

            for (int i = 0; i < 100; i++) {
                std::string topic = std::to_string((uintptr_t)ws) + "-" + std::to_string(i);
                perSocketData->topics.push_back(topic);
                ws->subscribe(topic);
            }
        },
        .message = [&app](auto *ws, std::string_view message, uWS::OpCode opCode) {
            PerSocketData *perSocketData = (PerSocketData *) ws->getUserData();

            app->publish(perSocketData->topics[++perSocketData->nr % 100], message, opCode);
        },
        .drain = [](auto */*ws*/) {
            /* Check ws->getBufferedAmount() here */
            //std::cout << "drain" << std::endl;
        },
        .ping = [](auto */*ws*/, std::string_view ) {
            /* Not implemented yet */
        },
        .pong = [](auto */*ws*/, std::string_view ) {
            /* Not implemented yet */
        },
        .close = [](auto */*ws*/, int /*code*/, std::string_view /*message*/) {
            /* You may access ws->getUserData() here */
        }
    }).listen(9001, [](auto *listen_s) {
        if (listen_s) {
            //std::cout << "Listening on port " << 9001 << std::endl;
            listen_socket = listen_s;
        }
    });
    
    app->run();

    delete app;

    uWS::Loop::get()->free();
}

/* Thus function should shutdown the event-loop and let the test fall through */
void teardown() {
	/* If we are called twice there's a bug (it potentially could if
	 * all open sockets cannot be error-closed in one epoll_wait call).
	 * But we only allow 1k FDs and we have a buffer of 1024 from epoll_wait */
	if (!listen_socket) {
		exit(-1);
	}

	/* We might have open sockets still, and these will be error-closed by epoll_wait */
	// us_socket_context_close - close all open sockets created with this socket context
    if (listen_socket) {
        us_listen_socket_close(0, listen_socket);
        listen_socket = NULL;
    }
}

```

`fuzzing/EpollEchoServerPubSub.dict`:

```dict
"get"
"post"
"get /"
"http/1.1"
"upgrade: websocket"
"\x0D\x0A"
"sec-websocket-key: dGhlIHNhbXBsZSBub25jZQ=="
"sec-websocket-version: 13"
"get / http/1.1"
"sec-websocket-extensions: permessage-deflate"
"sec-websocket-protocol: "
" "
```

`fuzzing/EpollHelloWorld.cpp`:

```cpp
/* We rely on wrapped syscalls */
#include "libEpollFuzzer/epoll_fuzzer.h"

#include "App.h"

/* We keep this one for teardown later on */
struct us_listen_socket_t *listen_socket;
struct us_socket_t *client;

/* This test is run by libEpollFuzzer */
void test() {
	/* ws->getUserData returns one of these */
    struct PerSocketData {
        /* Fill with user data */
    };

    {
        /* Keep in mind that uWS::SSLApp({options}) is the same as uWS::App() when compiled without SSL support.
        * You may swap to using uWS:App() if you don't need SSL */
        auto app = uWS::App({
            /* There are example certificates in uWebSockets.js repo */
            .key_file_name = "../misc/key.pem",
            .cert_file_name = "../misc/cert.pem",
            .passphrase = "1234"
        }).ws<PerSocketData>("/empty", {
        /* Having no handlers here should not crash */
        }).get("/*", [](auto *res, auto *req) {
            if (req->getHeader("write").length()) {
                res->writeStatus("200 OK")->writeHeader("write", "true")->write("Hello");
                res->write(" world!");
                res->end();
            } else if (req->getQuery().length()) {
                res->close();
            } else {
                res->end("Hello world!");
            }
        }).post("/*", [](auto *res, auto *req) {
            res->onAborted([]() {
                /* We might as well use this opportunity to stress the loop a bit */
                uWS::Loop::get()->defer([]() {

                });
            });
            res->onData([res](std::string_view chunk, bool isEnd) {
                if (isEnd) {
                    res->cork([res, chunk]() {
                        res->write("something ahead");
                        res->end(chunk);
                    });
                }
            });
        }).any("/:candy/*", [](auto *res, auto *req) {
            if (req->getParameter(0).length() == 0) {
                free((void *) -1);
            }
            /* Some invalid queries */
            req->getParameter(30000);
            req->getParameter((unsigned short) -34234);
            req->getHeader("yhello");
            req->getQuery();
            req->getQuery("assd");

            res->end("done");
        }).ws<PerSocketData>("/*", {
            /* Settings */
            .compression = uWS::SHARED_COMPRESSOR,
            .maxPayloadLength = 16 * 1024,
            .idleTimeout = 12,
            .maxBackpressure = 1024,
            /* Handlers */
            .open = [](auto *ws) {
                /* Open event here, you may access ws->getUserData() which points to a PerSocketData struct */
                ws->getNativeHandle();
                ws->getRemoteAddressAsText();
                us_poll_ext((struct us_poll_t *) ws);
            },
            .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
                ws->send(message, opCode, true);
            },
            .drain = [](auto *ws) {
                /* Check ws->getBufferedAmount() here */
            },
            .ping = [](auto *ws, std::string_view) {
                /* We use this to trigger the async/wakeup feature */
                uWS::Loop::get()->defer([]() {
                    /* Do nothing */
                });
            },
            .pong = [](auto *ws, std::string_view) {
                /* Not implemented yet */
            },
            .close = [](auto *ws, int code, std::string_view message) {
                /* You may access ws->getUserData() here */
            }
        }).listen(9001, [](auto *listenSocket) {
            listen_socket = listenSocket;
        });

        /* Here we want to stress the connect feature, since nothing else stresses it */
        struct us_loop_t *loop = (struct us_loop_t *) uWS::Loop::get();
        /* This function is stupid */
        us_loop_iteration_number(loop);
        struct us_socket_context_t *client_context = us_create_socket_context(0, loop, 0, {});
        us_socket_context_timestamp(0, client_context);
        client = us_socket_context_connect(0, client_context, "hostname", 5000, "localhost", 0, 0);
	    
        if (client) {
            us_socket_is_established(0, client);
            us_socket_local_port(0, client);
        }

        us_socket_context_on_connect_error(0, client_context, [](struct us_socket_t *s, int code) {
            client = nullptr;
            return s;
        });

        us_socket_context_on_open(0, client_context, [](struct us_socket_t *s, int is_client, char *ip, int ip_length) {
            us_socket_flush(0, s);
            return s;
        });

        us_socket_context_on_end(0, client_context, [](struct us_socket_t *s) {
            /* Someone sent is a FIN, but we can still send data */
            us_socket_write(0, s, "asdadasdasdasdaddfgdfhdfgdfg", 28, false);
            return s;
        });

        us_socket_context_on_data(0, client_context, [](struct us_socket_t *s, char *data, int length) {
            return s;
        });

        us_socket_context_on_writable(0, client_context, [](struct us_socket_t *s) {
            /* Let's defer a close here */
            us_socket_shutdown_read(0, s);
            return s;
        });

        us_socket_context_on_close(0, client_context, [](struct us_socket_t *s, int code, void *reason) {
            client = NULL;
            return s;
        });

        /* Trigger some context functions */
        app.addServerName("servername", {});
        app.removeServerName("servername");
        app.missingServerName(nullptr);
        app.getNativeHandle();

        app.run();

        /* After done we also free the client context */
        us_socket_context_free(0, client_context);
    }
    uWS::Loop::get()->setSilent(true);
    uWS::Loop::get()->free();
}

/* Thus function should shutdown the event-loop and let the test fall through */
void teardown() {
	/* If we are called twice there's a bug (it potentially could if
	 * all open sockets cannot be error-closed in one epoll_wait call).
	 * But we only allow 1k FDs and we have a buffer of 1024 from epoll_wait */
	if (!listen_socket && !client) {
		exit(-1);
	}

    if (client) {
        us_socket_close(0, client, 0, 0);
        client = NULL;
    }

	/* We might have open sockets still, and these will be error-closed by epoll_wait */
	// us_socket_context_close - close all open sockets created with this socket context
    if (listen_socket) {
        us_listen_socket_close(0, listen_socket);
        listen_socket = NULL;
    }
}

```

`fuzzing/EpollHelloWorld.dict`:

```dict
"get"
"post"
"get /"
"http/1.1"
"upgrade: websocket"
"\x0D\x0A"
"sec-websocket-key: dGhlIHNhbXBsZSBub25jZQ=="
"sec-websocket-version: 13"
"get / http/1.1"
"sec-websocket-extensions: permessage-deflate"
"sec-websocket-protocol: "
" "
```

`fuzzing/Extensions.cpp`:

```cpp
/* This is a fuzz test of the websocket extensions parser */

#define WIN32_EXPORT

#include <cstdio>
#include <string>
#include <cstdlib>

/* We test the websocket extensions parser */
#include "../src/WebSocketExtensions.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    /* This one must not return shared compressor, or above 13 */
    {
        auto [negCompression, negCompressionWindow, negInflationWindow, response] = uWS::negotiateCompression(true, 13, 0, std::string_view((char *) data, size));

        if (negCompression) {
            /* If we want dedicated compression, we must not end up here! */
            free((void *) (negCompressionWindow == 0));

            /* Some more checks (freeing 0 does nothing) */
            free((void *) (negCompressionWindow > 13));
            free((void *) (negInflationWindow != 0));
            free((void *) (negInflationWindow < 0 || negInflationWindow > 15 || negCompressionWindow < 0 || negCompressionWindow > 15));
        }
    }

    /* This one must not return anything over 0 (only shared) */
    {
        auto [negCompression, negCompressionWindow, negInflationWindow, response] = uWS::negotiateCompression(true, 0, 0, std::string_view((char *) data, size));

        if (negCompression) {
            /* If we want shared compression, we must not end up here! */
            free((void *) (negCompressionWindow != 0));
        }
    }


    /* Whatever, this one must not negotiate anything */
    {
        auto [negCompression, negCompressionWindow, negInflationWindow, response] = uWS::negotiateCompression(false, 13, 15, std::string_view((char *) data, size));

        if (negCompression) {
            free((void *) -1);
        }
    }

    return 0;
}


```

`fuzzing/Http.cpp`:

```cpp
/* This is a fuzz test of the http parser */

#define WIN32_EXPORT

#include "helpers.h"

/* We test the websocket parser */
#include "../src/HttpParser.h"

/* And the router */
#include "../src/HttpRouter.h"

/* Also ProxyParser */
#include "../src/ProxyParser.h"

struct StaticData {

    struct RouterData {

    };

    uWS::HttpRouter<RouterData> router;

    StaticData() {

        router.add({"get"}, "/:hello/:hi", [](auto *h) mutable {
            auto [paramsTop, params] = h->getParameters();

            /* Something is horribly wrong */
            if (paramsTop != 1 || !params[0].length() || !params[1].length()) {
                exit(-1);
            }

            /* This route did handle it */
            return true;
        });

        router.add({"post"}, "/:hello/:hi/*", [](auto *h) mutable {
            auto [paramsTop, params] = h->getParameters();

            /* Something is horribly wrong */
            if (paramsTop != 1 || !params[0].length() || !params[1].length()) {
                exit(-1);
            }

            /* This route did handle it */
            return true;
        });

        router.add({"get"}, "/*", [](auto *h) mutable {
            auto [paramsTop, params] = h->getParameters();

            /* Something is horribly wrong */
            if (paramsTop != -1) {
                exit(-1);
            }

            /* This route did not handle it */
            return false;
        });

        router.add({"get"}, "/hi", [](auto *h) mutable {
            auto [paramsTop, params] = h->getParameters();

            /* Something is horribly wrong */
            if (paramsTop != -1) {
                exit(-1);
            }

            /* This route did handle it */
            return true;
        });
    }
} staticData;

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    /* Create parser */
    uWS::HttpParser httpParser;
    /* User data */
    void *user = (void *) 13;

    /* If we are built with WITH_PROXY, pass a ProxyParser as reserved */
    void *reserved = nullptr;
#ifdef UWS_WITH_PROXY
    uWS::ProxyParser pp;
    reserved = (void *) &pp;
#endif

    /* Iterate the padded fuzz as chunks */
    makeChunked(makePadded(data, size), size, [&httpParser, &user, reserved](const uint8_t *data, size_t size) {
        /* We need at least 1 byte post padding */
        if (size) {
            size--;
        } else {
            /* We might be given zero length chunks */
            return;
        }

        /* If user is null then ignore this chunk */
        if (!user) {
            return;
        }

        /* Parse it */
        auto [err, returnedUser] = httpParser.consumePostPadded((char *) data, size, user, reserved, [reserved](void *s, uWS::HttpRequest *httpRequest) -> void * {

            readBytes(httpRequest->getHeader(httpRequest->getUrl()));
            readBytes(httpRequest->getMethod());
            readBytes(httpRequest->getQuery());
            readBytes(httpRequest->getQuery("hello"));
            readBytes(httpRequest->getQuery(""));
            //readBytes(httpRequest->getParameter(0));

#ifdef UWS_WITH_PROXY
            auto *pp = (uWS::ProxyParser *) reserved;
            readBytes(pp->getSourceAddress());
#endif

            /* Route the method and URL in two passes */
            staticData.router.getUserData() = {};
            if (!staticData.router.route(httpRequest->getMethod(), httpRequest->getUrl())) {
                /* It was not handled */
                return nullptr;
            }

            for (auto p : *httpRequest) {

            }

            /* Return ok */
            return s;

        }, [](void *user, std::string_view data, bool fin) -> void * {

            /* Return ok */
            return user;

        });

        if (!returnedUser) {
            /* It is of uttermost importance that if and when we return nullptr from the httpParser we must not
             * ever use the httpParser ever again. It is in a broken state as returning nullptr is only used
             * for signalling early closure. You must absolutely must throw it away. Here we just mark user as
             * null so that we can ignore further chunks of data */
            user = nullptr;
        }
    });

    return 0;
}


```

`fuzzing/Makefile`:

```
# You can select which sanitizer to use by setting this
SANITIZER ?= address
# These are set by OSS-Fuzz, we default to AddressSanitizer
CXXFLAGS ?= -DLIBUS_NO_SSL -fsanitize=$(SANITIZER),fuzzer
CFLAGS ?= -DLIBUS_NO_SSL
OUT ?= .

# These are fetched from libEpollFuzzer
WRAPPED_SYSCALLS = -Wl,--wrap=getpeername,--wrap=sendto,--wrap=send,--wrap=recv,--wrap=read,--wrap=listen,--wrap=getaddrinfo,--wrap=freeaddrinfo,--wrap=setsockopt,--wrap=fcntl,--wrap=bind,--wrap=socket,--wrap=epoll_wait,--wrap=epoll_create1,--wrap=timerfd_settime,--wrap=close,--wrap=accept4,--wrap=eventfd,--wrap=timerfd_create,--wrap=epoll_ctl,--wrap=shutdown

oss-fuzz:
# Copy dictionaries
	cp *.dict $(OUT)
# libEpollFuzzer cases
	# Compile uSockets without -flto
	rm -rf *.o
	$(CC) $(CFLAGS) -DLIBUS_NO_SSL -std=c11 -I../uSockets/src -O3 -c ../uSockets/src/*.c ../uSockets/src/eventing/*.c ../uSockets/src/crypto/*.c
	# Link against object files
	$(CXX) $(CXXFLAGS) $(WRAPPED_SYSCALLS) -std=c++17 -O3 -DUWS_MOCK_ZLIB -I../src -I../uSockets/src EpollHelloWorld.cpp -o $(OUT)/EpollHelloWorld $(LIB_FUZZING_ENGINE) *.o
	rm -f EpollHelloWorld.o
	$(CXX) $(CXXFLAGS) $(WRAPPED_SYSCALLS) -std=c++17 -O3 -DUWS_MOCK_ZLIB -I../src -I../uSockets/src AsyncEpollHelloWorld.cpp -o $(OUT)/AsyncEpollHelloWorld $(LIB_FUZZING_ENGINE) *.o
	rm -f AsyncEpollHelloWorld.o
	$(CXX) $(CXXFLAGS) $(WRAPPED_SYSCALLS) -std=c++17 -O3 -DUWS_MOCK_ZLIB -I../src -I../uSockets/src EpollEchoServer.cpp -o $(OUT)/EpollEchoServer $(LIB_FUZZING_ENGINE) *.o
	rm -f EpollEchoServer.o
	$(CXX) $(CXXFLAGS) $(WRAPPED_SYSCALLS) -std=c++17 -O3 -DUWS_MOCK_ZLIB -I../src -I../uSockets/src EpollEchoServerPubSub.cpp -o $(OUT)/EpollEchoServerPubSub $(LIB_FUZZING_ENGINE) *.o
# "Unit tests"
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 Extensions.cpp -o $(OUT)/Extensions $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 QueryParser.cpp -o $(OUT)/QueryParser $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 MultipartParser.cpp -o $(OUT)/MultipartParser $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 -I../uSockets/src WebSocket.cpp -o $(OUT)/WebSocket $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 Http.cpp -o $(OUT)/Http $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -DUWS_WITH_PROXY -std=c++17 -O3 Http.cpp -o $(OUT)/HttpWithProxy $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -DUWS_MOCK_ZLIB -std=c++17 -O3 PerMessageDeflate.cpp -o $(OUT)/PerMessageDeflate $(LIB_FUZZING_ENGINE)
	$(CXX) $(CXXFLAGS) -std=c++17 -O3 TopicTree.cpp -o $(OUT)/TopicTree $(LIB_FUZZING_ENGINE)

regression_test:
	$(OUT)/EpollEchoServer seed-corpus/EpollEchoServer/regressions/*
	$(OUT)/EpollHelloWorld seed-corpus/EpollHelloWorld/regressions/*
	$(OUT)/EpollEchoServerPubSub seed-corpus/EpollEchoServerPubSub/regressions/*
	# $(OUT)/Extensions seed-corpus/Extensions/regressions/*
	# $(OUT)/QueryParser seed-corpus/QueryParser/regressions/*
	$(OUT)/TopicTree seed-corpus/TopicTree/regressions/*
	$(OUT)/WebSocket seed-corpus/WebSocket/regressions/*
	$(OUT)/Http seed-corpus/Http/regressions/*
	$(OUT)/HttpWithProxy seed-corpus/HttpWithProxy/regressions/*
	# $(OUT)/MultipartParser seed-corpus/MultipartParser/regressions/*
	$(OUT)/PerMessageDeflate seed-corpus/PerMessageDeflate/regressions/*

```

`fuzzing/MultipartParser.cpp`:

```cpp
/* This is a fuzz test of the multipart parser */

#define WIN32_EXPORT

#include <cstdio>
#include <string>
#include <cstdlib>

#include "../src/Multipart.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    if (!size) {
        return 0;
    }

    char *mutableMemory = (char *) malloc(size);
    memcpy(mutableMemory, data, size);

    /* First byte determines how long contentType is */
    unsigned char contentTypeLength = data[0];
    size--;

    std::string_view contentType((char *) mutableMemory + 1, std::min<size_t>(contentTypeLength, size));
    size -= contentType.length();

    std::string_view body((char *) mutableMemory + 1 + contentType.length(), size);

    uWS::MultipartParser mp(contentType);
    if (mp.isValid()) {
        mp.setBody(body);

        std::pair<std::string_view, std::string_view> headers[10];

        while (true) {
            std::optional<std::string_view> optionalPart = mp.getNextPart(headers);
            if (!optionalPart.has_value()) {
                break;
            }

            std::string_view part = optionalPart.value();

            for (int i = 0; headers[i].first.length(); i++) {
                /* We care about content-type and content-disposition */
                if (headers[i].first == "content-disposition") {
                    /* Parse the parameters */
                    uWS::ParameterParser pp(headers[i].second);
                    while (true) {
                        auto [key, value] = pp.getKeyValue();
                        if (!key.length()) {
                            break;
                        }
                    }
                }
            }
        }
    }

    free(mutableMemory);
    return 0;
}


```

`fuzzing/PerMessageDeflate.cpp`:

```cpp
/* This is a fuzz test of the permessage-deflate module */

#define WIN32_EXPORT

#include <cstdio>
#include <string>
#include <bitset>

/* We test the permessage deflate module */
#include "../src/PerMessageDeflate.h"

#include "helpers.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    /* First byte determines what compressor to use */
    if (size >= 1) {

        uWS::CompressOptions compressors[] = {
            uWS::DEDICATED_COMPRESSOR_3KB,
            uWS::DEDICATED_COMPRESSOR_4KB,
            uWS::DEDICATED_COMPRESSOR_8KB,
            uWS::DEDICATED_COMPRESSOR_16KB,
            uWS::DEDICATED_COMPRESSOR_32KB,
            uWS::DEDICATED_COMPRESSOR_64KB,
            uWS::DEDICATED_COMPRESSOR_128KB,
            uWS::DEDICATED_COMPRESSOR_256KB
        };

        auto compressor = compressors[data[0] % 8];
        data++;
        size--;

        /* Bits 0 - 256 are okay */
        std::bitset<257> b;

        /* If we could specify LARGE_BUFFER_SIZE small here we could force it to inflate in chunks,
        * triggering more line coverage. Currently it is set to 16kb which is always too much */
        struct StaticData {
            uWS::DeflationStream deflationStream;
            uWS::InflationStream inflationStream;
            uWS::ZlibContext zlibContext;
        } staticData = {compressor, compressor};

        /* Why is this padded? */
        makeChunked(makePadded(data, size), size, [&staticData, &b](const uint8_t *data, size_t size) {
            auto inflation = staticData.inflationStream.inflate(&staticData.zlibContext, std::string_view((char *) data, size), 256, true);

            /* Trigger ASAN flaws if length is more than 256 */
            if (inflation.has_value()) {
                b.set(inflation->length());
            }
        });

        makeChunked(makePadded(data, size), size, [&staticData](const uint8_t *data, size_t size) {
            /* Always reset */
            staticData.deflationStream.deflate(&staticData.zlibContext, std::string_view((char *) data, size), true);
        });

    }

    return 0;
}


```

`fuzzing/QueryParser.cpp`:

```cpp
#include "../src/QueryParser.h"

#include <string>

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    std::string modifiableInput((char *) data, size);

    uWS::getDecodedQueryValue("", modifiableInput);
    uWS::getDecodedQueryValue("hello", modifiableInput);

    return 0;
}
```

`fuzzing/QueryParser.dict`:

```dict
"?"
"%FF"
"&"
"+"
"hello"
"="


```

`fuzzing/README.md`:

```md
# Fuzz-testing of various parsers, mocked examples and system libraries

A secure web server must be capable of receiving mass amount of malicious input without misbehaving or performing illegal actions, such as stepping outside of a memory block or otherwise spilling the beans.

### Continuous fuzzing under various sanitizers is done as part of the [Google OSS-Fuzz](https://github.com/google/oss-fuzz#oss-fuzz---continuous-fuzzing-for-open-source-software) project:
* UndefinedBehaviorSanitizer
* AddressSanitizer
* MemorySanitizer

### Overall coverage is about 95% for both uSockets and uWebSockets, all source code included
* No defects or outstanding bugs
* No timeouts, OOM, crashes or other issues
* Transparent reporting of found issues: https://bugs.chromium.org/p/oss-fuzz/issues/list?q=label%3AProj-uwebsockets&can=1

### Currently the following parts are individually fuzzed:

* WebSocket handshake generator
* WebSocket message parser
* WebSocket extensions parser & negotiator
* WebSocket permessage-deflate compression/inflation helper
* Http parser (with and without Proxy Protocol v2)
* Http method/url router
* Pub/sub "topic tree"

### While some targets are entire (mocked) example apps
* libEpollFuzzer mocks the kernel syscalls and allows to cover a lot of uSockets source code.
* A mock implementation of uSockets allows to cover a lot of the inbetween logic of uWebSockets.

```

`fuzzing/TopicTree.cpp`:

```cpp
#define WIN32_EXPORT

#include "helpers.h"

/* Test for the topic tree */
#include "../src/TopicTree.h"

#include <memory>

// std::vector<std::string_view> topics = {"", "one", "two", "three"};

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    /* Create topic tree */
    uWS::TopicTree<std::string, std::string_view> topicTree([](uWS::Subscriber *s, std::string &message, auto flags) {

        /* Depending on what publishing we do below (with or without empty strings),
         * this assumption can hold true or not. For now it should hold true */
        if (!message.length()) {
            free((void *) -1);
        }

        /* Break if we have no subscriptions (not really an error, just to bring more randomness) */
        if (s->topics.size() == 0) {
            return true;
        }

        /* Success */
        return false;
    });

    /* Holder for all manually allocated subscribers */
    std::map<uint32_t, uWS::Subscriber *> subscribers;

    /* Iterate the padded fuzz as chunks */
    makeChunked(makePadded(data, size), size, [&topicTree, &subscribers](const uint8_t *data, size_t size) {
        /* We need at least 5 bytes */
        if (size > 4) {
            /* Last of all is a string */
            std::string_view lastString((char *) data + 5, size - 5);
            
            /* Why not */
            topicTree.lookupTopic(lastString);

            /* First 4 bytes is the subscriber id */
            uint32_t id;
            memcpy(&id, data, 4);

            /* Then one byte action */
            if (data[4] == 'S') {

                /* Some ridiculously long topics has to be cut short (OOM) */
                if (lastString.length() > 512) {
                    lastString = "too long!";
                }

                /* Subscribe */
                if (subscribers.find(id) == subscribers.end()) {

                    /* Limit number of subscribers to 100 (OOM) */
                    if (subscribers.size() > 100) {
                        return;
                    }

                    uWS::Subscriber *subscriber = topicTree.createSubscriber();
                    subscribers[id] = subscriber;
                    topicTree.subscribe(subscriber, lastString);
                } else {
                    /* Limit per subscriber subscriptions (OOM) */
                    uWS::Subscriber *subscriber = subscribers[id];
                    if (subscriber->topics.size() < 50) {
                        topicTree.subscribe(subscriber, lastString);
                    }
                }
            } else if (data[4] == 'U') {
                /* Unsubscribe */
                auto it = subscribers.find(id);
                if (it != subscribers.end()) {
                    topicTree.unsubscribe(it->second, lastString);
                }
            } else if (data[4] == 'F') {
                /* Free subscriber */
                auto it = subscribers.find(id);
                if (it != subscribers.end()) {
                    topicTree.freeSubscriber(it->second);
                    subscribers.erase(it);
                }
            } else if (data[4] == 'A') {
                /* Unsubscribe from all */
                auto it = subscribers.find(id);
                if (it != subscribers.end()) {
                    std::vector<std::string> topics;
                    for (auto *topic : it->second->topics) {
                        topics.push_back(topic->name);
                    }

                    for (std::string &topic : topics) {
                        topicTree.unsubscribe(it->second, topic);
                    }
                }
            } else if (data[4] == 'O') {
                /* Drain one socket */
                auto it = subscribers.find(id);
                if (it != subscribers.end()) {
                    topicTree.drain(it->second);
                }
            } else if (data[4] == 'P') {
                /* Publish only if we actually have data */
                if (lastString.length()) {
                    topicTree.publish(nullptr, lastString, std::string(lastString));
                } else {
                    /* We could use having more strings */
                    topicTree.publish(nullptr, "", "anything");
                }
            } else {
                /* Drain for everything else (OOM) */
                topicTree.drain();
            }
        }
    });

    /* Remove any subscriber from the tree */
    for (auto &p : subscribers) {
        topicTree.freeSubscriber(p.second);
    }

    return 0;
}


```

`fuzzing/TopicTree.dict`:

```dict
"S"
"P"
"A"
"U"
"+"
"/"
"#"
"\x00\x00\x00\x00"
```

`fuzzing/WebSocket.cpp`:

```cpp
/* This is a fuzz test of the websocket parser */

#define WIN32_EXPORT

#include "helpers.h"

/* We test the websocket parser */
#include "../src/WebSocketProtocol.h"

struct Impl {
    static bool refusePayloadLength(uint64_t length, uWS::WebSocketState<true> *wState, void *s) {

        /* We need a limit */
        if (length > 16000) {
            return true;
        }

        /* Return ok */
        return false;
    }

    static bool setCompressed(uWS::WebSocketState<true> *wState, void *s) {
        /* We support it */
        return true;
    }

    static void forceClose(uWS::WebSocketState<true> *wState, void *s, std::string_view reason = {}) {

    }

    static bool handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, uWS::WebSocketState<true> *webSocketState, void *s) {

        if (opCode == uWS::TEXT) {
            if (!uWS::protocol::isValidUtf8((unsigned char *)data, length)) {
                /* Return break */
                return true;
            }
        } else if (opCode == uWS::CLOSE) {
            uWS::protocol::parseClosePayload((char *)data, length);
        }

        /* Return ok */
        return false;
    }
};

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    /* Create the parser state */
    uWS::WebSocketState<true> state;

    makeChunked(makePadded(data, size), size, [&state](const uint8_t *data, size_t size) {
        /* Parse it */
        uWS::WebSocketProtocol<true, Impl>::consume((char *) data, size, &state, nullptr);
    });

    return 0;
}


```

`fuzzing/helpers.h`:

```h
#ifndef HELPERS_H
#define HELPERS_H

/* Common helpers for fuzzing */

#include <functional>
#include <string_view>
#include <cstring>

/* We use this to pad the fuzz */
static inline const uint8_t *makePadded(const uint8_t *data, size_t size) {
    static int paddedLength = 512 * 1024;
    static char *padded = new char[128 + paddedLength + 128];

    /* Increase landing area if required */
    if (paddedLength < size) {
        delete [] padded;
        paddedLength = size;
        padded = new char [128 + paddedLength + 128];
    }

    memcpy(padded + 128, data, size);

    return (uint8_t *) padded + 128;
}

/* Splits the fuzz data in one or many chunks */
static inline void makeChunked(const uint8_t *data, size_t size, std::function<void(const uint8_t *data, size_t size)> cb) {
    /* First byte determines chunk size; 0 is all that remains, 1-255 is small chunk */
    for (int i = 0; i < size; ) {
        unsigned int chunkSize = data[i++];
        if (!chunkSize) {
            chunkSize = size - i;
        } else {
            chunkSize = std::min<int>(chunkSize, size - i);
        }

        cb(data + i, chunkSize);
        i += chunkSize;
    }
}

/* Reads all bytes to trigger invalid reads */
static inline void readBytes(std::string_view s) {
    volatile int sum = 0;
    for (int i = 0; i < s.size(); i++) {
        sum += s[i];
    }
}

#endif

```

`libEpollBenchmarker/Makefile`:

```
# You need to link with wrapped syscalls
override CFLAGS += -Wl,--wrap=recv,--wrap=bind,--wrap=listen,--wrap=send,--wrap=socket,--wrap=epoll_wait,--wrap=accept4,--wrap=epoll_ctl

# Include uSockets and uWebSockets
override CFLAGS += -DUWS_NO_ZLIB -I../src -I../uSockets/src

default:
	make -C ../uSockets
	$(CXX) -flto -O3 -std=c++17 ../examples/HelloWorld.cpp epoll_benchmarker.cpp $(CFLAGS) -o HelloWorld ../uSockets/uSockets.a

```

`libEpollBenchmarker/epoll_benchmarker.cpp`:

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdarg.h>

#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <errno.h>

#ifdef __cplusplus
extern "C" {
#endif

#define NUM_SOCKETS 10
uint64_t listen_socket_epoll_data = 0;
epoll_event ready_events[NUM_SOCKETS] = {};
static int accepted_sockets = 0;

int __wrap_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) {

	// the listen socket
	if (fd == 500) {
		listen_socket_epoll_data = event->data.u64;
		return 0;
	} else {
		if (fd < 500) {

		} else {
			// on our FDs
			ready_events[fd - 500 - 1].data.u64 = event->data.u64;
			ready_events[fd - 500 - 1].events = EPOLLIN;
		}
		
		return 0;
	}
}

int __wrap_epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout) {

	if (accepted_sockets != NUM_SOCKETS) {
		events[0].events = EPOLLIN;
		events[0].data.u64 = listen_socket_epoll_data;
		return 1;
	} else {
		for (int i = 0; i < NUM_SOCKETS; i++) {
			events[i] = ready_events[i];
		}
		return NUM_SOCKETS;
	}
}

int __wrap_recv(int sockfd, void *buf, size_t len, int flags) {
	const char request[] =
    "GET /joyent/http-parser HTTP/1.1\r\n"
    "Host: github.com\r\n"
    "DNT: 1\r\n"
    "Accept-Encoding: gzip, deflate, sdch\r\n"
    "Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) "
        "AppleWebKit/537.36 (KHTML, like Gecko) "
        "Chrome/39.0.2171.65 Safari/537.36\r\n"
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,"
        "image/webp,*/*;q=0.8\r\n"
    "Referer: https://github.com/joyent/http-parser\r\n"
    "Connection: keep-alive\r\n"
    "Cache-Control: max-age=0\r\n\r\n";

	memcpy(buf, request, sizeof(request) - 1);
	return sizeof(request) - 1;
}

int __wrap_send(int sockfd, const void *buf, size_t len, int flags) {
	static int sent = 0;
	static clock_t lastTime = clock();
	if (++sent == 1000000) {
		// print how long it took to make 1 million requests
		clock_t newTime = clock();
		float elapsed = float(newTime - lastTime) / CLOCKS_PER_SEC;
		printf("Req/sec: %f million\n", (1000000.0f / elapsed) / 1000000.0f);
		sent = 0;
		lastTime = newTime;
	}

	return len;
}

int __wrap_bind() {
	return 0;
}

int __wrap_setsockopt() {
	return 0;
}

int __wrap_accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
	if (accepted_sockets < NUM_SOCKETS) {
		accepted_sockets++;
		return accepted_sockets + 500;
	} else {
		return -1;
	}
}

int __wrap_listen() {
	return 0;
}

int __wrap_socket(int domain, int type, int protocol) {
	return 500;
}

#ifdef __cplusplus
}
#endif

```

`misc/READMORE.md`:

```md
# µWebSockets v19 user manual

For a list of frequently asked questions you may use the Discussions tab here on GitHub. Please don't misuse the issue tracker as your personal Q&A, we use it only for bug reporting. Discussions tab is less strict about content.

## Motivation and goals

µWebSockets is a simple to use yet thoroughly optimized, standards compliant and secure implementation of WebSockets (and HTTP).
It comes with built-in pub/sub support, URL routing, TLS 1.3, SNI, IPv6, permessage-deflate and is battle tested as one of the most popular implementations, reaching many millions of end-users daily. It's currently juggling billions of USD in many popular Bitcoin exchanges, every day with outstanding real-world performance.

### Standards compliant

Unlike other "pub/sub brokers", µWS does not assume or push any particular application protocol but only operates over raw, standard WebSockets. You need nothing but a standards compliant web browser and a handful of standards compliant JavaScript to communicate with it. No particular client library is needed or enforced - this unlike inadequate solutions like Socket.IO where you end up locked to a set of proprietary non-standard protocols with horrible performance.

### Performant
The implementation is header-only C++17 (but examples use C++20 features for brevity and elegance!), cross-platform and compiles down to a tiny binary of a handful kilobytes.
It depends on µSockets, which is a standard C project for Linux, macOS & Windows.

Performance wise you can expect to outperform, or equal, just about anything similar out there, that's the fundamental goal of the project. I can show small-message cases where µWS **with SSL** significantly outperforms the fastest Golang servers running **non-SSL**. You get the SSL for free in a sense (shown to be true for messaging with up to 4 kB per message).

We've [openly presented](https://medium.com/swlh/100k-secure-websockets-with-raspberry-pi-4-1ba5d2127a23) detailed cases where a single Raspberry Pi 4 can serve more than 100k very active TLS 1.3 WebSockets, simultaneously, with excellent stability. This is entirely impossible with the vast majority of alternative solutions. Most solutions cramp up and become unreliable at a tiny fraction of this load, on such a limited hardware. We also have measurements where we [serve 12x the HTTP requests per second](https://levelup.gitconnected.com/serving-100k-requests-second-from-a-fanless-raspberry-pi-4-over-ethernet-fdd2c2e05a1e) as compared to Node.js.

### Simple to use
Another goal of the project is minimalism, simplicity and elegance.
Design wise it follows an ExpressJS-like interface where you attach callbacks to different URL routes.
This way you can easily build complete REST/WebSocket services in a few lines of code.

Boilerplate logic like heartbeat timeouts, backpressure handling, ping/pong and other annoyances are handled efficiently and easily by the library itself. You write business logic, the library handles the protocol(s).

The project is async only and runs local to one thread. You scale it as individual threads much like Node.js scales as individual processes. That is, the implementation only sees a single thread and is not thread-safe. There are simple ways to do threading via async delegates though, if you really need to.

## Compiling
µWebSockets is 100% standard header-only C++17 - it compiles on any platform. However, it depends on µSockets in all cases, which is platform-specific C code that runs on Linux, Windows and macOS.

There are a few compilation flags for µSockets (see its documentation), but common between µSockets and µWebSockets flags are as follows:

* LIBUS_NO_SSL - disable OpenSSL dependency/functionality for uSockets and uWebSockets builds
* UWS_NO_ZLIB - disable Zlib dependency/functionality for uWebSockets

You can use the Makefile on Linux and macOS. It is simple to use and builds the examples for you. `WITH_OPENSSL=1 make` builds all examples with SSL enabled. Examples will fail to listen if cert and key cannot be found, so make sure to specify a path that works for you.

## User manual

### uWS::App & uWS::SSLApp
You begin your journey by constructing an "App". Either an SSL-app or a regular TCP-only App. The uWS::SSLApp constructor takes a struct holding SSL options such as cert and key. Interfaces for both apps are identical, so let's call them both "App" from now on.

Apps follow the builder pattern, member functions return the App so that you can chain calls.

### App.get, post, put, [...] and any routes
You attach behavior to "URL routes". A lambda is paired with a "method" (Http method that is) and a pattern (the URL matching pattern).

Methods are many, but most common are probably get & post. They all have the same signature, let's look at one example:

```c++
uWS::App().get("/hello", [](auto *res, auto *req) {
    res->end("Hello World!");
});
```

Important for all routes is that "req", the `uWS::HttpRequest *` dies with return. In other words, req is stack allocated so don't keep it in your pocket.

res, the `uWS::HttpResponse<SSL> *` will be alive and accessible until either its .onAborted callback emits, or you've responded to the request via res.end or res.tryEnd.

In other words, you either respond to the request immediately and return, or you attach lambdas to the res (which may hold captured data), and respond later on in some other async callback.

Data that you capture in a res follows RAII and is move-only so you can properly move-in for instance std::string buffers that you may use to, for instance, buffer upp streaming POST data. It's pretty cool, check out mutable lambdas with move-only captures.

The "any" route will match any method.

#### Pattern matching
Routes are matched in **order of specificity**, not by the order you register them:

* Highest priority - static routes, think "/hello/this/is/static".
* Middle priority - parameter routes, think "/candy/:kind", where value of :kind is retrieved by req.getParameter(0).
* Lowest priority - wildcard routes, think "/hello/*".

In other words, the more specific a route is, the earlier it will match. This allows you to define wildcard routes that match a wide range of URLs and then "carve" out more specific behavior from that.

"Any" routes, those who match any HTTP method, will match with lower priority than routes which specify their specific HTTP method (such as GET) if and only if the two routes otherwise are equally specific.

#### Middlewares
A very commonly asked question is how to achieve something like middlewares. We don't support middlewares as something built into the router itself. Partly because routes cannot pass data to other routes, partly because the HttpRequest object being stack-allocated and only valid in one single callback invocation, but most importantly - you can **easily** achieve the same function-chaining that is middlewares by instead using simple high-order functions and functional programming. There are tons of examples of this under Discussions (since it is a commonly asked question). A middleware isn't really something that has to be built-in to the server library itself, it really is just **a regular function**. By passing functions to other functions you can build chains of behaviors in very elegant and efficient ways.

Whether this library should keep a set of commonly used functions is another question - we might do that in the future and we might add an example of its usage but right now there is nothing like this provided. We aim to provide an easy to use server implementation that you can build things on. Not complete business logic puzzle pieces.

#### Streaming data
You should never call res.end(huge buffer). res.end guarantees sending so backpressure will probably spike. Instead you should use res.tryEnd to stream huge data part by part. Use in combination with res.onWritable and res.onAborted callbacks.

Tip: Check out the JavaScript project, it has many useful examples of async streaming of huge data.

#### Corking
It is very important to understand the corking mechanism, as that is responsible for efficiently formatting, packing and sending data. Without corking your app will still work reliably, but can perform very bad and use excessive networking. In some cases the performance can be dreadful without proper corking.

That's why your sockets will be corked by default in most simple cases, including all of the examples provided. However there are cases where default corking cannot happen automatically.

* Whenever your registered business logic (your callbacks) are called from the library, such as when receiving a message or when a socket opens, you'll be corked by default. Whatever you do with the socket inside of that callback will be efficient and properly corked.

* If you have callbacks registered to some other library, say libhiredis, those callbacks will not be called with corked sockets (how could **we** know when to cork the socket if we don't control the third-party library!?).

* Only one single socket can be corked at any point in time (isolated per thread, of course). It is efficient to cork-and-uncork.

* Whenever your callback is a coroutine, such as the JavaScript async/await, automatic corking can only happen in the very first portion of the coroutine (consider await a separator which essentially cuts the coroutine into smaller segments). Only the first "segment" of the coroutine will be called from µWS, the following async segments will be called by the JavaScript runtime at a later point in time and will thus not be under our control with default corking enabled.

* Corking is important even for calls which seem to be "atomic" and only send one chunk. res->end, res->tryEnd, res->writeStatus, res->writeHeader will most likely send multiple chunks of data and is very important to properly cork.

You can make sure corking is enabled, even for cases where default corking would be enabled, by wrapping whatever sending function calls in a lambda like so:

```c++
res->cork([res]() {
    res->end("This Http response will be properly corked and efficient in all cases");
});
```

The above res->end call will actually call three separate send functions; res->writeStatus, res->writeHeader and whatever it does itself. By wrapping the call in res->cork you make sure these three send functions are efficient and only result in one single send syscall and one single SSL block if using SSL.

Keep this in mind, corking is by far the single most important performance trick to use. Even when streaming huge amounts of data it can be useful to cork. At least in the very tip of the response, as that holds the headers and status.

### The App.ws route
WebSocket "routes" are registered similarly, but not identically.

Every websocket route has the same pattern and pattern matching as for Http, but instead of one single callback you have a whole set of them, here's an example:

```c++
uWS::App().ws<PerSocketData>("/*", {
    /* Settings */
    .compression = uWS::SHARED_COMPRESSOR,
    .maxPayloadLength = 16 * 1024,
    .idleTimeout = 10,
    /* Handlers */
    .upgrade = [](auto *res, auto *req, auto *context) {
        /* You may read from req only here, and COPY whatever you need into your PerSocketData.
         * See UpgradeSync and UpgradeAsync examples. */
    },
    .open = [](auto *ws) {

    },
    .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
        ws->send(message, opCode);
    },
    .drain = [](auto *ws) {
        /* Check getBufferedAmount here */
    },
    .ping = [](auto *ws, std::string_view message) {

    },
    .pong = [](auto *ws, std::string_view message) {

    },
    .close = [](auto *ws, int code, std::string_view message) {

    }
});
```

WebSocket routes specify a user data type that should be used to keep per-websocket data. Many times people tend to attach user data
which should belong to the websocket by putting the pointer and the user data in a std::map. That's wrong! Don't do that!

#### Use the WebSocket.getUserData() feature
You should use the provided user data feature to store and attach any per-socket user data. Going from user data to WebSocket is possible if you make your user data hold a pointer to WebSocket, and hook things up in the WebSocket open handler. Your user data memory is valid while your WebSocket is.

If you want to create something more elaborate you could have the user data hold a pointer to some dynamically allocated memory block that keeps a boolean whether the WebSocket is still valid or not. Sky is the limit here, you should never need any std::map for this.

#### WebSockets are valid from open to close
All given WebSocket pointers are guaranteed to live from open event (where you got your WebSocket) until close event is called. So is the user data memory. One open event will always end in exactly one close event, they are 1-to-1 and will always be balanced no matter what. Use them to drive your RAII data types, they can be seen as constructor and destructor.

Message events will never emit outside of open/close. Calling WebSocket.close or WebSocket.end will immediately call the close handler.

#### Backpressure in websockets
Similarly to for Http, methods such as ws.send(...) can cause backpressure. Make sure to check ws.getBufferedAmount() before sending, and check the return value of ws.send before sending any more data. WebSockets do not have .onWritable, but instead make use of the .drain handler of the websocket route handler.

Inside of .drain event you should check ws.getBufferedAmount(), it might have drained, or even increased. Most likely drained but don't assume that it has, .drain event is only a hint that it has changed.

#### Ping/pongs "heartbeats"
The library will automatically send pings to clients according to the `idleTimeout` specified. If you set idleTimeout = 120 seconds a ping will go out a few seconds before this timeout unless the client has sent something to the server recently. If the client responds to the ping, the socket will stay open. When client fails to respond in time, the socket will be forcefully closed and the close event will trigger. On disconnect all resources are freed, including subscriptions to topics and any backpressure. You can easily let the browser reconnect using 3-lines-or-so of JavaScript if you want to.

#### Backpressure
Sending on a WebSocket can build backpressure. WebSocket::send returns an enum of BACKPRESSURE, SUCCESS or DROPPED. When send returns BACKPRESSURE it means you should stop sending data until the drain event fires and WebSocket::getBufferedAmount() returns a reasonable amount of bytes. But in case you specified a maxBackpressure when creating the WebSocketContext, this limit will automatically be enforced. That means an attempt at sending a message which would result in too much backpressure will be canceled and send will return DROPPED. This means the message was dropped and will not be put in the queue. maxBackpressure is an essential setting when using pub/sub as a slow receiver otherwise could build up a lot of backpressure. By setting maxBackpressure the library will automatically manage an enforce a maximum allowed backpressure per socket for you.

#### Threading
The library is single threaded. You cannot, absolutely not, mix threads. A socket created from an App on thread 1 cannot be used in any way from thread 2. The only function in the whole entire library which is thread-safe and can be used from any thread is Loop:defer. Loop::defer takes a function (such as a lambda with data) and defers the execution of said function until the specified loop's thread is ready to execute the function in a single-threaded fashion on correct thread. So in case you want to publish a message under a topic, or send on some other thread's sockets you can, but it requires a bit of indirection. You should aim for having as isolated apps and threads as possible.

#### Settings
Compression (permessage-deflate) has three main modes; uWS::DISABLED, uWS::SHARED_COMPRESSOR and any of the uWS::DEDICATED_COMPRESSOR_xKB. Disabled and shared options require no memory, while dedicated compressor requires the amount of memory you selected. For instance, uWS::DEDICATED_COMPRESSOR_4KB adds an overhead of 4KB per WebSocket while uWS::DEDICATED_COMPRESSOR_256KB adds - you guessed it - 256KB!

Compressing using shared means that every WebSocket message is an isolated compression stream, it does not have a sliding compression window, kept between multiple send calls like the dedicated variants do.

You probably want shared compressor if dealing with larger JSON messages, or 4kb dedicated compressor if dealing with smaller JSON messages and if doing binary messaging you probably want to disable it completely.

* idleTimeout is roughly the amount of seconds that may pass between messages. Being idle for more than this, and the connection is severed. This means you should make your clients send small ping messages every now and then, to keep the connection alive. You can also make the server send ping messages but I would definitely put that labor on the client side. (outdated text - this is not entirely true anymore. The server will automatically send pings in case it needs to).

### Listening on a port
Once you have defined your routes and their behavior, it is time to start listening for new connections. You do this by calling

```c++
App.listen(port, [](auto *listenSocket) {
    /* listenSocket is either nullptr or us_listen_socket */
})
```

Canceling listening is done with the uSockets function call `us_listen_socket_close`.

### App.run and fallthrough
When you are done and want to enter the event loop, you call, once and only once, App.run.
This will block the calling thread until "fallthrough". The event loop will block until no more async work is scheduled, just like for Node.js.

Many users ask how they should stop the event loop. That's not how it is done, you never stop it, you let it fall through. By closing all sockets, stopping the listen socket, removing any timers, etc, the loop will automatically cause App.run to return gracefully, with no memory leaks.

Because the App itself is under RAII control, once the blocking .run call returns and the App goes out of scope, all memory will gracefully be deleted.

### Putting it all together

```c++
int main() {
    uWS::App().get("/*", [](auto *res, auto *req) {
        res->end("Hello World!");
    }).listen(9001, [](auto *listenSocket) {
        if (listenSocket) {
            std::cout << "Listening for connections..." << std::endl;
        }
    }).run();

    std::cout << "Shoot! We failed to listen and the App fell through, exiting now!" << std::endl;
}
```

### Scaling up

One event-loop per thread, isolated and without shared data. That's the design here. Just like Node.js, but instead of per-process, it's per thread (well, obviously you can do it per-process also).

If you want to, you can simply take the previous example, put it inside of a few `std::thread` and listen to separate ports, or share the same port (works on Linux). More features like these will probably come, such as master/slave set-ups but it really isn't that hard to understand the concept - keep things isolated and spawn multiple instances of whatever code you have.

Recent Node.js versions may scale using multiple threads, via the new Worker threads support. Scaling using that feature is identical to scaling using multiple threads in C++.

### Compression
We aren't as careful with resources as we used to be. Just look at, how many web developers represent time - it is not uncommon for web developers to send an entire textual representation of time as 30-something actual letters inside a JSON document with an actual textual key. This is just awful. We have had standardized, time-zone neutral representation of time in binary, efficient, 4-byte (or more commonly the 8 byte variant) representation since the 1970s. It's called unix timestamp and is an elegant and efficient way of representing time-zone neutral time down to the seconds.

This is just an example of how we have regressed in our algorithmic thinking. Today it is common to use textual representations such as bloated JSON to represent data, even though most of that bloat is obvious repetitions and inefficient in nature. But we don't care because we have compression. True, even the most bloated source format can be compressed down to a small payload with few repetitions - however - this comes at TREMENDOUS cost.

Compression should be seen as a last resort, a temporary duct-tape solution for when you cannot sit down and consider something better. Designing clever, binary and minimally repetitive protocols saves enormous amounts of CPU-time otherwise lost to compression.

In essence, compression is really just dynamically scanning for repetitions and gradually building up a dynamic palette of commonly repetitive chunks. That takes a lot of CPU-time and is incredibly inefficient. Overall, you're looking at only 20-30% remaining I/O performance if you use compression. Instead of letting some generic dynamic algorithm scan your inefficient data representation, you could have taken the time to design something that didn't suck in the first place.

You could have defined a static palette and referenced that efficiently using binary integers, instead of letting every single individual socket try and dynamically figure out and build that palette, dynamically and inefficiently, in its own memory consuming sliding window.

ProtoBuf and the like, where integral references can be used instead of textual strings is key if you plan on making something efficient. If you plan on using JSON that has to be compressed you might as well just shove your computer down a shredder and go do something else. That's my opinion and I have many of those.

It is true that we can do more permessage-deflate messages/second than many other solutions can do uncompressed messages/second, and yes we are entirely stable while doing so - but still - JSON is terrible.

So you might say - hey - that's too complex. Well build an SDK for your users then. Just wrap that "complex" protocol up in a JavaScript library that internally knows about this palette and exposes only simple-to-use functions for the end user. It's not that hard of a problem to solve.

##### What about TLS/SSL then? I still have to encrypt!
TLS is nothing like compression. With TLS 1.3 you're still looking at around 80% performance retention over non-TLS. This because TLS is block based and efficiently maps to modern CPUs. Modern CPUs also have hardware offloads for this. It's not that demanding to encrypt traffic using modern encryption standards. Compression is by far the most CPU-demanding thing you can do with your connection, and it requires TONS of per-socket memory.

```

`misc/cert.pem`:

```pem
-----BEGIN CERTIFICATE-----
MIIDXTCCAkWgAwIBAgIJAKLdQVPy90jjMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQwHhcNMTkwMjAzMTQ0OTM1WhcNMjAwMjAzMTQ0OTM1WjBF
MQswCQYDVQQGEwJBVTETMBEGA1UECAwKU29tZS1TdGF0ZTEhMB8GA1UECgwYSW50
ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEA7i7IIEdICTiSTVx+ma6xHxOtcbd6wGW3nkxlCkJ1UuV8NmY5ovMsGnGD
hJJtUQ2j5ig5BcJUf3tezqCNW4tKnSOgSISfEAKvpn2BPvaFq3yx2Yjz0ruvcGKp
DMZBXmB/AAtGyN/UFXzkrcfppmLHJTaBYGG6KnmU43gPkSDy4iw46CJFUOupc51A
FIz7RsE7mbT1plCM8e75gfqaZSn2k+Wmy+8n1HGyYHhVISRVvPqkS7gVLSVEdTea
UtKP1Vx/818/HDWk3oIvDVWI9CFH73elNxBkMH5zArSNIBTehdnehyAevjY4RaC/
kK8rslO3e4EtJ9SnA4swOjCiqAIQEwIDAQABo1AwTjAdBgNVHQ4EFgQUv5rc9Smm
9c4YnNf3hR49t4rH4yswHwYDVR0jBBgwFoAUv5rc9Smm9c4YnNf3hR49t4rH4ysw
DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEATcL9CAAXg0u//eYUAlQa
L+l8yKHS1rsq1sdmx7pvsmfZ2g8ONQGfSF3TkzkI2OOnCBokeqAYuyT8awfdNUtE
EHOihv4ZzhK2YZVuy0fHX2d4cCFeQpdxno7aN6B37qtsLIRZxkD8PU60Dfu9ea5F
DDynnD0TUabna6a0iGn77yD8GPhjaJMOz3gMYjQFqsKL252isDVHEDbpVxIzxPmN
w1+WK8zRNdunAcHikeoKCuAPvlZ83gDQHp07dYdbuZvHwGj0nfxBLc9qt90XsBtC
4IYR7c/bcLMmKXYf0qoQ4OzngsnPI5M+v9QEHvYWaKVwFY4CTcSNJEwfXw+BAeO5
OA==
-----END CERTIFICATE-----

```

`misc/key.pem`:

```pem
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDuLsggR0gJOJJN
XH6ZrrEfE61xt3rAZbeeTGUKQnVS5Xw2Zjmi8ywacYOEkm1RDaPmKDkFwlR/e17O
oI1bi0qdI6BIhJ8QAq+mfYE+9oWrfLHZiPPSu69wYqkMxkFeYH8AC0bI39QVfOSt
x+mmYsclNoFgYboqeZTjeA+RIPLiLDjoIkVQ66lznUAUjPtGwTuZtPWmUIzx7vmB
+pplKfaT5abL7yfUcbJgeFUhJFW8+qRLuBUtJUR1N5pS0o/VXH/zXz8cNaTegi8N
VYj0IUfvd6U3EGQwfnMCtI0gFN6F2d6HIB6+NjhFoL+QryuyU7d7gS0n1KcDizA6
MKKoAhATAgMBAAECggEAd5g/3o1MK20fcP7PhsVDpHIR9faGCVNJto9vcI5cMMqP
6xS7PgnSDFkRC6EmiLtLn8Z0k2K3YOeGfEP7lorDZVG9KoyE/doLbpK4MfBAwBG1
j6AHpbmd5tVzQrnNmuDjBBelbDmPWVbD0EqAFI6mphXPMqD/hFJWIz1mu52Kt2s6
++MkdqLO0ORDNhKmzu6SADQEcJ9Suhcmv8nccMmwCsIQAUrfg3qOyqU4//8QB8ZM
josO3gMUesihVeuF5XpptFjrAliPgw9uIG0aQkhVbf/17qy0XRi8dkqXj3efxEDp
1LSqZjBFiqJlFchbz19clwavMF/FhxHpKIhhmkkRSQKBgQD9blaWSg/2AGNhRfpX
Yq+6yKUkUD4jL7pmX1BVca6dXqILWtHl2afWeUorgv2QaK1/MJDH9Gz9Gu58hJb3
ymdeAISwPyHp8euyLIfiXSAi+ibKXkxkl1KQSweBM2oucnLsNne6Iv6QmXPpXtro
nTMoGQDS7HVRy1on5NQLMPbUBQKBgQDwmN+um8F3CW6ZV1ZljJm7BFAgNyJ7m/5Q
YUcOO5rFbNsHexStrx/h8jYnpdpIVlxACjh1xIyJ3lOCSAWfBWCS6KpgeO1Y484k
EYhGjoUsKNQia8UWVt+uWnwjVSDhQjy5/pSH9xyFrUfDg8JnSlhsy0oC0C/PBjxn
hxmADSLnNwKBgQD2A51USVMTKC9Q50BsgeU6+bmt9aNMPvHAnPf76d5q78l4IlKt
wMs33QgOExuYirUZSgjRwknmrbUi9QckRbxwOSqVeMOwOWLm1GmYaXRf39u2CTI5
V9gTMHJ5jnKd4gYDnaA99eiOcBhgS+9PbgKSAyuUlWwR2ciL/4uDzaVeDQKBgDym
vRSeTRn99bSQMMZuuD5N6wkD/RxeCbEnpKrw2aZVN63eGCtkj0v9LCu4gptjseOu
7+a4Qplqw3B/SXN5/otqPbEOKv8Shl/PT6RBv06PiFKZClkEU2T3iH27sws2EGru
w3C3GaiVMxcVewdg1YOvh5vH8ZVlxApxIzuFlDvnAoGAN5w+gukxd5QnP/7hcLDZ
F+vesAykJX71AuqFXB4Wh/qFY92CSm7ImexWA/L9z461+NKeJwb64Nc53z59oA10
/3o2OcIe44kddZXQVP6KTZBd7ySVhbtOiK3/pCy+BQRsrC7d71W914DxNWadwZ+a
jtwwKjDzmPwdIXDSQarCx0U=
-----END PRIVATE KEY-----

```

`misc/logo.svg`:

```svg
<svg version="1.1" viewBox="0.0 0.0 187.65616797900262 113.39370078740157" fill="none" stroke="none" stroke-linecap="square" stroke-miterlimit="10" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg"><clipPath id="p.0"><path d="m0 0l187.65617 0l0 113.3937l-187.65617 0l0 -113.3937z" clip-rule="nonzero"/></clipPath><g clip-path="url(#p.0)"><path fill="#000000" fill-opacity="0.0" d="m0 0l187.65617 0l0 113.3937l-187.65617 0z" fill-rule="evenodd"/><g filter="url(#shadowFilter-p.1)"><use xlink:href="#p.1" transform="matrix(1.0 0.0 0.0 1.0 0.0 2.0)"/></g><defs><filter id="shadowFilter-p.1" filterUnits="userSpaceOnUse"><feGaussianBlur in="SourceAlpha" stdDeviation="2.0" result="blur"/><feComponentTransfer in="blur" color-interpolation-filters="sRGB"><feFuncR type="linear" slope="0" intercept="0.0"/><feFuncG type="linear" slope="0" intercept="0.0"/><feFuncB type="linear" slope="0" intercept="0.0"/><feFuncA type="linear" slope="0.5" intercept="0"/></feComponentTransfer></filter></defs><g id="p.1"><defs><linearGradient id="p.2" gradientUnits="userSpaceOnUse" gradientTransform="matrix(10.20750017422515 0.0 0.0 10.20750017422515 0.0 0.0)" spreadMethod="pad" x1="0.6655852909187749" y1="0.31561582701378876" x2="0.6655483156810289" y2="10.523116001171969"><stop offset="0.0" stop-color="#3177ee"/><stop offset="1.0" stop-color="#113d8a"/></linearGradient></defs><path fill="url(#p.2)" d="m103.745865 15.829906c1.2349167 0 1.8523712 1.2349148 1.8523712 3.7047462c0 4.1163883 -2.2017822 10.58773 -6.605362 19.414024c-0.29676056 -3.4079819 -0.44514465 -6.2320175 -0.44514465 -8.4720955c0 -9.76445 1.7327118 -14.646675 5.1981354 -14.646675zm47.55861 -12.607628c-1.3497925 0 -2.733078 0.34941483 -4.149887 1.0482426c-5.7629395 2.7091556 -11.377502 7.533942 -16.843674 14.474361c-4.4705887 5.8778133 -8.94117 12.966614 -13.411758 21.266397c-4.882225 9.4676895 -8.409874 16.231007 -10.582939 20.289951c-3.771759 7.055298 -6.772888 11.377502 -9.003395 12.966614c2.5847015 -4.1163864 3.87706 -9.20443 3.87706 -15.264133c0 -1.177475 -0.24890137 -3.4558449 -0.7466965 -6.8351135c-0.4977951 -3.3792686 -0.89507294 -6.480915 -1.1918335 -9.304947c5.7054977 -9.821888 8.55825 -17.087786 8.55825 -21.797697c0 -3.23567 -1.2923508 -4.853506 -3.87706 -4.853506c-0.6509628 0 -1.3880844 0.26804543 -2.2113647 0.80413055c-2.9389038 1.7039948 -5.025818 5.3465176 -6.2607346 10.927568c-0.8807144 4.0015106 -1.3210678 7.8881474 -1.3210678 11.659903c0 3.7621841 0.11487579 6.701092 0.34462738 8.816723c-3.1112213 5.466175 -6.6388702 10.908421 -10.582947 16.326736c-6.117134 8.519962 -11.119026 13.603222 -15.005661 15.249767c-0.64138794 0.29676056 -0.9620819 0.5935211 -0.9620819 0.8902893c0 0.29676056 0.08615875 0.44514465 0.25846863 0.44514465c2.125206 0 6.744171 -4.5328064 13.856903 -13.598427c5.351303 -6.7010956 9.558632 -12.492756 12.621986 -17.37498c0.11487579 1.646553 0.6126709 4.824787 1.4933853 9.5346985c0.6509628 4.0589447 0.97644806 7.304188 0.97644806 9.735729c0 2.4411163 -0.32548523 4.164253 -0.97644806 5.1694183c-0.46907043 0.11487579 -0.7036133 0.36377716 -0.7036133 0.74668884c0 0.3829193 0.05744171 0.57437897 0.1723175 0.57437897c2.4123917 0 6.7633133 -5.6480637 13.0527725 -16.944191c1.177475 -2.0581932 3.3074646 -5.9208946 6.389969 -11.588104c3.0920715 -5.6767807 5.523613 -10.046848 7.2946167 -13.110207c5.7629395 -9.707012 11.468445 -16.88197 17.1165 -21.524868c4.4035797 -3.4079847 8.285431 -5.1119766 11.645554 -5.1119766c4.0589447 0 6.0884094 1.9672489 6.0884094 5.9017477l-0.52537537 2.880206l0 0c-2.3648834 0.9902582 -4.4858246 2.3851423 -6.3628387 4.184661l-0.1723175 0c-2.115631 0 -3.9392853 0.83763504 -5.4709625 2.512909c-1.5316772 1.6752758 -2.2975159 3.5994453 -2.2975159 5.7725143c0 4.413147 1.8810883 8.003017 5.64328 10.769611c1.1200409 0.8232765 2.8383942 2.0151138 5.15506 3.575512c2.326233 1.5603981 4.049362 2.7809525 5.169403 3.6616707c3.7047577 2.757019 5.557129 6.313385 5.557129 10.669098c0 3.1207962 -1.2636414 6.0932083 -3.7909088 8.917236c-2.5272675 2.8240356 -5.38002 4.882225 -8.558258 6.1745834c-1.2923431 0.41163635 -2.8527374 0.7323303 -4.681183 0.9620819c-0.41163635 0 -0.61746216 0.17710114 -0.61746216 0.5313034c0 0.18188477 0.14837646 0.27282715 0.44514465 0.27282715c4.298279 0 8.5056 -1.780571 12.621994 -5.341728c4.116379 -3.5611496 6.174576 -7.4286423 6.174576 -11.602463c0 -4.1738205 -1.8810883 -7.821129 -5.64328 -10.941925c-5.829956 -3.9440765 -9.362381 -6.385189 -10.597305 -7.3233376c-3.8196106 -2.8814735 -5.729431 -6.3516846 -5.729431 -10.410627c0 -1.7614326 0.5887451 -3.4654255 1.7662201 -5.1119766c1.234909 -1.5316811 2.7330933 -2.3836746 4.494522 -2.5559883l0 0c-1.9433136 2.1156292 -2.914978 4.4657993 -2.914978 7.0505066c0 3.8866348 2.0007477 7.179743 6.0022583 9.879324c1.0626068 0.7084007 2.857544 1.8571587 5.3848114 3.4462776c2.5272675 1.5891151 4.437088 2.8527489 5.729431 3.790905c4.0589447 2.824028 6.0884247 6.5287743 6.0884247 11.114239c0 7.4765053 -4.4083557 12.976185 -13.225082 16.49905c-5.1215515 2.115631 -9.946335 3.1734467 -14.474365 3.1734467c-4.528015 0 -8.4673 -1.3402252 -11.817856 -4.0206604c-3.3505402 -2.6708603 -5.025818 -6.428253 -5.025818 -11.27219c0 -4.853508 1.8523712 -8.7257805 5.5571136 -11.616825c3.4654236 -2.8144608 7.5818176 -4.2216873 12.349167 -4.2216873l1.4933777 0c0.94773865 0 1.4216003 -0.062229156 1.4216003 -0.18667603c0 -0.46907425 -1.3833008 -0.7036133 -4.1499023 -0.7036133c-4.997101 0 -9.395889 1.6321907 -13.196365 4.8965836c-3.7909012 3.2643929 -5.6863556 7.4717216 -5.6863556 12.621986c0 5.1406937 2.3549576 9.065628 7.064865 11.77478c3.7621918 2.230507 8.831085 3.3457565 15.206696 3.3457565c6.385193 0 12.373093 -1.646553 17.963715 -4.939659c6.7010956 -3.9345016 10.051651 -9.1661415 10.051651 -15.69492c0 -4.824787 -1.9720459 -8.855011 -5.916107 -12.090683c-4.700348 -2.9389114 -8.376373 -5.293865 -11.028091 -7.064869c-3.9919434 -2.6995811 -5.9879 -5.844309 -5.9879 -9.434181c0 -1.589117 0.41163635 -3.1160088 1.234909 -4.580675c2.699585 -4.7673492 7.725403 -7.151024 15.077454 -7.151024c2.6517181 0 5.0354004 0.38292122 7.1510315 1.1487598c3.0537872 1.0530262 4.580673 2.6421452 4.580673 4.7673473c0 1.4646683 -0.8232727 2.5655632 -2.4698334 3.3026829c-1.6465454 0.73711777 -3.4654083 1.1056805 -5.456604 1.1056805c-5.88739 0 -10.448914 -1.0578175 -13.684586 -3.1734467c-0.057434082 -0.06701279 -0.16275024 -0.10051727 -0.3159027 -0.10051727c-0.14360046 0 -0.21539307 0.062223434 -0.21539307 0.18667412c0 0.11487579 0.06222534 0.22975159 0.18666077 0.34462738c1.8188782 1.2923546 4.0828857 2.2065754 6.792038 2.7426624c2.5847168 0.64138985 5.05455 0.9620838 7.4095 0.9620838c2.35495 0 4.413147 -0.34941292 6.174576 -1.0482407c2.4698334 -0.8902893 3.7047424 -2.3023033 3.7047424 -4.2360497c0 -1.0051632 -0.354187 -1.948103 -1.0625916 -2.8288174c-2.2879486 -2.8814716 -6.729828 -4.3222055 -13.325607 -4.3222055c-3.337906 0 -6.3659973 0.5138922 -9.08429 1.5416708l0 0c0.044937134 -0.20180702 0.08959961 -0.41893482 0.13400269 -0.65138245c0.32546997 -1.7135639 0.4882202 -2.8910418 0.4882202 -3.5324335c0 -2.2400799 -0.5887451 -4.125959 -1.7662201 -5.6576366c-1.0626068 -1.5221055 -2.7091522 -2.2831583 -4.9396667 -2.2831583zm-88.39699 5.02582c-0.8232727 0 -1.2349129 0.29197693 -1.2349129 0.8759289c0 0.18188572 0.14359283 0.3302679 0.43078232 0.4451437c3.178234 0.5935259 5.590626 3.1543016 7.237179 7.6823244c-1.1200409 -0.18188858 -2.2352905 -0.27283096 -3.3457565 -0.27283096c-4.7673492 0 -9.386318 1.4263744 -13.856903 4.279127c-4.470585 2.8527527 -7.677536 6.3995457 -9.620857 10.640379c-1.4072266 3.1686592 -2.1108437 6.0501328 -2.1108437 8.644409c0 2.5847092 0.24889755 4.6141853 0.74669266 6.088421c0.49779892 1.4646683 1.541256 2.699585 3.130371 3.7047462c1.3593636 0.9381561 3.1255798 1.4072304 5.298649 1.4072304c2.1730652 0 4.8487167 -1.0721703 8.026951 -3.2165222c3.1782303 -2.153923 5.4709625 -4.403576 6.8781967 -6.7489586c0.12445068 -0.23932648 0.1866684 -0.44514465 0.1866684 -0.61745834c0 -0.18188858 -0.062217712 -0.27283096 -0.1866684 -0.27283096c-0.11487579 0 -0.25847626 0.11966324 -0.43078613 0.3589859c-1.7710037 2.4123955 -3.8627014 4.4418716 -6.275097 6.0884247c-2.4123917 1.6465492 -4.781708 2.4698296 -7.1079445 2.4698296c-2.3166618 0 -4.197754 -0.7036133 -5.643276 -2.1108437c-1.4359512 -1.4168015 -2.153923 -3.7143173 -2.153923 -6.8925514c0 -5.590626 2.0438309 -10.750467 6.1315002 -15.4795265c4.0876656 -4.7386303 8.898094 -7.1079445 14.431282 -7.1079445c2.5272713 0 4.762562 0.61745834 6.7058754 1.8523731c0.9381561 3.829197 1.4072342 8.553467 1.4072342 14.1728115c0 5.6097717 -1.0290985 12.353947 -3.087288 20.232513c-1.1200409 4.413151 -2.8719025 10.324467 -5.2555733 17.733967c-2.3836746 7.4094925 -3.575512 11.425362 -3.575512 12.047607c0 0.6222458 0.057437897 0.93336487 0.17231369 0.93336487c0.12445068 0 0.27283096 -0.1483841 0.44514465 -0.44514465c3.829197 -6.4139023 6.8446846 -14.383415 9.046474 -23.908543c2.211357 -9.5346985 3.3170395 -18.504585 3.3170395 -26.909676c0 -4.7673473 -0.35420227 -9.032114 -1.0625992 -12.7943l0 0c3.87706 3.4079838 5.81559 9.170923 5.81559 17.288822c0 4.4705887 -0.8519974 9.91283 -2.5559921 16.326733c-1.1200333 3.87706 -2.6804352 8.711418 -4.6811905 14.503082c-1.9911804 5.8012314 -2.9867706 8.859802 -2.9867706 9.175705c0 0.32548523 0.23453522 0.48822784 0.7036133 0.48822784c0.1723175 0 0.34941864 -0.08615875 0.5313034 -0.25847626c5.2268524 -10.118645 8.429016 -16.647423 9.606491 -19.586334c3.0633621 -7.4094925 4.5950394 -14.407352 4.5950394 -20.993565c0 -11.411007 -3.9727936 -18.236547 -11.918373 -20.476627c-1.7614288 -6.2320166 -4.346138 -9.348024 -7.7541237 -9.348024zm-36.48411 29.724134c-1.091322 0 -1.814085 0.7658386 -2.1682816 2.2975159c-0.995594 3.829193 -3.082508 8.39072 -6.2607365 13.684589c-0.35419846 0.64138794 -0.62224007 1.139183 -0.80413055 1.4933853c-0.17231369 0.35419846 -0.36377716 0.6796799 -0.57437897 0.97644806c-0.20103264 0.28718948 -0.3589878 0.5504494 -0.4738636 0.7897682c0 0.2297554 0.16274261 0.3446312 0.48822212 0.3446312c0.3254795 0 1.9002342 -2.4411125 4.72427 -7.3233376c1.7614288 -2.9963455 2.8479614 -5.1119766 3.2596035 -6.3468933l0 0c0 3.5898705 -0.61745834 7.1941032 -1.8523731 10.812691c-1.2349148 3.6185913 -3.001133 7.8689995 -5.2986507 12.7512245l-5.4709625 11.817856c-3.4654255 7.466934 -5.198134 13.08149 -5.198134 16.843674l0 0.27283478c0 2.9389114 1.1056805 5.509262 3.317041 7.7110443c2.2017899 2.2113647 4.7146997 3.317047 7.5387297 3.317047c1.1104698 0 2.5033398 -0.39728546 4.17861 -1.1918411c1.6848488 -0.79455566 2.8192482 -1.7231369 3.4031982 -2.785736l0 0c-3.178236 1.943306 -5.8826065 2.9149704 -8.11311 2.9149704c-3.4175568 0 -5.126335 -2.5320663 -5.126335 -7.596176c0 -5.054535 1.297142 -11.229111 3.8914204 -18.523735c0.17231369 -0.46907043 0.49301147 -1.5125275 0.9620857 -3.1303635c0.46907425 -1.617836 1.732708 -4.8965836 3.790903 -9.83625c6.6532307 -4.882225 11.15732 -9.616066 13.512276 -14.20153l0 0c-0.29676056 3.2356758 -0.44514465 5.734226 -0.44514465 7.4956512c0 4.355713 1.2349167 6.5335693 3.7047462 6.5335693c2.4698334 0 4.7338448 -1.4120178 6.792038 -4.2360497l0 -0.17231369c0 -0.35419846 -0.08615875 -0.5313034 -0.25847244 -0.5313034c0.057437897 0 -0.047863007 0.11966705 -0.31590652 0.35898972c-0.26804733 0.22975159 -0.8567848 0.7275429 -1.7662163 1.4933891c-0.9094353 0.7658386 -1.8045082 1.1487579 -2.6852264 1.1487579c-1.7710037 0 -2.6565018 -1.4120216 -2.6565018 -4.2360497c0 -4.1738205 0.6509628 -8.467308 1.9528885 -12.880459c1.110466 -1.4742393 1.665699 -3.0920715 1.665699 -4.853504c0 -0.65096664 -0.46907806 -0.97644806 -1.4072266 -0.97644806c-0.9381523 0 -1.6130447 0.20582199 -2.0246887 0.61745834c-1.0051651 1.3019257 -1.7997246 4.011078 -2.3836746 8.127468c-3.2931118 5.466175 -7.4094944 10.08036 -12.349157 13.842541c1.8188667 -5.4661713 3.0825005 -9.199638 3.790905 -11.200394c1.5316753 -4.5280266 2.2975178 -8.261494 2.2975178 -11.2003975c0 -2.9484825 -0.5456619 -4.422722 -1.636982 -4.422722z" fill-rule="evenodd"/></g></g></svg>
```

`src/App.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_APP_H
#define UWS_APP_H

#define _CRT_SECURE_NO_WARNINGS

#include <string>
#include <charconv>
#include <string_view>

namespace uWS {
    /* Safari 15.0 - 15.3 has a completely broken compression implementation (client_no_context_takeover not
     * properly implemented) - so we fully disable compression for this browser :-(
     * see https://github.com/uNetworking/uWebSockets/issues/1347 */
    inline bool hasBrokenCompression(std::string_view userAgent) {
        size_t posStart = userAgent.find(" Version/15.");
        if (posStart == std::string_view::npos) return false;
        posStart += 12;

        size_t posEnd = userAgent.find(' ', posStart);
        if (posEnd == std::string_view::npos) return false;

        unsigned int minorVersion = 0;
        auto result = std::from_chars(userAgent.data() + posStart, userAgent.data() + posEnd, minorVersion);
        if (result.ec != std::errc()) return false;
        if (result.ptr != userAgent.data() + posEnd) return false; // do not accept trailing chars
        if (minorVersion > 3) return false; // we target just Safari 15.0 - 15.3

        if (userAgent.find(" Safari/", posEnd) == std::string_view::npos) return false;

        return true;
    }
}

/* An app is a convenience wrapper of some of the most used fuctionalities and allows a
 * builder-pattern kind of init. Apps operate on the implicit thread local Loop */

#include "HttpContext.h"
#include "HttpResponse.h"
#include "WebSocketContext.h"
#include "WebSocket.h"
#include "PerMessageDeflate.h"

namespace uWS {

    /* This one matches us_socket_context_options_t but has default values */
    struct SocketContextOptions {
        const char *key_file_name = nullptr;
        const char *cert_file_name = nullptr;
        const char *passphrase = nullptr;
        const char *dh_params_file_name = nullptr;
        const char *ca_file_name = nullptr;
        const char *ssl_ciphers = nullptr;
        int ssl_prefer_low_memory_usage = 0;

        /* Conversion operator used internally */
        operator struct us_socket_context_options_t() const {
            struct us_socket_context_options_t socket_context_options;
            memcpy(&socket_context_options, this, sizeof(SocketContextOptions));
            return socket_context_options;
        }
    };

    static_assert(sizeof(struct us_socket_context_options_t) == sizeof(SocketContextOptions), "Mismatching uSockets/uWebSockets ABI");

template <bool SSL>
struct TemplatedApp {
private:
    /* The app always owns at least one http context, but creates websocket contexts on demand */
    HttpContext<SSL> *httpContext;
    /* WebSocketContexts are of differing type, but we as owners and creators must delete them correctly */
    std::vector<MoveOnlyFunction<void()>> webSocketContextDeleters;

    std::vector<void *> webSocketContexts;

public:

    TopicTree<TopicTreeMessage, TopicTreeBigMessage> *topicTree = nullptr;

    /* Server name */
    TemplatedApp &&addServerName(std::string hostname_pattern, SocketContextOptions options = {}) {

        /* Do nothing if not even on SSL */
        if constexpr (SSL) {
            /* First we create a new router for this domain */
            auto *domainRouter = new HttpRouter<typename HttpContextData<SSL>::RouterData>();

            us_socket_context_add_server_name(SSL, (struct us_socket_context_t *) httpContext, hostname_pattern.c_str(), options, domainRouter);
        }

        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&removeServerName(std::string hostname_pattern) {
    
        /* This will do for now, would be better if us_socket_context_remove_server_name returned the user data */
        auto *domainRouter = us_socket_context_find_server_name_userdata(SSL, (struct us_socket_context_t *) httpContext, hostname_pattern.c_str());
        if (domainRouter) {
            delete (HttpRouter<typename HttpContextData<SSL>::RouterData> *) domainRouter;
        }

        us_socket_context_remove_server_name(SSL, (struct us_socket_context_t *) httpContext, hostname_pattern.c_str());
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&missingServerName(MoveOnlyFunction<void(const char *hostname)> handler) {

        if (!constructorFailed()) {
            httpContext->getSocketContextData()->missingServerNameHandler = std::move(handler);

            us_socket_context_on_server_name(SSL, (struct us_socket_context_t *) httpContext, [](struct us_socket_context_t *context, const char *hostname) {

                /* This is the only requirements of being friends with HttpContextData */
                HttpContext<SSL> *httpContext = (HttpContext<SSL> *) context;
                httpContext->getSocketContextData()->missingServerNameHandler(hostname);
            });
        }

        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Returns the SSL_CTX of this app, or nullptr. */
    void *getNativeHandle() {
        return us_socket_context_get_native_handle(SSL, (struct us_socket_context_t *) httpContext);
    }

    /* Attaches a "filter" function to track socket connections/disconnections */
    TemplatedApp &&filter(MoveOnlyFunction<void(HttpResponse<SSL> *, int)> &&filterHandler) {
        httpContext->filter(std::move(filterHandler));

        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Same as publish, but takes a prepared message */
    bool publishPrepared(std::string_view topic, PreparedMessage &preparedMessage) {
        /* It is assumed by heuristics that a prepared message ought to be big,
         * and so there is no fast path for small messages (yet?) as preparing a small message is unlikely */

        return reinterpret_cast<TopicTree<TopicTreeMessage, PreparedMessage *> *>(topicTree)->publishBig(nullptr, topic, &preparedMessage, [](Subscriber *s, PreparedMessage *preparedMessage) {
            auto *ws = (WebSocket<SSL, true, int> *) s->user;

            /* Send will drain if needed */
            ws->sendPrepared(*preparedMessage);
        });
    }

    /* Publishes a message to all websocket contexts - conceptually as if publishing to the one single
     * TopicTree of this app (technically there are many TopicTrees, however the concept is that one
     * app has one conceptual Topic tree) */
    bool publish(std::string_view topic, std::string_view message, OpCode opCode, bool compress = false) {
        /* Anything big bypasses corking efforts */
        if (message.length() >= LoopData::CORK_BUFFER_SIZE) {
            return topicTree->publishBig(nullptr, topic, {message, opCode, compress}, [](Subscriber *s, TopicTreeBigMessage &message) {
                auto *ws = (WebSocket<SSL, true, int> *) s->user;

                /* Send will drain if needed */
                ws->send(message.message, (OpCode)message.opCode, message.compress);
            });
        } else {
            return topicTree->publish(nullptr, topic, {std::string(message), opCode, compress});
        }
    }

    /* Returns number of subscribers for this topic, or 0 for failure.
     * This function should probably be optimized a lot in future releases,
     * it could be O(1) with a hash map of fullnames and their counts. */
    unsigned int numSubscribers(std::string_view topic) {
        Topic *t = topicTree->lookupTopic(topic);
        if (t) {
            return (unsigned int) t->size();
        }

        return 0;
    }

    ~TemplatedApp() {
        /* Let's just put everything here */
        if (httpContext) {
            httpContext->free();

            /* Free all our webSocketContexts in a type less way */
            for (auto &webSocketContextDeleter : webSocketContextDeleters) {
                webSocketContextDeleter();
            }
        }

        /* Delete TopicTree */
        if (topicTree) {
            /* And unregister loop callbacks */
            /* We must unregister any loop post handler here */
            Loop::get()->removePostHandler(topicTree);
            Loop::get()->removePreHandler(topicTree);

        delete topicTree;
        }
    }

    /* Disallow copying, only move */
    TemplatedApp(const TemplatedApp &other) = delete;

    TemplatedApp(TemplatedApp &&other) {
        /* Move HttpContext */
        httpContext = other.httpContext;
        other.httpContext = nullptr;

        /* Move webSocketContextDeleters */
        webSocketContextDeleters = std::move(other.webSocketContextDeleters);

        webSocketContexts = std::move(other.webSocketContexts);

        /* Move TopicTree */
        topicTree = other.topicTree;
        other.topicTree = nullptr;
    }

    TemplatedApp(SocketContextOptions options = {}) {
        httpContext = HttpContext<SSL>::create(Loop::get(), options);

        /* Register default handler for 404 (can be overridden by user) */
        this->any("/*", [](auto *res, auto */*req*/) {
            res->writeStatus("404 File Not Found");
            res->end("<html><body><h1>File Not Found</h1><hr><i>uWebSockets/20 Server</i></body></html>");
        });
    }

    bool constructorFailed() {
        return !httpContext;
    }

    template <typename UserData>
    struct WebSocketBehavior {
        /* Disabled compression by default - probably a bad default */
        CompressOptions compression = DISABLED;
        /* Maximum message size we can receive */
        unsigned int maxPayloadLength = 16 * 1024;
        /* 2 minutes timeout is good */
        unsigned short idleTimeout = 120;
        /* 64kb backpressure is probably good */
        unsigned int maxBackpressure = 64 * 1024;
        bool closeOnBackpressureLimit = false;
        /* This one depends on kernel timeouts and is a bad default */
        bool resetIdleTimeoutOnSend = false;
        /* A good default, esp. for newcomers */
        bool sendPingsAutomatically = true;
        /* Maximum socket lifetime in minutes before forced closure (defaults to disabled) */
        unsigned short maxLifetime = 0;
        MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *, struct us_socket_context_t *)> upgrade = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *)> open = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, std::string_view, OpCode)> message = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, std::string_view, OpCode)> dropped = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *)> drain = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, std::string_view)> ping = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, std::string_view)> pong = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, std::string_view, int, int)> subscription = nullptr;
        MoveOnlyFunction<void(WebSocket<SSL, true, UserData> *, int, std::string_view)> close = nullptr;
    };

    /* Closes all sockets including listen sockets. */
    TemplatedApp &&close() {
        us_socket_context_close(SSL, (struct us_socket_context_t *) httpContext);
        for (void *webSocketContext : webSocketContexts) {
            us_socket_context_close(SSL, (struct us_socket_context_t *) webSocketContext);
        }

        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    template <typename UserData>
    TemplatedApp &&ws(std::string pattern, WebSocketBehavior<UserData> &&behavior) {
        /* Don't compile if alignment rules cannot be satisfied */
        static_assert(alignof(UserData) <= LIBUS_EXT_ALIGNMENT,
        "µWebSockets cannot satisfy UserData alignment requirements. You need to recompile µSockets with LIBUS_EXT_ALIGNMENT adjusted accordingly.");

        if (!httpContext) {
            return std::move(static_cast<TemplatedApp &&>(*this));
        }

        /* Terminate on misleading idleTimeout values */
        if (behavior.idleTimeout && behavior.idleTimeout < 8) {
            std::cerr << "Error: idleTimeout must be either 0 or greater than 8!" << std::endl;
            std::terminate();
        }

        /* Maximum idleTimeout is 16 minutes */
        if (behavior.idleTimeout > 240 * 4) {
            std::cerr << "Error: idleTimeout must not be greater than 960 seconds!" << std::endl;
            std::terminate();
        }

        /* Maximum maxLifetime is 4 hours */
        if (behavior.maxLifetime > 240) {
            std::cerr << "Error: maxLifetime must not be greater than 240 minutes!" << std::endl;
            std::terminate();
        }

        /* If we don't have a TopicTree yet, create one now */
        if (!topicTree) {

            bool needsUncork = false;
            topicTree = new TopicTree<TopicTreeMessage, TopicTreeBigMessage>([needsUncork](Subscriber *s, TopicTreeMessage &message, TopicTree<TopicTreeMessage, TopicTreeBigMessage>::IteratorFlags flags) mutable {
                /* Subscriber's user is the socket */
                /* Unfortunately we need to cast is to PerSocketData = int
                 * since many different WebSocketContexts use the same
                 * TopicTree now */
                auto *ws = (WebSocket<SSL, true, int> *) s->user;

                /* If this is the first message we try and cork */
                if (flags & TopicTree<TopicTreeMessage, TopicTreeBigMessage>::IteratorFlags::FIRST) {
                    if (ws->canCork() && !ws->isCorked()) {
                        ((AsyncSocket<SSL> *)ws)->cork();
                        needsUncork = true;
                    }
                }

                /* If we ever overstep maxBackpresure, exit immediately */
                if (WebSocket<SSL, true, int>::SendStatus::DROPPED == ws->send(message.message, (OpCode)message.opCode, message.compress)) {
                    if (needsUncork) {
                        ((AsyncSocket<SSL> *)ws)->uncork();
                        needsUncork = false;
                    }
                    /* Stop draining */
                    return true;
                }

                /* If this is the last message we uncork if we are corked */
                if (flags & TopicTree<TopicTreeMessage, TopicTreeBigMessage>::IteratorFlags::LAST) {
                    /* We should not uncork in all cases? */
                    if (needsUncork) {
                        ((AsyncSocket<SSL> *)ws)->uncork();
                    }
                }

                /* Success */
                return false;
            });

            /* And hook it up with the loop */
            /* We empty for both pre and post just to make sure */
            Loop::get()->addPostHandler(topicTree, [topicTree = topicTree](Loop */*loop*/) {
                /* Commit pub/sub batches every loop iteration */
                topicTree->drain();
            });

            Loop::get()->addPreHandler(topicTree, [topicTree = topicTree](Loop */*loop*/) {
                /* Commit pub/sub batches every loop iteration */
                topicTree->drain();
            });
        }

        /* Every route has its own websocket context with its own behavior and user data type */
        auto *webSocketContext = WebSocketContext<SSL, true, UserData>::create(Loop::get(), (us_socket_context_t *) httpContext, topicTree);

        /* We need to clear this later on */
        webSocketContextDeleters.push_back([webSocketContext]() {
            webSocketContext->free();
        });

        /* We also keep this list for easy closing */
        webSocketContexts.push_back((void *)webSocketContext);

        /* Quick fix to disable any compression if set */
#ifdef UWS_NO_ZLIB
        behavior.compression = DISABLED;
#endif

        /* If we are the first one to use compression, initialize it */
        if (behavior.compression) {
            LoopData *loopData = (LoopData *) us_loop_ext(us_socket_context_loop(SSL, webSocketContext->getSocketContext()));

            /* Initialize loop's deflate inflate streams */
            if (!loopData->zlibContext) {
                loopData->zlibContext = new ZlibContext;
                loopData->inflationStream = new InflationStream(CompressOptions::DEDICATED_DECOMPRESSOR);
                loopData->deflationStream = new DeflationStream(CompressOptions::DEDICATED_COMPRESSOR);
            }
        }

        /* Copy all handlers */
        webSocketContext->getExt()->openHandler = std::move(behavior.open);
        webSocketContext->getExt()->messageHandler = std::move(behavior.message);
        webSocketContext->getExt()->droppedHandler = std::move(behavior.dropped);
        webSocketContext->getExt()->drainHandler = std::move(behavior.drain);
        webSocketContext->getExt()->subscriptionHandler = std::move(behavior.subscription);
        webSocketContext->getExt()->closeHandler = std::move(behavior.close);
        webSocketContext->getExt()->pingHandler = std::move(behavior.ping);
        webSocketContext->getExt()->pongHandler = std::move(behavior.pong);

        /* Copy settings */
        webSocketContext->getExt()->maxPayloadLength = behavior.maxPayloadLength;
        webSocketContext->getExt()->maxBackpressure = behavior.maxBackpressure;
        webSocketContext->getExt()->closeOnBackpressureLimit = behavior.closeOnBackpressureLimit;
        webSocketContext->getExt()->resetIdleTimeoutOnSend = behavior.resetIdleTimeoutOnSend;
        webSocketContext->getExt()->sendPingsAutomatically = behavior.sendPingsAutomatically;
        webSocketContext->getExt()->maxLifetime = behavior.maxLifetime;
        webSocketContext->getExt()->compression = behavior.compression;

        /* Calculate idleTimeoutCompnents */
        webSocketContext->getExt()->calculateIdleTimeoutCompnents(behavior.idleTimeout);

        httpContext->onHttp("GET", pattern, [webSocketContext, behavior = std::move(behavior)](auto *res, auto *req) mutable {

            /* If we have this header set, it's a websocket */
            std::string_view secWebSocketKey = req->getHeader("sec-websocket-key");
            if (secWebSocketKey.length() == 24) {

                /* Emit upgrade handler */
                if (behavior.upgrade) {

                    /* Nasty, ugly Safari 15 hack */
                    if (hasBrokenCompression(req->getHeader("user-agent"))) {
                        std::string_view secWebSocketExtensions = req->getHeader("sec-websocket-extensions");
                        memset((void *) secWebSocketExtensions.data(), ' ', secWebSocketExtensions.length());
                    }

                    behavior.upgrade(res, req, (struct us_socket_context_t *) webSocketContext);
                } else {
                    /* Default handler upgrades to WebSocket */
                    std::string_view secWebSocketProtocol = req->getHeader("sec-websocket-protocol");
                    std::string_view secWebSocketExtensions = req->getHeader("sec-websocket-extensions");

                    /* Safari 15 hack */
                    if (hasBrokenCompression(req->getHeader("user-agent"))) {
                        secWebSocketExtensions = "";
                    }

                    res->template upgrade<UserData>({}, secWebSocketKey, secWebSocketProtocol, secWebSocketExtensions, (struct us_socket_context_t *) webSocketContext);
                }

                /* We are going to get uncorked by the Http get return */

                /* We do not need to check for any close or shutdown here as we immediately return from get handler */

            } else {
                /* Tell the router that we did not handle this request */
                req->setYield(true);
            }
        }, true);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Browse to a server name, changing the router to this domain */
    TemplatedApp &&domain(std::string serverName) {
        HttpContextData<SSL> *httpContextData = httpContext->getSocketContextData();

        void *domainRouter = us_socket_context_find_server_name_userdata(SSL, (struct us_socket_context_t *) httpContext, serverName.c_str());
        if (domainRouter) {
            std::cout << "Browsed to SNI: " << serverName << std::endl;
            httpContextData->currentRouter = (decltype(httpContextData->currentRouter)) domainRouter;
        } else {
            std::cout << "Cannot browse to SNI: " << serverName << std::endl;
            httpContextData->currentRouter = &httpContextData->router;
        }
    
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&get(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("GET", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&post(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("POST", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&options(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("OPTIONS", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&del(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("DELETE", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&patch(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("PATCH", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&put(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("PUT", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&head(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("HEAD", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&connect(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("CONNECT", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&trace(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("TRACE", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* This one catches any method */
    TemplatedApp &&any(std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler) {
        if (httpContext) {
            httpContext->onHttp("*", pattern, std::move(handler));
        }
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Host, port, callback */
    TemplatedApp &&listen(std::string host, int port, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
        if (!host.length()) {
            return listen(port, std::move(handler));
        }
        handler(httpContext ? httpContext->listen(host.c_str(), port, 0) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Host, port, options, callback */
    TemplatedApp &&listen(std::string host, int port, int options, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
        if (!host.length()) {
            return listen(port, options, std::move(handler));
        }
        handler(httpContext ? httpContext->listen(host.c_str(), port, options) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Port, callback */
    TemplatedApp &&listen(int port, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
        handler(httpContext ? httpContext->listen(nullptr, port, 0) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Port, options, callback */
    TemplatedApp &&listen(int port, int options, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
        handler(httpContext ? httpContext->listen(nullptr, port, options) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* options, callback, path to unix domain socket */
    TemplatedApp &&listen(int options, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler, std::string path) {
        handler(httpContext ? httpContext->listen(path.c_str(), options) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* callback, path to unix domain socket */
    TemplatedApp &&listen(MoveOnlyFunction<void(us_listen_socket_t *)> &&handler, std::string path) {
        handler(httpContext ? httpContext->listen(path.c_str(), 0) : nullptr);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* Register event handler for accepted FD. Can be used together with adoptSocket. */
    TemplatedApp &&preOpen(LIBUS_SOCKET_DESCRIPTOR (*handler)(struct us_socket_context_t *, LIBUS_SOCKET_DESCRIPTOR)) {
        httpContext->onPreOpen(handler);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&removeChildApp(TemplatedApp *app) {
        /* Remove this app from httpContextData list over child apps and reset round robin */
        auto &childApps = httpContext->getSocketContextData()->childApps;
        childApps.erase(
            std::remove(childApps.begin(), childApps.end(), (void *) app),
            childApps.end()
        );
        httpContext->getSocketContextData()->roundRobin = 0;
        
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&addChildApp(TemplatedApp *app) {
        /* Add this app to httpContextData list over child apps and set onPreOpen */
        httpContext->getSocketContextData()->childApps.push_back((void *) app);
        
        httpContext->onPreOpen([](struct us_socket_context_t *context, LIBUS_SOCKET_DESCRIPTOR fd) -> LIBUS_SOCKET_DESCRIPTOR {
            
            HttpContext<SSL> *httpContext = (HttpContext<SSL> *) context;

            if (httpContext->getSocketContextData()->childApps.empty()) {
                return fd;
            }

            //std::cout << "Distributing fd: " << fd << " from context: " << context << std::endl;

            unsigned int *roundRobin = &httpContext->getSocketContextData()->roundRobin;

            //std::cout << "Round robin is: " << *roundRobin << " and size of apps is: " << httpContext->getSocketContextData()->childApps.size() << std::endl;

            TemplatedApp *receivingApp = (TemplatedApp *) httpContext->getSocketContextData()->childApps[*roundRobin];


            //std::cout << "Loop is " << receivingApp->getLoop() << std::endl;


            receivingApp->getLoop()->defer([fd, receivingApp]() {
                //std::cout << "About to adopt socket " << fd << " on receivingApp " << receivingApp << std::endl;
                receivingApp->adoptSocket(fd);
                //std::cout << "Done " << std::endl;
            });

            if (++(*roundRobin) == httpContext->getSocketContextData()->childApps.size()) {
                *roundRobin = 0;
            }

            return fd + 1;
        });
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    /* adopt an externally accepted socket */
    TemplatedApp &&adoptSocket(LIBUS_SOCKET_DESCRIPTOR accepted_fd) {
        httpContext->adoptAcceptedSocket(accepted_fd);
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    TemplatedApp &&run() {
        uWS::run();
        return std::move(static_cast<TemplatedApp &&>(*this));
    }

    Loop *getLoop() {
        return (Loop *) httpContext->getLoop();
    }

};

}

namespace uWS {
    typedef uWS::TemplatedApp<false> App;
    typedef uWS::TemplatedApp<true> SSLApp;
}

#endif // UWS_APP_H

```

`src/AsyncSocket.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_ASYNCSOCKET_H
#define UWS_ASYNCSOCKET_H

/* This class implements async socket memory management strategies */

/* NOTE: Many unsigned/signed conversion warnings could be solved by moving from int length
 * to unsigned length for everything to/from uSockets - this would however remove the opportunity
 * to signal error with -1 (which is how the entire UNIX syscalling is built). */

#include <cstring>
#include <iostream>

#include "libusockets.h"

#include "LoopData.h"
#include "AsyncSocketData.h"

namespace uWS {

    enum SendBufferAttribute {
        NEEDS_NOTHING,
        NEEDS_DRAIN,
        NEEDS_UNCORK
    };

    template <bool, bool, typename> struct WebSocketContext;

template <bool SSL>
struct AsyncSocket {
    /* This guy is promiscuous */
    template <bool> friend struct HttpContext;
    template <bool, bool, typename> friend struct WebSocketContext;
    template <bool> friend struct TemplatedApp;
    template <bool, typename> friend struct WebSocketContextData;
    template <typename, typename> friend struct TopicTree;
    template <bool> friend struct HttpResponse;

private:
    /* Helper, do not use directly (todo: move to uSockets or de-crazify) */
    void throttle_helper(int toggle) {
        /* These should be exposed by uSockets */
        static thread_local int us_events[2] = {0, 0};

        struct us_poll_t *p = (struct us_poll_t *) this;
        struct us_loop_t *loop = us_socket_context_loop(SSL, us_socket_context(SSL, (us_socket_t *) this));

        if (toggle) {
            /* Pause */
            int events = us_poll_events(p);
            if (events) {
                us_events[getBufferedAmount() ? 1 : 0] = events;
            }
            us_poll_change(p, loop, 0);
        } else {
            /* Resume */
            int events = us_events[getBufferedAmount() ? 1 : 0];
            us_poll_change(p, loop, events);
        }
    }

protected:
    /* Returns SSL pointer or FD as pointer */
    void *getNativeHandle() {
        return us_socket_get_native_handle(SSL, (us_socket_t *) this);
    }

    /* Get loop data for socket */
    LoopData *getLoopData() {
        return (LoopData *) us_loop_ext(us_socket_context_loop(SSL, us_socket_context(SSL, (us_socket_t *) this)));
    }

    /* Get socket extension */
    AsyncSocketData<SSL> *getAsyncSocketData() {
        return (AsyncSocketData<SSL> *) us_socket_ext(SSL, (us_socket_t *) this);
    }

    /* Socket timeout */
    void timeout(unsigned int seconds) {
        us_socket_timeout(SSL, (us_socket_t *) this, seconds);
    }

    /* Shutdown socket without any automatic drainage */
    void shutdown() {
        us_socket_shutdown(SSL, (us_socket_t *) this);
    }

    /* Experimental pause */
    us_socket_t *pause() {
        throttle_helper(1);
        return (us_socket_t *) this;
    }

    /* Experimental resume */
    us_socket_t *resume() {
        throttle_helper(0);
        return (us_socket_t *) this;
    }

    /* Immediately close socket */
    us_socket_t *close() {
        return us_socket_close(SSL, (us_socket_t *) this, 0, nullptr);
    }

    void corkUnchecked() {
        /* What if another socket is corked? */
        getLoopData()->corkedSocket = this;
    }

    void uncorkWithoutSending() {
        if (isCorked()) {
            getLoopData()->corkedSocket = nullptr;
        }
    }

    /* Cork this socket. Only one socket may ever be corked per-loop at any given time */
    void cork() {
        /* Extra check for invalid corking of others */
        if (getLoopData()->corkOffset && getLoopData()->corkedSocket != this) {
            std::cerr << "Error: Cork buffer must not be acquired without checking canCork!" << std::endl;
            std::terminate();
        }

        /* What if another socket is corked? */
        getLoopData()->corkedSocket = this;
    }

    /* Returns whether we are corked or not */
    bool isCorked() {
        return getLoopData()->corkedSocket == this;
    }

    /* Returns whether we could cork (it is free) */
    bool canCork() {
        return getLoopData()->corkedSocket == nullptr;
    }

    /* Returns a suitable buffer for temporary assemblation of send data */
    std::pair<char *, SendBufferAttribute> getSendBuffer(size_t size) {
        /* First step is to determine if we already have backpressure or not */
        LoopData *loopData = getLoopData();
        BackPressure &backPressure = getAsyncSocketData()->buffer;
        size_t existingBackpressure = backPressure.length();
        if ((!existingBackpressure) && (isCorked() || canCork()) && (loopData->corkOffset + size < LoopData::CORK_BUFFER_SIZE)) {
            /* Cork automatically if we can */
            if (isCorked()) {
                char *sendBuffer = loopData->corkBuffer + loopData->corkOffset;
                loopData->corkOffset += (unsigned int) size;
                return {sendBuffer, SendBufferAttribute::NEEDS_NOTHING};
            } else {
                cork();
                char *sendBuffer = loopData->corkBuffer + loopData->corkOffset;
                loopData->corkOffset += (unsigned int) size;
                return {sendBuffer, SendBufferAttribute::NEEDS_UNCORK};
            }
        } else {

            /* If we are corked and there is already data in the cork buffer,
            mark how much is ours and reset it */
            unsigned int ourCorkOffset = 0;
            if (isCorked() && loopData->corkOffset) {
                ourCorkOffset = loopData->corkOffset;
                loopData->corkOffset = 0;
            }

            /* Fallback is to use the backpressure as buffer */
            backPressure.resize(ourCorkOffset + existingBackpressure + size);

            /* And copy corkbuffer in front */
            memcpy((char *) backPressure.data() + existingBackpressure, loopData->corkBuffer, ourCorkOffset);

            return {(char *) backPressure.data() + ourCorkOffset + existingBackpressure, SendBufferAttribute::NEEDS_DRAIN};
        }
    }

    /* Returns the user space backpressure. */
    unsigned int getBufferedAmount() {
        /* We return the actual amount of bytes in backbuffer, including pendingRemoval */
        return (unsigned int) getAsyncSocketData()->buffer.totalLength();
    }

    /* Returns the text representation of an IPv4 or IPv6 address */
    std::string_view addressAsText(std::string_view binary) {
        static thread_local char buf[64];
        int ipLength = 0;

        if (!binary.length()) {
            return {};
        }

        unsigned char *b = (unsigned char *) binary.data();

        if (binary.length() == 4) {
            ipLength = snprintf(buf, 64, "%u.%u.%u.%u", b[0], b[1], b[2], b[3]);
        } else {
            ipLength = snprintf(buf, 64, "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
                b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10], b[11],
                b[12], b[13], b[14], b[15]);
        }

        return {buf, (unsigned int) ipLength};
    }

    /* Returns the remote IP address or empty string on failure */
    std::string_view getRemoteAddress() {
        static thread_local char buf[16];
        int ipLength = 16;
        us_socket_remote_address(SSL, (us_socket_t *) this, buf, &ipLength);
        return std::string_view(buf, (unsigned int) ipLength);
    }

    /* Returns the text representation of IP */
    std::string_view getRemoteAddressAsText() {
        return addressAsText(getRemoteAddress());
    }

    /* Write in three levels of prioritization: cork-buffer, syscall, socket-buffer. Always drain if possible.
     * Returns pair of bytes written (anywhere) and whether or not this call resulted in the polling for
     * writable (or we are in a state that implies polling for writable). */
    std::pair<int, bool> write(const char *src, int length, bool optionally = false, int nextLength = 0) {
        /* Fake success if closed, simple fix to allow uncork of closed socket to succeed */
        if (us_socket_is_closed(SSL, (us_socket_t *) this)) {
            return {length, false};
        }

        LoopData *loopData = getLoopData();
        AsyncSocketData<SSL> *asyncSocketData = getAsyncSocketData();

        /* We are limited if we have a per-socket buffer */
        if (asyncSocketData->buffer.length()) {
            /* Write off as much as we can */
            int written = us_socket_write(SSL, (us_socket_t *) this, asyncSocketData->buffer.data(), (int) asyncSocketData->buffer.length(), /*nextLength != 0 | */length);

            /* On failure return, otherwise continue down the function */
            if ((unsigned int) written < asyncSocketData->buffer.length()) {

                /* Update buffering (todo: we can do better here if we keep track of what happens to this guy later on) */
                asyncSocketData->buffer.erase((unsigned int) written);

                if (optionally) {
                    /* Thankfully we can exit early here */
                    return {0, true};
                } else {
                    /* This path is horrible and points towards erroneous usage */
                    asyncSocketData->buffer.append(src, (unsigned int) length);

                    return {length, true};
                }
            }

            /* At this point we simply have no buffer and can continue as normal */
            asyncSocketData->buffer.clear();
        }

        if (length) {
            if (loopData->corkedSocket == this) {
                /* We are corked */
                if (LoopData::CORK_BUFFER_SIZE - loopData->corkOffset >= (unsigned int) length) {
                    /* If the entire chunk fits in cork buffer */
                    memcpy(loopData->corkBuffer + loopData->corkOffset, src, (unsigned int) length);
                    loopData->corkOffset += (unsigned int) length;
                    /* Fall through to default return */
                } else {
                    /* Strategy differences between SSL and non-SSL regarding syscall minimizing */
                    if constexpr (false) {
                        /* Cork up as much as we can */
                        unsigned int stripped = LoopData::CORK_BUFFER_SIZE - loopData->corkOffset;
                        memcpy(loopData->corkBuffer + loopData->corkOffset, src, stripped);
                        loopData->corkOffset = LoopData::CORK_BUFFER_SIZE;

                        auto [written, failed] = uncork(src + stripped, length - (int) stripped, optionally);
                        return {written + (int) stripped, failed};
                    }

                    /* For non-SSL we take the penalty of two syscalls */
                    return uncork(src, length, optionally);
                }
            } else {
                /* We are not corked */
                int written = us_socket_write(SSL, (us_socket_t *) this, src, length, nextLength != 0);

                /* Did we fail? */
                if (written < length) {
                    /* If the write was optional then just bail out */
                    if (optionally) {
                        return {written, true};
                    }

                    /* Fall back to worst possible case (should be very rare for HTTP) */
                    /* At least we can reserve room for next chunk if we know it up front */
                    if (nextLength) {
                        asyncSocketData->buffer.reserve(asyncSocketData->buffer.length() + (size_t) (length - written + nextLength));
                    }

                    /* Buffer this chunk */
                    asyncSocketData->buffer.append(src + written, (size_t) (length - written));

                    /* Return the failure */
                    return {length, true};
                }
                /* Fall through to default return */
            }
        }

        /* Default fall through return */
        return {length, false};
    }

    /* Uncork this socket and flush or buffer any corked and/or passed data. It is essential to remember doing this. */
    /* It does NOT count bytes written from cork buffer (they are already accounted for in the write call responsible for its corking)! */
    std::pair<int, bool> uncork(const char *src = nullptr, int length = 0, bool optionally = false) {
        LoopData *loopData = getLoopData();

        if (loopData->corkedSocket == this) {
            loopData->corkedSocket = nullptr;

            if (loopData->corkOffset) {
                /* Corked data is already accounted for via its write call */
                auto [written, failed] = write(loopData->corkBuffer, (int) loopData->corkOffset, false, length);
                loopData->corkOffset = 0;

                if (failed) {
                    /* We do not need to care for buffering here, write does that */
                    return {0, true};
                }
            }

            /* We should only return with new writes, not things written to cork already */
            return write(src, length, optionally, 0);
        } else {
            /* We are not even corked! */
            return {0, false};
        }
    }
};

}

#endif // UWS_ASYNCSOCKET_H

```

`src/AsyncSocketData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2025.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_ASYNCSOCKETDATA_H
#define UWS_ASYNCSOCKETDATA_H

#include <string>

namespace uWS {

struct BackPressure {
    std::string buffer;
    unsigned int pendingRemoval = 0;
    BackPressure(BackPressure &&other) {
        buffer = std::move(other.buffer);
        pendingRemoval = other.pendingRemoval;
    }
    BackPressure() = default;
    void append(const char *data, size_t length) {
        buffer.append(data, length);
    }
    void erase(unsigned int length) {
        pendingRemoval += length;
        /* Always erase a minimum of 1/32th the current backpressure */
        if (pendingRemoval > (buffer.length() >> 5)) {
            std::string(buffer.begin() + pendingRemoval, buffer.end()).swap(buffer);
            pendingRemoval = 0;
        }
    }
    size_t length() {
        return buffer.length() - pendingRemoval;
    }
    /* Only used in AsyncSocket::write - what about replacing it with the other functions like erase(length())? */
    void clear() {
        pendingRemoval = 0;
        buffer.clear();
        buffer.shrink_to_fit();
    }
    /* Only used by AsyncSocket::write (optionally) before append */
    void reserve(size_t length) {
        buffer.reserve(length + pendingRemoval);
    }
    /* Only used by getSendBuffer as last resort */
    void resize(size_t length) {
        buffer.resize(length + pendingRemoval);
    }
    const char *data() {
        return buffer.data() + pendingRemoval;
    }
    /* The total length, incuding pending removal */
    size_t totalLength() {
        return buffer.length();
    }
};

/* Depending on how we want AsyncSocket to function, this will need to change */

template <bool SSL>
struct AsyncSocketData {
    /* This will do for now */
    BackPressure buffer;

    /* Allow move constructing us */
    AsyncSocketData(BackPressure &&backpressure) : buffer(std::move(backpressure)) {

    }

    /* Or emppty */
    AsyncSocketData() = default;
};

}

#endif // UWS_ASYNCSOCKETDATA_H

```

`src/BloomFilter.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2022.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_BLOOMFILTER_H
#define UWS_BLOOMFILTER_H

/* This filter has no false positives or collisions for the standard
 * and non-standard common request headers */

#include <cstdint>
#include <string_view>
#include <bitset>

namespace uWS {

struct BloomFilter {
private:
    std::bitset<256> filter;
    static inline uint32_t perfectHash(uint32_t features) {
        return features * 1843993368;
    }

    union ScrambleArea {
        unsigned char p[4];
        uint32_t val;
    };

    ScrambleArea getFeatures(std::string_view key) {
        ScrambleArea s;
        s.p[0] = reinterpret_cast<const unsigned char&>(key[0]);
        s.p[1] = reinterpret_cast<const unsigned char&>(key[key.length() - 1]);
        s.p[2] = reinterpret_cast<const unsigned char&>(key[key.length() - 2]);
        s.p[3] = reinterpret_cast<const unsigned char&>(key[key.length() >> 1]);
        return s;
    }

public:
    bool mightHave(std::string_view key) {
        if (key.length() < 2) {
            return true;
        }
    
        ScrambleArea s = getFeatures(key);
        s.val = perfectHash(s.val);
        return filter[s.p[0]] &&
        filter[s.p[1]] &&
        filter[s.p[2]] &&
        filter[s.p[3]];
    }

    void add(std::string_view key) {
        if (key.length() >= 2) {
            ScrambleArea s = getFeatures(key);
            s.val = perfectHash(s.val);
            filter[s.p[0]] = 1;
            filter[s.p[1]] = 1;
            filter[s.p[2]] = 1;
            filter[s.p[3]] = 1;
        }
    }

    void reset() {
        filter.reset();
    }
};

}

#endif // UWS_BLOOMFILTER_H

```

`src/CachingApp.h`:

```h
#ifndef UWS_CACHINGAPP_H
#define UWS_CACHINGAPP_H

#include "App.h"
#include <unordered_map>
#include <string>
#include <functional>
#include <string_view>

namespace uWS {

struct StringViewHash {
    size_t operator()(std::string_view sv) const {
        return std::hash<std::string_view>{}(sv);
    }
};

struct StringViewEqual {
    bool operator()(std::string_view sv1, std::string_view sv2) const {
        return sv1 == sv2;
    }
};



class CachingHttpResponse {
public:
    CachingHttpResponse(uWS::HttpResponse<false> *res)
        : res(res) {}

    void write(std::string_view data) {
        buffer.append(data);
    }

    void end(std::string_view data = "", bool closeConnection = false) {
        buffer.append(data);

        // end for all queued up sockets also
        res->end(buffer);

        created = time(0);

        std::ignore = closeConnection;
    }

public:
    uWS::HttpResponse<false>* res; // should be a vector of waiting sockets


    std::string buffer; // body
    time_t created;
};

typedef std::unordered_map<std::string_view, CachingHttpResponse *, 
                       StringViewHash, 
                       StringViewEqual> CacheType;

// we can also derive from H3app later on
template <bool SSL>
struct CachingApp : public uWS::TemplatedAppBase<SSL, CachingApp<SSL>> {
public:
    CachingApp(SocketContextOptions options = {}) : uWS::TemplatedAppBase<SSL, CachingApp<SSL>>(options) {}

    using uWS::TemplatedAppBase<SSL, CachingApp<SSL>>::get;

    CachingApp(const CachingApp &other) = delete;
    CachingApp(CachingApp<SSL> &&other) : uWS::TemplatedAppBase<SSL, CachingApp<SSL>>(std::move(other)) {
        // also move the cache
    }

    ~CachingApp() {

    }

    // variant 1: only taking URL into account
    CachingApp &&get(const std::string& url, uWS::MoveOnlyFunction<void(CachingHttpResponse*, uWS::HttpRequest*)> &&handler, unsigned int secondsToExpiry) {
        ((uWS::TemplatedAppBase<SSL, CachingApp<SSL>> *)this)->get(url, [this, handler = std::move(handler), secondsToExpiry](auto* res, auto* req) mutable {
            /* We need to know the cache key and the time of now */
            std::string_view cache_key = req->getFullUrl();
            time_t now = static_cast<LoopData *>(us_loop_ext((us_loop_t *)uWS::Loop::get()))->cacheTimepoint;

            auto it = cache.find(cache_key);
            if (it != cache.end()) {

                if (it->second->created + secondsToExpiry > now) {
                    res->end(it->second->buffer); // tryEnd!
                    return;
                }

                /* We are no longer valid, delete old cache and fall through to create a new entry */
                delete it->second;

                // is the cache completed? if not, add yourself to the waiting list of sockets to that cache

                // if the cache completed? ok, is it still valid? use it
            }

            // immediately take the place in the cache
            CachingHttpResponse *cachingRes;
            cache[cache_key] = (cachingRes = new CachingHttpResponse(res));

            handler(cachingRes, req);
        });
        return std::move(*this);
    }

    // variant 2: taking URL and a list of headers into account
    // todo

private:
    CacheType cache;
};

}
#endif
```

`src/ChunkedEncoding.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2026.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_CHUNKEDENCODING_H
#define UWS_CHUNKEDENCODING_H

/* Independent chunked encoding parser, used by HttpParser. */

#include <string>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <string_view>
#include "MoveOnlyFunction.h"
#include <optional>

namespace uWS {

    constexpr uint64_t STATE_HAS_SIZE = 1ull << (sizeof(uint64_t) * 8 - 1);//0x80000000;
    constexpr uint64_t STATE_IS_CHUNKED = 1ull << (sizeof(uint64_t) * 8 - 2);//0x40000000;
    constexpr uint64_t STATE_SIZE_MASK = ~(3ull << (sizeof(uint64_t) * 8 - 2));//0x3FFFFFFF;
    constexpr uint64_t STATE_IS_ERROR = ~0ull;//0xFFFFFFFF;
    constexpr uint64_t STATE_SIZE_OVERFLOW = 0x0Full << (sizeof(uint64_t) * 8 - 8);//0x0F000000;

    inline uint64_t chunkSize(uint64_t state) {
        return state & STATE_SIZE_MASK;
    }

    /* Reads hex number until CR or out of data to consume. Updates state. Returns bytes consumed. */
    inline void consumeHexNumber(std::string_view &data, uint64_t &state) {
        /* Consume everything higher than 32 */
        while (data.length() && data.data()[0] > 32) {

            unsigned char digit = (unsigned char)data.data()[0];
            if (digit >= 'a') {
                digit = (unsigned char) (digit - ('a' - ':'));
            } else if (digit >= 'A') {
                digit = (unsigned char) (digit - ('A' - ':'));
            }

            unsigned int number = ((unsigned int) digit - (unsigned int) '0');

            if (number > 16 || (chunkSize(state) & STATE_SIZE_OVERFLOW)) {
                state = STATE_IS_ERROR;
                return;
            }

            // extract state bits
            uint64_t bits = /*state &*/ STATE_IS_CHUNKED;

            state = (state & STATE_SIZE_MASK) * 16ull + number;

            state |= bits;
            data.remove_prefix(1);
        }
        /* Consume everything not /n */
        while (data.length() && data.data()[0] != '\n') {
            data.remove_prefix(1);
        }
        /* Now we stand on \n so consume it and enable size */
        if (data.length()) {
            state += 2; // include the two last /r/n
            state |= STATE_HAS_SIZE | STATE_IS_CHUNKED;
            data.remove_prefix(1);
        }
    }

    inline void decChunkSize(uint64_t &state, unsigned int by) {

        //unsigned int bits = state & STATE_IS_CHUNKED;

        state = (state & ~STATE_SIZE_MASK) | (chunkSize(state) - by);

        //state |= bits;
    }

    inline bool hasChunkSize(uint64_t state) {
        return state & STATE_HAS_SIZE;
    }

    /* Are we in the middle of parsing chunked encoding? */
    inline bool isParsingChunkedEncoding(uint64_t state) {
        return state & ~STATE_SIZE_MASK;
    }

    inline bool isParsingInvalidChunkedEncoding(uint64_t state) {
        return state == STATE_IS_ERROR;
    }

    /* Returns next chunk (empty or not), or if all data was consumed, nullopt is returned. */
    static std::optional<std::string_view> getNextChunk(std::string_view &data, uint64_t &state, bool trailer = false) {

        while (data.length()) {

            // if in "drop trailer mode", just drop up to what we have as size
            if (((state & STATE_IS_CHUNKED) == 0) && hasChunkSize(state) && chunkSize(state)) {

                //printf("Parsing trailer now\n");

                while(data.length() && chunkSize(state)) {
                    data.remove_prefix(1);
                    decChunkSize(state, 1);

                    if (chunkSize(state) == 0) {

                        /* This is an actual place where we need 0 as state */
                        state = 0;

                        /* The parser MUST stop consuming here */
                        return std::nullopt;
                    }
                }
                continue;
            }

            if (!hasChunkSize(state)) {
                consumeHexNumber(data, state);
                if (isParsingInvalidChunkedEncoding(state)) {
                    return std::nullopt;
                }
                if (hasChunkSize(state) && chunkSize(state) == 2) {

                    //printf("Setting state to trailer-parsing and emitting empty chunk\n");

                    // set trailer state and increase size to 4
                    if (trailer) {
                        state = 4 /*| STATE_IS_CHUNKED*/ | STATE_HAS_SIZE;
                    } else {
                        state = 2 /*| STATE_IS_CHUNKED*/ | STATE_HAS_SIZE;
                    }

                    return std::string_view(nullptr, 0);
                }
                continue;
            }

            // do we have data to emit all?
            if (data.length() >= chunkSize(state)) {
                // emit all but 2 bytes then reset state to 0 and goto beginning
                // not fin
                std::string_view emitSoon;
                bool shouldEmit = false;
                if (chunkSize(state) > 2) {
                    emitSoon = std::string_view(data.data(), chunkSize(state) - 2);
                    shouldEmit = true;
                }
                data.remove_prefix(chunkSize(state));
                state = STATE_IS_CHUNKED;
                if (shouldEmit) {
                    return emitSoon;
                }
                continue;
            } else {
                /* We will consume all our input data */
                std::string_view emitSoon;
                if (chunkSize(state) > 2) {
                    uint64_t maximalAppEmit = chunkSize(state) - 2;
                    if (data.length() > maximalAppEmit) {
                        emitSoon = data.substr(0, maximalAppEmit);
                    } else {
                        //cb(data);
                        emitSoon = data;
                    }
                }
                decChunkSize(state, (unsigned int) data.length());
                state |= STATE_IS_CHUNKED;
                // new: decrease data by its size (bug)
                data.remove_prefix(data.length()); // ny bug fix för getNextChunk
                if (emitSoon.length()) {
                    return emitSoon;
                } else {
                    return std::nullopt;
                }
            }
        }

        return std::nullopt;
    }

    /* This is really just a wrapper for convenience */
    struct ChunkIterator {

        std::string_view *data;
        std::optional<std::string_view> chunk;
        uint64_t *state;
        bool trailer;

        ChunkIterator(std::string_view *data, uint64_t *state, bool trailer = false) : data(data), state(state), trailer(trailer) {
            chunk = uWS::getNextChunk(*data, *state, trailer);
        }

        ChunkIterator() {

        }

        ChunkIterator begin() {
            return *this;
        }

        ChunkIterator end() {
            return ChunkIterator();
        }

        std::string_view operator*() {
            if (!chunk.has_value()) {
                std::abort();
            }
            return chunk.value();
        }

        bool operator!=(const ChunkIterator &other) const {
            return other.chunk.has_value() != chunk.has_value();
        }

        ChunkIterator &operator++() {
            chunk = uWS::getNextChunk(*data, *state, trailer);
            return *this;
        }

    };
}

#endif // UWS_CHUNKEDENCODING_H

```

`src/ClientApp.h`:

```h
#include "MoveOnlyFunction.h"
#include "WebSocketContext.h"
#include <string>

namespace uWS {

    struct WebSocketClientBehavior {
        MoveOnlyFunction<void()> open;
        MoveOnlyFunction<void()> message;
        MoveOnlyFunction<void()> close;
        //MoveOnlyFunction<void()> failed;

    };

    struct ClientApp {

        WebSocketContext<0, false, int> *webSocketContext;
        // behöver ett nytt http context med minimal klient, som slår om till den riktiga websocketcontext
        // om samma storlek på httpsocket och websocket blir det enkel övergång

        ClientApp(WebSocketClientBehavior &&behavior) {
            //webSocketContext = WebSocketContext<0, false, int>::create();
        }

        ClientApp &&connect(std::string url, std::string protocol = "") {

            return std::move(*this);
        }

        void run() {

        }

    };

}
```

`src/Http3App.h`:

```h
#include "App.h"

#include "Http3Response.h"
#include "Http3Request.h"
#include "Http3Context.h"

namespace uWS {

    struct H3App {
        Http3Context *http3Context;

        H3App(SocketContextOptions options = {}) {
            /* This conversion should not be needed */
            us_quic_socket_context_options_t h3options = {};

            h3options.key_file_name = strdup(options.key_file_name);
            h3options.cert_file_name = strdup(options.cert_file_name);
            h3options.passphrase = strdup(options.passphrase);

            /* Create the http3 context */
            http3Context = Http3Context::create((us_loop_t *)Loop::get(), h3options);

            http3Context->init();
        }

        /* Disallow copying, only move */
        H3App(const H3App &other) = delete;

        H3App(H3App &&other) {
            /* Move HttpContext */
            http3Context = other.http3Context;
            other.http3Context = nullptr;
        }

        /* Host, port, callback */
        H3App &&listen(std::string host, int port, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
            if (!host.length()) {
                return listen(port, std::move(handler));
            }
            handler(http3Context ? (us_listen_socket_t *) http3Context->listen(host.c_str(), port) : nullptr);
            return std::move(*this);
        }

        /* Host, port, options, callback */
        H3App &&listen(std::string host, int port, int options, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
            if (!host.length()) {
                return listen(port, options, std::move(handler));
            }
            handler(http3Context ? (us_listen_socket_t *) http3Context->listen(host.c_str(), port) : nullptr);
            return std::move(*this);
        }

        /* Port, callback */
        H3App &&listen(int port, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
            handler(http3Context ? (us_listen_socket_t *) http3Context->listen(nullptr, port) : nullptr);
            return std::move(*this);
        }

        /* Port, options, callback */
        H3App &&listen(int port, int options, MoveOnlyFunction<void(us_listen_socket_t *)> &&handler) {
            handler(http3Context ? (us_listen_socket_t *) http3Context->listen(nullptr, port) : nullptr);
            return std::move(*this);
        }

        H3App &&get(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("GET", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&post(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("POST", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&options(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("OPTIONS", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&del(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("DELETE", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&patch(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("PATCH", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&put(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("PUT", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&head(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("HEAD", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&connect(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("CONNECT", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        H3App &&trace(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("TRACE", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        /* This one catches any method */
        H3App &&any(std::string pattern, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&handler) {
            if (http3Context) {
                http3Context->onHttp("*", pattern, std::move(handler));
            }
            return std::move(*this);
        }

        void run() {
            uWS::Loop::get()->run();
        }
    };
}
```

`src/Http3Context.h`:

```h

extern "C" {
#include "quic.h"
}

#include "Http3ContextData.h"
#include "Http3ResponseData.h"

namespace uWS {
    struct Http3Context {
        static Http3Context *create(us_loop_t *loop, us_quic_socket_context_options_t options) {

            /* Create quic socket context (assumes h3 for now) */
            auto *context = us_create_quic_socket_context(loop, options, sizeof(Http3ContextData));

            /* Specify application callbacks */
            us_quic_socket_context_on_stream_data(context, [](us_quic_stream_t *s, char *data, int length) {

                Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext(s);
                
                /* We never emit FIN here */
                if (responseData->onData) {
                    responseData->onData({data, (size_t) length}, false);
                }
            });
            us_quic_socket_context_on_stream_end(context, [](us_quic_stream_t *s) {

                Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext(s);
                
                /* Emit FIN to app */
                if (responseData->onData) {
                    responseData->onData({nullptr, 0}, true);
                }

                /* Have we written our entire backpressure, if any? */
                // if (responseData->buffer.length() && (responseData->bufferOffset == (int) responseData->buffer.length())) {
                //     printf("We got FIN and we have no backpressure, closing stream now!\n");
                //     //us_quic_stream_close(s);
                // } else {
                //     //printf("We got FIN but we have data to write, so keeping connection half-closed!\n");
                // }

            });
            us_quic_socket_context_on_stream_open(context, [](us_quic_stream_t *s, int is_client) {

                printf("Stream open!\n");

                /* Inplace init our per stream data */
                new (us_quic_stream_ext(s)) Http3ResponseData();
            });
            us_quic_socket_context_on_close(context, [](us_quic_socket_t *s) {
                printf("QUIC socket disconnected!\n");
            });
            us_quic_socket_context_on_stream_writable(context, [](us_quic_stream_t *s) {
                Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext(s);

                /* Either we handle the streaming or we let the application handle it */
                if (responseData->onWritable) {
                    responseData->onWritable(responseData->offset);
                } else {
                    int written = us_quic_stream_write(s, (char *) responseData->backpressure.data(), responseData->backpressure.length());
                    responseData->backpressure.erase(written);

                    if (responseData->backpressure.length() == 0) {
                        printf("wrote until end, shutting down now!\n");
                        us_quic_stream_shutdown(s);
                        us_quic_stream_close(s);
                    }
                }
            });
            us_quic_socket_context_on_stream_headers(context, [](us_quic_stream_t *s) {

                /* This is the main place of start for requests */
                Http3ContextData *contextData = (Http3ContextData *) us_quic_socket_context_ext(us_quic_socket_context(us_quic_stream_socket(s)));

                Http3Request *req = nullptr;

                std::string_view upperCasedMethod = req->getHeader(":method");
                std::string_view path = req->getHeader(":path");
                
                contextData->router.getUserData() = {(Http3Response *) s, (Http3Request *) nullptr};
                contextData->router.route(upperCasedMethod, path);

            });
            us_quic_socket_context_on_open(context, [](us_quic_socket_t *s, int is_client) {
                printf("QUIC socket connected!\n");
            });
            us_quic_socket_context_on_stream_close(context, [](us_quic_stream_t *s) {

                printf("Stream closed!\n");

                //lsquic_stream_has_unacked_data

                Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext(s);
                
                if (responseData->onAborted) {
                    responseData->onAborted();
                }

                //printf("Freeing per stream data in on_stream_close in uws!\n");

                responseData->~Http3ResponseData();
            });

            return (Http3Context *) context;

            // call init here after setting the ext to Http3ContextData
        }

        us_quic_listen_socket_t *listen(const char *host, int port) {
            /* The listening socket is the actual UDP socket used */
            us_quic_listen_socket_t *listen_socket = us_quic_socket_context_listen((us_quic_socket_context_t *) this, host, port, sizeof(Http3ResponseData));

            //printf("Listen socket is: %p\n", listen_socket);

            return listen_socket;
        }

        void init() {
            // set all callbacks here



            Http3ContextData *contextData = (Http3ContextData *) us_quic_socket_context_ext((us_quic_socket_context_t *) this);

            //printf("init: %p\n", contextData);

            new (contextData) Http3ContextData();

        }

        // generic for get, post, any, etc
        void onHttp(std::string method, std::string path, MoveOnlyFunction<void(Http3Response *, Http3Request *)> &&cb) {
            // modifies the router we own as part of Http3ContextData, used in callbacks set in init
        
            Http3ContextData *contextData = (Http3ContextData *) us_quic_socket_context_ext((us_quic_socket_context_t *) this);

            /* Todo: This is ugly, fix */
            std::vector<std::string> methods;
            if (method == "*") {
                methods = {"*"}; //bug! needs to be upper cased!
                // router.upperCasedMethods;
            } else {
                methods = {method};
            }

            contextData->router.add(methods, path, [handler = std::move(cb)](HttpRouter<Http3ContextData::RouterData> *router) mutable {

                Http3ContextData::RouterData &routerData = router->getUserData();

                handler(routerData.res, routerData.req);

                return true;
            });
        }
    };
}
```

`src/Http3ContextData.h`:

```h
#include "HttpRouter.h"

struct Http3Response;
struct Http3Request;

namespace uWS {

    struct Http3ContextData {
        struct RouterData {
            Http3Response *res;
            Http3Request *req;
        };

        HttpRouter<RouterData> router;

        Http3ContextData() {
            //printf("Constructing http3contextdata: %p\n", this);
        }
    };
    
}
```

`src/Http3Request.h`:

```h
extern "C" {
#include "quic.h"
}

namespace uWS {

    struct Http3Request {

        std::string_view getHeader(std::string_view key) {
            for (int i = 0, more = 1; more; i++) {
                char *name, *value;
                int name_length, value_length;
                if ((more = us_quic_socket_context_get_header(nullptr, i, &name, &name_length, &value, &value_length))) {
                    if (name_length == (int) key.length() && !memcmp(name, key.data(), key.length())) {
                        return {value, (size_t) value_length};
                    }
                }
            }
            return {nullptr, 0};
        }
    };
}
```

`src/Http3Response.h`:

```h
extern "C" {
#include "quic.h"
}

#include "Http3ResponseData.h"

namespace uWS {

    /* Is a quic stream */
    struct Http3Response {

        // this one is AsyncSocket, so it has to translate to the stream - abrupt stream termination
        void close() {
            //us_quic_stream_close((us_quic_stream_t *) this);
        }

        void endWithoutBody(std::optional<size_t> reportedContentLength = std::nullopt, bool closeConnection = false) {

        }

        Http3Response *writeStatus(std::string_view status) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            /* Nothing is done if status already written */
            if (responseData->headerOffset == 0) {
                us_quic_socket_context_set_header(nullptr, 0, (char *) ":status", 7, status.data(), status.length());
                responseData->headerOffset = 1;
            }

            return this;
        }

        Http3Response *writeHeader(std::string_view key, std::string_view value) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            writeStatus("200 OK");

            us_quic_socket_context_set_header(nullptr, responseData->headerOffset++, key.data(), key.length(), value.data(), value.length());

            return this;
        }

        std::pair<bool, bool> tryEnd(std::string_view data, uintmax_t totalSize = 0) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            writeStatus("200 OK");

            us_quic_socket_context_send_headers(nullptr, (us_quic_stream_t *) this, responseData->headerOffset, data.length() > 0);


            unsigned int written = us_quic_stream_write((us_quic_stream_t *) this, (char *) data.data(), (int) data.length());

            if (written == data.length()) {
                return {true, true};
            } else {

                responseData->offset = written;

                return {true, false};
            }


            return {true, true};
        }

        /* Idnetical */
        Http3Response *write(std::string_view data) {


            return this;
        }

        /* Identical */
        void end(std::string_view data = {}, bool closeConnection = false) {

            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            /* If not already written */
            writeStatus("200 OK");
            
            // has body is determined by the ending so this is perfect here
            us_quic_socket_context_send_headers(nullptr, (us_quic_stream_t *) this, responseData->headerOffset, data.length() > 0);

            /* Write body and shutdown (unknown if content-length must be present?) */
            unsigned int written = us_quic_stream_write((us_quic_stream_t *) this, (char *) data.data(), (int) data.length());

            /* Buffer up remains */
            if (written != data.length()) {
                responseData->backpressure.append(data.data() + written, data.length() - written);
            } else {
                /* Every request has its own stream, so we conceptually serve requests like in HTTP 1.0 */
                us_quic_stream_shutdown((us_quic_stream_t *) this);
            }
        }

        /* Attach handler for aborted HTTP request */
        Http3Response *onAborted(MoveOnlyFunction<void()> &&handler) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            responseData->onAborted = std::move(handler);
            return this;
        }

        /* Attach a read handler for data sent. Will be called with FIN set true if last segment. */
        Http3Response *onData(MoveOnlyFunction<void(std::string_view, bool)> &&handler) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            responseData->onData = std::move(handler);
            return this;
        }

        Http3Response *onWritable(MoveOnlyFunction<bool(uintmax_t)> &&handler) {
            Http3ResponseData *responseData = (Http3ResponseData *) us_quic_stream_ext((us_quic_stream_t *) this);

            responseData->onWritable = std::move(handler);
            return this;
        }
    };

}
```

`src/Http3ResponseData.h`:

```h
#ifndef UWS_H3RESPONSEDATA_H
#define UWS_H3RESPONSEDATA_H

#include "MoveOnlyFunction.h"
#include "AsyncSocketData.h"
#include <string_view>

namespace uWS {
    struct Http3ResponseData {

        MoveOnlyFunction<void()> onAborted = nullptr;
        MoveOnlyFunction<void(std::string_view, bool)> onData = nullptr;
        MoveOnlyFunction<bool(uintmax_t)> onWritable = nullptr;

        /* Status is always first header just like for h1 */
        unsigned int headerOffset = 0;
        
        /* Write offset */
        uintmax_t offset = 0;

        BackPressure backpressure;
    };
}

#endif
```

`src/HttpContext.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2026.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPCONTEXT_H
#define UWS_HTTPCONTEXT_H

/* This class defines the main behavior of HTTP and emits various events */

#include "Loop.h"
#include "HttpContextData.h"
#include "HttpResponseData.h"
#include "AsyncSocket.h"
#include "WebSocketData.h"

#include <string_view>
#include <iostream>
#include "MoveOnlyFunction.h"

namespace uWS {
template<bool> struct HttpResponse;

template <bool SSL>
struct HttpContext {
    template<bool> friend struct TemplatedApp;
    template<bool> friend struct HttpResponse;
private:
    HttpContext() = delete;

    /* Maximum delay allowed until an HTTP connection is terminated due to outstanding request or rejected data (slow loris protection) */
    static const int HTTP_IDLE_TIMEOUT_S = 10;

    /* Minimum allowed receive throughput per second (clients uploading less than 16kB/sec get dropped) */
    static const int HTTP_RECEIVE_THROUGHPUT_BYTES = 16 * 1024;

    us_loop_t *getLoop() {
        return us_socket_context_loop(SSL, getSocketContext());
    }

    us_socket_context_t *getSocketContext() {
        return (us_socket_context_t *) this;
    }

    static us_socket_context_t *getSocketContext(us_socket_t *s) {
        return (us_socket_context_t *) us_socket_context(SSL, s);
    }

    HttpContextData<SSL> *getSocketContextData() {
        return (HttpContextData<SSL> *) us_socket_context_ext(SSL, getSocketContext());
    }

    static HttpContextData<SSL> *getSocketContextDataS(us_socket_t *s) {
        return (HttpContextData<SSL> *) us_socket_context_ext(SSL, getSocketContext(s));
    }

    /* Init the HttpContext by registering libusockets event handlers */
    HttpContext<SSL> *init() {
        /* Handle socket connections */
        us_socket_context_on_open(SSL, getSocketContext(), [](us_socket_t *s, int /*is_client*/, char */*ip*/, int /*ip_length*/) {
            /* Any connected socket should timeout until it has a request */
            us_socket_timeout(SSL, s, HTTP_IDLE_TIMEOUT_S);

            /* Init socket ext */
            new (us_socket_ext(SSL, s)) HttpResponseData<SSL>;

            /* Call filter */
            HttpContextData<SSL> *httpContextData = getSocketContextDataS(s);
            for (auto &f : httpContextData->filterHandlers) {
                f((HttpResponse<SSL> *) s, 1);
            }

            return s;
        });

        /* Handle socket disconnections */
        us_socket_context_on_close(SSL, getSocketContext(), [](us_socket_t *s, int /*code*/, void */*reason*/) {
            /* Get socket ext */
            HttpResponseData<SSL> *httpResponseData = (HttpResponseData<SSL> *) us_socket_ext(SSL, s);

            /* Call filter */
            HttpContextData<SSL> *httpContextData = getSocketContextDataS(s);
            for (auto &f : httpContextData->filterHandlers) {
                f((HttpResponse<SSL> *) s, -1);
            }

            /* Signal broken HTTP request only if we have a pending request */
            if (httpResponseData->onAborted) {
                httpResponseData->onAborted();
            }

            /* Destruct socket ext */
            httpResponseData->~HttpResponseData<SSL>();

            return s;
        });

        /* Handle HTTP data streams */
        us_socket_context_on_data(SSL, getSocketContext(), [](us_socket_t *s, char *data, int length) {

            // total overhead is about 210k down to 180k
            // ~210k req/sec is the original perf with write in data
            // ~200k req/sec is with cork and formatting
            // ~190k req/sec is with http parsing
            // ~180k - 190k req/sec is with varying routing

            HttpContextData<SSL> *httpContextData = getSocketContextDataS(s);

            /* Do not accept any data while in shutdown state */
            if (us_socket_is_shut_down(SSL, (us_socket_t *) s)) {
                return s;
            }

            HttpResponseData<SSL> *httpResponseData = (HttpResponseData<SSL> *) us_socket_ext(SSL, s);

            /* Cork this socket */
            ((AsyncSocket<SSL> *) s)->cork();

            /* Mark that we are inside the parser now */
            httpContextData->isParsingHttp = true;

            // clients need to know the cursor after http parse, not servers!
            // how far did we read then? we need to know to continue with websocket parsing data? or?

            void *proxyParser = nullptr;
#ifdef UWS_WITH_PROXY
            proxyParser = &httpResponseData->proxyParser;
#endif

            /* The return value is entirely up to us to interpret. The HttpParser only care for whether the returned value is DIFFERENT or not from passed user */
            auto [err, returnedSocket] = httpResponseData->consumePostPadded(data, (unsigned int) length, s, proxyParser, [httpContextData](void *s, HttpRequest *httpRequest) -> void * {
                /* For every request we reset the timeout and hang until user makes action */
                /* Warning: if we are in shutdown state, resetting the timer is a security issue! */
                us_socket_timeout(SSL, (us_socket_t *) s, 0);

                /* Reset httpResponse */
                HttpResponseData<SSL> *httpResponseData = (HttpResponseData<SSL> *) us_socket_ext(SSL, (us_socket_t *) s);
                httpResponseData->offset = 0;

                /* Are we not ready for another request yet? Terminate the connection.
                 * Important for denying async pipelining until, if ever, we want to suppot it.
                 * Otherwise requests can get mixed up on the same connection. We still support sync pipelining. */
                if (httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) {
                    us_socket_close(SSL, (us_socket_t *) s, 0, nullptr);
                    return nullptr;
                }

                /* Mark pending request and emit it */
                httpResponseData->state = HttpResponseData<SSL>::HTTP_RESPONSE_PENDING;

                /* Mark this response as connectionClose if ancient or connection: close */
                if (httpRequest->isAncient() || httpRequest->getHeader("connection").length() == 5) {
                    httpResponseData->state |= HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE;
                }

                /* Select the router based on SNI (only possible for SSL) */
                auto *selectedRouter = &httpContextData->router;
                if constexpr (SSL) {
                    void *domainRouter = us_socket_server_name_userdata(SSL, (struct us_socket_t *) s);
                    if (domainRouter) {
                        selectedRouter = (decltype(selectedRouter)) domainRouter;
                    }
                }

                /* Route the method and URL */
                selectedRouter->getUserData() = {(HttpResponse<SSL> *) s, httpRequest};
                if (!selectedRouter->route(httpRequest->getCaseSensitiveMethod(), httpRequest->getUrl())) {
                    /* We have to force close this socket as we have no handler for it */
                    us_socket_close(SSL, (us_socket_t *) s, 0, nullptr);
                    return nullptr;
                }

                /* First of all we need to check if this socket was deleted due to upgrade */
                if (httpContextData->upgradedWebSocket) {
                    /* We differ between closed and upgraded below */
                    return nullptr;
                }

                /* Was the socket closed? */
                if (us_socket_is_closed(SSL, (struct us_socket_t *) s)) {
                    return nullptr;
                }

                /* We absolutely have to terminate parsing if shutdown */
                if (us_socket_is_shut_down(SSL, (us_socket_t *) s)) {
                    return nullptr;
                }

                /* Returning from a request handler without responding or attaching an onAborted handler is ill-use */
                if (!((HttpResponse<SSL> *) s)->hasResponded() && !httpResponseData->onAborted) {
                    /* Throw exception here? */
                    std::cerr << "Error: Returning from a request handler without responding or attaching an abort handler is forbidden!"
                              << std::endl
                              << "\tMethod: \"" << httpRequest->getCaseSensitiveMethod() << "\"" << std::endl
                              << "\tURL: \"" << httpRequest->getUrl() << "\"" << std::endl;
                    std::terminate();
                }

                /* If we have not responded and we have a data handler, we need to timeout to enfore client sending the data */
                if (!((HttpResponse<SSL> *) s)->hasResponded() && httpResponseData->inStream) {
                    us_socket_timeout(SSL, (us_socket_t *) s, HTTP_IDLE_TIMEOUT_S);
                }

                /* Continue parsing */
                return s;

            }, [httpResponseData](void *user, std::string_view data, bool fin) -> void * {
                /* We always get an empty chunk even if there is no data */
                if (httpResponseData->inStream) {

                    /* Todo: can this handle timeout for non-post as well? */
                    if (fin) {
                        /* If we just got the last chunk (or empty chunk), disable timeout */
                        us_socket_timeout(SSL, (struct us_socket_t *) user, 0);
                    } else {
                        /* We still have some more data coming in later, so reset timeout */
                        /* Only reset timeout if we got enough bytes (16kb/sec) since last time we reset here */
                        httpResponseData->received_bytes_per_timeout += (unsigned int) data.length();
                        if (httpResponseData->received_bytes_per_timeout >= HTTP_RECEIVE_THROUGHPUT_BYTES * HTTP_IDLE_TIMEOUT_S) {
                            us_socket_timeout(SSL, (struct us_socket_t *) user, HTTP_IDLE_TIMEOUT_S);
                            httpResponseData->received_bytes_per_timeout = 0;
                        }
                    }

                    /* We might respond in the handler, so do not change timeout after this */
                    httpResponseData->inStream(data, fin);

                    /* Was the socket closed? */
                    if (us_socket_is_closed(SSL, (struct us_socket_t *) user)) {
                        return nullptr;
                    }

                    /* We absolutely have to terminate parsing if shutdown */
                    if (us_socket_is_shut_down(SSL, (us_socket_t *) user)) {
                        return nullptr;
                    }

                    /* If we were given the last data chunk, reset data handler to ensure following
                     * requests on the same socket won't trigger any previously registered behavior */
                    if (fin) {
                        httpResponseData->inStream = nullptr;
                    }
                }
                return user;
            });

            /* Mark that we are no longer parsing Http */
            httpContextData->isParsingHttp = false;

            /* If we got fullptr that means the parser wants us to close the socket from error (same as calling the errorHandler) */
            if (returnedSocket == FULLPTR) {
                /* For errors, we only deliver them "at most once". We don't care if they get halfways delivered or not. */
                us_socket_write(SSL, s, httpErrorResponses[err].data(), (int) httpErrorResponses[err].length(), false);
                us_socket_shutdown(SSL, s);
                /* Close any socket on HTTP errors */
                us_socket_close(SSL, s, 0, nullptr);
                /* This just makes the following code act as if the socket was closed from error inside the parser. */
                returnedSocket = nullptr;
            }

            /* We need to uncork in all cases, except for nullptr (closed socket, or upgraded socket) */
            if (returnedSocket != nullptr) {
                /* Timeout on uncork failure */
                auto [written, failed] = ((AsyncSocket<SSL> *) returnedSocket)->uncork();
                if (failed) {
                    /* All Http sockets timeout by this, and this behavior match the one in HttpResponse::cork */
                    /* Warning: both HTTP_IDLE_TIMEOUT_S and HTTP_TIMEOUT_S are 10 seconds and both are used the same */
                    ((AsyncSocket<SSL> *) s)->timeout(HTTP_IDLE_TIMEOUT_S);
                }

                /* We need to check if we should close this socket here now */
                if (httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) {
                    if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) == 0) {
                        if (((AsyncSocket<SSL> *) s)->getBufferedAmount() == 0) {
                            ((AsyncSocket<SSL> *) s)->shutdown();
                            /* We need to force close after sending FIN since we want to hinder
                             * clients from keeping to send their huge data */
                            ((AsyncSocket<SSL> *) s)->close();
                        }
                    }
                }

                return (us_socket_t *) returnedSocket;
            }

            /* If we upgraded, check here (differ between nullptr close and nullptr upgrade) */
            if (httpContextData->upgradedWebSocket) {
                /* This path is only for upgraded websockets */
                AsyncSocket<SSL> *asyncSocket = (AsyncSocket<SSL> *) httpContextData->upgradedWebSocket;

                /* Uncork here as well (note: what if we failed to uncork and we then pub/sub before we even upgraded?) */
                auto [written, failed] = asyncSocket->uncork();

                /* If we succeeded in uncorking, check if we have sent WebSocket FIN */
                if (!failed) {
                    WebSocketData *webSocketData = (WebSocketData *) asyncSocket->getAsyncSocketData();
                    if (webSocketData->isShuttingDown) {
                        /* In that case, also send TCP FIN (this is similar to what we have in ws drain handler) */
                        asyncSocket->shutdown();
                    }
                }

                /* Reset upgradedWebSocket before we return */
                httpContextData->upgradedWebSocket = nullptr;

                /* Return the new upgraded websocket */
                return (us_socket_t *) asyncSocket;
            }

            /* It is okay to uncork a closed socket and we need to */
            ((AsyncSocket<SSL> *) s)->uncork();

            /* We cannot return nullptr to the underlying stack in any case */
            return s;
        });

        /* Handle HTTP write out (note: SSL_read may trigger this spuriously, the app need to handle spurious calls) */
        us_socket_context_on_writable(SSL, getSocketContext(), [](us_socket_t *s) {

            AsyncSocket<SSL> *asyncSocket = (AsyncSocket<SSL> *) s;
            HttpResponseData<SSL> *httpResponseData = (HttpResponseData<SSL> *) asyncSocket->getAsyncSocketData();

            /* Ask the developer to write data and return success (true) or failure (false), OR skip sending anything and return success (true). */
            if (httpResponseData->onWritable) {
                /* We are now writable, so hang timeout again, the user does not have to do anything so we should hang until end or tryEnd rearms timeout */
                us_socket_timeout(SSL, s, 0);

                /* We expect the developer to return whether or not write was successful (true).
                 * If write was never called, the developer should still return true so that we may drain. */
                bool success = httpResponseData->callOnWritable(httpResponseData->offset);

                /* The developer indicated that their onWritable failed. */
                if (!success) {
                    /* Skip testing if we can drain anything since that might perform an extra syscall */
                    return s;
                }

                /* We don't want to fall through since we don't want to mess with timeout.
                 * It makes little sense to drain any backpressure when the user has registered onWritable. */
                return s;
            }

            /* Drain any socket buffer, this might empty our backpressure and thus finish the request */
            /*auto [written, failed] = */asyncSocket->write(nullptr, 0, true, 0);

            /* Should we close this connection after a response - and is this response really done? */
            if (httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) {
                if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) == 0) {
                    if (asyncSocket->getBufferedAmount() == 0) {
                        asyncSocket->shutdown();
                        /* We need to force close after sending FIN since we want to hinder
                         * clients from keeping to send their huge data */
                        asyncSocket->close();
                    }
                }
            }

            /* Expect another writable event, or another request within the timeout */
            asyncSocket->timeout(HTTP_IDLE_TIMEOUT_S);

            return s;
        });

        /* Handle FIN, HTTP does not support half-closed sockets, so simply close */
        us_socket_context_on_end(SSL, getSocketContext(), [](us_socket_t *s) {

            /* We do not care for half closed sockets */
            AsyncSocket<SSL> *asyncSocket = (AsyncSocket<SSL> *) s;
            return asyncSocket->close();

        });

        /* Handle socket timeouts, simply close them so to not confuse client with FIN */
        us_socket_context_on_timeout(SSL, getSocketContext(), [](us_socket_t *s) {

            /* Force close rather than gracefully shutdown and risk confusing the client with a complete download */
            AsyncSocket<SSL> *asyncSocket = (AsyncSocket<SSL> *) s;
            return asyncSocket->close();

        });

        return this;
    }

public:
    /* Construct a new HttpContext using specified loop */
    static HttpContext *create(Loop *loop, us_socket_context_options_t options = {}) {
        HttpContext *httpContext;

        httpContext = (HttpContext *) us_create_socket_context(SSL, (us_loop_t *) loop, sizeof(HttpContextData<SSL>), options);

        if (!httpContext) {
            return nullptr;
        }

        /* Init socket context data */
        new ((HttpContextData<SSL> *) us_socket_context_ext(SSL, (us_socket_context_t *) httpContext)) HttpContextData<SSL>();
        return httpContext->init();
    }

    /* Destruct the HttpContext, it does not follow RAII */
    void free() {
        /* Destruct socket context data */
        HttpContextData<SSL> *httpContextData = getSocketContextData();
        httpContextData->~HttpContextData<SSL>();

        /* Free the socket context in whole */
        us_socket_context_free(SSL, getSocketContext());
    }

    void filter(MoveOnlyFunction<void(HttpResponse<SSL> *, int)> &&filterHandler) {
        getSocketContextData()->filterHandlers.emplace_back(std::move(filterHandler));
    }

    /* Register an HTTP route handler acording to URL pattern */
    void onHttp(std::string method, std::string pattern, MoveOnlyFunction<void(HttpResponse<SSL> *, HttpRequest *)> &&handler, bool upgrade = false) {
        HttpContextData<SSL> *httpContextData = getSocketContextData();

        /* Todo: This is ugly, fix */
        std::vector<std::string> methods;
        if (method == "*") {
            methods = {"*"};
        } else {
            methods = {method};
        }

        uint32_t priority = method == "*" ? httpContextData->currentRouter->LOW_PRIORITY : (upgrade ? httpContextData->currentRouter->HIGH_PRIORITY : httpContextData->currentRouter->MEDIUM_PRIORITY);

        /* If we are passed nullptr then remove this */
        if (!handler) {
            httpContextData->currentRouter->remove(methods[0], pattern, priority);
            return;
        }

        /* Record this route's parameter offsets */
        std::map<std::string, unsigned short, std::less<>> parameterOffsets;
        unsigned short offset = 0;
        for (unsigned int i = 0; i < pattern.length(); i++) {
            if (pattern[i] == ':') {
                i++;
                unsigned int start = i;
                while (i < pattern.length() && pattern[i] != '/') {
                    i++;
                }
                parameterOffsets[std::string(pattern.data() + start, i - start)] = offset;
                //std::cout << "<" << std::string(pattern.data() + start, i - start) << "> is offset " << offset;
                offset++;
            }
        }

        httpContextData->currentRouter->add(methods, pattern, [handler = std::move(handler), parameterOffsets = std::move(parameterOffsets)](auto *r) mutable {
            auto user = r->getUserData();
            user.httpRequest->setYield(false);
            user.httpRequest->setParameters(r->getParameters());
            user.httpRequest->setParameterOffsets(&parameterOffsets);

            /* Middleware? Automatically respond to expectations */
            std::string_view expect = user.httpRequest->getHeader("expect");
            if (expect.length() && expect == "100-continue") {
                user.httpResponse->writeContinue();
            }

            handler(user.httpResponse, user.httpRequest);

            /* If any handler yielded, the router will keep looking for a suitable handler. */
            if (user.httpRequest->getYield()) {
                return false;
            }
            return true;
        }, priority);
    }

    /* Listen to port using this HttpContext */
    us_listen_socket_t *listen(const char *host, int port, int options) {
        return us_socket_context_listen(SSL, getSocketContext(), host, port, options, sizeof(HttpResponseData<SSL>));
    }

    /* Listen to unix domain socket using this HttpContext */
    us_listen_socket_t *listen(const char *path, int options) {
        return us_socket_context_listen_unix(SSL, getSocketContext(), path, options, sizeof(HttpResponseData<SSL>));
    }

    void onPreOpen(LIBUS_SOCKET_DESCRIPTOR (*handler)(struct us_socket_context_t *, LIBUS_SOCKET_DESCRIPTOR)) {
        us_socket_context_on_pre_open(SSL, getSocketContext(), handler);
    }

    /* Adopt an externally accepted socket into this HttpContext */
    us_socket_t *adoptAcceptedSocket(LIBUS_SOCKET_DESCRIPTOR accepted_fd) {
        return us_adopt_accepted_socket(SSL, getSocketContext(), accepted_fd, sizeof(HttpResponseData<SSL>), 0, 0);
    }
};

}

#endif // UWS_HTTPCONTEXT_H

```

`src/HttpContextData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPCONTEXTDATA_H
#define UWS_HTTPCONTEXTDATA_H

#include "HttpRouter.h"

#include <vector>
#include "MoveOnlyFunction.h"

namespace uWS {
template<bool> struct HttpResponse;
struct HttpRequest;

template <bool SSL>
struct alignas(16) HttpContextData {
    template <bool> friend struct HttpContext;
    template <bool> friend struct HttpResponse;
    template <bool> friend struct TemplatedApp;
private:
    std::vector<MoveOnlyFunction<void(HttpResponse<SSL> *, int)>> filterHandlers;

    MoveOnlyFunction<void(const char *hostname)> missingServerNameHandler;

    struct RouterData {
        HttpResponse<SSL> *httpResponse;
        HttpRequest *httpRequest;
    };

    /* This is the currently browsed-to router when using SNI */
    HttpRouter<RouterData> *currentRouter = &router;

    /* This is the default router for default SNI or non-SSL */
    HttpRouter<RouterData> router;
    void *upgradedWebSocket = nullptr;
    bool isParsingHttp = false;

    /* If we are main acceptor, distribute to these apps */
    std::vector<void *> childApps;
    unsigned int roundRobin = 0;
};

}

#endif // UWS_HTTPCONTEXTDATA_H

```

`src/HttpErrors.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2023.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTP_ERRORS
#define UWS_HTTP_ERRORS

#include <string_view>

namespace uWS {
/* Possible errors from http parsing */
enum HttpError {
    HTTP_ERROR_505_HTTP_VERSION_NOT_SUPPORTED = 1,
    HTTP_ERROR_431_REQUEST_HEADER_FIELDS_TOO_LARGE = 2,
    HTTP_ERROR_400_BAD_REQUEST = 3
};

#ifndef UWS_HTTPRESPONSE_NO_WRITEMARK

/* Returned parser errors match this LUT. */
static const std::string_view httpErrorResponses[] = {
    "", /* Zeroth place is no error so don't use it */
    "HTTP/1.1 505 HTTP Version Not Supported\r\nConnection: close\r\n\r\n<h1>HTTP Version Not Supported</h1><p>This server does not support HTTP/1.0.</p><hr><i>uWebSockets/20 Server</i>",
    "HTTP/1.1 431 Request Header Fields Too Large\r\nConnection: close\r\n\r\n<h1>Request Header Fields Too Large</h1><hr><i>uWebSockets/20 Server</i>",
    "HTTP/1.1 400 Bad Request\r\nConnection: close\r\n\r\n<h1>Bad Request</h1><hr><i>uWebSockets/20 Server</i>",
};

#else
/* Anonymized pages */
static const std::string_view httpErrorResponses[] = {
    "", /* Zeroth place is no error so don't use it */
    "HTTP/1.1 505 HTTP Version Not Supported\r\nConnection: close\r\n\r\n",
    "HTTP/1.1 431 Request Header Fields Too Large\r\nConnection: close\r\n\r\n",
    "HTTP/1.1 400 Bad Request\r\nConnection: close\r\n\r\n"
};
#endif

}

#endif
```

`src/HttpParser.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2024.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPPARSER_H
#define UWS_HTTPPARSER_H

// todo: HttpParser is in need of a few clean-ups and refactorings

/* The HTTP parser is an independent module subject to unit testing / fuzz testing */

#include <string>
#include <cstring>
#include <algorithm>
#include <climits>
#include <string_view>
#include <map>
#include "MoveOnlyFunction.h"
#include "ChunkedEncoding.h"

#include "BloomFilter.h"
#include "ProxyParser.h"
#include "QueryParser.h"
#include "HttpErrors.h"

namespace uWS {

/* We require at least this much post padding */
static const unsigned int MINIMUM_HTTP_POST_PADDING = 32;
static void *FULLPTR = (void *)~(uintptr_t)0;

/* STL needs one of these */
template <typename T>
std::optional<T *> optional_ptr(T *ptr) {
    return ptr ? std::optional<T *>(ptr) : std::nullopt;
}

static const size_t MAX_FALLBACK_SIZE = (size_t) atoi(optional_ptr(getenv("UWS_HTTP_MAX_HEADERS_SIZE")).value_or((char *) "4096"));
#ifndef UWS_HTTP_MAX_HEADERS_COUNT
#define UWS_HTTP_MAX_HEADERS_COUNT 100
#endif

struct HttpRequest {

    friend struct HttpParser;

private:
    struct Header {
        std::string_view key, value;
    } headers[UWS_HTTP_MAX_HEADERS_COUNT];
    bool ancientHttp;
    unsigned int querySeparator;
    bool didYield;
    BloomFilter bf;
    std::pair<int, std::string_view *> currentParameters;
    std::map<std::string, unsigned short, std::less<>> *currentParameterOffsets = nullptr;

public:
    bool isAncient() {
        return ancientHttp;
    }

    bool getYield() {
        return didYield;
    }

    /* Iteration over headers (key, value) */
    struct HeaderIterator {
        Header *ptr;

        bool operator!=(const HeaderIterator &other) const {
            /* Comparison with end is a special case */
            if (ptr != other.ptr) {
                return other.ptr || ptr->key.length();
            }
            return false;
        }

        HeaderIterator &operator++() {
            ptr++;
            return *this;
        }

        std::pair<std::string_view, std::string_view> operator*() const {
            return {ptr->key, ptr->value};
        }
    };

    HeaderIterator begin() {
        return {headers + 1};
    }

    HeaderIterator end() {
        return {nullptr};
    }

    /* If you do not want to handle this route */
    void setYield(bool yield) {
        didYield = yield;
    }

    std::string_view getHeader(std::string_view lowerCasedHeader) {
        if (bf.mightHave(lowerCasedHeader)) {
            for (Header *h = headers; (++h)->key.length(); ) {
                if (h->key.length() == lowerCasedHeader.length() && !strncmp(h->key.data(), lowerCasedHeader.data(), lowerCasedHeader.length())) {
                    return h->value;
                }
            }
        }
        return std::string_view(nullptr, 0);
    }

    std::string_view getUrl() {
        return std::string_view(headers->value.data(), querySeparator);
    }

    std::string_view getFullUrl() {
        return std::string_view(headers->value.data(), headers->value.length());
    }

    /* Hack: this should be getMethod */
    std::string_view getCaseSensitiveMethod() {
        return std::string_view(headers->key.data(), headers->key.length());
    }

    std::string_view getMethod() {
        /* Compatibility hack: lower case method (todo: remove when major version bumps) */
        for (unsigned int i = 0; i < headers->key.length(); i++) {
            ((char *) headers->key.data())[i] |= 32;
        }

        return std::string_view(headers->key.data(), headers->key.length());
    }

    /* Returns the raw querystring as a whole, still encoded */
    std::string_view getQuery() {
        if (querySeparator < headers->value.length()) {
            /* Strip the initial ? */
            return std::string_view(headers->value.data() + querySeparator + 1, headers->value.length() - querySeparator - 1);
        } else {
            return std::string_view(nullptr, 0);
        }
    }

    /* Finds and decodes the URI component. */
    std::string_view getQuery(std::string_view key) {
        /* Raw querystring including initial '?' sign */
        std::string_view queryString = std::string_view(headers->value.data() + querySeparator, headers->value.length() - querySeparator);

        return getDecodedQueryValue(key, queryString);
    }

    void setParameters(std::pair<int, std::string_view *> parameters) {
        currentParameters = parameters;
    }

    void setParameterOffsets(std::map<std::string, unsigned short, std::less<>> *offsets) {
        currentParameterOffsets = offsets;
    }

    std::string_view getParameter(std::string_view name) {
        if (!currentParameterOffsets) {
            return {nullptr, 0};
        }
        auto it = currentParameterOffsets->find(name);
        if (it == currentParameterOffsets->end()) {
            return {nullptr, 0};
        }
        return getParameter(it->second);
    }

    std::string_view getParameter(unsigned short index) {
        if (currentParameters.first < (int) index) {
            return {};
        } else {
            return currentParameters.second[index];
        }
    }

};

struct HttpParser {

private:
    std::string fallback;
    /* This guy really has only 30 bits since we reserve two highest bits to chunked encoding parsing state */
    uint64_t remainingStreamingBytes = 0;

    /* Returns UINT64_MAX on error. Maximum 999999999 is allowed. */
    static uint64_t toUnsignedInteger(std::string_view str) {
        /* We assume at least 64-bit integer giving us safely 999999999999999999 (18 number of 9s) */
        if (str.length() > 18) {
            return UINT64_MAX;
        }

        uint64_t unsignedIntegerValue = 0;
        for (char c : str) {
            /* As long as the letter is 0-9 we cannot overflow. */
            if (c < '0' || c > '9') {
                return UINT64_MAX;
            }
            unsignedIntegerValue = unsignedIntegerValue * 10ull + ((unsigned int) c - (unsigned int) '0');
        }
        return unsignedIntegerValue;
    }
    
    static inline uint64_t hasLess(uint64_t x, uint64_t n) {
        return (((x)-~0ULL/255*(n))&~(x)&~0ULL/255*128);
    }

    static inline uint64_t hasMore(uint64_t x, uint64_t n) {
        return (( ((x)+~0ULL/255*(127-(n))) |(x))&~0ULL/255*128);
    }

    static inline uint64_t hasBetween(uint64_t x, uint64_t m, uint64_t n) {
        return (( (~0ULL/255*(127+(n))-((x)&~0ULL/255*127)) &~(x)& (((x)&~0ULL/255*127)+~0ULL/255*(127-(m))) )&~0ULL/255*128);
    }

    static inline bool notFieldNameWord(uint64_t x) {
        return hasLess(x, '-') |
        hasBetween(x, '-', '0') |
        hasBetween(x, '9', 'A') |
        hasBetween(x, 'Z', 'a') |
        hasMore(x, 'z');
    }

    /* RFC 9110 5.6.2. Tokens */
    /* Hyphen is not checked here as it is very common */
    static inline bool isUnlikelyFieldNameByte(unsigned char c)
    {
        /* Digits and 14 of the 15 non-alphanum characters (lacking hyphen) */
        return ((c == '~') | (c == '|') | (c == '`') | (c == '_') | (c == '^') | (c == '.') | (c == '+')
            | (c == '*') | (c == '!')) || ((c >= 48) & (c <= 57)) || ((c <= 39) & (c >= 35));
    }

    static inline bool isFieldNameByteFastLowercased(unsigned char &in) {
        /* Most common is lowercase alpha and hyphen */
        if (((in >= 97) & (in <= 122)) | (in == '-')) [[likely]] {
            return true;
        /* Second is upper case alpha */
        } else if ((in >= 65) & (in <= 90)) [[unlikely]] {
            in |= 32;
            return true;
        /* These are rarely used but still valid */
        } else if (isUnlikelyFieldNameByte(in)) [[unlikely]] {
            return true;
        }
        return false;
    }
    
    static inline void *consumeFieldName(char *p) {
        /* Best case fast path (particularly useful with clang) */
        while (true) {
            while ((*p >= 65) & (*p <= 90)) [[likely]] {
                *p |= 32;
                p++;
            }
            while (((*p >= 97) & (*p <= 122))) [[likely]] {
                p++;
            }
            if (*p == ':') {
                return (void *)p;
            }
            if (*p == '-') {
                p++;
            } else if (!((*p >= 65) & (*p <= 90))) {
                /* Exit fast path parsing */
                break;
            }
        }

        /* Generic */
        while (isFieldNameByteFastLowercased(*(unsigned char *)p)) {
            p++;
        }
        return (void *)p;
    }

    /* Puts method as key, target as value and returns non-null (or nullptr on error). */
    static inline char *consumeRequestLine(char *data, char *end, HttpRequest::Header &header) {
        /* Scan until single SP, assume next is / (origin request) */
        char *start = data;
        /* This catches the post padded CR and fails */
        while (data[0] > 32) data++;
        if (&data[1] == end) [[unlikely]] {
            return nullptr;
        }
        if (data[0] == 32 && data[1] == '/') [[likely]] {
            header.key = {start, (size_t) (data - start)};
            data++;
            /* Scan for less than 33 (catches post padded CR and fails) */
            start = data;
            for (; true; data += 8) {
                uint64_t word;
                memcpy(&word, data, sizeof(uint64_t));
                if (hasLess(word, 33)) {
                    while (*(unsigned char *)data > 32) data++;
                    /* Now we stand on space */
                    header.value = {start, (size_t) (data - start)};
                    /* Check that the following is http 1.1 */
                    if (data + 11 >= end) {
                        /* Whatever we have must be part of the version string */
                        if (memcmp(" HTTP/1.1\r\n", data, std::min<unsigned int>(11, (unsigned int) (end - data))) == 0) {
                            return nullptr;
                        }
                        return (char *) 0x1;
                    }
                    if (memcmp(" HTTP/1.1\r\n", data, 11) == 0) {
                        return data + 11;
                    }
                    /* If we stand at the post padded CR, we have fragmented input so try again later */
                    if (data[0] == '\r') {
                        return nullptr;
                    }
                    /* This is an error */
                    return (char *) 0x1;
                }
            }
        }
        /* If we stand at the post padded CR, we have fragmented input so try again later */
        if (data[0] == '\r') {
            return nullptr;
        }
        return (char *) 0x1;
    }

    /* RFC 9110: 5.5 Field Values (TLDR; anything above 31 is allowed; htab (9) is also allowed)
     * Field values are usually constrained to the range of US-ASCII characters [...]
     * Field values containing CR, LF, or NUL characters are invalid and dangerous [...]
     * Field values containing other CTL characters are also invalid. */
    static inline void *tryConsumeFieldValue(char *p) {
        for (; true; p += 8) {
            uint64_t word;
            memcpy(&word, p, sizeof(uint64_t));
            if (hasLess(word, 32)) {
                while (*(unsigned char *)p > 31) p++;
                return (void *)p;
            }
        }
    }

    /* End is only used for the proxy parser. The HTTP parser recognizes "\ra" as invalid "\r\n" scan and breaks. */
    static unsigned int getHeaders(char *postPaddedBuffer, char *end, struct HttpRequest::Header *headers, void *reserved, unsigned int &err) {
        char *preliminaryKey, *preliminaryValue, *start = postPaddedBuffer;

        #ifdef UWS_WITH_PROXY
            /* ProxyParser is passed as reserved parameter */
            ProxyParser *pp = (ProxyParser *) reserved;

            /* Parse PROXY protocol */
            auto [done, offset] = pp->parse({postPaddedBuffer, (size_t) (end - postPaddedBuffer)});
            if (!done) {
                /* We do not reset the ProxyParser (on filure) since it is tied to this
                * connection, which is really only supposed to ever get one PROXY frame
                * anyways. We do however allow multiple PROXY frames to be sent (overwrites former). */
                return 0;
            } else {
                /* We have consumed this data so skip it */
                postPaddedBuffer += offset;
            }
        #else
            /* This one is unused */
            (void) reserved;
            (void) end;
        #endif

        /* It is critical for fallback buffering logic that we only return with success
         * if we managed to parse a complete HTTP request (minus data). Returning success
         * for PROXY means we can end up succeeding, yet leaving bytes in the fallback buffer
         * which is then removed, and our counters to flip due to overflow and we end up with a crash */

        /* The request line is different from the field names / field values */
        if ((char *) 2 > (postPaddedBuffer = consumeRequestLine(postPaddedBuffer, end, headers[0]))) {
            /* Error - invalid request line */
            /* Assuming it is 505 HTTP Version Not Supported */
            err = postPaddedBuffer ? HTTP_ERROR_505_HTTP_VERSION_NOT_SUPPORTED : 0;
            return 0;
        }
        headers++;

        for (unsigned int i = 1; i < UWS_HTTP_MAX_HEADERS_COUNT - 1; i++) {
            /* Lower case and consume the field name */
            preliminaryKey = postPaddedBuffer;
            postPaddedBuffer = (char *) consumeFieldName(postPaddedBuffer);
            headers->key = std::string_view(preliminaryKey, (size_t) (postPaddedBuffer - preliminaryKey));

            /* We should not accept whitespace between key and colon, so colon must foloow immediately */
            if (postPaddedBuffer[0] != ':') {
                /* If we stand at the end, we are fragmented */
                if (postPaddedBuffer == end) {
                    return 0;
                }
                /* Error: invalid chars in field name */
                err = HTTP_ERROR_400_BAD_REQUEST;
                return 0;
            }
            postPaddedBuffer++;

            preliminaryValue = postPaddedBuffer;
            /* The goal of this call is to find next "\r\n", or any invalid field value chars, fast */
            while (true) {
                postPaddedBuffer = (char *) tryConsumeFieldValue(postPaddedBuffer);
                /* If this is not CR then we caught some stinky invalid char on the way */
                if (postPaddedBuffer[0] != '\r') {
                    /* If TAB then keep searching */
                    if (postPaddedBuffer[0] == '\t') {
                        postPaddedBuffer++;
                        continue;
                    }
                    /* Error - invalid chars in field value */
                    err = HTTP_ERROR_400_BAD_REQUEST;
                    return 0;
                }
                break;
            }
            /* We fence end[0] with \r, followed by end[1] being something that is "not \n", to signify "not found".
                * This way we can have this one single check to see if we found \r\n WITHIN our allowed search space. */
            if (postPaddedBuffer[1] == '\n') {
                /* Store this header, it is valid */
                headers->value = std::string_view(preliminaryValue, (size_t) (postPaddedBuffer - preliminaryValue));
                postPaddedBuffer += 2;

                /* Trim trailing whitespace (SP, HTAB) */
                while (headers->value.length() && headers->value.back() < 33) {
                    headers->value.remove_suffix(1);
                }

                /* Trim initial whitespace (SP, HTAB) */
                while (headers->value.length() && headers->value.front() < 33) {
                    headers->value.remove_prefix(1);
                }
                
                headers++;

                /* We definitely have at least one header (or request line), so check if we are done */
                if (*postPaddedBuffer == '\r') {
                    if (postPaddedBuffer[1] == '\n') {
                        /* This cann take the very last header space */
                        headers->key = std::string_view(nullptr, 0);
                        return (unsigned int) ((postPaddedBuffer + 2) - start);
                    } else {
                        /* \r\n\r plus non-\n letter is malformed request, or simply out of search space */
                        if (postPaddedBuffer + 1 < end) {
                            err = HTTP_ERROR_400_BAD_REQUEST;
                        }
                        return 0;
                    }
                }
            } else {
                /* We are either out of search space or this is a malformed request */
                return 0;
            }
        }
        /* We ran out of header space, too large request */
        err = HTTP_ERROR_431_REQUEST_HEADER_FIELDS_TOO_LARGE;
        return 0;
    }

    /* This is the only caller of getHeaders and is thus the deepest part of the parser.
     * From here we return either [consumed, user] for "keep going",
      * or [consumed, nullptr] for "break; I am closed or upgraded to websocket"
      * or [whatever, fullptr] for "break and close me, I am a parser error!" */
    template <int CONSUME_MINIMALLY>
    std::pair<unsigned int, void *> fenceAndConsumePostPadded(char *data, unsigned int length, void *user, void *reserved, HttpRequest *req, MoveOnlyFunction<void *(void *, HttpRequest *)> &requestHandler, MoveOnlyFunction<void *(void *, std::string_view, bool)> &dataHandler) {

        /* How much data we CONSUMED (to throw away) */
        unsigned int consumedTotal = 0;
        unsigned int err = 0;

        /* Fence two bytes past end of our buffer (buffer has post padded margins).
         * This is to always catch scan for \r but not for \r\n. */
        data[length] = '\r';
        data[length + 1] = 'a'; /* Anything that is not \n, to trigger "invalid request" */

        for (unsigned int consumed; length && (consumed = getHeaders(data, data + length, req->headers, reserved, err)); ) {
            data += consumed;
            length -= consumed;
            consumedTotal += consumed;

            /* Even if we could parse it, check for length here as well */
            if (consumed > MAX_FALLBACK_SIZE) {
                return {HTTP_ERROR_431_REQUEST_HEADER_FIELDS_TOO_LARGE, FULLPTR};
            }

            /* Store HTTP version (ancient 1.0 or 1.1) */
            req->ancientHttp = false;

            /* Add all headers to bloom filter */
            req->bf.reset();
            for (HttpRequest::Header *h = req->headers; (++h)->key.length(); ) {
                if (req->bf.mightHave(h->key)) [[unlikely]] {
                    /* Host header is not allowed twice */
                    if (h->key == "host" && req->getHeader("host").data()) {
                        return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
                    }
                }
                req->bf.add(h->key);
            }
            
            /* Break if no host header (but we can have empty string which is different from nullptr) */
            if (!req->getHeader("host").data()) {
                return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
            }

            /* RFC 9112 6.3
            * If a message is received with both a Transfer-Encoding and a Content-Length header field,
            * the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt
            * to perform request smuggling (Section 11.2) or response splitting (Section 11.1) and
            * ought to be handled as an error. */
            std::string_view transferEncodingString = req->getHeader("transfer-encoding");
            std::string_view contentLengthString = req->getHeader("content-length");
            if (transferEncodingString.length() && contentLengthString.length()) {
                /* Returning fullptr is the same as calling the errorHandler */
                /* We could be smart and set an error in the context along with this, to indicate what 
                 * http error response we might want to return */
                return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
            }

            /* Parse query */
            const char *querySeparatorPtr = (const char *) memchr(req->headers->value.data(), '?', req->headers->value.length());
            req->querySeparator = (unsigned int) ((querySeparatorPtr ? querySeparatorPtr : req->headers->value.data() + req->headers->value.length()) - req->headers->value.data());

            /* If returned socket is not what we put in we need
             * to break here as we either have upgraded to
             * WebSockets or otherwise closed the socket. */
            void *returnedUser = requestHandler(user, req);
            if (returnedUser != user) {
                /* We are upgraded to WebSocket or otherwise broken */
                return {consumedTotal, returnedUser};
            }

            /* The rules at play here according to RFC 9112 for requests are essentially:
             * If both content-length and transfer-encoding then invalid message; must break.
             * If has transfer-encoding then must be chunked regardless of value.
             * If content-length then fixed length even if 0.
             * If none of the above then fixed length is 0. */

            /* RFC 9112 6.3
             * If a message is received with both a Transfer-Encoding and a Content-Length header field,
             * the Transfer-Encoding overrides the Content-Length. */
            if (transferEncodingString.length()) {

                /* If a proxy sent us the transfer-encoding header that 100% means it must be chunked or else the proxy is
                 * not RFC 9112 compliant. Therefore it is always better to assume this is the case, since that entirely eliminates 
                 * all forms of transfer-encoding obfuscation tricks. We just rely on the header. */

                /* RFC 9112 6.3
                 * If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the
                 * final encoding, the message body length cannot be determined reliably; the server MUST respond with the
                 * 400 (Bad Request) status code and then close the connection. */

                /* In this case we fail later by having the wrong interpretation (assuming chunked).
                 * This could be made stricter but makes no difference either way, unless forwarding the identical message as a proxy. */

                remainingStreamingBytes = STATE_IS_CHUNKED;
                /* If consume minimally, we do not want to consume anything but we want to mark this as being chunked */
                if (!CONSUME_MINIMALLY) {
                    /* Go ahead and parse it (todo: better heuristics for emitting FIN to the app level) */
                    std::string_view dataToConsume(data, length);
                    for (auto chunk : uWS::ChunkIterator(&dataToConsume, &remainingStreamingBytes)) {
                        dataHandler(user, chunk, chunk.length() == 0);
                    }
                    if (isParsingInvalidChunkedEncoding(remainingStreamingBytes)) {
                        return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
                    }
                    unsigned int consumed = (length - (unsigned int) dataToConsume.length());
                    data = (char *) dataToConsume.data();
                    length = (unsigned int) dataToConsume.length();
                    consumedTotal += consumed;
                }
            } else if (contentLengthString.length()) {
                remainingStreamingBytes = toUnsignedInteger(contentLengthString);
                if (remainingStreamingBytes == UINT64_MAX) {
                    /* Parser error */
                    return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
                }

                if (!CONSUME_MINIMALLY) {
                    unsigned int emittable = (unsigned int) std::min<uint64_t>(remainingStreamingBytes, length);
                    dataHandler(user, std::string_view(data, emittable), emittable == remainingStreamingBytes);
                    remainingStreamingBytes -= emittable;

                    data += emittable;
                    length -= emittable;
                    consumedTotal += emittable;
                }
            } else {
                /* If we came here without a body; emit an empty data chunk to signal no data */
                dataHandler(user, {}, true);
            }

            /* Consume minimally should break as easrly as possible */
            if (CONSUME_MINIMALLY) {
                break;
            }
        }
        /* Whenever we return FULLPTR, the interpretation of "consumed" should be the HttpError enum. */
        if (err) {
            return {err, FULLPTR};
        }
        return {consumedTotal, user};
    }

public:
    std::pair<unsigned int, void *> consumePostPadded(char *data, unsigned int length, void *user, void *reserved, MoveOnlyFunction<void *(void *, HttpRequest *)> &&requestHandler, MoveOnlyFunction<void *(void *, std::string_view, bool)> &&dataHandler) {

        /* This resets BloomFilter by construction, but later we also reset it again.
         * Optimize this to skip resetting twice (req could be made global) */
        HttpRequest req;

        if (remainingStreamingBytes) {

            /* It's either chunked or with a content-length */
            if (isParsingChunkedEncoding(remainingStreamingBytes)) {
                std::string_view dataToConsume(data, length);
                for (auto chunk : uWS::ChunkIterator(&dataToConsume, &remainingStreamingBytes)) {
                    dataHandler(user, chunk, chunk.length() == 0);
                }
                if (isParsingInvalidChunkedEncoding(remainingStreamingBytes)) {
                    return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
                }
                data = (char *) dataToConsume.data();
                length = (unsigned int) dataToConsume.length();
            } else {
                // this is exactly the same as below!
                // todo: refactor this
                if (remainingStreamingBytes >= length) {
                    void *returnedUser = dataHandler(user, std::string_view(data, length), remainingStreamingBytes == length);
                    remainingStreamingBytes -= length;
                    return {0, returnedUser};
                } else {
                    void *returnedUser = dataHandler(user, std::string_view(data, remainingStreamingBytes), true);

                    data += (unsigned int) remainingStreamingBytes;
                    length -= (unsigned int) remainingStreamingBytes;

                    remainingStreamingBytes = 0;

                    if (returnedUser != user) {
                        return {0, returnedUser};
                    }
                }
            }

        } else if (fallback.length()) {
            unsigned int had = (unsigned int) fallback.length();

            size_t maxCopyDistance = std::min<size_t>(MAX_FALLBACK_SIZE - fallback.length(), (size_t) length);

            /* We don't want fallback to be short string optimized, since we want to move it */
            fallback.reserve(fallback.length() + maxCopyDistance + std::max<unsigned int>(MINIMUM_HTTP_POST_PADDING, sizeof(std::string)));
            fallback.append(data, maxCopyDistance);

            // break here on break
            std::pair<unsigned int, void *> consumed = fenceAndConsumePostPadded<true>(fallback.data(), (unsigned int) fallback.length(), user, reserved, &req, requestHandler, dataHandler);
            if (consumed.second != user) {
                return consumed;
            }

            if (consumed.first) {

                /* This logic assumes that we consumed everything in fallback buffer.
                 * This is critically important, as we will get an integer overflow in case
                 * of "had" being larger than what we consumed, and that we would drop data */
                fallback.clear();
                data += consumed.first - had;
                length -= consumed.first - had;

                if (remainingStreamingBytes) {
                    /* It's either chunked or with a content-length */
                    if (isParsingChunkedEncoding(remainingStreamingBytes)) {
                        std::string_view dataToConsume(data, length);
                        for (auto chunk : uWS::ChunkIterator(&dataToConsume, &remainingStreamingBytes)) {
                            dataHandler(user, chunk, chunk.length() == 0);
                        }
                        if (isParsingInvalidChunkedEncoding(remainingStreamingBytes)) {
                            return {HTTP_ERROR_400_BAD_REQUEST, FULLPTR};
                        }
                        data = (char *) dataToConsume.data();
                        length = (unsigned int) dataToConsume.length();
                    } else {
                        // this is exactly the same as above!
                        if (remainingStreamingBytes >= (unsigned int) length) {
                            void *returnedUser = dataHandler(user, std::string_view(data, length), remainingStreamingBytes == (unsigned int) length);
                            remainingStreamingBytes -= length;
                            return {0, returnedUser};
                        } else {
                            void *returnedUser = dataHandler(user, std::string_view(data, remainingStreamingBytes), true);

                            data += (unsigned int) remainingStreamingBytes;
                            length -= (unsigned int) remainingStreamingBytes;

                            remainingStreamingBytes = 0;

                            if (returnedUser != user) {
                                return {0, returnedUser};
                            }
                        }
                    }
                }

            } else {
                if (fallback.length() == MAX_FALLBACK_SIZE) {
                    return {HTTP_ERROR_431_REQUEST_HEADER_FIELDS_TOO_LARGE, FULLPTR};
                }
                return {0, user};
            }
        }

        std::pair<unsigned int, void *> consumed = fenceAndConsumePostPadded<false>(data, length, user, reserved, &req, requestHandler, dataHandler);
        if (consumed.second != user) {
            return consumed;
        }

        data += consumed.first;
        length -= consumed.first;

        if (length) {
            if (length < MAX_FALLBACK_SIZE) {
                fallback.append(data, length);
            } else {
                return {HTTP_ERROR_431_REQUEST_HEADER_FIELDS_TOO_LARGE, FULLPTR};
            }
        }

        // added for now
        return {0, user};
    }
};

}

#endif // UWS_HTTPPARSER_H

```

`src/HttpResponse.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2025.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPRESPONSE_H
#define UWS_HTTPRESPONSE_H

/* An HttpResponse is the channel on which you send back a response */

#include "AsyncSocket.h"
#include "HttpResponseData.h"
#include "HttpContext.h"
#include "HttpContextData.h"
#include "Utilities.h"

#include "WebSocketExtensions.h"
#include "WebSocketHandshake.h"
#include "WebSocket.h"
#include "WebSocketContextData.h"

#include "MoveOnlyFunction.h"

/* todo: tryWrite is missing currently, only send smaller segments with write */

namespace uWS {

/* Some pre-defined status constants to use with writeStatus */
static const char *HTTP_200_OK = "200 OK";

/* The general timeout for HTTP sockets */
static const int HTTP_TIMEOUT_S = 10;

template <bool SSL>
struct HttpResponse : public AsyncSocket<SSL> {
    /* Solely used for getHttpResponseData() */
    template <bool> friend struct TemplatedApp;
    typedef AsyncSocket<SSL> Super;
private:
    HttpResponseData<SSL> *getHttpResponseData() {
        return (HttpResponseData<SSL> *) Super::getAsyncSocketData();
    }

    /* Write an unsigned 32-bit integer in hex */
    void writeUnsignedHex(unsigned int value) {
        /* Buf really only needs to be 8 long but building with
         * -mavx2, GCC still wants to overstep it so made it 16 */
        char buf[16];
        int length = utils::u32toaHex(value, buf);

        /* For now we do this copy */
        Super::write(buf, length);
    }

    /* Write an unsigned 64-bit integer */
    void writeUnsigned64(uint64_t value) {
        char buf[20];
        int length = utils::u64toa(value, buf);

        /* For now we do this copy */
        Super::write(buf, length);
    }

    /* Called only once per request */
    void writeMark() {
        /* Date is always written */
        writeHeader("Date", std::string_view(((LoopData *) us_loop_ext(us_socket_context_loop(SSL, (us_socket_context(SSL, (us_socket_t *) this)))))->date, 29));

        /* You can disable this altogether */
#ifndef UWS_HTTPRESPONSE_NO_WRITEMARK
        if (!Super::getLoopData()->noMark) {
            /* We only expose major version */
            writeHeader("uWebSockets", "20");
        }
#endif
    }

    /* Returns true on success, indicating that it might be feasible to write more data.
     * Will start timeout if stream reaches totalSize or write failure. */
    bool internalEnd(std::string_view data, uintmax_t totalSize, bool optional, bool allowContentLength = true, bool closeConnection = false) {
        /* Write status if not already done */
        writeStatus(HTTP_200_OK);

        /* If no total size given then assume this chunk is everything */
        if (!totalSize) {
            totalSize = data.length();
        }

        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        /* In some cases, such as when refusing huge data we want to close the connection when drained */
        if (closeConnection) {

            /* HTTP 1.1 must send this back unless the client already sent it to us.
             * It is a connection close when either of the two parties say so but the
             * one party must tell the other one so.
             *
             * This check also serves to limit writing the header only once. */
            if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) == 0) {
                writeHeader("Connection", "close");
            }

            httpResponseData->state |= HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE;
        }

        if (httpResponseData->state & HttpResponseData<SSL>::HTTP_WRITE_CALLED) {

            /* We do not have tryWrite-like functionalities, so ignore optional in this path */

            /* Do not allow sending 0 chunk here */
            if (data.length()) {
                Super::write("\r\n", 2);
                writeUnsignedHex((unsigned int) data.length());
                Super::write("\r\n", 2);

                /* Ignoring optional for now */
                Super::write(data.data(), (int) data.length());
            }

            /* Terminating 0 chunk */
            Super::write("\r\n0\r\n\r\n", 7);

            httpResponseData->markDone();

            /* We need to check if we should close this socket here now */
            if (!Super::isCorked()) {
                if (httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) {
                    if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) == 0) {
                        if (((AsyncSocket<SSL> *) this)->getBufferedAmount() == 0) {
                            ((AsyncSocket<SSL> *) this)->shutdown();
                            /* We need to force close after sending FIN since we want to hinder
                                * clients from keeping to send their huge data */
                            ((AsyncSocket<SSL> *) this)->close();
                            return true;
                        }
                    }
                }
            }

            /* tryEnd can never fail when in chunked mode, since we do not have tryWrite (yet), only write */
            Super::timeout(HTTP_TIMEOUT_S);
            return true;
        } else {
            /* Write content-length on first call */
            if (!(httpResponseData->state & HttpResponseData<SSL>::HTTP_END_CALLED)) {
                /* Write mark, this propagates to WebSockets too */
                writeMark();

                /* WebSocket upgrades does not allow content-length */
                if (allowContentLength) {
                    /* Even zero is a valid content-length */
                    Super::write("Content-Length: ", 16);
                    writeUnsigned64(totalSize);
                    Super::write("\r\n\r\n", 4);
                } else {
                    Super::write("\r\n", 2);
                }

                /* Mark end called */
                httpResponseData->state |= HttpResponseData<SSL>::HTTP_END_CALLED;
            }

            /* Even if we supply no new data to write, its failed boolean is useful to know
             * if it failed to drain any prior failed header writes */

            /* Write as much as possible without causing backpressure */
            size_t written = 0;
            bool failed = false;
            while (written < data.length() && !failed) {
                /* uSockets only deals with int sizes, so pass chunks of max signed int size */
                auto writtenFailed = Super::write(data.data() + written, (int) std::min<size_t>(data.length() - written, INT_MAX), optional);

                written += (size_t) writtenFailed.first;
                failed = writtenFailed.second;
            }

            httpResponseData->offset += written;

            /* Success is when we wrote the entire thing without any failures */
            bool success = written == data.length() && !failed;

            /* If we are now at the end, start a timeout. Also start a timeout if we failed. */
            if (!success || httpResponseData->offset == totalSize) {
                Super::timeout(HTTP_TIMEOUT_S);
            }

            /* Remove onAborted, onWritable function and mark done if we reach the end, or if we were given no data (faked size like in HEAD response) */
            /* I need to figure out if this line should rather be simply httpResponseData->offset == data.length() */
            /* No that can't be right, tryEnd with fake length should not complete the response even if the smaller chunk wrote in one go */
            /* Possibly need  to separate endWithoutBody and tryEnd with fake length into two separate calls with a boolean that explicitly marks isHeadOnly */
            if (httpResponseData->offset == totalSize || !data.length()) {
                httpResponseData->markDone();

                /* We need to check if we should close this socket here now */
                if (!Super::isCorked()) {
                    if (httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) {
                        if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) == 0) {
                            if (((AsyncSocket<SSL> *) this)->getBufferedAmount() == 0) {
                                ((AsyncSocket<SSL> *) this)->shutdown();
                                /* We need to force close after sending FIN since we want to hinder
                                * clients from keeping to send their huge data */
                                ((AsyncSocket<SSL> *) this)->close();
                            }
                        }
                    }
                }
            }

            return success;
        }
    }

public:
    /* If we have proxy support; returns the proxed source address as reported by the proxy. */
#ifdef UWS_WITH_PROXY
    std::string_view getProxiedRemoteAddress() {
        return getHttpResponseData()->proxyParser.getSourceAddress();
    }

    std::string_view getProxiedRemoteAddressAsText() {
        return Super::addressAsText(getProxiedRemoteAddress());
    }
#endif

    /* Manually upgrade to WebSocket. Typically called in upgrade handler. Immediately calls open handler.
     * NOTE: Will invalidate 'this' as socket might change location in memory. Throw away after use. */
    template <typename UserData>
    void upgrade(UserData &&userData, std::string_view secWebSocketKey, std::string_view secWebSocketProtocol,
            std::string_view secWebSocketExtensions,
            struct us_socket_context_t *webSocketContext) {

        /* Extract needed parameters from WebSocketContextData */
        WebSocketContextData<SSL, UserData> *webSocketContextData = (WebSocketContextData<SSL, UserData> *) us_socket_context_ext(SSL, webSocketContext);

        /* Note: OpenSSL can be used here to speed this up somewhat */
        char secWebSocketAccept[29] = {};
        WebSocketHandshake::generate(secWebSocketKey.data(), secWebSocketAccept);

        writeStatus("101 Switching Protocols")
            ->writeHeader("Upgrade", "websocket")
            ->writeHeader("Connection", "Upgrade")
            ->writeHeader("Sec-WebSocket-Accept", secWebSocketAccept);

        /* Select first subprotocol if present */
        if (secWebSocketProtocol.length()) {
            writeHeader("Sec-WebSocket-Protocol", secWebSocketProtocol.substr(0, secWebSocketProtocol.find(',')));
        }

        /* Negotiate compression */
        bool perMessageDeflate = false;
        CompressOptions compressOptions = CompressOptions::DISABLED;
        if (secWebSocketExtensions.length() && webSocketContextData->compression != DISABLED) {

            /* Make sure to map SHARED_DECOMPRESSOR to windowBits = 0, not 1  */
            int wantedInflationWindow = 0;
            if ((webSocketContextData->compression & CompressOptions::_DECOMPRESSOR_MASK) != CompressOptions::SHARED_DECOMPRESSOR) {
                wantedInflationWindow = (webSocketContextData->compression & CompressOptions::_DECOMPRESSOR_MASK) >> 8;
            }

            /* Map from selected compressor (this automatically maps SHARED_COMPRESSOR to windowBits 0, not 1) */
            int wantedCompressionWindow = (webSocketContextData->compression & CompressOptions::_COMPRESSOR_MASK) >> 4;

            auto [negCompression, negCompressionWindow, negInflationWindow, negResponse] =
            negotiateCompression(true, wantedCompressionWindow, wantedInflationWindow,
                                        secWebSocketExtensions);

            if (negCompression) {
                perMessageDeflate = true;

                /* Map from negotiated windowBits to compressor and decompressor */
                if (negCompressionWindow == 0) {
                    compressOptions = CompressOptions::SHARED_COMPRESSOR;
                } else {
                    compressOptions = (CompressOptions) ((uint32_t) (negCompressionWindow << 4)
                                                        | (uint32_t) (negCompressionWindow - 7));

                    /* If we are dedicated and have the 3kb then correct any 4kb to 3kb,
                     * (they both share the windowBits = 9) */
                    if (webSocketContextData->compression & DEDICATED_COMPRESSOR_3KB) {
                        compressOptions = DEDICATED_COMPRESSOR_3KB;
                    }
                }

                /* Here we modify the above compression with negotiated decompressor */
                if (negInflationWindow == 0) {
                    compressOptions = CompressOptions(compressOptions | CompressOptions::SHARED_DECOMPRESSOR);
                } else {
                    compressOptions = CompressOptions(compressOptions | (negInflationWindow << 8));
                }

                writeHeader("Sec-WebSocket-Extensions", negResponse);
            }
        }

        internalEnd({nullptr, 0}, 0, false, false);

        /* Grab the httpContext from res */
        HttpContext<SSL> *httpContext = (HttpContext<SSL> *) us_socket_context(SSL, (struct us_socket_t *) this);

        /* Move any backpressure out of HttpResponse */
        BackPressure backpressure(std::move(((AsyncSocketData<SSL> *) getHttpResponseData())->buffer));

        /* Destroy HttpResponseData */
        getHttpResponseData()->~HttpResponseData();

        /* Before we adopt and potentially change socket, check if we are corked */
        bool wasCorked = Super::isCorked();

        /* Adopting a socket invalidates it, do not rely on it directly to carry any data */
        WebSocket<SSL, true, UserData> *webSocket = (WebSocket<SSL, true, UserData> *) us_socket_context_adopt_socket(SSL,
                    (us_socket_context_t *) webSocketContext, (us_socket_t *) this, sizeof(WebSocketData) + sizeof(UserData));

        /* For whatever reason we were corked, update cork to the new socket */
        if (wasCorked) {
            webSocket->AsyncSocket<SSL>::corkUnchecked();
        }

        /* Initialize websocket with any moved backpressure intact */
        webSocket->init(perMessageDeflate, compressOptions, std::move(backpressure));

        /* We should only mark this if inside the parser; if upgrading "async" we cannot set this */
        HttpContextData<SSL> *httpContextData = httpContext->getSocketContextData();
        if (httpContextData->isParsingHttp) {
            /* We need to tell the Http parser that we changed socket */
            httpContextData->upgradedWebSocket = webSocket;
        }

        /* Arm maxLifetime timeout */
        us_socket_long_timeout(SSL, (us_socket_t *) webSocket, webSocketContextData->maxLifetime);

        /* Arm idleTimeout */
        us_socket_timeout(SSL, (us_socket_t *) webSocket, webSocketContextData->idleTimeoutComponents.first);

        /* Move construct the UserData right before calling open handler */
        new (webSocket->getUserData()) UserData(std::move(userData));

        /* Emit open event and start the timeout */
        if (webSocketContextData->openHandler) {
            webSocketContextData->openHandler(webSocket);
        }
    }

    /* Immediately terminate this Http response */
    using Super::close;

    /* See AsyncSocket */
    using Super::getRemoteAddress;
    using Super::getRemoteAddressAsText;
    using Super::getNativeHandle;

    /* Throttle reads and writes */
    HttpResponse *pause() {
        Super::pause();
        Super::timeout(0);
        return this;
    }

    HttpResponse *resume() {
        Super::resume();
        Super::timeout(HTTP_TIMEOUT_S);
        return this;
    }

    /* Note: Headers are not checked in regards to timeout.
     * We only check when you actively push data or end the request */

    /* Write 100 Continue, can be done any amount of times */
    HttpResponse *writeContinue() {
        Super::write("HTTP/1.1 100 Continue\r\n\r\n", 25);
        return this;
    }

    /* Write the HTTP status */
    HttpResponse *writeStatus(std::string_view status) {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        /* Do not allow writing more than one status */
        if (httpResponseData->state & HttpResponseData<SSL>::HTTP_STATUS_CALLED) {
            return this;
        }

        /* Update status */
        httpResponseData->state |= HttpResponseData<SSL>::HTTP_STATUS_CALLED;

        Super::write("HTTP/1.1 ", 9);
        Super::write(status.data(), (int) status.length());
        Super::write("\r\n", 2);
        return this;
    }

    /* Write an HTTP header with string value */
    HttpResponse *writeHeader(std::string_view key, std::string_view value) {
        writeStatus(HTTP_200_OK);

        Super::write(key.data(), (int) key.length());
        Super::write(": ", 2);
        Super::write(value.data(), (int) value.length());
        Super::write("\r\n", 2);
        return this;
    }

    /* Write an HTTP header with unsigned int value */
    HttpResponse *writeHeader(std::string_view key, uint64_t value) {
        writeStatus(HTTP_200_OK);

        Super::write(key.data(), (int) key.length());
        Super::write(": ", 2);
        writeUnsigned64(value);
        Super::write("\r\n", 2);
        return this;
    }

    /* End without a body (no content-length) or end with a spoofed content-length. */
    void endWithoutBody(std::optional<size_t> reportedContentLength = std::nullopt, bool closeConnection = false) {
        if (reportedContentLength.has_value()) {
            internalEnd({nullptr, 0}, reportedContentLength.value(), false, true, closeConnection);
        } else {
            internalEnd({nullptr, 0}, 0, false, false, closeConnection);
        }
    }

    /* End the response with an optional data chunk. Always starts a timeout. */
    void end(std::string_view data = {}, bool closeConnection = false) {
        internalEnd(data, data.length(), false, true, closeConnection);
    }

    /* Try and end the response. Returns [true, true] on success.
     * Starts a timeout in some cases. Returns [ok, hasResponded] */
    std::pair<bool, bool> tryEnd(std::string_view data, uintmax_t totalSize = 0, bool closeConnection = false) {
        bool ok = internalEnd(data, totalSize, true, true, closeConnection);
        return {ok, hasResponded()};
    }

    /* Write parts of the response in chunking fashion. Starts timeout if failed. */
    bool write(std::string_view data) {
        writeStatus(HTTP_200_OK);

        /* Do not allow sending 0 chunks, they mark end of response */
        if (!data.length()) {
            /* If you called us, then according to you it was fine to call us so it's fine to still call us */
            return true;
        }

        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        if (!(httpResponseData->state & HttpResponseData<SSL>::HTTP_WRITE_CALLED)) {
            /* Write mark on first call to write */
            writeMark();

            writeHeader("Transfer-Encoding", "chunked");
            httpResponseData->state |= HttpResponseData<SSL>::HTTP_WRITE_CALLED;
        }

        Super::write("\r\n", 2);
        writeUnsignedHex((unsigned int) data.length());
        Super::write("\r\n", 2);

        auto [written, failed] = Super::write(data.data(), (int) data.length());
        if (failed) {
            Super::timeout(HTTP_TIMEOUT_S);
        }

        /* If we did not fail the write, accept more */
        return !failed;
    }

    /* Get the current byte write offset for this Http response */
    uintmax_t getWriteOffset() {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        return httpResponseData->offset;
    }

    /* If you are messing around with sendfile you might want to override the offset. */
    void overrideWriteOffset(uintmax_t offset) {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        httpResponseData->offset = offset;
    }

    /* Checking if we have fully responded and are ready for another request */
    bool hasResponded() {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        return !(httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING);
    }

    /* Corks the response if possible. Leaves already corked socket be. */
    HttpResponse *cork(MoveOnlyFunction<void()> &&handler) {
        if (!Super::isCorked() && Super::canCork()) {
            LoopData *loopData = Super::getLoopData();
            Super::cork();
            handler();

            /* The only way we could possibly have changed the corked socket during handler call, would be if 
             * the HTTP socket was upgraded to WebSocket and caused a realloc. Because of this we cannot use "this"
             * from here downwards. The corking is done with corkUnchecked() in upgrade. It steals cork. */
            auto *newCorkedSocket = loopData->corkedSocket;

            /* If nobody is corked, it means most probably that large amounts of data has
             * been written and the cork buffer has already been sent off and uncorked.
             * We are done here, if that is the case. */
            if (!newCorkedSocket) {
                return this;
            }

            /* Timeout on uncork failure, since most writes will succeed while corked */
            auto [written, failed] = static_cast<Super *>(newCorkedSocket)->uncork();

            /* If we are no longer an HTTP socket then early return the new "this".
             * We don't want to even overwrite timeout as it is set in upgrade already. */
            if (this != newCorkedSocket) {
                return static_cast<HttpResponse *>(newCorkedSocket);
            }

            if (failed) {
                /* For now we only have one single timeout so let's use it */
                /* This behavior should equal the behavior in HttpContext when uncorking fails */
                Super::timeout(HTTP_TIMEOUT_S);
            }

            /* If we have no backbuffer and we are connection close and we responded fully then close */
            HttpResponseData<SSL> *httpResponseData = getHttpResponseData();
            if (httpResponseData->state & HttpResponseData<SSL>::HTTP_CONNECTION_CLOSE) {
                if ((httpResponseData->state & HttpResponseData<SSL>::HTTP_RESPONSE_PENDING) == 0) {
                    if (((AsyncSocket<SSL> *) this)->getBufferedAmount() == 0) {
                        ((AsyncSocket<SSL> *) this)->shutdown();
                        /* We need to force close after sending FIN since we want to hinder
                        * clients from keeping to send their huge data */
                        ((AsyncSocket<SSL> *) this)->close();
                    }
                }
            }
        } else {
            /* We are already corked, or can't cork so let's just call the handler */
            handler();
        }

        return this;
    }

    /* Attach handler for writable HTTP response */
    HttpResponse *onWritable(MoveOnlyFunction<bool(uintmax_t)> &&handler) {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        httpResponseData->onWritable = std::move(handler);
        return this;
    }

    /* Attach handler for aborted HTTP request */
    HttpResponse *onAborted(MoveOnlyFunction<void()> &&handler) {
        HttpResponseData<SSL> *httpResponseData = getHttpResponseData();

        httpResponseData->onAborted = std::move(handler);
        return this;
    }

    /* Attach a read handler for data sent. Will be called with FIN set true if last segment. */
    void onData(MoveOnlyFunction<void(std::string_view, bool)> &&handler) {
        HttpResponseData<SSL> *data = getHttpResponseData();
        data->inStream = std::move(handler);

        /* Always reset this counter here */
        data->received_bytes_per_timeout = 0;
    }
};

}

#endif // UWS_HTTPRESPONSE_H

```

`src/HttpResponseData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPRESPONSEDATA_H
#define UWS_HTTPRESPONSEDATA_H

/* This data belongs to the HttpResponse */

#include "HttpParser.h"
#include "AsyncSocketData.h"
#include "ProxyParser.h"

#include "MoveOnlyFunction.h"

namespace uWS {

template <bool SSL>
struct HttpResponseData : AsyncSocketData<SSL>, HttpParser {
    template <bool> friend struct HttpResponse;
    template <bool> friend struct HttpContext;

    /* When we are done with a response we mark it like so */
    void markDone() {
        onAborted = nullptr;
        /* Also remove onWritable so that we do not emit when draining behind the scenes. */
        onWritable = nullptr;

        /* We are done with this request */
        state &= ~HttpResponseData<SSL>::HTTP_RESPONSE_PENDING;
    }

    /* Caller of onWritable. It is possible onWritable calls markDone so we need to borrow it. */
    bool callOnWritable(uintmax_t offset) {
        /* Borrow real onWritable */
        MoveOnlyFunction<bool(uintmax_t)> borrowedOnWritable = std::move(onWritable);

        /* Set onWritable to placeholder */
        onWritable = [](uintmax_t) {return true;};

        /* Run borrowed onWritable */
        bool ret = borrowedOnWritable(offset);

        /* If we still have onWritable (the placeholder) then move back the real one */
        if (onWritable) {
            /* We haven't reset onWritable, so give it back */
            onWritable = std::move(borrowedOnWritable);
        }

        return ret;
    }
private:
    /* Bits of status */
    enum {
        HTTP_STATUS_CALLED = 1, // used
        HTTP_WRITE_CALLED = 2, // used
        HTTP_END_CALLED = 4, // used
        HTTP_RESPONSE_PENDING = 8, // used
        HTTP_CONNECTION_CLOSE = 16 // used
    };

    /* Per socket event handlers */
    MoveOnlyFunction<bool(uintmax_t)> onWritable;
    MoveOnlyFunction<void()> onAborted;
    MoveOnlyFunction<void(std::string_view, bool)> inStream; // onData
    /* Outgoing offset */
    uintmax_t offset = 0;

    /* Let's track number of bytes since last timeout reset in data handler */
    unsigned int received_bytes_per_timeout = 0;

    /* Current state (content-length sent, status sent, write called, etc */
    int state = 0;

#ifdef UWS_WITH_PROXY
    ProxyParser proxyParser;
#endif
};

}

#endif // UWS_HTTPRESPONSEDATA_H

```

`src/HttpRouter.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_HTTPROUTER_HPP
#define UWS_HTTPROUTER_HPP

#include <map>
#include <vector>
#include <cstring>
#include <string_view>
#include <string>
#include <algorithm>
#include <memory>
#include <utility>

#include <iostream>

#include "MoveOnlyFunction.h"

namespace uWS {

template <class USERDATA>
struct HttpRouter {
    static constexpr std::string_view ANY_METHOD_TOKEN = "*";
    static const uint32_t HIGH_PRIORITY = 0xd0000000, MEDIUM_PRIORITY = 0xe0000000, LOW_PRIORITY = 0xf0000000;

private:
    USERDATA userData;
    static const unsigned int MAX_URL_SEGMENTS = 100;

    /* Handler ids are 32-bit */
    static const uint32_t HANDLER_MASK = 0x0fffffff;

    /* List of handlers */
    std::vector<MoveOnlyFunction<bool(HttpRouter *)>> handlers;

    /* Current URL cache */
    std::string_view currentUrl;
    std::string_view urlSegmentVector[MAX_URL_SEGMENTS];
    int urlSegmentTop;

    /* The matching tree */
    struct Node {
        std::string name;
        std::vector<std::unique_ptr<Node>> children;
        std::vector<uint32_t> handlers;
        bool isHighPriority;

        Node(std::string name) : name(name) {}
    } root = {"rootNode"};

    /* Sort wildcards after alphanum */
    int lexicalOrder(std::string &name) {
        if (!name.length()) {
            return 2;
        }
        if (name[0] == ':') {
            return 1;
        }
        if (name[0] == '*') {
            return 0;
        }
        return 2;
    }

    /* Advance from parent to child, adding child if necessary */
    Node *getNode(Node *parent, std::string child, bool isHighPriority) {
        for (std::unique_ptr<Node> &node : parent->children) {
            if (node->name == child && node->isHighPriority == isHighPriority) {
                return node.get();
            }
        }

        /* Insert sorted, but keep order if parent is root (we sort methods by priority elsewhere) */
        std::unique_ptr<Node> newNode(new Node(child));
        newNode->isHighPriority = isHighPriority;
        return parent->children.emplace(std::upper_bound(parent->children.begin(), parent->children.end(), newNode, [parent, this](auto &a, auto &b) {

            if (a->isHighPriority != b->isHighPriority) {
                return a->isHighPriority;
            }

            return b->name.length() && (parent != &root) && (lexicalOrder(b->name) < lexicalOrder(a->name));
        }), std::move(newNode))->get();
    }

    /* Basically a pre-allocated stack */
    struct RouteParameters {
        friend struct HttpRouter;
    private:
        std::string_view params[MAX_URL_SEGMENTS];
        int paramsTop;

        void reset() {
            paramsTop = -1;
        }

        void push(std::string_view param) {
            /* We check these bounds indirectly via the urlSegments limit */
            params[++paramsTop] = param;
        }

        void pop() {
            /* Same here, we cannot pop outside */
            paramsTop--;
        }
    } routeParameters;

    /* Set URL for router. Will reset any URL cache */
    inline void setUrl(std::string_view url) {

        /* Todo: URL may also start with "http://domain/" or "*", not only "/" */

        /* We expect to stand on a slash */
        currentUrl = url;
        urlSegmentTop = -1;
    }

    /* Lazily parse or read from cache */
    inline std::pair<std::string_view, bool> getUrlSegment(int urlSegment) {
        if (urlSegment > urlSegmentTop) {
            /* Signal as STOP when we have no more URL or stack space */
            if (!currentUrl.length() || urlSegment > int(MAX_URL_SEGMENTS - 1)) {
                return {{}, true};
            }

            /* We always stand on a slash here, so step over it */
            currentUrl.remove_prefix(1);

            auto segmentLength = currentUrl.find('/');
            if (segmentLength == std::string::npos) {
                segmentLength = currentUrl.length();

                /* Push to url segment vector */
                urlSegmentVector[urlSegment] = currentUrl.substr(0, segmentLength);
                urlSegmentTop++;

                /* Update currentUrl */
                currentUrl = currentUrl.substr(segmentLength);
            } else {
                /* Push to url segment vector */
                urlSegmentVector[urlSegment] = currentUrl.substr(0, segmentLength);
                urlSegmentTop++;

                /* Update currentUrl */
                currentUrl = currentUrl.substr(segmentLength);
            }
        }
        /* In any case we return it */
        return {urlSegmentVector[urlSegment], false};
    }

    /* Executes as many handlers it can */
    bool executeHandlers(Node *parent, int urlSegment, USERDATA &userData) {

        auto [segment, isStop] = getUrlSegment(urlSegment);

        /* If we are on STOP, return where we may stand */
        if (isStop) {
            /* We have reached accross the entire URL with no stoppage, execute */
            for (uint32_t handler : parent->handlers) {
                if (handlers[handler & HANDLER_MASK](this)) {
                    return true;
                }
            }
            /* We reached the end, so go back */
            return false;
        }

        for (auto &p : parent->children) {
            if (p->name.length() && p->name[0] == '*') {
                /* Wildcard match (can be seen as a shortcut) */
                for (uint32_t handler : p->handlers) {
                    if (handlers[handler & HANDLER_MASK](this)) {
                        return true;
                    }
                }
            } else if (p->name.length() && p->name[0] == ':' && segment.length()) {
                /* Parameter match */
                routeParameters.push(segment);
                if (executeHandlers(p.get(), urlSegment + 1, userData)) {
                    return true;
                }
                routeParameters.pop();
            } else if (p->name == segment) {
                /* Static match */
                if (executeHandlers(p.get(), urlSegment + 1, userData)) {
                    return true;
                }
            }
        }
        return false;
    }

    /* Scans for one matching handler, returning the handler and its priority or UINT32_MAX for not found */
    uint32_t findHandler(std::string method, std::string pattern, uint32_t priority) {
        for (std::unique_ptr<Node> &node : root.children) {
            if (method == node->name) {
                setUrl(pattern);
                Node *n = node.get();
                for (int i = 0; !getUrlSegment(i).second; i++) {
                    /* Go to next segment or quit */
                    std::string segment = std::string(getUrlSegment(i).first);
                    Node *next = nullptr;
                    for (std::unique_ptr<Node> &child : n->children) {
                        if (((segment.length() && child->name.length() && segment[0] == ':' && child->name[0] == ':') || child->name == segment) && child->isHighPriority == (priority == HIGH_PRIORITY)) {
                            next = child.get();
                            break;
                        }
                    }
                    if (!next) {
                        return UINT32_MAX;
                    }
                    n = next;
                }
                /* Seek for a priority match in the found node */
                for (unsigned int i = 0; i < n->handlers.size(); i++) {
                    if ((n->handlers[i] & ~HANDLER_MASK) == priority) {
                        return n->handlers[i];
                    }
                }
                return UINT32_MAX;
            }
        }
        return UINT32_MAX;
    }

public:
    HttpRouter() {
        /* Always have ANY route */
        getNode(&root, std::string(ANY_METHOD_TOKEN.data(), ANY_METHOD_TOKEN.length()), false);
    }

    std::pair<int, std::string_view *> getParameters() {
        return {routeParameters.paramsTop, routeParameters.params};
    }

    USERDATA &getUserData() {
        return userData;
    }

    /* Fast path */
    bool route(std::string_view method, std::string_view url) {
        /* Reset url parsing cache */
        setUrl(url);
        routeParameters.reset();

        /* Begin by finding the method node */
        for (auto &p : root.children) {
            if (p->name == method) {
                /* Then route the url */
                if (executeHandlers(p.get(), 0, userData)) {
                    return true;
                } else {
                    break;
                }
            }
        }

        /* Always test any route last (this check should not be necessary if we always have at least one handler) */
        if (root.children.empty()) [[unlikely]] {
            return false;
        }
        return executeHandlers(root.children.back().get(), 0, userData);
    }

    /* Adds the corresponding entires in matching tree and handler list */
    void add(std::vector<std::string> methods, std::string pattern, MoveOnlyFunction<bool(HttpRouter *)> &&handler, uint32_t priority = MEDIUM_PRIORITY) {
        /* First remove existing handler */
        remove(methods[0], pattern, priority);
        
        for (std::string method : methods) {
            /* Lookup method */
            Node *node = getNode(&root, method, false);
            /* Iterate over all segments */
            setUrl(pattern);
            for (int i = 0; !getUrlSegment(i).second; i++) {
                std::string strippedSegment(getUrlSegment(i).first);
                if (strippedSegment.length() && strippedSegment[0] == ':') {
                    /* Parameter routes must be named only : */
                    strippedSegment = ":";
                }
                node = getNode(node, strippedSegment, priority == HIGH_PRIORITY);
            }
            /* Insert handler in order sorted by priority (most significant 1 byte) */
            node->handlers.insert(std::upper_bound(node->handlers.begin(), node->handlers.end(), (uint32_t) (priority | handlers.size())), (uint32_t) (priority | handlers.size()));
        }

        /* Alloate this handler */
        handlers.emplace_back(std::move(handler));

        /* ANY method must be last, GET must be first */
        std::sort(root.children.begin(), root.children.end(), [](const auto &a, const auto &b) {
            if (a->name == "GET" && b->name != "GET") {
                return true;
            } else if (b->name == "GET" && a->name != "GET") {
                return false;
            } else if (a->name == ANY_METHOD_TOKEN && b->name != ANY_METHOD_TOKEN) {
                return false;
            } else if (b->name == ANY_METHOD_TOKEN && a->name != ANY_METHOD_TOKEN) {
                return true;
            } else {
                return a->name < b->name;
            }
        });
    }

    bool cullNode(Node *parent, Node *node, uint32_t handler) {
        /* For all children */
        for (unsigned int i = 0; i < node->children.size(); ) {
            /* Optimization todo: only enter those with same isHighPrioirty */
            /* Enter child so we get depth first */
            if (!cullNode(node, node->children[i].get(), handler)) {
                /* Only increase if this node was not removed */
                i++;
            }
        }

        /* Cull this node (but skip the root node) */
        if (parent /*&& parent != &root*/) {
            /* Scan for equal (remove), greater (lower by 1) */
            for (auto it = node->handlers.begin(); it != node->handlers.end(); ) {
                if ((*it & HANDLER_MASK) > (handler & HANDLER_MASK)) {
                    *it = ((*it & HANDLER_MASK) - 1) | (*it & ~HANDLER_MASK);
                } else if (*it == handler) {
                    it = node->handlers.erase(it);
                    continue;
                }
                it++;
            }

            /* If we have no children and no handlers, remove us from the parent->children list */
            if (!node->handlers.size() && !node->children.size()) {
                parent->children.erase(std::find_if(parent->children.begin(), parent->children.end(), [node](const std::unique_ptr<Node> &a) {
                    return a.get() == node;
                }));
                /* Returning true means we removed node from parent */
                return true;
            }
        }

        return false;
    }

    /* Removes ALL routes with the same handler as can be found with the given parameters.
     * Removing a wildcard is done by removing ONE OF the methods the wildcard would match with.
     * Example: If wildcard includes POST, GET, PUT, you can remove ALL THREE by removing GET. */
    bool remove(std::string method, std::string pattern, uint32_t priority) {
        uint32_t handler = findHandler(method, pattern, priority);
        if (handler == UINT32_MAX) {
            /* Not found or already removed, do nothing */
            return false;
        }

        /* Cull the entire tree */
        /* For all nodes in depth first tree traveral;
         * if node contains handler - remove the handler -
         * if node holds no handlers after removal, remove the node and return */
        cullNode(nullptr, &root, handler);

        /* Now remove the actual handler */
        handlers.erase(handlers.begin() + (handler & HANDLER_MASK));

        return true;
    }
};

}

#endif // UWS_HTTPROUTER_HPP

```

`src/LocalCluster.h`:

```h
/* This header is highly experimental and needs refactorings but will do for now */

#include <thread>
#include <algorithm>
#include <mutex>

unsigned int roundRobin = 0;
unsigned int hardwareConcurrency = std::thread::hardware_concurrency();
std::vector<std::thread *> threads(hardwareConcurrency);
std::vector<uWS::SSLApp *> apps;
std::mutex m;

namespace uWS {
struct LocalCluster {

    //std::vector<std::thread *> threads = std::thread::hardware_concurrency();
    //std::vector<uWS::SSLApp *> apps;
    //std::mutex m;


    static void loadBalancer() {
        static std::atomic<unsigned int> roundRobin = 0; // atomic fetch_add
    }

    LocalCluster(SocketContextOptions options = {}, std::function<void(uWS::SSLApp &)> cb = nullptr) {
        std::transform(threads.begin(), threads.end(), threads.begin(), [options, &cb](std::thread *) {

            return new std::thread([options, &cb]() {

                // lock this
                m.lock();
                apps.emplace_back(new uWS::SSLApp(options));
                uWS::SSLApp *app = apps.back();

                cb(*app);
                
                app->preOpen([](struct us_socket_context_t *context, LIBUS_SOCKET_DESCRIPTOR fd) -> LIBUS_SOCKET_DESCRIPTOR {

                    std::ignore = context;

                    /* Distribute this socket in round robin fashion */
                    //std::cout << "About to load balance " << fd << " to " << roundRobin << std::endl;

                    auto receivingApp = apps[roundRobin];
                    apps[roundRobin]->getLoop()->defer([fd, receivingApp]() {
                        receivingApp->adoptSocket(fd);
                    });

                    roundRobin = (roundRobin + 1) % hardwareConcurrency;
                    return (LIBUS_SOCKET_DESCRIPTOR) -1;
                });
                m.unlock();
                app->run();
                std::cout << "Fallthrough!" << std::endl;
                delete app;
            });
        });

        std::for_each(threads.begin(), threads.end(), [](std::thread *t) {
            t->join();
        });
    }
};
}
```

`src/Loop.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_LOOP_H
#define UWS_LOOP_H

/* The loop is lazily created per-thread and run with run() */

#include "LoopData.h"
#include <libusockets.h>
#include <iostream>

namespace uWS {

/* A prepared message is dependent on the Loop, so it belongs here */
struct PreparedMessage {
    /* These should be a single alloation along with the PreparedMessage itself (they are static) */
    std::string originalMessage, compressedMessage;
    bool compressed;
    int opCode;
};

struct Loop {
private:
    static void wakeupCb(us_loop_t *loop) {
        LoopData *loopData = (LoopData *) us_loop_ext(loop);

        /* Swap current deferQueue */
        loopData->deferMutex.lock();
        int oldDeferQueue = loopData->currentDeferQueue;
        loopData->currentDeferQueue = (loopData->currentDeferQueue + 1) % 2;
        loopData->deferMutex.unlock();

        /* Drain the queue */
        for (auto &x : loopData->deferQueues[oldDeferQueue]) {
            x();
        }
        loopData->deferQueues[oldDeferQueue].clear();
    }

    static void preCb(us_loop_t *loop) {
        LoopData *loopData = (LoopData *) us_loop_ext(loop);

        for (auto &p : loopData->preHandlers) {
            p.second((Loop *) loop);
        }
    }

    static void postCb(us_loop_t *loop) {
        LoopData *loopData = (LoopData *) us_loop_ext(loop);

        for (auto &p : loopData->postHandlers) {
            p.second((Loop *) loop);
        }

        /* After every event loop iteration, we must not hold the cork buffer */
        if (loopData->corkedSocket) {
            std::cerr << "Error: Cork buffer must not be held across event loop iterations!" << std::endl;
            std::terminate();
        }
    }

    Loop() = delete;
    ~Loop() = default;

    Loop *init() {
        new (us_loop_ext((us_loop_t *) this)) LoopData;
        return this;
    }

    static Loop *create(void *hint) {
        Loop *loop = ((Loop *) us_create_loop(hint, wakeupCb, preCb, postCb, sizeof(LoopData)))->init();

        /* We also need some timers (should live off the one 4 second timer rather) */
        LoopData *loopData = (LoopData *) us_loop_ext((struct us_loop_t *) loop);
        loopData->dateTimer = us_create_timer((struct us_loop_t *) loop, 1, sizeof(LoopData *));
        memcpy(us_timer_ext(loopData->dateTimer), &loopData, sizeof(LoopData *));
        us_timer_set(loopData->dateTimer, [](struct us_timer_t *t) {
            LoopData *loopData;
            memcpy(&loopData, us_timer_ext(t), sizeof(LoopData *));
            loopData->updateDate();
        }, 1000, 1000);

        return loop;
    }

    /* What to do with loops created with existingNativeLoop? */
    struct LoopCleaner {
        ~LoopCleaner() {
            if(loop && cleanMe) {
                loop->free();
            }
        }
        Loop *loop = nullptr;
        bool cleanMe = false;
    };

    static LoopCleaner &getLazyLoop() {
        static thread_local LoopCleaner lazyLoop;
        return lazyLoop;
    }

public:

    /* Preformatted messages need the Loop */
    PreparedMessage prepareMessage(std::string_view message, int opCode, bool compress = true) {
        /* The message could be formatted right here, but this optimization is not done yet */
        PreparedMessage preparedMessage;
        preparedMessage.compressed = compress;
        preparedMessage.opCode = opCode;
        preparedMessage.originalMessage = message;

        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        if (compress) {
            /* Initialize loop's deflate inflate streams */
            if (!loopData->zlibContext) {
                loopData->zlibContext = new ZlibContext;
                loopData->inflationStream = new InflationStream(CompressOptions::DEDICATED_DECOMPRESSOR);
                loopData->deflationStream = new DeflationStream(CompressOptions::DEDICATED_COMPRESSOR);
            }

            preparedMessage.compressedMessage = loopData->deflationStream->deflate(loopData->zlibContext, {preparedMessage.originalMessage.data(), preparedMessage.originalMessage.length()}, true);
        }

        return preparedMessage;
    }

    /* Lazily initializes a per-thread loop and returns it.
     * Will automatically free all initialized loops at exit. */
    static Loop *get(void *existingNativeLoop = nullptr) {
        if (!getLazyLoop().loop) {
            /* If we are given a native loop pointer we pass that to uSockets and let it deal with it */
            if (existingNativeLoop) {
                /* Todo: here we want to pass the pointer, not a boolean */
                getLazyLoop().loop = create(existingNativeLoop);
                /* We cannot register automatic free here, must be manually done */
            } else {
                getLazyLoop().loop = create(nullptr);
                getLazyLoop().cleanMe = true;
            }
        }

        return getLazyLoop().loop;
    }

    /* Freeing the default loop should be done once */
    void free() {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        /* Stop and free dateTimer first */
        us_timer_close(loopData->dateTimer);

        loopData->~LoopData();
        /* uSockets will track whether this loop is owned by us or a borrowed alien loop */
        us_loop_free((us_loop_t *) this);

        /* Reset lazyLoop */
        getLazyLoop().loop = nullptr;
    }

    void addPostHandler(void *key, MoveOnlyFunction<void(Loop *)> &&handler) {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        loopData->postHandlers.emplace(key, std::move(handler));
    }

    /* Bug: what if you remove a handler while iterating them? */
    void removePostHandler(void *key) {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        loopData->postHandlers.erase(key);
    }

    void addPreHandler(void *key, MoveOnlyFunction<void(Loop *)> &&handler) {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        loopData->preHandlers.emplace(key, std::move(handler));
    }

    /* Bug: what if you remove a handler while iterating them? */
    void removePreHandler(void *key) {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        loopData->preHandlers.erase(key);
    }

    /* Defer this callback on Loop's thread of execution */
    void defer(MoveOnlyFunction<void()> &&cb) {
        LoopData *loopData = (LoopData *) us_loop_ext((us_loop_t *) this);

        //if (std::thread::get_id() == ) // todo: add fast path for same thread id
        loopData->deferMutex.lock();
        loopData->deferQueues[loopData->currentDeferQueue].emplace_back(std::move(cb));
        loopData->deferMutex.unlock();

        us_wakeup_loop((us_loop_t *) this);
    }

    /* Actively block and run this loop */
    void run() {
        us_loop_run((us_loop_t *) this);
    }

    /* Passively integrate with the underlying default loop */
    /* Used to seamlessly integrate with third parties such as Node.js */
    void integrate() {
        us_loop_integrate((us_loop_t *) this);
    }

    /* Dynamically change this */
    void setSilent(bool silent) {
        ((LoopData *) us_loop_ext((us_loop_t *) this))->noMark = silent;
    }
};

/* Can be called from any thread to run the thread local loop */
inline void run() {
    Loop::get()->run();
}

}

#endif // UWS_LOOP_H

```

`src/LoopData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_LOOPDATA_H
#define UWS_LOOPDATA_H

#include <thread>
#include <functional>
#include <vector>
#include <mutex>
#include <map>
#include <ctime>
#include <cstdint>

#include "PerMessageDeflate.h"
#include "MoveOnlyFunction.h"

struct us_timer_t;

namespace uWS {

struct Loop;

struct alignas(16) LoopData {
    friend struct Loop;
private:
    std::mutex deferMutex;
    int currentDeferQueue = 0;
    std::vector<MoveOnlyFunction<void()>> deferQueues[2];

    /* Map from void ptr to handler */
    std::map<void *, MoveOnlyFunction<void(Loop *)>> postHandlers, preHandlers;

public:
    LoopData() {
        updateDate();
    }

    ~LoopData() {
        /* If we have had App.ws called with compression we need to clear this */
        if (zlibContext) {
            delete zlibContext;
            delete inflationStream;
            delete deflationStream;
        }
        delete [] corkBuffer;
    }

    void updateDate() {
        cacheTimepoint = time(0);
        struct tm tstruct = {};
#ifdef _WIN32
        /* Micro, fucking soft never follows spec. */
        gmtime_s(&tstruct, &cacheTimepoint);
#else
        gmtime_r(&cacheTimepoint, &tstruct);
#endif
        static const char wday_name[][4] = {
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
        };
        static const char mon_name[][4] = {
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
        };
        snprintf(date, 32, "%.3s, %.2u %.3s %.4u %.2u:%.2u:%.2u GMT",
            wday_name[tstruct.tm_wday],
            tstruct.tm_mday % 99,
            mon_name[tstruct.tm_mon],
            (1900 + tstruct.tm_year) % 9999,
            tstruct.tm_hour % 99,
            tstruct.tm_min % 99,
            tstruct.tm_sec % 99);
    }

    char date[32];
    time_t cacheTimepoint = 0;

    /* Be silent */
    bool noMark = false;

    /* Good 16k for SSL perf. */
    static const unsigned int CORK_BUFFER_SIZE = 16 * 1024;

    /* Cork data */
    char *corkBuffer = new char[CORK_BUFFER_SIZE];
    unsigned int corkOffset = 0;
    void *corkedSocket = nullptr;

    /* Per message deflate data */
    ZlibContext *zlibContext = nullptr;
    InflationStream *inflationStream = nullptr;
    DeflationStream *deflationStream = nullptr;

    us_timer_t *dateTimer;
};

}

#endif // UWS_LOOPDATA_H

```

`src/MessageParser.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Implements the common parser (RFC 822) used in both HTTP and Multipart parsing */

#ifndef UWS_MESSAGE_PARSER_H
#define UWS_MESSAGE_PARSER_H

#include <string_view>
#include <utility>
#include <cstring>

/* For now we have this one here */
#define MAX_HEADERS 10

namespace uWS {

    // should be templated on whether it needs at lest one header (http), or not (multipart)
    static inline unsigned int getHeaders(char *postPaddedBuffer, char *end, std::pair<std::string_view, std::string_view> *headers) {
        char *preliminaryKey, *preliminaryValue, *start = postPaddedBuffer;

        for (unsigned int i = 0; i < MAX_HEADERS; i++) {
            for (preliminaryKey = postPaddedBuffer; (*postPaddedBuffer != ':') & (*(unsigned char *)postPaddedBuffer > 32); *(postPaddedBuffer++) |= 32);
            if (*postPaddedBuffer == '\r') {
                if ((postPaddedBuffer != end) & (postPaddedBuffer[1] == '\n') /* & (i > 0) */) { // multipart does not require any headers like http does
                    headers->first = std::string_view(nullptr, 0);
                    return (unsigned int) ((postPaddedBuffer + 2) - start);
                } else {
                    return 0;
                }
            } else {
                headers->first = std::string_view(preliminaryKey, (size_t) (postPaddedBuffer - preliminaryKey));
                for (postPaddedBuffer++; (*postPaddedBuffer == ':' || *(unsigned char *)postPaddedBuffer < 33) && *postPaddedBuffer != '\r'; postPaddedBuffer++);
                preliminaryValue = postPaddedBuffer;
                postPaddedBuffer = (char *) memchr(postPaddedBuffer, '\r', end - postPaddedBuffer);
                if (postPaddedBuffer && postPaddedBuffer[1] == '\n') {
                    headers->second = std::string_view(preliminaryValue, (size_t) (postPaddedBuffer - preliminaryValue));
                    postPaddedBuffer += 2;
                    headers++;
                } else {
                    return 0;
                }
            }
        }
        return 0;
    }

}

#endif
```

`src/MoveOnlyFunction.h`:

```h
/*
MIT License

Copyright (c) 2020 Oleg Fatkhiev

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/* Sources fetched from https://github.com/ofats/any_invocable on 2021-02-19. */

#ifndef _ANY_INVOKABLE_H_
#define _ANY_INVOKABLE_H_

#include <functional>

#if !defined(__cpp_lib_move_only_function) || __cpp_lib_move_only_function < 202110L

#include <memory>
#include <type_traits>

// clang-format off
/*
namespace std {
  template<class Sig> class any_invocable; // never defined

  template<class R, class... ArgTypes>
  class any_invocable<R(ArgTypes...) cv ref noexcept(noex)> {
  public:
    using result_type = R;

    // SECTION.3, construct/copy/destroy
    any_invocable() noexcept;
    any_invocable(nullptr_t) noexcept;
    any_invocable(any_invocable&&) noexcept;
    template<class F> any_invocable(F&&);

    template<class T, class... Args>
      explicit any_invocable(in_place_type_t<T>, Args&&...);
    template<class T, class U, class... Args>
      explicit any_invocable(in_place_type_t<T>, initializer_list<U>, Args&&...);

    any_invocable& operator=(any_invocable&&) noexcept;
    any_invocable& operator=(nullptr_t) noexcept;
    template<class F> any_invocable& operator=(F&&);
    template<class F> any_invocable& operator=(reference_wrapper<F>) noexcept;

    ~any_invocable();

    // SECTION.4, any_invocable modifiers
    void swap(any_invocable&) noexcept;

    // SECTION.5, any_invocable capacity
    explicit operator bool() const noexcept;

    // SECTION.6, any_invocable invocation
    R operator()(ArgTypes...) cv ref noexcept(noex);

    // SECTION.7, null pointer comparisons
    friend bool operator==(const any_invocable&, nullptr_t) noexcept;

    // SECTION.8, specialized algorithms
    friend void swap(any_invocable&, any_invocable&) noexcept;
  };
}
*/
// clang-format on

namespace ofats {

namespace any_detail {

using buffer = std::aligned_storage_t<sizeof(void*) * 2, alignof(void*)>;

template <class T>
inline constexpr bool is_small_object_v =
    sizeof(T) <= sizeof(buffer) && alignof(buffer) % alignof(T) == 0 &&
    std::is_nothrow_move_constructible_v<T>;

union storage {
  void* ptr_ = nullptr;
  buffer buf_;
};

enum class action { destroy, move };

template <class R, class... ArgTypes>
struct handler_traits {
  template <class Derived>
  struct handler_base {
    static void handle(action act, storage* current, storage* other = nullptr) {
      switch (act) {
        case (action::destroy):
          Derived::destroy(*current);
          break;
        case (action::move):
          Derived::move(*current, *other);
          break;
      }
    }
  };

  template <class T>
  struct small_handler : handler_base<small_handler<T>> {
    template <class... Args>
    static void create(storage& s, Args&&... args) {
      new (static_cast<void*>(&s.buf_)) T(std::forward<Args>(args)...);
    }

    static void destroy(storage& s) noexcept {
      T& value = *static_cast<T*>(static_cast<void*>(&s.buf_));
      value.~T();
    }

    static void move(storage& dst, storage& src) noexcept {
      create(dst, std::move(*static_cast<T*>(static_cast<void*>(&src.buf_))));
      destroy(src);
    }

    static R call(storage& s, ArgTypes... args) {
      return std::invoke(*static_cast<T*>(static_cast<void*>(&s.buf_)),
                         std::forward<ArgTypes>(args)...);
    }
  };

  template <class T>
  struct large_handler : handler_base<large_handler<T>> {
    template <class... Args>
    static void create(storage& s, Args&&... args) {
      s.ptr_ = new T(std::forward<Args>(args)...);
    }

    static void destroy(storage& s) noexcept { delete static_cast<T*>(s.ptr_); }

    static void move(storage& dst, storage& src) noexcept {
      dst.ptr_ = src.ptr_;
    }

    static R call(storage& s, ArgTypes... args) {
      return std::invoke(*static_cast<T*>(s.ptr_),
                         std::forward<ArgTypes>(args)...);
    }
  };

  template <class T>
  using handler = std::conditional_t<is_small_object_v<T>, small_handler<T>,
                                     large_handler<T>>;
};

template <class T>
struct is_in_place_type : std::false_type {};

template <class T>
struct is_in_place_type<std::in_place_type_t<T>> : std::true_type {};

template <class T>
inline constexpr auto is_in_place_type_v = is_in_place_type<T>::value;

template <class R, bool is_noexcept, class... ArgTypes>
class any_invocable_impl {
  template <class T>
  using handler =
      typename any_detail::handler_traits<R, ArgTypes...>::template handler<T>;

  using storage = any_detail::storage;
  using action = any_detail::action;
  using handle_func = void (*)(any_detail::action, any_detail::storage*,
                               any_detail::storage*);
  using call_func = R (*)(any_detail::storage&, ArgTypes...);

 public:
  using result_type = R;

  any_invocable_impl() noexcept = default;
  any_invocable_impl(std::nullptr_t) noexcept {}
  any_invocable_impl(any_invocable_impl&& rhs) noexcept {
    if (rhs.handle_) {
      handle_ = rhs.handle_;
      handle_(action::move, &storage_, &rhs.storage_);
      call_ = rhs.call_;
      rhs.handle_ = nullptr;
    }
  }

  any_invocable_impl& operator=(any_invocable_impl&& rhs) noexcept {
    any_invocable_impl{std::move(rhs)}.swap(*this);
    return *this;
  }
  any_invocable_impl& operator=(std::nullptr_t) noexcept {
    destroy();
    return *this;
  }

  ~any_invocable_impl() { destroy(); }

  void swap(any_invocable_impl& rhs) noexcept {
    if (handle_) {
      if (rhs.handle_) {
        storage tmp;
        handle_(action::move, &tmp, &storage_);
        rhs.handle_(action::move, &storage_, &rhs.storage_);
        handle_(action::move, &rhs.storage_, &tmp);
        std::swap(handle_, rhs.handle_);
        std::swap(call_, rhs.call_);
      } else {
        rhs.swap(*this);
      }
    } else if (rhs.handle_) {
      rhs.handle_(action::move, &storage_, &rhs.storage_);
      handle_ = rhs.handle_;
      call_ = rhs.call_;
      rhs.handle_ = nullptr;
    }
  }

  explicit operator bool() const noexcept { return handle_ != nullptr; }

 protected:
  template <class F, class... Args>
  void create(Args&&... args) {
    using hdl = handler<F>;
    hdl::create(storage_, std::forward<Args>(args)...);
    handle_ = &hdl::handle;
    call_ = &hdl::call;
  }

  void destroy() noexcept {
    if (handle_) {
      handle_(action::destroy, &storage_, nullptr);
      handle_ = nullptr;
    }
  }

  R call(ArgTypes... args) noexcept(is_noexcept) {
    return call_(storage_, std::forward<ArgTypes>(args)...);
  }

  friend bool operator==(const any_invocable_impl& f, std::nullptr_t) noexcept {
    return !f;
  }
  friend bool operator==(std::nullptr_t, const any_invocable_impl& f) noexcept {
    return !f;
  }
  friend bool operator!=(const any_invocable_impl& f, std::nullptr_t) noexcept {
    return static_cast<bool>(f);
  }
  friend bool operator!=(std::nullptr_t, const any_invocable_impl& f) noexcept {
    return static_cast<bool>(f);
  }

  friend void swap(any_invocable_impl& lhs, any_invocable_impl& rhs) noexcept {
    lhs.swap(rhs);
  }

 private:
  storage storage_;
  handle_func handle_ = nullptr;
  call_func call_;
};

template <class T>
using remove_cvref_t = std::remove_cv_t<std::remove_reference_t<T>>;

template <class AI, class F, bool noex, class R, class FCall, class... ArgTypes>
using can_convert = std::conjunction<
    std::negation<std::is_same<remove_cvref_t<F>, AI>>,
    std::negation<any_detail::is_in_place_type<remove_cvref_t<F>>>,
    std::is_invocable_r<R, FCall, ArgTypes...>,
    std::bool_constant<(!noex ||
                        std::is_nothrow_invocable_r_v<R, FCall, ArgTypes...>)>,
    std::is_constructible<std::decay_t<F>, F>>;

}  // namespace any_detail

template <class Signature>
class any_invocable;

#define __OFATS_ANY_INVOCABLE(cv, ref, noex, inv_quals)                        \
  template <class R, class... ArgTypes>                                        \
  class any_invocable<R(ArgTypes...) cv ref noexcept(noex)>                    \
      : public any_detail::any_invocable_impl<R, noex, ArgTypes...> {          \
    using base_type = any_detail::any_invocable_impl<R, noex, ArgTypes...>;    \
                                                                               \
   public:                                                                     \
    using base_type::base_type;                                                \
                                                                               \
    template <                                                                 \
        class F,                                                               \
        class = std::enable_if_t<any_detail::can_convert<                      \
            any_invocable, F, noex, R, F inv_quals, ArgTypes...>::value>>      \
    any_invocable(F&& f) {                                                     \
      base_type::template create<std::decay_t<F>>(std::forward<F>(f));         \
    }                                                                          \
                                                                               \
    template <class T, class... Args, class VT = std::decay_t<T>,              \
              class = std::enable_if_t<                                        \
                  std::is_move_constructible_v<VT> &&                          \
                  std::is_constructible_v<VT, Args...> &&                      \
                  std::is_invocable_r_v<R, VT inv_quals, ArgTypes...> &&       \
                  (!noex || std::is_nothrow_invocable_r_v<R, VT inv_quals,     \
                                                          ArgTypes...>)>>      \
    explicit any_invocable(std::in_place_type_t<T>, Args&&... args) {          \
      base_type::template create<VT>(std::forward<Args>(args)...);             \
    }                                                                          \
                                                                               \
    template <                                                                 \
        class T, class U, class... Args, class VT = std::decay_t<T>,           \
        class = std::enable_if_t<                                              \
            std::is_move_constructible_v<VT> &&                                \
            std::is_constructible_v<VT, std::initializer_list<U>&, Args...> && \
            std::is_invocable_r_v<R, VT inv_quals, ArgTypes...> &&             \
            (!noex ||                                                          \
             std::is_nothrow_invocable_r_v<R, VT inv_quals, ArgTypes...>)>>    \
    explicit any_invocable(std::in_place_type_t<T>,                            \
                           std::initializer_list<U> il, Args&&... args) {      \
      base_type::template create<VT>(il, std::forward<Args>(args)...);         \
    }                                                                          \
                                                                               \
    template <class F, class FDec = std::decay_t<F>>                           \
    std::enable_if_t<!std::is_same_v<FDec, any_invocable> &&                   \
                         std::is_move_constructible_v<FDec>,                   \
                     any_invocable&>                                           \
    operator=(F&& f) {                                                         \
      any_invocable{std::forward<F>(f)}.swap(*this);                           \
      return *this;                                                            \
    }                                                                          \
    template <class F>                                                         \
    any_invocable& operator=(std::reference_wrapper<F> f) {                    \
      any_invocable{f}.swap(*this);                                            \
      return *this;                                                            \
    }                                                                          \
                                                                               \
    R operator()(ArgTypes... args) cv ref noexcept(noex) {                     \
      return base_type::call(std::forward<ArgTypes>(args)...);                 \
    }                                                                          \
  };

// cv -> {`empty`, const}
// ref -> {`empty`, &, &&}
// noex -> {true, false}
// inv_quals -> (is_empty(ref) ? & : ref)
__OFATS_ANY_INVOCABLE(, , false, &)               // 000
__OFATS_ANY_INVOCABLE(, , true, &)                // 001
__OFATS_ANY_INVOCABLE(, &, false, &)              // 010
__OFATS_ANY_INVOCABLE(, &, true, &)               // 011
__OFATS_ANY_INVOCABLE(, &&, false, &&)            // 020
__OFATS_ANY_INVOCABLE(, &&, true, &&)             // 021
__OFATS_ANY_INVOCABLE(const, , false, const&)     // 100
__OFATS_ANY_INVOCABLE(const, , true, const&)      // 101
__OFATS_ANY_INVOCABLE(const, &, false, const&)    // 110
__OFATS_ANY_INVOCABLE(const, &, true, const&)     // 111
__OFATS_ANY_INVOCABLE(const, &&, false, const&&)  // 120
__OFATS_ANY_INVOCABLE(const, &&, true, const&&)   // 121

#undef __OFATS_ANY_INVOCABLE

}  // namespace ofats

/* We, uWebSockets define our own type */
namespace uWS {
  template <class T>
  using MoveOnlyFunction = ofats::any_invocable<T>;
}

#else // !defined(__cpp_lib_move_only_function) || __cpp_lib_move_only_function < 202110L

namespace uWS {
  template <class T>
  using MoveOnlyFunction = std::move_only_function<T>;
}

#endif

#endif  // _ANY_INVOKABLE_H_

```

`src/Multipart.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Implements the multipart protocol. Builds atop parts of our common http parser (not yet refactored that way). */
/* https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html */

#ifndef UWS_MULTIPART_H
#define UWS_MULTIPART_H

#include "MessageParser.h"

#include <string_view>
#include <optional>
#include <cstring>
#include <utility>
#include <cctype>

namespace uWS {

    /* This one could possibly be shared with ExtensionsParser to some degree */
    struct ParameterParser {

        /* Takes the line, commonly given as content-disposition header in the multipart */
        ParameterParser(std::string_view line) {
            remainingLine = line;
        }

        /* Returns next key/value where value can simply be empty.
         * If key (first) is empty then we are at the end */
        std::pair<std::string_view, std::string_view> getKeyValue() {
            auto key = getToken();
            auto op = getToken();

            if (!op.length()) {
                return {key, ""};
            }

            if (op[0] != ';') {
                auto value = getToken();
                /* Strip ; or if at end, nothing */
                getToken();
                return {key, value};
            }

            return {key, ""};
        }

    private:
        std::string_view remainingLine;

        /* Consumes a token from the line. Will "unquote" strings */
        std::string_view getToken() {
            /* Strip whitespace */
            while (remainingLine.length() && isspace(remainingLine[0])) {
                remainingLine.remove_prefix(1);
            }

            if (!remainingLine.length()) {
                /* All we had was space */
                return {};
            } else {
                /* Are we at an operator? */
                if (remainingLine[0] == ';' || remainingLine[0] == '=') {
                    auto op = remainingLine.substr(0, 1);
                    remainingLine.remove_prefix(1);
                    return op;
                } else {
                    /* Are we at a quoted string? */
                    if (remainingLine[0] == '\"') {
                        /* Remove first quote and start counting */
                        remainingLine.remove_prefix(1);
                        auto quote = remainingLine;
                        int quoteLength = 0;

                        /* Read anything until other double quote appears */
                        while (remainingLine.length() && remainingLine[0] != '\"') {
                            remainingLine.remove_prefix(1);
                            quoteLength++;
                        }

                        /* We can't remove_prefix if we have nothing to remove */
                        if (!remainingLine.length()) {
                            return {};
                        }

                        remainingLine.remove_prefix(1);
                        return quote.substr(0, quoteLength);
                    } else {
                        /* Read anything until ; = space or end */
                        std::string_view token = remainingLine;

                        int tokenLength = 0;
                        while (remainingLine.length() && remainingLine[0] != ';' && remainingLine[0] != '=' && !isspace(remainingLine[0])) {
                            remainingLine.remove_prefix(1);
                            tokenLength++;
                        }

                        return token.substr(0, tokenLength);
                    }
                }
            }

            /* Nothing */
            return "";
        }
    };

    struct MultipartParser {

        /* 2 chars of hyphen + 1 - 70 chars of boundary */
        char prependedBoundaryBuffer[72];
        std::string_view prependedBoundary;
        std::string_view remainingBody;
        bool first = true;

        /* I think it is more than sane to limit this to 10 per part */
        //static const int MAX_HEADERS = 10;

        /* Construct the parser based on contentType (reads boundary) */
        MultipartParser(std::string_view contentType) {

            /* We expect the form "multipart/something;somethingboundary=something" */
            if (contentType.length() < 10 || contentType.substr(0, 10) != "multipart/") {
                return;
            }

            /* For now we simply guess boundary will lie between = and end. This is not entirely
            * standards compliant as boundary may be expressed with or without " and spaces */
            auto equalToken = contentType.find('=', 10);
            if (equalToken != std::string_view::npos) {

                /* Boundary must be less than or equal to 70 chars yet 1 char or longer */
                std::string_view boundary = contentType.substr(equalToken + 1);
                if (!boundary.length() || boundary.length() > 70) {
                    /* Invalid size */
                    return;
                }

                /* Prepend it with two hyphens */
                prependedBoundaryBuffer[0] = prependedBoundaryBuffer[1] = '-';
                memcpy(&prependedBoundaryBuffer[2], boundary.data(), boundary.length());

                prependedBoundary = {prependedBoundaryBuffer, boundary.length() + 2};
            }
        }

        /* Is this even a valid multipart request? */
        bool isValid() {
            return prependedBoundary.length() != 0;
        }

        /* Set the body once, before getting any parts */
        void setBody(std::string_view body) {
            remainingBody = body;
        }

        /* Parse out the next part's data, filling the headers. Returns nullopt on end or error. */
        std::optional<std::string_view> getNextPart(std::pair<std::string_view, std::string_view> *headers) {

            /* The remaining two hyphens should be shorter than the boundary */
            if (remainingBody.length() < prependedBoundary.length()) {
                /* We are done now */
                return std::nullopt;
            }

            if (first) {
                auto nextBoundary = remainingBody.find(prependedBoundary);
                if (nextBoundary == std::string_view::npos) {
                    /* Cannot parse */
                    return std::nullopt;
                }

                /* Toss away boundary and anything before it */
                remainingBody.remove_prefix(nextBoundary + prependedBoundary.length());
                first = false;
            }

            auto nextEndBoundary = remainingBody.find(prependedBoundary);
            if (nextEndBoundary == std::string_view::npos) {
                /* Cannot parse (or simply done) */
                return std::nullopt;
            }

            std::string_view part = remainingBody.substr(0, nextEndBoundary);
            remainingBody.remove_prefix(nextEndBoundary + prependedBoundary.length());

            /* Also strip rn before and rn after the part */
            if (part.length() < 4) {
                /* Cannot strip */
                return std::nullopt;
            }
            part.remove_prefix(2);
            part.remove_suffix(2);

            /* We are allowed to post pad like this because we know the boundary is at least 2 bytes */
            /* This makes parsing a second pass invalid, so you can only iterate over parts once */
            memset((char *) part.data() + part.length(), '\r', 1);

            /* For this to be a valid part, we need to consume at least 4 bytes (\r\n\r\n) */
            int consumed = getHeaders((char *) part.data(), (char *) part.data() + part.length(), headers);

            if (!consumed) {
                /* This is an invalid part */
                return std::nullopt;
            }

            /* Strip away the headers from the part body data */
            part.remove_prefix(consumed);

            /* Now pass whatever is remaining of the part */
            return part;
        }
    };

}

#endif

```

`src/PerMessageDeflate.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2021.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This standalone module implements deflate / inflate streams */

#ifndef UWS_PERMESSAGEDEFLATE_H
#define UWS_PERMESSAGEDEFLATE_H

#include <cstdint>
#include <cstring>

/* We always define these options no matter if ZLIB is enabled or not */
namespace uWS {
    /* Compressor mode is 8 lowest bits where HIGH4(windowBits), LOW4(memLevel).
     * Decompressor mode is 8 highest bits LOW4(windowBits).
     * If compressor or decompressor bits are 1, then they are shared.
     * If everything is just simply 0, then everything is disabled. */
    enum CompressOptions : uint16_t {
        /* These are not actual compression options */
        _COMPRESSOR_MASK = 0x00FF,
        _DECOMPRESSOR_MASK = 0x0F00,
        /* Disabled, shared, shared are "special" values */
        DISABLED = 0,
        SHARED_COMPRESSOR = 1,
        SHARED_DECOMPRESSOR = 1 << 8,
        /* Highest 4 bits describe decompressor */
        DEDICATED_DECOMPRESSOR_32KB = 15 << 8,
        DEDICATED_DECOMPRESSOR_16KB = 14 << 8,
        DEDICATED_DECOMPRESSOR_8KB = 13 << 8,
        DEDICATED_DECOMPRESSOR_4KB = 12 << 8,
        DEDICATED_DECOMPRESSOR_2KB = 11 << 8,
        DEDICATED_DECOMPRESSOR_1KB = 10 << 8,
        DEDICATED_DECOMPRESSOR_512B = 9 << 8,
        /* Same as 32kb */
        DEDICATED_DECOMPRESSOR = 15 << 8,

        /* Lowest 8 bit describe compressor */
        DEDICATED_COMPRESSOR_3KB = 9 << 4 | 1,
        DEDICATED_COMPRESSOR_4KB = 9 << 4 | 2,
        DEDICATED_COMPRESSOR_8KB = 10 << 4 | 3,
        DEDICATED_COMPRESSOR_16KB = 11 << 4 | 4,
        DEDICATED_COMPRESSOR_32KB = 12 << 4 | 5,
        DEDICATED_COMPRESSOR_64KB = 13 << 4 | 6,
        DEDICATED_COMPRESSOR_128KB = 14 << 4 | 7,
        DEDICATED_COMPRESSOR_256KB = 15 << 4 | 8,
        /* Same as 256kb */
        DEDICATED_COMPRESSOR = 15 << 4 | 8
    };
}

#if !defined(UWS_NO_ZLIB) && !defined(UWS_MOCK_ZLIB)
#include <zlib.h>
#endif

#include <string>
#include <optional>

#ifdef UWS_USE_LIBDEFLATE
#include "libdeflate.h"
#include <cstring>
#endif

namespace uWS {

/* Do not compile this module if we don't want it */
#if defined(UWS_NO_ZLIB) || defined(UWS_MOCK_ZLIB)
struct ZlibContext {};
struct InflationStream {
    std::optional<std::string_view> inflate(ZlibContext * /*zlibContext*/, std::string_view compressed, size_t maxPayloadLength, bool /*reset*/) {
        return compressed.substr(0, std::min(maxPayloadLength, compressed.length()));
    }
    InflationStream(CompressOptions /*compressOptions*/) {
    }
};
struct DeflationStream {
    std::string_view deflate(ZlibContext * /*zlibContext*/, std::string_view raw, bool /*reset*/) {
        return raw;
    }
    DeflationStream(CompressOptions /*compressOptions*/) {
    }
};
#else

#define LARGE_BUFFER_SIZE 1024 * 16 // todo: fix this

struct ZlibContext {
    /* Any returned data is valid until next same-class call.
     * We need to have two classes to allow inflation followed
     * by many deflations without modifying the inflation */
    std::string dynamicDeflationBuffer;
    std::string dynamicInflationBuffer;
    char *deflationBuffer;
    char *inflationBuffer;

#ifdef UWS_USE_LIBDEFLATE
    libdeflate_decompressor *decompressor;
    libdeflate_compressor *compressor;
#endif

    ZlibContext() {
        deflationBuffer = (char *) malloc(LARGE_BUFFER_SIZE);
        inflationBuffer = (char *) malloc(LARGE_BUFFER_SIZE);

#ifdef UWS_USE_LIBDEFLATE
        decompressor = libdeflate_alloc_decompressor();
        compressor = libdeflate_alloc_compressor(6);
#endif
    }

    ~ZlibContext() {
        free(deflationBuffer);
        free(inflationBuffer);

#ifdef UWS_USE_LIBDEFLATE
        libdeflate_free_decompressor(decompressor);
        libdeflate_free_compressor(compressor);
#endif
    }
};

struct DeflationStream {
    z_stream deflationStream = {};

    DeflationStream(CompressOptions compressOptions) {

        /* Sliding inflator should be about 44kb by default, less than compressor */

        /* Memory usage is given by 2 ^ (windowBits + 2) + 2 ^ (memLevel + 9) */
        int windowBits = -(int) ((compressOptions & _COMPRESSOR_MASK) >> 4), memLevel = compressOptions & 0xF;

        //printf("windowBits: %d, memLevel: %d\n", windowBits, memLevel);

        deflateInit2(&deflationStream, Z_DEFAULT_COMPRESSION, Z_DEFLATED, windowBits, memLevel, Z_DEFAULT_STRATEGY);
    }

    /* Deflate and optionally reset. You must not deflate an empty string. */
    std::string_view deflate(ZlibContext *zlibContext, std::string_view raw, bool reset) {

        /* Odd place to clear this one, fix */
        zlibContext->dynamicDeflationBuffer.clear();

        deflationStream.next_in = (Bytef *) raw.data();
        deflationStream.avail_in = (unsigned int) raw.length();

        /* This buffer size has to be at least 6 bytes for Z_SYNC_FLUSH to work */
        const int DEFLATE_OUTPUT_CHUNK = LARGE_BUFFER_SIZE;

        int err;
        do {
            deflationStream.next_out = (Bytef *) zlibContext->deflationBuffer;
            deflationStream.avail_out = DEFLATE_OUTPUT_CHUNK;

            err = ::deflate(&deflationStream, Z_SYNC_FLUSH);
            if (Z_OK == err && deflationStream.avail_out == 0) {
                zlibContext->dynamicDeflationBuffer.append(zlibContext->deflationBuffer, DEFLATE_OUTPUT_CHUNK - deflationStream.avail_out);
                continue;
            } else {
                break;
            }
        } while (true);

        /* This must not change avail_out */
        if (reset) {
            deflateReset(&deflationStream);
        }

        if (zlibContext->dynamicDeflationBuffer.length()) {
            zlibContext->dynamicDeflationBuffer.append(zlibContext->deflationBuffer, DEFLATE_OUTPUT_CHUNK - deflationStream.avail_out);

            return std::string_view((char *) zlibContext->dynamicDeflationBuffer.data(), zlibContext->dynamicDeflationBuffer.length() - 4);
        }

        /* Note: We will get an interger overflow resulting in heap buffer overflow if Z_BUF_ERROR is returned
         * from passing 0 as avail_in. Therefore we must not deflate an empty string */
        return {
            zlibContext->deflationBuffer,
            DEFLATE_OUTPUT_CHUNK - deflationStream.avail_out - 4
        };
    }

    ~DeflationStream() {
        deflateEnd(&deflationStream);
    }
};

struct InflationStream {
    z_stream inflationStream = {};

    InflationStream(CompressOptions compressOptions) {
        /* Inflation windowBits are the top 8 bits of the 16 bit compressOptions */
        inflateInit2(&inflationStream, -(compressOptions >> 8));
    }

    ~InflationStream() {
        inflateEnd(&inflationStream);
    }

    /* Zero length inflates are possible and valid */
    std::optional<std::string_view> inflate(ZlibContext *zlibContext, std::string_view compressed, size_t maxPayloadLength, bool reset) {

#ifdef UWS_USE_LIBDEFLATE
        if (reset) {
            /* Try fast path first (assuming single DEFLATE block and shared compressor aka reset = true) */
            size_t written = 0, consumed;
            zlibContext->dynamicInflationBuffer.clear();
            zlibContext->dynamicInflationBuffer.reserve(maxPayloadLength);

            ((char *)compressed.data())[0] |= 0x1; // BFINAL = 1
            libdeflate_result res = libdeflate_deflate_decompress_ex(zlibContext->decompressor, compressed.data(), compressed.length(), zlibContext->dynamicInflationBuffer.data(), maxPayloadLength, &consumed, &written);
    
            /* Still not entirely sure why 1 extra zero byte is optional and ignored by both zlib and libdeflate in some cases */
            /* Minimal reproducer is load_test.c with 102 byte message size. It should be tested with Chrome at various message sizes as well. */
            if (res == 0 && (consumed == compressed.length() || (consumed + 1 == compressed.length() && compressed[consumed] == '\0'))) {
                return std::string_view(zlibContext->dynamicInflationBuffer.data(), written);
            } else {
                /* We can only end up here if the first DEFLATE block was not the last, so mark it as such */
                ((char *)compressed.data())[0] &= ~0x1; // BFINAL = 0
            }
        }
#endif

        /* Save off the bytes we're about to overwrite */
        char* tailLocation = (char*)compressed.data() + compressed.length();
        char preTailBytes[4];
        memcpy(preTailBytes, tailLocation, 4);

        /* Append tail to chunk */
        unsigned char tail[4] = {0x00, 0x00, 0xff, 0xff};
        memcpy(tailLocation, tail, 4);
        compressed = {compressed.data(), compressed.length() + 4};

        /* We clear this one here, could be done better */
        zlibContext->dynamicInflationBuffer.clear();

        inflationStream.next_in = (Bytef *) compressed.data();
        inflationStream.avail_in = (unsigned int) compressed.length();

        int err;
        do {
            inflationStream.next_out = (Bytef *) zlibContext->inflationBuffer;
            inflationStream.avail_out = LARGE_BUFFER_SIZE;

            err = ::inflate(&inflationStream, Z_SYNC_FLUSH);
            if (err == Z_OK && inflationStream.avail_out) {
                break;
            }

            zlibContext->dynamicInflationBuffer.append(zlibContext->inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);


        } while (inflationStream.avail_out == 0 && zlibContext->dynamicInflationBuffer.length() <= maxPayloadLength);

        if (reset) {
            inflateReset(&inflationStream);
        }

        /* Restore the bytes we used for the tail */
        memcpy(tailLocation, preTailBytes, 4);

        if ((err != Z_BUF_ERROR && err != Z_OK) || zlibContext->dynamicInflationBuffer.length() > maxPayloadLength) {
            return std::nullopt;
        }

        if (zlibContext->dynamicInflationBuffer.length()) {
            zlibContext->dynamicInflationBuffer.append(zlibContext->inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);

            /* Let's be strict about the max size */
            if (zlibContext->dynamicInflationBuffer.length() > maxPayloadLength) {
                return std::nullopt;
            }

            return std::string_view(zlibContext->dynamicInflationBuffer.data(), zlibContext->dynamicInflationBuffer.length());
        }

        /* Let's be strict about the max size */
        if ((LARGE_BUFFER_SIZE - inflationStream.avail_out) > maxPayloadLength) {
            return std::nullopt;
        }

        return std::string_view(zlibContext->inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);
    }

};

#endif

}

#endif // UWS_PERMESSAGEDEFLATE_H

```

`src/ProxyParser.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This module implements The PROXY Protocol v2 */

#ifndef UWS_PROXY_PARSER_H
#define UWS_PROXY_PARSER_H

#ifdef UWS_WITH_PROXY

namespace uWS {

struct proxy_hdr_v2 {
    uint8_t sig[12];  /* hex 0D 0A 0D 0A 00 0D 0A 51 55 49 54 0A */
    uint8_t ver_cmd;  /* protocol version and command */
    uint8_t fam;      /* protocol family and address */
    uint16_t len;     /* number of following bytes part of the header */
};

union proxy_addr {
    struct {        /* for TCP/UDP over IPv4, len = 12 */
        uint32_t src_addr;
        uint32_t dst_addr;
        uint16_t src_port;
        uint16_t dst_port;
    } ipv4_addr;
    struct {        /* for TCP/UDP over IPv6, len = 36 */
            uint8_t  src_addr[16];
            uint8_t  dst_addr[16];
            uint16_t src_port;
            uint16_t dst_port;
    } ipv6_addr;
};

/* Byte swap for little-endian systems */
/* Todo: This functions should be shared with the one in WebSocketProtocol.h! */
template <typename T>
T _cond_byte_swap(T value) {
    uint32_t endian_test = 1;
    if (*((char *)&endian_test)) {
        union {
            T i;
            uint8_t b[sizeof(T)];
        } src = { value }, dst;

        for (unsigned int i = 0; i < sizeof(value); i++) {
            dst.b[i] = src.b[sizeof(value) - 1 - i];
        }

        return dst.i;
    }
    return value;
}

struct ProxyParser {
private:
    union proxy_addr addr;

    /* Default family of 0 signals no proxy address */
    uint8_t family = 0;

public:
    /* Returns 4 or 16 bytes source address */
    std::string_view getSourceAddress() {

        // UNSPEC family and protocol
        if (family == 0) {
            return {};
        }

        if ((family & 0xf0) >> 4 == 1) {
            /* Family 1 is INET4 */
            return {(char *) &addr.ipv4_addr.src_addr, 4};
        } else {
            /* Family 2 is INET6 */
            return {(char *) &addr.ipv6_addr.src_addr, 16};
        }
    }

    /* Returns [done, consumed] where done = false on failure */
    std::pair<bool, unsigned int> parse(std::string_view data) {

        /* We require at least four bytes to determine protocol */
        if (data.length() < 4) {
            return {false, 0};
        }

        /* HTTP can never start with "\r\n\r\n", but PROXY always does */
        if (memcmp(data.data(), "\r\n\r\n", 4)) {
            /* This is HTTP, so be done */
            return {true, 0};
        }

        /* We assume we are parsing PROXY V2 here */

        /* We require 16 bytes here */
        if (data.length() < 16) {
            return {false, 0};
        }

        /* Header is 16 bytes */
        struct proxy_hdr_v2 header;
        memcpy(&header, data.data(), 16);

        if (memcmp(header.sig, "\x0D\x0A\x0D\x0A\x00\x0D\x0A\x51\x55\x49\x54\x0A", 12)) {
            /* This is not PROXY protocol at all */
            return {false, 0};
        }

        /* We only support version 2 */
        if ((header.ver_cmd & 0xf0) >> 4 != 2) {
            return {false, 0};
        }

        //printf("Version: %d\n", (header.ver_cmd & 0xf0) >> 4);
        //printf("Command: %d\n", (header.ver_cmd & 0x0f));

        /* We get length in network byte order (todo: share this function with the rest) */
        uint16_t hostLength = _cond_byte_swap<uint16_t>(header.len);

        /* We must have all the data available */
        if (data.length() < 16u + hostLength) {
            return {false, 0};
        }

        /* Payload cannot be more than sizeof proxy_addr */
        if (sizeof(proxy_addr) < hostLength) {
            return {false, 0};
        }

        //printf("Family: %d\n", (header.fam & 0xf0) >> 4);
        //printf("Transport: %d\n", (header.fam & 0x0f));

        /* We have 0 family by default, and UNSPEC is 0 as well */
        family = header.fam;

        /* Copy payload */
        memcpy(&addr, data.data() + 16, hostLength);

        /* We consumed everything */
        return {true, 16 + hostLength};
    }
};

}

#endif

#endif // UWS_PROXY_PARSER_H
```

`src/QueryParser.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This module implements URI query parsing and retrieval of value given key */

#ifndef UWS_QUERYPARSER_H
#define UWS_QUERYPARSER_H

#include <string_view>

namespace uWS {

    /* Takes raw query including initial '?' sign. Will inplace decode, so input will mutate */
    static inline std::string_view getDecodedQueryValue(std::string_view key, std::string_view rawQuery) {

        /* Can't have a value without a key */
        if (!key.length()) {
            return {};
        }

        /* Start with the whole querystring including initial '?' */
        std::string_view queryString = rawQuery;

        /* List of key, value could be cached for repeated fetches similar to how headers are, todo! */
        while (queryString.length()) {
            /* Find boundaries of this statement */
            std::string_view statement = queryString.substr(1, queryString.find('&', 1) - 1);

            /* Only bother if first char of key match (early exit) */
            if (statement.length() && statement[0] == key[0]) {
                /* Equal sign must be present and not in the end of statement */
                auto equality = statement.find('=');
                if (equality != std::string_view::npos) {

                    std::string_view statementKey = statement.substr(0, equality);
                    std::string_view statementValue = statement.substr(equality + 1);

                    /* String comparison */
                    if (key == statementKey) {

                        /* Decode value inplace, put null at end if before length of original */
                        char *in = (char *) statementValue.data();

                        /* Write offset */
                        unsigned int out = 0;

                        /* Walk over all chars until end or null char, decoding in place */
                        for (unsigned int i = 0; i < statementValue.length() && in[i]; i++) {
                                /* Only bother with '%' */
                                if (in[i] == '%') {
                                    /* Do we have enough data for two bytes hex? */
                                    if (i + 2 >= statementValue.length()) {
                                        return {};
                                    }

                                    /* Two bytes hex */
                                    int hex1 = in[i + 1] - '0';
                                    if (hex1 > 9) {
                                        hex1 &= 223;
                                        hex1 -= 7;
                                    }

                                    int hex2 = in[i + 2] - '0';
                                    if (hex2 > 9) {
                                        hex2 &= 223;
                                        hex2 -= 7;
                                    }

                                    *((unsigned char *) &in[out]) = (unsigned char) (hex1 * 16 + hex2);
                                    i += 2;
                                } else {
                                    /* Is this even a rule? */
                                    if (in[i] == '+') {
                                        in[out] = ' ';
                                    } else {
                                        in[out] = in[i];
                                    }
                                }

                                /* We always only write one char */
                                out++;
                        }

                        /* If decoded string is shorter than original, put null char to stop next read */
                        if (out < statementValue.length()) {
                            in[out] = 0;
                        }

                        return statementValue.substr(0, out);
                    }
                } else {
                    /* This querystring is invalid, cannot parse it */
                    return {nullptr, 0};
                }
            }

            queryString.remove_prefix(statement.length() + 1);
        }

        /* Nothing found is given as nullptr, while empty string is given as some pointer to the given buffer */
        return {nullptr, 0};
    }

}

#endif

```

`src/TopicTree.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2021.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_TOPICTREE_H
#define UWS_TOPICTREE_H

#include <map>
#include <list>
#include <iostream>
#include <unordered_set>
#include <utility>
#include <memory>
#include <unordered_map>
#include <vector>
#include <string_view>
#include <functional>
#include <set>
#include <string>
#include <exception>

namespace uWS {

struct Subscriber;

struct Topic : std::unordered_set<Subscriber *> {

    Topic(std::string_view topic) : name(topic) {

    }

    std::string name;
};

struct Subscriber {

    template <typename, typename> friend struct TopicTree;

private:
    /* We use a factory */
    Subscriber() = default;

    /* State of prev, next does not matter unless we are needsDrainage() since we are not in the list */
    Subscriber *prev, *next;

    /* Any one subscriber can be part of at most 32 publishes before it needs a drain,
     * or whatever encoding of runs or whatever we might do in the future */
    uint16_t messageIndices[32];

    /* This one matters the most, if it is 0 we are not in the list of drainableSubscribers */
    unsigned char numMessageIndices = 0;

public:

    /* We have a list of topics we subscribe to (read by WebSocket::iterateTopics) */
    std::set<Topic *> topics;

    /* User data */
    void *user;

    bool needsDrainage() {
        return numMessageIndices;
    }
};

template <typename T, typename B>
struct TopicTree {

    enum IteratorFlags {
        LAST = 1,
        FIRST = 2
    };

    /* Whomever is iterating this topic is locked to not modify its own list */
    Subscriber *iteratingSubscriber = nullptr;

private:

    /* The drain callback must not publish, unsubscribe or subscribe.
     * It must only cork, uncork, send, write */
    std::function<bool(Subscriber *, T &, IteratorFlags)> cb;

    /* The topics */
    std::unordered_map<std::string_view, std::unique_ptr<Topic>> topics;

    /* List of subscribers that needs drainage */
    Subscriber *drainableSubscribers = nullptr;

    /* Palette of outgoing messages, up to 64k */
    std::vector<T> outgoingMessages;

    void checkIteratingSubscriber(Subscriber *s) {
        /* Notify user that they are doing something wrong here */
        if (iteratingSubscriber == s) {
            std::cerr << "Error: WebSocket must not subscribe or unsubscribe to topics while iterating its topics!" << std::endl;
            std::terminate();
        }
    }

    /* Warning: does NOT unlink from drainableSubscribers or modify next, prev. */
    void drainImpl(Subscriber *s) {
        /* Before we call cb we need to make sure this subscriber will not report needsDrainage()
         * since WebSocket::send will call drain from within the cb in that case.*/
        int numMessageIndices = s->numMessageIndices;
        s->numMessageIndices = 0;

        /* Then we emit cb */
        for (int i = 0; i < numMessageIndices; i++) {
            T &outgoingMessage = outgoingMessages[s->messageIndices[i]];

            int flags = (i == numMessageIndices - 1) ? LAST : 0;

            /* Returning true will stop drainage short (such as when backpressure is too high) */
            if (cb(s, outgoingMessage, (IteratorFlags)(flags | (i == 0 ? FIRST : 0)))) {
                break;
            }
        }
    }

    void unlinkDrainableSubscriber(Subscriber *s) {
        if (s->prev) {
            s->prev->next = s->next;
        }
        if (s->next) {
            s->next->prev = s->prev;
        }
        /* If we are the head, then we also need to reset the head */
        if (drainableSubscribers == s) {
            drainableSubscribers = s->next;
        }
    }

public:

    TopicTree(std::function<bool(Subscriber *, T &, IteratorFlags)> cb) : cb(cb) {

    }

    /* Returns nullptr if not found */
    Topic *lookupTopic(std::string_view topic) {
        auto it = topics.find(topic);
        if (it == topics.end()) {
            return nullptr;
        }
        return it->second.get();
    }

    /* Subscribe fails if we already are subscribed */
    Topic *subscribe(Subscriber *s, std::string_view topic) {
        /* Notify user that they are doing something wrong here */
        checkIteratingSubscriber(s);

        /* Lookup or create new topic */
        Topic *topicPtr = lookupTopic(topic);
        if (!topicPtr) {
            Topic *newTopic = new Topic(topic);
            topics.insert({std::string_view(newTopic->name.data(), newTopic->name.length()), std::unique_ptr<Topic>(newTopic)});
            topicPtr = newTopic;
        }

        /* Insert us in topic, insert topic in us */
        auto [it, inserted] = s->topics.insert(topicPtr);
        if (!inserted) {
            return nullptr;
        }
        topicPtr->insert(s);

        /* Success */
        return topicPtr;
    }

    /* Returns ok, last, newCount */
    std::tuple<bool, bool, int> unsubscribe(Subscriber *s, std::string_view topic) {
        /* Notify user that they are doing something wrong here */
        checkIteratingSubscriber(s);

        /* Lookup topic */
        Topic *topicPtr = lookupTopic(topic);
        if (!topicPtr) {
            /* If the topic doesn't exist we are assumed to still be subscribers of something */
            return {false, false, -1};
        }

        /* Erase from our list first */
        if (s->topics.erase(topicPtr) == 0) {
            return {false, false, -1};
        }

        /* Remove us from topic */
        topicPtr->erase(s);

        int newCount = (int) topicPtr->size();

        /* If there is no subscriber to this topic, remove it */
        if (!topicPtr->size()) {
            /* Unique_ptr deletes the topic */
            topics.erase(topic);
        }

        /* If we don't hold any topics we are to be freed altogether */
        return {true, s->topics.size() == 0, newCount};
    }

    /* Factory function for creating a Subscriber */
    Subscriber *createSubscriber() {
        return new Subscriber();
    }

    /* This is used to end a Subscriber, before freeing it */
    void freeSubscriber(Subscriber *s) {

        /* I guess we call this one even if we are not subscribers */
        if (!s) {
            return;
        }

        /* For all topics, unsubscribe */
        for (Topic *topicPtr : s->topics) {
            /* If we are the last subscriber, simply remove the whole topic */
            if (topicPtr->size() == 1) {
                topics.erase(topicPtr->name);
            } else {
                /* Otherwise just remove us */
                topicPtr->erase(s);
            }
        }

        /* We also need to unlink us */
        if (s->needsDrainage()) {
            unlinkDrainableSubscriber(s);
        }

        delete s;
    }

    /* Mainly used by WebSocket::send to drain one socket before sending */
    void drain(Subscriber *s) {
        /* The list is undefined and cannot be touched unless needsDrainage(). */
        if (s->needsDrainage()) {
            /* This function differs from drainImpl by properly unlinking
            * the subscriber from drainableSubscribers. drainImpl does not. */
            unlinkDrainableSubscriber(s);

            /* This one always resets needsDrainage before it calls any cb's.
             * Otherwise we would stackoverflow when sending after publish but before drain. */
            drainImpl(s);
            
            /* If we drained last subscriber, also clear outgoingMessages */
            if (!drainableSubscribers) {
                outgoingMessages.clear();
            }
        }
    }

    /* Called everytime we call send, to drain published messages so to sync outgoing messages */
    void drain() {
        if (drainableSubscribers) {
            /* Drain one socket a time */
            for (Subscriber *s = drainableSubscribers; s; s = s->next) {
                /* Instead of unlinking every single subscriber, we just leave the list undefined
                 * and reset drainableSubscribers ptr below. */
                drainImpl(s);
            }
            /* Drain always clears drainableSubscribers and outgoingMessages */
            drainableSubscribers = nullptr;
            outgoingMessages.clear();
        }
    }

    /* Big messages bypass all buffering and land directly in backpressure */
    template <typename F>
    bool publishBig(Subscriber *sender, std::string_view topic, B &&bigMessage, F cb) {
        /* Do we even have this topic? */
        auto it = topics.find(topic);
        if (it == topics.end()) {
            return false;
        }

        /* For all subscribers in topic */
        for (Subscriber *s : *it->second) {

            /* If we are sender then ignore us */
            if (sender != s) {
                cb(s, bigMessage);
            }
        }

        return true;
    }

    /* Linear in number of affected subscribers */
    bool publish(Subscriber *sender, std::string_view topic, T &&message) {
        /* Do we even have this topic? */
        auto it = topics.find(topic);
        if (it == topics.end()) {
            return false;
        }

        /* If we have more than 65k messages we need to drain every socket. */
        if (outgoingMessages.size() == UINT16_MAX) {
            /* If there is a socket that is currently corked, this will be ugly as all sockets will drain
             * to their own backpressure */
            drain();
        }

        /* If nobody references this message, don't buffer it */
        bool referencedMessage = false;

        /* For all subscribers in topic */
        for (Subscriber *s : *it->second) {

            /* If we are sender then ignore us */
            if (sender != s) {

                /* At least one subscriber wants this message */
                referencedMessage = true;

                /* If we already have too many outgoing messages on this subscriber, drain it now */
                if (s->numMessageIndices == 32) {
                    /* This one does not need to check needsDrainage here but still does. */
                    drain(s);
                }

                /* Finally we can continue */
                s->messageIndices[s->numMessageIndices++] = (uint16_t)outgoingMessages.size();
                /* First message adds subscriber to list of drainable subscribers */
                if (s->numMessageIndices == 1) {
                    /* Insert us in the head of drainable subscribers */
                    s->next = drainableSubscribers;
                    s->prev = nullptr;
                    if (s->next) {
                        s->next->prev = s;
                    }
                    drainableSubscribers = s;
                }
            }
        }

        /* Push this message and return with success */
        if (referencedMessage) {
            outgoingMessages.emplace_back(message);
        }

        /* Success if someone wants it */
        return referencedMessage;
    }
};

}

#endif

```

`src/Utilities.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_UTILITIES_H
#define UWS_UTILITIES_H

/* Various common utilities */

#include <cstdint>

namespace uWS {
namespace utils {

inline int u32toaHex(uint32_t value, char *dst) {
    char palette[] = "0123456789abcdef";
    char temp[10];
    char *p = temp;
    do {
        *p++ = palette[value & 15];
        value >>= 4;
    } while (value > 0);

    int ret = (int) (p - temp);

    do {
        *dst++ = *--p;
    } while (p != temp);

    return ret;
}

inline int u64toa(uint64_t value, char *dst) {
    char temp[20];
    char *p = temp;
    do {
        *p++ = (char) ((value % 10) + '0');
        value /= 10;
    } while (value > 0);

    int ret = (int) (p - temp);

    do {
        *dst++ = *--p;
    } while (p != temp);

    return ret;
}

}
}

#endif // UWS_UTILITIES_H

```

`src/WebSocket.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2021.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKET_H
#define UWS_WEBSOCKET_H

#include "WebSocketData.h"
#include "WebSocketProtocol.h"
#include "AsyncSocket.h"
#include "WebSocketContextData.h"

#include <string_view>

namespace uWS {

/* Experimental */
enum CompressFlags : int {
    NO_ACTION,
    COMPRESS,
    ALREADY_COMPRESSED
};

template <bool SSL, bool isServer, typename USERDATA>
struct WebSocket : AsyncSocket<SSL> {
    template <bool> friend struct TemplatedApp;
    template <bool> friend struct HttpResponse;
private:
    typedef AsyncSocket<SSL> Super;

    void *init(bool perMessageDeflate, CompressOptions compressOptions, BackPressure &&backpressure) {
        new (us_socket_ext(SSL, (us_socket_t *) this)) WebSocketData(perMessageDeflate, compressOptions, std::move(backpressure));
        return this;
    }
public:

    /* Returns pointer to the per socket user data */
    USERDATA *getUserData() {
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        /* We just have it overallocated by sizeof type */
        return (USERDATA *) (webSocketData + 1);
    }

    /* See AsyncSocket */
    using Super::getBufferedAmount;
    using Super::getRemoteAddress;
    using Super::getRemoteAddressAsText;
    using Super::getNativeHandle;

    /* WebSocket close cannot be an alias to AsyncSocket::close since
     * we need to check first if it was shut down by remote peer */
    us_socket_t *close() {
        if (us_socket_is_closed(SSL, (us_socket_t *) this)) {
            return nullptr;
        }
        WebSocketData *webSocketData = (WebSocketData *) Super::getAsyncSocketData();
        if (webSocketData->isShuttingDown) {
            return nullptr;
        }

        return us_socket_close(SSL, (us_socket_t *) this, 0, nullptr);
    }

    enum SendStatus : int {
        BACKPRESSURE,
        SUCCESS,
        DROPPED
    };

    /* Sending fragmented messages puts a bit of effort on the user; you must not interleave regular sends
     * with fragmented sends and you must sendFirstFragment, [sendFragment], then finally sendLastFragment. */
    SendStatus sendFirstFragment(std::string_view message, OpCode opCode = OpCode::BINARY, bool compress = false) {
        return send(message, opCode, compress, false);
    }

    SendStatus sendFragment(std::string_view message, bool compress = false) {
        return send(message, CONTINUATION, compress, false);
    }

    SendStatus sendLastFragment(std::string_view message, bool compress = false) {
        return send(message, CONTINUATION, compress, true);
    }

    /* Experimental */
    bool hasNegotiatedCompression() {
        WebSocketData *webSocketData = (WebSocketData *) Super::getAsyncSocketData();
        return webSocketData->compressionStatus == WebSocketData::ENABLED;
    }

    /* Experimental */
    SendStatus sendPrepared(PreparedMessage &preparedMessage) {
        if (preparedMessage.compressed && hasNegotiatedCompression() && preparedMessage.compressedMessage.length() < preparedMessage.originalMessage.length()) {
            return send({preparedMessage.compressedMessage.data(), preparedMessage.compressedMessage.length()}, (OpCode) preparedMessage.opCode, uWS::CompressFlags::ALREADY_COMPRESSED);
        }
        return send({preparedMessage.originalMessage.data(), preparedMessage.originalMessage.length()}, (OpCode) preparedMessage.opCode);
    }

    /* Send or buffer a WebSocket frame, compressed or not. Returns BACKPRESSURE on increased user space backpressure,
     * DROPPED on dropped message (due to backpressure) or SUCCCESS if you are free to send even more now. */
    SendStatus send(std::string_view message, OpCode opCode = OpCode::BINARY, int compress = false, bool fin = true) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        /* Skip sending and report success if we are over the limit of maxBackpressure */
        if (webSocketContextData->maxBackpressure && webSocketContextData->maxBackpressure < getBufferedAmount()) {
            /* Also defer a close if we should */
            if (webSocketContextData->closeOnBackpressureLimit) {
                us_socket_shutdown_read(SSL, (us_socket_t *) this);
            }

            /* It is okay to call send again from within this callback since we immediately return with DROPPED afterwards */
            if (webSocketContextData->droppedHandler) {
                webSocketContextData->droppedHandler(this, message, opCode);
            }

            return DROPPED;
        }

        /* If we are subscribers and have messages to drain we need to drain them here to stay synced */
        WebSocketData *webSocketData = (WebSocketData *) Super::getAsyncSocketData();

        /* Special path for long sends of non-compressed, non-SSL messages */
        if (message.length() >= 16 * 1024 && !compress && !SSL && !webSocketData->subscriber && getBufferedAmount() == 0 && Super::getLoopData()->corkOffset == 0) {
            char header[10];
            int header_length = (int) protocol::formatMessage<isServer>(header, "", 0, opCode, message.length(), compress, fin);
            int written = us_socket_write2(0, (struct us_socket_t *)this, header, header_length, message.data(), (int) message.length());
        
            if (written != header_length + (int) message.length()) {
                /* Buffer up backpressure */
                if (written > header_length) {
                    webSocketData->buffer.append(message.data() + written - header_length, message.length() - (size_t) (written - header_length));
                } else {
                    webSocketData->buffer.append(header + written, (size_t) header_length - (size_t) written);
                    webSocketData->buffer.append(message.data(), message.length());
                }
                /* We cannot still be corked if we have backpressure.
                 * We also cannot uncork normally since it will re-write the already buffered
                 * up backpressure again. */
                Super::uncorkWithoutSending();
                return BACKPRESSURE;
            }
        } else {

            if (webSocketData->subscriber) {
                /* This will call back into us, send. */
                webSocketContextData->topicTree->drain(webSocketData->subscriber);
            }

            /* Transform the message to compressed domain if requested */
            if (compress) {
                WebSocketData *webSocketData = (WebSocketData *) Super::getAsyncSocketData();

                /* Check and correct the compress hint. It is never valid to compress 0 bytes */
                if (message.length() && opCode < 3 && webSocketData->compressionStatus == WebSocketData::ENABLED) {
                    /* If compress is 2 (IS_PRE_COMPRESSED), skip this step (experimental) */
                    if (compress != CompressFlags::ALREADY_COMPRESSED) {
                        LoopData *loopData = Super::getLoopData();
                        /* Compress using either shared or dedicated deflationStream */
                        if (webSocketData->deflationStream) {
                            message = webSocketData->deflationStream->deflate(loopData->zlibContext, message, false);
                        } else {
                            message = loopData->deflationStream->deflate(loopData->zlibContext, message, true);
                        }
                    }
                } else {
                    compress = false;
                }
            }

            /* Get size, allocate size, write if needed */
            size_t messageFrameSize = protocol::messageFrameSize(message.length());
            auto [sendBuffer, sendBufferAttribute] = Super::getSendBuffer(messageFrameSize);
            protocol::formatMessage<isServer>(sendBuffer, message.data(), message.length(), opCode, message.length(), compress, fin);

            /* Depending on size of message we have different paths */
            if (sendBufferAttribute == SendBufferAttribute::NEEDS_DRAIN) {
                /* This is a drain */
                auto[written, failed] = Super::write(nullptr, 0);
                if (failed) {
                    /* Return false for failure, skipping to reset the timeout below */
                    return BACKPRESSURE;
                }
            } else if (sendBufferAttribute == SendBufferAttribute::NEEDS_UNCORK) {
                /* Uncork if we came here uncorked */
                auto [written, failed] = Super::uncork();
                if (failed) {
                    return BACKPRESSURE;
                }
            }

        }

        /* Every successful send resets the timeout */
        if (webSocketContextData->resetIdleTimeoutOnSend) {
            Super::timeout(webSocketContextData->idleTimeoutComponents.first);
            WebSocketData *webSocketData = (WebSocketData *) Super::getAsyncSocketData();
            webSocketData->hasTimedOut = false;
        }

        /* Return success */
        return SUCCESS;
    }

    /* Send websocket close frame, emit close event, send FIN if successful.
     * Will not append a close reason if code is 0 or 1005. */
    void end(int code = 0, std::string_view message = {}) {
        /* Check if we already called this one */
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        if (webSocketData->isShuttingDown) {
            return;
        }

        /* We postpone any FIN sending to either drainage or uncorking */
        webSocketData->isShuttingDown = true;

        /* Format and send the close frame */
        static const int MAX_CLOSE_PAYLOAD = 123;
        size_t length = std::min<size_t>(MAX_CLOSE_PAYLOAD, message.length());
        char closePayload[MAX_CLOSE_PAYLOAD + 2];
        size_t closePayloadLength = protocol::formatClosePayload(closePayload, (uint16_t) code, message.data(), length);
        bool ok = send(std::string_view(closePayload, closePayloadLength), OpCode::CLOSE);

        /* FIN if we are ok and not corked */
        if (!this->isCorked()) {
            if (ok) {
                /* If we are not corked, and we just sent off everything, we need to FIN right here.
                 * In all other cases, we need to fin either if uncork was successful, or when drainage is complete. */
                this->shutdown();
            }
        }

        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        /* Set shorter timeout (use ping-timeout) to avoid long hanging sockets after end() on broken connections */
        Super::timeout(webSocketContextData->idleTimeoutComponents.second);

        /* At this point we iterate all currently held subscriptions and emit an event for all of them */
        if (webSocketData->subscriber && webSocketContextData->subscriptionHandler) {
            for (Topic *t : webSocketData->subscriber->topics) {
                webSocketContextData->subscriptionHandler(this, t->name, (int) t->size() - 1, (int) t->size());
            }
        }

        /* Make sure to unsubscribe from any pub/sub node at exit */
        webSocketContextData->topicTree->freeSubscriber(webSocketData->subscriber);
        webSocketData->subscriber = nullptr;

        /* Emit close event */
        if (webSocketContextData->closeHandler) {
            webSocketContextData->closeHandler(this, code, message);
        }
        ((USERDATA *) this->getUserData())->~USERDATA();
    }

    /* Corks the response if possible. Leaves already corked socket be. */
    void cork(MoveOnlyFunction<void()> &&handler) {
        if (!Super::isCorked() && Super::canCork()) {
            Super::cork();
            handler();

            /* There is no timeout when failing to uncork for WebSockets,
             * as that is handled by idleTimeout */
            auto [written, failed] = Super::uncork();
            (void)written;
            (void)failed;
        } else {
            /* We are already corked, or can't cork so let's just call the handler */
            handler();
        }
    }

    /* Subscribe to a topic according to MQTT rules and syntax. Returns success */
    bool subscribe(std::string_view topic, bool = false) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        /* Make us a subscriber if we aren't yet */
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        if (!webSocketData->subscriber) {
            webSocketData->subscriber = webSocketContextData->topicTree->createSubscriber();
            webSocketData->subscriber->user = this;
        }

        /* Cannot return numSubscribers as this is only for this particular websocket context */
        Topic *topicOrNull = webSocketContextData->topicTree->subscribe(webSocketData->subscriber, topic);
        if (topicOrNull && webSocketContextData->subscriptionHandler) {
            /* Emit this socket, the topic, new count, old count */
            webSocketContextData->subscriptionHandler(this, topic, (int) topicOrNull->size(), (int) topicOrNull->size() - 1);
        }

        /* Subscribe always succeeds */
        return true;
    }

    /* Unsubscribe from a topic, returns true if we were subscribed. */
    bool unsubscribe(std::string_view topic, bool = false) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        
        if (!webSocketData->subscriber) { return false; }

        /* Cannot return numSubscribers as this is only for this particular websocket context */
        auto [ok, last, newCount] = webSocketContextData->topicTree->unsubscribe(webSocketData->subscriber, topic);
        /* Emit subscription event if last */
        if (ok && webSocketContextData->subscriptionHandler) {
            webSocketContextData->subscriptionHandler(this, topic, newCount, newCount + 1);
        }

        /* Leave us as subscribers even if we subscribe to nothing (last unsubscribed topic might miss its message otherwise) */

        return ok;
    }

    /* Returns whether this socket is subscribed to the specified topic */
    bool isSubscribed(std::string_view topic) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        if (!webSocketData->subscriber) {
            return false;
        }

        Topic *topicPtr = webSocketContextData->topicTree->lookupTopic(topic);
        if (!topicPtr) {
            return false;
        }

        return topicPtr->count(webSocketData->subscriber);
    }

    /* Iterates all topics of this WebSocket. Every topic is represented by its full name.
     * Can be called in close handler. It is possible to modify the subscription list while
     * inside the callback ONLY IF not modifying the topic passed to the callback.
     * Topic names are valid only for the duration of the callback. */
    void iterateTopics(MoveOnlyFunction<void(std::string_view)> cb) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        if (webSocketData->subscriber) {
            /* Lock this subscriber for unsubscription / subscription */
            webSocketContextData->topicTree->iteratingSubscriber = webSocketData->subscriber;

            for (Topic *topicPtr : webSocketData->subscriber->topics) {
                cb({topicPtr->name.data(), topicPtr->name.length()});
            }

            /* Unlock subscriber */
            webSocketContextData->topicTree->iteratingSubscriber = nullptr;
        }
    }

    /* Publish a message to a topic according to MQTT rules and syntax. Returns success.
     * We, the WebSocket, must be subscribed to the topic itself and if so - no message will be sent to ourselves.
     * Use App::publish for an unconditional publish that simply publishes to whomever might be subscribed. */
    bool publish(std::string_view topic, std::string_view message, OpCode opCode = OpCode::TEXT, bool compress = false) {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL,
            (us_socket_context_t *) us_socket_context(SSL, (us_socket_t *) this)
        );

        /* We cannot be a subscriber of this topic if we are not a subscriber of anything */
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) this);
        if (!webSocketData->subscriber) {
            /* Failure, but still do return the number of subscribers */
            return false;
        }

        /* Publish as sender, does not receive its own messages even if subscribed to relevant topics */
        if (message.length() >= LoopData::CORK_BUFFER_SIZE) {
            return webSocketContextData->topicTree->publishBig(webSocketData->subscriber, topic, {message, opCode, compress}, [](Subscriber *s, TopicTreeBigMessage &message) {
                auto *ws = (WebSocket<SSL, true, int> *) s->user;

                ws->send(message.message, (OpCode)message.opCode, message.compress);
            });
        } else {
            return webSocketContextData->topicTree->publish(webSocketData->subscriber, topic, {std::string(message), opCode, compress});
        }
    }
};

}

#endif // UWS_WEBSOCKET_H

```

`src/WebSocketContext.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKETCONTEXT_H
#define UWS_WEBSOCKETCONTEXT_H

#include "WebSocketContextData.h"
#include "WebSocketProtocol.h"
#include "WebSocketData.h"
#include "WebSocket.h"

namespace uWS {

template <bool SSL, bool isServer, typename USERDATA>
struct WebSocketContext {
    template <bool> friend struct TemplatedApp;
    template <bool, typename> friend struct WebSocketProtocol;
private:
    WebSocketContext() = delete;

    us_socket_context_t *getSocketContext() {
        return (us_socket_context_t *) this;
    }

    WebSocketContextData<SSL, USERDATA> *getExt() {
        return (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, (us_socket_context_t *) this);
    }

    /* If we have negotiated compression, set this frame compressed */
    static bool setCompressed(WebSocketState<isServer> */*wState*/, void *s) {
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) s);

        if (webSocketData->compressionStatus == WebSocketData::CompressionStatus::ENABLED) {
            webSocketData->compressionStatus = WebSocketData::CompressionStatus::COMPRESSED_FRAME;
            return true;
        } else {
            return false;
        }
    }

    static void forceClose(WebSocketState<isServer> */*wState*/, void *s, std::string_view reason = {}) {
        us_socket_close(SSL, (us_socket_t *) s, (int) reason.length(), (void *) reason.data());
    }

    /* Returns true on breakage */
    static bool handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, WebSocketState<isServer> *webSocketState, void *s) {
        /* WebSocketData and WebSocketContextData */
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));
        WebSocketData *webSocketData = (WebSocketData *) us_socket_ext(SSL, (us_socket_t *) s);

        /* Is this a non-control frame? */
        if (opCode < 3) {
            /* Did we get everything in one go? */
            if (!remainingBytes && fin && !webSocketData->fragmentBuffer.length()) {

                /* Handle compressed frame */
                if (webSocketData->compressionStatus == WebSocketData::CompressionStatus::COMPRESSED_FRAME) {
                        webSocketData->compressionStatus = WebSocketData::CompressionStatus::ENABLED;

                        LoopData *loopData = (LoopData *) us_loop_ext(us_socket_context_loop(SSL, us_socket_context(SSL, (us_socket_t *) s)));
                        /* Decompress using shared or dedicated decompressor */
                        std::optional<std::string_view> inflatedFrame;
                        if (webSocketData->inflationStream) {
                            inflatedFrame = webSocketData->inflationStream->inflate(loopData->zlibContext, {data, length}, webSocketContextData->maxPayloadLength, false);
                        } else {
                            inflatedFrame = loopData->inflationStream->inflate(loopData->zlibContext, {data, length}, webSocketContextData->maxPayloadLength, true);
                        }

                        if (!inflatedFrame.has_value()) {
                            forceClose(webSocketState, s, ERR_TOO_BIG_MESSAGE_INFLATION);
                            return true;
                        } else {
                            data = (char *) inflatedFrame->data();
                            length = inflatedFrame->length();
                        }
                }

                /* Check text messages for Utf-8 validity */
                if (opCode == 1 && !protocol::isValidUtf8((unsigned char *) data, length)) {
                    forceClose(webSocketState, s, ERR_INVALID_TEXT);
                    return true;
                }

                /* Emit message event & break if we are closed or shut down when returning */
                if (webSocketContextData->messageHandler) {
                    webSocketContextData->messageHandler((WebSocket<SSL, isServer, USERDATA> *) s, std::string_view(data, length), (OpCode) opCode);
                    if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                        return true;
                    }
                }
            } else {
                /* Allocate fragment buffer up front first time */
                if (!webSocketData->fragmentBuffer.length()) {
                    webSocketData->fragmentBuffer.reserve(length + remainingBytes);
                }
                /* Fragments forming a big message are not caught until appending them */
                if (refusePayloadLength(length + webSocketData->fragmentBuffer.length(), webSocketState, s)) {
                    forceClose(webSocketState, s, ERR_TOO_BIG_MESSAGE);
                    return true;
                }
                webSocketData->fragmentBuffer.append(data, length);

                /* Are we done now? */
                // todo: what if we don't have any remaining bytes yet we are not fin? forceclose!
                if (!remainingBytes && fin) {

                    /* Handle compression */
                    if (webSocketData->compressionStatus == WebSocketData::CompressionStatus::COMPRESSED_FRAME) {
                            webSocketData->compressionStatus = WebSocketData::CompressionStatus::ENABLED;

                            /* 9 bytes of padding for libdeflate, 4 for zlib */
                            webSocketData->fragmentBuffer.append("123456789");

                            LoopData *loopData = (LoopData *) us_loop_ext(
                                us_socket_context_loop(SSL,
                                    us_socket_context(SSL, (us_socket_t *) s)
                                )
                            );

                            /* Decompress using shared or dedicated decompressor */
                            std::optional<std::string_view> inflatedFrame;
                            if (webSocketData->inflationStream) {
                                inflatedFrame = webSocketData->inflationStream->inflate(loopData->zlibContext, {webSocketData->fragmentBuffer.data(), webSocketData->fragmentBuffer.length() - 9}, webSocketContextData->maxPayloadLength, false);
                            } else {
                                inflatedFrame = loopData->inflationStream->inflate(loopData->zlibContext, {webSocketData->fragmentBuffer.data(), webSocketData->fragmentBuffer.length() - 9}, webSocketContextData->maxPayloadLength, true);
                            }

                            if (!inflatedFrame.has_value()) {
                                forceClose(webSocketState, s, ERR_TOO_BIG_MESSAGE_INFLATION);
                                return true;
                            } else {
                                data = (char *) inflatedFrame->data();
                                length = inflatedFrame->length();
                            }


                    } else {
                        // reset length and data ptrs
                        length = webSocketData->fragmentBuffer.length();
                        data = webSocketData->fragmentBuffer.data();
                    }

                    /* Check text messages for Utf-8 validity */
                    if (opCode == 1 && !protocol::isValidUtf8((unsigned char *) data, length)) {
                        forceClose(webSocketState, s, ERR_INVALID_TEXT);
                        return true;
                    }

                    /* Emit message and check for shutdown or close */
                    if (webSocketContextData->messageHandler) {
                        webSocketContextData->messageHandler((WebSocket<SSL, isServer, USERDATA> *) s, std::string_view(data, length), (OpCode) opCode);
                        if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                            return true;
                        }
                    }

                    /* If we shutdown or closed, this will be taken care of elsewhere */
                    webSocketData->fragmentBuffer.clear();
                }
            }
        } else {
            /* Control frames need the websocket to send pings, pongs and close */
            WebSocket<SSL, isServer, USERDATA> *webSocket = (WebSocket<SSL, isServer, USERDATA> *) s;

            if (!remainingBytes && fin && !webSocketData->controlTipLength) {
                if (opCode == CLOSE) {
                    auto closeFrame = protocol::parseClosePayload(data, length);
                    webSocket->end(closeFrame.code, std::string_view(closeFrame.message, closeFrame.length));
                    return true;
                } else {
                    if (opCode == PING) {
                        webSocket->send(std::string_view(data, length), (OpCode) OpCode::PONG);
                        if (webSocketContextData->pingHandler) {
                            webSocketContextData->pingHandler(webSocket, {data, length});
                            if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                                return true;
                            }
                        }
                    } else if (opCode == PONG) {
                        if (webSocketContextData->pongHandler) {
                            webSocketContextData->pongHandler(webSocket, {data, length});
                            if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                                return true;
                            }
                        }
                    }
                }
            } else {
                /* Here we never mind any size optimizations as we are in the worst possible path */
                webSocketData->fragmentBuffer.append(data, length);
                webSocketData->controlTipLength += (unsigned int) length;

                if (!remainingBytes && fin) {
                    char *controlBuffer = (char *) webSocketData->fragmentBuffer.data() + webSocketData->fragmentBuffer.length() - webSocketData->controlTipLength;
                    if (opCode == CLOSE) {
                        protocol::CloseFrame closeFrame = protocol::parseClosePayload(controlBuffer, webSocketData->controlTipLength);
                        webSocket->end(closeFrame.code, std::string_view(closeFrame.message, closeFrame.length));
                        return true;
                    } else {
                        if (opCode == PING) {
                            webSocket->send(std::string_view(controlBuffer, webSocketData->controlTipLength), (OpCode) OpCode::PONG);
                            if (webSocketContextData->pingHandler) {
                                webSocketContextData->pingHandler(webSocket, std::string_view(controlBuffer, webSocketData->controlTipLength));
                                if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                                    return true;
                                }
                            }
                        } else if (opCode == PONG) {
                            if (webSocketContextData->pongHandler) {
                                webSocketContextData->pongHandler(webSocket, std::string_view(controlBuffer, webSocketData->controlTipLength));
                                if (us_socket_is_closed(SSL, (us_socket_t *) s) || webSocketData->isShuttingDown) {
                                    return true;
                                }
                            }
                        }
                    }

                    /* Same here, we do not care for any particular smart allocation scheme */
                    webSocketData->fragmentBuffer.resize((unsigned int) webSocketData->fragmentBuffer.length() - webSocketData->controlTipLength);
                    webSocketData->controlTipLength = 0;
                }
            }
        }
        return false;
    }

    static bool refusePayloadLength(uint64_t length, WebSocketState<isServer> */*wState*/, void *s) {
        auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));

        /* Return true for refuse, false for accept */
        return webSocketContextData->maxPayloadLength < length;
    }

    WebSocketContext<SSL, isServer, USERDATA> *init() {
        /* Adopting a socket does not trigger open event.
         * We arreive as WebSocket with timeout set and
         * any backpressure from HTTP state kept. */

        /* Handle socket disconnections */
        us_socket_context_on_close(SSL, getSocketContext(), [](auto *s, int code, void *reason) {
            /* For whatever reason, if we already have emitted close event, do not emit it again */
            WebSocketData *webSocketData = (WebSocketData *) (us_socket_ext(SSL, s));
            if (!webSocketData->isShuttingDown) {
                /* Emit close event */
                auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));

                /* At this point we iterate all currently held subscriptions and emit an event for all of them */
                if (webSocketData->subscriber && webSocketContextData->subscriptionHandler) {
                    for (Topic *t : webSocketData->subscriber->topics) {
                        webSocketContextData->subscriptionHandler((WebSocket<SSL, isServer, USERDATA> *) s, t->name, (int) t->size() - 1, (int) t->size());
                    }
                }

                /* Make sure to unsubscribe from any pub/sub node at exit */
                webSocketContextData->topicTree->freeSubscriber(webSocketData->subscriber);
                webSocketData->subscriber = nullptr;

                auto *ws = (WebSocket<SSL, isServer, USERDATA> *) s;
                if (webSocketContextData->closeHandler) {
                    webSocketContextData->closeHandler(ws, 1006, {(char *) reason, (size_t) code});
                }
                ((USERDATA *) ws->getUserData())->~USERDATA();
            }

            /* Destruct in-placed data struct */
            webSocketData->~WebSocketData();

            return s;
        });

        /* Handle WebSocket data streams */
        us_socket_context_on_data(SSL, getSocketContext(), [](auto *s, char *data, int length) {

            /* We need the websocket data */
            WebSocketData *webSocketData = (WebSocketData *) (us_socket_ext(SSL, s));

            /* When in websocket shutdown mode, we do not care for ANY message, whether responding close frame or not.
             * We only care for the TCP FIN really, not emitting any message after closing is key */
            if (webSocketData->isShuttingDown) {
                return s;
            }

            auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));
            auto *asyncSocket = (AsyncSocket<SSL> *) s;

            /* Every time we get data and not in shutdown state we simply reset the timeout */
            asyncSocket->timeout(webSocketContextData->idleTimeoutComponents.first);
            webSocketData->hasTimedOut = false;

            /* We always cork on data */
            asyncSocket->cork();

            /* This parser has virtually no overhead */
            WebSocketProtocol<isServer, WebSocketContext<SSL, isServer, USERDATA>>::consume(data, (unsigned int) length, (WebSocketState<isServer> *) webSocketData, s);

            /* Uncorking a closed socekt is fine, in fact it is needed */
            asyncSocket->uncork();

            /* If uncorking was successful and we are in shutdown state then send TCP FIN */
            if (asyncSocket->getBufferedAmount() == 0) {
                /* We can now be in shutdown state */
                if (webSocketData->isShuttingDown) {
                    /* Shutting down a closed socket is handled by uSockets and just fine */
                    asyncSocket->shutdown();
                }
            }

            return s;
        });

        /* Handle HTTP write out (note: SSL_read may trigger this spuriously, the app need to handle spurious calls) */
        us_socket_context_on_writable(SSL, getSocketContext(), [](auto *s) {

            /* NOTE: Are we called here corked? If so, the below write code is broken, since
             * we will have 0 as getBufferedAmount due to writing to cork buffer, then sending TCP FIN before
             * we actually uncorked and sent off things */

            /* It makes sense to check for us_is_shut_down here and return if so, to avoid shutting down twice */
            if (us_socket_is_shut_down(SSL, (us_socket_t *) s)) {
                return s;
            }

            AsyncSocket<SSL> *asyncSocket = (AsyncSocket<SSL> *) s;
            WebSocketData *webSocketData = (WebSocketData *)(us_socket_ext(SSL, s));

            /* We store old backpressure since it is unclear whether write drained anything,
             * however, in case of coming here with 0 backpressure we still need to emit drain event */
            unsigned int backpressure = asyncSocket->getBufferedAmount();

            /* Drain as much as possible */
            asyncSocket->write(nullptr, 0);

            /* Behavior: if we actively drain backpressure, always reset timeout (even if we are in shutdown) */
            /* Also reset timeout if we came here with 0 backpressure */
            if (!backpressure || backpressure > asyncSocket->getBufferedAmount()) {
                auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));
                asyncSocket->timeout(webSocketContextData->idleTimeoutComponents.first);
                webSocketData->hasTimedOut = false;
            }

            /* Are we in (WebSocket) shutdown mode? */
            if (webSocketData->isShuttingDown) {
                /* Check if we just now drained completely */
                if (asyncSocket->getBufferedAmount() == 0) {
                    /* Now perform the actual TCP/TLS shutdown which was postponed due to backpressure */
                    asyncSocket->shutdown();
                }
            } else if (!backpressure || backpressure > asyncSocket->getBufferedAmount()) {
                /* Only call drain if we actually drained backpressure or if we came here with 0 backpressure */
                auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));
                if (webSocketContextData->drainHandler) {
                    webSocketContextData->drainHandler((WebSocket<SSL, isServer, USERDATA> *) s);
                }
                /* No need to check for closed here as we leave the handler immediately*/
            }

            return s;
        });

        /* Handle FIN, WebSocket does not support half-closed sockets, so simply close */
        us_socket_context_on_end(SSL, getSocketContext(), [](auto *s) {

            /* If we get a fin, we just close I guess */
            us_socket_close(SSL, (us_socket_t *) s, (int) ERR_TCP_FIN.length(), (void *) ERR_TCP_FIN.data());

            return s;
        });

        us_socket_context_on_long_timeout(SSL, getSocketContext(), [](auto *s) {
            ((WebSocket<SSL, isServer, USERDATA> *) s)->end(1000, "please reconnect");

            return s;
        });

        /* Handle socket timeouts, simply close them so to not confuse client with FIN */
        us_socket_context_on_timeout(SSL, getSocketContext(), [](auto *s) {

            auto *webSocketData = (WebSocketData *)(us_socket_ext(SSL, s));
            auto *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, us_socket_context(SSL, (us_socket_t *) s));

            if (webSocketContextData->sendPingsAutomatically && !webSocketData->isShuttingDown && !webSocketData->hasTimedOut) {
                webSocketData->hasTimedOut = true;
                us_socket_timeout(SSL, s, webSocketContextData->idleTimeoutComponents.second);
                /* Send ping without being corked */
                ((AsyncSocket<SSL> *) s)->write("\x89\x00", 2);
                return s;
            }

            /* Timeout is very simple; we just close it */
            /* Warning: we happen to know forceClose will not use first parameter so pass nullptr here */
            forceClose(nullptr, s, ERR_WEBSOCKET_TIMEOUT);

            return s;
        });

        return this;
    }

    void free() {
        WebSocketContextData<SSL, USERDATA> *webSocketContextData = (WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, (us_socket_context_t *) this);
        webSocketContextData->~WebSocketContextData();

        us_socket_context_free(SSL, (us_socket_context_t *) this);
    }

public:
    /* WebSocket contexts are always child contexts to a HTTP context so no SSL options are needed as they are inherited */
    static WebSocketContext *create(Loop */*loop*/, us_socket_context_t *parentSocketContext, TopicTree<TopicTreeMessage, TopicTreeBigMessage> *topicTree) {
        WebSocketContext *webSocketContext = (WebSocketContext *) us_create_child_socket_context(SSL, parentSocketContext, sizeof(WebSocketContextData<SSL, USERDATA>));
        if (!webSocketContext) {
            return nullptr;
        }

        /* Init socket context data */
        new ((WebSocketContextData<SSL, USERDATA> *) us_socket_context_ext(SSL, (us_socket_context_t *)webSocketContext)) WebSocketContextData<SSL, USERDATA>(topicTree);
        return webSocketContext->init();
    }
};

}

#endif // UWS_WEBSOCKETCONTEXT_H

```

`src/WebSocketContextData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKETCONTEXTDATA_H
#define UWS_WEBSOCKETCONTEXTDATA_H

#include "Loop.h"
#include "AsyncSocket.h"

#include "MoveOnlyFunction.h"
#include <string_view>
#include <vector>

#include "WebSocketProtocol.h"
#include "TopicTree.h"
#include "WebSocketData.h"

namespace uWS {

/* Type queued up when publishing */
struct TopicTreeMessage {
    std::string message;
    /*OpCode*/ int opCode;
    bool compress;
};
struct TopicTreeBigMessage {
    std::string_view message;
    /*OpCode*/ int opCode;
    bool compress;
};

template <bool, bool, typename> struct WebSocket;

/* todo: this looks identical to WebSocketBehavior, why not just std::move that entire thing in? */

template <bool SSL, typename USERDATA>
struct WebSocketContextData {
private:

public:

    /* This one points to the App's shared topicTree */
    TopicTree<TopicTreeMessage, TopicTreeBigMessage> *topicTree;

    /* The callbacks for this context */
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *)> openHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, std::string_view, OpCode)> messageHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, std::string_view, OpCode)> droppedHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *)> drainHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, std::string_view, int, int)> subscriptionHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, int, std::string_view)> closeHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, std::string_view)> pingHandler = nullptr;
    MoveOnlyFunction<void(WebSocket<SSL, true, USERDATA> *, std::string_view)> pongHandler = nullptr;

    /* Settings for this context */
    size_t maxPayloadLength = 0;

    /* We do need these for async upgrade */
    CompressOptions compression;

    /* There needs to be a maxBackpressure which will force close everything over that limit */
    size_t maxBackpressure = 0;
    bool closeOnBackpressureLimit;
    bool resetIdleTimeoutOnSend;
    bool sendPingsAutomatically;
    unsigned short maxLifetime;

    /* These are calculated on creation */
    std::pair<unsigned short, unsigned short> idleTimeoutComponents;

    /* This is run once on start-up */
    void calculateIdleTimeoutCompnents(unsigned short idleTimeout) {
        unsigned short margin = 4;
        /* 4, 8 or 16 seconds margin based on idleTimeout */
        while ((int) idleTimeout - margin * 2 >= margin * 2 && margin < 16) {
            margin = (unsigned short) (margin << 1);
        }
        idleTimeoutComponents = {
            idleTimeout - (sendPingsAutomatically ? margin : 0), /* reduce normal idleTimeout if it is extended by ping-timeout */
            margin /* ping-timeout - also used for end() timeout */
        };
    }

    ~WebSocketContextData() {

    }

    WebSocketContextData(TopicTree<TopicTreeMessage, TopicTreeBigMessage> *topicTree) : topicTree(topicTree) {

    }
};

}

#endif // UWS_WEBSOCKETCONTEXTDATA_H

```

`src/WebSocketData.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKETDATA_H
#define UWS_WEBSOCKETDATA_H

#include "WebSocketProtocol.h"
#include "AsyncSocketData.h"
#include "PerMessageDeflate.h"
#include "TopicTree.h"

#include <string>

namespace uWS {

struct WebSocketData : AsyncSocketData<false>, WebSocketState<true> {
    /* This guy has a lot of friends - why? */
    template <bool, bool, typename> friend struct WebSocketContext;
    template <bool, typename> friend struct WebSocketContextData;
    template <bool, bool, typename> friend struct WebSocket;
    template <bool> friend struct HttpContext;
private:
    std::string fragmentBuffer;
    unsigned int controlTipLength = 0;
    bool isShuttingDown = 0;
    bool hasTimedOut = false;
    enum CompressionStatus : char {
        DISABLED,
        ENABLED,
        COMPRESSED_FRAME
    } compressionStatus;

    /* We might have a dedicated compressor */
    DeflationStream *deflationStream = nullptr;
    /* And / or a dedicated decompressor */
    InflationStream *inflationStream = nullptr;

    /* We could be a subscriber */
    Subscriber *subscriber = nullptr;
public:
    WebSocketData(bool perMessageDeflate, CompressOptions compressOptions, BackPressure &&backpressure) : AsyncSocketData<false>(std::move(backpressure)), WebSocketState<true>() {
        compressionStatus = perMessageDeflate ? ENABLED : DISABLED;

        /* Initialize the dedicated sliding window(s) */
        if (perMessageDeflate) {
            if ((compressOptions & CompressOptions::_COMPRESSOR_MASK) != CompressOptions::SHARED_COMPRESSOR) {
                deflationStream = new DeflationStream(compressOptions);
            }
            if ((compressOptions & CompressOptions::_DECOMPRESSOR_MASK) != CompressOptions::SHARED_DECOMPRESSOR) {
                inflationStream = new InflationStream(compressOptions);
            }
        }
    }

    ~WebSocketData() {
        if (deflationStream) {
            delete deflationStream;
        }

        if (inflationStream) {
            delete inflationStream;
        }

        if (subscriber) {
            delete subscriber;
        }
    }
};

}

#endif // UWS_WEBSOCKETDATA_H

```

`src/WebSocketExtensions.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2021.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKETEXTENSIONS_H
#define UWS_WEBSOCKETEXTENSIONS_H

/* There is a new, huge bug scenario that needs to be fixed:
 * pub/sub does not support being in DEDICATED_COMPRESSOR-mode while having
 * some clients downgraded to SHARED_COMPRESSOR - we cannot allow the client to
 * demand a downgrade to SHARED_COMPRESSOR (yet) until we fix that scenario in pub/sub */
// #define UWS_ALLOW_SHARED_AND_DEDICATED_COMPRESSOR_MIX

/* We forbid negotiating 8 windowBits since Zlib has a bug with this */
// #define UWS_ALLOW_8_WINDOW_BITS

#include <climits>
#include <cctype>
#include <string>
#include <string_view>
#include <tuple>

namespace uWS {

enum ExtensionTokens {
    /* Standard permessage-deflate tokens */
    TOK_PERMESSAGE_DEFLATE = 1838,
    TOK_SERVER_NO_CONTEXT_TAKEOVER = 2807,
    TOK_CLIENT_NO_CONTEXT_TAKEOVER = 2783,
    TOK_SERVER_MAX_WINDOW_BITS = 2372,
    TOK_CLIENT_MAX_WINDOW_BITS = 2348,
    /* Non-standard alias for Safari */
    TOK_X_WEBKIT_DEFLATE_FRAME = 2149,
    TOK_NO_CONTEXT_TAKEOVER = 2049,
    TOK_MAX_WINDOW_BITS = 1614

};

struct ExtensionsParser {
private:
    int *lastInteger = nullptr;

public:
    /* Standard */
    bool perMessageDeflate = false;
    bool serverNoContextTakeover = false;
    bool clientNoContextTakeover = false;
    int serverMaxWindowBits = 0;
    int clientMaxWindowBits = 0;

    /* Non-standard Safari */
    bool xWebKitDeflateFrame = false;
    bool noContextTakeover = false;
    int maxWindowBits = 0;

    int getToken(const char *&in, const char *stop) {
        while (in != stop && !isalnum(*in)) {
            in++;
        }

        /* Don't care more than this for now */
        static_assert(SHRT_MIN > INT_MIN, "Integer overflow fix is invalid for this platform, report this as a bug!");

        int hashedToken = 0;
        while (in != stop && (isalnum(*in) || *in == '-' || *in == '_')) {
            if (isdigit(*in)) {
                /* This check is a quick and incorrect fix for integer overflow
                 * in oss-fuzz but we don't care as it doesn't matter either way */
                if (hashedToken > SHRT_MIN && hashedToken < SHRT_MAX) {
                    hashedToken = hashedToken * 10 - (*in - '0');
                }
            } else {
                hashedToken += *in;
            }
            in++;
        }
        return hashedToken;
    }

    ExtensionsParser(const char *data, size_t length) {
        const char *stop = data + length;
        int token = 1;

        /* Ignore anything before permessage-deflate or x-webkit-deflate-frame */
        for (; token && token != TOK_PERMESSAGE_DEFLATE && token != TOK_X_WEBKIT_DEFLATE_FRAME; token = getToken(data, stop));

        /* What protocol are we going to use? */
        perMessageDeflate = (token == TOK_PERMESSAGE_DEFLATE);
        xWebKitDeflateFrame = (token == TOK_X_WEBKIT_DEFLATE_FRAME);

        while ((token = getToken(data, stop))) {
            switch (token) {
            case TOK_X_WEBKIT_DEFLATE_FRAME:
                /* Duplicates not allowed/supported */
                return;
            case TOK_NO_CONTEXT_TAKEOVER:
                noContextTakeover = true;
                break;
            case TOK_MAX_WINDOW_BITS:
                maxWindowBits = 1;
                lastInteger = &maxWindowBits;
                break;
            case TOK_PERMESSAGE_DEFLATE:
                /* Duplicates not allowed/supported */
                return;
            case TOK_SERVER_NO_CONTEXT_TAKEOVER:
                serverNoContextTakeover = true;
                break;
            case TOK_CLIENT_NO_CONTEXT_TAKEOVER:
                clientNoContextTakeover = true;
                break;
            case TOK_SERVER_MAX_WINDOW_BITS:
                serverMaxWindowBits = 1;
                lastInteger = &serverMaxWindowBits;
                break;
            case TOK_CLIENT_MAX_WINDOW_BITS:
                clientMaxWindowBits = 1;
                lastInteger = &clientMaxWindowBits;
                break;
            default:
                if (token < 0 && lastInteger) {
                    *lastInteger = -token;
                }
                break;
            }
        }
    }
};

/* Takes what we (the server) wants, returns what we got */
static inline std::tuple<bool, int, int, std::string_view> negotiateCompression(bool wantCompression, int wantedCompressionWindow, int wantedInflationWindow, std::string_view offer) {

    /* If we don't want compression then we are done here */
    if (!wantCompression) {
        return {false, 0, 0, ""};
    }

    ExtensionsParser ep(offer.data(), offer.length());

    static thread_local std::string response;
    response = "";

    int compressionWindow = wantedCompressionWindow;
    int inflationWindow = wantedInflationWindow;
    bool compression = false;

    if (ep.xWebKitDeflateFrame) {
        /* We now have compression */
        compression = true;
        response = "x-webkit-deflate-frame";

        /* If the other peer has DEMANDED us no sliding window,
         * we cannot compress with anything other than shared compressor */
        if (ep.noContextTakeover) {
            /* We must fail here right now (fix pub/sub) */
#ifndef UWS_ALLOW_SHARED_AND_DEDICATED_COMPRESSOR_MIX
            if (wantedCompressionWindow != 0) {
                return {false, 0, 0, ""};
            }
#endif

            compressionWindow = 0;
        }

        /* If the other peer has DEMANDED us to use a limited sliding window,
         * we have to limit out compression sliding window */
        if (ep.maxWindowBits && ep.maxWindowBits < compressionWindow) {
            compressionWindow = ep.maxWindowBits;
#ifndef UWS_ALLOW_8_WINDOW_BITS
            /* We cannot really deny this, so we have to disable compression in this case */
            if (compressionWindow == 8) {
                return {false, 0, 0, ""};
            }
#endif
        }

        /* We decide our own inflation sliding window (and their compression sliding window) */
        if (wantedInflationWindow < 15) {
            if (!wantedInflationWindow) {
                response += "; no_context_takeover";
            } else {
                response += "; max_window_bits=" + std::to_string(wantedInflationWindow);
            }
        }
    } else if (ep.perMessageDeflate) {
        /* We now have compression */
        compression = true;
        response = "permessage-deflate";

        if (ep.clientNoContextTakeover) {
            inflationWindow = 0;
        } else if (ep.clientMaxWindowBits && ep.clientMaxWindowBits != 1) {
            inflationWindow = std::min<int>(ep.clientMaxWindowBits, inflationWindow);
        }

        /* Whatever we have now, write */
        if (inflationWindow < 15) {
            if (!inflationWindow || !ep.clientMaxWindowBits) {
                response += "; client_no_context_takeover";
                inflationWindow = 0;
            } else {
                response += "; client_max_window_bits=" + std::to_string(inflationWindow);
            }
        }

        /* This block basically lets the client lower it */
        if (ep.serverNoContextTakeover) {
        /* This is an important (temporary) fix since we haven't allowed
         * these two modes to mix, and pub/sub will not handle this case (yet) */
#ifdef UWS_ALLOW_SHARED_AND_DEDICATED_COMPRESSOR_MIX
            compressionWindow = 0;
#endif
        } else if (ep.serverMaxWindowBits) {
            compressionWindow = std::min<int>(ep.serverMaxWindowBits, compressionWindow);
#ifndef UWS_ALLOW_8_WINDOW_BITS
            /* Zlib cannot do windowBits=8, memLevel=1 so we raise it up to 9 minimum */
            if (compressionWindow == 8) {
                compressionWindow = 9;
            }
#endif
        }

        /* Whatever we have now, write */
        if (compressionWindow < 15) {
            if (!compressionWindow) {
                response += "; server_no_context_takeover";
            } else {
                response += "; server_max_window_bits=" + std::to_string(compressionWindow);
            }
        }
    }

    /* A final sanity check (this check does not actually catch too high values!) */
    if ((compressionWindow && compressionWindow < 8) || compressionWindow > 15 || (inflationWindow && inflationWindow < 8) || inflationWindow > 15) {
        return {false, 0, 0, ""};
    }

    return {compression, compressionWindow, inflationWindow, response};
}

}

#endif // UWS_WEBSOCKETEXTENSIONS_H

```

`src/WebSocketHandshake.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

#ifndef UWS_WEBSOCKETHANDSHAKE_H
#define UWS_WEBSOCKETHANDSHAKE_H

#include <cstdint>
#include <cstddef>

namespace uWS {

struct WebSocketHandshake {
    template <int N, typename T>
    struct static_for {
        void operator()(uint32_t *a, uint32_t *b) {
            static_for<N - 1, T>()(a, b);
            T::template f<N - 1>(a, b);
        }
    };

    template <typename T>
    struct static_for<0, T> {
        void operator()(uint32_t */*a*/, uint32_t */*hash*/) {}
    };

    static inline uint32_t rol(uint32_t value, size_t bits) {return (value << bits) | (value >> (32 - bits));}
    static inline uint32_t blk(uint32_t b[16], size_t i) {
        return rol(b[(i + 13) & 15] ^ b[(i + 8) & 15] ^ b[(i + 2) & 15] ^ b[i], 1);
    }

    struct Sha1Loop1 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            a[i % 5] += ((a[(3 + i) % 5] & (a[(2 + i) % 5] ^ a[(1 + i) % 5])) ^ a[(1 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(4 + i) % 5], 5);
            a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
        }
    };
    struct Sha1Loop2 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            b[i] = blk(b, i);
            a[(1 + i) % 5] += ((a[(4 + i) % 5] & (a[(3 + i) % 5] ^ a[(2 + i) % 5])) ^ a[(2 + i) % 5]) + b[i] + 0x5a827999 + rol(a[(5 + i) % 5], 5);
            a[(4 + i) % 5] = rol(a[(4 + i) % 5], 30);
        }
    };
    struct Sha1Loop3 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            b[(i + 4) % 16] = blk(b, (i + 4) % 16);
            a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 4) % 16] + 0x6ed9eba1 + rol(a[(4 + i) % 5], 5);
            a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
        }
    };
    struct Sha1Loop4 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            b[(i + 8) % 16] = blk(b, (i + 8) % 16);
            a[i % 5] += (((a[(3 + i) % 5] | a[(2 + i) % 5]) & a[(1 + i) % 5]) | (a[(3 + i) % 5] & a[(2 + i) % 5])) + b[(i + 8) % 16] + 0x8f1bbcdc + rol(a[(4 + i) % 5], 5);
            a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
        }
    };
    struct Sha1Loop5 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            b[(i + 12) % 16] = blk(b, (i + 12) % 16);
            a[i % 5] += (a[(3 + i) % 5] ^ a[(2 + i) % 5] ^ a[(1 + i) % 5]) + b[(i + 12) % 16] + 0xca62c1d6 + rol(a[(4 + i) % 5], 5);
            a[(3 + i) % 5] = rol(a[(3 + i) % 5], 30);
        }
    };
    struct Sha1Loop6 {
        template <int i>
        static inline void f(uint32_t *a, uint32_t *b) {
            b[i] += a[4 - i];
        }
    };

    static inline void sha1(uint32_t hash[5], uint32_t b[16]) {
        uint32_t a[5] = {hash[4], hash[3], hash[2], hash[1], hash[0]};
        static_for<16, Sha1Loop1>()(a, b);
        static_for<4, Sha1Loop2>()(a, b);
        static_for<20, Sha1Loop3>()(a, b);
        static_for<20, Sha1Loop4>()(a, b);
        static_for<20, Sha1Loop5>()(a, b);
        static_for<5, Sha1Loop6>()(a, hash);
    }

    static inline void base64(unsigned char *src, char *dst) {
        const char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (int i = 0; i < 18; i += 3) {
            *dst++ = b64[(src[i] >> 2) & 63];
            *dst++ = b64[((src[i] & 3) << 4) | ((src[i + 1] & 240) >> 4)];
            *dst++ = b64[((src[i + 1] & 15) << 2) | ((src[i + 2] & 192) >> 6)];
            *dst++ = b64[src[i + 2] & 63];
        }
        *dst++ = b64[(src[18] >> 2) & 63];
        *dst++ = b64[((src[18] & 3) << 4) | ((src[19] & 240) >> 4)];
        *dst++ = b64[((src[19] & 15) << 2)];
        *dst++ = '=';
    }

public:
    static inline void generate(const char input[24], char output[28]) {
        uint32_t b_output[5] = {
            0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0
        };
        uint32_t b_input[16] = {
            0, 0, 0, 0, 0, 0, 0x32353845, 0x41464135, 0x2d453931, 0x342d3437, 0x44412d39,
            0x3543412d, 0x43354142, 0x30444338, 0x35423131, 0x80000000
        };

        for (int i = 0; i < 6; i++) {
            b_input[i] = (uint32_t) ((input[4 * i + 3] & 0xff) | (input[4 * i + 2] & 0xff) << 8 | (input[4 * i + 1] & 0xff) << 16 | (input[4 * i + 0] & 0xff) << 24);
        }
        sha1(b_output, b_input);
        uint32_t last_b[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 480};
        sha1(b_output, last_b);
        for (int i = 0; i < 5; i++) {
            uint32_t tmp = b_output[i];
            char *bytes = (char *) &b_output[i];
            bytes[3] = (char) (tmp & 0xff);
            bytes[2] = (char) ((tmp >> 8) & 0xff);
            bytes[1] = (char) ((tmp >> 16) & 0xff);
            bytes[0] = (char) ((tmp >> 24) & 0xff);
        }
        base64((unsigned char *) b_output, output);
    }
};

}

#endif // UWS_WEBSOCKETHANDSHAKE_H

```

`src/WebSocketProtocol.h`:

```h
/*
 * Authored by Alex Hultman, 2018-2020.
 * Intellectual property of third-party.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef UWS_WEBSOCKETPROTOCOL_H
#define UWS_WEBSOCKETPROTOCOL_H

#include <libusockets.h>

#include <cstdint>
#include <cstring>
#include <cstdlib>
#include <string_view>

#ifdef UWS_USE_SIMDUTF
  #include <simdutf.h>
#endif

namespace uWS {

/* We should not overcomplicate these */
constexpr std::string_view ERR_TOO_BIG_MESSAGE("Received too big message");
constexpr std::string_view ERR_WEBSOCKET_TIMEOUT("WebSocket timed out from inactivity");
constexpr std::string_view ERR_INVALID_TEXT("Received invalid UTF-8");
constexpr std::string_view ERR_TOO_BIG_MESSAGE_INFLATION("Received too big message, or other inflation error");
constexpr std::string_view ERR_INVALID_CLOSE_PAYLOAD("Received invalid close payload");
constexpr std::string_view ERR_PROTOCOL("Received invalid WebSocket frame");
constexpr std::string_view ERR_TCP_FIN("Received TCP FIN before WebSocket close frame");

enum OpCode : unsigned char {
    CONTINUATION = 0,
    TEXT = 1,
    BINARY = 2,
    CLOSE = 8,
    PING = 9,
    PONG = 10
};

enum {
    CLIENT,
    SERVER
};

// 24 bytes perfectly
template <bool isServer>
struct WebSocketState {
public:
    static const unsigned int SHORT_MESSAGE_HEADER = isServer ? 6 : 2;
    static const unsigned int MEDIUM_MESSAGE_HEADER = isServer ? 8 : 4;
    static const unsigned int LONG_MESSAGE_HEADER = isServer ? 14 : 10;

    // 16 bytes
    struct State {
        unsigned int wantsHead : 1;
        unsigned int spillLength : 4;
        signed int opStack : 2; // -1, 0, 1
        unsigned int lastFin : 1;

        // 15 bytes
        unsigned char spill[LONG_MESSAGE_HEADER - 1];
        OpCode opCode[2];

        State() {
            wantsHead = true;
            spillLength = 0;
            opStack = -1;
            lastFin = true;
        }

    } state;

    // 8 bytes
    unsigned int remainingBytes = 0;
    char mask[isServer ? 4 : 1];
};

namespace protocol {

template <typename T>
T bit_cast(char *c) {
    T val;
    memcpy(&val, c, sizeof(T));
    return val;
}

/* Byte swap for little-endian systems */
template <typename T>
T cond_byte_swap(T value) {
    static_assert(std::is_trivially_copyable<T>::value, "T must be trivially copyable");
    uint32_t endian_test = 1;
    if (*reinterpret_cast<char*>(&endian_test)) {
        uint8_t src[sizeof(T)];
        uint8_t dst[sizeof(T)];

        std::memcpy(src, &value, sizeof(T));
        for (size_t i = 0; i < sizeof(T); ++i) {
            dst[i] = src[sizeof(T) - 1 - i];
        }

        T result;
        std::memcpy(&result, dst, sizeof(T));
        return result;
    }
    return value;
}

#ifdef UWS_USE_SIMDUTF

static bool isValidUtf8(unsigned char *s, size_t length)
{
    return simdutf::validate_utf8((const char *)s, length);
}

#else
// Based on utf8_check.c by Markus Kuhn, 2005
// https://www.cl.cam.ac.uk/~mgk25/ucs/utf8_check.c
// Optimized for predominantly 7-bit content by Alex Hultman, 2016
// Licensed as Zlib, like the rest of this project
// This runs about 40% faster than simdutf with g++ -mavx
static bool isValidUtf8(unsigned char *s, size_t length)
{
    for (unsigned char *e = s + length; s != e; ) {
        if (s + 16 <= e) {
            uint64_t tmp[2];
            memcpy(tmp, s, 16);
            if (((tmp[0] & 0x8080808080808080) | (tmp[1] & 0x8080808080808080)) == 0) {
                s += 16;
                continue;
            }
        }

        while (!(*s & 0x80)) {
            if (++s == e) {
                return true;
            }
        }

        if ((s[0] & 0x60) == 0x40) {
            if (s + 1 >= e || (s[1] & 0xc0) != 0x80 || (s[0] & 0xfe) == 0xc0) {
                return false;
            }
            s += 2;
        } else if ((s[0] & 0xf0) == 0xe0) {
            if (s + 2 >= e || (s[1] & 0xc0) != 0x80 || (s[2] & 0xc0) != 0x80 ||
                    (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) || (s[0] == 0xed && (s[1] & 0xe0) == 0xa0)) {
                return false;
            }
            s += 3;
        } else if ((s[0] & 0xf8) == 0xf0) {
            if (s + 3 >= e || (s[1] & 0xc0) != 0x80 || (s[2] & 0xc0) != 0x80 || (s[3] & 0xc0) != 0x80 ||
                    (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) || (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4) {
                return false;
            }
            s += 4;
        } else {
            return false;
        }
    }
    return true;
}

#endif

struct CloseFrame {
    uint16_t code;
    char *message;
    size_t length;
};

static inline CloseFrame parseClosePayload(char *src, size_t length) {
    /* If we get no code or message, default to reporting 1005 no status code present */
    CloseFrame cf = {1005, nullptr, 0};
    if (length >= 2) {
        memcpy(&cf.code, src, 2);
        cf = {cond_byte_swap<uint16_t>(cf.code), src + 2, length - 2};
        if (cf.code < 1000 || cf.code > 4999 || (cf.code > 1011 && cf.code < 4000) ||
            (cf.code >= 1004 && cf.code <= 1006) || !isValidUtf8((unsigned char *) cf.message, cf.length)) {
            /* Even though we got a WebSocket close frame, it in itself is abnormal */
            return {1006, (char *) ERR_INVALID_CLOSE_PAYLOAD.data(), ERR_INVALID_CLOSE_PAYLOAD.length()};
        }
    }
    return cf;
}

static inline size_t formatClosePayload(char *dst, uint16_t code, const char *message, size_t length) {
    /* We could have more strict checks here, but never append code 0 or 1005 or 1006 */
    if (code && code != 1005 && code != 1006) {
        code = cond_byte_swap<uint16_t>(code);
        memcpy(dst, &code, 2);
        /* It is invalid to pass nullptr to memcpy, even though length is 0 */
        if (message) {
            memcpy(dst + 2, message, length);
        }
        return length + 2;
    }
    return 0;
}

static inline size_t messageFrameSize(size_t messageSize) {
    if (messageSize < 126) {
        return 2 + messageSize;
    } else if (messageSize <= UINT16_MAX) {
        return 4 + messageSize;
    }
    return 10 + messageSize;
}

enum {
    SND_CONTINUATION = 1,
    SND_NO_FIN = 2,
    SND_COMPRESSED = 64
};

template <bool isServer>
static inline size_t formatMessage(char *dst, const char *src, size_t length, OpCode opCode, size_t reportedLength, bool compressed, bool fin) {
    size_t messageLength;
    size_t headerLength;
    if (reportedLength < 126) {
        headerLength = 2;
        dst[1] = (char) reportedLength;
    } else if (reportedLength <= UINT16_MAX) {
        headerLength = 4;
        dst[1] = 126;
        uint16_t tmp = cond_byte_swap<uint16_t>((uint16_t) reportedLength);
        memcpy(&dst[2], &tmp, sizeof(uint16_t));
    } else {
        headerLength = 10;
        dst[1] = 127;
        uint64_t tmp = cond_byte_swap<uint64_t>((uint64_t) reportedLength);
        memcpy(&dst[2], &tmp, sizeof(uint64_t));
    }

    dst[0] = (char) ((fin ? 128 : 0) | ((compressed && opCode) ? SND_COMPRESSED : 0) | (char) opCode);

    //printf("%d\n", (int)dst[0]);

    char mask[4];
    if (!isServer) {
        dst[1] |= 0x80;
        uint32_t random = (uint32_t) rand();
        memcpy(mask, &random, 4);
        memcpy(dst + headerLength, &random, 4);
        headerLength += 4;
    }

    messageLength = headerLength + length;
    memcpy(dst + headerLength, src, length);

    if (!isServer) {

        // overwrites up to 3 bytes outside of the given buffer!
        //WebSocketProtocol<isServer>::unmaskInplace(dst + headerLength, dst + headerLength + length, mask);

        // this is not optimal
        char *start = dst + headerLength;
        char *stop = start + length;
        int i = 0;
        while (start != stop) {
            (*start++) ^= mask[i++ % 4];
        }
    }
    return messageLength;
}

}

// essentially this is only a parser
template <const bool isServer, typename Impl>
struct WebSocketProtocol {
public:
    static const unsigned int SHORT_MESSAGE_HEADER = isServer ? 6 : 2;
    static const unsigned int MEDIUM_MESSAGE_HEADER = isServer ? 8 : 4;
    static const unsigned int LONG_MESSAGE_HEADER = isServer ? 14 : 10;

protected:
    static inline bool isFin(char *frame) {return *((unsigned char *) frame) & 128;}
    static inline unsigned char getOpCode(char *frame) {return *((unsigned char *) frame) & 15;}
    static inline unsigned char payloadLength(char *frame) {return ((unsigned char *) frame)[1] & 127;}
    static inline bool rsv23(char *frame) {return *((unsigned char *) frame) & 48;}
    static inline bool rsv1(char *frame) {return *((unsigned char *) frame) & 64;}

    template <int N>
    static inline void UnrolledXor(char * __restrict data, char * __restrict mask) {
        if constexpr (N != 1) {
            UnrolledXor<N - 1>(data, mask);
        }
        data[N - 1] ^= mask[(N - 1) % 4];
    }

    template <int DESTINATION>
    static inline void unmaskImprecise8(char *src, uint64_t mask, unsigned int length) {
        for (unsigned int n = (length >> 3) + 1; n; n--) {
            uint64_t loaded;
            memcpy(&loaded, src, 8);
            loaded ^= mask;
            memcpy(src - DESTINATION, &loaded, 8);
            src += 8;
        }
    }

    /* DESTINATION = 6 makes this not SIMD, DESTINATION = 4 is with SIMD but we don't want that for short messages */
    template <int DESTINATION>
    static inline void unmaskImprecise4(char *src, uint32_t mask, unsigned int length) {
        for (unsigned int n = (length >> 2) + 1; n; n--) {
            uint32_t loaded;
            memcpy(&loaded, src, 4);
            loaded ^= mask;
            memcpy(src - DESTINATION, &loaded, 4);
            src += 4;
        }
    }

    template <int HEADER_SIZE>
    static inline void unmaskImpreciseCopyMask(char *src, unsigned int length) {
        if constexpr (HEADER_SIZE != 6) {
            char mask[8] = {src[-4], src[-3], src[-2], src[-1], src[-4], src[-3], src[-2], src[-1]};
            uint64_t maskInt;
            memcpy(&maskInt, mask, 8);
            unmaskImprecise8<HEADER_SIZE>(src, maskInt, length);
        } else {
            char mask[4] = {src[-4], src[-3], src[-2], src[-1]};
            uint32_t maskInt;
            memcpy(&maskInt, mask, 4);
            unmaskImprecise4<HEADER_SIZE>(src, maskInt, length);
        }
    }

    static inline void rotateMask(unsigned int offset, char *mask) {
        char originalMask[4] = {mask[0], mask[1], mask[2], mask[3]};
        mask[(0 + offset) % 4] = originalMask[0];
        mask[(1 + offset) % 4] = originalMask[1];
        mask[(2 + offset) % 4] = originalMask[2];
        mask[(3 + offset) % 4] = originalMask[3];
    }

    static inline void unmaskInplace(char *data, char *stop, char *mask) {
        while (data < stop) {
            *(data++) ^= mask[0];
            *(data++) ^= mask[1];
            *(data++) ^= mask[2];
            *(data++) ^= mask[3];
        }
    }

    template <unsigned int MESSAGE_HEADER, typename T>
    static inline bool consumeMessage(T payLength, char *&src, unsigned int &length, WebSocketState<isServer> *wState, void *user) {
        if (getOpCode(src)) {
            if (wState->state.opStack == 1 || (!wState->state.lastFin && getOpCode(src) < 2)) {
                Impl::forceClose(wState, user, ERR_PROTOCOL);
                return true;
            }
            wState->state.opCode[++wState->state.opStack] = (OpCode) getOpCode(src);
        } else if (wState->state.opStack == -1) {
            Impl::forceClose(wState, user, ERR_PROTOCOL);
            return true;
        }
        wState->state.lastFin = isFin(src);

        if (Impl::refusePayloadLength(payLength, wState, user)) {
            Impl::forceClose(wState, user, ERR_TOO_BIG_MESSAGE);
            return true;
        }

        if (payLength + MESSAGE_HEADER <= length) {
            bool fin = isFin(src);
            if (isServer) {
                /* This guy can never be assumed to be perfectly aligned since we can get multiple messages in one read */
                unmaskImpreciseCopyMask<MESSAGE_HEADER>(src + MESSAGE_HEADER, (unsigned int) payLength);
                if (Impl::handleFragment(src, payLength, 0, wState->state.opCode[wState->state.opStack], fin, wState, user)) {
                    return true;
                }
            } else {
                if (Impl::handleFragment(src + MESSAGE_HEADER, payLength, 0, wState->state.opCode[wState->state.opStack], isFin(src), wState, user)) {
                    return true;
                }
            }

            if (fin) {
                wState->state.opStack--;
            }

            src += payLength + MESSAGE_HEADER;
            length -= (unsigned int) (payLength + MESSAGE_HEADER);
            wState->state.spillLength = 0;
            return false;
        } else {
            wState->state.spillLength = 0;
            wState->state.wantsHead = false;
            wState->remainingBytes = (unsigned int) (payLength - length + MESSAGE_HEADER);
            bool fin = isFin(src);
            if constexpr (isServer) {
                memcpy(wState->mask, src + MESSAGE_HEADER - 4, 4);
                uint64_t mask;
                memcpy(&mask, src + MESSAGE_HEADER - 4, 4);
                memcpy(((char *)&mask) + 4, src + MESSAGE_HEADER - 4, 4);
                unmaskImprecise8<0>(src + MESSAGE_HEADER, mask, length);
                rotateMask(4 - (length - MESSAGE_HEADER) % 4, wState->mask);
            }
            Impl::handleFragment(src + MESSAGE_HEADER, length - MESSAGE_HEADER, wState->remainingBytes, wState->state.opCode[wState->state.opStack], fin, wState, user);
            return true;
        }
    }

    /* This one is nicely vectorized on both ARM64 and X64 - especially with -mavx */
    static inline void unmaskAll(char * __restrict data, char * __restrict mask) {
        for (int i = 0; i < LIBUS_RECV_BUFFER_LENGTH; i += 16) {
            UnrolledXor<16>(data + i, mask);
        }
    }

    static inline bool consumeContinuation(char *&src, unsigned int &length, WebSocketState<isServer> *wState, void *user) {
        if (wState->remainingBytes <= length) {
            if (isServer) {
                unsigned int n = wState->remainingBytes >> 2;
                unmaskInplace(src, src + n * 4, wState->mask);
                for (unsigned int i = 0, s = wState->remainingBytes % 4; i < s; i++) {
                    src[n * 4 + i] ^= wState->mask[i];
                }
            }

            if (Impl::handleFragment(src, wState->remainingBytes, 0, wState->state.opCode[wState->state.opStack], wState->state.lastFin, wState, user)) {
                return false;
            }

            if (wState->state.lastFin) {
                wState->state.opStack--;
            }

            src += wState->remainingBytes;
            length -= wState->remainingBytes;
            wState->state.wantsHead = true;
            return true;
        } else {
            if (isServer) {
                /* No need to unmask if mask is 0 */
                uint32_t nullmask = 0;
                if (memcmp(wState->mask, &nullmask, sizeof(uint32_t))) {
                    if /*constexpr*/ (LIBUS_RECV_BUFFER_LENGTH == length) {
                        unmaskAll(src, wState->mask);
                    } else {
                        // Slow path
                        unmaskInplace(src, src + ((length >> 2) + 1) * 4, wState->mask);
                    }
                }
            }

            wState->remainingBytes -= length;
            if (Impl::handleFragment(src, length, wState->remainingBytes, wState->state.opCode[wState->state.opStack], wState->state.lastFin, wState, user)) {
                return false;
            }

            if (isServer && length % 4) {
                rotateMask(4 - (length % 4), wState->mask);
            }
            return false;
        }
    }

public:
    WebSocketProtocol() {

    }

    static inline void consume(char *src, unsigned int length, WebSocketState<isServer> *wState, void *user) {
        if (wState->state.spillLength) {
            src -= wState->state.spillLength;
            length += wState->state.spillLength;
            memcpy(src, wState->state.spill, wState->state.spillLength);
        }
        if (wState->state.wantsHead) {
            parseNext:
            while (length >= SHORT_MESSAGE_HEADER) {

                // invalid reserved bits / invalid opcodes / invalid control frames / set compressed frame
                if ((rsv1(src) && !Impl::setCompressed(wState, user)) || rsv23(src) || (getOpCode(src) > 2 && getOpCode(src) < 8) ||
                    getOpCode(src) > 10 || (getOpCode(src) > 2 && (!isFin(src) || payloadLength(src) > 125))) {
                    Impl::forceClose(wState, user, ERR_PROTOCOL);
                    return;
                }

                if (payloadLength(src) < 126) {
                    if (consumeMessage<SHORT_MESSAGE_HEADER, uint8_t>(payloadLength(src), src, length, wState, user)) {
                        return;
                    }
                } else if (payloadLength(src) == 126) {
                    if (length < MEDIUM_MESSAGE_HEADER) {
                        break;
                    } else if(consumeMessage<MEDIUM_MESSAGE_HEADER, uint16_t>(protocol::cond_byte_swap<uint16_t>(protocol::bit_cast<uint16_t>(src + 2)), src, length, wState, user)) {
                        return;
                    }
                } else if (length < LONG_MESSAGE_HEADER) {
                    break;
                } else if (consumeMessage<LONG_MESSAGE_HEADER, uint64_t>(protocol::cond_byte_swap<uint64_t>(protocol::bit_cast<uint64_t>(src + 2)), src, length, wState, user)) {
                    return;
                }
            }
            if (length) {
                memcpy(wState->state.spill, src, length);
                wState->state.spillLength = length & 0xf;
            }
        } else if (consumeContinuation(src, length, wState, user)) {
            goto parseNext;
        }
    }

    static const int CONSUME_POST_PADDING = 4;
    static const int CONSUME_PRE_PADDING = LONG_MESSAGE_HEADER - 1;
};

}

#endif // UWS_WEBSOCKETPROTOCOL_H

```

`tests/BloomFilter.cpp`:

```cpp
#include "../src/BloomFilter.h"

#include <cassert>
#include <vector>
#include <string>
#include <algorithm>
#include <iostream>

/* From Wikipedia */
std::vector<std::string> commonHeaders = {
    "A-IM",
    "Accept",
    "Accept-Charset",
    "Accept-Datetime",
    "Accept-Encoding",
    "Accept-Language",
    "Access-Control-Request-Method",
    "Access-Control-Request-Headers",
    "Authorization",
    "Cache-Control",
    "Connection",
    "Content-Encoding",
    "Content-Length",
    "Content-MD5",
    "Content-Type",
    "Cookie",
    "Date",
    "Expect",
    "Forwarded",
    "From",
    "Host",
    "HTTP2-Settings",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Max-Forwards",
    "Origin",
    "Pragma",
    "Proxy-Authorization",
    "Range",
    "Referer",
    "TE",
    "Trailer",
    "Transfer-Encoding",
    "User-Agent",
    "Upgrade",
    "Via",
    "Warning",

    /* Put common non-standard ones here */
};

int main() {

    /* Lowercase everything */
    std::transform(commonHeaders.begin(), commonHeaders.end(), commonHeaders.begin(), [](std::string &header) {
        std::transform(header.begin(), header.end(), header.begin(), ::tolower);
        return header;
    });

    uWS::BloomFilter bf;
    unsigned int totalCollisions = 0;

    /* One on one */
    for (int i = 0; i < commonHeaders.size(); i++) {
        bf.reset();
        assert(bf.mightHave(commonHeaders[i]) == false);

        bf.add(commonHeaders[i]);
        assert(bf.mightHave(commonHeaders[i]) == true);

        for (int j = i + 1; j < commonHeaders.size(); j++) {
            if (bf.mightHave(commonHeaders[j])) {
                std::cout << commonHeaders[i] << " collides with " << commonHeaders[j] << std::endl;
                totalCollisions++;
            }
        }
    }

    /* We don't want any direct one-one-one collisions (please) */
    std::cout << "Total collisions: " << totalCollisions << std::endl;
    assert(totalCollisions == 0);

    unsigned int totalFalsePositives = 0;

    /* Add all except the one we test */
    for (int i = 0; i < commonHeaders.size(); i++) {
        bf.reset();

        /* Add all headers but our */
        for (int j = 0; j < commonHeaders.size(); j++) {
            if (j != i) {
                bf.add(commonHeaders[j]);
            }
        }

        /* Do we have false positives? */
        if (bf.mightHave(commonHeaders[i])) {
            std::cout << commonHeaders[i] << " has false positives" << std::endl;
            totalFalsePositives++;
        }
    }

    /* It is totally fine to have a few false positives */
    std::cout << "Total false positives: " << totalFalsePositives << std::endl;
    assert(totalFalsePositives == 0);
}

```

`tests/ChunkedEncoding.cpp`:

```cpp
#include <iostream>
#include <cassert>
#include <sstream>
#include <iomanip>
#include <vector>
#include <climits>

#include "../src/ChunkedEncoding.h"

void consumeChunkEncoding(int maxConsume, std::string_view &chunkEncoded, uint64_t &state) {
    //int maxConsume = 200;

    if (uWS::isParsingChunkedEncoding(state)) {
        std::cout << "already in chunked parsing state!" << std::endl;
        std::abort();
    }

    // this should not break the parser
    state = uWS::STATE_IS_CHUNKED;

    while (chunkEncoded.length()) {

        /* Split up the chunkEncoded string into further chunks for parsing */
        std::string_view data = chunkEncoded.substr(0, std::min<size_t>(maxConsume, chunkEncoded.length()));
        unsigned int data_length_before_parsing = data.length();

        for (auto chunk : uWS::ChunkIterator(&data, &state, true)) {
        }

        /* Only remove that which was consumed */
        chunkEncoded.remove_prefix(data_length_before_parsing - data.length());

        if (state == 0) {

            if (chunkEncoded.length() == 0 || chunkEncoded.length() == 74) {
                break;
            } else {
                std::abort();
            }

            // should be fine
            state = uWS::STATE_IS_CHUNKED;

            //std::cout << "remaining chunk:" << chunkEncoded.length() << std::endl;
            //std::abort();
            //break;
        }

        /* Here we must be in parsingchunked state */
        if (!uWS::isParsingChunkedEncoding(state)) {
            std::cout << "not in parsing chunked strate!" << std::endl;
            std::abort();
        }

    }
}

void runBetterTest(unsigned int maxConsume) {
    /* A list of chunks */
    std::vector<std::string_view> chunks = {
        "Hello there I am the first segment",
        "Why hello there",
        "",
        "I am last?",
        "And I am a little longer but it doesn't matter",
        ""
    };

    /* Encode them in chunked encoding */
    std::stringstream ss;
    for (std::string_view chunk : chunks) {
        /* Generic chunked encoding format */
        ss << std::hex << chunk.length() << "\r\n" << chunk << "\r\n";

        /* Every null chunk is followed by an empty trailer */
        if (chunk.length() == 0) {
            ss << "\r\n";
        }
    }
    std::string buffer = ss.str();
    std::string_view chunkEncoded = buffer;

    uint64_t state = 0;

    if (uWS::isParsingChunkedEncoding(state)) {
        std::abort();
    }
    consumeChunkEncoding(maxConsume, chunkEncoded, state);
    if (state != 0) {
        std::abort();
    }
    consumeChunkEncoding(maxConsume, chunkEncoded, state);
    if (state != 0) {
        std::abort();
    }

    // consumeChunkEncoding(chunkEncoded) - consumes in further chunkes and does isParsingChunked checks
    // assume state == 0 and we still have bytes to parse (we should have consumed EXACTLY right bytes)
    // consumeChunkEncoding(chunkEncoded)
    // assume state == 0 and we have no bytes to consume
}

void runTest(unsigned int maxConsume) {
    /* A list of chunks */
    std::vector<std::string_view> chunks = {
        "Hello there I am the first segment",
        "Why hello there",
        "",
        "I am last?",
        "And I am a little longer but it doesn't matter",
        ""
    };

    /* Encode them in chunked encoding */
    std::stringstream ss;
    for (std::string_view chunk : chunks) {
        /* Generic chunked encoding format */
        ss << std::hex << chunk.length() << "\r\n" << chunk << "\r\n";

        /* Every null chunk is followed by an empty trailer */
        if (chunk.length() == 0) {
            ss << "\r\n";
        }
    }
    std::string buffer = ss.str();

    /* Since we have 2 chunked bodies in our buffer, the parser must stop with state == 0 exactly 2 times */
    unsigned int stoppedWithClearState = 0;
    
    /* Begin with a clear state and the full data */
    uint64_t state = 0;
    unsigned int chunkOffset = 0;
    std::string_view chunkEncoded = buffer;

    // consumeChunkEncoding(chunkEncoded) - consumes in further chunkes and does isParsingChunked checks
    // assume state == 0 and we still have bytes to parse (we should have consumed EXACTLY right bytes)
    // consumeChunkEncoding(chunkEncoded)
    // assume state == 0 and we have no bytes to consume

    // this while should be more like if original size or "is parsing chunked" (which tests the uWS::wantsChunkedParsing(state))
    while (chunkEncoded.length()) {
        /* Parse a small part of the given data */
        std::string_view data = chunkEncoded.substr(0, std::min<size_t>(maxConsume, chunkEncoded.length()));
        

        unsigned int data_length_before_parsing = data.length();
        

        /* Whatever chunk we emit, or part of chunk, it must match the expected one */
        //std::cout << "Calling parser now" << std::endl;
        for (auto chunk : uWS::ChunkIterator(&data, &state, true)) {
            std::cout << "<" << chunk << ">" << std::endl;

            /* Run check here */
            if (!chunk.length() && chunks[chunkOffset].length()) {
                std::cout << "We got emitted an empty chunk but expected a non-empty one" << std::endl;
                std::abort();
            }

            if (chunks[chunkOffset].substr(0, chunk.length()) == chunk /*starts_with(chunk)*/) {
                chunks[chunkOffset].remove_prefix(chunk.length());
                if (!chunks[chunkOffset].length()) {
                    chunkOffset++;
                }
            } else {
                std::cerr << "Chunk does not match! Should be <" << chunks[chunkOffset] << ">" << std::endl;
                std::abort();                
            }
        }

        /* The parser returtned, okay count the times it has state == 0, it should be 2 per the whole buffer always */
        if (state == 0) {
            printf("Parser stopped with no state set!\n");
            stoppedWithClearState++;
        }

        /* Only remove that which was consumed */
        chunkEncoded.remove_prefix(data_length_before_parsing - data.length());
    }

    if (stoppedWithClearState != 2) {
        std::cerr << "Error: The parser stopped with no state " << stoppedWithClearState << " times!" << std::endl;
        std::abort();
    }
}

void testWithoutTrailer() {
    /* A list of chunks */
    std::vector<std::string_view> chunks = {
        "Hello there I am the first segment",
        ""
    };

    /* Encode them in chunked encoding */
    std::stringstream ss;
    for (std::string_view chunk : chunks) {
        /* Generic chunked encoding format */
        ss << std::hex << chunk.length() << "\r\n" << chunk << "\r\n";
    }
    std::string buffer = ss.str();
    std::string_view dataToConsume(buffer.data(), buffer.length());

    uint64_t state = uWS::STATE_IS_CHUNKED;

    for (auto chunk : uWS::ChunkIterator(&dataToConsume, &state)) {

    }

    if (state) {
        std::abort();
    }
}

int main() {

    testWithoutTrailer();

    for (int i = 1; i < 1000; i++) {
        runBetterTest(i);
    }

    for (int i = 1; i < 1000; i++) {
        runTest(i);
    }

    std::cout << "ALL BRUTEFORCE DONE" << std::endl;
}
```

`tests/ExtensionsNegotiator.cpp`:

```cpp
/* This is a temporary fix since we do not support this mode with pub/sub yet */
#define UWS_ALLOW_SHARED_AND_DEDICATED_COMPRESSOR_MIX

/* Zlib bug should not affect testing */
#define UWS_ALLOW_8_WINDOW_BITS

#include "../src/WebSocketExtensions.h"

#include <iostream>

void testNegotiation(bool wantCompression, int wantedCompressionWindow, int wantedInflationWindow, std::string_view offer,
                    bool negCompression, int negCompressionWindow, int negInflationWindow, std::string_view negResponse) {

    auto [compression, compressionWindow, inflationWindow, response] = uWS::negotiateCompression(wantCompression, wantedCompressionWindow, wantedInflationWindow, offer);

    if (compression == negCompression && compressionWindow == negCompressionWindow && inflationWindow == negInflationWindow && response == negResponse) {
        std::cout << "PASS" << std::endl;
    } else {
        std::cout << "FAIL: <" << response << "> is not expected <" << negResponse << ">" << std::endl;
    }

}

int main() {

    /* Both parties must indicate compression for it to negotiate */
    testNegotiation(false, 15, 15, "permessage-deflate", false, 0, 0, "");
    testNegotiation(false, 15, 15, "x-webkit-deflate-frame", false, 0, 0, "");
    testNegotiation(true, 15, 15, "", false, 15, 15, "");
    testNegotiation(true, 15, 15, "", false, 15, 15, "");

    /* client_max_window_bits can only be used if the client indicates support */
    testNegotiation(true, 15, 11, "permessage-deflate; ", true, 15, 0, "permessage-deflate; client_no_context_takeover");
    testNegotiation(true, 15, 0, "permessage-deflate; ", true, 15, 0, "permessage-deflate; client_no_context_takeover");
    testNegotiation(true, 15, 11, "permessage-deflate; client_max_window_bits=14", true, 15, 11, "permessage-deflate; client_max_window_bits=11");
    testNegotiation(true, 15, 11, "permessage-deflate; client_max_window_bits=9", true, 15, 9, "permessage-deflate; client_max_window_bits=9");

    /* server_max_window_bits can always be used */
    testNegotiation(true, 0, 15, "permessage-deflate; ", true, 0, 15, "permessage-deflate; server_no_context_takeover");
    testNegotiation(true, 8, 15, "permessage-deflate; ", true, 8, 15, "permessage-deflate; server_max_window_bits=8");
    testNegotiation(true, 15, 15, "permessage-deflate; server_max_window_bits=8", true, 8, 15, "permessage-deflate; server_max_window_bits=8");
    testNegotiation(true, 11, 15, "permessage-deflate; server_max_window_bits=14", true, 11, 15, "permessage-deflate; server_max_window_bits=11");

    /* x-webkit-deflate-frame has no particular rules */
    testNegotiation(true, 11, 15, "x-webkit-deflate-frame; no_context_takeover; max_window_bits=8", true, 0, 15, "x-webkit-deflate-frame");
    testNegotiation(true, 11, 12, "x-webkit-deflate-frame; no_context_takeover; max_window_bits=8", true, 0, 12, "x-webkit-deflate-frame; max_window_bits=12");
    testNegotiation(true, 11, 12, "x-webkit-deflate-frame; max_window_bits=8", true, 8, 12, "x-webkit-deflate-frame; max_window_bits=12");
    testNegotiation(true, 15, 0, "x-webkit-deflate-frame; max_window_bits=15", true, 15, 0, "x-webkit-deflate-frame; no_context_takeover");

    /* Defaults */
    testNegotiation(true, 15, 15, "x-webkit-deflate-frame", true, 15, 15, "x-webkit-deflate-frame");
    testNegotiation(true, 15, 15, "permessage-deflate", true, 15, 15, "permessage-deflate");

    /* Fail on invalid values */
    testNegotiation(true, 15, 15, "x-webkit-deflate-frame; max_window_bits=3", false, 0, 0, "");
    /* This one doesn't fail, but at least ignores the too high value */
    testNegotiation(true, 15, 15, "x-webkit-deflate-frame; max_window_bits=16", true, 15, 15, "x-webkit-deflate-frame");

    testNegotiation(true, 15, 15, "permessage-deflate; server_max_window_bits=3", false, 0, 0, "");
    testNegotiation(true, 15, 15, "permessage-deflate; client_max_window_bits=3", false, 0, 0, "");

    /* Same here; these won't fail but just be ignored */
    testNegotiation(true, 15, 15, "permessage-deflate; server_max_window_bits=17", true, 15, 15, "permessage-deflate");
    testNegotiation(true, 15, 15, "permessage-deflate; client_max_window_bits=17", true, 15, 15, "permessage-deflate");

    std::cout << "ALL PASS" << std::endl;
}
```

`tests/HttpParser.cpp`:

```cpp
#include <iostream>
#include <cassert>

#include "../src/HttpParser.h"

int main() {
    /* Parser needs at least 8 bytes post padding */
    unsigned char data[] = {0x47, 0x45, 0x54, 0x20, 0x2f, 0x20, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31, 0x2e, 0x31, 0xd, 0xa, 0x61, 0x73, 0x63, 0x69, 0x69, 0x3a, 0x20, 0x74, 0x65, 0x73, 0x74, 0xd, 0xa, 0x75, 0x74, 0x66, 0x38, 0x3a, 0x20, 0xd1, 0x82, 0xd0, 0xb5, 0xd1, 0x81, 0xd1, 0x82, 0xd, 0xa, 0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20, 0x31, 0x32, 0x37, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0xd, 0xa, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0xd, 0xa, 0xd, 0xa, 'E', 'E', 'E', 'E', 'E', 'E', 'E', 'E'};
    int size = sizeof(data) - 8;
    void *user = nullptr;
    void *reserved = nullptr;

    uWS::HttpParser httpParser;

    auto [err, returnedUser] = httpParser.consumePostPadded((char *) data, size, user, reserved, [reserved](void *s, uWS::HttpRequest *httpRequest) -> void * {

        std::cout << httpRequest->getMethod() << std::endl;

        for (auto [key, value] : *httpRequest) {
            std::cout << key << ": " << value << std::endl;
        }

        /* Since we did proper whitespace trimming this thing is there, but empty */
        assert(httpRequest->getHeader("utf8").data());

        /* Return ok */
        return s;

    }, [](void *user, std::string_view data, bool fin) -> void * {

        /* Return ok */
        return user;

    });

    std::cout << "HTTP DONE" << std::endl;

}
```

`tests/HttpRouter.cpp`:

```cpp
#include "../src/HttpRouter.h"

#include <cassert>
#include <iostream>

void testMethodPriority() {
    std::cout << "TestMethodPriority" << std::endl;
    uWS::HttpRouter<int> r;
    std::string result;

    r.add({"*"}, "/static/route", [&result](auto *) {
        std::cout << "ANY static route" << std::endl;
        result += "AS";
        return true;
    }, r.LOW_PRIORITY);

    r.add({"PATCH"}, "/static/route", [&result](auto *) {
        std::cout << "PATCH static route" << std::endl;
        result += "PS";
        return false;
    });

    r.add({"GET"}, "/static/route", [&result](auto *) {
        std::cout << "GET static route" << std::endl;
        result += "GS";
        return true;
    });

    assert(r.route("nonsense", "/static/route") == true);
    assert(r.route("GET", "/static") == false);
    assert(result == "AS");

    /* Should end up directly in ANY handler */
    result.clear();
    assert(r.route("POST", "/static/route"));
    assert(result == "AS");

    /* Should up directly in GET handler */
    result.clear();
    assert(r.route("GET", "/static/route"));
    assert(result == "GS");

    /* Should end up in PATCH then in ANY handler */
    result.clear();
    assert(r.route("PATCH", "/static/route"));
    assert(result == "PSAS");
}

void testDeepParameterRoutes() {
    std::cout << "TestDeepParameterRoutes" << std::endl;
    uWS::HttpRouter<int> r;
    std::string result;

    r.add({"GET"}, "/something/:id/sync", [&result](auto *h) {
        result += "ETT";
        return false;
    });

    r.add({"GET"}, "/something/:somethingId/pin", [&result](auto *h) {
        result += "TVÅ";
        return false;
    });

    r.add({"GET"}, "/something/:id/:attribute", [&result](auto *h) {
        result += "TRE";
        return false;
    });

    assert(r.route("GET", "/something/1234/pin") == false);
    assert(result == "TVÅTRE");

    result.clear();
    assert(r.route("GET", "/something/1234/sync") == false);
    assert(result == "ETTTRE");
}

void testPatternPriority() {
    std::cout << "TestPatternPriority" << std::endl;
    uWS::HttpRouter<int> r;
    std::string result;

    r.add({"*"}, "/a/b/c", [&result](auto *) {
        std::cout << "ANY static route" << std::endl;
        result += "AS";
        return false;
    }, r.LOW_PRIORITY);

    r.add({"GET"}, "/a/:b/c", [&result](auto *) {
        std::cout << "GET parameter route" << std::endl;
        result += "GP";
        return false;
    });

    r.add({"GET"}, "/a/*", [&result](auto *) {
        std::cout << "GET wildcard route" << std::endl;
        result += "GW";
        return false;
    });

    r.add({"GET"}, "/a/b/c", [&result](auto *) {
        std::cout << "GET static route" << std::endl;
        result += "GS";
        return false;
    });

    r.add({"POST"}, "/a/:b/c", [&result](auto *) {
        std::cout << "POST parameter route" << std::endl;
        result += "PP";
        return false;
    });

    r.add({"*"}, "/a/:b/c", [&result](auto *) {
        std::cout << "ANY parameter route" << std::endl;
        result += "AP";
        return false;
    }, r.LOW_PRIORITY);

    assert(r.route("POST", "/a/b/c") == false);
    assert(result == "PPASAP");

    result.clear();
    assert(r.route("GET", "/a/b/c") == false);
    assert(result == "GSGPGWASAP");
}

void testUpgrade() {
    std::cout << "TestUpgrade" << std::endl;
    uWS::HttpRouter<int> r;
    std::string result;

    /* HTTP on / */
    r.add({"GET"}, "/something", [&result](auto *) {
        result += "GS";
        return true;
    }, r.MEDIUM_PRIORITY);

    /* HTTP on /* */
    r.add({"GET"}, "/*", [&result](auto *) {
        result += "GW";
        return false;
    }, r.MEDIUM_PRIORITY);

    /* WebSockets on /* */
    r.add({"GET"}, "/*", [&result](auto *) {
        result += "WW";
        return false;
    }, r.HIGH_PRIORITY);

    assert(r.route("GET", "/something"));
    assert(result == "WWGS");
    result.clear();

    assert(r.route("GET", "/") == false);
    assert(result == "WWGW");
}

void testBugReports() {
    std::cout << "TestBugReports" << std::endl;
    {
        uWS::HttpRouter<int> r;
        std::string result;

        r.add({"GET"}, "/route", [&result](auto *) {
            result += "ROUTE";
            return true;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/route/:id", [&result](auto *) {
            result += "ROUID";
            return true;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/route/21");
        assert(result == "ROUID");

        result = "";
        r.route("GET", "/route");
        assert(result == "ROUTE");

        result = "";
        r.remove("GET", "/route", r.MEDIUM_PRIORITY);
        r.route("GET", "/route");
        assert(result == "");

        std::cout << "TRYING TO DELETE /route/:id" << std::endl;
        bool found = r.remove("GET", "/route/:id", r.MEDIUM_PRIORITY);
        std::cout << "Found:" << found << std::endl;

        /* The bug is really only this line, it does not remove parameter routes */
        r.route("GET", "/route/21");
        std::cout << "Found:" << found << ", " << result << std::endl;
        assert(result == "");
    }
    {
        uWS::HttpRouter<int> r;
        std::string result;

        r.add({"GET"}, "/foo//////bar/baz/qux", [&result](auto *) {
            result += "MANYSLASH";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/foo", [&result](auto *) {
            result += "FOO";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/foo");
        r.route("GET", "/foo/");
        r.route("GET", "/foo//bar/baz/qux");
        r.route("GET", "/foo//////bar/baz/qux");
        assert(result == "FOOMANYSLASH");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        r.add({"GET"}, "/test/*", [&result](auto *) {
            result += "TEST";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/test/");
        assert(result == "TEST");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        /* WS on /* */
        r.add({"GET"}, "/*", [&result](auto *) {
            result += "WW";
            return false;
        }, r.HIGH_PRIORITY);

        /* HTTP on /ok */
        r.add({"GET"}, "/ok", [&result](auto *) {
            result += "GS";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/*", [&result](auto *) {
            result += "GW";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/ok");
        assert(result == "WWGSGW");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        /* WS on / */
        r.add({"GET"}, "/", [&result](auto *) {
            result += "WS";
            return false;
        }, r.HIGH_PRIORITY);

        /* HTTP on / */
        r.add({"GET"}, "/", [&result](auto *) {
            result += "GS";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/");
        assert(result == "WSGS");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        /* WS on /* */
        r.add({"GET"}, "/*", [&result](auto *) {
            result += "WW";
            return false;
        }, r.HIGH_PRIORITY);

        /* GET on /static */
        r.add({"GET"}, "/static", [&result](auto *) {
            result += "GSL";
            return false;
        }, r.MEDIUM_PRIORITY);

        /* ANY on /* */
        r.add({"*"}, "/*", [&result](auto *) {
            result += "AW";
            return false;
        }, r.LOW_PRIORITY);

        r.route("GET", "/static");
        assert(result == "WWGSLAW");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        /* WS on /* */
        r.add({"GET"}, "/*", [&result](auto *) {
            result += "WW";
            return false;
        }, r.HIGH_PRIORITY);

        /* GET on / */
        r.add({"GET"}, "/", [&result](auto *) {
            result += "GSS";
            return false;
        }, r.MEDIUM_PRIORITY);

        /* GET on /static */
        r.add({"GET"}, "/static", [&result](auto *) {
            result += "GSL";
            return false;
        }, r.MEDIUM_PRIORITY);

        /* ANY on /* */
        r.add({"*"}, "/*", [&result](auto *) {
            result += "AW";
            return false;
        }, r.LOW_PRIORITY);

        r.route("GET", "/static");
        assert(result == "WWGSLAW");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        r.add({"GET"}, "/foo", [&result](auto *) {
            result += "FOO";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/:id", [&result](auto *) {
            result += "ID";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/1ab", [&result](auto *) {
            result += "ONEAB";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/1ab");
        // this one fails with IDONEAB
        std::cout << result << std::endl;
        assert(result == "ONEABID");
    }

    {
        uWS::HttpRouter<int> r;
        std::string result;

        r.add({"GET"}, "/*", [&result](auto *) {
            result += "STAR";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.add({"GET"}, "/", [&result](auto *) {
            result += "STATIC";
            return false;
        }, r.MEDIUM_PRIORITY);

        r.route("GET", "/");
        std::cout << result << std::endl;
        // this one fails with STARSTATIC
        assert(result == "STATICSTAR");
    }

}

void testParameters() {
    std::cout << "TestParameters" << std::endl;
    uWS::HttpRouter<int> r;
    std::string result;

    r.add({"GET"}, "/candy/:kind/*", [&result](auto *h) {
        auto [paramsTop, params] = h->getParameters();

        assert(paramsTop == 0);
        assert(params[0] == "lollipop");

        result += "GPW";
        return false;
    });

    r.add({"GET"}, "/candy/lollipop/*", [&result](auto *h) {
        auto [paramsTop, params] = h->getParameters();

        assert(paramsTop == -1);

        result += "GLW";
        return false;
    });

    r.add({"GET"}, "/candy/:kind/:action", [&result](auto *h) {
        auto [paramsTop, params] = h->getParameters();

        assert(paramsTop == 1);
        assert(params[0] == "lollipop");
        assert(params[1] == "eat");

        result += "GPP";
        return false;
    });

    r.add({"GET"}, "/candy/lollipop/:action", [&result](auto *h) {
        auto [paramsTop, params] = h->getParameters();

        assert(params[0] == "eat");
        assert(paramsTop == 0);

        result += "GLP";
        return false;
    });

    r.add({"GET"}, "/candy/lollipop/eat", [&result](auto *h) {
        auto [paramsTop, params] = h->getParameters();

        assert(paramsTop == -1);

        result += "GLS";
        return false;
    });

    r.route("GET", "/candy/lollipop/eat");
    assert(result == "GLSGLPGLWGPPGPW");
    result.clear();

    r.route("GET", "/candy/lollipop/");
    r.route("GET", "/candy/lollipop");
    r.route("GET", "/candy/");
    assert(result == "GLWGPW");
}

#include <chrono>

void testPerformance() {
    std::cout << "TestPerformance" << std::endl;
    uWS::HttpRouter<int> r;

    r.add({"GET"}, "/*", [](auto *h) {
        return true;
    });

    r.add({"*"}, "/*", [](auto *h) {
        return true;
    });

    auto start = std::chrono::steady_clock::now();
    for (int i = 0; i < 1000000; i++) {
        r.route("GET", "/something");
        r.route("other", "/whatever");
    }
    auto end = std::chrono::steady_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "Duration: " << duration << "ms" << std::endl;
}

int main() {
    testDeepParameterRoutes();
    testPatternPriority();
    testMethodPriority();
    testUpgrade();
    testBugReports();
    testParameters();
    testPerformance();
}

```

`tests/Makefile`:

```
default:
	$(CXX) -std=c++17 -fsanitize=address Query.cpp -o Query
	./Query
	$(CXX) -std=c++17 -fsanitize=address ChunkedEncoding.cpp -o ChunkedEncoding
	./ChunkedEncoding
	$(CXX) -std=c++17 -fsanitize=address TopicTree.cpp -o TopicTree
	./TopicTree
	$(CXX) -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_DEBUG -std=c++17 -g -fsanitize=address HttpRouter.cpp -o HttpRouter
	./HttpRouter
	$(CXX) -std=c++17 -fsanitize=address BloomFilter.cpp -o BloomFilter
	./BloomFilter
	$(CXX) -std=c++17 -fsanitize=address ExtensionsNegotiator.cpp -o ExtensionsNegotiator
	./ExtensionsNegotiator
	$(CXX) -std=c++17 -fsanitize=address HttpParser.cpp -o HttpParser
	./HttpParser

performance:
	$(CXX) -std=c++17 HttpRouter.cpp -O3 -o HttpRouter
	./HttpRouter

smoke:
	../Crc32 &
	sleep 1
	~/.deno/bin/deno run --allow-net smoke.mjs
	node smoke.mjs
	pkill Crc32

compliance:
	../EchoBody &
	sleep 1
	~/.deno/bin/deno run --allow-net ../h1spec/http_test.ts localhost 3000
	pkill EchoBody

```

`tests/Query.cpp`:

```cpp
#include <iostream>
#include <cassert>

#include "../src/QueryParser.h"

int main() {

    {
        std::string buf = "?test1=&test2=someValue";
        assert(uWS::getDecodedQueryValue("test2", (char *) buf.data()) == "someValue");
    }

    {
        std::string buf = "?test1=&test2=someValue";
        assert(uWS::getDecodedQueryValue("test1", (char *) buf.data()) == "");
        assert(uWS::getDecodedQueryValue("test2", (char *) buf.data()) == "someValue");
    }

    {
        std::string buf = "?Kest1=&test2=someValue";
        assert(uWS::getDecodedQueryValue("test2", (char *) buf.data()) == "someValue");
    }

    {
        std::string buf = "?Test1=&Kest2=some";
        assert(uWS::getDecodedQueryValue("Test1", (char *) buf.data()) == "");
        assert(uWS::getDecodedQueryValue("Kest2", (char *) buf.data()) == "some");
    }

    {
        std::string buf = "?Test1=&Kest2=some";
        assert(uWS::getDecodedQueryValue("Test1", (char *) buf.data()).data() != nullptr);
        assert(uWS::getDecodedQueryValue("sdfsdf", (char *) buf.data()).data() == nullptr);
    }

    {
        std::string buf = "?Kest1=&test2=some%20Value";
        assert(uWS::getDecodedQueryValue("test2", (char *) buf.data()) == "some Value");
    }

    return 0;
}
```

`tests/README.md`:

```md
# Testing
This folder holds some unit tests and a smoke test. These are run by GitHub Actions on every push. There are more tests in fuzzing, benchmarks folders and elsewhere.

* We test with 500+ **standards conformance tests** known as the Autobahn|Testsuite where we get a full perfect score.
* In the fuzzing folder you will find extensive **security fuzz testing** under AddressSanitizer, MemoySanitizer, UndefinedBehaviorSanitizer executed by Google on a daily basis. We also fuzz a short while as part of GitHub Actions.
* HTTP standards conformance tests are run on every commit, testing fragmentation, invalid chars, and the like.
* In benchmarks folder you can find **performance testing** - we've done extensive performance testing of every commit since before we even had a single line of code.
* A set of **integration smoke tests** for testing basic features against real-world "web browsers" (Deno, Node.js and Bun are the "web browsers").
* And of course in this folder you can find the very **module unit tests** that check individual modules.
* Customers and users indirectly feed us with **real world, high scale production testing**.
* Semmle perform **static code analysis** and security testing for us, where we get the perfect A+ score.

```

`tests/TopicTree.cpp`:

```cpp
#include "../src/TopicTree.h"

#include <cassert>
#include <iostream>

/* Modifying the topicTree inside callback is not allowed, we had
 * tests for this before but we never need this to work anyways.
 * Closing a socket when reaching too much backpressure is done
 * deferred to next event loop iteration so we never need to modify
 * topicTree inside callback - removed this test */

/* This tests pretty much all features for obvious incorrectness */
void testCorrectness() {
    std::cout << "TestCorrectness" << std::endl;

    uWS::TopicTree<std::string, std::string_view> *topicTree;
    std::map<void *, std::string> expectedResult;
    std::map<void *, std::string> actualResult;

    topicTree = new uWS::TopicTree<std::string, std::string_view>([&topicTree, &actualResult](uWS::Subscriber *s, std::string &message, auto flags) {

        actualResult[s] += message;

        /* Success */
        return false;
    });

    uWS::Subscriber *s1 = topicTree->createSubscriber();
    uWS::Subscriber *s2 = topicTree->createSubscriber();

    /* Make sure s1 < s2 (for debugging) */
    if (s2 < s1) {
        uWS::Subscriber *tmp = s1;
        s1 = s2;
        s2 = tmp;
    }

    /* Publish to topic3 - nobody should see this */
    topicTree->publish(nullptr, "topic3", "Nobody should see");

    /* Subscribe s1 to topic3 - s1 should not see above message */
    topicTree->subscribe(s1, "topic3");

    /* Publish to topic3 with s1 as sender - s1 should not get its own messages */
    topicTree->publish(s1, "topic3", "Nobody should see");

    /* Subscribe s2 to topic3 - should not get any message */
    topicTree->subscribe(s2, "topic3");

    /* Publish to topic3 without sender - both should see */
    topicTree->publish(nullptr, "topic3", "Both should see");

    /* Publish to topic3 with s2 as sender - s1 should see */
    topicTree->publish(s2, "topic3", "s1 should see, not s2");

    /* Publish to topic3 with s1 as sender - s2 should see */
    topicTree->publish(s1, "topic3", "s2 should see, not s1");

    /* Publish to topic3 without sender - both should see */
    topicTree->publish(nullptr, "topic3", "Again, both should see this as well");

    // todo: add more cases involving more topics and duplicates, etc

    /* Fill out expectedResult */
    expectedResult = {
        {s1, "Both should sees1 should see, not s2Again, both should see this as well"},
        {s2, "Both should sees2 should see, not s1Again, both should see this as well"}
    };

    /* Compare result with expected result for every subscriber */
    topicTree->drain();
    for (auto &p : expectedResult) {
        std::cout << "Subscriber: " << p.first << std::endl;

        if (p.second != actualResult[p.first]) {
            std::cout << "ERROR: <" << actualResult[p.first] << "> should be <" << p.second << ">" << std::endl;
            exit(1);
        }
    }

    /* Release resources */
    topicTree->freeSubscriber(s1);
    topicTree->freeSubscriber(s2);

    delete topicTree;
}

void testBugReport() {
    std::cout << "TestBugReport" << std::endl;

    uWS::TopicTree<std::string, std::string_view> *topicTree;
    std::map<void *, std::string> expectedResult;
    std::map<void *, std::string> actualResult;

    topicTree = new uWS::TopicTree<std::string, std::string_view>([&topicTree, &actualResult](uWS::Subscriber *s, std::string &message, auto flags) {

        actualResult[s] += message;

        /* Success */
        return false;
    });

    uWS::Subscriber *s1 = topicTree->createSubscriber();
    uWS::Subscriber *s2 = topicTree->createSubscriber();

    /* Make sure s1 < s2 (for debugging) */
    if (s2 < s1) {
        uWS::Subscriber *tmp = s1;
        s1 = s2;
        s2 = tmp;
    }

    /* Each subscriber to its own topic */
    topicTree->subscribe(s1, "b1");
    topicTree->subscribe(s2, "b2");

    /* This one should send b2 to s2 */
    topicTree->publish(s1, "b1", "b1");
    topicTree->publish(s1, "b2", "b2");

    /* This one should send b1 to s1 */
    topicTree->publish(s2, "b1", "b1");
    topicTree->publish(s2, "b2", "b2");

    /* Fill out expectedResult */
    expectedResult = {
        {s1, "b1"},
        {s2, "b2"}
    };

    /* Compare result with expected result for every subscriber */
    topicTree->drain();
    for (auto &p : expectedResult) {
        std::cout << "Subscriber: " << p.first << std::endl;

        if (p.second != actualResult[p.first]) {
            std::cout << "ERROR: <" << actualResult[p.first] << "> should be <" << p.second << ">" << std::endl;
            exit(1);
        }
    }

    /* Release resources */
    topicTree->freeSubscriber(s1);
    topicTree->freeSubscriber(s2);

    delete topicTree;
}

void testReorderingv19() {
    std::cout << "TestReorderingv19" << std::endl;

    uWS::TopicTree<std::string, std::string_view> *topicTree;
    std::map<void *, std::string> expectedResult;
    std::map<void *, std::string> actualResult;

    topicTree = new uWS::TopicTree<std::string, std::string_view>([&topicTree, &actualResult](uWS::Subscriber *s, std::string &message, auto flags) {

        actualResult[s] += message;

        /* Success */
        return false;
    });

    uWS::Subscriber *s1 = topicTree->createSubscriber();

    /* Subscribe to 100 topics */
    for (int i = 0; i < 100; i++) {
        topicTree->subscribe(s1, std::to_string(i));
    }

    /* Publish to 100 topics in order with messages in order */
    for (int i = 0; i < 100; i++) {
        topicTree->publish(nullptr, std::to_string(i), std::to_string(i) + ",");

        expectedResult[s1].append(std::to_string(i) + ",");
    }

    /* Compare result with expected result for every subscriber */
    topicTree->drain();
    for (auto &p : expectedResult) {
        std::cout << "Subscriber: " << p.first << std::endl;

        if (p.second != actualResult[p.first]) {
            std::cout << "ERROR: <" << actualResult[p.first] << "> should be <" << p.second << ">" << std::endl;
            exit(1);
        }
    }

    /* Release resources */
    topicTree->freeSubscriber(s1);

    delete topicTree;
}

int main() {
    testCorrectness();
    testBugReport();
    testReorderingv19();
}
```

`tests/smoke.mjs`:

```mjs
/* This smoke test runs against the Crc32 example program for now, but this example will be extended for more tests */

var crc32 = (function () {
    var table = new Uint32Array(256);
    for (var i = 256; i--;) {
        var tmp = i;
        for (var k = 8; k--;) {
            tmp = tmp & 1 ? 3988292384 ^ tmp >>> 1 : tmp >>> 1;
        }
        table[i] = tmp;
    }
    return function (data) {
        var crc = -1; // Begin with all bits set ( 0xffffffff )
        for (var i = 0, l = data.length; i < l; i++) {
            crc = crc >>> 8 ^ table[crc & 255 ^ data[i]];
        }
        return (crc ^ -1) >>> 0; // Apply binary NOT
    };
})();

async function chunkedCrc32Test(array) {

    console.log("Making chunked request with body size: " + array.length);

    const stream = new ReadableStream(/*{type: "bytes"}, */{
        async start(controller) {
            await 1;
            controller.enqueue(array);
            controller.close();
        },
    });

    const r = await fetch("http://localhost:3000", {
        method: 'POST',
        headers: { 'Content-Type': 'application/octet-stream' },
        body: stream,
        duplex: 'half',
    });

    /* Download the response body (it's a crc32 hash plus newline) */
    const body = await r.body.getReader().read();

    /* Make a crc32 comparison of the two (mind the newline in one!) */
    const got = new TextDecoder().decode(body.value);

    const want = crc32(array).toString(16);
    if (got.toString().slice(0, -1) !== want.toString()) {
        throw new Error("failed chunked test");
    }
}

async function fixedCrc32Test(array) {
    console.log("Making request with body size: " + array.length);

    /* Send it with content-length */
    const res = await fetch("http://localhost:3000", { keepalive: true, headers: { 'Content-Type': 'text/plain' }, method: "POST", body: array });

    /* Download the response body (it's a crc32 hash plus newline) */
    const body = await res.body.getReader().read();

    /* Make a crc32 comparison of the two (mind the newline in one!) */
    const got = new TextDecoder().decode(body.value);
    const want = crc32(array).toString(16);
    if (got.toString().slice(0, -1) !== want.toString()) {
        throw new Error("failed test");
    }
}

/* Maximum chunk size is less than 256mb */
const sizes = [0, 0, 32, 32, 128, 256, 1024, 65536, 1024 * 1024, 1024 * 1024 * 128, 0, 0, 32, 32];
for (let i = 0; i < sizes.length; i++) {

    /* Create buffer with random data */
    const array = new Uint8Array(sizes[i]);
    //if (sizes[i] <= 65536) {
    //self.crypto.getRandomValues(array);
    //} else {
    array.fill(Math.random() * 255);
    //}

    /* Do this for all methods */
    await fixedCrc32Test(array);
    await chunkedCrc32Test(array);
}

console.log("Done!");
```