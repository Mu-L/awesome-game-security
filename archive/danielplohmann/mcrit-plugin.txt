Project Path: arc_danielplohmann_mcrit-plugin_sxxui06t

Source Tree:

```txt
arc_danielplohmann_mcrit-plugin_sxxui06t
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ config_override.json.template
‚îú‚îÄ‚îÄ helpers
‚îÇ   ‚îú‚îÄ‚îÄ ClassCollection.py
‚îÇ   ‚îú‚îÄ‚îÄ IdaProxy.py
‚îÇ   ‚îú‚îÄ‚îÄ McritInterface.py
‚îÇ   ‚îú‚îÄ‚îÄ McritTableColumn.py
‚îÇ   ‚îú‚îÄ‚îÄ QtShim.py
‚îÇ   ‚îú‚îÄ‚îÄ ScoreColorProvider.py
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ minimcrit
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ McritClient.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graph.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utility.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ matchers
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FunctionCfgMatcher.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MatcherFlags.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LocalQueue.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ storage
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FamilyEntry.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FunctionEntry.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ FunctionLabelEntry.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MatchedFunctionEntry.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MatchedSampleEntry.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ MatchingResult.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SampleEntry.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ pylev
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LICENSE
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ classic.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ damerau.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ recursive.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wf.py
‚îÇ   ‚îî‚îÄ‚îÄ pyperclip
‚îÇ       ‚îú‚îÄ‚îÄ LICENSE
‚îÇ       ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ icons
‚îÇ   ‚îú‚îÄ‚îÄ bomb.png
‚îÇ   ‚îú‚îÄ‚îÄ bug.png
‚îÇ   ‚îú‚îÄ‚îÄ cloud-download.png
‚îÇ   ‚îú‚îÄ‚îÄ cloud-upload.png
‚îÇ   ‚îú‚îÄ‚îÄ cluster.png
‚îÇ   ‚îú‚îÄ‚îÄ dna.png
‚îÇ   ‚îú‚îÄ‚îÄ export.png
‚îÇ   ‚îú‚îÄ‚îÄ fingerprint_scan.png
‚îÇ   ‚îú‚îÄ‚îÄ flag-triangle.png
‚îÇ   ‚îú‚îÄ‚îÄ mcrit.png
‚îÇ   ‚îú‚îÄ‚îÄ palette.png
‚îÇ   ‚îú‚îÄ‚îÄ puzzle.png
‚îÇ   ‚îú‚îÄ‚îÄ radar.png
‚îÇ   ‚îú‚îÄ‚îÄ relationship.png
‚îÇ   ‚îú‚îÄ‚îÄ satellite_dish.png
‚îÇ   ‚îú‚îÄ‚îÄ scan.png
‚îÇ   ‚îú‚îÄ‚îÄ search.png
‚îÇ   ‚îú‚îÄ‚îÄ settings.png
‚îÇ   ‚îú‚îÄ‚îÄ upload.png
‚îÇ   ‚îî‚îÄ‚îÄ yara.png
‚îú‚îÄ‚îÄ ida-plugin.json
‚îú‚îÄ‚îÄ ida_mcrit.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ qt-designer-mockup
‚îÇ   ‚îî‚îÄ‚îÄ Mockup.ui
‚îî‚îÄ‚îÄ widgets
    ‚îú‚îÄ‚îÄ BlockMatchWidget.py
    ‚îú‚îÄ‚îÄ FunctionMatchWidget.py
    ‚îú‚îÄ‚îÄ FunctionOverviewWidget.py
    ‚îú‚îÄ‚îÄ LocalInfoWidget.py
    ‚îú‚îÄ‚îÄ MainWidget.py
    ‚îú‚îÄ‚îÄ NumberQTableWidgetItem.py
    ‚îú‚îÄ‚îÄ ResultChooserDialog.py
    ‚îú‚îÄ‚îÄ SampleInfoWidget.py
    ‚îú‚îÄ‚îÄ SmdaGraphViewer.py
    ‚îú‚îÄ‚îÄ SmdaInfoDialog.py
    ‚îú‚îÄ‚îÄ YaraStringBuilderDialog.py
    ‚îî‚îÄ‚îÄ __init__.py

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# MCRIT IDA Plugin

[![IDA Version](https://img.shields.io/badge/IDA-9.0%2B-blue.svg)](https://hex-rays.com/ida-pro/)
[![Python](https://img.shields.io/badge/python-3.x-blue.svg)](https://www.python.org/)
[![License](https://img.shields.io/badge/license-GPL--3.0-green.svg)](LICENSE)
[![HCLI Compatible](https://img.shields.io/badge/HCLI-compatible-brightgreen.svg)](https://hcli.docs.hex-rays.com/)

> **Integration with MCRIT** for MinHash-based code similarity analysis in IDA Pro.

MCRIT (MinHash-based Code Relationship & Investigation Toolkit) simplifies MinHash-based code similarity detection.
This plugin seamlessly integrates MCRIT servers with IDA Pro for malware analysis and function identification.

## ‚ú® Features

- **Code Similarity** - Compare functions/blocks against MCRIT.
- **Function Matching** - Identify similar functions across binaries.
- **Label Management** - Sync function labels with the server.
- **Interactive Widgets** - Dedicated views for blocks, functions, and overview.
- **Integrated Settings** - Native configuration via `ida-settings`.
- **HCLI Support** - Easy installation and updates.

## üöÄ Installation

### HCLI

The recommended way to install is using [HCLI](https://hcli.docs.hex-rays.com/).

```bash
hcli plugin install mcrit-ida
```

This automatically handles dependencies (including `smda` and `mcrit` client) and configuration.

### As a Script

When using HCLI is not an option, you can also simply check out the repository or grab a source bundle from the releases.  
In this case, you need to ensure presence of the dependencies manually:

```bash
python -m pip install smda
```

and optionally

```bash
python -m pip install ida-settings>=3.3.0
```

If your installation of IDA Pro is situated in an offline Windows VM, there are dependency packages available to facilitate the setup (covering Python 3.10-3.13).  
After unpacking the wheelhouse, navigate to the folder and install them using:  

```bash
python -m pip install --no-index --find-links=. -r requirements.txt
```


## ‚öôÔ∏è Configuration

Configuration is managed via [ida-settings](https://github.com/williballenthin/ida-settings).

### Setup
1.  **GUI (Recommended)**: Install `ida-settings-editor` (`hcli plugin install ida-settings-editor`) and configure via **Edit ‚Üí Plugins ‚Üí Plugin Settings Manager**.
2.  **Interactive**: HCLI prompts for config values during installation.
3.  **Manual**: Edit `$IDAUSR/ida-config.json`, `config.py` or better, derive a `config_override.json` (discouraged)

### Connecting to Server
Configure the plugin to connect to your MCRIT instance:

| Setting | Description | Example |
| :--- | :--- | :--- |
| `mcrit_server` | Server URL | `https://mcrit.example.com/api/` |
| `mcritweb_api_token` | API Token (for MCRITweb) | `eyJ0eXAi...` |
| `mcritweb_username` | Username (optional) | `analyst` |

**Note**: For MCRITweb, the username is inferred automatically by setting the API token.

## üìñ Usage

1.  **Open Binary**: Load a file in IDA Pro.
2.  **Open Widgets**: View ‚Üí Open subviews ‚Üí MCRIT widgets.
3.  **Analyze**: Right-click a function ‚Üí **MCRIT** ‚Üí **Query function**.
4.  **Matches**: Review results in the **Function Scope Widget**.

## üîß Development

### Project Structure
```text
mcrit-plugin/
‚îú‚îÄ‚îÄ ida-plugin.json   # Plugin metadata
‚îú‚îÄ‚îÄ ida_mcrit.py      # Entry point
‚îú‚îÄ‚îÄ config.py         # Settings management
‚îú‚îÄ‚îÄ helpers/          # Utilities (incl. vendored pyperclip and pylev)
‚îú‚îÄ‚îÄ widgets/          # UI components
‚îî‚îÄ‚îÄ icons/            # Resources
```

### Local Build & Install
To install a development version from source:

```bash
# 1. Clone
git clone https://github.com/danielplohmann/mcrit-plugins.git
cd mcrit-plugins

# 2. Package
zip -r ../mcrit-ida.zip .

# 3. Install
hcli plugin install ../mcrit-ida.zip
```

##  Version History

### v1.1.4 (2026-01-30)
- added Github action to build dependency packages to facilitate installation in offline environments.
- Removed the mcrit package dependency by internalizing McritClient and required DTOs.
- Restored plugin hotkey handler and added a close action to the graph context menu.
- Improved resilience for missing or empty match data and guarded SMDA import paths.
- Hardened UI flows around function labels and form handling.
- Dev/CI: Added Ruff config + GitHub Action and reformatted the codebase.

### v1.1.3 (2026-01-28)
- Significantly improved usablity of FunctionOverviewWidget by being able to deconflict multiple candidate labels.

### v1.1.2 (2026-01-19)
- Optionally use SMDA as backend analysis engine (consistency towards MCRIT server), even when in IDA Pro.

### v1.1.1 (2026-01-15)
- Now coloring results in BlockMatch (by frequency) and FunctionMatch (by score) widgets
- Can now display offsets of matched functions in FunctionMatchWidget

### v1.1.0 (2025-12-30)
- Full HCLI Plugin Manager support.
- Migrated configuration to `ida-settings`.
- Code quality improvements.
- Strict HCLI compliance.

### v1.0.0 (2025-12-22)
- Initial standalone release.
- IDA 9.2 (PySide6) compatibility.

## üìÑ License
GPL-3.0. See [LICENSE](LICENSE) for details.

## üë§ Author
**Daniel Plohmann** ([@danielplohmann](https://github.com/danielplohmann))

```

`config.py`:

```py
import json
import logging
import os

import ida_settings

import helpers.McritTableColumn as McritTableColumn


# --- Settings Wrapper ---
class SettingsWrapper:
    def __init__(self):
        self._defaults = {
            "mcritweb_username": "",
            "mcrit_server": "http://127.0.0.1:8000/",
            "mcritweb_api_token": "",
            "auto_analyze_smda_on_startup": False,
            "use_smda_for_analysis": False,
            "submit_function_names_on_close": False,
            "blocks_filter_library_functions": False,
            "blocks_live_query": False,
            "blocks_min_size": 4,
            "function_filter_library_functions": False,
            "function_live_query": False,
            "function_min_score": 50,
            "overview_fetch_labels_automatically": False,
            "overview_filter_to_labels": False,
            "overview_filter_to_conflicts": False,
            "overview_min_score": 50,
        }
        # a little developer convenience to override settings without messing with IDA settings
        CONFIG_FILE_PATH = os.path.abspath(__file__)
        PROJECT_ROOT = os.path.dirname(CONFIG_FILE_PATH)
        if os.path.exists(PROJECT_ROOT + os.sep + "config_override.json"):
            try:
                with open(PROJECT_ROOT + os.sep + "config_override.json", "r") as override_file:
                    override_settings = json.load(override_file)
                    for key in self._defaults.keys():
                        self._defaults[key] = override_settings.get(key, self._defaults[key])
            except (json.JSONDecodeError, IOError):
                pass

    def _get(self, key):
        try:
            return ida_settings.get_current_plugin_setting(key)
        except (KeyError, AttributeError, ValueError, TypeError, RuntimeError):
            return self._defaults.get(key)

    @property
    def MCRITWEB_USERNAME(self):
        return self._get("mcritweb_username")

    @property
    def MCRIT_SERVER(self):
        return self._get("mcrit_server")

    @property
    def MCRITWEB_API_TOKEN(self):
        return self._get("mcritweb_api_token")

    @property
    def AUTO_ANALYZE_SMDA_ON_STARTUP(self):
        return self._get("auto_analyze_smda_on_startup")

    @property
    def USE_SMDA_FOR_ANALYSIS(self):
        return self._get("use_smda_for_analysis")

    @property
    def SUBMIT_FUNCTION_NAMES_ON_CLOSE(self):
        return self._get("submit_function_names_on_close")

    # Widget specific settings
    @property
    def BLOCKS_FILTER_LIBRARY_FUNCTIONS(self):
        return self._get("blocks_filter_library_functions")

    @property
    def BLOCKS_LIVE_QUERY(self):
        return self._get("blocks_live_query")

    @property
    def BLOCKS_MIN_SIZE(self):
        value = self._get("blocks_min_size")
        try:
            return int(value) if not isinstance(value, int) else value
        except (ValueError, TypeError):
            return 4

    @property
    def FUNCTION_FILTER_LIBRARY_FUNCTIONS(self):
        return self._get("function_filter_library_functions")

    @property
    def FUNCTION_LIVE_QUERY(self):
        return self._get("function_live_query")

    @property
    def FUNCTION_MIN_SCORE(self):
        value = self._get("function_min_score")
        try:
            return int(value) if not isinstance(value, int) else value
        except (ValueError, TypeError):
            return 50

    @property
    def OVERVIEW_FETCH_LABELS_AUTOMATICALLY(self):
        return self._get("overview_fetch_labels_automatically")

    @property
    def OVERVIEW_FILTER_TO_LABELS(self):
        return self._get("overview_filter_to_labels")

    @property
    def OVERVIEW_FILTER_TO_CONFLICTS(self):
        return self._get("overview_filter_to_conflicts")

    @property
    def OVERVIEW_MIN_SCORE(self):
        value = self._get("overview_min_score")
        try:
            return int(value) if not isinstance(value, int) else value
        except (ValueError, TypeError):
            return 50


settings = SettingsWrapper()


# --- Original Config Constants ---
VERSION = "1.1.4"
# relevant paths
CONFIG_FILE_PATH = os.path.abspath(__file__)
PROJECT_ROOT = os.path.dirname(CONFIG_FILE_PATH)
# PLUGINS_ROOT = str(os.path.abspath(os.sep.join([PROJECT_ROOT, ".."]))) # No longer needed as icons are inside
ICON_FILE_PATH = os.path.join(PROJECT_ROOT, "icons") + os.sep

### Configuration of Logging
LOG_PATH = "./"
LOG_LEVEL = logging.INFO
LOG_FORMAT = "%(asctime)-15s: %(name)-25s: %(message)s"
if not logging.getLogger().hasHandlers():
    logging.basicConfig(level=LOG_LEVEL, format=LOG_FORMAT)

MCRIT4IDA_PLUGIN_ONLY = False

# Proxy properties to settings wrapper
MCRITWEB_USERNAME = settings.MCRITWEB_USERNAME
MCRIT_SERVER = settings.MCRIT_SERVER
MCRITWEB_API_TOKEN = settings.MCRITWEB_API_TOKEN

### UI behavior configurations
## General behavior
AUTO_ANALYZE_SMDA_ON_STARTUP = settings.AUTO_ANALYZE_SMDA_ON_STARTUP
USE_SMDA_FOR_ANALYSIS = settings.USE_SMDA_FOR_ANALYSIS
SUBMIT_FUNCTION_NAMES_ON_CLOSE = settings.SUBMIT_FUNCTION_NAMES_ON_CLOSE

## Widget specific behavior
# Block Scope Widget
BLOCKS_FILTER_LIBRARY_FUNCTIONS = settings.BLOCKS_FILTER_LIBRARY_FUNCTIONS
BLOCKS_LIVE_QUERY = settings.BLOCKS_LIVE_QUERY
BLOCKS_MIN_SIZE = settings.BLOCKS_MIN_SIZE
#
BLOCK_SUMMARY_TABLE_COLUMNS = [
    McritTableColumn.OFFSET,
    McritTableColumn.PIC_BLOCK_HASH,
    McritTableColumn.SIZE,
    McritTableColumn.FAMILIES,
    McritTableColumn.SAMPLES,
    McritTableColumn.FUNCTIONS,
    McritTableColumn.IS_LIBRARY,
]
BLOCK_MATCHES_TABLE_COLUMNS = [
    McritTableColumn.FAMILY_NAME,
    McritTableColumn.FAMILY_ID,
    McritTableColumn.SAMPLE_ID,
    McritTableColumn.FUNCTION_ID,
    McritTableColumn.OFFSET,
    # McritTableColumn.SHA256,
]
# Function Scope Widget
FUNCTION_FILTER_LIBRARY_FUNCTIONS = settings.FUNCTION_FILTER_LIBRARY_FUNCTIONS
FUNCTION_LIVE_QUERY = settings.FUNCTION_LIVE_QUERY
FUNCTION_MIN_SCORE = settings.FUNCTION_MIN_SCORE
#
FUNCTION_MATCHES_TABLE_COLUMNS = [
    McritTableColumn.SCORE,
    McritTableColumn.SHA256,
    # McritTableColumn.OFFSET,
    McritTableColumn.FAMILY_NAME,
    McritTableColumn.VERSION,
    McritTableColumn.SAMPLE_ID,
    McritTableColumn.FUNCTION_ID,
    McritTableColumn.PIC_HASH_MATCH,
    McritTableColumn.IS_LIBRARY,
]
FUNCTION_NAMES_TABLE_COLUMNS = [
    McritTableColumn.FUNCTION_ID,
    McritTableColumn.SCORE,
    McritTableColumn.USER,
    McritTableColumn.FUNCTION_LABEL,
    # McritTableColumn.TIMESTAMP,
]
# Function Overview Widget
OVERVIEW_FETCH_LABELS_AUTOMATICALLY = settings.OVERVIEW_FETCH_LABELS_AUTOMATICALLY
OVERVIEW_FILTER_TO_LABELS = settings.OVERVIEW_FILTER_TO_LABELS
OVERVIEW_FILTER_TO_CONFLICTS = settings.OVERVIEW_FILTER_TO_CONFLICTS
OVERVIEW_MIN_SCORE = settings.OVERVIEW_MIN_SCORE
#
OVERVIEW_TABLE_COLUMNS = [
    McritTableColumn.OFFSET,
    McritTableColumn.FAMILIES,
    McritTableColumn.SAMPLES,
    McritTableColumn.FUNCTIONS,
    McritTableColumn.IS_LIBRARY,
    McritTableColumn.SCORE_AND_LABEL,
]

```

`config_override.json.template`:

```template
{
    "mcritweb_username": "",
    "mcrit_server": "http://127.0.0.1:8000/",
    "mcritweb_api_token": "",
    "auto_analyze_smda_on_startup": false,
    "use_smda_for_analysis": false,
    "submit_function_names_on_close": false,
    "blocks_filter_library_functions": false,
    "blocks_live_query": false,
    "blocks_min_size": 4,
    "function_filter_library_functions": false,
    "function_live_query": false,
    "function_min_score": 50,
    "overview_fetch_labels_automatically": false,
    "overview_filter_to_labels": false,
    "overview_filter_to_conflicts": false,
    "overview_min_score": 50
}
```

`helpers/ClassCollection.py`:

```py
import json
import os
import re
import sys
import time
from collections import deque

from helpers.IdaProxy import IdaProxy


class ClassCollection:
    def __init__(self, shim):
        # python imports
        self.json = json
        self.os = os
        self.os_path = os.path
        self.re = re
        self.sys = sys
        self.time = time
        self.deque = deque
        # PySide / PyQt imports
        self.QtShim = shim
        self.QtGui = self.QtShim.get_QtGui()
        self.QtCore = self.QtShim.get_QtCore()
        self.QIcon = self.QtShim.get_QIcon()
        self.QWidget = self.QtShim.get_QWidget()
        self.QVBoxLayout = self.QtShim.get_QVBoxLayout()
        self.QHBoxLayout = self.QtShim.get_QHBoxLayout()
        self.QGridLayout = self.QtShim.get_QGridLayout()
        self.QSplitter = self.QtShim.get_QSplitter()
        self.QStyleFactory = self.QtShim.get_QStyleFactory()
        self.QLabel = self.QtShim.get_QLabel()
        self.QTableWidget = self.QtShim.get_QTableWidget()
        self.QAbstractItemView = self.QtShim.get_QAbstractItemView()
        self.QTableWidgetItem = self.QtShim.get_QTableWidgetItem()
        self.QStyledItemDelegate = self.QtShim.get_QStyledItemDelegate()
        self.QPushButton = self.QtShim.get_QPushButton()
        self.QScrollArea = self.QtShim.get_QScrollArea()
        self.QSizePolicy = self.QtShim.get_QSizePolicy()
        self.QLineEdit = self.QtShim.get_QLineEdit()
        self.QTextEdit = self.QtShim.get_QTextEdit()
        self.QMainWindow = self.QtShim.get_QMainWindow()
        self.QSlider = self.QtShim.get_QSlider()
        self.QCompleter = self.QtShim.get_QCompleter()
        self.QTextBrowser = self.QtShim.get_QTextBrowser()
        self.QStringListModel = self.QtShim.get_QStringListModel()
        self.QDialog = self.QtShim.get_QDialog()
        self.QGroupBox = self.QtShim.get_QGroupBox()
        self.QRadioButton = self.QtShim.get_QRadioButton()
        self.QComboBox = self.QtShim.get_QComboBox()
        self.QCheckBox = self.QtShim.get_QCheckBox()
        self.QAction = self.QtShim.get_QAction()
        self.QColor = self.QtShim.get_QColor()
        self.QBrush = self.QtShim.get_QBrush()
        self.QPalette = self.QtShim.get_QPalette()
        self.QTreeWidget = self.QtShim.get_QTreeWidget()
        self.QTreeWidgetItem = self.QtShim.get_QTreeWidgetItem()
        self.QStyle = self.QtShim.get_QStyle()
        self.QPainter = self.QtShim.get_QPainter()
        self.QApplication = self.QtShim.get_QApplication()
        self.QStyleOptionSlider = self.QtShim.get_QStyleOptionSlider()
        self.QTabWidget = self.QtShim.get_QTabWidget()
        self.DescendingOrder = self.QtShim.get_DescendingOrder()
        self.QFrame = self.QtShim.get_QFrame()
        self.QFrameHLine = self.QtShim.get_QFrameHLine()
        self.QFrameShadow = self.QtShim.get_QFrameShadow()
        self.QSpinBox = self.QtShim.get_QSpinBox()
        self.QFont = self.QtShim.get_QFont()
        # ida_proxy
        self.ida_proxy = IdaProxy()

```

`helpers/IdaProxy.py`:

```py
#!/usr/bin/python
########################################################################
# Copyright (c) 2012
# Daniel Plohmann <daniel.plohmann<at>gmail<dot>com>
# Alexander Hanel <alexander.hanel<at>gmail<dot>com>
# All rights reserved.
########################################################################
#
#  This file is part of IDAscope
#
#  IDAscope is free software: you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see
#  <http://www.gnu.org/licenses/>.
#
########################################################################

import ida_bytes
import idaapi
import idautils
import idc


class IdaProxy:
    """
    This class serves as a generic proxy to the IDA Pro Python API. This is neccessary because while running the
    plugin, dynamic references to the loaded Python modules get lost when inside functions called by Qt.
    As a side effect, we can also do central error handling in this proxy class.
    """

    def __init__(self):
        self.idc = idc
        self.idaapi = idaapi
        self.idautils = idautils
        self.ida_bytes = ida_bytes
        # debug output
        self.verbose = False
        # constants
        self.BAD_ADDR = self.idaapi.BADADDR
        self.CIC_ITEM = self.idc.CIC_ITEM
        self.FF_LABL = self.idc.FF_LABL
        self.FL_CN = self.idc.fl_CN
        self.FL_CN = self.idc.fl_CN
        self.FUNC_LIB = self.idaapi.FUNC_LIB
        self.FUNCATTR_END = self.idc.FUNCATTR_END
        self.INF_SHORT_DN = self.idc.INF_SHORT_DN
        self.SN_NOWARN = self.idc.SN_NOWARN
        self.SN_NOCHECK = self.idc.SN_NOCHECK
        self.SA_REL_BYTE = self.idc.saRelByte
        self.SA_REL_PARA = self.idc.saRelPara
        self.SC_PRIV = self.idc.scPriv
        self.SC_PUB = self.idc.scPub
        self.SEGMOD_KILL = self.idaapi.SEGMOD_KILL
        self.SEARCH_DOWN = 1
        self.MFF_FAST = self.idaapi.MFF_FAST
        if self.idaapi.IDA_SDK_VERSION < 700:
            self.ASCSTR_C = self.idc.ASCSTR_C
        else:
            self.ASCSTR_C = self.idc.STRTYPE_C
        self.FUNCATTR_START = self.idc.FUNCATTR_START

    ###############################################################################
    # From idc.py
    ###############################################################################

    def AddHotkey(self, hotkey, function):
        return self.idc.AddHotkey(hotkey, function)

    def AddSeg(self, start_ea, end_ea, base, use32, align, comb):
        return self.idc.AddSeg(start_ea, end_ea, base, use32, align, comb)

    def Byte(self, byte):
        return self.idc.Byte(byte)

    def Comment(self, addr):
        return self.idc.Comment(addr)

    def DelSeg(self, address, flags):
        return self.idc.DelSeg(address, flags)

    def Demangle(self, name, disable_mask):
        return self.idc.Demangle(name, disable_mask)

    def Dword(self, addr):
        return self.idc.Dword(addr)

    def FirstSeg(self):
        return self.idc.FirstSeg()

    def get_byte(self, address):
        return self.idaapi.get_byte(address)

    def GetCommentEx(self, ea, repeatable):
        return self.idaapi.GetCommentEx(ea, repeatable)

    def GetDisasm(self, address):
        return self.idc.GetDisasm(address)

    def GetFlags(self, address):
        return self.idc.GetFlags(address)

    def GetFunctionAttr(self, ea, attr):
        return self.idc.GetFunctionAttr(ea, attr)

    def GetFunctionCmt(self, ea, repeatable):
        return self.idc.GetFunctionCmt(ea, repeatable)

    def GetFunctionFlags(self, address):
        return self.idc.GetFunctionFlags(address)

    def GetFunctionName(self, address):
        return self.idc.GetFunctionName(address)

    def GetFrame(self, ea):
        return self.idc.GetFrame(ea)

    def GetInputMD5(self):
        return self.idc.retrieve_input_file_md5()

    def GetLongPrm(self, offset):
        return self.idc.GetLongPrm(offset)

    def GetLastMember(self, sid):
        return self.idc.GetLastMember(sid)

    def GetMnem(self, address):
        return self.idc.GetMnem(address)

    def GetMemberComment(self, sid, member_offset, repeatable):
        return self.idc.GetMemberComment(sid, member_offset, repeatable)

    def GetMemberFlag(self, sid, member_offset):
        return self.idc.GetMemberFlag(sid, member_offset)

    def GetMemberName(self, sid, member_offset):
        return self.idc.GetMemberName(sid, member_offset)

    def GetMemberSize(self, sid, member_offset):
        return self.idc.GetMemberSize(sid, member_offset)

    def GetMemberOffset(self, sid, member_name):
        return self.idc.GetMemberOffset(sid, member_name)

    def GetOpType(self, address, index):
        return self.idc.GetOpType(address, index)

    def GetOperandValue(self, address, index):
        return self.idc.GetOperandValue(address, index)

    def GetString(self, address):
        return self.idc.GetString(address)

    def GetType(self, address):
        type_at_address = self.idc.GetType(address)
        if type_at_address is not None:
            return type_at_address
        else:
            if self.verbose:
                print(
                    '[!] IdaProxy.FlowChart: No type information for 0x%x available, returning "".'
                    % address
                )
            return ""

    def isCode(self, flags):
        return self.idc.isCode(flags)

    def Jump(self, address):
        return self.idc.jumpto(address)

    def LocByName(self, name):
        return self.idc.LocByName(name)

    def MakeFunction(self, instruction):
        return self.idc.MakeFunction(instruction)

    def MakeNameEx(self, address, name, warning_level):
        return self.idc.MakeNameEx(address, name, warning_level)

    def set_name(self, address, name, warning_level):
        return self.idc.set_name(address, name, warning_level)

    def MakeRptCmt(self, ea, comment):
        return self.idc.MakeRptCmt(ea, comment)

    def Name(self, address):
        return self.idc.Name(address)

    def NextSeg(self, address):
        return self.idc.NextSeg(address)

    def PatchByte(self, address, byte):
        self.idc.PatchByte(address, byte)

    def PrevHead(self, ea, minea=0):
        return self.idc.PrevHead(ea, minea)

    def NextHead(self, ea, minea=0):
        return self.idc.NextHead(ea, minea)

    def ReadSelectionStart(self):
        return self.idc.read_selection_start()

    def ReadSelectionEnd(self):
        return self.idc.read_selection_end()

    def RptCmt(self, ea):
        return self.idc.RptCmt(ea)

    def SegEnd(self, address):
        return self.idc.SegEnd(address)

    def SegName(self, address):
        return self.idc.SegName(address)

    def SegRename(self, address, name):
        return self.idc.SegRename(address, name)

    def SegStart(self, address):
        return self.idc.SegStart(address)

    def SetColor(self, address, location_type, color):
        return self.idc.SetColor(address, location_type, color)

    def GetOpnd(self, ea, n):
        return self.idc.GetOpnd(ea, n)

    ###############################################################################
    # From idaapi.py
    ###############################################################################

    def CompileLine(self, line):
        return self.idaapi.CompileLine(line)

    def find_not_func(self, *args):
        return self.idaapi.find_not_func(*args)

    def find_binary(self, *args):
        return self.idaapi.find_binary(*args)

    def FlowChart(self, function_address):
        function_chart = []
        try:
            function_chart = self.idaapi.FlowChart(function_address)
        except Exception:
            if self.verbose:
                if function_address is not None:
                    print(
                        "[!] Trying to resolve an API address in non-function code at location: 0x%x, continuing "
                        + "analysis..." % function_address
                    )
                else:
                    print(
                        "[!] IdaProxy.FlowChart: Tried to create a FlowChart on None object, skipping function."
                    )
        return function_chart

    def get_func(self, function_address):
        return self.idaapi.get_func(function_address)

    def get_highlighted_identifier(self):
        return self.idaapi.get_highlighted_identifier()

    def isASCII(self, flags):
        return self.idaapi.isASCII(flags)

    def minEA(self):
        return self.idaapi.cvar.inf.minEA

    def refresh_idaview_anyway(self):
        return self.idaapi.refresh_idaview_anyway()

    def get_import_module_qty(self):
        return self.idaapi.get_import_module_qty()

    def get_import_module_name(self, mod_index):
        return self.idaapi.get_import_module_name(mod_index)

    def enum_import_names(self, mod_index, py_cb):
        return self.idaapi.enum_import_names(mod_index, py_cb)

    ###############################################################################
    # From idautils.py
    ###############################################################################

    def CodeRefsFrom(self, source, flow):
        return self.idautils.CodeRefsFrom(source, flow)

    def CodeRefsTo(self, destination, flow):
        return self.idautils.CodeRefsTo(destination, flow)

    def DataRefsFrom(self, source):
        return self.idautils.DataRefsFrom(source)

    def DataRefsTo(self, destination):
        return self.idautils.DataRefsTo(destination)

    def execute_sync(self, *args):
        return self.idaapi.execute_sync(*args)

    def FuncItems(self, function_address):
        return self.idautils.FuncItems(function_address)

    def Functions(self, start_address=None, end_address=None):
        return self.idautils.Functions(start_address, end_address)

    def Heads(self, start_address=None, end_address=None):
        return self.idautils.Heads(start_address, end_address)

    def Names(self):
        return self.idautils.Names()

    def Segments(self):
        return self.idautils.Segments()

    def XrefsTo(self, ea, flag=0):
        return self.idautils.XrefsTo(ea, flag)

    ###############################################################################
    # From idautils.py
    ###############################################################################

    def GetBytes(self, address, size):
        return self.ida_bytes.get_bytes(address, size)

```

`helpers/McritInterface.py`:

```py
import json
import os
import traceback

from helpers.minimcrit.client.McritClient import McritClient
from helpers.minimcrit.storage.MatchingResult import MatchingResult

try:
    from smda.common.BinaryInfo import BinaryInfo
    from smda.Disassembler import Disassembler
    from smda.ida.IdaInterface import IdaInterface
except Exception as exc:
    Disassembler = None
    IdaInterface = None
    BinaryInfo = None
    _SMDA_IMPORT_ERROR = exc
else:
    _SMDA_IMPORT_ERROR = None
# from helpers.SmdaConfig import SmdaConfig


class McritInterface(object):
    def __init__(self, parent):
        if Disassembler is None or IdaInterface is None or BinaryInfo is None:
            raise ImportError(
                "SMDA not found, please install it (and its dependencies) as a python package to proceed!"
            ) from _SMDA_IMPORT_ERROR
        self.parent = parent
        self.config = parent.config
        self._mcrit_server = self.config.MCRIT_SERVER
        self.mcrit_client = McritClient(self.config.MCRIT_SERVER)
        if self.config.MCRITWEB_API_TOKEN:
            self.mcrit_client.setApitoken(self.config.MCRITWEB_API_TOKEN)
        if self.config.MCRITWEB_USERNAME:
            self.mcrit_client.setUsername(self.config.MCRITWEB_USERNAME)
        # self.smda_config = SmdaConfig()
        self.smda_disassembler = Disassembler(backend="IDA")
        self.smda_ida = IdaInterface()
        # IDA 6.x Windows workaronud to avoid lost imports
        self.json = json
        self.os = os
        self.os_path = os.path
        self._withTraceback = False

    def _getMcritServerAddress(self):
        return self._mcrit_server

    def convertIdbToSmda(self):
        self.parent.local_widget.updateActivityInfo("Converting to SMDA report...")
        report = self.smda_disassembler.disassembleBuffer(self.smda_ida.getBinary(), 0)
        self.parent.local_widget.updateActivityInfo("Conversion from IDB to SMDA finished.")
        return report

    def getIdaBinaryInfo(self):
        binary_info = BinaryInfo(self.smda_ida.getBinary())
        if not binary_info.architecture:
            binary_info.architecture = self.smda_ida.getArchitecture()
        if not binary_info.base_addr:
            binary_info.base_addr = self.smda_ida.getBaseAddr()
        if not binary_info.bitness:
            binary_info.bitness = self.smda_ida.getBitness()
        return binary_info

    def convertIdbToSmdaUsingSmda(self):
        self.parent.local_widget.updateActivityInfo("Converting to SMDA report using SMDA...")
        smda_disassembler = Disassembler(backend="intel")
        binary_info = self.getIdaBinaryInfo()
        report = smda_disassembler._disassemble(binary_info, timeout=300)
        function_symbols = self.smda_ida.getFunctionSymbols()
        for smda_function in report.getFunctions():
            if smda_function.offset in function_symbols:
                smda_function.function_name = function_symbols[smda_function.offset]
        self.parent.local_widget.updateActivityInfo("Conversion from IDB to SMDA finished.")
        return report

    def checkConnection(self):
        self.parent.local_widget.updateActivityInfo(
            "Checking connection to server: %s" % self._getMcritServerAddress()
        )
        try:
            mcrit_version = self.mcrit_client.getVersion()
            if mcrit_version:
                self.parent.local_widget.updateActivityInfo("Connection check successful!")
                self.parent.local_widget.updateServerInfo(
                    self._getMcritServerAddress(), version=mcrit_version
                )
            else:
                self.parent.local_widget.updateActivityInfo(
                    "Connection check failed (status code)."
                )
                self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo("Connection check failed (unreachable).")
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def querySampleSha256(self, sha256):
        self.parent.local_widget.updateActivityInfo("Querying for SHA256")
        try:
            sample_by_sha256 = self.mcrit_client.getSampleBySha256(sha256)
            if sample_by_sha256:
                self.parent.remote_sample_entry = sample_by_sha256
                self.parent.remote_sample_id = sample_by_sha256.sample_id
                self.parent.local_widget.updateActivityInfo(
                    "Success! Received remote Sample Entry."
                )
            else:
                self.parent.local_widget.updateActivityInfo("querySampleSha256 failed")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "querySampleSha256 failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def uploadReport(self, report):
        self.parent.local_widget.updateActivityInfo(
            "Sending SMDA report to server %s" % self._getMcritServerAddress()
        )
        try:
            sample_entry, job_id = self.mcrit_client.addReport(report)
            if sample_entry:
                if job_id:
                    self.parent.local_widget.updateActivityInfo(
                        "Upload finished, remote sample_id is: %d (processing MinHashes as job_id: %s)"
                        % (sample_entry.sample_id, job_id)
                    )
                else:
                    self.parent.local_widget.updateActivityInfo(
                        "Upload finished, remote sample_id is: %d." % sample_entry.sample_id
                    )
                self.parent.remote_sample_entry = sample_entry
                self.parent.remote_sample_id = sample_entry.sample_id
                self.parent.local_widget.update()
            else:
                self.parent.local_widget.updateActivityInfo("Upload failed.")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo("Upload failed, error on connection :(")
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryJobs(self, sample_id=None):
        """Fetch all jobs regarding Matches, optionally filter to a sample_id"""
        if sample_id is not None:
            self.parent.local_widget.updateActivityInfo(
                "Querying jobs for sample with id: %d" % self.parent.remote_sample_id
            )
        else:
            self.parent.local_widget.updateActivityInfo("Querying jobs.")
        try:
            # fetch jobs
            jobs = self.mcrit_client.getQueueData(filter="Matches")
            # check if we already have a match report for the sample id
            if sample_id is not None:
                jobs = [
                    job
                    for job in jobs
                    if "(" + str(sample_id) + ")" in job.parameters
                    or "(" + str(sample_id) + "," in job.parameters
                    or "," + str(sample_id) + "," in job.parameters
                    or "," + str(sample_id) + ")" in job.parameters
                ]
            if jobs:
                self.parent.local_widget.updateActivityInfo("Success! Fetched Jobs.")
            else:
                self.parent.local_widget.updateActivityInfo("No jobs available yet.")
            return jobs
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo("Job query failed, error on connection :(")
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def requestMatchingJob(self, sample_id, force_update=False):
        self.parent.local_widget.updateActivityInfo(
            "Tasking matching job for sample with id: %d" % self.parent.remote_sample_id
        )
        try:
            job_id = self.mcrit_client.requestMatchesForSample(
                sample_id, band_matches_required=2, force_recalculation=force_update
            )
            if job_id:
                self.parent.local_widget.updateActivityInfo(
                    "Success! MatchingJob has ID: %s." % job_id
                )
            else:
                self.parent.local_widget.updateActivityInfo("Match query failed.")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "Match query failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def getMatchingJobById(self, job_id):
        self.parent.local_widget.updateActivityInfo("Querying result for job with id: %s" % job_id)
        try:
            matching_result = self.mcrit_client.getResultForJob(job_id)
            if matching_result:
                self.parent.matching_job_id = job_id
                self.parent.matching_report = MatchingResult.fromDict(matching_result)
                self.parent.local_widget.updateActivityInfo("Success! Downloaded MatchResult.")
            else:
                self.parent.local_widget.updateActivityInfo("Result query failed.")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "Result query failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryAllFamilyEntries(self):
        self.parent.local_widget.updateActivityInfo("Querying for FamilyEntries")
        try:
            family_entries = self.mcrit_client.getFamilies()
            if family_entries:
                self.parent.family_infos = {int(k): v for k, v in family_entries.items()}
                self.parent.local_widget.updateActivityInfo(
                    "Success! Received all remote FamilyEntries."
                )
            else:
                self.parent.local_widget.updateActivityInfo("queryAllFamilyEntries failed")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryAllFamilyEntries failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def querySmdaFunctionMatches(self, smda_report):
        try:
            functions = list(smda_report.getFunctions())
            if not functions:
                return None
            smda_function = functions[0]
            if smda_function.offset not in self.parent.function_matches:
                match_report_dict = self.mcrit_client.getMatchesForSmdaFunction(
                    smda_report, exclude_self_matches=False
                )
                if match_report_dict:
                    self.parent.function_matches.update({smda_function.offset: match_report_dict})
                if match_report_dict:
                    match_report = MatchingResult.fromDict(match_report_dict)
                    matched_function_ids = [
                        match.matched_function_id for match in match_report.function_matches
                    ]
                    unknown_function_ids = [
                        fid
                        for fid in matched_function_ids
                        if fid not in self.parent.function_id_to_offset
                    ]
                    if unknown_function_ids:
                        function_entries = self.queryFunctionEntriesById(unknown_function_ids)
                        if function_entries:
                            for function_id, function_entry in function_entries.items():
                                self.parent.function_id_to_offset[function_id] = (
                                    function_entry.offset
                                )
                    return match_report
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "querySmdaFunctionMatches failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryFunctionEntriesById(self, function_ids, with_label_only=False):
        try:
            function_entries = self.mcrit_client.getFunctionsByIds(
                function_ids, with_label_only=with_label_only
            )
            if function_entries:
                if self.parent.matched_function_entries is None:
                    self.parent.matched_function_entries = {}
                self.parent.matched_function_entries.update(function_entries)
                return function_entries
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryFunctionEntriesById failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryPicHashMatches(self, pichash):
        try:
            if pichash not in self.parent.pichash_matches:
                pichash_matches = self.mcrit_client.getMatchesForPicHash(pichash)
                if pichash_matches:
                    self.parent.pichash_matches.update({pichash: pichash_matches})
                pichash_match_summary = self.mcrit_client.getMatchesForPicHash(
                    pichash, summary=True
                )
                if pichash_match_summary:
                    self.parent.pichash_match_summaries.update({pichash: pichash_match_summary})
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryPicHashMatches failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryAllSampleEntries(self):
        self.parent.local_widget.updateActivityInfo("Querying for SampleEntries")
        try:
            sample_entries = self.mcrit_client.getSamples()
            if sample_entries:
                self.parent.sample_infos = sample_entries
                self.parent.local_widget.updateActivityInfo(
                    "Success! Received all remote SampleEntries."
                )
            else:
                self.parent.local_widget.updateActivityInfo("queryAllSampleEntries query failed")
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryAllSampleEntries failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryFunctionEntriesBySampleId(self, sample_id):
        self.parent.local_widget.updateActivityInfo("Querying for remote FunctionEntry mapping")
        try:
            functions_for_sample = self.mcrit_client.getFunctionsBySampleId(sample_id)
            if functions_for_sample:
                self.parent.remote_function_mapping = {
                    function_entry.function_id: function_entry
                    for function_entry in functions_for_sample
                }
                self.parent.local_widget.updateActivityInfo(
                    "Success! Fetched remote FunctionEntry mapping."
                )
            else:
                self.parent.local_widget.updateActivityInfo(
                    "queryFunctionEntriesBySampleId query failed."
                )
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryFunctionEntriesBySampleId failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def queryFunctionEntryById(self, function_id):
        try:
            return self.mcrit_client.getFunctionById(function_id, with_xcfg=True)
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "queryFunctionEntryById failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def querySampleEntryById(self, sample_id):
        try:
            return self.mcrit_client.getSampleById(sample_id)
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "querySampleEntryById failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

    def getMatchesForPicBlockHash(self, picblockhash):
        try:
            return self.mcrit_client.getMatchesForPicBlockHash(picblockhash)
        except Exception:
            if self._withTraceback:
                traceback.print_exc()
            self.parent.local_widget.updateActivityInfo(
                "querySampleEntryById failed, error on connection :("
            )
            self.parent.local_widget.updateServerInfo(self._getMcritServerAddress())

```

`helpers/McritTableColumn.py`:

```py
from typing import List, Optional

# This file holds enums for configurable table column types across the different tables in the MCRIT plugin.
# The SHA256 hash of the sample, shortened to the first 8 hexbytes, right-click copies full hash to clipboard.
SHA256 = 1
# The name of the family assigned to the sample.
FAMILY_NAME = 1 << 1
# The version string assigned to the sample.
VERSION = 1 << 2
# Boolean indicating whether the sample is a library.
IS_LIBRARY = 1 << 3
# Unique identifier for the family as registered in MCRIT
FAMILY_ID = 1 << 4
# Unique identifier for the sample as registered in MCRIT
SAMPLE_ID = 1 << 5
# Unique identifier for the function as registered in MCRIT
FUNCTION_ID = 1 << 6
# The offset of the function or block within the sample.
OFFSET = 1 << 7
# The size of the function or block in bytes.
SIZE = 1 << 8
# The PIC block hash of the function or block.
PIC_BLOCK_HASH = 1 << 9
# The number of families matching the function or block.
FAMILIES = 1 << 10
# The number of samples matching the function or block.
SAMPLES = 1 << 11
# The number of functions matching the function or block.
FUNCTIONS = 1 << 12
# Boolean indicating whether there is a PIC hash match for the function or block
PIC_HASH_MATCH = 1 << 13
# Matching Score for the function
SCORE = 1 << 14
# The username of the user who submitted the label.
USER = 1 << 15
# The label assigned to the function
FUNCTION_LABEL = 1 << 16
# Timestamp of when the label was assigned
TIMESTAMP = 1 << 17
# ComboBox with all scores / labels for the function
SCORE_AND_LABEL = 1 << 18

MAP_COLUMN_TO_HEADER_STRING = {
    SHA256: "SHA256",
    FAMILY_NAME: "Family",
    VERSION: "Version",
    IS_LIBRARY: "Library?",
    FAMILY_ID: "Family ID",
    SAMPLE_ID: "Sample ID",
    FUNCTION_ID: "Function ID",
    OFFSET: "Offset",
    SIZE: "Size",
    PIC_BLOCK_HASH: "PIC#",
    FAMILIES: "Families",
    SAMPLES: "Samples",
    FUNCTIONS: "Functions",
    PIC_HASH_MATCH: "PIC?",
    SCORE: "Score",
    USER: "User",
    FUNCTION_LABEL: "Label",
    TIMESTAMP: "Timestamp",
    SCORE_AND_LABEL: "Score & Labels",
}


def columnTypeToIndex(column_type: int, configured_columns: List[int]) -> Optional[int]:
    """
    Given a column type and a list of configured columns, return the index of the column type in the list.
    If the column type is not found, return None.
    """
    for index, ctype in enumerate(configured_columns):
        if ctype == column_type:
            return index
    return None

```

`helpers/QtShim.py`:

```py
# inspired by this gist of Willi Ballenthin
# https://gist.github.com/williballenthin/277eedca569043ef0984

import idaapi


def get_QtCore():
    if idaapi.IDA_SDK_VERSION <= 680:
        # IDA 6.8 and below
        import PySide.QtCore as QtCore

        return QtCore
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        # IDA 6.9 - IDA 9.1
        import PyQt5.QtCore as QtCore

        return QtCore
    else:
        # IDA 9.2 and above
        import PySide6.QtCore as QtCore

        return QtCore


def get_QtGui():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui


def get_QtWidgets():
    if idaapi.IDA_SDK_VERSION <= 680:
        return None
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets


def get_Qt():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore

        return QtCore.Qt
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtCore as QtCore

        return QtCore.Qt
    else:
        # IDA 9.2 and above
        import PySide6.QtCore as QtCore

        return QtCore.Qt


def get_QTreeWidget():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTreeWidget
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTreeWidget
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTreeWidget


def get_QTreeWidgetItem():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTreeWidgetItem
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTreeWidgetItem
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTreeWidgetItem


def get_QHeaderView():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QHeaderView
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QHeaderView
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QHeaderView


def get_QCheckBox():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QCheckBox
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QCheckBox
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QCheckBox


def get_QIcon():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QIcon
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QIcon
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QIcon


def get_QWidget():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QWidget
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QWidget
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QWidget


def get_QVBoxLayout():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QVBoxLayout
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QVBoxLayout
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QVBoxLayout


def get_QHBoxLayout():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QHBoxLayout
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QHBoxLayout
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QHBoxLayout


def get_QGridLayout():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QGridLayout
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QGridLayout
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QGridLayout


def get_QSplitter():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QSplitter
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QSplitter
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QSplitter


def get_QStyleFactory():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QStyleFactory
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QStyleFactory
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QStyleFactory


def get_QStyleOptionSlider():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QStyleOptionSlider
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QStyleOptionSlider
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QStyleOptionSlider


def get_QApplication():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QApplication
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QApplication
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QApplication


def get_QPainter():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QPainter
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QPainter
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QPainter


def get_QPalette():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QPalette
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QPalette
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QPalette


def get_DescendingOrder():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore

        return QtCore.Qt.SortOrder.DescendingOrder
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtCore as QtCore

        return QtCore.Qt.DescendingOrder
    else:
        # IDA 9.2 and above
        import PySide6.QtCore as QtCore

        return QtCore.Qt.DescendingOrder


def get_QTabWidget():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTabWidget
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTabWidget
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTabWidget


def get_QStyle():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QStyle
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QStyle
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QStyle


def get_QLabel():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QLabel
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QLabel
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QLabel


def get_QTableWidget():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTableWidget
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTableWidget
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTableWidget


def get_QTableWidgetItem():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTableWidgetItem
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTableWidgetItem
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTableWidgetItem


def get_QStyledItemDelegate():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QStyledItemDelegate
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QStyledItemDelegate
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QStyledItemDelegate


def get_QPushButton():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QPushButton
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QPushButton
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QPushButton


def get_QAbstractItemView():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QAbstractItemView
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QAbstractItemView
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QAbstractItemView


def get_QScrollArea():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QScrollArea
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QScrollArea
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QScrollArea


def get_QSizePolicy():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QSizePolicy
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QSizePolicy
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QSizePolicy


def get_QLineEdit():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QLineEdit
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QLineEdit
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QLineEdit


def get_QCompleter():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QCompleter
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QCompleter
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QCompleter


def get_QTextBrowser():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTextBrowser
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTextBrowser
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTextBrowser


def get_QSlider():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QSlider
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QSlider
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QSlider


def get_QMainWindow():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QMainWindow
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QMainWindow
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QMainWindow


def get_QTextEdit():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QTextEdit
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QTextEdit
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QTextEdit


def get_QDialog():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QDialog
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QDialog
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QDialog


def get_QGroupBox():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QGroupBox
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QGroupBox
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QGroupBox


def get_QRadioButton():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QRadioButton
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QRadioButton
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QRadioButton


def get_QComboBox():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QComboBox
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QComboBox
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QComboBox


def get_QAction():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QAction
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QAction
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QAction


def get_QBrush():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QBrush
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QBrush
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QBrush


def get_QColor():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QColor
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QColor
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QColor


def get_QStringListModel():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QStringListModel
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtCore as QtCore

        return QtCore.QStringListModel
    else:
        # IDA 9.2 and above
        import PySide6.QtCore as QtCore

        return QtCore.QStringListModel


def get_Signal():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtCore as QtCore

        return QtCore.Signal
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtCore as QtCore

        return QtCore.pyqtSignal
    else:
        # IDA 9.2 and above
        import PySide6.QtCore as QtCore

        return QtCore.Signal


def get_QFrame():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QFrame
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QFrame
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QFrame


def get_QFrameHLine():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QFrame.HLine
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QFrame.HLine
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QFrame.Shape.HLine


def get_QFrameShadow():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QFrame
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QFrame
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QFrame.Shadow


def get_QSpinBox():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QSpinBox
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtWidgets as QtWidgets

        return QtWidgets.QSpinBox
    else:
        # IDA 9.2 and above
        import PySide6.QtWidgets as QtWidgets

        return QtWidgets.QSpinBox


def get_QFont():
    if idaapi.IDA_SDK_VERSION <= 680:
        import PySide.QtGui as QtGui

        return QtGui.QFont
    elif 680 < idaapi.IDA_SDK_VERSION <= 910:
        import PyQt5.QtGui as QtGui

        return QtGui.QFont
    else:
        # IDA 9.2 and above
        import PySide6.QtGui as QtGui

        return QtGui.QFont

```

`helpers/ScoreColorProvider.py`:

```py
import math


class ScoreColorProvider(object):
    frequency_color_map = {
        # white
        0: (0xFF, 0xFF, 0xFF),
        # blue
        1: (0x10, 0x7F, 0xFC),
        # light blue
        2: (0x22, 0xFE, 0xFD),
        # green
        3: (0x1F, 0xFE, 0x28),
        # green yellow: (0xc1, 0xfe, 0x2f)
        # yellow
        4: (0xFF, 0xFF, 0x35),
        # light orange: (0xfe, 0xc1, 0x2c)
        # orange
        5: (0xFE, 0x82, 0x25),
        # light red:
        # 6: (0xfd, 0x46, 0x21),
        # red
        6: (0xFD, 0x1A, 0x20),
        # violet
        7: (0xB4, 0x00, 0xFF),
    }

    matching_color_map_50 = {
        # white
        0: (0xFF, 0xFF, 0xFF),
        # dark blue
        1: (0x00, 0x45, 0xBA),
        # blue
        2: (0x00, 0x80, 0xFF),
        # light blue
        3: (0x22, 0xFE, 0xFD),
        # green
        4: (0x1F, 0xFE, 0x28),
        # yellow
        5: (0xFF, 0xFF, 0x35),
        # orange
        6: (0xFE, 0x82, 0x25),
        # red
        7: (0xFD, 0x1A, 0x20),
    }

    def _calculateLogScore(self, cluster_size):
        if cluster_size == 0:
            return 0
        elif cluster_size == 1:
            return 1
        else:
            return 1 + int(math.log(cluster_size, 2))

    def _adjustOpacity(self, tup, opacity=1):
        return tuple(int(255 - opacity * (255 - e)) for e in tup)

    def frequencyToColor(self, count, opacity=1):
        top_color_tuple = self._adjustOpacity(
            self.frequency_color_map[max(self.frequency_color_map)], opacity
        )
        frequency = self._calculateLogScore(count)
        if frequency in self.frequency_color_map:
            top_color_tuple = self._adjustOpacity(self.frequency_color_map[frequency], opacity)
        return top_color_tuple

    def scoreToColor(self, score, opacity=1):
        if score > 100:
            return self._adjustOpacity(self.matching_color_map_50[1], opacity)
        elif score == 100:
            return self._adjustOpacity(self.matching_color_map_50[2], opacity)
        elif score >= 90:
            return self._adjustOpacity(self.matching_color_map_50[3], opacity)
        elif score >= 80:
            return self._adjustOpacity(self.matching_color_map_50[4], opacity)
        elif score >= 70:
            return self._adjustOpacity(self.matching_color_map_50[5], opacity)
        elif score >= 60:
            return self._adjustOpacity(self.matching_color_map_50[6], opacity)
        elif score >= 50:
            return self._adjustOpacity(self.matching_color_map_50[7], opacity)
        return self._adjustOpacity(self.frequency_color_map[0])

    def uniqueScoreToColor(self, score, opacity=0.4):
        if score is not None and score > 0:
            return self.scoreToColor(60, opacity=opacity)
        return self._adjustOpacity(self.frequency_color_map[0], opacity=1)

    def __init__(self) -> None:
        pass

```

`helpers/minimcrit/README.md`:

```md
# MiniMCRIT

This helper package internalizes central DTOs and the McritClient itself into this plugin, in order to remove excessive package dependencies.  
Package and class structure is identical to MCRIT itself.  
Changes include swapping the Levenshtein implementation to a pure Python variant and removing the MinHash dependencies (which incur numpy and more).  
MiniMCRIT will need to be updated whenever DTOs in core MCRIT are changed, which, however, is not expected to occur regularly.
```

`helpers/minimcrit/client/McritClient.py`:

```py
import functools
import time
import json
import logging
import datetime
from typing import Dict, List, Optional, Tuple

import requests
import urllib.parse
from helpers.minimcrit.storage.FamilyEntry import FamilyEntry
from helpers.minimcrit.storage.FunctionEntry import FunctionEntry
from helpers.minimcrit.storage.SampleEntry import SampleEntry
from helpers.minimcrit.queue.LocalQueue import Job
from smda.common.SmdaReport import SmdaReport
from smda.Disassembler import Disassembler


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)-7s - %(name)-36s - %(message)s"
)
LOGGER = logging.getLogger(__name__)


class JobTerminatedError(Exception):
    pass


def isJobTerminated(job):
    if job is None:
        return True

    return job.is_terminated


def isJobFailed(job):
    return (job is not None) and (job.is_failed)


def isJobFinishedTerminatedOrFailed(job):
    return isJobTerminated(job) or (job.result is not None) or isJobFailed(job)


def handle_response(response):
    data = None
    if response.status_code in [500, 501]:
        LOGGER.warning("McritClient received status code 500 from MCRIT.")
    elif response.status_code in [400, 404, 410]:
        # nothing to here as of now
        pass
    elif response.status_code in [200, 202]:
        json_response = response.json()
        if "status" in json_response and json_response["status"] == "successful":
            data = json_response["data"]
    return data


class McritClient:
    def __init__(self, mcrit_server=None, apitoken=None, username=None, raw_responses=False):
        self.mcrit_server = "http://localhost:8000"
        self.headers = {}
        self.raw = True if raw_responses else False
        if apitoken:
            self.headers.update({"apitoken": apitoken})
        if username:
            self.headers.update({"username": username})
        if mcrit_server is not None:
            self.mcrit_server = mcrit_server

    def setApitoken(self, apitoken):
        self.headers.update({"apitoken": apitoken})

    def setUsername(self, username):
        self.headers.update({"username": username})

    def _getMatchingRequestParams(
        self,
        minhash_threshold=None,
        pichash_size=None,
        force_recalculation=None,
        band_matches_required=None,
        exclude_self_matches=False,
        sample_group_only=False,
    ):
        params = {}
        if minhash_threshold is not None:
            params["minhash_score"] = minhash_threshold
        if pichash_size is not None:
            params["pichash_size"] = pichash_size
        if force_recalculation is not None:
            params["force_recalculation"] = force_recalculation
        if band_matches_required is not None:
            params["band_matches_required"] = band_matches_required
        if exclude_self_matches:
            params["exclude_self_matches"] = True
        if sample_group_only:
            params["sample_group_only"] = True
        return params

    def respawn(self):
        response = requests.post(f"{self.mcrit_server}/respawn", headers=self.headers)
        return handle_response(response)

    def completeMinhashes(self):
        response = requests.get(f"{self.mcrit_server}/complete_minhashes", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def rebuildIndex(self):
        response = requests.get(f"{self.mcrit_server}/rebuild_index", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def recalculatePicHashes(self):
        response = requests.get(f"{self.mcrit_server}/recalculate_pichashes", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def recalculateMinHashes(self):
        response = requests.get(f"{self.mcrit_server}/recalculate_minhashes", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def addReport(self, smda_report: SmdaReport) -> Tuple[SampleEntry, Optional[str]]:
        smda_json = smda_report.toDict()
        response = requests.post(
            f"{self.mcrit_server}/samples", json=smda_json, headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            if "job_id" in data:
                job_id = data["job_id"]
            else:
                job_id = None
            return SampleEntry.fromDict(data["sample_info"]), job_id

    def addBinarySample(
        self,
        binary: bytes,
        filename=None,
        family=None,
        version=None,
        is_dump=False,
        base_addr=None,
        bitness=None,
    ) -> Tuple[SampleEntry, Optional[str]]:
        query_fields = []
        if filename is not None:
            query_fields.append(f"filename={filename}")
        if family is not None:
            query_fields.append(f"family={family}")
        if version is not None:
            query_fields.append(f"version={version}")
        if is_dump:
            query_fields.append(f"is_dump=1")
        if base_addr is not None:
            query_fields.append(f"base_addr=0x{base_addr:x}")
        if bitness is not None and bitness in [32, 64]:
            query_fields.append(f"bitness={bitness}")
        query_string = ""
        if len(query_fields) > 0:
            query_string = "?" + "&".join(query_fields)
        response = requests.post(
            f"{self.mcrit_server}/samples/binary{query_string}", data=binary, headers=self.headers
        )
        return handle_response(response)

    ###########################################
    ### Families
    ###########################################

    def modifyFamily(self, family_id, family_name=None, is_library=None):
        update_dict = {}
        if family_name is not None:
            update_dict["family_name"] = family_name
        if is_library is not None:
            update_dict["is_library"] = is_library
        response = requests.put(
            f"{self.mcrit_server}/families/{family_id}", update_dict, headers=self.headers
        )
        return handle_response(response)

    def getFamily(self, family_id: int, with_samples=True) -> Optional[FamilyEntry]:
        """
        Get a FamilyEntry by its <family_id>
        Supported by mcritweb API pass-through
        """
        query_params = "?with_samples=true" if with_samples else "?with_samples=false"
        response = requests.get(
            f"{self.mcrit_server}/families/{family_id}{query_params}", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return FamilyEntry.fromDict(data)
        return None

    def getFamilies(self) -> Optional[Dict[int, FamilyEntry]]:
        """
        Get all FamilyEntry objects in a dict, with <family_id> as key
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/families", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return {i: FamilyEntry.fromDict(entry) for i, entry in data.items()}
        return None

    def isFamilyId(self, family_id) -> bool:
        """
        Check if a <family_id> is valid in MCRIT
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/families/{family_id}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return True
        return False

    def deleteFamily(self, family_id, keep_samples=False):
        query_params = "?keep_samples=true" if keep_samples else "?keep_samples=false"
        response = requests.delete(
            f"{self.mcrit_server}/families/{family_id}{query_params}", headers=self.headers
        )
        return handle_response(response)

    ###########################################
    ### Samples
    ###########################################

    def isSampleId(self, sample_id):
        """
        Check if a <sample_id> is valid in MCRIT
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/samples/{sample_id}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return True
        return False

    def modifySample(
        self, sample_id, family_name=None, version=None, component=None, is_library=None
    ):
        update_dict = {}
        if family_name is not None:
            update_dict["family_name"] = family_name
        if version is not None:
            update_dict["version"] = version
        if component is not None:
            update_dict["component"] = component
        if is_library is not None:
            update_dict["is_library"] = is_library
        response = requests.put(
            f"{self.mcrit_server}/samples/{sample_id}", update_dict, headers=self.headers
        )
        return handle_response(response)

    def deleteSample(self, sample_id):
        response = requests.delete(f"{self.mcrit_server}/samples/{sample_id}", headers=self.headers)
        return handle_response(response)

    def getSamplesByFamilyId(self, family_id: int) -> Optional[List[SampleEntry]]:
        family_data = self.getFamily(family_id)
        if family_data is not None:
            return family_data.samples

    def getSampleById(self, sample_id):
        """
        Get a SampleEntry by its <sample_id>
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/samples/{sample_id}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return SampleEntry.fromDict(data)

    def getSamples(self, start=0, limit=0):
        """
        Get all SampleEntries, optionally from sample_id <start> and up to <limit> many
        Supported by mcritweb API pass-through
        """
        query_string = ""
        if (isinstance(start, int) and start >= 0) and (isinstance(limit, int) and limit >= 0):
            query_string = f"?start={start}&limit={limit}"
        response = requests.get(f"{self.mcrit_server}/samples{query_string}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return {int(k): SampleEntry.fromDict(v) for k, v in data.items()}

    ###########################################
    ### Functions
    ###########################################

    def getFunctionsBySampleId(self, sample_id):
        """
        Get a all FunctionEntries for a given <sample_id>
        Supported by mcritweb API pass-through
        """
        response = requests.get(
            f"{self.mcrit_server}/samples/{sample_id}/functions", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return [
                FunctionEntry.fromDict(function_entry_dict) for function_entry_dict in data.values()
            ]

    def getFunctions(self, start=0, limit=0):
        """
        Get a all FunctionEntries, optionally from sample_id <start> and up to <limit> many
        Supported by mcritweb API pass-through
        """
        query_string = ""
        if (isinstance(start, int) and start >= 0) and (isinstance(limit, int) and limit >= 0):
            query_string = f"?start={start}&limit={limit}"
        response = requests.get(
            f"{self.mcrit_server}/functions{query_string}", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return {int(k): FunctionEntry.fromDict(v) for k, v in data.items()}

    def getFunctionsByIds(self, function_ids: list, with_label_only=False):
        """
        Get all FunctionEntries identified by the provided list of function_ids
        Supported by mcritweb API pass-through
        """
        query_with_label_only = "?with_label_only=True" if with_label_only else ""
        function_id_string = ",".join(["%d" % fid for fid in function_ids])
        response = requests.post(
            f"{self.mcrit_server}/functions{query_with_label_only}",
            data=function_id_string,
            headers=self.headers,
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return {int(k): FunctionEntry.fromDict(v) for k, v in data.items()}
        return {}

    def isFunctionId(self, function_id):
        """
        Check if a <function_id> is valid in MCRIT
        Supported by mcritweb API pass-through
        """
        response = requests.get(
            f"{self.mcrit_server}/functions/{function_id}", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if self.raw:
            return data
        if data is not None:
            return True
        return False

    def getFunctionById(self, function_id: int, with_xcfg=False) -> Optional[FunctionEntry]:
        """
        Get a FunctionEntry by its <function_id>
        Supported by mcritweb API pass-through
        """
        query_with_xcfg = "?with_xcfg=True" if with_xcfg else ""
        response = requests.get(
            f"{self.mcrit_server}/functions/{function_id}{query_with_xcfg}", headers=self.headers
        )
        data = handle_response(response)
        if self.raw:
            return response
        if data is not None:
            return FunctionEntry.fromDict(data)

    def completeMinhashes(self):
        response = requests.get(f"{self.mcrit_server}/complete_minhashes", headers=self.headers)
        return handle_response(response)

    ###########################################
    ### Matching
    ###########################################

    def requestMatchesForSmdaReport(
        self,
        smda_report: SmdaReport,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        force_recalculation=False,
    ) -> str:
        smda_json = smda_report.toDict()
        params = self._getMatchingRequestParams(
            minhash_threshold, pichash_size, force_recalculation, band_matches_required
        )
        response = requests.post(
            f"{self.mcrit_server}/query", json=smda_json, headers=self.headers, params=params
        )
        if self.raw:
            return response
        return handle_response(response)

    def requestMatchesForMappedBinary(
        self,
        binary: bytes,
        base_address: int,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        disassemble_locally=True,
        force_recalculation=False,
    ) -> str:
        if disassemble_locally:
            disassembler = Disassembler()
            smda_report = disassembler.disassembleBuffer(binary, base_address)
            if smda_report.status == "error":
                return None
            return self.requestMatchesForSmdaReport(
                smda_report,
                minhash_threshold=minhash_threshold,
                pichash_size=pichash_size,
                band_matches_required=band_matches_required,
                force_recalculation=force_recalculation,
            )

        params = self._getMatchingRequestParams(
            minhash_threshold, pichash_size, force_recalculation, band_matches_required
        )
        response = requests.post(
            f"{self.mcrit_server}/query/binary/mapped/{base_address}",
            binary,
            headers=self.headers,
            params=params,
        )
        if self.raw:
            return response
        return handle_response(response)

    def requestMatchesForUnmappedBinary(
        self,
        binary: bytes,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        disassemble_locally=True,
        force_recalculation=False,
    ) -> str:
        if disassemble_locally:
            disassembler = Disassembler()
            smda_report = disassembler.disassembleUnmappedBuffer(binary)
            if smda_report.status == "error":
                return None
            return self.requestMatchesForSmdaReport(
                smda_report,
                minhash_threshold=minhash_threshold,
                pichash_size=pichash_size,
                band_matches_required=band_matches_required,
                force_recalculation=force_recalculation,
            )

        params = self._getMatchingRequestParams(
            minhash_threshold, pichash_size, force_recalculation, band_matches_required
        )

        response = requests.post(
            f"{self.mcrit_server}/query/binary", binary, headers=self.headers, params=params
        )
        if self.raw:
            return response
        return handle_response(response)

    def requestMatchesForSample(
        self,
        sample_id,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        force_recalculation=False,
    ) -> None:
        params = self._getMatchingRequestParams(
            minhash_threshold, pichash_size, force_recalculation, band_matches_required
        )
        response = requests.get(
            f"{self.mcrit_server}/matches/sample/{sample_id}", headers=self.headers, params=params
        )
        if self.raw:
            return response
        return handle_response(response)

    def requestMatchesForSampleVs(
        self,
        sample_id,
        other_sample_id,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        force_recalculation=False,
    ) -> str:
        params = self._getMatchingRequestParams(
            minhash_threshold, pichash_size, force_recalculation, band_matches_required
        )
        response = requests.get(
            f"{self.mcrit_server}/matches/sample/{sample_id}/{other_sample_id}",
            headers=self.headers,
            params=params,
        )
        if self.raw:
            return response
        return handle_response(response)

    def requestMatchesCross(
        self,
        sample_ids,
        sample_group_only=False,
        minhash_threshold=None,
        pichash_size=None,
        band_matches_required=None,
        force_recalculation=False,
    ) -> None:
        params = self._getMatchingRequestParams(
            minhash_threshold,
            pichash_size,
            force_recalculation,
            band_matches_required,
            sample_group_only=sample_group_only,
        )
        response = requests.get(
            f"{self.mcrit_server}/matches/sample/cross/{','.join([str(id) for id in sample_ids])}",
            headers=self.headers,
            params=params,
        )
        if self.raw:
            return response
        return handle_response(response)

    def getMatchFunctionVs(self, function_id_a: int, function_id_b: int) -> None:
        response = requests.get(
            f"{self.mcrit_server}/matches/function/{function_id_a}/{function_id_b}",
            headers=self.headers,
        )
        if self.raw:
            return response
        return handle_response(response)

    def getMatchesForSmdaFunction(
        self,
        smda_report,
        minhash_threshold=None,
        pichash_size=None,
        force_recalculation=None,
        band_matches_required=None,
        exclude_self_matches=False,
    ):
        """
        Get all matches for a SmdaReport with a single SmdaFunction
        Supported by mcritweb API pass-through
        """
        # TODO add the same parameter possibilities that are used for regular full matching jobs
        params = self._getMatchingRequestParams(
            minhash_threshold,
            pichash_size,
            force_recalculation,
            band_matches_required,
            exclude_self_matches,
        )
        response = requests.post(
            f"{self.mcrit_server}/query/function",
            json=smda_report.toDict(),
            headers=self.headers,
            params=params,
        )
        if self.raw:
            return response
        return handle_response(response)

    def getMatchesForPicHash(self, pichash, summary=False):
        """
        Get all matches for a given <pichash>, optionally only as <summary>
        Supported by mcritweb API pass-through
        """
        summary_string = "/summary" if summary else ""
        response = requests.get(
            f"{self.mcrit_server}/query/pichash/{pichash:016x}{summary_string}",
            headers=self.headers,
        )
        if self.raw:
            return response
        return handle_response(response)

    def getMatchesForPicBlockHash(self, picblockhash, summary=False):
        """
        Get all matches for a given <picblockhash>, optionally only as <summary>
        Supported by mcritweb API pass-through
        """
        summary_string = "/summary" if summary else ""
        response = requests.get(
            f"{self.mcrit_server}/query/picblockhash/{picblockhash:016x}{summary_string}",
            headers=self.headers,
        )
        if self.raw:
            return response
        return handle_response(response)

    def getSampleBySha256(self, sample_sha256: str):
        """
        Get a SampleEntry by its <sha256>
        Supported by mcritweb API pass-through
        """
        response = requests.get(
            f"{self.mcrit_server}/samples/sha256/{sample_sha256}", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is None:
            return None
        return SampleEntry.fromDict(data)

    ###########################################
    ### Status, Results
    ###########################################

    def getStatus(self, with_pichash=True):
        """
        Get a status report of the MCRIT server with some statistics
        Supported by mcritweb API pass-through
        """
        query_string = ""
        if with_pichash:
            query_string = f"?with_pichash=True"
        response = requests.get(f"{self.mcrit_server}/status{query_string}", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def getVersion(self):
        """
        Get a version report of the MCRIT server
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/version", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if isinstance(data, dict) and "version" in data:
            return data["version"]
        return None

    def getJobCount(self, filter=None):
        query_string = ""
        if isinstance(filter, str) and filter is not None:
            if len(query_string) == 0:
                query_string = f"?filter={filter}"
            else:
                query_string += f"&filter={filter}"
        response = requests.get(f"{self.mcrit_server}/jobs{query_string}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return len(data)

    def getQueueStatistics(self, with_refresh=False):
        """
        Get a summary of queue statistics
        Supported by mcritweb API pass-through
        """
        query_string = ""
        if with_refresh:
            if len(query_string) == 0:
                query_string = f"?with_refresh=True"
        response = requests.get(
            f"{self.mcrit_server}/jobs/stats/{query_string}", headers=self.headers
        )
        if self.raw:
            return response
        return handle_response(response)

    def getQueueData(self, start=0, limit=0, method=None, filter=None, state=None, ascending=False):
        """
        Get queue data, optionally from <start> and <limit> many
        Supported by mcritweb API pass-through
        """
        query_string = "?ascending=True" if ascending else ""
        if isinstance(start, int) and start > 0:
            if len(query_string) == 0:
                query_string = f"?start={start}"
            else:
                query_string += f"&start={start}"
        if isinstance(limit, int) and limit > 0:
            if len(query_string) == 0:
                query_string = f"?limit={limit}"
            else:
                query_string += f"&limit={limit}"
        if isinstance(method, str) and method is not None:
            if len(query_string) == 0:
                query_string = f"?method={method}"
            else:
                query_string += f"&method={method}"
        if isinstance(filter, str) and filter is not None:
            if len(query_string) == 0:
                query_string = f"?filter={filter}"
            else:
                query_string += f"&filter={filter}"
        if isinstance(state, str) and state is not None:
            if len(query_string) == 0:
                query_string = f"?state={state}"
            else:
                query_string += f"&state={state}"
        response = requests.get(f"{self.mcrit_server}/jobs/{query_string}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return [Job(job_data, None) for job_data in data]

    def deleteQueueData(self, method=None, created_before=None, finished_before=None):
        """
        Delete Jobs that match given provided criteria
        Supported by mcritweb API pass-through
        """
        query_string = ""
        if isinstance(method, str) and method is not None:
            if len(query_string) == 0:
                query_string = f"?method={method}"
            else:
                query_string += f"&method={method}"
        if isinstance(created_before, datetime.datetime) and created_before is not None:
            if len(query_string) == 0:
                query_string = f"?created_before={created_before.strftime('%Y-%m-%dT%H:%M:%S')}"
            else:
                query_string += f"&created_before={created_before.strftime('%Y-%m-%dT%H:%M:%S')}"
        if isinstance(finished_before, datetime.datetime) and finished_before is not None:
            if len(query_string) == 0:
                query_string = f"?finished_before={finished_before.strftime('%Y-%m-%dT%H:%M:%S')}"
            else:
                query_string += f"&finished_before={finished_before.strftime('%Y-%m-%dT%H:%M:%S')}"
        response = requests.delete(f"{self.mcrit_server}/jobs/{query_string}", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def deleteJob(self, job_id):
        """
        Delete the Job for a given <job_id>
        Supported by mcritweb API pass-through
        """
        response = requests.delete(f"{self.mcrit_server}/jobs/{job_id}", headers=self.headers)
        if self.raw:
            return response
        return handle_response(response)

    def getJobData(self, job_id):
        """
        Get the Job for a given <job_id>
        Supported by mcritweb API pass-through
        """
        response = requests.get(f"{self.mcrit_server}/jobs/{job_id}", headers=self.headers)
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return Job(data, None)

    def getResultForJob(self, job_id, compact=False):
        """
        Get the Result for Job with a given <job_id>
        Supported by mcritweb API pass-through
        """
        query_string = "?compact=True" if compact else ""
        response = requests.get(
            f"{self.mcrit_server}/jobs/{job_id}/result{query_string}", headers=self.headers
        )
        if self.raw:
            return response
        return handle_response(response)

    def getResult(self, result_id, compact=False):
        """
        Get the Result for a given <result_id>
        Supported by mcritweb API pass-through
        """
        query_string = "?compact=True" if compact else ""
        response = requests.get(
            f"{self.mcrit_server}/results/{result_id}{query_string}", headers=self.headers
        )
        if self.raw:
            return response
        return handle_response(response)

    def getJobForResult(self, result_id):
        """
        Get the Job for the Result with a given <result_id>
        Supported by mcritweb API pass-through
        """
        response = requests.get(
            f"{self.mcrit_server}/results/{result_id}/job", headers=self.headers
        )
        if self.raw:
            return response
        data = handle_response(response)
        if data is not None:
            return Job(data, None)

    def awaitResult(self, job_id, sleep_time=2, compact=False):
        if job_id is None:
            return None
        job = self.getJobData(job_id)
        while not isJobFinishedTerminatedOrFailed(job):
            time.sleep(sleep_time)
            job = self.getJobData(job_id)
        if isJobTerminated(job):
            raise JobTerminatedError
        result_id = job.result
        return self.getResult(result_id, compact=compact)

    ###########################################
    ### Import / Export
    ###########################################

    def getExportData(self, sample_ids=None, compress_data=True) -> dict:
        compress_uri_param = "?compress=True" if compress_data else ""
        result_data = {}
        if sample_ids is not None:
            if isinstance(sample_ids, list) and all(isinstance(item, int) for item in sample_ids):
                sample_ids_as_str = ",".join([str(sample_id) for sample_id in sample_ids])
                response = requests.get(
                    f"{self.mcrit_server}/export/{sample_ids_as_str}{compress_uri_param}",
                    headers=self.headers,
                )
                result_data = handle_response(response)
            else:
                raise ValueError("sample_ids must be a list of int.")
        else:
            response = requests.get(
                f"{self.mcrit_server}/export{compress_uri_param}", headers=self.headers
            )
            result_data = handle_response(response)
        return result_data

    def addImportData(self, import_data):
        if not isinstance(import_data, dict):
            raise ValueError("Can only forward dictionaries with export data.")
        response = requests.post(
            f"{self.mcrit_server}/import", json=import_data, headers=self.headers
        )
        return handle_response(response)

    ###########################################
    ### Unique Blocks
    ###########################################

    def requestUniqueBlocksForSamples(self, sample_ids: List[int]) -> Dict:
        if isinstance(sample_ids, list) and all(isinstance(item, int) for item in sample_ids):
            sample_ids_as_str = ",".join([str(sample_id) for sample_id in sample_ids])
            response = requests.get(
                f"{self.mcrit_server}/uniqueblocks/samples/{sample_ids_as_str}",
                headers=self.headers,
            )
            result_data = handle_response(response)
        else:
            raise ValueError("sample_ids must be a list of int.")
        return result_data

    def requestUniqueBlocksForFamily(self, family_id: int) -> Dict:
        if isinstance(family_id, int):
            response = requests.get(
                f"{self.mcrit_server}/uniqueblocks/family/{family_id}", headers=self.headers
            )
            result_data = handle_response(response)
        else:
            raise ValueError("sample_ids must be a list of int.")
        return result_data

    ###########################################
    ### Search
    ###########################################

    # When performing an initial search, the cursor should be set to None.
    # Search results are of the following form:
    # {
    #     "search_results": {
    #         id1: found_entry1,
    #         id2: found_entry2,
    #         ...
    #     },
    #     "cursor": {
    #         "forward": forward cursor,
    #         "backward": backward cursor,
    #     }
    # }
    # To get further results, perform a search using the forward cursor.
    # To get back to the previous search results, use the backward cursor.
    # If no further or previous results are available, the forward or backward cursor will be None.
    #
    # IMPORTANT: A cursor shall only be used in combination with the same
    # search_term, is_ascending and sort_by value that were used when the cursor was returned from mcrit.
    # If those parameters are altered, mcrit's behavior is undefined.

    def _search_base(
        self, search_kind, search_term, cursor=None, is_ascending=True, sort_by=None, limit=None
    ):
        params = {
            "query": search_term,
            "is_ascending": is_ascending,
        }
        if cursor is not None:
            params["cursor"] = cursor
        if sort_by is not None:
            params["sort_by"] = sort_by
        if limit is not None:
            params["limit"] = limit
        encoded_params = urllib.parse.urlencode(params)
        response = requests.get(
            f"{self.mcrit_server}/search/{search_kind}?{encoded_params}", headers=self.headers
        )
        return handle_response(response)

    search_families = functools.partialmethod(_search_base, "families")

    search_samples = functools.partialmethod(_search_base, "samples")

    search_functions = functools.partialmethod(_search_base, "functions")

```

`helpers/minimcrit/libs/graph.py`:

```py
from collections import defaultdict


class Graph:
    # straightforward implementation to enable us to do DFS to find clusters in undirected graphs
    # credit: Neelam Yadav
    # https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/
    def __init__(self):
        self.graph = defaultdict(list)

    def addNode(self, v):
        self.graph[v].append(v)

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def DFSUtil(self, v, visited):
        visited.add(v)
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)

    def DFS(self, v):
        visited = set()
        self.DFSUtil(v, visited)
        return visited

```

`helpers/minimcrit/libs/utility.py`:

```py
import io
import json
import base64
import string
import zipfile


def generate_unique_pairs(data):
    """For a given list of items, yield a list of unique, size-sorted pairs"""
    sorted_data = sorted(data)
    for index_a, data_a in enumerate(sorted_data):
        for _, data_b in enumerate(sorted_data[index_a + 1 :]):
            yield data_a, data_b


def generate_unique_groups(data):
    """For a given list of items, yield a list of unique, size-sorted groups"""
    sorted_data = sorted(data)
    for index_a, data_a in enumerate(sorted_data):
        group_b = []
        for _, data_b in enumerate(sorted_data[index_a + 1 :]):
            group_b.append(data_b)
        if group_b:
            yield data_a, group_b


def occurrences(string, sub):
    # https://stackoverflow.com/a/2970542
    count = start = 0
    while True:
        start = string.find(sub, start) + 1
        if start > 0:
            count += 1
        else:
            return count


def generate_segmented_sequence(weights, sequence_length):
    sequence = []
    sum_of_weights = sum([value for value in weights.values()])
    for key, weight in sorted(weights.items(), key=lambda x: x[1]):
        num_entries = int(weight / sum_of_weights * sequence_length)
        for _ in range(num_entries):
            sequence.append(key)
    if weights and len(sequence) < sequence_length:
        sequence.append(key)
    return sequence


def compress_encode(content):
    zip_buffer = io.BytesIO()
    zip_base64 = ""
    with zipfile.ZipFile(zip_buffer, "a", zipfile.ZIP_DEFLATED, False) as zip_file:
        zip_file.writestr("content", content)
    zip_base64 = base64.b85encode(zip_buffer.getvalue()).decode()
    return zip_base64


def decompress_decode(compressed_b64):
    de_b64ed = base64.b85decode(compressed_b64)
    zip_buffer = io.BytesIO(de_b64ed)
    decompressed = ""
    with zipfile.ZipFile(zip_buffer, "r", zipfile.ZIP_DEFLATED, False) as zip_file:
        decompressed = zip_file.read("content")
    return decompressed


def encode_two_complement(unit64):
    if unit64 > 0x7FFFFFFFFFFFFFFF:
        return unit64 - 0x10000000000000000
    return unit64


def decode_two_complement(int64):
    if int64 < 0:
        return int64 + 0x10000000000000000
    return int64

```

`helpers/minimcrit/matchers/FunctionCfgMatcher.py`:

```py
import struct
import hashlib
import logging

from smda.intel.IntelInstructionEscaper import IntelInstructionEscaper

import helpers.pylev


class FunctionCfgMatcher(object):
    def __init__(self, sample_entry_a, smda_function_a, sample_entry_b, smda_function_b) -> None:
        """
        Initialize with two smda_functions and their respective sample_entries or smda_reports (only needed for base_addr and binary_size)
        """
        self.sample_entry_a = sample_entry_a
        self.sample_entry_b = sample_entry_b
        self.smda_function_a = smda_function_a
        self.smda_function_b = smda_function_b
        self.match_colors = {
            # based on hashing
            "regular_pic": "#00DDFF",
            "small_pic": "#C0F4FF",
            "escaped": "#00ff00",
            # based on distance function
            0: "#40ff40",
            1: "#c0ff80",
            2: "#FFFF40",
            3: "#FFCC40",
            99: "#FFA0A0",
        }

    @staticmethod
    def getPicBlockHashesForFunction(sample_entry, smda_function, min_size=0):
        pic_block_hashes = []
        for block in smda_function.getBlocks():
            if block.length >= min_size:
                escaped_binary_seq = []
                for instruction in block.getInstructions():
                    escaped_binary_seq.append(
                        instruction.getEscapedBinary(
                            IntelInstructionEscaper,
                            escape_intraprocedural_jumps=True,
                            lower_addr=sample_entry.base_addr,
                            upper_addr=sample_entry.base_addr + sample_entry.binary_size,
                        )
                    )
                as_bytes = bytes([ord(c) for c in "".join(escaped_binary_seq)])
                hashed = struct.unpack("Q", hashlib.sha256(as_bytes).digest()[:8])[0]
                pic_block_hashes.append(
                    {"offset": block.offset, "hash": hashed, "size": block.length}
                )
        return pic_block_hashes

    def getAllPicblockMatches(self):
        node_colors = {"a": {}, "b": {}}
        all_phbs_a = []
        for block in self.smda_function_a.getBlocks():
            escaped_binary_seq = []
            for instruction in block.getInstructions():
                escaped_binary_seq.append(
                    instruction.getEscapedBinary(
                        IntelInstructionEscaper,
                        escape_intraprocedural_jumps=True,
                        lower_addr=self.sample_entry_a.base_addr,
                        upper_addr=self.sample_entry_a.base_addr + self.sample_entry_a.binary_size,
                    )
                )
            as_bytes = bytes([ord(c) for c in "".join(escaped_binary_seq)])
            hashed = struct.unpack("Q", hashlib.sha256(as_bytes).digest()[:8])[0]
            all_phbs_a.append({"offset": block.offset, "hash": hashed, "size": block.length})
        all_phbs_b = []
        for block in self.smda_function_b.getBlocks():
            escaped_binary_seq = []
            for instruction in block.getInstructions():
                escaped_binary_seq.append(
                    instruction.getEscapedBinary(
                        IntelInstructionEscaper,
                        escape_intraprocedural_jumps=True,
                        lower_addr=self.sample_entry_b.base_addr,
                        upper_addr=self.sample_entry_b.base_addr + self.sample_entry_b.binary_size,
                    )
                )
            as_bytes = bytes([ord(c) for c in "".join(escaped_binary_seq)])
            hashed = struct.unpack("Q", hashlib.sha256(as_bytes).digest()[:8])[0]
            all_phbs_b.append({"offset": block.offset, "hash": hashed, "size": block.length})
        phb_a = set([pbh["hash"] for pbh in all_phbs_a])
        phb_b = set([pbh["hash"] for pbh in all_phbs_b])
        phb_match_addr_a = [
            (pbh["offset"], pbh["size"])
            for pbh in all_phbs_a
            if pbh["hash"] in phb_a.intersection(phb_b)
        ]
        phb_match_addr_b = [
            (pbh["offset"], pbh["size"])
            for pbh in all_phbs_b
            if pbh["hash"] in phb_a.intersection(phb_b)
        ]
        for addr, size in phb_match_addr_a:
            if size >= 4:
                node_colors["a"][f"Node0x{addr:x}"] = self.match_colors["regular_pic"]
            else:
                node_colors["a"][f"Node0x{addr:x}"] = self.match_colors["small_pic"]
        for addr, size in phb_match_addr_b:
            if size >= 4:
                node_colors["b"][f"Node0x{addr:x}"] = self.match_colors["regular_pic"]
            else:
                node_colors["b"][f"Node0x{addr:x}"] = self.match_colors["small_pic"]
        return node_colors

    def getEscapedMatches(self):
        node_colors = {"a": {}, "b": {}}
        all_escapes_a = []
        for block in self.smda_function_a.getBlocks():
            escaped_ins_seq = []
            for instruction in block.getInstructions():
                escaped_ins = (
                    IntelInstructionEscaper.escapeMnemonic(instruction.mnemonic)
                    + " "
                    + IntelInstructionEscaper.escapeOperands(instruction)
                )
                escaped_ins_seq.append(escaped_ins)
            merged = ";".join(escaped_ins_seq)
            # print("0x%x" % block.offset, merged)
            hashed = struct.unpack("Q", hashlib.sha256(merged.encode("ascii")).digest()[:8])[0]
            all_escapes_a.append({"offset": block.offset, "hash": hashed})
        all_escapes_b = []
        for block in self.smda_function_b.getBlocks():
            escaped_ins_seq = []
            for instruction in block.getInstructions():
                escaped_ins = (
                    IntelInstructionEscaper.escapeMnemonic(instruction.mnemonic)
                    + " "
                    + IntelInstructionEscaper.escapeOperands(instruction)
                )
                escaped_ins_seq.append(escaped_ins)
            merged = ";".join(escaped_ins_seq)
            # print("0x%x" % block.offset, merged)
            hashed = struct.unpack("Q", hashlib.sha256(merged.encode("ascii")).digest()[:8])[0]
            all_escapes_b.append({"offset": block.offset, "hash": hashed})
        phb_a = set([pbh["hash"] for pbh in all_escapes_a])
        phb_b = set([pbh["hash"] for pbh in all_escapes_b])
        phb_match_addr_a = [
            pbh["offset"] for pbh in all_escapes_a if pbh["hash"] in phb_a.intersection(phb_b)
        ]
        phb_match_addr_b = [
            pbh["offset"] for pbh in all_escapes_b if pbh["hash"] in phb_a.intersection(phb_b)
        ]
        for addr in phb_match_addr_a:
            node_colors["a"][f"Node0x{addr:x}"] = self.match_colors["escaped"]
        for addr in phb_match_addr_b:
            node_colors["b"][f"Node0x{addr:x}"] = self.match_colors["escaped"]
        return node_colors

    def getLevenshteinMatches(self, unmatched_nodes):
        node_colors = {"a": {}, "b": {}}
        # across all blocks in unmatched nodes, collect tokens and map to symbols
        # token -> symbol, like "M REG, REG" -> 0
        # we use symbols from chr(0x20) to chr(0x7e), i.e. up to 94 printables, which "should always be enough (TM)""
        alphabet = {}
        num_symbols = 0
        # offset -> symbolified block
        candidate_blocks_a = {}
        for block in self.smda_function_a.getBlocks():
            if block.offset not in unmatched_nodes["a"]:
                continue
            symbolified_block = ""
            for instruction in block.getInstructions():
                escaped_ins = (
                    instruction.mnemonic + " " + IntelInstructionEscaper.escapeOperands(instruction)
                )
                if escaped_ins not in alphabet:
                    alphabet[escaped_ins] = chr(0x30 + num_symbols)
                    num_symbols += 1
                    if num_symbols > 94:
                        raise Exception("Basic Block contains too many tokens to compare.")
                symbolified_block += alphabet[escaped_ins]
            candidate_blocks_a[block.offset] = symbolified_block
        candidate_blocks_b = {}
        for block in self.smda_function_b.getBlocks():
            if block.offset not in unmatched_nodes["b"]:
                continue
            symbolified_block = ""
            for instruction in block.getInstructions():
                escaped_ins = (
                    instruction.mnemonic + " " + IntelInstructionEscaper.escapeOperands(instruction)
                )
                if escaped_ins not in alphabet:
                    alphabet[escaped_ins] = chr(0x30 + num_symbols)
                    num_symbols += 1
                    if num_symbols > 94:
                        raise Exception("Basic Block contains too many tokens to compare.")
                symbolified_block += alphabet[escaped_ins]
            candidate_blocks_b[block.offset] = symbolified_block
        # print(alphabet)
        by_score = {0: [], 1: [], 2: [], 3: []}
        for block_a, symbols_a in candidate_blocks_a.items():
            for block_b, symbols_b in candidate_blocks_b.items():
                distance = helpers.pylev.levenshtein(symbols_a, symbols_b, score_cutoff=3)
                if distance < 4:
                    by_score[distance].append((block_a, block_b))
                    # print(f"0x{block_a:x} 0x{block_b:x}: {symbols_a} || {symbols_b} - {distance}")
        used_blocks = set()
        for score, pairs in by_score.items():
            for pair in pairs:
                block_a, block_b = pair
                if block_a not in used_blocks and block_b not in used_blocks:
                    node_colors["a"][f"Node0x{block_a:x}"] = score
                    node_colors["b"][f"Node0x{block_b:x}"] = score
                    used_blocks.add(block_a)
                    used_blocks.add(block_b)
        node_colors["a"] = {k: self.match_colors[v] for k, v in node_colors["a"].items()}
        node_colors["b"] = {k: self.match_colors[v] for k, v in node_colors["b"].items()}
        return node_colors

    def getColoredMatches(self):
        # thresholded edit distance match over escaped instruction sequence: green to orange
        node_colors = {"a": {}, "b": {}}
        # no match / base color: bleak red
        for block in self.smda_function_a.getBlocks():
            node_colors["a"][f"Node0x{block.offset:x}"] = self.match_colors[99]
        for block in self.smda_function_b.getBlocks():
            node_colors["b"][f"Node0x{block.offset:x}"] = self.match_colors[99]
        # escaped blocks matches
        escaped_block_matches = self.getEscapedMatches()
        node_colors["a"].update(escaped_block_matches["a"])
        node_colors["b"].update(escaped_block_matches["b"])
        # ad-hoc picblock match (small BB): bleak teal
        # full picblock match (regular BB>=4 instructions): teal
        smaller_picblock_matches = self.getAllPicblockMatches()
        node_colors["a"].update(smaller_picblock_matches["a"])
        node_colors["b"].update(smaller_picblock_matches["b"])
        # compare everything not colored by now using our adapted Levenshtein
        unmatched_nodes = {
            "a": [
                int(k[6:], 16) for k, v in node_colors["a"].items() if v == self.match_colors[99]
            ],
            "b": [
                int(k[6:], 16) for k, v in node_colors["b"].items() if v == self.match_colors[99]
            ],
        }
        levenshtein_matches = self.getLevenshteinMatches(unmatched_nodes)
        node_colors["a"].update(levenshtein_matches["a"])
        node_colors["b"].update(levenshtein_matches["b"])
        return node_colors

```

`helpers/minimcrit/matchers/MatcherFlags.py`:

```py
# Collection of flags, put in their own file to avoid tangled imports

IS_MINHASH_FLAG = 1
IS_PICHASH_FLAG = 1 << 1
IS_LIBRARY_FLAG = 1 << 2

```

`helpers/minimcrit/queue/LocalQueue.py`:

```py
from calendar import c
import json
import traceback
import uuid
import logging
from collections import defaultdict
from datetime import datetime, timedelta

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)-7s - %(name)-36s - %(message)s"
)
LOGGER = logging.getLogger(__name__)


# copied from mongoqueue
class Job(object):
    """
    This class is also used to represent jobs to the outside
    """

    def __init__(self, data, queue):
        self._data = data
        self._queue = queue
        # All currently known remote jobs as implemented in the Worker, redundantly organized by various aspects
        self.method_types = {
            "matching": [
                "getMatchesForSample",
                "getMatchesForSampleVs",
                "combineMatchesToCross",
            ],
            "query": [
                "getMatchesForUnmappedBinary",
                "getMatchesForMappedBinary",
                "getMatchesForSmdaReport",
            ],
            "blocks": [
                "getUniqueBlocks",
            ],
            "minhashing": [
                "updateMinHashesForSample",
                "updateMinHashes",
                "rebuildIndex",
            ],
            "collection": [
                "addBinarySample",
                "deleteSample",
                "modifySample",
                "deleteFamily",
                "modifyFamily",
            ],
            "sample_id": [
                "getMatchesForSampleVs",
                "getMatchesForSample",
                "updateMinHashesForSample",
                "deleteSample",
                "modifySample",
            ],
            "family_id": [
                "deleteFamily",
                "modifyFamily",
            ],
            "all": [
                "getMatchesForSample",
                "getMatchesForSampleVs",
                "combineMatchesToCross",
                "getMatchesForUnmappedBinary",
                "getMatchesForMappedBinary",
                "getMatchesForSmdaReport",
                "getUniqueBlocks",
                "updateMinHashesForSample",
                "updateMinHashes",
                "addBinarySample",
                "modifySample",
                "deleteSample",
                "modifyFamily",
                "deleteFamily",
                "rebuildIndex",
            ],
        }

    def __str__(self) -> str:
        return f"ID: {self.job_id} - {self.parameters} | created: {self.created_at}, finished: {self.finished_at}, result: {self.result}, progress: {self.progress}"

    @property
    def family(self) -> str:
        if self.method in ["addBinarySample"]:
            descriptor = json.loads(self._data["payload"]["descriptor"])
            return descriptor[1]["2"]

    @property
    def sha256(self) -> str:
        if self.method in [
            "getMatchesForUnmappedBinary",
            "getMatchesForMappedBinary",
            "getMatchesForSmdaReport",
            "addBinarySample",
        ]:
            descriptor = json.loads(self._data["payload"]["descriptor"])
            return descriptor[2]["0"]

    @property
    def filename(self) -> str:
        if self.method in ["addBinarySample"]:
            descriptor = json.loads(self._data["payload"]["descriptor"])
            return descriptor[1]["1"]

    @property
    def family_id(self):
        if self.method in self.method_types["family_id"]:
            return int(self.arguments[0])
        if self.method == "getUniqueBlocks":
            if len(self.arguments) > 1:
                return int(self.arguments[1])

    @property
    def has_family_id(self):
        if self.method in self.method_types["family_id"] or self.method == "getUniqueBlocks":
            return True
        return False

    @property
    def sample_ids(self):
        sample_ids = []
        if self.method == "combineMatchesToCross":
            sample_ids = [int(key) for key, value in self.arguments[0].items()]
        elif self.method == "getUniqueBlocks":
            sample_ids = [int(sid) for sid in self.arguments[0]]
        elif self.method in self.method_types["sample_id"]:
            sample_ids.append(int(self.arguments[0]))
            if self.method == "getMatchesForSampleVs":
                sample_ids.append(int(self.arguments[1]))
        elif self.sample_id is not None:
            sample_ids.append(self.sample_id)
        return set(list(sample_ids))

    @property
    def sample_id(self):
        if self.method in self.method_types["sample_id"]:
            return int(self.arguments[0])
        elif self.method == "updateMinHashesForSample":
            return int(self.arguments[0])
        elif self.method == "getUniqueBlocks":
            if len(self.arguments[0]) > 0:
                return int(self.arguments[0][0])
        elif self.method == "deleteSample":
            return int(self.arguments[0])
        elif self.method == "modifySample":
            return int(self.arguments[0])

    @property
    def other_sample_id(self):
        if self.method == "getMatchesForSampleVs":
            return int(self.arguments[1])

    def has_sample_id(self, sample_id: int):
        if self.method in self.method_types["sample_id"]:
            if self.method == "getMatchesForSampleVs":
                return int(self.arguments[0]) == sample_id or int(self.arguments[1]) == sample_id
            else:
                return int(self.arguments[0]) == sample_id

    @property
    def is_matching_job(self):
        if self.method in self.method_types["matching"]:
            return True
        return False

    @property
    def is_minhashing_job(self):
        if self.method in self.method_types["minhashing"]:
            return True
        return False

    @property
    def is_query_job(self):
        if self.method in self.method_types["query"]:
            return True
        return False

    @property
    def is_block_job(self):
        if self.method in self.method_types["blocks"]:
            return True
        return False

    @property
    def is_collection_job(self):
        if self.method in self.method_types["collection"]:
            return True
        return False

    @property
    def method(self):
        if "payload" in self._data and "method" in self._data["payload"]:
            return self._data["payload"]["method"]

    @property
    def payload(self):
        return self._data["payload"]

    @property
    def arguments(self):
        combined_values = []
        if (
            "payload" in self._data
            and "params" in self._data["payload"]
            and "method" in self._data["payload"]
        ):
            payload_params = json.loads(self._data["payload"]["params"])
            indexed_key_values = []
            named_key_values = []
            for k, v in payload_params.items():
                try:
                    int(k)
                    indexed_key_values.append(v)
                except:
                    named_key_values.append(v)
            combined_values = indexed_key_values + named_key_values
        return combined_values

    @property
    def parameters(self):
        method_str = ""
        if (
            "payload" in self._data
            and "params" in self._data["payload"]
            and "method" in self._data["payload"]
        ):
            method_str = self._data["payload"]["method"]
            method_str += "(" + ", ".join([str(v) for v in self.arguments]) + ")"
        return method_str

    @property
    def short_parameters(self):
        method_str = ""
        if (
            "payload" in self._data
            and "params" in self._data["payload"]
            and "method" in self._data["payload"]
        ):
            method_str = self._data["payload"]["method"]
            method_str += "(" + ", ".join([str(v) for v in self.arguments]) + ")"
            if len(method_str) > 50:
                method_str = method_str[:107] + "..." + ")"
        return method_str

    @property
    def all_dependencies(self):
        return self._data["all_dependencies"]

    @property
    def job_id(self):
        if isinstance(self._data["_id"], dict):
            return str(self._data["_id"]["$oid"])
        return self._data["_id"]

    @property
    def number(self):
        return self._data["number"] if "number" in self._data else -1

    @property
    def priority(self):
        return self._data["priority"]

    @property
    def attempts_left(self):
        return self._data["attempts_left"]

    @property
    def is_failed(self):
        return self._data["attempts_left"] == 0

    @property
    def locked_by(self):
        return self._data["locked_by"]

    @property
    def locked_at(self):
        if isinstance(self._data["locked_at"], dict):
            return str(self._data["locked_at"]["$date"])
        return self._data["locked_at"]

    @property
    def last_error(self):
        return self._data["last_error"]

    @property
    def finished_at(self):
        if isinstance(self._data["finished_at"], dict):
            return str(self._data["finished_at"]["$date"])
        return self._data["finished_at"]

    @property
    def is_finished(self):
        return self._data["finished_at"] is not None

    @property
    def duration(self):
        if self.is_finished:
            FMT = "%Y-%m-%d-%H:%M:%S"
            finished_at = self.finished_at[:10] + "-" + self.finished_at[11:19]
            started_at = self.started_at[:10] + "-" + self.started_at[11:19]
            duration = datetime.strptime(finished_at, FMT) - datetime.strptime(started_at, FMT)
            return duration
        return None

    @property
    def created_at(self):
        if isinstance(self._data["created_at"], dict):
            return str(self._data["created_at"]["$date"])
        return self._data["created_at"]

    @property
    def started_at(self):
        if isinstance(self._data["started_at"], dict):
            return str(self._data["started_at"]["$date"])
        return self._data["started_at"]

    @property
    def is_terminated(self):
        return self._is_terminated()

    @property
    def progress(self):
        return self._data["progress"] if "progress" in self._data else 0

    # NOTE: This is a GridFS id, not the actual result
    @property
    def result(self):
        return self._data["result"]

    @result.setter
    def result(self, res):
        self._data["result"] = res

    ## job control

    def complete(self, result=None):
        """job has been completed."""
        if result:
            self._data["result"] = result
        self._data["finished_at"] = datetime.now()
        self._data["progress"] = 1
        return self

    def error(self, message=None):
        """note an error processing a job, and return it to the queue."""
        self._data["locked_by"] = None
        self._data["locked_at"] = None
        self._data["last_error"] = message
        self._data["attempts_left"] -= 1

    def progressor(self, count=0):
        self._data["progress"] = count

    def __enter__(self):
        return self._data

    def __exit__(self, type, value, tb):
        if (type, value, tb) == (None, None, None):
            self.complete()
        else:
            error = traceback.format_exc()
            self.error(error)

    # only works for jobs that report progress
    # used_cached flag is useless for this kind of queue
    def _is_terminated(self, use_cached=False):
        terminated = self._data["terminated"]
        if terminated is None:
            return False
        return terminated

    # only works for jobs that report progress
    def terminate(self):
        self._data["terminated"] = True


class LocalQueue(object):
    def __init__(self):
        self._setup_empty_queue()
        self._worker = None
        self._job_counter = 0
        self.clean_interval = 10**9
        self.cache_time = 10**9
        self.max_attempts = 1

    def _setup_empty_queue(self):
        self._jobs = defaultdict(lambda: None)
        self._files = defaultdict(lambda: None)
        self._files_meta = defaultdict(lambda: None)
        self._descriptor_to_job = defaultdict(lambda: None)
        self._hash_to_file = defaultdict(lambda: None)

    def registerWorker(self):
        # left empty, as we only have one worker in local mode
        pass

    def unregisterWorker(self):
        # left empty, as we only have one worker in local mode
        pass

    def getQueueStatistics(self):
        # we don't track stats for the volatile local mode
        return {}

    def set_worker(self, worker):
        self._worker = worker

    def get_job(self, job_id):
        data = self._jobs[job_id]
        return data and Job(data, self)

    def get_jobs(
        self, start_index: int, limit: int, method=None, state=None, filter=None, ascencing=False
    ):
        # TODO implement all the filtering methods properly
        jobs = []
        for job_id, job_document in self._jobs.items():
            if method is not None and job_document["payload"]["method"] != method:
                continue
            jobs.append(Job(job_document, self))
        return jobs[start_index : start_index + limit]

    def get_cached_job_id(self, payload):
        return self._descriptor_to_job[payload["descriptor"]]

    def _file_to_grid(self, file, metadata=None):
        id = str(uuid.uuid4())
        try:
            file.seek(0)
            data = file.read()
        except AttributeError:
            if not isinstance(file, (str, bytes)):
                raise TypeError("Only strings, bytes or file-like objecs are supported")
            if isinstance(file, str):
                try:
                    data = data.encode(self.encoding)
                except AttributeError:
                    raise TypeError("no encoding was specified")
            else:
                data = file
        self._files[id] = data
        self._files_meta[id] = metadata
        try:
            self._hash_to_file[metadata["sha256"]] = id
        except:
            pass
        return id

    def _grid_to_file(self, grid, results_only=True):
        file = self._files[grid]
        if file is None:
            return None
        if results_only:
            metadata = self._files_meta[grid]
            if not "result" in metadata or not metadata["result"]:
                return b'"Access Not Allowed"'
        return file

    def get_file_by_hash_inc_lock(self, sha256):
        id = self._hash_to_file[sha256]
        self._inc_lock(id)
        return id

    def _get_file_by_hash(self, sha256):
        return self._hash_to_file[sha256]

    def _inc_lock(self, id):
        if id is None:
            return
        try:
            self._files_meta[id]["tmp_lock"] += 1
        except:
            pass

    def _dec_lock(self, id):
        if id is None:
            return
        try:
            self._files_meta[id]["tmp_lock"] -= 1
        except:
            pass

    def add_job_id_to_file(self, job_id, file_id):
        self._files_meta[file_id]["jobs"].append(job_id)
        self._dec_lock(file_id)

    def _dicts_to_grid(self, dicts, **kwargs):
        return self._file_to_grid(json.dumps(dicts).encode("ascii"), **kwargs)

    def _grid_to_dicts(self, grid, **kwargs):
        return json.loads(self._grid_to_file(grid, **kwargs).decode("ascii"))

    def _grid_to_meta(self, grid):
        return self._files_meta[grid]

    def _delete_grid(self, grid):
        meta = self._files_meta[grid]
        try:
            if self._hash_to_file[meta["sha256"]] == grid:
                del self._hash_to_file[meta["sha256"]]
        except:
            pass
        del self._files[grid]
        del self._files_meta[grid]

    def put(self, payload, await_jobs=[]):
        id = str(uuid.uuid4())
        job_data = defaultdict(lambda: None)
        job_data["_id"] = id
        job_data["number"] = self._job_counter
        self._job_counter += 1
        job_data["payload"] = payload
        job_data["unfinished_dependencies"] = await_jobs
        job_data["all_dependencies"] = await_jobs
        job_data["attempts_left"] = self.max_attempts
        job_data["created_at"] = datetime.now()
        self._jobs[id] = job_data
        self._descriptor_to_job[payload["descriptor"]] = id
        job_data["started_at"] = datetime.now()
        # NOTE: we can just ignore await jobs, because all jobs are
        #       executed in submission order
        self._worker._executeJob(Job(job_data, self))
        return id

    def clear(self):
        self.terminate_all_jobs()
        self._setup_empty_queue()

    def delete_job(self, id):
        if id not in self._jobs:
            return 0
        job = self._jobs[id]
        result = job["result"]
        file_params = json.loads(job["payload"]["file_params"])
        descriptor = job["payload"]["descriptor"]
        if self._descriptor_to_job[descriptor] == id:
            del self._descriptor_to_job[descriptor]
        del self._jobs[id]
        self._delete_grid(result)
        for f in file_params.values():
            meta = self._grid_to_meta(f)
            LOGGER.debug("Job meta: %s", meta)
            meta["jobs"].remove(id)
        return 1

    delete_history = []

    def delete_jobs(self, method=None, created_before=None, finished_before=None):
        delete_list = []
        deleted_count = 0
        for d in self._jobs.values():
            if d["payload"]["method"] is not None and d["payload"]["method"] != method:
                continue
            if d["created_at"] is not None and d["created_at"] >= finished_before:
                continue
            if d["finished_at"] is not None and d["finished_at"] >= finished_before:
                continue
            delete_list.append(d["_id"])
        for id in delete_list:
            deleted_count += self.delete_job(id)
        return deleted_count

    def clean(self):
        time_threshold = datetime.now() - timedelta(seconds=self.cache_time)
        delete_list = []
        for d in self._jobs.values():
            if (d["finished_at"] is not None) and d["finished_at"] < time_threshold:
                delete_list.append(d["_id"])

        self.delete_history.append(delete_list)
        LOGGER.debug("Perfomed clean, delete_history now has %d entries.", len(self.delete_history))

        for id in delete_list:
            self.delete_job(id)

        delete_list = []
        for id, meta in self._files_meta.items():
            if "result" in meta and meta["result"]:
                continue
            if len(meta["jobs"]) == 0 and meta["tmp_lock"] == 0:
                delete_list.append(id)
        for id in delete_list:
            self._delete_grid(id)

    def terminate_all_jobs(self):
        for job in self._jobs.values():
            if job["result"] is None:
                job["terminated"] = True

    def next(self):
        # this is a dummy, as we don't have an actual queue
        return None

```

`helpers/minimcrit/storage/FamilyEntry.py`:

```py
from typing import Dict, List, Optional

from helpers.minimcrit.storage.SampleEntry import SampleEntry


class FamilyEntry(object):
    family_id: int
    family_name: str
    num_samples: int
    num_functions: int
    num_library_samples: int
    # This is not supposed to be stored in storage
    samples: Optional[Dict[int, SampleEntry]]

    def __init__(
        self,
        family_name="",
        family_id=0,
        num_samples=0,
        num_functions=0,
        num_library_samples=0,
        samples=None,
    ):
        self.family_id = family_id
        self.family_name = family_name
        self.num_samples = num_samples
        self.num_functions = num_functions
        self.num_library_samples = num_library_samples
        self.samples = samples

    @property
    def is_library(self):
        return self.num_library_samples > 0

    @property
    def family(self):
        return self.family_name

    def toDict(self):
        family_entry = {
            "family_id": self.family_id,
            "family_name": self.family_name,
            "num_samples": self.num_samples,
            "num_functions": self.num_functions,
            "num_library_samples": self.num_library_samples,
        }
        if self.samples is not None:
            family_entry["samples"] = {id: sample.toDict() for id, sample in self.samples.items()}
        return family_entry

    @classmethod
    def fromDict(cls, entry_dict: Dict):
        family_entry = cls(None)  # type: ignore
        family_entry.family_id = entry_dict["family_id"]
        family_entry.family_name = entry_dict["family_name"]
        family_entry.num_samples = entry_dict["num_samples"]
        family_entry.num_functions = entry_dict["num_functions"]
        family_entry.num_library_samples = entry_dict["num_library_samples"]
        samples = entry_dict.get("samples", None)
        if samples is not None:
            family_entry.samples = {
                id: SampleEntry.fromDict(sample) for id, sample in samples.items()
            }
        return family_entry

    def __str__(self):
        return "Famliy {} ({}): ".format(self.family_id, self.family_name)

```

`helpers/minimcrit/storage/FunctionEntry.py`:

```py
from typing import TYPE_CHECKING, Dict, Optional

from smda.common.BinaryInfo import BinaryInfo
from smda.common.SmdaFunction import SmdaFunction

from helpers.minimcrit.libs.utility import encode_two_complement, decode_two_complement
from helpers.minimcrit.storage.FunctionLabelEntry import FunctionLabelEntry

if TYPE_CHECKING:  # pragma: no cover
    from helpers.minimcrit.storage.SampleEntry import SampleEntry
    from smda.common.SmdaFunction import SmdaFunction

# Dataclass, post init
# constructor -> .fromSmdaFunction
# assume sample_entry, smda_function always available

# TODO remove (everywhere) from alchemy function


class FunctionEntry(object):
    # MCRIT specific
    function_id: int
    family_id: int
    sample_id: int
    minhash: bytes  # TODO rename -> minhash_bytes? minhash_hex?
    minhash_shingle_composition: Dict = None  # FIXME MongoDbStorage fails without this, ... why?
    # inherited from sample
    architecture: str
    # smda information
    function_name: str
    function_labels: list
    matches: Dict
    pichash: int
    picblockhashes: list
    num_blocks: int
    num_instructions: int
    binweight: float
    offset: int
    xcfg: Dict

    def __init__(
        self,
        sample_entry: "SampleEntry",
        smda_function: "SmdaFunction",
        function_id: int,
        minhash: bytes = None,
    ) -> None:
        self.function_id = function_id
        if sample_entry:
            self.family_id = sample_entry.family_id
            self.sample_id = sample_entry.sample_id
            self.architecture = sample_entry.architecture
        if smda_function:
            self.num_blocks = smda_function.num_blocks
            self.num_instructions = smda_function.num_instructions
            self.binweight = smda_function.binweight
            self.offset = smda_function.offset
            self.xcfg = smda_function.toDict()
            self.function_name = smda_function.function_name
            self.pichash = smda_function.pic_hash
            self.picblockhashes = []
        self.function_labels = []
        self.matches = {}
        self.minhash = None
        self.shingler_composition = {}

    def getMinHash(self, minhash_bits=32):
        return None

    def toSmdaFunction(self):
        binary_info = BinaryInfo(b"")
        binary_info.architecture = self.architecture
        return SmdaFunction.fromDict(self.xcfg, binary_info=binary_info)

    def toDict(self):
        minhash = None
        shingler_composition = {}
        function_entry = {
            "architecture": self.architecture,
            "binweight": self.binweight,
            "family_id": self.family_id,
            "function_id": self.function_id,
            "function_name": self.function_name,
            "function_labels": [l.toDict() for l in self.function_labels],
            "matches": self.matches,
            "minhash": minhash,
            "minhash_shingle_composition": shingler_composition,
            "num_blocks": self.num_blocks,
            "num_instructions": self.num_instructions,
            "offset": encode_two_complement(self.offset),
            "pichash": self.pichash,
            "picblockhashes": self.picblockhashes,
            "sample_id": self.sample_id,
            "xcfg": self.xcfg,
        }
        return function_entry

    @classmethod
    def fromDict(cls, entry_dict):
        function_entry = cls(None, None, entry_dict["function_id"])  # type: ignore
        function_entry.family_id = entry_dict["family_id"]
        # function_entry.function_id = entry_dict["function_id"]
        function_entry.sample_id = entry_dict["sample_id"]
        function_entry.architecture = entry_dict["architecture"]
        function_entry.function_name = entry_dict["function_name"]
        function_entry.function_labels = (
            [FunctionLabelEntry.fromDict(l) for l in entry_dict["function_labels"]]
            if "function_labels" in entry_dict
            else []
        )
        for label in function_entry.function_labels:
            label.setFunctionId(entry_dict["function_id"])
        function_entry.matches = entry_dict["matches"]
        function_entry.pichash = entry_dict["pichash"]
        function_entry.picblockhashes = entry_dict["picblockhashes"]
        function_entry.minhash = bytes.fromhex(entry_dict["minhash"])
        function_entry.minhash_shingle_composition = entry_dict["minhash_shingle_composition"]
        function_entry.num_blocks = entry_dict["num_blocks"]
        function_entry.num_instructions = entry_dict["num_instructions"]
        function_entry.binweight = entry_dict["binweight"]
        function_entry.offset = decode_two_complement(entry_dict["offset"])
        function_entry.xcfg = entry_dict["xcfg"] if "xcfg" in entry_dict else None
        return function_entry

    def __str__(self):
        return "Family: {} Sample: {} Function: {} @ 0x{:08x} - {} blocks ({} hashes), {} instructions - pichash: {}".format(
            self.family_id,
            self.sample_id,
            self.function_id,
            self.offset,
            self.num_blocks,
            len(self.picblockhashes),
            self.num_instructions,
            self.pichash,
        )

```

`helpers/minimcrit/storage/FunctionLabelEntry.py`:

```py
import datetime
from typing import TYPE_CHECKING, Dict, Optional


class FunctionLabelEntry(object):
    # MCRIT specific
    function_id: int
    function_label: str
    username: str
    timestamp: datetime

    def __init__(
        self,
        function_label: str,
        username: str,
        function_id: Optional[int] = None,
        timestamp: Optional[datetime.datetime] = None,
    ) -> None:
        self.function_label = function_label
        self.username = username
        self.function_id = function_id
        self.timestamp = timestamp
        if timestamp is None:
            self.timestamp = datetime.datetime.utcnow()

    def setFunctionId(self, function_id):
        self.function_id = function_id

    def toDict(self):
        function_entry = {
            "function_label": self.function_label,
            "username": self.username,
            "timestamp": self.timestamp.strftime("%Y-%m-%dT%H:%M:%S"),
        }
        return function_entry

    @classmethod
    def fromDict(cls, entry_dict):
        function_label_entry = cls(None, None)  # type: ignore
        function_label_entry.function_label = entry_dict["function_label"]
        # function_entry.function_id = entry_dict["function_id"]
        function_label_entry.username = entry_dict["username"]
        function_label_entry.function_id = (
            entry_dict["function_id"] if "function_id" in entry_dict else None
        )
        function_label_entry.timestamp = datetime.datetime.strptime(
            entry_dict["timestamp"], "%Y-%m-%dT%H:%M:%S"
        )
        return function_label_entry

    def __str__(self):
        return f"FunctionLabel: '{self.function_label}' -- by user: {self.username}"

```

`helpers/minimcrit/storage/MatchedFunctionEntry.py`:

```py
from typing import TYPE_CHECKING, Dict, List, Optional

import helpers.minimcrit.matchers.MatcherFlags as MatcherFlags

if TYPE_CHECKING:  # pragma: no cover
    from helpers.minimcrit.storage.SampleEntry import SampleEntry

# Dataclass, post init
# constructor -> .fromSmdaFunction
# assume sample_entry, smda_function always available


class MatchedFunctionEntry(object):
    # basic information
    function_id: int
    num_bytes: int
    offset: int
    matched_family_id: int
    matched_family: str
    matched_sample_id: int
    matched_function_id: int
    matched_score: float
    matched_link_score: float
    matched_unique: bool
    matched_offset: int
    match_is_minhash: bool
    match_is_pichash: bool
    match_is_library: bool

    def __init__(self, function_id: int, num_bytes: int, offset: int, match_tuple: List) -> None:
        self.function_id = function_id
        self.num_bytes = num_bytes
        self.offset = offset
        self.matched_family_id = match_tuple[0]
        self.matched_sample_id = match_tuple[1]
        self.matched_function_id = match_tuple[2]
        self.matched_score = match_tuple[3]
        self.match_is_minhash = match_tuple[4] & MatcherFlags.IS_MINHASH_FLAG
        self.match_is_pichash = match_tuple[4] & MatcherFlags.IS_PICHASH_FLAG
        self.match_is_library = match_tuple[4] & MatcherFlags.IS_LIBRARY_FLAG
        self.matched_family = None
        self.matched_link_score = 0
        self.matched_unique = None
        self.matched_offset = None

    def getMatchTuple(self):
        return [
            self.matched_family_id,
            self.matched_sample_id,
            self.matched_function_id,
            self.matched_score,
            self.match_is_minhash * MatcherFlags.IS_MINHASH_FLAG
            + self.match_is_pichash * MatcherFlags.IS_PICHASH_FLAG
            + self.match_is_library * MatcherFlags.IS_LIBRARY_FLAG,
        ]

    def toDict(self):
        matching_entry = {
            "fid": self.function_id,
            "num_bytes": self.num_bytes,
            "offset": self.offset,
            "matches": self.getMatchTuple(),
        }
        return matching_entry

    @classmethod
    def fromDict(cls, entry_dict):
        matching_entry = cls(
            entry_dict["fid"], entry_dict["num_bytes"], entry_dict["offset"], entry_dict["matches"]
        )
        return matching_entry

    def __str__(self):
        flag_str = "m" if self.match_is_minhash else "."
        flag_str += "p" if self.match_is_pichash else "."
        flag_str += "l" if self.match_is_library else "."
        return "Function: fid({}) num_bytes({}) - Matched: family_id({}) sample_id({}) function_id({}) score({}) flags({})".format(
            self.function_id,
            self.num_bytes,
            self.matched_family_id,
            self.matched_sample_id,
            self.matched_function_id,
            self.matched_score,
            flag_str,
        )

```

`helpers/minimcrit/storage/MatchedSampleEntry.py`:

```py
from typing import TYPE_CHECKING, Dict, List, Optional

from helpers.minimcrit.storage.SampleEntry import SampleEntry

if TYPE_CHECKING:  # pragma: no cover
    from helpers.minimcrit.storage.SampleEntry import SampleEntry

# Dataclass, post init
# constructor -> .fromSmdaFunction
# assume sample_entry, smda_function always available


class MatchedSampleEntry(object):
    # basic information
    family: str
    family_id: int
    version: str
    bitness: int
    sha256: str
    filename: str
    sample_id: int
    num_bytes: int
    num_functions: int
    is_library: bool
    # related to matching
    matched_functions_minhash: int
    matched_functions_pichash: int
    matched_functions_combined: int
    matched_functions_library: int
    # scores
    matched_bytes_unweighted: float
    matched_bytes_score_weighted: float
    matched_bytes_frequency_weighted: float
    matched_bytes_nonlib_unweighted: float
    matched_bytes_nonlib_score_weighted: float
    matched_bytes_nonlib_frequency_weighted: float
    matched_percent_unweighted: float
    matched_percent_score_weighted: float
    matched_percent_frequency_weighted: float
    matched_percent_nonlib_unweighted: float
    matched_percent_nonlib_score_weighted: float
    matched_percent_nonlib_frequency_weighted: float

    def __init__(self, sample_id: int) -> None:
        self.sample_id = sample_id

    def getShortSha256(self, prefix=8, border=0):
        if border > 0:
            return self.sha256[:border] + "..." + self.sha256[-border:]
        elif prefix > 0:
            return self.sha256[:prefix]
        return self.sha256

    def getShortFilename(self, size_visible=20):
        if len(self.filename) > 2 * size_visible:
            return self.filename[:size_visible] + "..." + self.filename[-size_visible:]
        return self.filename

    def toDict(self):
        matching_entry = {
            "family": self.family,
            "family_id": self.family_id,
            "version": self.version,
            "bitness": self.bitness,
            "sha256": self.sha256,
            "filename": self.filename,
            "sample_id": self.sample_id,
            "num_bytes": self.num_bytes,
            "num_functions": self.num_functions,
            "matched": {
                "functions": {
                    "minhashes": self.matched_functions_minhash,
                    "pichashes": self.matched_functions_pichash,
                    "combined": self.matched_functions_combined,
                    "library": self.matched_functions_library,
                },
                "bytes": {
                    "unweighted": self.matched_bytes_unweighted,
                    "score_weighted": self.matched_bytes_score_weighted,
                    "frequency_weighted": self.matched_bytes_frequency_weighted,
                    "nonlib_unweighted": self.matched_bytes_nonlib_unweighted,
                    "nonlib_score_weighted": self.matched_bytes_nonlib_score_weighted,
                    "nonlib_frequency_weighted": self.matched_bytes_nonlib_frequency_weighted,
                },
                "percent": {
                    "unweighted": self.matched_percent_unweighted,
                    "score_weighted": self.matched_percent_score_weighted,
                    "frequency_weighted": self.matched_percent_frequency_weighted,
                    "nonlib_unweighted": self.matched_percent_nonlib_unweighted,
                    "nonlib_score_weighted": self.matched_percent_nonlib_score_weighted,
                    "nonlib_frequency_weighted": self.matched_percent_nonlib_frequency_weighted,
                },
            },
        }
        return matching_entry

    @classmethod
    def fromDict(cls, entry_dict):
        matching_entry = cls(None)
        matching_entry.family = entry_dict["family"]
        matching_entry.family_id = entry_dict["family_id"]
        matching_entry.version = entry_dict["version"]
        matching_entry.bitness = entry_dict["bitness"]
        matching_entry.sha256 = entry_dict["sha256"]
        matching_entry.filename = entry_dict["filename"]
        matching_entry.sample_id = entry_dict["sample_id"]
        matching_entry.num_bytes = entry_dict["num_bytes"]
        matching_entry.num_functions = entry_dict["num_functions"]
        matching_entry.is_library = (
            entry_dict["is_library"] if "is_library" in entry_dict else False
        )

        matching_entry.matched_functions_minhash = entry_dict["matched"]["functions"]["minhashes"]
        matching_entry.matched_functions_pichash = entry_dict["matched"]["functions"]["pichashes"]
        matching_entry.matched_functions_combined = entry_dict["matched"]["functions"]["combined"]
        matching_entry.matched_functions_library = entry_dict["matched"]["functions"]["library"]

        matching_entry.matched_bytes_unweighted = entry_dict["matched"]["bytes"]["unweighted"]
        matching_entry.matched_bytes_score_weighted = entry_dict["matched"]["bytes"][
            "score_weighted"
        ]
        matching_entry.matched_bytes_frequency_weighted = entry_dict["matched"]["bytes"][
            "frequency_weighted"
        ]
        matching_entry.matched_bytes_nonlib_unweighted = entry_dict["matched"]["bytes"][
            "nonlib_unweighted"
        ]
        matching_entry.matched_bytes_nonlib_score_weighted = entry_dict["matched"]["bytes"][
            "nonlib_score_weighted"
        ]
        matching_entry.matched_bytes_nonlib_frequency_weighted = entry_dict["matched"]["bytes"][
            "nonlib_frequency_weighted"
        ]

        matching_entry.matched_percent_unweighted = entry_dict["matched"]["percent"]["unweighted"]
        matching_entry.matched_percent_score_weighted = entry_dict["matched"]["percent"][
            "score_weighted"
        ]
        matching_entry.matched_percent_frequency_weighted = entry_dict["matched"]["percent"][
            "frequency_weighted"
        ]
        matching_entry.matched_percent_nonlib_unweighted = entry_dict["matched"]["percent"][
            "nonlib_unweighted"
        ]
        matching_entry.matched_percent_nonlib_score_weighted = entry_dict["matched"]["percent"][
            "nonlib_score_weighted"
        ]
        matching_entry.matched_percent_nonlib_frequency_weighted = entry_dict["matched"]["percent"][
            "nonlib_frequency_weighted"
        ]

        return matching_entry

    def __str__(self):
        return "Matched Sample: id({}) family({}) - Matched: {} ({}) - {} ({}) {} ({})".format(
            self.sample_id,
            self.family,
            self.matched_bytes_unweighted,
            self.matched_percent_unweighted,
            self.matched_bytes_score_weighted,
            self.matched_percent_score_weighted,
            self.matched_bytes_frequency_weighted,
            self.matched_percent_frequency_weighted,
        )

```

`helpers/minimcrit/storage/MatchingResult.py`:

```py
import math
from copy import deepcopy
from typing import TYPE_CHECKING, Dict, List, Optional

from smda.common.SmdaFunction import SmdaFunction
from smda.common.BinaryInfo import BinaryInfo

from helpers.minimcrit.libs.graph import Graph
from helpers.minimcrit.storage.SampleEntry import SampleEntry
from helpers.minimcrit.storage.MatchedSampleEntry import MatchedSampleEntry
from helpers.minimcrit.storage.MatchedFunctionEntry import MatchedFunctionEntry
import helpers.minimcrit.matchers.MatcherFlags as MatcherFlags

if TYPE_CHECKING:  # pragma: no cover
    from helpers.minimcrit.storage.SampleEntry import SampleEntry

# Dataclass, post init
# constructor -> .fromSmdaFunction
# assume sample_entry, smda_function always available


class MatchingResult(object):
    reference_sample_entry: "SampleEntry"
    other_sample_entry: "SampleEntry"
    match_aggregation: Dict
    sample_matches: List["MatchedSampleEntry"]
    function_matches: List["MatchedFunctionEntry"]
    # filtered versions
    filtered_sample_matches: List["MatchedSampleEntry"]
    filtered_function_matches: List["MatchedFunctionEntry"]
    # function_id -> [(family_id, sample_id), ...]
    library_matches: Dict
    # function_id -> {family_id_a, family_id_b, ...}
    function_id_to_family_ids_matched: Dict
    unique_family_scores_per_sample: Dict
    family_id_to_name_map: Dict
    is_family_filtered: bool
    is_sample_filtered: bool
    is_function_filtered: bool
    is_score_filtered: bool
    is_sample_count_filtered: bool
    is_family_count_filtered: bool
    is_library_filtered: bool
    is_pic_filtered: bool
    is_query: bool
    filter_values: Dict

    def __init__(self, sample_entry: "SampleEntry") -> None:
        self.reference_sample_entry = sample_entry
        self.unique_family_scores_per_sample = None
        self.family_id_to_name_map = None
        self.is_query = False
        self.filter_values = {}
        self.function_id_to_family_ids_matched = {}

    @property
    def num_original_function_matches(self):
        return len(self.function_matches)

    @property
    def num_original_sample_matches(self):
        return len(self.sample_matches)

    @property
    def num_original_family_matches(self):
        return len(
            set([sample.family_id for sample in self.sample_matches if not sample.is_library])
        )

    @property
    def num_original_library_matches(self):
        return len(set([sample.family_id for sample in self.sample_matches if sample.is_library]))

    @property
    def num_function_matches(self):
        return len(self.filtered_function_matches)

    @property
    def num_sample_matches(self):
        return len(self.filtered_sample_matches)

    @property
    def num_family_matches(self):
        return len(
            set(
                [
                    sample.family_id
                    for sample in self.filtered_sample_matches
                    if not sample.is_library
                ]
            )
        )

    @property
    def num_library_matches(self):
        return len(
            set([sample.family_id for sample in self.filtered_sample_matches if sample.is_library])
        )

    def setFilterValues(self, filter_dict):
        self.filter_values = filter_dict

    def getFilterValue(self, filter_name):
        return self.filter_values[filter_name] if filter_name in self.filter_values else 0

    def applyFilterValues(self):
        """use the filter_values that have been set before to reduce the data"""
        # filter family/sample
        if self.filter_values.get("filter_unique_only", None):
            self.filterToUniqueMatchesOnly()
        if self.filter_values.get("filter_direct_min_score", None):
            self.filterToDirectMinScore(self.filter_values["filter_direct_min_score"])
        if self.filter_values.get("filter_direct_nonlib_min_score", None):
            self.filterToDirectMinScore(
                self.filter_values["filter_direct_nonlib_min_score"], nonlib=True
            )
        if self.filter_values.get("filter_frequency_min_score", None):
            self.filterToFrequencyMinScore(self.filter_values["filter_frequency_min_score"])
        if self.filter_values.get("filter_frequency_nonlib_min_score", None):
            self.filterToFrequencyMinScore(
                self.filter_values["filter_frequency_nonlib_min_score"], nonlib=True
            )
        if self.filter_values.get("filter_exclude_own_family", None):
            self.excludeOwnFamily()
        if self.filter_values.get("filter_family_name", None):
            self.filterByFamilyName(self.filter_values["filter_family_name"])
        # filter functions
        if self.filter_values.get("filter_exclude_library", None):
            self.excludeLibraryMatches()
        if self.filter_values.get("filter_library_min_score", None):
            self.filterToFunctionScore(
                min_score=self.filter_values["filter_library_min_score"], library_only=True
            )
        if self.filter_values.get("filter_max_num_families", None):
            self.filterToFamilyCount(self.filter_values["filter_max_num_families"])
        if self.filter_values.get("filter_min_num_samples", None):
            self.filterToSampleCount(min_samples=self.filter_values["filter_min_num_samples"])
        if self.filter_values.get("filter_max_num_samples", None):
            self.filterToSampleCount(max_samples=self.filter_values["filter_max_num_samples"])
        if self.filter_values.get("filter_function_min_score", None):
            self.filterToFunctionScore(min_score=self.filter_values["filter_function_min_score"])
        if self.filter_values.get("filter_function_max_score", None):
            self.filterToFunctionScore(max_score=self.filter_values["filter_function_max_score"])
        if self.filter_values.get("filter_function_offset", None):
            self.filterToFunctionOffset(self.filter_values["filter_function_offset"])
        if self.filter_values.get("filter_exclude_pic", None):
            self.excludePicMatches()
        if self.filter_values.get("filter_func_unique", None):
            self.filterToUniqueFunctionMatchesOnly()

    def getFamilyNameByFamilyId(self, family_id):
        if self.family_id_to_name_map is None:
            self.family_id_to_name_map = {}
            for sample_match in self.sample_matches:
                self.family_id_to_name_map[sample_match.family_id] = sample_match.family
        return (
            self.family_id_to_name_map[family_id] if family_id in self.family_id_to_name_map else ""
        )

    def getFamilyIdsMatchedByFunctionId(self, function_id):
        if function_id not in self.function_id_to_family_ids_matched:
            return 0
        return self.function_id_to_family_ids_matched[function_id]

    def filterByFamilyName(self, filter_term):
        """reduce families and samples to those where family_name is part of the family_name"""
        filtered_sample_matches = []
        for sample_match in self.filtered_sample_matches:
            if filter_term in sample_match.family:
                filtered_sample_matches.append(sample_match)
        self.filtered_sample_matches = filtered_sample_matches

    def filterToDirectMinScore(self, min_score, nonlib=False):
        """reduce aggregated sample matches to those with direct score of min_score or higher, but nonlib flag is not applied to library samples"""
        filtered_sample_matches = []
        for sample_match in self.filtered_sample_matches:
            if nonlib:
                if sample_match.is_library:
                    filtered_sample_matches.append(sample_match)
                elif sample_match.matched_percent_nonlib_score_weighted >= min_score:
                    filtered_sample_matches.append(sample_match)
            else:
                if sample_match.matched_percent_score_weighted >= min_score:
                    filtered_sample_matches.append(sample_match)
        self.filtered_sample_matches = filtered_sample_matches

    def filterToFrequencyMinScore(self, min_score, nonlib=False):
        """reduce aggregated sample matches to those with frequency score of min_score or higher, but nonlib flag is not applied to library samples"""
        filtered_sample_matches = []
        for sample_match in self.filtered_sample_matches:
            if nonlib:
                if sample_match.is_library:
                    filtered_sample_matches.append(sample_match)
                elif sample_match.matched_percent_nonlib_frequency_weighted >= min_score:
                    filtered_sample_matches.append(sample_match)
            else:
                if sample_match.matched_percent_frequency_weighted >= min_score:
                    filtered_sample_matches.append(sample_match)
        self.filtered_sample_matches = filtered_sample_matches

    def filterToUniqueMatchesOnly(self):
        """reduce aggregated sample matches to those with unique matches only"""
        filtered_sample_matches = []
        for sample_match in self.filtered_sample_matches:
            unique_info = self.getUniqueFamilyMatchInfoForSample(sample_match.sample_id)
            if unique_info["unique_score"] > 0 or sample_match.is_library:
                filtered_sample_matches.append(sample_match)
        self.filtered_sample_matches = filtered_sample_matches

    def filterToUniqueFunctionMatchesOnly(self):
        """reduce function matches to those with unique matches (with respect to the family) only"""
        aggregated = self.getAggregatedFunctionMatches()
        filtered_function_matches = []
        unique_info_by_function_id = {
            entry["function_id"]: entry["num_families_matched"] == 1 for entry in aggregated
        }
        for function_match in self.filtered_function_matches:
            if unique_info_by_function_id[function_match.function_id]:
                filtered_function_matches.append(function_match)
        self.filtered_function_matches = filtered_function_matches

    def filterToFunctionOffset(self, offset):
        """reduce function matches to those that match a specific offset"""
        filtered_function_matches = []
        for function_match in self.filtered_function_matches:
            if function_match.offset == offset:
                filtered_function_matches.append(function_match)
        self.filtered_function_matches = filtered_function_matches

    def excludeOwnFamily(self):
        """remove all sample matches with the same family_id as the reference samples"""
        filtered_sample_matches = []
        for sample_match in self.filtered_sample_matches:
            if sample_match.family_id != self.reference_sample_entry.family_id:
                filtered_sample_matches.append(sample_match)
        self.filtered_sample_matches = filtered_sample_matches

    def excludeLibraryMatches(self):
        """reduce contained matches to those where none of the matches is with a library (transitive library identification)"""
        library_matches = [matches for matches in self.library_matches.values() if matches]
        library_samples = set([match[1] for match_list in library_matches for match in match_list])
        library_matched_functions = [
            key for key in self.library_matches if self.library_matches[key]
        ]
        self.filtered_sample_matches = [
            sample_match
            for sample_match in self.filtered_sample_matches
            if sample_match.sample_id not in library_samples
        ]
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if function_match.function_id not in library_matched_functions
        ]
        self.is_library_filtered = True

    def excludePicMatches(self):
        """reduce contained matches to those which are not identified as quasi-identical via PIC matching"""
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if not function_match.match_is_pichash
        ]
        self.is_pic_filtered = True

    def filterToSampleCount(self, min_samples=None, max_samples=None):
        """reduce contained matches to those with a maximum of <max_sample_count> matched samples"""
        matched_samples_by_function_id = {}
        for function_match in self.filtered_function_matches:
            if not function_match.function_id in matched_samples_by_function_id:
                matched_samples_by_function_id[function_match.function_id] = []
            if (
                not function_match.matched_sample_id
                in matched_samples_by_function_id[function_match.function_id]
            ):
                matched_samples_by_function_id[function_match.function_id].append(
                    function_match.matched_sample_id
                )
        if min_samples is not None:
            self.filtered_function_matches = [
                function_match
                for function_match in self.filtered_function_matches
                if len(matched_samples_by_function_id[function_match.function_id]) >= min_samples
            ]
        if max_samples is not None:
            self.filtered_function_matches = [
                function_match
                for function_match in self.filtered_function_matches
                if len(matched_samples_by_function_id[function_match.function_id]) <= max_samples
            ]
        self.is_sample_count_filtered = True

    def filterToFamilyCount(self, max_family_count):
        """reduce contained matches to those with a maximum of <max_family_count> matched families"""
        matched_families_by_function_id = {}
        for function_match in self.filtered_function_matches:
            if not function_match.function_id in matched_families_by_function_id:
                matched_families_by_function_id[function_match.function_id] = []
            if (
                not function_match.matched_family_id
                in matched_families_by_function_id[function_match.function_id]
            ):
                matched_families_by_function_id[function_match.function_id].append(
                    function_match.matched_family_id
                )
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if len(matched_families_by_function_id[function_match.function_id]) <= max_family_count
        ]
        self.is_family_count_filtered = True

    def filterToFunctionScore(self, min_score=None, max_score=None, library_only=False):
        """reduce contained matches to those with a minimum score of <threshold>"""
        filtered_function_matches = []
        for function_match in self.filtered_function_matches:
            if library_only and not function_match.match_is_library:
                filtered_function_matches.append(function_match)
            else:
                if (min_score is not None) and (max_score is not None):
                    if min_score <= function_match.matched_score <= max_score:
                        filtered_function_matches.append(function_match)
                else:
                    # no duplicates expected as per above condition only one case can be true
                    if min_score is not None and function_match.matched_score >= min_score:
                        filtered_function_matches.append(function_match)
                    if max_score is not None and function_match.matched_score <= max_score:
                        filtered_function_matches.append(function_match)
        self.filtered_function_matches = filtered_function_matches
        self.is_score_filtered = True

    def filterToFamilyId(self, family_id):
        """reduce contained matches to chosen family_id by deleting the other sample and function matches"""
        self.filtered_sample_matches = [
            sample_match
            for sample_match in self.filtered_sample_matches
            if sample_match.family_id == family_id
        ]
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if function_match.matched_family_id == family_id
        ]
        self.is_family_filtered = True

    def filterToSampleId(self, sample_id):
        """reduce contained matches to chosen sample_id by deleting the other sample and function matches"""
        self.filtered_sample_matches = [
            sample_match
            for sample_match in self.filtered_sample_matches
            if sample_match.sample_id == sample_id
        ]
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if function_match.matched_sample_id == sample_id
        ]
        self.is_sample_filtered = True

    def filterToFunctionId(self, function_id):
        """reduce contained matches to chosen function_id by deleting the other sample and function matches"""
        self.filtered_function_matches = [
            function_match
            for function_match in self.filtered_function_matches
            if function_match.function_id == function_id
        ]
        self.is_function_filtered = True

    def hasLibraryMatch(self, function_id):
        return function_id in self.library_matches and self.library_matches[function_id]

    def getBestSampleMatchesPerFamily(
        self, start=None, limit=None, unfiltered=False, library_only=False, malware_only=False
    ):
        by_family = {}
        source_matches = self.sample_matches if unfiltered else self.filtered_sample_matches
        for sample_match in source_matches:
            if library_only and not sample_match.is_library:
                continue
            if malware_only and sample_match.is_library:
                continue
            if sample_match.family not in by_family:
                by_family[sample_match.family] = {
                    "score": sample_match.matched_percent_frequency_weighted,
                    "report": sample_match,
                }
            elif (
                sample_match.matched_percent_frequency_weighted
                > by_family[sample_match.family]["score"]
            ):
                by_family[sample_match.family]["score"] = (
                    sample_match.matched_percent_frequency_weighted
                )
                by_family[sample_match.family]["report"] = sample_match
        result_list = []
        for family, score_entry in sorted(
            by_family.items(), key=lambda e: e[1]["score"], reverse=True
        ):
            result_list.append(score_entry["report"])
        if start is not None:
            result_list = result_list[start:]
        if limit is not None:
            result_list = result_list[:limit]
        return result_list

    def getUniqueFamilyMatchInfoForSample(self, sample_id):
        if self.unique_family_scores_per_sample is None:
            self.unique_family_scores_per_sample = {
                entry.sample_id: {"functions_matched": 0, "bytes_matched": 0, "unique_score": 0}
                for entry in self.sample_matches
            }
            families_matched_by_function_id = {}
            samples_matched_by_function_id = {}
            weighted_bytes_per_function_id = {}
            for function_match_summary in self.function_matches:
                if function_match_summary.function_id not in families_matched_by_function_id:
                    families_matched_by_function_id[function_match_summary.function_id] = set()
                    samples_matched_by_function_id[function_match_summary.function_id] = set()
                    weighted_bytes_per_function_id[function_match_summary.function_id] = 0
                families_matched_by_function_id[function_match_summary.function_id].add(
                    function_match_summary.matched_family_id
                )
                samples_matched_by_function_id[function_match_summary.function_id].add(
                    function_match_summary.matched_sample_id
                )
                # matches should be weighted by match score
                weighted_bytes_per_function_id[function_match_summary.function_id] = (
                    function_match_summary.num_bytes * function_match_summary.matched_score / 100.0
                )
            for function_id in families_matched_by_function_id:
                if len(families_matched_by_function_id[function_id]) == 1:
                    for sid in samples_matched_by_function_id[function_id]:
                        self.unique_family_scores_per_sample[sid]["functions_matched"] += 1
                        self.unique_family_scores_per_sample[sid]["bytes_matched"] += (
                            weighted_bytes_per_function_id[function_id]
                        )
            for sid in self.unique_family_scores_per_sample:
                self.unique_family_scores_per_sample[sid]["unique_score"] = (
                    100.0
                    * self.unique_family_scores_per_sample[sid]["bytes_matched"]
                    / self.reference_sample_entry.binweight
                )
        if sample_id in self.unique_family_scores_per_sample:
            return self.unique_family_scores_per_sample[sample_id]
        else:
            return {"functions_matched": 0, "bytes_matched": 0, "unique_score": 0}

    def getSampleMatches(
        self, start=None, limit=None, unfiltered=False, library_only=False, malware_only=False
    ):
        by_sample_id = {}
        source_matches = self.sample_matches if unfiltered else self.filtered_sample_matches
        for sample_match in source_matches:
            if library_only and not sample_match.is_library:
                continue
            if malware_only and sample_match.is_library:
                continue
            by_sample_id[sample_match.sample_id] = {
                "score": sample_match.matched_percent_frequency_weighted,
                "report": sample_match,
            }
        result_list = []
        for sample_id, score_entry in sorted(
            by_sample_id.items(), key=lambda e: e[1]["score"], reverse=True
        ):
            result_list.append(score_entry["report"])
        if start is not None:
            result_list = result_list[start:]
        if limit is not None:
            result_list = result_list[:limit]
        return result_list

    def getFunctionMatches(self, start=None, limit=None, unfiltered=False):
        source_matches = self.function_matches if unfiltered else self.filtered_function_matches
        result_list = source_matches
        if start is not None:
            result_list = result_list[start:]
        if limit is not None:
            result_list = result_list[:limit]
        return result_list

    def getAggregatedFunctionMatches(self, start=None, limit=None, unfiltered=False):
        by_function_id = {}
        source_matches = self.function_matches if unfiltered else self.filtered_function_matches
        for function_match in source_matches:
            if function_match.function_id not in by_function_id:
                by_function_id[function_match.function_id] = {
                    "function_id": function_match.function_id,
                    "num_bytes": 0,
                    "offset": 0,
                    "best_score": 0,
                    "num_families_matched": 0,
                    "family_ids_matched": set([]),
                    "families_matched": set([]),
                    "num_samples_matched": 0,
                    "sample_ids_matched": set([]),
                    "num_functions_matched": 0,
                    "function_ids_matched": set([]),
                    "minhash_matches": 0,
                    "pichash_matches": 0,
                    "library_matches": 0,
                }
            by_function_id[function_match.function_id]["num_bytes"] = function_match.num_bytes
            by_function_id[function_match.function_id]["offset"] = function_match.offset
            by_function_id[function_match.function_id]["best_score"] = max(
                function_match.matched_score,
                by_function_id[function_match.function_id]["best_score"],
            )
            by_function_id[function_match.function_id]["family_ids_matched"].add(
                function_match.matched_family_id
            )
            by_function_id[function_match.function_id]["families_matched"].add(
                self.getFamilyNameByFamilyId(function_match.matched_family_id)
            )
            by_function_id[function_match.function_id]["sample_ids_matched"].add(
                function_match.matched_sample_id
            )
            by_function_id[function_match.function_id]["function_ids_matched"].add(
                function_match.matched_function_id
            )
            by_function_id[function_match.function_id]["num_families_matched"] = len(
                by_function_id[function_match.function_id]["family_ids_matched"]
            )
            by_function_id[function_match.function_id]["num_samples_matched"] = len(
                by_function_id[function_match.function_id]["sample_ids_matched"]
            )
            by_function_id[function_match.function_id]["num_functions_matched"] = len(
                by_function_id[function_match.function_id]["function_ids_matched"]
            )
            by_function_id[function_match.function_id]["minhash_matches"] += (
                1 if function_match.match_is_minhash else 0
            )
            by_function_id[function_match.function_id]["pichash_matches"] += (
                1 if function_match.match_is_pichash else 0
            )
            by_function_id[function_match.function_id]["library_matches"] += (
                1 if function_match.match_is_library else 0
            )
            by_function_id[function_match.function_id]["is_family_unique"] = (
                True
                if len(by_function_id[function_match.function_id]["family_ids_matched"]) == 1
                else False
            )
        aggregated_matched = [v for k, v in sorted(by_function_id.items())]
        if start is not None:
            aggregated_matched = aggregated_matched[start:]
        if limit is not None:
            aggregated_matched = aggregated_matched[:limit]
        return aggregated_matched

    def getFunctionsSlice(self, start, limit, unfiltered=False):
        return self.filtered_function_matches[start : start + limit]

    def getLinkHuntResults(
        self,
        min_score=None,
        min_lib_score=None,
        min_size=None,
        min_offset=None,
        max_offset=None,
        unpenalized_family_count=3,
        exclude_family_ids=None,
        exclude_sample_ids=None,
        strongest_per_family=True,
    ):
        """Returns the most promising matches for finding inter-family relationship as a list"""
        # run over all function_matches while applying filters, collect aggregate data needed to calculate scores
        by_function_id = {}
        link_matches = []
        droppable_fids = set()
        for function_match in sorted(
            self.function_matches,
            key=lambda x: (x.matched_score, x.matched_family_id),
            reverse=True,
        ):
            if min_offset is not None and function_match.offset < min_offset:
                continue
            if max_offset is not None and max_offset < function_match.offset:
                continue
            if (
                min_lib_score is not None
                and function_match.match_is_library
                and function_match.matched_score < min_lib_score
            ):
                continue
            if min_score is not None and function_match.matched_score < min_score:
                continue
            if min_size is not None and function_match.num_bytes < min_size:
                continue
            if (
                exclude_family_ids is not None
                and function_match.matched_family_id in exclude_family_ids
            ):
                continue
            if (
                exclude_sample_ids is not None
                and function_match.matched_sample_id in exclude_sample_ids
            ):
                continue
            if function_match.function_id not in by_function_id:
                by_function_id[function_match.function_id] = {
                    "function_id": function_match.function_id,
                    "num_bytes": 0,
                    "offset": 0,
                    "position": len(by_function_id),
                    "num_families_matched": 0,
                    "family_ids_matched": set([]),
                    "families_matched": set([]),
                    "library_matches": 0,
                }
            # only keep the first / strongest per function_id and family_id
            if (
                strongest_per_family
                and function_match.matched_family_id
                in by_function_id[function_match.function_id]["family_ids_matched"]
            ):
                continue
            by_function_id[function_match.function_id]["num_bytes"] = function_match.num_bytes
            by_function_id[function_match.function_id]["offset"] = function_match.offset
            by_function_id[function_match.function_id]["family_ids_matched"].add(
                function_match.matched_family_id
            )
            by_function_id[function_match.function_id]["num_families_matched"] = len(
                by_function_id[function_match.function_id]["family_ids_matched"]
            )
            family_name = self.getFamilyNameByFamilyId(function_match.matched_family_id)
            function_match.matched_family = family_name
            by_function_id[function_match.function_id]["families_matched"].add(family_name)
            by_function_id[function_match.function_id]["library_matches"] += (
                1 if function_match.match_is_library else 0
            )
            # these will be discarded later on anyway
            if function_match.match_is_library:
                droppable_fids.add(function_match.function_id)
            link_matches.append(function_match)
        filtered_link_matched = []
        for match in link_matches:
            if match.function_id in droppable_fids:
                continue
            filtered_link_matched.append(match)
        link_matches = filtered_link_matched
        for match in link_matches:
            num_families_matched = by_function_id[match.function_id]["num_families_matched"]
            family_adjustment_value = (
                1
                if num_families_matched < unpenalized_family_count
                else 1 + int(math.log(1 + num_families_matched - unpenalized_family_count, 2))
            )
            # for now, we use an interpolated polynome that is flatter than linear initially and crosses upwards once past ~10 families matched
            family_adjustment_value = (
                1
                if num_families_matched < unpenalized_family_count
                else max(
                    1,
                    math.floor(
                        0.0545793 * num_families_matched**2
                        + 0.370159 * num_families_matched
                        - 0.170796
                    ),
                )
            )
            # magic formula:
            # do a compound score that is based on
            # 10% position, front of binary preferred
            # 20% size, functions larger 100bytes preferred
            # 70% score, as originally produced by minhash
            position_score = 100 * (
                1 - (by_function_id[match.function_id]["position"] / len(by_function_id))
            )
            size_score = 100 * (min(300, by_function_id[match.function_id]["num_bytes"]) / 300)
            # scale the whole compound score with frequency weight
            match.matched_link_score = (
                0.1 * position_score + 0.2 * size_score + 0.7 * match.matched_score
            ) / family_adjustment_value
            match.matched_unique = num_families_matched == 1
            link_matches.sort(key=lambda x: (x.matched_link_score, x.function_id), reverse=True)
        return link_matches

    def clusterLinkHuntResult(self, function_entries, link_hunt_matches):
        """
        Clustering is based on ICFG relationships, so we need to pass in that information in the form of function_entries
        """
        cluster_results = []
        # build some helper lookup structures
        function_offsets = [f.offset for f in function_entries]
        candidate_links = {}
        family_id_to_name = {}
        families_per_offset = {}
        for fm in link_hunt_matches:
            # map names
            family_id_to_name[fm.matched_family_id] = fm.matched_family
            # filter to some minimal link score (remove super common functions to break up huge clusters)
            if fm.matched_family_id not in candidate_links:
                candidate_links[fm.matched_family_id] = []
            if fm.matched_link_score > 1:
                candidate_links[fm.matched_family_id].append(fm)
            # make unique matches identifiable
            if fm.offset not in families_per_offset:
                families_per_offset[fm.offset] = set()
            families_per_offset[fm.offset].add(fm.matched_family_id)
        # extract code references from function_entries via SmdaFunctions
        binfo = BinaryInfo(b"")
        all_function_links = {}
        for function_entry in function_entries:
            binfo.architecture = function_entry.architecture
            smda_function = SmdaFunction.fromDict(function_entry.xcfg, binfo)
            for _, to_offsets in smda_function.outrefs.items():
                for to_offset in [o for o in to_offsets if o in function_offsets]:
                    from_offset = smda_function.offset
                    if from_offset not in all_function_links:
                        all_function_links[from_offset] = set()
                    all_function_links[from_offset].add(to_offset)
                    if to_offset not in all_function_links:
                        all_function_links[to_offset] = set()
                    all_function_links[to_offset].add(from_offset)
        # turn into proper (undirected) ICFG and DFS all clusters
        for fam_id, links in candidate_links.items():
            offset_to_link = {}
            g = Graph()
            for index, link_a in enumerate(links):
                g.addNode(link_a.offset)
                offset_to_link[link_a.offset] = link_a
                for link_b in links[index:]:
                    if (
                        link_a.offset in all_function_links
                        and link_b.offset in all_function_links[link_a.offset]
                    ):
                        g.addEdge(link_a.offset, link_b.offset)
                        g.addEdge(link_b.offset, link_a.offset)
            queue = set([k for k in g.graph.keys()])
            while queue:
                start = queue.pop()
                reachable = g.DFS(start)
                subgraph_score = 0
                max_score = 0
                for offset in reachable:
                    subgraph_score += offset_to_link[offset].matched_link_score
                    max_score = max(max_score, offset_to_link[offset].matched_link_score)
                subgraph_result = {
                    "family_id": fam_id,
                    "family": family_id_to_name[fam_id],
                    "links": [offset_to_link[offset] for offset in reachable],
                    "unique_matches": [
                        offset_to_link[offset]
                        for offset in reachable
                        if len(families_per_offset[offset]) == 1
                    ],
                    "score": subgraph_score,
                    "max_score": max_score,
                }
                cluster_results.append(subgraph_result)
                queue.difference_update(reachable)
        return cluster_results

    def toDict(self):
        # we need to aggregate by function_id here
        summarized_function_match_summaries = {}
        for function_match_entry in self.function_matches:
            if function_match_entry.function_id not in summarized_function_match_summaries:
                summarized_function_match_summaries[function_match_entry.function_id] = {
                    "num_bytes": function_match_entry.num_bytes,
                    "offset": function_match_entry.offset,
                    "fid": function_match_entry.function_id,
                    "matches": [function_match_entry.getMatchTuple()],
                }
            else:
                summarized_function_match_summaries[function_match_entry.function_id][
                    "matches"
                ].append(function_match_entry.getMatchTuple())
        # build the dictionary
        matching_entry = {
            "info": {"sample": self.reference_sample_entry.toDict()},
            "matches": {
                "aggregation": self.match_aggregation,
                "functions": summarized_function_match_summaries,
                "samples": [match.toDict() for match in self.sample_matches],
            },
        }
        if self.other_sample_entry is not None:
            matching_entry["other_sample_info"] = self.other_sample_entry.toDict()
        return matching_entry

    @classmethod
    def fromDict(cls, entry_dict):
        matching_entry = cls(None)
        matching_entry.reference_sample_entry = SampleEntry.fromDict(entry_dict["info"]["sample"])
        if "other_sample_info" in entry_dict:
            matching_entry.other_sample_entry = SampleEntry.fromDict(
                entry_dict["other_sample_info"]
            )
        else:
            matching_entry.other_sample_entry = None
        matching_entry.match_aggregation = entry_dict["matches"]["aggregation"]
        matching_entry.sample_matches = [
            MatchedSampleEntry.fromDict(entry) for entry in entry_dict["matches"]["samples"]
        ]
        # expand function matches into individual entries
        list_of_function_matches = []
        if "functions" in entry_dict["matches"]:
            matching_entry.library_matches = {
                abs(entry["fid"]): [] for entry in entry_dict["matches"]["functions"]
            }
            matching_entry.unique_family_scores_per_sample = None
            for function_match_summary in entry_dict["matches"]["functions"]:
                num_bytes = function_match_summary["num_bytes"]
                offset = function_match_summary["offset"]
                function_id = function_match_summary["fid"]
                # ensure that we have all function_ids in increasing order, regardless of whether they come from a query or regular match.
                matching_entry.is_query = True if function_id < 0 else False
                function_id = abs(function_id)
                if function_id not in matching_entry.function_id_to_family_ids_matched:
                    matching_entry.function_id_to_family_ids_matched[function_id] = []
                for match_tuple in function_match_summary["matches"]:
                    list_of_function_matches.append(
                        MatchedFunctionEntry(function_id, num_bytes, offset, match_tuple)
                    )
                    if (
                        match_tuple[0]
                        not in matching_entry.function_id_to_family_ids_matched[function_id]
                    ):
                        matching_entry.function_id_to_family_ids_matched[function_id].append(
                            match_tuple[0]
                        )
                    if match_tuple[4] & MatcherFlags.IS_LIBRARY_FLAG:
                        if (match_tuple[0], match_tuple[1]) not in matching_entry.library_matches[
                            function_id
                        ]:
                            matching_entry.library_matches[function_id].append(
                                (match_tuple[0], match_tuple[1])
                            )
        matching_entry.function_matches = sorted(
            list_of_function_matches, key=lambda x: x.function_id
        )
        # create deep copies for filtering
        matching_entry.filtered_function_matches = deepcopy(matching_entry.function_matches)
        matching_entry.filtered_sample_matches = deepcopy(matching_entry.sample_matches)
        return matching_entry

    def __str__(self):
        return "Matched: Samples: {} (unfiltered: {}) Functions: {} (unfiltered: {})".format(
            len(self.filtered_sample_matches),
            len(self.sample_matches),
            len(self.filtered_function_matches),
            len(self.function_matches),
        )

```

`helpers/minimcrit/storage/SampleEntry.py`:

```py
from dataclasses import dataclass
import datetime
from typing import Dict, TYPE_CHECKING

from helpers.minimcrit.libs.utility import encode_two_complement, decode_two_complement

if TYPE_CHECKING:  # pragma: no cover
    from smda.common.SmdaReport import SmdaReport


# @dataclass
class SampleEntry(object):
    family_id: int
    sample_id: int
    architecture: str
    base_addr: int
    binary_size: int
    binweight: float
    bitness: int
    component: str
    family: str
    version: str
    is_library: bool
    filename: str
    sha256: str
    smda_version: str
    summary: None
    statistics: Dict[str, int]
    timestamp: datetime.datetime

    # TODO -> rename to fromSmdaReport
    def __init__(self, smda_report: "SmdaReport", sample_id=-1, family_id=0):
        self.sample_id = sample_id
        self.family_id = family_id
        if smda_report:
            self.architecture = smda_report.architecture
            self.base_addr = smda_report.base_addr
            self.binary_size = smda_report.binary_size
            self.binweight = smda_report.binweight
            self.bitness = smda_report.bitness
            self.component = smda_report.component
            self.family = smda_report.family
            self.filename = smda_report.filename
            self.is_library = smda_report.is_library
            self.sha256 = smda_report.sha256
            self.smda_version = smda_report.smda_version
            self.statistics = smda_report.statistics.toDict()
            self.timestamp = smda_report.timestamp
            self.version = smda_report.version

    def getShortSha256(self, prefix=8, border=0):
        if border > 0:
            return self.sha256[:border] + "..." + self.sha256[-border:]
        elif prefix > 0:
            return self.sha256[:prefix]
        return self.sha256

    def getShortFilename(self, size_visible=20):
        if len(self.filename) > 2 * size_visible:
            return self.filename[:size_visible] + "..." + self.filename[-size_visible:]
        return self.filename

    def toDict(self):
        sample_entry = {
            "architecture": self.architecture,
            "base_addr": encode_two_complement(self.base_addr),
            "binary_size": self.binary_size,
            "binweight": self.binweight,
            "bitness": self.bitness,
            "component": self.component,
            "family_id": self.family_id,
            "family": self.family,
            "filename": self.filename,
            "is_library": self.is_library,
            "sample_id": self.sample_id,
            "sha256": self.sha256,
            "smda_version": self.smda_version,
            "statistics": self.statistics,
            "timestamp": self.timestamp.strftime("%Y-%m-%dT%H-%M-%S"),
            "version": self.version,
        }
        return sample_entry

    @classmethod
    def fromDict(cls, entry_dict):
        sample_entry = cls(None)  # type: ignore
        sample_entry.family_id = entry_dict["family_id"]
        sample_entry.sample_id = entry_dict["sample_id"]
        sample_entry.architecture = entry_dict["architecture"]
        sample_entry.base_addr = decode_two_complement(entry_dict["base_addr"])
        sample_entry.binary_size = entry_dict["binary_size"]
        sample_entry.binweight = entry_dict["binweight"]
        sample_entry.bitness = entry_dict["bitness"]
        sample_entry.component = entry_dict["component"]
        sample_entry.family = entry_dict["family"]
        sample_entry.version = entry_dict["version"]
        sample_entry.is_library = entry_dict["is_library"]
        sample_entry.filename = entry_dict["filename"]
        sample_entry.sha256 = entry_dict["sha256"]
        sample_entry.smda_version = entry_dict["smda_version"]
        sample_entry.statistics = entry_dict["statistics"]
        sample_entry.timestamp = datetime.datetime.strptime(
            entry_dict["timestamp"], "%Y-%m-%dT%H-%M-%S"
        )
        return sample_entry

    @classmethod
    def fromAlchemySample(cls, sample):
        sample_entry = cls(None)  # type:ignore
        sample_entry.sample_id = sample.id
        sample_entry.family_id = sample.family.id
        sample_entry.family = sample.family.name
        sample_entry.architecture = sample.architecture.name
        sample_entry.base_addr = sample.base_addr
        sample_entry.binary_size = sample.binary_size
        sample_entry.component = sample.component
        sample_entry.binweight = sample.binweight
        sample_entry.bitness = sample.bitness.name
        sample_entry.version = sample.version
        sample_entry.is_library = sample.is_library
        sample_entry.filename = sample.filename
        sample_entry.sha256 = sample.sha256
        sample_entry.smda_version = sample.smda_version
        sample_entry.statistics = sample.statistics
        sample_entry.timestamp = sample.timestamp
        return sample_entry

    def __str__(self):
        return "Sample {} ({}, {} bit) - {} ({}): ".format(
            self.sample_id, self.architecture, self.bitness, self.filename, self.family
        )

    def __hash__(self):
        """Override the default hash behavior"""
        return hash(f"{self.sample_id}_{self.sha256}")

```

`helpers/pylev/LICENSE`:

```
Copyright (c) 2012, Daniel Lindsley
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the pylev nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL pylev BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`helpers/pylev/__init__.py`:

```py
"""
pylev
=====

A pure Python Levenshtein implementation that's not freaking GPL'd.

Based off the Wikipedia code samples at
http://en.wikipedia.org/wiki/Levenshtein_distance.

Usage
-----

Usage is fairly straightforward.::

    import pylev
    distance = pylev.levenshtein('kitten', 'sitting')
    assert distance == 3

"""

from .classic import classic_levenshtein
from .recursive import recursive_levenshtein
from .wf import wf_levenshtein, wfi_levenshtein
from .damerau import damerau_levenshtein

__author__ = "Daniel Lindsley"
__version__ = (1, 5, 0, "alpha")
__license__ = "New BSD"


levenshtein = wfi_levenshtein

# Backward-compatibilty because I misspelled.
classic_levenschtein = classic_levenshtein
levenschtein = levenshtein


__all__ = [
    "levenshtein",
    "classic_levenshtein",
    "recursive_levenshtein",
    "wf_levenshtein",
    "wfi_levenshtein",
    "damerau_levenshtein",
]

```

`helpers/pylev/classic.py`:

```py
def classic_levenshtein(string_1, string_2):
    """
    Calculates the Levenshtein distance between two strings.

    This version is easier to read, but significantly slower than the version
    below (up to several orders of magnitude). Useful for learning, less so
    otherwise.

    Usage::

        >>> classic_levenshtein('kitten', 'sitting')
        3
        >>> classic_levenshtein('kitten', 'kitten')
        0
        >>> classic_levenshtein('', '')
        0

    """
    len_1 = len(string_1)
    len_2 = len(string_2)
    cost = 0

    if len_1 and len_2 and string_1[0] != string_2[0]:
        cost = 1

    if len_1 == 0:
        return len_2
    elif len_2 == 0:
        return len_1
    else:
        return min(
            classic_levenshtein(string_1[1:], string_2) + 1,
            classic_levenshtein(string_1, string_2[1:]) + 1,
            classic_levenshtein(string_1[1:], string_2[1:]) + cost,
        )

```

`helpers/pylev/damerau.py`:

```py
import sys


PY2 = sys.version_info[0] == 2

if PY2:
    range = xrange


def damerau_levenshtein(string_1, string_2):
    """
    Calculates the Damerau-Levenshtein distance between two strings.

    In addition to insertions, deletions and substitutions,
    Damerau-Levenshtein considers adjacent transpositions.

    This version is based on an iterative version of the Wagner-Fischer algorithm.

    Usage::

        >>> damerau_levenshtein('kitten', 'sitting')
        3
        >>> damerau_levenshtein('kitten', 'kittne')
        1
        >>> damerau_levenshtein('', '')
        0

    """
    if string_1 == string_2:
        return 0

    len_1 = len(string_1)
    len_2 = len(string_2)

    if len_1 == 0:
        return len_2
    if len_2 == 0:
        return len_1

    if len_1 > len_2:
        string_2, string_1 = string_1, string_2
        len_2, len_1 = len_1, len_2

    prev_cost = 0
    d0 = [i for i in range(len_2 + 1)]
    d1 = [j for j in range(len_2 + 1)]
    dprev = d0[:]

    s1 = string_1
    s2 = string_2

    for i in range(len_1):
        d1[0] = i + 1
        for j in range(len_2):
            cost = d0[j]

            if s1[i] != s2[j]:
                # substitution
                cost += 1

                # insertion
                x_cost = d1[j] + 1
                if x_cost < cost:
                    cost = x_cost

                # deletion
                y_cost = d0[j + 1] + 1
                if y_cost < cost:
                    cost = y_cost

                # transposition
                if i > 0 and j > 0 and s1[i] == s2[j - 1] and s1[i - 1] == s2[j]:
                    transp_cost = dprev[j - 1] + 1
                    if transp_cost < cost:
                        cost = transp_cost
            d1[j + 1] = cost

        dprev, d0, d1 = d0, d1, dprev

    return d0[-1]

```

`helpers/pylev/recursive.py`:

```py
def recursive_levenshtein(
    string_1, string_2, len_1=None, len_2=None, offset_1=0, offset_2=0, memo=None
):
    """
    Calculates the Levenshtein distance between two strings.

    Usage::

        >>> recursive_levenshtein('kitten', 'sitting')
        3
        >>> recursive_levenshtein('kitten', 'kitten')
        0
        >>> recursive_levenshtein('', '')
        0

    """
    if len_1 is None:
        len_1 = len(string_1)

    if len_2 is None:
        len_2 = len(string_2)

    if memo is None:
        memo = {}

    key = ",".join([str(offset_1), str(len_1), str(offset_2), str(len_2)])

    if memo.get(key) is not None:
        return memo[key]

    if len_1 == 0:
        return len_2
    elif len_2 == 0:
        return len_1

    cost = 0

    if string_1[offset_1] != string_2[offset_2]:
        cost = 1

    dist = min(
        recursive_levenshtein(string_1, string_2, len_1 - 1, len_2, offset_1 + 1, offset_2, memo)
        + 1,
        recursive_levenshtein(string_1, string_2, len_1, len_2 - 1, offset_1, offset_2 + 1, memo)
        + 1,
        recursive_levenshtein(
            string_1, string_2, len_1 - 1, len_2 - 1, offset_1 + 1, offset_2 + 1, memo
        )
        + cost,
    )
    memo[key] = dist
    return dist

```

`helpers/pylev/wf.py`:

```py
import sys


PY2 = sys.version_info[0] == 2

if PY2:
    range = xrange


def wf_levenshtein(string_1, string_2):
    """
    Calculates the Levenshtein distance between two strings.

    This version uses the Wagner-Fischer algorithm.

    Usage::

        >>> wf_levenshtein('kitten', 'sitting')
        3
        >>> wf_levenshtein('kitten', 'kitten')
        0
        >>> wf_levenshtein('', '')
        0

    """
    len_1 = len(string_1) + 1
    len_2 = len(string_2) + 1

    d = [0] * (len_1 * len_2)

    for i in range(len_1):
        d[i] = i
    for j in range(len_2):
        d[j * len_1] = j

    for j in range(1, len_2):
        for i in range(1, len_1):
            if string_1[i - 1] == string_2[j - 1]:
                d[i + j * len_1] = d[i - 1 + (j - 1) * len_1]
            else:
                d[i + j * len_1] = min(
                    d[i - 1 + j * len_1] + 1,  # deletion
                    d[i + (j - 1) * len_1] + 1,  # insertion
                    d[i - 1 + (j - 1) * len_1] + 1,  # substitution
                )

    return d[-1]


def wfi_levenshtein(string_1, string_2, score_cutoff=None):
    """
    Calculates the Levenshtein distance between two strings.

    This version uses an iterative version of the Wagner-Fischer algorithm.

    Usage::

        >>> wfi_levenshtein('kitten', 'sitting')
        3
        >>> wfi_levenshtein('kitten', 'kitten')
        0
        >>> wfi_levenshtein('', '')
        0

    """
    if string_1 == string_2:
        return 0

    len_1 = len(string_1)
    len_2 = len(string_2)

    if len_1 == 0:
        return len_2
    if len_2 == 0:
        return len_1

    if len_1 > len_2:
        string_2, string_1 = string_1, string_2
        len_2, len_1 = len_1, len_2

    d0 = [i for i in range(len_2 + 1)]
    d1 = [j for j in range(len_2 + 1)]

    for i in range(len_1):
        d1[0] = i + 1
        for j in range(len_2):
            cost = d0[j]

            if string_1[i] != string_2[j]:
                # substitution
                cost += 1

                # insertion
                x_cost = d1[j] + 1
                if x_cost < cost:
                    cost = x_cost

                # deletion
                y_cost = d0[j + 1] + 1
                if y_cost < cost:
                    cost = y_cost

            d1[j + 1] = cost

        d0, d1 = d1, d0

    return d0[-1]

```

`helpers/pyperclip/LICENSE`:

```
Copyright (c) 2014, Al Sweigart
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`helpers/pyperclip/__init__.py`:

```py
"""
Pyperclip

A cross-platform clipboard module for Python, with copy & paste functions for plain text.
By Al Sweigart al@inventwithpython.com
BSD License

Usage:
  import pyperclip
  pyperclip.copy('The text to be copied to the clipboard.')
  spam = pyperclip.paste()

  if not pyperclip.is_available():
    print("Copy functionality unavailable!")

On Windows, no additional modules are needed.
On Mac, the pyobjc module is used, falling back to the pbcopy and pbpaste cli
    commands. (These commands should come with OS X.).
On Linux, install xclip, xsel, or wl-clipboard (for "wayland" sessions) via package manager.
For example, in Debian:
    sudo apt-get install xclip
    sudo apt-get install xsel
    sudo apt-get install wl-clipboard

Otherwise on Linux, you will need the qtpy or PyQt5 modules installed.

This module does not work with PyGObject yet.

Cygwin is currently not supported.

Security Note: This module runs programs with these names:
    - which
    - pbcopy
    - pbpaste
    - xclip
    - xsel
    - wl-copy/wl-paste
    - klipper
    - qdbus
A malicious user could rename or add programs with these names, tricking
Pyperclip into running them with whatever permissions the Python process has.

"""
__version__ = '1.11.0'

import base64
import contextlib
import ctypes
import os
import platform
import subprocess
import sys
import time
import warnings

from ctypes import c_size_t, sizeof, c_wchar_p, get_errno, c_wchar
from typing import Union, Optional


_IS_RUNNING_PYTHON_2 = sys.version_info[0] == 2  # type: bool

# For paste(): Python 3 uses str, Python 2 uses unicode.
if _IS_RUNNING_PYTHON_2:
    # mypy complains about `unicode` for Python 2, so we ignore the type error:
    _PYTHON_STR_TYPE = unicode  # type: ignore
else:
    _PYTHON_STR_TYPE = str

ENCODING = 'utf-8'  # type: str

try:
    # Use shutil.which() for Python 3+
    from shutil import which
    def _py3_executable_exists(name):  # type: (str) -> bool
        return bool(which(name))
    _executable_exists = _py3_executable_exists
except ImportError:
    # Use the "which" unix command for Python 2.7 and prior.
    def _py2_executable_exists(name):  # type: (str) -> bool
        return subprocess.call(['which', name],
                            stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0
    _executable_exists = _py2_executable_exists

# Exceptions
class PyperclipException(RuntimeError):
    pass

class PyperclipWindowsException(PyperclipException):
    def __init__(self, message):
        message += " (%s)" % ctypes.WinError()
        super(PyperclipWindowsException, self).__init__(message)

class PyperclipTimeoutException(PyperclipException):
    pass


def init_osx_pbcopy_clipboard():
    def copy_osx_pbcopy(text):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        p = subprocess.Popen(['pbcopy', 'w'],
                             stdin=subprocess.PIPE, close_fds=True)
        p.communicate(input=text.encode(ENCODING))

    def paste_osx_pbcopy():
        p = subprocess.Popen(['pbpaste', 'r'],
                             stdout=subprocess.PIPE, close_fds=True)
        stdout, stderr = p.communicate()
        return stdout.decode(ENCODING)

    return copy_osx_pbcopy, paste_osx_pbcopy


def init_osx_pyobjc_clipboard():
    def copy_osx_pyobjc(text):
        '''Copy string argument to clipboard'''
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        newStr = Foundation.NSString.stringWithString_(text).nsstring()
        newData = newStr.dataUsingEncoding_(Foundation.NSUTF8StringEncoding)
        board = AppKit.NSPasteboard.generalPasteboard()
        board.declareTypes_owner_([AppKit.NSStringPboardType], None)
        board.setData_forType_(newData, AppKit.NSStringPboardType)

    def paste_osx_pyobjc():
        "Returns contents of clipboard"
        board = AppKit.NSPasteboard.generalPasteboard()
        content = board.stringForType_(AppKit.NSStringPboardType)
        return content

    return copy_osx_pyobjc, paste_osx_pyobjc


def init_qt_clipboard():
    global QApplication
    # $DISPLAY should exist

    # Try to import from qtpy, but if that fails try PyQt5
    try:
        from qtpy.QtWidgets import QApplication
    except:
        from PyQt5.QtWidgets import QApplication

    app = QApplication.instance()
    if app is None:
        app = QApplication([])

    def copy_qt(text):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        cb = app.clipboard()
        cb.setText(text)

    def paste_qt():
        cb = app.clipboard()
        return _PYTHON_STR_TYPE(cb.text())

    return copy_qt, paste_qt


def init_xclip_clipboard():
    DEFAULT_SELECTION='c'
    PRIMARY_SELECTION='p'

    def copy_xclip(text, primary=False):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        selection=DEFAULT_SELECTION
        if primary:
            selection=PRIMARY_SELECTION
        p = subprocess.Popen(['xclip', '-selection', selection],
                             stdin=subprocess.PIPE, close_fds=True)
        p.communicate(input=text.encode(ENCODING))

    def paste_xclip(primary=False):
        selection=DEFAULT_SELECTION
        if primary:
            selection=PRIMARY_SELECTION
        p = subprocess.Popen(['xclip', '-selection', selection, '-o'],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
        stdout, stderr = p.communicate()
        # Intentionally ignore extraneous output on stderr when clipboard is empty
        return stdout.decode(ENCODING)

    return copy_xclip, paste_xclip


def init_xsel_clipboard():
    DEFAULT_SELECTION='-b'
    PRIMARY_SELECTION='-p'

    def copy_xsel(text, primary=False):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        selection_flag = DEFAULT_SELECTION
        if primary:
            selection_flag = PRIMARY_SELECTION
        p = subprocess.Popen(['xsel', selection_flag, '-i'],
                             stdin=subprocess.PIPE, close_fds=True)
        p.communicate(input=text.encode(ENCODING))

    def paste_xsel(primary=False):
        selection_flag = DEFAULT_SELECTION
        if primary:
            selection_flag = PRIMARY_SELECTION
        p = subprocess.Popen(['xsel', selection_flag, '-o'],
                             stdout=subprocess.PIPE, close_fds=True)
        stdout, stderr = p.communicate()
        return stdout.decode(ENCODING)

    return copy_xsel, paste_xsel


def init_wl_clipboard():
    PRIMARY_SELECTION = "-p"

    def copy_wl(text, primary=False):
        text = _PYTHON_STR_TYPE(text)  # Converts non-str values to str.
        args = ["wl-copy"]
        if primary:
            args.append(PRIMARY_SELECTION)
        if not text:
            args.append('--clear')
            subprocess.check_call(args, close_fds=True)
        else:
            pass
            p = subprocess.Popen(args, stdin=subprocess.PIPE, close_fds=True)
            p.communicate(input=text.encode(ENCODING))

    def paste_wl(primary=False):
        args = ["wl-paste", "-n", "-t", "text"]
        if primary:
            args.append(PRIMARY_SELECTION)
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
        stdout, _stderr = p.communicate()
        return stdout.decode(ENCODING)

    return copy_wl, paste_wl


def init_klipper_clipboard():
    def copy_klipper(text):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        p = subprocess.Popen(
            ['qdbus', 'org.kde.klipper', '/klipper', 'setClipboardContents',
             text.encode(ENCODING)],
            stdin=subprocess.PIPE, close_fds=True)
        p.communicate(input=None)

    def paste_klipper():
        p = subprocess.Popen(
            ['qdbus', 'org.kde.klipper', '/klipper', 'getClipboardContents'],
            stdout=subprocess.PIPE, close_fds=True)
        stdout, stderr = p.communicate()

        # Workaround for https://bugs.kde.org/show_bug.cgi?id=342874
        # TODO: https://github.com/asweigart/pyperclip/issues/43
        clipboardContents = stdout.decode(ENCODING)
        # even if blank, Klipper will append a newline at the end
        assert len(clipboardContents) > 0
        # make sure that newline is there
        assert clipboardContents.endswith('\n')
        if clipboardContents.endswith('\n'):
            clipboardContents = clipboardContents[:-1]
        return clipboardContents

    return copy_klipper, paste_klipper


def init_dev_clipboard_clipboard():
    def copy_dev_clipboard(text):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        if text == '':
            warnings.warn('Pyperclip cannot copy a blank string to the clipboard on Cygwin. This is effectively a no-op.')
        if '\r' in text:
            warnings.warn('Pyperclip cannot handle \\r characters on Cygwin.')

        fo = open('/dev/clipboard', 'wt')
        fo.write(text)
        fo.close()

    def paste_dev_clipboard():
        fo = open('/dev/clipboard', 'rt')
        content = fo.read()
        fo.close()
        return content

    return copy_dev_clipboard, paste_dev_clipboard


def init_no_clipboard():
    class ClipboardUnavailable(object):

        def __call__(self, *args, **kwargs):
            additionalInfo = ''
            if sys.platform == 'linux':
                additionalInfo = '\nOn Linux, you can run `sudo apt-get install xclip`, `sudo apt-get install xselect` (on X11) or `sudo apt-get install wl-clipboard` (on Wayland) to install a copy/paste mechanism.'
            raise PyperclipException('Pyperclip could not find a copy/paste mechanism for your system. For more information, please visit https://pyperclip.readthedocs.io/en/latest/index.html#not-implemented-error' + additionalInfo)

        if _IS_RUNNING_PYTHON_2:
            def __nonzero__(self):
                return False
        else:
            def __bool__(self):
                return False

    return ClipboardUnavailable(), ClipboardUnavailable()




# Windows-related clipboard functions:
class CheckedCall(object):
    def __init__(self, f):
        super(CheckedCall, self).__setattr__("f", f)

    def __call__(self, *args):
        ret = self.f(*args)
        if not ret and get_errno():
            raise PyperclipWindowsException("Error calling " + self.f.__name__)
        return ret

    def __setattr__(self, key, value):
        setattr(self.f, key, value)


def init_windows_clipboard():
    global HGLOBAL, LPVOID, DWORD, LPCSTR, INT, HWND, HINSTANCE, HMENU, BOOL, UINT, HANDLE
    from ctypes.wintypes import (HGLOBAL, LPVOID, DWORD, LPCSTR, INT, HWND,
                                 HINSTANCE, HMENU, BOOL, UINT, HANDLE)

    windll = ctypes.windll
    msvcrt = ctypes.CDLL('msvcrt')

    safeCreateWindowExA = CheckedCall(windll.user32.CreateWindowExA)
    safeCreateWindowExA.argtypes = [DWORD, LPCSTR, LPCSTR, DWORD, INT, INT,
                                    INT, INT, HWND, HMENU, HINSTANCE, LPVOID]
    safeCreateWindowExA.restype = HWND

    safeDestroyWindow = CheckedCall(windll.user32.DestroyWindow)
    safeDestroyWindow.argtypes = [HWND]
    safeDestroyWindow.restype = BOOL

    OpenClipboard = windll.user32.OpenClipboard
    OpenClipboard.argtypes = [HWND]
    OpenClipboard.restype = BOOL

    safeCloseClipboard = CheckedCall(windll.user32.CloseClipboard)
    safeCloseClipboard.argtypes = []
    safeCloseClipboard.restype = BOOL

    safeEmptyClipboard = CheckedCall(windll.user32.EmptyClipboard)
    safeEmptyClipboard.argtypes = []
    safeEmptyClipboard.restype = BOOL

    safeGetClipboardData = CheckedCall(windll.user32.GetClipboardData)
    safeGetClipboardData.argtypes = [UINT]
    safeGetClipboardData.restype = HANDLE

    safeSetClipboardData = CheckedCall(windll.user32.SetClipboardData)
    safeSetClipboardData.argtypes = [UINT, HANDLE]
    safeSetClipboardData.restype = HANDLE

    safeGlobalAlloc = CheckedCall(windll.kernel32.GlobalAlloc)
    safeGlobalAlloc.argtypes = [UINT, c_size_t]
    safeGlobalAlloc.restype = HGLOBAL

    safeGlobalLock = CheckedCall(windll.kernel32.GlobalLock)
    safeGlobalLock.argtypes = [HGLOBAL]
    safeGlobalLock.restype = LPVOID

    safeGlobalUnlock = CheckedCall(windll.kernel32.GlobalUnlock)
    safeGlobalUnlock.argtypes = [HGLOBAL]
    safeGlobalUnlock.restype = BOOL

    wcslen = CheckedCall(msvcrt.wcslen)
    wcslen.argtypes = [c_wchar_p]
    wcslen.restype = UINT

    GMEM_MOVEABLE = 0x0002
    CF_UNICODETEXT = 13

    @contextlib.contextmanager
    def window():
        """
        Context that provides a valid Windows hwnd.
        """
        # we really just need the hwnd, so setting "STATIC"
        # as predefined lpClass is just fine.
        hwnd = safeCreateWindowExA(0, b"STATIC", None, 0, 0, 0, 0, 0,
                                   None, None, None, None)
        try:
            yield hwnd
        finally:
            safeDestroyWindow(hwnd)

    @contextlib.contextmanager
    def clipboard(hwnd):
        """
        Context manager that opens the clipboard and prevents
        other applications from modifying the clipboard content.
        """
        # We may not get the clipboard handle immediately because
        # some other application is accessing it (?)
        # We try for at least 500ms to get the clipboard.
        t = time.time() + 0.5
        success = False
        while time.time() < t:
            success = OpenClipboard(hwnd)
            if success:
                break
            time.sleep(0.01)
        if not success:
            raise PyperclipWindowsException("Error calling OpenClipboard")

        try:
            yield
        finally:
            safeCloseClipboard()

    def copy_windows(text):
        # This function is heavily based on
        # http://msdn.com/ms649016#_win32_Copying_Information_to_the_Clipboard

        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.

        with window() as hwnd:
            # http://msdn.com/ms649048
            # If an application calls OpenClipboard with hwnd set to NULL,
            # EmptyClipboard sets the clipboard owner to NULL;
            # this causes SetClipboardData to fail.
            # => We need a valid hwnd to copy something.
            with clipboard(hwnd):
                safeEmptyClipboard()

                if text:
                    # http://msdn.com/ms649051
                    # If the hMem parameter identifies a memory object,
                    # the object must have been allocated using the
                    # function with the GMEM_MOVEABLE flag.
                    count = wcslen(text) + 1
                    handle = safeGlobalAlloc(GMEM_MOVEABLE,
                                             count * sizeof(c_wchar))
                    locked_handle = safeGlobalLock(handle)

                    ctypes.memmove(c_wchar_p(locked_handle), c_wchar_p(text), count * sizeof(c_wchar))

                    safeGlobalUnlock(handle)
                    safeSetClipboardData(CF_UNICODETEXT, handle)

    def paste_windows():
        with clipboard(None):
            handle = safeGetClipboardData(CF_UNICODETEXT)
            if not handle:
                # GetClipboardData may return NULL with errno == NO_ERROR
                # if the clipboard is empty.
                # (Also, it may return a handle to an empty buffer,
                # but technically that's not empty)
                return ""
            locked_handle = safeGlobalLock(handle)
            return_value = c_wchar_p(locked_handle).value
            safeGlobalUnlock(handle)
            return return_value

    return copy_windows, paste_windows


def init_wsl_clipboard():

    def copy_wsl(text):
        text = _PYTHON_STR_TYPE(text) # Converts non-str values to str.
        p = subprocess.Popen(['clip.exe'],
                             stdin=subprocess.PIPE, close_fds=True)
        p.communicate(input=text.encode('utf-16le'))

    def paste_wsl():
        ps_script = '[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes((Get-Clipboard -Raw)))'

        # '-noprofile' speeds up load time
        p = subprocess.Popen(['powershell.exe', '-noprofile', '-command', ps_script],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             close_fds=True)
        stdout, stderr = p.communicate()

        if stderr:
            raise Exception(f"Error pasting from clipboard: {stderr}")

        try:
            base64_encoded = stdout.decode('utf-8').strip()
            decoded_bytes = base64.b64decode(base64_encoded)
            return decoded_bytes.decode('utf-8')
        except Exception as e:
            raise RuntimeError(f"Decoding error: {e}")

    return copy_wsl, paste_wsl


# Automatic detection of clipboard mechanisms and importing is done in determine_clipboard():
def determine_clipboard():
    '''
    Determine the OS/platform and set the copy() and paste() functions
    accordingly.
    '''

    global Foundation, AppKit, qtpy, PyQt5

    # Setup for the CYGWIN platform:
    if 'cygwin' in platform.system().lower(): # Cygwin has a variety of values returned by platform.system(), such as 'CYGWIN_NT-6.1'
        # FIXME: pyperclip currently does not support Cygwin,
        # see https://github.com/asweigart/pyperclip/issues/55
        if os.path.exists('/dev/clipboard'):
            warnings.warn('Pyperclip\'s support for Cygwin is not perfect, see https://github.com/asweigart/pyperclip/issues/55')
            return init_dev_clipboard_clipboard()

    # Setup for the WINDOWS platform:
    elif os.name == 'nt' or platform.system() == 'Windows':
        return init_windows_clipboard()

    if platform.system() == 'Linux' and os.path.isfile('/proc/version'):
        with open('/proc/version', 'r') as f:
            if "microsoft" in f.read().lower():
                return init_wsl_clipboard()

    # Setup for the MAC OS X platform:
    if os.name == 'mac' or platform.system() == 'Darwin':
        try:
            import Foundation  # check if pyobjc is installed
            import AppKit
        except ImportError:
            return init_osx_pbcopy_clipboard()
        else:
            return init_osx_pyobjc_clipboard()

    # Setup for the LINUX platform:

    if os.getenv("WAYLAND_DISPLAY") and _executable_exists("wl-copy")  and _executable_exists("wl-paste"):
        return init_wl_clipboard()

    # `import PyQt4` sys.exit()s if DISPLAY is not in the environment.
    # Thus, we need to detect the presence of $DISPLAY manually
    # and not load PyQt4 if it is absent.
    elif os.getenv("DISPLAY"):
        if _executable_exists("xclip"):
            # Note: 2024/06/18 Google Trends shows xclip as more popular than xsel.
            return init_xclip_clipboard()
        if _executable_exists("xsel"):
            return init_xsel_clipboard()
        if _executable_exists("klipper") and _executable_exists("qdbus"):
            return init_klipper_clipboard()

        try:
            # qtpy is a small abstraction layer that lets you write
            # applications using a single api call to either PyQt or PySide.
            # https://pypi.python.org/pypi/QtPy
            import qtpy  # check if qtpy is installed
            return init_qt_clipboard()
        except ImportError:
            pass

        # If qtpy isn't installed, fall back on importing PyQt5
        try:
            import PyQt5  # check if PyQt5 is installed
            return init_qt_clipboard()
        except ImportError:
            pass

    return init_no_clipboard()


def set_clipboard(clipboard):
    '''
    Explicitly sets the clipboard mechanism. The "clipboard mechanism" is how
    the copy() and paste() functions interact with the operating system to
    implement the copy/paste feature. The clipboard parameter must be one of:
        - pbcopy
        - pbobjc (default on Mac OS X)
        - qt
        - xclip
        - xsel
        - klipper
        - windows (default on Windows)
        - no (this is what is set when no clipboard mechanism can be found)
    '''
    global copy, paste

    clipboard_types = {
        "pbcopy": init_osx_pbcopy_clipboard,
        "pyobjc": init_osx_pyobjc_clipboard,
        "qt": init_qt_clipboard,  # TODO - split this into 'qtpy' and 'pyqt5'
        "xclip": init_xclip_clipboard,
        "xsel": init_xsel_clipboard,
        "wl-clipboard": init_wl_clipboard,
        "klipper": init_klipper_clipboard,
        "windows": init_windows_clipboard,
        "no": init_no_clipboard,
    }

    if clipboard not in clipboard_types:
        raise ValueError('Argument must be one of %s' % (', '.join([repr(_) for _ in clipboard_types.keys()])))

    # Sets pyperclip's copy() and paste() functions:
    copy, paste = clipboard_types[clipboard]()


def lazy_load_stub_copy(text):
    '''
    A stub function for copy(), which will load the real copy() function when
    called so that the real copy() function is used for later calls.

    This allows users to import pyperclip without having determine_clipboard()
    automatically run, which will automatically select a clipboard mechanism.
    This could be a problem if it selects, say, the memory-heavy PyQt5 module
    but the user was just going to immediately call set_clipboard() to use a
    different clipboard mechanism.

    The lazy loading this stub function implements gives the user a chance to
    call set_clipboard() to pick another clipboard mechanism. Or, if the user
    simply calls copy() or paste() without calling set_clipboard() first,
    will fall back on whatever clipboard mechanism that determine_clipboard()
    automatically chooses.
    '''
    global copy, paste
    copy, paste = determine_clipboard()
    return copy(text)


def lazy_load_stub_paste():
    '''
    A stub function for paste(), which will load the real paste() function when
    called so that the real paste() function is used for later calls.

    This allows users to import pyperclip without having determine_clipboard()
    automatically run, which will automatically select a clipboard mechanism.
    This could be a problem if it selects, say, the memory-heavy PyQt5 module
    but the user was just going to immediately call set_clipboard() to use a
    different clipboard mechanism.

    The lazy loading this stub function implements gives the user a chance to
    call set_clipboard() to pick another clipboard mechanism. Or, if the user
    simply calls copy() or paste() without calling set_clipboard() first,
    will fall back on whatever clipboard mechanism that determine_clipboard()
    automatically chooses.
    '''
    global copy, paste
    copy, paste = determine_clipboard()
    return paste()


def is_available():
    return copy != lazy_load_stub_copy and paste != lazy_load_stub_paste


# Initially, copy() and paste() are set to lazy loading wrappers which will
# set `copy` and `paste` to real functions the first time they're used, unless
# set_clipboard() or determine_clipboard() is called first.
copy, paste = lazy_load_stub_copy, lazy_load_stub_paste



__all__ = ['copy', 'paste', 'set_clipboard', 'determine_clipboard']

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "mcrit-ida",
    "version": "1.1.4",
    "entryPoint": "ida_mcrit.py",
    "idaVersions": ">=8.4",
    "description": "Integration with MCRIT server for code similarity analysis.",
    "license": "GPL-3.0",
    "logoPath": "icons/mcrit.png",
    "categories": [
      "malware-analysis",
      "integration-with-third-parties-interoperability"
    ],
    "keywords": [
      "mcrit",
      "minhash",
      "smda",
      "code-similarity",
      "malware-analysis",
      "yara"
    ],
    "pythonDependencies": [
      "smda>=2.4.6",
      "ida-settings>=3.3.0"
    ],
    "urls": {
      "repository": "https://github.com/danielplohmann/mcrit-plugins"
    },
    "authors": [
      {
        "name": "Daniel Plohmann",
        "email": "daniel.plohmann@fkie.fraunhofer.de"
      }
    ],
    "settings": [
      {
        "key": "mcritweb_username",
        "type": "string",
        "required": false,
        "default": "",
        "name": "MCRITWeb Username",
        "documentation": "Username for MCRITWeb (optional if API Token is provided)."
      },
      {
        "key": "mcrit_server",
        "type": "string",
        "required": false,
        "default": "http://127.0.0.1:8000/",
        "name": "MCRIT Server URL",
        "documentation": "URL of the MCRIT server."
      },
      {
        "key": "mcritweb_api_token",
        "type": "string",
        "required": false,
        "default": "",
        "name": "MCRITWeb API Token",
        "documentation": "API Token for MCRITWeb authentication."
      },
      {
        "key": "auto_analyze_smda_on_startup",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Auto Analyze SMDA on Startup",
        "documentation": "Automatically convert IDB to SMDA on plugin startup."
      },
      {
        "key": "use_smda_for_analysis",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Use SMDA for Analysis",
        "documentation": "Use SMDA for code analysis instead of IDA's engine."
      },
      {
        "key": "submit_function_names_on_close",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Submit Function Names on Close",
        "documentation": "Ask to upload updated function names to MCRIT server on close."
      },
      {
        "key": "blocks_filter_library_functions",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Blocks: Filter Library Functions",
        "documentation": "Filter out library functions in Block Scope Widget."
      },
      {
        "key": "blocks_live_query",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Blocks: Live Query",
        "documentation": "Enable live query in Block Scope Widget."
      },
      {
        "key": "blocks_min_size",
        "type": "string",
        "required": false,
        "default": "4",
        "name": "Blocks: Minimum Size",
        "documentation": "Minimum block size for Block Scope Widget."
      },
      {
        "key": "function_filter_library_functions",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Functions: Filter Library Functions",
        "documentation": "Filter out library functions in Function Scope Widget."
      },
      {
        "key": "function_live_query",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Functions: Live Query",
        "documentation": "Enable live query in Function Scope Widget."
      },
      {
        "key": "function_min_score",
        "type": "string",
        "required": false,
        "default": "50",
        "name": "Functions: Minimum Score",
        "documentation": "Minimum score for Function Scope Widget."
      },
      {
        "key": "overview_fetch_labels_automatically",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Overview: Fetch Labels Automatically",
        "documentation": "Automatically fetch labels in Function Overview Widget."
      },
      {
        "key": "overview_filter_to_labels",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Overview: Filter to Labels",
        "documentation": "Filter to labels in Function Overview Widget."
      },
      {
        "key": "overview_filter_to_conflicts",
        "type": "boolean",
        "required": false,
        "default": false,
        "name": "Overview: Filter to Conflicts",
        "documentation": "Filter to conflicts in Function Overview Widget."
      },
      {
        "key": "overview_min_score",
        "type": "string",
        "required": false,
        "default": "50",
        "name": "Overview: Minimum Score",
        "documentation": "Minimum score for Function Overview Widget."
      }
    ]
  }
}

```

`ida_mcrit.py`:

```py
#!/usr/bin/python
"""
MCRIT4IDA - integration with MCRIT server
code inspired by and based on IDAscope
"""

import ida_idaapi
import ida_kernwin
import idaapi
from ida_kernwin import PluginForm

try:
    from smda.common.SmdaReport import SmdaReport
    from smda.ida.IdaInterface import IdaInterface
except Exception as exc:
    SmdaReport = None
    IdaInterface = None
    _SMDA_IMPORT_ERROR = exc
else:
    _SMDA_IMPORT_ERROR = None

import config
import helpers.pyperclip as pyperclip
import helpers.QtShim as QtShim
from helpers.ClassCollection import ClassCollection
from helpers.McritInterface import McritInterface
from widgets.BlockMatchWidget import BlockMatchWidget
from widgets.FunctionMatchWidget import FunctionMatchWidget
from widgets.FunctionOverviewWidget import FunctionOverviewWidget
from widgets.LocalInfoWidget import LocalInfoWidget
from widgets.MainWidget import MainWidget
from widgets.SampleInfoWidget import SampleInfoWidget

QtGui = QtShim.get_QtGui()
QtCore = QtShim.get_QtCore()
QtWidgets = QtShim.get_QtWidgets()

################################################################################
# Core of the MCRIT4IDA GUI.
################################################################################

HOTKEYS = None
MCRIT4IDA = None
NAME = "MCRIT4IDA v%s" % config.VERSION

G_FORM = None


class IdaViewHooks(idaapi.View_Hooks):
    """
    Courtesy of Alex Hanel's FunctionTrapperKeeper
    https://github.com/alexander-hanel/FunctionTrapperKeeper/blob/main/function_trapper_keeper.py
    """

    def __init__(self, form):
        super().__init__()
        self.form = form

    def view_curpos(self, view):
        self.refresh_widget(view)

    def view_dblclick(self, view, event):
        self.refresh_widget(view)

    def view_click(self, view, event):
        self.refresh_widget(view)

    def view_loc_changed(self, view, now, was):
        self.refresh_widget(view)

    def refresh_widget(self, view):
        if not self.form:
            return
        for widget in self.form.hook_subscribed_widgets:
            widget.hook_refresh(view)


class Mcrit4IdaForm(PluginForm):
    """
    This class contains the main window of MCRIT4IDA
    Setup of core modules and widgets is performed in here.
    """

    def __init__(self):
        super(Mcrit4IdaForm, self).__init__()
        global HOTKEYS
        HOTKEYS = []
        self.cc = ClassCollection(QtShim)
        self.tabs = None
        self.parent = None
        self.config = config
        #### local state used to populate and exchange information across widgets
        self.remote_sample_id = None
        self.remote_sample_entry = None
        self.local_smda_report = None
        # the smda_report without xcfg part
        self.local_smda_report_outline = None
        # after selecting a finished remote job, this is the cached data
        self.matching_job_id = None
        self.matching_report = None
        self.matched_function_entries = None
        # cached function matches that result from Function Scope queries
        self.current_block = None
        self.current_function = None
        self.function_matches = {}
        # offset to PicBlockHash
        self.block_to_hash = {}
        # PicBlockHash to matches from remote server
        self.blockhash_matches = {}
        # unused
        self.remote_function_mapping = {}
        self.sample_infos = {}
        self.family_infos = None
        self.function_id_to_offset = {}
        self.pichash_matches = {}
        self.pichash_match_summaries = {}
        self.picblockhash_matches = {}
        ##### some more setup
        self.icon = self.cc.QIcon(config.ICON_FILE_PATH + "relationship.png")
        self.mcrit_interface = McritInterface(self)
        self.hook_subscribed_widgets = []
        self.view_hook = None

    def copyStringToClipboard(self, string_to_copy: str):
        if string_to_copy is not None:
            pyperclip.copy(string_to_copy)
            print('Copied "%s" to clipboard.' % string_to_copy)

    def getMatchingReport(self):
        return self.matching_report

    def getSampleInfos(self):
        return self.sample_infos

    def getFunctionInfos(self):
        return self.remote_function_mapping

    def getLocalSmdaReport(self):
        return self.local_smda_report

    def getLocalSmdaReportOutline(self):
        if self.local_smda_report_outline is None and self.local_smda_report:
            report_as_dict = self.local_smda_report.toDict()
            report_as_dict["xcfg"] = {}
            self.local_smda_report_outline = SmdaReport.fromDict(report_as_dict)
        return self.local_smda_report_outline

    def getRemoteSampleInformation(self):
        time_before = self.cc.time.time()
        print("[/] starting download of meta data from MCRIT...")
        self.mcrit_interface.queryAllFamilyEntries()
        print("[|] downloaded FamilyEntries!")
        self.mcrit_interface.queryAllSampleEntries()
        print("[|] downloaded SampleEntries!")
        print("[\\] this took %3.2f seconds.\n" % (self.cc.time.time() - time_before))
        self.local_widget.updateActivityInfo("Downloaded all family/sample information from MCRIT")

    def setupWidgets(self):
        """
        Setup MCRIT4IDA widgets.
        """
        time_before = self.cc.time.time()
        print("[/] setting up widgets...")
        self.local_widget = LocalInfoWidget(self)
        self.block_match_widget = BlockMatchWidget(self)
        self.function_match_widget = FunctionMatchWidget(self)
        self.sample_widget = SampleInfoWidget(self)
        self.function_widget = FunctionOverviewWidget(self)
        self.main_widget = MainWidget(self)
        self.hook_subscribed_widgets.append(self.function_match_widget)
        self.hook_subscribed_widgets.append(self.block_match_widget)
        # produce layout and render
        layout = self.cc.QVBoxLayout()
        layout.addWidget(self.main_widget)
        self.parent.setLayout(layout)
        print("[\\] this took %3.2f seconds.\n" % (self.cc.time.time() - time_before))

    def OnCreate(self, form):
        """
        When creating the form, setup the shared modules and widgets
        """
        print("[+] Loading MCRIT4IDA")
        # compatibility with IDA < 6.9
        self.view_hook = IdaViewHooks(self)
        self.view_hook.hook()
        try:
            self.parent = self.FormToPySideWidget(form)
        except Exception:
            self.parent = self.FormToPyQtWidget(form)
        self.parent.setWindowIcon(self.icon)
        self.setupWidgets()
        if self.config.AUTO_ANALYZE_SMDA_ON_STARTUP:
            # simulate button click on "Convert IDB to SMDA" to capture potential family info
            print("Performing automatic SMDA analysis on startup...")
            self.main_widget._onConvertSmdaButtonClicked()

    def OnClose(self, form):
        """
        Perform cleanup.
        """
        # check if there is a mismatch between function names stored in self.local_smda_report and the atual IDB
        # if yes, ask the user if they want to upload an updated report to the MCRIT server
        if config.SUBMIT_FUNCTION_NAMES_ON_CLOSE:
            ida_interface = IdaInterface()
            ida_function_names = ida_interface.getFunctionSymbols()
            print("Checking for unsynced function names...")
            if self.local_smda_report is not None:
                smda_report_function_names = {
                    func.offset: func.function_name
                    for func in self.local_smda_report.getFunctions()
                    if func.function_name
                }
                unsynced_function_names = []
                for offset, ida_function_name in ida_function_names.items():
                    smda_function_name = smda_report_function_names.get(offset, None)
                    if smda_function_name is not None and smda_function_name != ida_function_name:
                        unsynced_function_names.append(
                            (offset, smda_function_name, ida_function_name)
                        )
                    if offset not in smda_report_function_names:
                        unsynced_function_names.append((offset, None, ida_function_name))
                if len(unsynced_function_names) > 0:
                    # currently this loops infinitely?!
                    res = ida_kernwin.ask_yn(
                        0,
                        "There are new function name changes in the IDB. Do you want to upload an updated report to the MCRIT server before closing?",
                    )
                    if res == ida_kernwin.ASKBTN_YES:
                        # save metadata before upload to not overwrite it
                        local_family = (
                            self.local_smda_report.family if self.local_smda_report else ""
                        )
                        local_version = (
                            self.local_smda_report.version if self.local_smda_report else ""
                        )
                        local_library = (
                            self.local_smda_report.is_library if self.local_smda_report else False
                        )
                        # update before export, to ensure we have all most recent function label information
                        self.local_smda_report = self.main_widget.getLocalSmdaReport()
                        self.local_smda_report.family = local_family
                        self.local_smda_report.version = local_version
                        self.local_smda_report.is_library = local_library
                        self.mcrit_interface.uploadReport(self.local_smda_report)
            else:
                # we need to decide if we want to prompt the user in order to push an initial SMDA report to MCRIT or not
                pass
        if self.view_hook is not None:
            self.view_hook.unhook()
            self.view_hook = None
        self.hook_subscribed_widgets = []
        global G_FORM
        if G_FORM is self:
            G_FORM = None
        global MCRIT4IDA
        if MCRIT4IDA is self:
            MCRIT4IDA = None

    def Show(self):
        if self.cc.ida_proxy.GetInputMD5() is not None:
            return PluginForm.Show(
                self,
                NAME,
                options=(
                    PluginForm.WCLS_CLOSE_LATER | PluginForm.WOPN_RESTORE | PluginForm.WCLS_SAVE
                ),
            )
        return None

    ################################################################################
    # functionality offered to MCRIT4IDA's widgets
    ################################################################################

    def registerHotkey(self, shortcut, py_function_pointer):
        """
        Can be used by MCRIT4IDA widgets to register hotkeys.
        Uses a global list HOTKEYS of function pointers that link to the desired functionality.
        Right now, linked functions cannot take parameters and should scrape all information they need by themselves.
        @param shortcut: A string describing a shortcut, e.g. "ctrl+F3"
        @type shortcut: str
        @param py_function_pointer: a python function that shall be called when the shortcut is triggered.
        @type py_function_pointer: a pointer to a python function
        """
        global HOTKEYS
        hotkey_index = len(HOTKEYS)
        hotkey_name = "MCRIT4IDA_HOTKEY_%d" % hotkey_index
        HOTKEYS.append(py_function_pointer)
        self.cc.ida_proxy.CompileLine(
            'static %s() { RunPythonStatement("HOTKEYS[%d]()"); }' % (hotkey_name, hotkey_index)
        )
        self.cc.ida_proxy.AddHotkey(shortcut, hotkey_name)


################################################################################
# Usage as plugin
################################################################################


def PLUGIN_ENTRY():
    return Mcrit4IdaPlugin()


def show_mcrit_form():
    global MCRIT4IDA
    created_form = False
    if MCRIT4IDA is None:
        try:
            MCRIT4IDA = Mcrit4IdaForm()
            created_form = True
        except ImportError as exc:
            ida_kernwin.warning(str(exc))
            return None
    if MCRIT4IDA.Show() is None:
        if created_form:
            try:
                MCRIT4IDA.OnClose(MCRIT4IDA)
            except Exception as exc:
                print(f"[!] Error closing MCRIT4IDA after failed show: {exc}")
            MCRIT4IDA = None
        return None
    global G_FORM
    G_FORM = MCRIT4IDA
    return MCRIT4IDA


class Mcrit4IdaPlugmod(ida_idaapi.plugmod_t):
    def __init__(self):
        super().__init__()
        self.form = None

    def run(self, arg):
        self.form = show_mcrit_form()
        return True


class Mcrit4IdaPlugin(ida_idaapi.plugin_t):
    """
    Plugin version of MCRIT4IDA. Use this to deploy MCRIT4IDA via IDA plugins folder.
    """

    flags = ida_idaapi.PLUGIN_MULTI
    comment = NAME
    help = "MCRIT4IDA - Plugin to interact with a MCRIT server."
    wanted_name = "MCRIT4IDA"
    wanted_hotkey = "Ctrl-F4"

    def init(self):
        # Some initialization
        self.icon_id = 0
        return Mcrit4IdaPlugmod()

    def run(self, arg):
        show_mcrit_form()
        return True


################################################################################
# Usage as script
################################################################################


def main():
    global MCRIT4IDA
    if MCRIT4IDA is not None:
        try:
            MCRIT4IDA.OnClose(MCRIT4IDA)
            print("reloading MCRIT4IDA")
        except Exception:
            pass
        MCRIT4IDA = None

    if config.MCRIT4IDA_PLUGIN_ONLY:
        print("MCRIT4IDA: configured as plugin-only mode, ignoring main function of script.")
        return

    show_mcrit_form()


if __name__ == "__main__":
    main()

```

`pyproject.toml`:

```toml
[tool.ruff]
target-version = "py38"
line-length = 100
exclude = [
    ".git",
    ".vscode",
    "helpers/minimcrit",
    "helpers/pylev",
    "helpers/pyperclip",
    "icons",
    "qt-designer-mockup",
]

[tool.ruff.lint]
select = ["E4", "E7", "E9", "F", "I"]

[tool.ruff.format]
line-ending = "lf"

```

`qt-designer-mockup/Mockup.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1264</width>
    <height>1599</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout">
   <property name="sizeConstraint">
    <enum>QLayout::SetNoConstraint</enum>
   </property>
   <item>
    <widget class="QTabWidget" name="tabIdaMockWidget">
     <property name="sizePolicy">
      <sizepolicy hsizetype="MinimumExpanding" vsizetype="MinimumExpanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="currentIndex">
      <number>1</number>
     </property>
     <widget class="QWidget" name="tabIdaView">
      <attribute name="title">
       <string>IDA View-A</string>
      </attribute>
     </widget>
     <widget class="QWidget" name="tabMcritView">
      <attribute name="title">
       <string>MCRIT</string>
      </attribute>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QToolButton" name="toolButton">
         <property name="toolTip">
          <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Convert IDB to SMDA Report&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="icon">
          <iconset>
           <normaloff>../../../../../../Documents/glyphicons-pro/glyphicons-basic-2-2/png/glyphicons-basic-86-reload.png</normaloff>../../../../../../Documents/glyphicons-pro/glyphicons-basic-2-2/png/glyphicons-basic-86-reload.png</iconset>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_4">
         <property name="text">
          <string>Info: 2019-08-07 13:28:06 | Received matching data from MCRIT server.</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="Line" name="line">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Local Sample Overview</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QTableWidget" name="tableWidget">
         <property name="sizePolicy">
          <sizepolicy hsizetype="MinimumExpanding" vsizetype="MinimumExpanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="minimumSize">
          <size>
           <width>0</width>
           <height>210</height>
          </size>
         </property>
         <property name="verticalScrollBarPolicy">
          <enum>Qt::ScrollBarAsNeeded</enum>
         </property>
         <property name="autoScroll">
          <bool>true</bool>
         </property>
         <property name="alternatingRowColors">
          <bool>true</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <row>
          <property name="text">
           <string>1</string>
          </property>
         </row>
         <row>
          <property name="text">
           <string>2</string>
          </property>
         </row>
         <row>
          <property name="text">
           <string>3</string>
          </property>
         </row>
         <row>
          <property name="text">
           <string>4</string>
          </property>
         </row>
         <row>
          <property name="text">
           <string>5</string>
          </property>
         </row>
         <row>
          <property name="text">
           <string>6</string>
          </property>
         </row>
         <column>
          <property name="text">
           <string>Field</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Value</string>
          </property>
         </column>
         <item row="0" column="0">
          <property name="text">
           <string>Architecture</string>
          </property>
         </item>
         <item row="0" column="1">
          <property name="text">
           <string>Intel</string>
          </property>
         </item>
         <item row="1" column="0">
          <property name="text">
           <string>Bitness</string>
          </property>
         </item>
         <item row="1" column="1">
          <property name="text">
           <string>32bit</string>
          </property>
         </item>
         <item row="2" column="0">
          <property name="text">
           <string>ImageBase</string>
          </property>
         </item>
         <item row="2" column="1">
          <property name="text">
           <string>0x00400000</string>
          </property>
         </item>
         <item row="3" column="0">
          <property name="text">
           <string>Size</string>
          </property>
         </item>
         <item row="3" column="1">
          <property name="text">
           <string>104,131</string>
          </property>
         </item>
         <item row="4" column="0">
          <property name="text">
           <string>Functions</string>
          </property>
         </item>
         <item row="4" column="1">
          <property name="text">
           <string>641</string>
          </property>
         </item>
         <item row="5" column="0">
          <property name="text">
           <string>Instructions</string>
          </property>
         </item>
         <item row="5" column="1">
          <property name="text">
           <string>36,051</string>
          </property>
         </item>
        </widget>
       </item>
       <item>
        <widget class="QTabWidget" name="tabMcritWidget">
         <property name="enabled">
          <bool>true</bool>
         </property>
         <property name="sizePolicy">
          <sizepolicy hsizetype="MinimumExpanding" vsizetype="MinimumExpanding">
           <horstretch>1</horstretch>
           <verstretch>1</verstretch>
          </sizepolicy>
         </property>
         <property name="maximumSize">
          <size>
           <width>20000</width>
           <height>20000</height>
          </size>
         </property>
         <property name="currentIndex">
          <number>0</number>
         </property>
         <widget class="QWidget" name="tabSampleMatches">
          <attribute name="title">
           <string>Sample Matches</string>
          </attribute>
          <layout class="QVBoxLayout" name="verticalLayout_2">
           <item>
            <widget class="QCheckBox" name="checkBox">
             <property name="text">
              <string>Filter Library Matches (37)</string>
             </property>
             <property name="checked">
              <bool>true</bool>
             </property>
            </widget>
           </item>
           <item>
            <widget class="Line" name="line_2">
             <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="label">
             <property name="text">
              <string>Best Family Matches</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QTableWidget" name="familyMatchTable">
             <property name="alternatingRowColors">
              <bool>true</bool>
             </property>
             <property name="sortingEnabled">
              <bool>true</bool>
             </property>
             <attribute name="horizontalHeaderCascadingSectionResizes">
              <bool>false</bool>
             </attribute>
             <attribute name="horizontalHeaderDefaultSectionSize">
              <number>150</number>
             </attribute>
             <attribute name="horizontalHeaderMinimumSectionSize">
              <number>64</number>
             </attribute>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <row>
              <property name="text">
               <string>1</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>2</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>3</string>
              </property>
             </row>
             <column>
              <property name="text">
               <string>Family</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Version</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>PicHash Matches</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>MinHash Matches</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Combined</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Score</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Percent</string>
              </property>
             </column>
             <item row="0" column="0">
              <property name="text">
               <string>win.ice_ix</string>
              </property>
             </item>
             <item row="0" column="1">
              <property name="text">
               <string>2012-01-20-1.2.6.0</string>
              </property>
             </item>
             <item row="0" column="2">
              <property name="text">
               <string>437</string>
              </property>
             </item>
             <item row="0" column="3">
              <property name="text">
               <string>535</string>
              </property>
             </item>
             <item row="0" column="4">
              <property name="text">
               <string>620</string>
              </property>
             </item>
             <item row="0" column="5">
              <property name="text">
               <string>95,590</string>
              </property>
             </item>
             <item row="0" column="6">
              <property name="text">
               <string>91.79</string>
              </property>
             </item>
             <item row="1" column="0">
              <property name="text">
               <string>win.citadel</string>
              </property>
             </item>
             <item row="1" column="1">
              <property name="text">
               <string>2012-06-15-1.3.4.5</string>
              </property>
             </item>
             <item row="1" column="2">
              <property name="text">
               <string>382</string>
              </property>
             </item>
             <item row="1" column="3">
              <property name="text">
               <string>420</string>
              </property>
             </item>
             <item row="1" column="4">
              <property name="text">
               <string>556</string>
              </property>
             </item>
             <item row="1" column="5">
              <property name="text">
               <string>72,636</string>
              </property>
             </item>
             <item row="1" column="6">
              <property name="text">
               <string>69.75</string>
              </property>
             </item>
             <item row="2" column="0">
              <property name="text">
               <string>win.vmzeus</string>
              </property>
             </item>
             <item row="2" column="1">
              <property name="text">
               <string>2015-08-07-3.1.0.0</string>
              </property>
             </item>
             <item row="2" column="2">
              <property name="text">
               <string>321</string>
              </property>
             </item>
             <item row="2" column="3">
              <property name="text">
               <string>375</string>
              </property>
             </item>
             <item row="2" column="4">
              <property name="text">
               <string>407</string>
              </property>
             </item>
             <item row="2" column="5">
              <property name="text">
               <string>58,388</string>
              </property>
             </item>
             <item row="2" column="6">
              <property name="text">
               <string>48.17</string>
              </property>
             </item>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="label_2">
             <property name="text">
              <string>Sample Matches within Family: win.citadel</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QTableWidget" name="sampleMatchTable">
             <property name="alternatingRowColors">
              <bool>true</bool>
             </property>
             <attribute name="horizontalHeaderDefaultSectionSize">
              <number>150</number>
             </attribute>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <row>
              <property name="text">
               <string>1</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>2</string>
              </property>
             </row>
             <column>
              <property name="text">
               <string>SHA256</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Sample ID</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Version</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>PicHash Matches</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>MinHash Matches</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Score</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Percent</string>
              </property>
             </column>
             <item row="0" column="0">
              <property name="text">
               <string>2c5ab3b92df90bf933da41bc1f3dfb140331c39c0d2d9381913fa73d2cc2ab74</string>
              </property>
             </item>
             <item row="0" column="1">
              <property name="text">
               <string>43</string>
              </property>
             </item>
             <item row="0" column="2">
              <property name="text">
               <string>2012-06-15-1.3.4.5</string>
              </property>
             </item>
             <item row="0" column="3">
              <property name="text">
               <string>420</string>
              </property>
             </item>
             <item row="0" column="4">
              <property name="text">
               <string>556</string>
              </property>
             </item>
             <item row="0" column="5">
              <property name="text">
               <string>72,636</string>
              </property>
             </item>
             <item row="0" column="6">
              <property name="text">
               <string>69.75</string>
              </property>
             </item>
             <item row="1" column="0">
              <property name="text">
               <string>97bf981931c9d52abff35eef3ede355e51c61014fad6c9f2698f15d24c14335a</string>
              </property>
             </item>
             <item row="1" column="1">
              <property name="text">
               <string>44</string>
              </property>
             </item>
             <item row="1" column="2">
              <property name="text">
               <string>2012-11-08-1.3.5.1</string>
              </property>
             </item>
             <item row="1" column="3">
              <property name="text">
               <string>386</string>
              </property>
             </item>
             <item row="1" column="4">
              <property name="text">
               <string>510</string>
              </property>
             </item>
             <item row="1" column="5">
              <property name="text">
               <string>67,352</string>
              </property>
             </item>
             <item row="1" column="6">
              <property name="text">
               <string>64.32</string>
              </property>
             </item>
            </widget>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="tabFunctionMatches">
          <attribute name="title">
           <string>Function Matches</string>
          </attribute>
          <layout class="QVBoxLayout" name="verticalLayout_3">
           <item>
            <widget class="QCheckBox" name="checkBox_2">
             <property name="text">
              <string>Filter to Library Functions</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QComboBox" name="comboBox">
             <item>
              <property name="text">
               <string>MinHash Threshold: 80</string>
              </property>
             </item>
            </widget>
           </item>
           <item>
            <widget class="Line" name="line_3">
             <property name="orientation">
              <enum>Qt::Horizontal</enum>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="label_5">
             <property name="text">
              <string>Local Functions</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QTableWidget" name="tableWidget_2">
             <attribute name="horizontalHeaderDefaultSectionSize">
              <number>150</number>
             </attribute>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <row>
              <property name="text">
               <string>1</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>2</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>3</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>4</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>5</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>6</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>7</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>8</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>9</string>
              </property>
             </row>
             <column>
              <property name="text">
               <string>Offset</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Function Name</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>PicHash Family</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>PicHash Sample</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>MinHash Family</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>MinHash Sample</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>LibraryMatch?</string>
              </property>
             </column>
             <item row="0" column="0">
              <property name="text">
               <string>0x407BF0</string>
              </property>
             </item>
             <item row="0" column="1">
              <property name="text">
               <string>sub_407BF0</string>
              </property>
             </item>
             <item row="0" column="2">
              <property name="text">
               <string>4</string>
              </property>
             </item>
             <item row="0" column="3">
              <property name="text">
               <string>10</string>
              </property>
             </item>
             <item row="0" column="4">
              <property name="text">
               <string>6</string>
              </property>
             </item>
             <item row="0" column="5">
              <property name="text">
               <string>13</string>
              </property>
             </item>
             <item row="1" column="0">
              <property name="text">
               <string>0x407BD0</string>
              </property>
             </item>
             <item row="1" column="1">
              <property name="text">
               <string>start</string>
              </property>
             </item>
             <item row="1" column="2">
              <property name="text">
               <string>6</string>
              </property>
             </item>
             <item row="1" column="3">
              <property name="text">
               <string>16</string>
              </property>
             </item>
             <item row="1" column="4">
              <property name="text">
               <string>8</string>
              </property>
             </item>
             <item row="1" column="5">
              <property name="text">
               <string>21</string>
              </property>
             </item>
             <item row="2" column="0">
              <property name="text">
               <string>0x407CA4</string>
              </property>
             </item>
             <item row="2" column="1">
              <property name="text">
               <string>sub_407CA4</string>
              </property>
             </item>
             <item row="2" column="2">
              <property name="text">
               <string>4</string>
              </property>
             </item>
             <item row="2" column="3">
              <property name="text">
               <string>11</string>
              </property>
             </item>
             <item row="2" column="4">
              <property name="text">
               <string>7</string>
              </property>
             </item>
             <item row="2" column="5">
              <property name="text">
               <string>13</string>
              </property>
             </item>
             <item row="3" column="0">
              <property name="text">
               <string>0x40CC2E</string>
              </property>
             </item>
             <item row="3" column="1">
              <property name="text">
               <string>rc4init</string>
              </property>
             </item>
             <item row="3" column="2">
              <property name="text">
               <string>12</string>
              </property>
             </item>
             <item row="3" column="3">
              <property name="text">
               <string>34</string>
              </property>
             </item>
             <item row="3" column="4">
              <property name="text">
               <string>17</string>
              </property>
             </item>
             <item row="3" column="5">
              <property name="text">
               <string>51</string>
              </property>
             </item>
             <item row="3" column="6">
              <property name="text">
               <string>YES</string>
              </property>
             </item>
             <item row="4" column="0">
              <property name="text">
               <string>0x4100D2</string>
              </property>
             </item>
             <item row="4" column="1">
              <property name="text">
               <string>sub_4100D2</string>
              </property>
             </item>
             <item row="4" column="2">
              <property name="text">
               <string>6</string>
              </property>
             </item>
             <item row="4" column="3">
              <property name="text">
               <string>16</string>
              </property>
             </item>
             <item row="4" column="4">
              <property name="text">
               <string>8</string>
              </property>
             </item>
             <item row="4" column="5">
              <property name="text">
               <string>19</string>
              </property>
             </item>
             <item row="5" column="0">
              <property name="text">
               <string>0x410693</string>
              </property>
             </item>
             <item row="5" column="1">
              <property name="text">
               <string>sub_410693</string>
              </property>
             </item>
             <item row="5" column="2">
              <property name="text">
               <string>4</string>
              </property>
             </item>
             <item row="5" column="3">
              <property name="text">
               <string>11</string>
              </property>
             </item>
             <item row="5" column="4">
              <property name="text">
               <string>6</string>
              </property>
             </item>
             <item row="5" column="5">
              <property name="text">
               <string>12</string>
              </property>
             </item>
             <item row="6" column="0">
              <property name="text">
               <string>0x41BD03</string>
              </property>
             </item>
             <item row="6" column="1">
              <property name="text">
               <string>sub_41bD03</string>
              </property>
             </item>
             <item row="6" column="2">
              <property name="text">
               <string>3</string>
              </property>
             </item>
             <item row="6" column="3">
              <property name="text">
               <string>8</string>
              </property>
             </item>
             <item row="6" column="4">
              <property name="text">
               <string>3</string>
              </property>
             </item>
             <item row="6" column="5">
              <property name="text">
               <string>8</string>
              </property>
             </item>
             <item row="7" column="0">
              <property name="text">
               <string>0x41C551</string>
              </property>
             </item>
             <item row="7" column="1">
              <property name="text">
               <string>sub_41C551</string>
              </property>
             </item>
             <item row="7" column="2">
              <property name="text">
               <string>4</string>
              </property>
             </item>
             <item row="7" column="3">
              <property name="text">
               <string>10</string>
              </property>
             </item>
             <item row="7" column="4">
              <property name="text">
               <string>5</string>
              </property>
             </item>
             <item row="7" column="5">
              <property name="text">
               <string>11</string>
              </property>
             </item>
             <item row="8" column="0">
              <property name="text">
               <string>0x41CAD1</string>
              </property>
             </item>
             <item row="8" column="1">
              <property name="text">
               <string>sub_41CAD1</string>
              </property>
             </item>
             <item row="8" column="2">
              <property name="text">
               <string>5</string>
              </property>
             </item>
             <item row="8" column="3">
              <property name="text">
               <string>14</string>
              </property>
             </item>
             <item row="8" column="4">
              <property name="text">
               <string>6</string>
              </property>
             </item>
             <item row="8" column="5">
              <property name="text">
               <string>16</string>
              </property>
             </item>
            </widget>
           </item>
           <item>
            <widget class="QLabel" name="label_6">
             <property name="text">
              <string>Matches</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QTableWidget" name="tableWidget_3">
             <attribute name="horizontalHeaderDefaultSectionSize">
              <number>150</number>
             </attribute>
             <attribute name="horizontalHeaderStretchLastSection">
              <bool>true</bool>
             </attribute>
             <row>
              <property name="text">
               <string>1</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>2</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>3</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>4</string>
              </property>
             </row>
             <row>
              <property name="text">
               <string>5</string>
              </property>
             </row>
             <column>
              <property name="text">
               <string>SHA256</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Family</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Version</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Sample ID</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Pichash Match</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>MinHash Score</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>Label</string>
              </property>
             </column>
             <column>
              <property name="text">
               <string>LibraryMatch?</string>
              </property>
             </column>
             <item row="0" column="0">
              <property name="text">
               <string>2c5ab3b92df90bf933da41bc1f3dfb140331c39c0d2d9381913fa73d2cc2ab74</string>
              </property>
             </item>
             <item row="0" column="1">
              <property name="text">
               <string>win.citadel</string>
              </property>
             </item>
             <item row="0" column="2">
              <property name="text">
               <string>2012-06-15-1.3.4.5</string>
              </property>
             </item>
             <item row="0" column="3">
              <property name="text">
               <string>43</string>
              </property>
             </item>
             <item row="0" column="4">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="0" column="5">
              <property name="text">
               <string>92</string>
              </property>
             </item>
             <item row="0" column="6">
              <property name="text">
               <string/>
              </property>
             </item>
             <item row="0" column="7">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="1" column="0">
              <property name="text">
               <string>3dfb140331c39c0d2d9381913fa73d2cc2ab742c5ab3b92df90bf933da41bc1f</string>
              </property>
             </item>
             <item row="1" column="1">
              <property name="text">
               <string>win.citadel</string>
              </property>
             </item>
             <item row="1" column="2">
              <property name="text">
               <string>2013-12-18-2.0.c.0</string>
              </property>
             </item>
             <item row="1" column="3">
              <property name="text">
               <string>12</string>
              </property>
             </item>
             <item row="1" column="4">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="1" column="5">
              <property name="text">
               <string>91</string>
              </property>
             </item>
             <item row="1" column="7">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="2" column="0">
              <property name="text">
               <string>2df90bf933da41bc1f3dfb140331c39c0d2d9381913fa73d2cc2ab742c5ab3b9</string>
              </property>
             </item>
             <item row="2" column="1">
              <property name="text">
               <string>win.zeus</string>
              </property>
             </item>
             <item row="2" column="2">
              <property name="text">
               <string>2.0.8.9</string>
              </property>
             </item>
             <item row="2" column="3">
              <property name="text">
               <string>46</string>
              </property>
             </item>
             <item row="2" column="4">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="2" column="5">
              <property name="text">
               <string>88</string>
              </property>
             </item>
             <item row="2" column="7">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="3" column="0">
              <property name="text">
               <string>bf933da41bc1f3dfb140331c39c0d2d9381913fa73d2cc2ab742c5ab3b92df90</string>
              </property>
             </item>
             <item row="3" column="1">
              <property name="text">
               <string>win.ice_ix</string>
              </property>
             </item>
             <item row="3" column="2">
              <property name="text">
               <string>2011-08-09-1.3.4.0</string>
              </property>
             </item>
             <item row="3" column="3">
              <property name="text">
               <string>33</string>
              </property>
             </item>
             <item row="3" column="4">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="3" column="5">
              <property name="text">
               <string>88</string>
              </property>
             </item>
             <item row="3" column="7">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="4" column="0">
              <property name="text">
               <string>d2d9381913fa73d2cc2ab742c5ab3b92df90bf933da41bc1f3dfb140331c39c0</string>
              </property>
             </item>
             <item row="4" column="1">
              <property name="text">
               <string>win.vmzeus</string>
              </property>
             </item>
             <item row="4" column="2">
              <property name="text">
               <string>2014-04-13-v3.2.1</string>
              </property>
             </item>
             <item row="4" column="3">
              <property name="text">
               <string>34</string>
              </property>
             </item>
             <item row="4" column="4">
              <property name="text">
               <string>no</string>
              </property>
             </item>
             <item row="4" column="5">
              <property name="text">
               <string>86</string>
              </property>
             </item>
             <item row="4" column="7">
              <property name="text">
               <string>no</string>
              </property>
             </item>
            </widget>
           </item>
          </layout>
         </widget>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="tabHexView">
      <attribute name="title">
       <string>Hex View-A</string>
      </attribute>
     </widget>
     <widget class="QWidget" name="tabStructures">
      <attribute name="title">
       <string>Structures</string>
      </attribute>
     </widget>
     <widget class="QWidget" name="tabMore">
      <attribute name="title">
       <string>...</string>
      </attribute>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`widgets/BlockMatchWidget.py`:

```py
import time

import ida_funcs
import ida_kernwin
import idaapi

try:
    import ida_hexrays
except ImportError:
    ida_hexrays = None

import helpers.McritTableColumn as McritTableColumn
import helpers.QtShim as QtShim
from helpers.minimcrit.matchers.FunctionCfgMatcher import FunctionCfgMatcher
from helpers.ScoreColorProvider import ScoreColorProvider
from widgets.NumberQTableWidgetItem import NumberQTableWidgetItem
from widgets.SmdaGraphViewer import SmdaGraphViewer

QMainWindow = QtShim.get_QMainWindow()
QColor = QtShim.get_QColor()


class BlockMatchWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        print("[|] loading BlockMatchWidget")
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.scp = ScoreColorProvider()
        self.last_viewed_function = None
        self.last_viewed_block = None
        self._last_block_matches = None
        self.name = "Block Scope"
        self.last_family_selected = None
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "puzzle.png")
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.label_current_function_matches = self.cc.QLabel("Block Matches for: <function_offset>")
        self.cb_filter_library = self.cc.QCheckBox("Filter out Library Matches")
        self.cb_filter_library.setEnabled(False)
        self.cb_filter_library.setChecked(self.parent.config.BLOCKS_FILTER_LIBRARY_FUNCTIONS)
        self.cb_filter_library.clicked.connect(self._onCbFilterLibraryClicked)
        self.cb_activate_live_tracking = self.cc.QCheckBox("Live Block Queries")
        self.cb_activate_live_tracking.setEnabled(False)
        self.cb_activate_live_tracking.setChecked(self.parent.config.BLOCKS_LIVE_QUERY)
        self.cb_activate_live_tracking.clicked.connect(self._onCbLiveClicked)
        # filter wheel
        self.sb_blocksize_threshold = self.cc.QSpinBox()
        self.sb_blocksize_threshold.setRange(4, 20)
        self.sb_blocksize_threshold.setValue(self.parent.config.BLOCKS_MIN_SIZE)
        self.sb_blocksize_threshold.valueChanged.connect(self.handleSpinThresholdChange)
        self.label_sb_threshold = self.cc.QLabel("Min. Block Size: ")
        # query button
        self.b_query_single = self.cc.QPushButton("Query current basic block")
        self.b_query_single.clicked.connect(self.queryCurrentBlock)
        self.b_query_single.setEnabled(False)
        ### self.cb_filter_library.stateChanged.connect(self.populateBestMatchTable)
        # horizontal line
        self.hline = self.cc.QFrame()
        self.hline.setFrameShape(self.cc.QFrameHLine)
        self.hline.setFrameShadow(self.cc.QFrameShadow.Sunken)
        # upper table
        self.label_block_summary = self.cc.QLabel("Blocks Summary")
        self.table_block_summary = self.cc.QTableWidget()
        self.table_block_summary.clicked.connect(self._onTableBlockSummaryClicked)
        self.table_block_summary.doubleClicked.connect(self._onTableBlockSummaryDoubleClicked)
        # lower table
        self.label_block_matches = self.cc.QLabel("Block Matches for <block_offset>")
        self.table_block_matches = self.cc.QTableWidget()
        self.table_block_matches.doubleClicked.connect(self._onTableBlockMatchesDoubleClicked)
        self.table_block_matches.setContextMenuPolicy(self.cc.QtCore.Qt.CustomContextMenu)
        self.table_block_matches.customContextMenuRequested.connect(
            self._onTableBlockMatchesRightClicked
        )
        ### self.table_picblockhash_matches.doubleClicked.connect(self._onTablePicBlockHashDoubleClicked)
        # static links to objects to help IDA
        self.NumberQTableWidgetItem = NumberQTableWidgetItem
        self._QtShim = QtShim
        self._createGui()

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # layout and fill the widget
        block_info_layout = self.cc.QVBoxLayout()
        self.controls_widget = self.cc.QWidget()
        controls_layout = self.cc.QHBoxLayout()
        # checkboxes
        self.checkbox_widget = self.cc.QWidget()
        checkbox_layout = self.cc.QVBoxLayout()
        checkbox_layout.addWidget(self.cb_filter_library)
        checkbox_layout.addWidget(self.cb_activate_live_tracking)
        self.checkbox_widget.setLayout(checkbox_layout)
        # threshold spinbox and label
        self.threshold_widget = self.cc.QWidget()
        threshold_layout = self.cc.QVBoxLayout()
        threshold_layout.addWidget(self.label_sb_threshold)
        threshold_layout.addWidget(self.sb_blocksize_threshold)
        self.threshold_widget.setLayout(threshold_layout)
        # glue controls
        controls_layout.addWidget(self.checkbox_widget)
        controls_layout.addWidget(self.threshold_widget)
        self.controls_widget.setLayout(controls_layout)
        # glue all together
        block_info_layout.addWidget(self.label_current_function_matches)
        block_info_layout.addWidget(self.controls_widget)
        block_info_layout.addWidget(self.b_query_single)
        block_info_layout.addWidget(self.hline)
        block_info_layout.addWidget(self.label_block_summary)
        block_info_layout.addWidget(self.table_block_summary)
        block_info_layout.addWidget(self.label_block_matches)
        block_info_layout.addWidget(self.table_block_matches)
        self.central_widget.setLayout(block_info_layout)

    def _onCbLiveClicked(self, mi):
        if self.cb_activate_live_tracking.isChecked():
            self.queryCurrentBlock()

    def _onCbFilterLibraryClicked(self, mi):
        """
        If the filter is altered, we refresh the table.
        """
        self.hook_refresh(None, use_current_block=True)

    def enable(self):
        self.cb_filter_library.setEnabled(True)
        self.cb_activate_live_tracking.setEnabled(True)
        self.b_query_single.setEnabled(True)

    def updateCurrentBlock(self, view):
        """
        Courtesy of Alex Hanel's FunctionTrapperKeeper
        https://github.com/alexander-hanel/FunctionTrapperKeeper/blob/main/function_trapper_keeper.py
        """
        if view is None:
            return
        widgetType = idaapi.get_widget_type(view)
        if widgetType == idaapi.BWN_DISASM:
            ea = ida_kernwin.get_screen_ea()
            if not ea:
                return
            # validate offset is within a function
            temp_current_function = ida_funcs.get_func(ea)
            if not temp_current_function:
                return
            # get the start of the function
            temp_current_f = temp_current_function.start_ea
            if not temp_current_f:
                return
            if temp_current_f != self.parent.current_function:
                self.parent.current_function = temp_current_f
            temp_current_block = self.parent.local_smda_report.findBlockByContainedAddress(ea)
            if temp_current_block and temp_current_block.offset != self.parent.current_block:
                self.parent.current_block = temp_current_block.offset

        elif widgetType == idaapi.BWN_PSEUDOCODE:
            ea = ida_kernwin.get_screen_ea()
            if not ea or ida_hexrays is None:
                return
            try:
                cfunc = ida_hexrays.decompile(ea)
            except ida_hexrays.DecompilationFailure:
                return
            for cc, item in enumerate(cfunc.treeitems):
                if item.ea != idaapi.BADADDR:
                    if cfunc.treeitems.at(cc).ea == ea:
                        # cursor offset was found in decompiler tree
                        # validate offset is within a function
                        cur_func = ida_funcs.get_func(ea)
                        if not cur_func:
                            return
                            # get the start of the function
                        current_f = cur_func.start_ea
                        if not current_f:
                            return
                        if current_f != self.parent.current_function:
                            self.parent.current_function = current_f
                        temp_current_block = (
                            self.parent.local_smda_report.findBlockByContainedAddress(ea)
                        )
                        if (
                            temp_current_block
                            and temp_current_block.offset != self.parent.current_block
                        ):
                            self.parent.current_block = temp_current_block.offset
        return self.parent.current_function

    def handleSpinThresholdChange(self):
        self.updateViewWithCurrentBlock()

    def queryCurrentBlock(self):
        self.parent.main_widget.hideLocalWidget()
        self.updateViewWithCurrentBlock()

    def hook_refresh(self, view, use_current_block=False):
        if self.parent.local_smda_report is None:
            self.label_current_function_matches.setText(
                "Cannot check for matches, need to convert IDB to SMDA report first."
            )
            return
        # get current function from cursor position
        if self.updateCurrentBlock(view) is None and not use_current_block:
            return
        if self.parent.current_function == self.last_viewed_function and not use_current_block:
            return
        if not self.cb_activate_live_tracking.isChecked():
            self.clearTable()
            self.label_current_function_matches.setText("Live Function Queries are deactivated.")
            return
        self.updateViewWithCurrentBlock()

    def clearTable(self):
        # upper table
        self.table_block_summary.clear()
        self.table_block_summary.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.BLOCK_SUMMARY_TABLE_COLUMNS
        ]
        self.table_block_summary.setColumnCount(len(self.function_matches_header_labels))
        self.table_block_summary.setHorizontalHeaderLabels(self.function_matches_header_labels)
        self.table_block_summary.setRowCount(0)
        self.table_block_summary.resizeRowToContents(0)
        # lower table
        self.table_block_matches.clear()
        self.table_block_matches.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS
        ]
        self.table_block_matches.setColumnCount(len(self.function_matches_header_labels))
        self.table_block_matches.setHorizontalHeaderLabels(self.function_matches_header_labels)
        self.table_block_matches.setRowCount(0)
        self.table_block_matches.resizeRowToContents(0)

    def updateViewWithCurrentBlock(self):
        if self.parent.family_infos is None:
            self.parent.mcrit_interface.queryAllFamilyEntries()
        self.last_viewed_function = self.parent.current_function
        self.last_viewed_block = self.parent.current_block
        if self.parent.current_block:
            self.label_block_matches.setText(
                "No Block Matches for: 0x%x" % self.parent.current_block
            )
        smda_function = self.parent.local_smda_report.getFunction(self.parent.current_function)
        if smda_function is None or smda_function.num_instructions < 4:
            self.clearTable()
            self.label_current_function_matches.setText(
                "Can only query functions with 4 instructions or more."
            )
            return
        # calculate all block pichashes
        pbh = FunctionCfgMatcher.getPicBlockHashesForFunction(
            self.parent.local_smda_report, smda_function, min_size=4
        )
        block_matches_by_offset = {}
        start = time.time()
        num_queries = 0
        for entry in pbh:
            if entry["hash"] not in self.parent.blockhash_matches:
                pichash_matches = self.parent.mcrit_interface.getMatchesForPicBlockHash(
                    entry["hash"]
                )
                num_queries += 1
                self.parent.blockhash_matches[entry["hash"]] = pichash_matches
            pichash_matches = self.parent.blockhash_matches[entry["hash"]]
            if pichash_matches is None:
                pichash_matches = []
            # cache this so we only query once per block
            if entry["offset"] not in self.parent.block_to_hash:
                self.parent.block_to_hash[entry["offset"]] = entry["hash"]
            summary = {
                "families": len(set([e[0] for e in pichash_matches])),
                "samples": len(set([e[1] for e in pichash_matches])),
                "functions": len(set([e[2] for e in pichash_matches])),
                "offsets": len(pichash_matches),
            }
            block_matches_by_offset[entry["offset"]] = {
                "picblockhash": entry,
                "matches": pichash_matches,
                "summary": summary,
                "has_library_matches": False,
            }
        stop = time.time()
        if num_queries > 0:
            print(
                f"Querying {num_queries} blocks took {stop - start:5.3f} seconds, or {(stop - start) / num_queries:5.3f} seconds per block."
            )
        if block_matches_by_offset:
            # TODO when filtering, we should actually fully remove them by offset here, as we don't want to see such blocks in the summary later on
            set_families = set([])
            set_samples = set([])
            set_all_functions = set([])
            set_functions = set([])
            library_families = []
            for k, v in self.parent.family_infos.items():
                if v.num_samples and v.num_library_samples == v.num_samples:
                    library_families.append(k)
            min_block_size = self.sb_blocksize_threshold.value()
            offsets_to_drop = {"by_size": set([]), "by_lib": set([])}
            for offset, data in block_matches_by_offset.items():
                set_all_functions.update([entry[2] for entry in data["matches"]])
                filtered_matches = [
                    entry for entry in data["matches"] if entry[0] not in library_families
                ]
                if data["picblockhash"]["size"] < min_block_size:
                    offsets_to_drop["by_size"].add(offset)
                    print("dropping because of size", offset)
                if len(filtered_matches) < len(data["matches"]):
                    block_matches_by_offset[offset]["has_library_matches"] = True
                    offsets_to_drop["by_lib"].add(offset)
                # reduce matches if we actually have matched some blocks against libraries
                if (
                    self.cb_filter_library.isChecked()
                    and block_matches_by_offset[offset]["has_library_matches"]
                ):
                    block_matches_by_offset[offset]["matches"] = filtered_matches
                    continue
                block_matches_by_offset[offset]["summary"] = {
                    "families": len(set([e[0] for e in filtered_matches])),
                    "samples": len(set([e[1] for e in filtered_matches])),
                    "functions": len(set([e[2] for e in filtered_matches])),
                    "offsets": len(filtered_matches),
                }
                set_families.update([entry[0] for entry in filtered_matches])
                set_samples.update([entry[1] for entry in filtered_matches])
                set_functions.update([entry[2] for entry in filtered_matches])
            for offset in offsets_to_drop["by_size"]:
                block_matches_by_offset.pop(offset, None)
            if self.cb_filter_library.isChecked():
                for offset in offsets_to_drop["by_lib"]:
                    block_matches_by_offset.pop(offset, None)
                self.label_current_function_matches.setText(
                    "Block Matches for Function: 0x%x -- %d families, %d samples, %d functions (%d filtered)."
                    % (
                        self.parent.current_function,
                        len(set_families),
                        len(set_samples),
                        len(set_functions),
                        len(set_all_functions) - len(set_functions),
                    )
                )
            else:
                self.label_current_function_matches.setText(
                    "Block Matches for Function: 0x%x -- %d families, %d samples, %d functions."
                    % (
                        self.parent.current_function,
                        len(set_families),
                        len(set_samples),
                        len(set_all_functions),
                    )
                )
                self.current_block_offset = self.parent.current_function
        else:
            self.label_current_function_matches.setText(
                "No Block Matches for Function: 0x%x" % self.parent.current_function
            )
            self.label_block_matches.setText(
                "No Block Matches for: 0x%x" % self.parent.current_block
            )
        self._last_block_matches = block_matches_by_offset
        # populate tables with data
        self.populateBlockSummaryTable(block_matches_by_offset)
        self.populateBlockMatchTable(block_matches_by_offset, self.last_viewed_block)

    def generateSummaryTableCellItem(self, column_type, block_offset, block_entry):
        tmp_item = None
        if column_type == McritTableColumn.OFFSET:
            tmp_item = self.cc.QTableWidgetItem("0x%x" % block_offset)
        elif column_type == McritTableColumn.PIC_BLOCK_HASH:
            tmp_item = self.cc.QTableWidgetItem("0x%x" % block_entry["picblockhash"]["hash"])
        elif column_type == McritTableColumn.SIZE:
            tmp_item = self.NumberQTableWidgetItem("%d" % block_entry["picblockhash"]["size"])
        elif column_type == McritTableColumn.FAMILIES:
            tmp_item = self.NumberQTableWidgetItem("%d" % block_entry["summary"]["families"])
        elif column_type == McritTableColumn.SAMPLES:
            tmp_item = self.NumberQTableWidgetItem("%d" % block_entry["summary"]["samples"])
        elif column_type == McritTableColumn.FUNCTIONS:
            tmp_item = self.NumberQTableWidgetItem("%d" % block_entry["summary"]["functions"])
        elif column_type == McritTableColumn.IS_LIBRARY:
            tmp_item = self.cc.QTableWidgetItem(
                "YES" if block_entry["has_library_matches"] else "NO"
            )
        return tmp_item

    def populateBlockSummaryTable(self, block_matches):
        """
        Populate the function match table with all matches for the selected function_id
        """
        self.table_block_summary.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.BLOCK_SUMMARY_TABLE_COLUMNS
        ]
        self.table_block_summary.clear()
        self.table_block_summary.setColumnCount(len(self.function_matches_header_labels))
        self.table_block_summary.setHorizontalHeaderLabels(self.function_matches_header_labels)
        # Identify number of table entries and prepare addresses to display
        self.table_block_summary.setRowCount(len(block_matches))
        self.table_block_summary.resizeRowToContents(0)
        row = 0
        for block_offset, block_entry in sorted(block_matches.items(), key=lambda x: x[0]):
            for column, column_name in enumerate(self.function_matches_header_labels):
                column_type = self.parent.config.BLOCK_SUMMARY_TABLE_COLUMNS[column]
                tmp_item = self.generateSummaryTableCellItem(column_type, block_offset, block_entry)
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                # Set background color and font color
                if block_entry["summary"]["families"] > 0:
                    row_color = self.scp.frequencyToColor(
                        block_entry["summary"]["families"], opacity=1
                    )
                    tmp_item.setBackground(QColor(row_color[0], row_color[1], row_color[2]))
                    tmp_item.setForeground(QColor("black"))
                self.table_block_summary.setItem(row, column, tmp_item)
            # self.table_function_matches.resizeRowToContents(row)
            row += 1
        self.table_block_summary.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_block_summary.resizeColumnsToContents()
        self.table_block_summary.setSortingEnabled(True)
        header = self.table_block_summary.horizontalHeader()
        header.setStretchLastSection(True)

    def generateMatchTableCellItem(self, column_type, match_entry):
        tmp_item = None
        if column_type == McritTableColumn.SHA256:
            sample_sha256 = self.parent.sample_infos[match_entry[1]].sha256
            tmp_item = self.cc.QTableWidgetItem(sample_sha256[:8])
        elif column_type == McritTableColumn.OFFSET:
            tmp_item = self.cc.QTableWidgetItem("0x%x" % match_entry[3])
        elif column_type == McritTableColumn.FAMILY_NAME:
            tmp_item = self.cc.QTableWidgetItem(
                self.parent.family_infos[match_entry[0]].family_name
            )
        elif column_type == McritTableColumn.FAMILY_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % match_entry[0])
        elif column_type == McritTableColumn.SAMPLE_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % match_entry[1])
        elif column_type == McritTableColumn.FUNCTION_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % match_entry[2])
        return tmp_item

    def populateBlockMatchTable(self, block_matches, block_offset):
        """
        Populate the function name table with all names for the matches we found
        """
        self.label_block_matches.setText("Block Matches for: 0x%x" % self.parent.current_block)
        self.table_block_matches.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS
        ]
        self.table_block_matches.clear()
        self.table_block_matches.setColumnCount(len(self.function_matches_header_labels))
        self.table_block_matches.setHorizontalHeaderLabels(self.function_matches_header_labels)
        self.table_block_matches.setRowCount(0)
        if block_offset not in block_matches:
            return
        # Identify number of table entries and prepare addresses to display
        if block_offset not in block_matches:
            self.table_block_matches.setRowCount(0)
            return
        self.table_block_matches.setRowCount(len(block_matches[block_offset]["matches"]))
        self.table_block_matches.resizeRowToContents(0)

        preselect_row = 0
        row = 0
        for match_entry in sorted(
            block_matches[block_offset]["matches"], key=lambda x: (x[0], x[1], x[2])
        ):
            for column, column_name in enumerate(self.function_matches_header_labels):
                if block_offset == match_entry[3]:
                    preselect_row = row
                column_type = self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS[column]
                tmp_item = self.generateMatchTableCellItem(column_type, match_entry)
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                self.table_block_matches.setItem(row, column, tmp_item)
            # self.table_function_matches.resizeRowToContents(row)
            row += 1
        self.table_block_matches.selectRow(preselect_row)
        self.table_block_matches.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_block_matches.resizeColumnsToContents()
        self.table_block_matches.setSortingEnabled(True)
        header = self.table_block_matches.horizontalHeader()
        header.setStretchLastSection(True)

    def _onTableBlockSummaryClicked(self, mi):
        """
        Use the row with that was clicked to show block matches corresponding to the current block
        """
        clicked_block_address = None
        for index, column_type in enumerate(self.parent.config.BLOCK_SUMMARY_TABLE_COLUMNS):
            if column_type == McritTableColumn.OFFSET:
                clicked_block_address = self.table_block_summary.item(mi.row(), index).text()
        # print("clicked_block_address", clicked_block_address)
        if clicked_block_address is not None:
            self.parent.current_block = int(clicked_block_address, 16)
            self.populateBlockMatchTable(self._last_block_matches, self.parent.current_block)

    def _onTableBlockSummaryDoubleClicked(self, mi):
        """
        Use the row with that was double clicked to jump to that block
        """
        offset_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.BLOCK_SUMMARY_TABLE_COLUMNS
        )
        if offset_column_index is not None and mi.column() == offset_column_index:
            clicked_block_address = self.table_block_summary.item(
                mi.row(), offset_column_index
            ).text()
            # print("double clicked_block_address", clicked_block_address)
            self.cc.ida_proxy.Jump(int(clicked_block_address, 16))
            self.parent.current_block = int(clicked_block_address, 16)
            self.populateBlockMatchTable(self._last_block_matches, self.parent.current_block)

    def _onTableBlockMatchesDoubleClicked(self, mi):
        """
        Use the row with that was double clicked to show the matched remote function in a graph viewer
        """
        block_offset_b = None
        function_id_b = None
        for index, column_type in enumerate(self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS):
            if column_type == McritTableColumn.OFFSET:
                block_offset_b = int(self.table_block_matches.item(mi.row(), index).text(), 16)
            elif column_type == McritTableColumn.FUNCTION_ID:
                function_id_b = int(self.table_block_matches.item(mi.row(), index).text())
        # print("double clicked row for function_id", function_id_b)
        if block_offset_b is not None and function_id_b is not None:
            function_entry_b = self.parent.mcrit_interface.queryFunctionEntryById(function_id_b)
            smda_function_b = function_entry_b.toSmdaFunction()
            sample_entry_b = self.parent.mcrit_interface.querySampleEntryById(
                function_entry_b.sample_id
            )
            #
            coloring = {block_offset_b: 0x00DDFF}
            for offset, data in self._last_block_matches.items():
                for match in data["matches"]:
                    if match[2] == function_entry_b.function_id:
                        coloring[match[3]] = 0xC0F4FF
            coloring[block_offset_b] = 0x00DDFF
            g = SmdaGraphViewer(self, sample_entry_b, function_entry_b, smda_function_b, coloring)
            g.Show()

    def _onTableBlockMatchesRightClicked(self, position):
        sha256_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SHA256, self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS
        )
        sample_id_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SAMPLE_ID, self.parent.config.BLOCK_MATCHES_TABLE_COLUMNS
        )
        if (
            sha256_column_index is not None
            and self.table_block_matches.currentColumn() == sha256_column_index
        ):
            if sample_id_column_index is None:
                # TODO possibly can reconstruct clicked row from matching data, but let's keep it simple for now
                print("Need a column with sample IDs to copy SHA256 to clipboard.")
            # copy to clipboard
            sample_id = self.table_block_matches.item(
                self.table_block_matches.currentRow(), sample_id_column_index
            ).text()
            sha256 = self.parent.sample_infos[int(sample_id)].sha256
            self.parent.copyStringToClipboard(sha256)

```

`widgets/FunctionMatchWidget.py`:

```py
import ida_funcs
import ida_kernwin
import idaapi

try:
    import ida_hexrays
except ImportError:
    ida_hexrays = None

import helpers.McritTableColumn as McritTableColumn
import helpers.QtShim as QtShim
from helpers.minimcrit.matchers.FunctionCfgMatcher import FunctionCfgMatcher
from helpers.minimcrit.storage.MatchedFunctionEntry import MatchedFunctionEntry
from helpers.minimcrit.storage.MatchingResult import MatchingResult
from helpers.ScoreColorProvider import ScoreColorProvider
from widgets.NumberQTableWidgetItem import NumberQTableWidgetItem
from widgets.SmdaGraphViewer import SmdaGraphViewer

QMainWindow = QtShim.get_QMainWindow()
QColor = QtShim.get_QColor()


class FunctionMatchWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        print("[|] loading FunctionMatchWidget")
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.scp = ScoreColorProvider()
        self.last_viewed = None
        self.name = "Function Scope"
        self.last_family_selected = None
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "flag-triangle.png")
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.current_function_offset = None
        self.label_current_function_matches = self.cc.QLabel("Matches for: <function_offset>")
        self.cb_filter_library = self.cc.QCheckBox("Filter out Library Matches")
        self.cb_filter_library.setEnabled(False)
        self.cb_filter_library.setChecked(self.parent.config.FUNCTION_FILTER_LIBRARY_FUNCTIONS)
        self.cb_filter_library.clicked.connect(self._onCbFilterLibraryClicked)
        self.cb_activate_live_tracking = self.cc.QCheckBox("Live Function Queries")
        self.cb_activate_live_tracking.setEnabled(False)
        self.cb_activate_live_tracking.setChecked(self.parent.config.FUNCTION_LIVE_QUERY)
        self.cb_activate_live_tracking.clicked.connect(self._onCbLiveClicked)
        # filter wheel
        self.sb_score_threshold = self.cc.QSpinBox()
        self.sb_score_threshold.setRange(50, 100)
        self.sb_score_threshold.setValue(self.parent.config.FUNCTION_MIN_SCORE)
        self.sb_score_threshold.valueChanged.connect(self.handleSpinThresholdChange)
        self.label_sb_threshold = self.cc.QLabel("Min. Score: ")
        self.b_query_single = self.cc.QPushButton("Query current function")
        self.b_query_single.clicked.connect(self.queryCurrentFunction)
        self.b_query_single.setEnabled(False)
        ### self.cb_filter_library.stateChanged.connect(self.populateBestMatchTable)
        # horizontal line
        self.hline = self.cc.QFrame()
        self.hline.setFrameShape(self.cc.QFrameHLine)
        self.hline.setFrameShadow(self.cc.QFrameShadow.Sunken)
        # upper table
        self.label_function_matches = self.cc.QLabel("Function Matches")
        self.table_function_matches = self.cc.QTableWidget()
        self.table_function_matches.doubleClicked.connect(self._onTableFunctionMatchDoubleClicked)
        self.table_function_matches.setContextMenuPolicy(self.cc.QtCore.Qt.CustomContextMenu)
        self.table_function_matches.customContextMenuRequested.connect(
            self._onTableFunctionMatchRightClicked
        )

        # lower table
        self.label_function_names = self.cc.QLabel("Names from Matched Functions")
        self.table_function_names = self.cc.QTableWidget()
        self.table_function_names.doubleClicked.connect(self._onTableFunctionNameDoubleClicked)
        ### self.table_picblockhash_matches.doubleClicked.connect(self._onTablePicBlockHashDoubleClicked)
        # static links to objects to help IDA
        self.NumberQTableWidgetItem = NumberQTableWidgetItem
        self._QtShim = QtShim
        self._createGui()

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # layout and fill the widget
        sample_info_layout = self.cc.QVBoxLayout()
        self.controls_widget = self.cc.QWidget()
        controls_layout = self.cc.QHBoxLayout()
        # checkboxes
        self.checkbox_widget = self.cc.QWidget()
        checkbox_layout = self.cc.QVBoxLayout()
        checkbox_layout.addWidget(self.cb_filter_library)
        checkbox_layout.addWidget(self.cb_activate_live_tracking)
        self.checkbox_widget.setLayout(checkbox_layout)
        # threshold spinbox and label
        self.threshold_widget = self.cc.QWidget()
        threshold_layout = self.cc.QVBoxLayout()
        threshold_layout.addWidget(self.label_sb_threshold)
        threshold_layout.addWidget(self.sb_score_threshold)
        self.threshold_widget.setLayout(threshold_layout)
        # glue controls
        controls_layout.addWidget(self.checkbox_widget)
        controls_layout.addWidget(self.threshold_widget)
        self.controls_widget.setLayout(controls_layout)
        # glue all together
        sample_info_layout.addWidget(self.label_current_function_matches)
        sample_info_layout.addWidget(self.controls_widget)
        sample_info_layout.addWidget(self.b_query_single)
        sample_info_layout.addWidget(self.hline)
        sample_info_layout.addWidget(self.label_function_matches)
        sample_info_layout.addWidget(self.table_function_matches)
        sample_info_layout.addWidget(self.label_function_names)
        sample_info_layout.addWidget(self.table_function_names)
        self.central_widget.setLayout(sample_info_layout)

    def _onCbFilterLibraryClicked(self, mi):
        """
        If the filter is altered, we refresh the table.
        """
        self.hook_refresh(None, use_current_function=True)

    def _onCbLiveClicked(self, mi):
        if self.cb_activate_live_tracking.isChecked():
            self.parent.main_widget.hideLocalWidget()
            self.updateViewWithCurrentFunction()

    def handleSpinThresholdChange(self):
        self.updateViewWithCurrentFunction()

    def enable(self):
        self.cb_filter_library.setEnabled(True)
        self.cb_activate_live_tracking.setEnabled(True)
        self.b_query_single.setEnabled(True)

    def updateCurrentFunction(self, view):
        """
        Courtesy of Alex Hanel's FunctionTrapperKeeper
        https://github.com/alexander-hanel/FunctionTrapperKeeper/blob/main/function_trapper_keeper.py
        """
        if view is None:
            return
        widgetType = idaapi.get_widget_type(view)
        if widgetType == idaapi.BWN_DISASM:
            ea = ida_kernwin.get_screen_ea()
            if not ea:
                return
            # validate offset is within a function
            temp_current_function = ida_funcs.get_func(ea)
            if not temp_current_function:
                return
            # get the start of the function
            temp_current_f = temp_current_function.start_ea
            if not temp_current_f:
                return
            if temp_current_f != self.parent.current_function:
                self.parent.current_function = temp_current_f

        elif widgetType == idaapi.BWN_PSEUDOCODE:
            ea = ida_kernwin.get_screen_ea()
            if not ea or ida_hexrays is None:
                return
            try:
                cfunc = ida_hexrays.decompile(ea)
            except ida_hexrays.DecompilationFailure:
                return
            for cc, item in enumerate(cfunc.treeitems):
                if item.ea != idaapi.BADADDR:
                    if cfunc.treeitems.at(cc).ea == ea:
                        # cursor offset was found in decompiler tree
                        # validate offset is within a function
                        cur_func = ida_funcs.get_func(ea)
                        if not cur_func:
                            return
                            # get the start of the function
                        current_f = cur_func.start_ea
                        if not current_f:
                            return
                        if current_f != self.parent.current_function:
                            self.parent.current_function = current_f
        return self.parent.current_function

    def queryCurrentFunction(self):
        self.parent.main_widget.hideLocalWidget()
        self.updateViewWithCurrentFunction()

    def hook_refresh(self, view, use_current_function=False):
        if self.parent.local_smda_report is None:
            self.label_current_function_matches.setText(
                "Cannot check for matches, need to convert IDB to SMDA report first."
            )
            return
        # get current function from cursor position
        if self.updateCurrentFunction(view) is None and not use_current_function:
            return
        if self.parent.current_function == self.last_viewed and not use_current_function:
            return
        if not self.cb_activate_live_tracking.isChecked():
            self.clearTable()
            self.label_current_function_matches.setText("Live Function Queries are deactivated.")
            return
        self.updateViewWithCurrentFunction()

    def clearTable(self):
        # upper table
        self.table_function_matches.clear()
        self.table_function_matches.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS
        ]
        self.table_function_matches.setColumnCount(len(self.function_matches_header_labels))
        self.table_function_matches.setHorizontalHeaderLabels(self.function_matches_header_labels)
        self.table_function_matches.setRowCount(0)
        self.table_function_matches.resizeRowToContents(0)
        # lower table
        self.table_function_names.clear()
        self.table_function_names.setSortingEnabled(False)
        self.function_names_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.FUNCTION_NAMES_TABLE_COLUMNS
        ]
        self.table_function_names.setColumnCount(len(self.function_names_header_labels))
        self.table_function_names.setHorizontalHeaderLabels(self.function_names_header_labels)
        self.table_function_names.setRowCount(0)
        self.table_function_names.resizeRowToContents(0)

    def updateViewWithCurrentFunction(self):
        self.last_viewed = self.parent.current_function
        smda_function = self.parent.local_smda_report.getFunction(self.parent.current_function)
        if smda_function is None or smda_function.num_instructions < 10:
            self.clearTable()
            self.label_current_function_matches.setText(
                "Can only query functions with 10 instructions or more."
            )
            return
        match_report = None
        single_function_smda_report = self.parent.getLocalSmdaReportOutline()
        single_function_smda_report.xcfg = {smda_function.offset: smda_function}
        # check if pichash match data is already available in local cache
        if smda_function.offset not in self.parent.function_matches:
            self.parent.mcrit_interface.querySmdaFunctionMatches(single_function_smda_report)
        if smda_function.offset in self.parent.function_matches:
            match_report = MatchingResult.fromDict(
                self.parent.function_matches[smda_function.offset]
            )
            match_report.filterToFunctionScore(int(self.sb_score_threshold.value()))
            num_all_functions = len(match_report.function_matches)
            if self.cb_filter_library.isChecked():
                num_functions = len(
                    [m for m in match_report.filtered_function_matches if not m.match_is_library]
                )
                self.label_current_function_matches.setText(
                    "Matches for Function: 0x%x -- %d families, %d samples, %d functions (%d filtered)."
                    % (
                        self.parent.current_function,
                        match_report.num_original_family_matches,
                        match_report.num_original_sample_matches,
                        num_functions,
                        num_all_functions - num_functions,
                    )
                )
            elif len(match_report.filtered_function_matches) < len(match_report.function_matches):
                self.label_current_function_matches.setText(
                    "Matches for Function: 0x%x -- %d families, %d samples, %d functions (%d filtered)."
                    % (
                        self.parent.current_function,
                        match_report.num_original_family_matches,
                        match_report.num_original_sample_matches,
                        len(match_report.filtered_function_matches),
                        num_all_functions - len(match_report.filtered_function_matches),
                    )
                )
                self.current_function_offset = self.parent.current_function
            else:
                self.label_current_function_matches.setText(
                    "Matches for Function: 0x%x -- %d families, %d samples, %d functions."
                    % (
                        self.parent.current_function,
                        match_report.num_original_family_matches,
                        match_report.num_original_sample_matches,
                        num_all_functions,
                    )
                )
                self.current_function_offset = self.parent.current_function
        if match_report is not None:
            # populate tables with data
            self.populateFunctionMatchTable(match_report)
            # TODO fetch all labels to populate lower table as soon as we support this
            self.populateFunctionNameTable(match_report)

    def generateMatchTableCellItem(self, column_type, function_match_entry: MatchedFunctionEntry):
        tmp_item = None
        if column_type == McritTableColumn.FUNCTION_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % function_match_entry.matched_function_id)
        elif column_type == McritTableColumn.OFFSET:
            function_offset = self.parent.function_id_to_offset.get(
                function_match_entry.matched_function_id, 0
            )
            tmp_item = self.NumberQTableWidgetItem("0x%x" % function_offset)
        elif column_type == McritTableColumn.SHA256:
            sample_sha256 = self.parent.sample_infos[function_match_entry.matched_sample_id].sha256
            tmp_item = self.cc.QTableWidgetItem(sample_sha256[:8])
        elif column_type == McritTableColumn.SAMPLE_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % function_match_entry.matched_sample_id)
        elif column_type == McritTableColumn.FAMILY_NAME:
            family_name = self.parent.family_infos[
                function_match_entry.matched_family_id
            ].family_name
            tmp_item = self.cc.QTableWidgetItem(family_name)
        elif column_type == McritTableColumn.VERSION:
            sample_version = self.parent.sample_infos[
                function_match_entry.matched_sample_id
            ].version
            tmp_item = self.cc.QTableWidgetItem(sample_version)
        elif column_type == McritTableColumn.PIC_HASH_MATCH:
            tmp_item = self.cc.QTableWidgetItem(
                "YES" if function_match_entry.match_is_pichash else "NO"
            )
        elif column_type == McritTableColumn.SCORE:
            tmp_item = self.NumberQTableWidgetItem("%d" % function_match_entry.matched_score)
        elif column_type == McritTableColumn.IS_LIBRARY:
            library_value = "YES" if function_match_entry.match_is_library else "NO"
            tmp_item = self.cc.QTableWidgetItem("%s" % library_value)
        return tmp_item

    def populateFunctionMatchTable(self, match_report: MatchingResult):
        """
        Populate the function match table with all matches for the selected function_id
        """
        self.table_function_matches.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS
        ]
        self.table_function_matches.clear()
        self.table_function_matches.setColumnCount(len(self.function_matches_header_labels))
        self.table_function_matches.setHorizontalHeaderLabels(self.function_matches_header_labels)
        # Identify number of table entries and prepare addresses to display
        if self.cb_filter_library.isChecked():
            self.table_function_matches.setRowCount(
                len([m for m in match_report.filtered_function_matches if not m.match_is_library])
            )
        else:
            self.table_function_matches.setRowCount(len(match_report.filtered_function_matches))
        self.table_function_matches.resizeRowToContents(0)

        row = 0
        sorted_entries = sorted(
            match_report.filtered_function_matches,
            key=lambda x: x.matched_score
            + (1 if x.match_is_pichash else 0)
            + (1 if x.match_is_library else 0),
            reverse=True,
        )
        for function_match_entry in sorted_entries:
            if self.cb_filter_library.isChecked() and function_match_entry.match_is_library:
                continue
            for column, column_name in enumerate(self.function_matches_header_labels):
                column_type = self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS[column]
                tmp_item = self.generateMatchTableCellItem(column_type, function_match_entry)
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                # colorize by score
                row_color = self.scp.scoreToColor(function_match_entry.matched_score, opacity=1)
                tmp_item.setBackground(QColor(row_color[0], row_color[1], row_color[2]))
                tmp_item.setForeground(QColor("black"))
                self.table_function_matches.setItem(row, column, tmp_item)
            # self.table_function_matches.resizeRowToContents(row)
            row += 1
        self.table_function_matches.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_function_matches.resizeColumnsToContents()
        self.table_function_matches.setSortingEnabled(True)
        header = self.table_function_matches.horizontalHeader()
        header.setStretchLastSection(True)

    def generateNameTableCellItem(self, column_type, function_label_entry):
        tmp_item = None
        if column_type == McritTableColumn.FUNCTION_ID:
            tmp_item = self.NumberQTableWidgetItem("%d" % function_label_entry.function_id)
        elif column_type == McritTableColumn.SCORE:
            tmp_item = self.NumberQTableWidgetItem("%d" % function_label_entry.score)
        elif column_type == McritTableColumn.USER:
            tmp_item = self.cc.QTableWidgetItem(function_label_entry.username)
        elif column_type == McritTableColumn.FUNCTION_LABEL:
            tmp_item = self.cc.QTableWidgetItem(function_label_entry.function_label)
        elif column_type == McritTableColumn.TIMESTAMP:
            timestamp = function_label_entry.timestamp.strftime("%Y-%m-%d %H:%M:%S")
            tmp_item = self.cc.QTableWidgetItem(timestamp)
        return tmp_item

    def populateFunctionNameTable(self, match_report: MatchingResult):
        """
        Populate the function name table with all names for the matches we found
        """
        function_matches_by_id = {
            match.matched_function_id: match for match in match_report.filtered_function_matches
        }
        function_entries = self.parent.mcrit_interface.queryFunctionEntriesById(
            [i for i in function_matches_by_id.keys()]
        )
        if not function_entries:
            return
        matched_entries = {}
        for function_id in function_matches_by_id.keys():
            matched_entry = self.parent.matched_function_entries.get(function_id)
            if matched_entry is None:
                continue
            matched_entries[function_id] = matched_entry
        function_label_entries = []
        for function_id, entry in matched_entries.items():
            if (
                self.cb_filter_library.isChecked()
                and function_matches_by_id[entry.function_id].match_is_library
            ):
                continue
            if entry.function_labels:
                for function_label in entry.function_labels:
                    function_label.score = function_matches_by_id[function_id].matched_score
                    function_label_entries.append(function_label)

        self.table_function_names.setSortingEnabled(False)
        self.function_matches_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.FUNCTION_NAMES_TABLE_COLUMNS
        ]
        self.table_function_names.clear()
        self.table_function_names.setColumnCount(len(self.function_matches_header_labels))
        self.table_function_names.setHorizontalHeaderLabels(self.function_matches_header_labels)
        # Identify number of table entries and prepare addresses to display
        self.table_function_names.setRowCount(len(function_label_entries))
        self.table_function_names.resizeRowToContents(0)

        row = 0
        sorted_entries = sorted(
            function_label_entries, key=lambda x: (x.score, x.username, x.timestamp), reverse=True
        )
        for function_label_entry in sorted_entries:
            for column, column_name in enumerate(self.function_matches_header_labels):
                column_type = self.parent.config.FUNCTION_NAMES_TABLE_COLUMNS[column]
                tmp_item = self.generateNameTableCellItem(column_type, function_label_entry)
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                self.table_function_names.setItem(row, column, tmp_item)
            # self.table_function_matches.resizeRowToContents(row)
            row += 1
        self.table_function_names.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_function_names.resizeColumnsToContents()
        self.table_function_names.setSortingEnabled(True)
        header = self.table_function_names.horizontalHeader()
        header.setStretchLastSection(True)

    def _onTableFunctionMatchDoubleClicked(self, mi):
        """
        Use the row with that was double clicked to import the function_name to the current function
        """
        function_id_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.FUNCTION_ID, self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS
        )
        if function_id_column_index is not None:
            remote_function_id = int(
                self.table_function_matches.item(mi.row(), function_id_column_index).text()
            )
            smda_function_a = self.parent.local_smda_report.getFunction(
                self.current_function_offset
            )
            smda_report_a = self.parent.local_smda_report
            function_entry_b = self.parent.mcrit_interface.queryFunctionEntryById(
                remote_function_id
            )
            smda_function_b = function_entry_b.toSmdaFunction()
            sample_entry_b = self.parent.mcrit_interface.querySampleEntryById(
                function_entry_b.sample_id
            )
            fcm = FunctionCfgMatcher(
                smda_report_a, smda_function_a, sample_entry_b, smda_function_b
            )
            coloring = fcm.getColoredMatches()
            coloring = {int(k[6:], 16): int(v[1:], 16) for k, v in coloring["b"].items()}
            g = SmdaGraphViewer(self, sample_entry_b, function_entry_b, smda_function_b, coloring)
            g.Show()

    def _onTableFunctionNameDoubleClicked(self, mi):
        """
        Use the row with that was double clicked to import the function_name to the current function
        """
        function_id_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.FUNCTION_ID, self.parent.config.FUNCTION_NAMES_TABLE_COLUMNS
        )
        function_label_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.FUNCTION_LABEL, self.parent.config.FUNCTION_NAMES_TABLE_COLUMNS
        )
        if function_id_column_index is not None and mi.column() == function_id_column_index:
            smda_function_a = self.parent.local_smda_report.getFunction(
                self.current_function_offset
            )
            smda_report_a = self.parent.local_smda_report
            remote_function_id = int(
                self.table_function_names.item(mi.row(), function_id_column_index).text()
            )
            function_entry_b = self.parent.mcrit_interface.queryFunctionEntryById(
                remote_function_id
            )
            smda_function_b = function_entry_b.toSmdaFunction()
            sample_entry_b = self.parent.mcrit_interface.querySampleEntryById(
                function_entry_b.sample_id
            )
            fcm = FunctionCfgMatcher(
                smda_report_a, smda_function_a, sample_entry_b, smda_function_b
            )
            coloring = fcm.getColoredMatches()
            coloring = {int(k[6:], 16): int(v[1:], 16) for k, v in coloring["b"].items()}
            g = SmdaGraphViewer(self, sample_entry_b, function_entry_b, smda_function_b, coloring)
            g.Show()
        elif function_label_column_index is not None and mi.column() == function_label_column_index:
            function_name = self.table_function_names.item(
                mi.row(), function_label_column_index
            ).text()
            # print(function_name)
            self.cc.ida_proxy.set_name(self.last_viewed, function_name, self.cc.ida_proxy.SN_NOWARN)

    def _onTableFunctionMatchRightClicked(self, position):
        """
        Right click context menu for function matches
        """
        sha256_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SHA256, self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS
        )
        sample_id_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SAMPLE_ID, self.parent.config.FUNCTION_MATCHES_TABLE_COLUMNS
        )
        if (
            sha256_column_index is not None
            and self.table_function_matches.currentColumn() == sha256_column_index
        ):
            if sample_id_column_index is None:
                # TODO possibly can reconstruct clicked row from matching data, but let's keep it simple for now
                print("Need a column with sample IDs to copy SHA256 to clipboard.")
            # copy to clipboard
            sample_id = self.table_function_matches.item(
                self.table_function_matches.currentRow(), sample_id_column_index
            ).text()
            sha256 = self.parent.sample_infos[int(sample_id)].sha256
            self.parent.copyStringToClipboard(sha256)

```

`widgets/FunctionOverviewWidget.py`:

```py
import re

import ida_funcs

import helpers.McritTableColumn as McritTableColumn
import helpers.QtShim as QtShim
from widgets.NumberQTableWidgetItem import NumberQTableWidgetItem

QMainWindow = QtShim.get_QMainWindow()
QStyledItemDelegate = QtShim.get_QStyledItemDelegate()
QComboBox = QtShim.get_QComboBox()
QColor = QtShim.get_QColor()
QPalette = QtShim.get_QPalette()


class ColoredComboBox(QComboBox):
    def __init__(self, parent=None, criticality=0):
        super().__init__(parent)
        self.criticality = criticality
        self.user_has_interacted = False
        self.user_made_selection = False
        self.programmatic_change = False

        # Connect signals to track user interaction
        self.activated.connect(self._on_user_activated)
        self.currentTextChanged.connect(self._on_text_changed)

        # Set colors immediately in constructor
        color_rgb = None
        if criticality == 0:
            pass
            # color_rgb = "100, 100, 100"  # could be grey but default works as well on light theme?
        elif criticality == 1:
            color_rgb = "70, 120, 220"  # blue
        elif criticality == 2:
            color_rgb = "70, 180, 70"  # dark green
        elif criticality == 3:
            color_rgb = "100, 255, 100"  # green
        elif criticality == 4:
            color_rgb = "255, 255, 100"  # yellow
        elif criticality >= 5:
            color_rgb = "255, 100, 100"  # red

        if color_rgb:
            # Use more aggressive stylesheet targeting all parts of the combobox
            stylesheet = f"""
                QComboBox {{
                    background-color: rgb({color_rgb});
                    color: black;
                    border: 1px solid gray;
                }}
                QComboBox:drop-down {{
                    background-color: rgb({color_rgb});
                }}
                QComboBox:disabled {{
                    background-color: rgb({color_rgb});
                    color: black;
                }}
                QComboBox QAbstractItemView {{
                    background-color: rgb({color_rgb});
                    color: black;
                }}
            """

            self.setStyleSheet(stylesheet)
            self.setAutoFillBackground(True)

    def _on_user_activated(self, index):
        """Called when user actively selects an item from dropdown"""
        if not self.programmatic_change:
            self.user_has_interacted = True
            self.user_made_selection = True

    def _on_text_changed(self, text):
        """Called when text changes - but this can be misleading for dropdowns"""
        # For QComboBox, text changes can happen without user selection
        # We rely more on the activated signal for true user interaction
        if not self.programmatic_change and hasattr(self, "user_has_interacted"):
            # Only mark as interacted if text actually changed to something different
            if not hasattr(self, "_last_known_text") or self._last_known_text != text:
                self.user_has_interacted = True
                self._last_known_text = text

    def showPopup(self):
        """Override to track when dropdown is opened"""
        self.dropdown_was_opened = True
        super().showPopup()

    def hidePopup(self):
        """Override to track when dropdown is closed"""
        super().hidePopup()
        # If dropdown was opened but no selection was made via activated signal,
        # and text didn't change, then user just clicked away
        if hasattr(self, "dropdown_was_opened") and self.dropdown_was_opened:
            self.dropdown_was_opened = False

    def setCurrentText(self, text):
        """Override to mark programmatic changes"""
        self.programmatic_change = True
        super().setCurrentText(text)
        self.programmatic_change = False

    def setCurrentIndex(self, index):
        """Override to mark programmatic changes"""
        self.programmatic_change = True
        super().setCurrentIndex(index)
        self.programmatic_change = False

    def hasUserInteracted(self):
        """Check if user has ever interacted with this combobox"""
        return self.user_has_interacted

    def hasUserMadeSelection(self):
        """Check if user has actively selected an item from dropdown"""
        return self.user_made_selection

    def hasUserOpenedDropdown(self):
        """Check if user has opened the dropdown (even without selecting)"""
        return hasattr(self, "dropdown_was_opened") and self.dropdown_was_opened

    def getUserInteractionType(self):
        """Get detailed info about user interaction"""
        if self.user_made_selection:
            return "SELECTED"  # User made an actual selection
        elif self.user_has_interacted:
            return "INTERACTED"  # User changed text somehow but didn't use dropdown
        elif hasattr(self, "dropdown_was_opened"):
            return "OPENED"  # User opened dropdown but didn't select
        else:
            return "NONE"  # No user interaction at all


class DropdownDelegate(QStyledItemDelegate):
    def __init__(self, function_name_mapping, row_criticality_mapping=None, parent_widget=None):
        super().__init__()
        self.function_name_mapping = function_name_mapping
        self.row_criticality_mapping = (
            row_criticality_mapping if row_criticality_mapping is not None else {}
        )
        self.parent_widget = parent_widget
        # Store references to created editors
        self.editors_by_row = {}  # row -> ColoredComboBox

    def createEditor(self, parent, option, index):
        criticality = self.row_criticality_mapping.get(index.row(), 0)
        editor = ColoredComboBox(parent, criticality)
        choices = self.function_name_mapping.get((index.row(), index.column()), [])
        choice_items = [entry["text"] for entry in choices]
        editor.addItems(choice_items)
        editor.setCurrentText(
            next((entry["text"] for entry in choices if entry["preselected"]), choice_items[0])
        )

        # Store editor reference by row
        self.editors_by_row[index.row()] = editor

        # Store row information for right-click handling
        editor.table_row = index.row()
        editor.table_column = index.column()

        # Enable context menu for the combo box to handle right-clicks
        editor.setContextMenuPolicy(QtShim.get_Qt().CustomContextMenu)
        editor.customContextMenuRequested.connect(
            lambda pos: self._handleComboBoxRightClick(editor, pos)
        )

        return editor

    def getEditorForRow(self, row):
        """Get the ColoredComboBox editor for a specific row"""
        return self.editors_by_row.get(row, None)

    def getUserInteractionTypeForRow(self, row):
        """Get interaction type for a specific row"""
        editor = self.getEditorForRow(row)
        if editor:
            return editor.getUserInteractionType()
        return "NONE"

    def _handleComboBoxRightClick(self, combo_box, position):
        """Handle right-click events on combo box"""
        if self.parent_widget and hasattr(combo_box, "table_row"):
            row = combo_box.table_row
            column = combo_box.table_column

            # Call the parent widget's right-click handler directly
            if hasattr(self.parent_widget, "_handleRightClickOnRow"):
                self.parent_widget._handleRightClickOnRow(row, column)

    def setEditorData(self, editor, index):
        value = index.data()
        editor.setCurrentText(value)

    def setModelData(self, editor, model, index):
        value = editor.currentText()
        model.setData(index, value)


class FunctionOverviewWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        print("[|] loading FunctionOverviewWidget")
        self.last_selected_fields = {}  # offset -> selected label string
        self.resolved_function_labels = {}  # offset -> resolved label string
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.name = "Function Overview"
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "relationship.png")
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.b_fetch_labels = self.cc.QPushButton("Fetch labels for matches")
        self.b_fetch_labels.clicked.connect(self.fetchLabels)

        # Create horizontal layout for filter options
        self.filter_container = self.cc.QWidget()
        self.filter_layout = self.cc.QHBoxLayout()
        self.filter_container.setLayout(self.filter_layout)

        # Filter label
        self.filter_label = self.cc.QLabel("Filter:")
        self.filter_layout.addWidget(self.filter_label)

        # Create radio buttons for filter options
        self.rb_filter_none = self.cc.QRadioButton("none")
        self.rb_filter_labels = self.cc.QRadioButton("labels")
        self.rb_filter_applicable = self.cc.QRadioButton("applicable")
        self.rb_filter_conflicted = self.cc.QRadioButton("conflicted")

        # Add radio buttons to layout
        self.filter_layout.addWidget(self.rb_filter_none)
        self.filter_layout.addWidget(self.rb_filter_labels)
        self.filter_layout.addWidget(self.rb_filter_applicable)
        self.filter_layout.addWidget(self.rb_filter_conflicted)
        self.filter_layout.addStretch()  # Add stretch to push everything to the left

        # Set default selection based on config
        if self.parent.config.OVERVIEW_FILTER_TO_CONFLICTS:
            self.rb_filter_conflicted.setChecked(True)
        elif self.parent.config.OVERVIEW_FILTER_TO_LABELS:
            self.rb_filter_labels.setChecked(True)
        else:
            self.rb_filter_none.setChecked(True)

        # Connect radio buttons to populate function
        self.rb_filter_none.toggled.connect(self.update)
        self.rb_filter_labels.toggled.connect(self.update)
        self.rb_filter_applicable.toggled.connect(self.update)
        self.rb_filter_conflicted.toggled.connect(self.update)

        # Create horizontal layout for button container
        self.button_container = self.cc.QWidget()
        self.button_layout = self.cc.QHBoxLayout()
        self.button_container.setLayout(self.button_layout)

        # Create buttons
        self.b_select_deselect_all = self.cc.QPushButton("(de)select all")
        self.b_select_deselect_all.clicked.connect(self.selectDeselectAllLabels)
        self.b_import_labels = self.cc.QPushButton("Import all labels for unnamed functions")
        # TODO implement an actual selective import function here
        self.b_import_labels.clicked.connect(self.importSelectedLabels)

        # Add buttons to horizontal layout
        self.button_layout.addWidget(self.b_select_deselect_all)
        self.button_layout.addWidget(self.b_import_labels)
        self.button_layout.addStretch()  # Add stretch to push buttons to the left
        self.sb_minhash_threshold = self.cc.QSpinBox()
        self.sb_minhash_threshold.setRange(100, 100)
        self.sb_minhash_threshold.valueChanged.connect(self.handleSpinThresholdChange)
        self.global_minimum_match_value = None
        self.global_maximum_match_value = None
        # horizontal line
        self.hline = self.cc.QFrame()
        self.hline.setFrameShape(self.cc.QFrameHLine)
        self.hline.setFrameShadow(self.cc.QFrameShadow.Sunken)
        # table
        self.label_local_functions = self.cc.QLabel("Functions Matched")
        self.table_local_functions = self.cc.QTableWidget()
        self.table_local_functions.selectionModel().selectionChanged.connect(
            self._onTableFunctionsSelectionChanged
        )
        self.table_local_functions.clicked.connect(self._onTableFunctionsClicked)
        self.table_local_functions.doubleClicked.connect(self._onTableFunctionsDoubleClicked)
        # Enable context menu for right-click handling -> we need to do that in the delegate now
        # self.table_local_functions.setContextMenuPolicy(self.cc.QtCore.Qt.CustomContextMenu)
        # self.table_local_functions.customContextMenuRequested.connect(self._onTableFunctionsRightClicked)
        # cache for function_names
        self.function_name_mapping = None
        self.current_rows = []
        # static links to objects to help IDA
        self.NumberQTableWidgetItem = NumberQTableWidgetItem
        self._QtShim = QtShim
        self._createGui()

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # layout and fill the widget
        function_info_layout = self.cc.QVBoxLayout()
        function_info_layout.addWidget(self.b_fetch_labels)
        function_info_layout.addWidget(self.filter_container)
        function_info_layout.addWidget(self.button_container)
        function_info_layout.addWidget(self.sb_minhash_threshold)
        function_info_layout.addWidget(self.hline)
        function_info_layout.addWidget(self.label_local_functions)
        function_info_layout.addWidget(self.table_local_functions)
        self.central_widget.setLayout(function_info_layout)

    ################################################################################
    # Rendering and state keeping
    ################################################################################

    def fetchLabels(self):
        match_report = self.parent.getMatchingReport()
        if match_report is None:
            return
        matched_function_ids = set()
        for function_match in match_report.function_matches:
            matched_function_ids.add(function_match.matched_function_id)
        print("Number of matched remote functions: ", len(matched_function_ids))
        self.parent.mcrit_interface.queryFunctionEntriesById(
            list(matched_function_ids), with_label_only=True
        )
        function_entries_with_labels = {}
        if self.parent.matched_function_entries:
            for function_id, function_entry in self.parent.matched_function_entries.items():
                if function_entry.function_labels:
                    function_entries_with_labels[function_id] = function_entry
        function_labels = []
        for function_id, entry in function_entries_with_labels.items():
            for label in entry.function_labels:
                function_labels.append(label)
        print("Fetched function entries, found labels for:", len(function_labels))
        self.update()

    def update(self):
        self.populateFunctionTable()

    def handleSpinThresholdChange(self):
        self.update()

    def getSelectedFilter(self):
        """Get the currently selected filter option"""
        if self.rb_filter_none.isChecked():
            return "none"
        elif self.rb_filter_labels.isChecked():
            return "labels"
        elif self.rb_filter_applicable.isChecked():
            return "applicable"
        elif self.rb_filter_conflicted.isChecked():
            return "conflicted"
        return "none"  # fallback

    def getSelectedLabel(self, row, column):
        """Get the currently selected label value from a ComboBox editor or table item"""
        # Get the actual selected value from the ComboBox editor, not the table item
        selected_item_value = None
        delegate = self.table_local_functions.itemDelegateForColumn(column)
        if hasattr(delegate, "getEditorForRow"):
            editor = delegate.getEditorForRow(row)
            if editor:
                selected_item_value = editor.currentText()

        # Fallback to table item if no editor found
        if selected_item_value is None:
            selected_item_value = (
                self.table_local_functions.item(row, column).text() if column is not None else None
            )

        return selected_item_value

    def selectDeselectAllLabels(self):
        """Toggle between selecting all labels or deselecting all labels"""
        match_report = self.parent.getMatchingReport()
        if match_report is None:
            return

        # Get all offsets from the current matching report
        current_offsets = set()
        for function_match in match_report.function_matches:
            current_offsets.add(function_match.offset)

        # Check current state: count how many are NOT set to the empty demarker "-|-"
        non_empty_count = 0
        total_count = len(current_offsets)

        for offset in current_offsets:
            selected_value = self.last_selected_fields.get(offset, "-")
            if selected_value != "-|-":
                non_empty_count += 1

        print(f"Current state: {non_empty_count}/{total_count} functions have labels selected")

        # Decision logic based on current state
        if non_empty_count > 0:
            # DESELECTION: At least one row is not set to empty demarker
            print("Performing deselection - setting all to empty demarker")
            for offset in current_offsets:
                self.last_selected_fields[offset] = "-|-"
            self.resolved_function_labels = {}  # Clear resolved labels as well
            self.parent.local_widget.updateActivityInfo(
                f"Deselected labels for {total_count} functions."
            )
        else:
            # SELECTION: All rows are currently set to empty demarker or unset
            print("Performing selection - resetting selection memory")
            self.last_selected_fields = {}  # Reset to forget chosen values
            self.parent.local_widget.updateActivityInfo(
                f"Reset label selection for {total_count} functions."
            )

        # Refresh the table to show the changes
        self.populateFunctionTable(track_selection=False)

    def importSelectedLabels(self):
        # get currently selected names from all dropdowns in the table
        label_score_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        num_names_applied = 0
        num_names_skipped = 0
        for row_id in range(self.table_local_functions.rowCount()):
            offset = int(self.table_local_functions.item(row_id, 0).text(), 16)
            label_via_table = self.getSelectedLabel(row_id, label_score_column_index)
            # we did not get a usable label, we continue to the next row
            if label_via_table == "-":
                continue
            # we found a manually disabled label, we continue to the next row
            if label_via_table == "-|-":
                num_names_skipped += 1
                continue
            # extract the actual name from the score|name pair
            label_fields = label_via_table.split("|")
            if len(label_fields) < 2:
                self.parent.local_widget.updateActivityInfo(
                    f"Error: Could not parse label '{label_via_table}' for function at 0x{offset:x}."
                )
                continue
            label_via_table = label_via_table.split("|")[1]
            # check if IDA function has default name
            ida_function_name = ida_funcs.get_func_name(offset)
            if ida_function_name and re.match("sub_[0-9A-Fa-f]+$", ida_function_name):
                # apply label
                self.cc.ida_proxy.set_name(offset, label_via_table, self.cc.ida_proxy.SN_NOWARN)
                num_names_applied += 1
        if num_names_applied:
            self.parent.local_widget.updateActivityInfo(
                f"Success! Imported {num_names_applied} function names (skipped: {num_names_skipped})."
            )
        else:
            self.parent.local_widget.updateActivityInfo(
                "No suitable function names found to import."
            )

    def _updateLabelFunctionMatches(self, num_functions_matched):
        local_smda_report = self.parent.getLocalSmdaReport()
        total_local_functions = local_smda_report.num_functions
        self.label_local_functions.setText(
            "Local Functions Matched (%d/%d), Remote Functions Matched: %d"
            % (self._countLocalMatches(), total_local_functions, self._countRemoteMatches())
        )

    def _countLocalMatches(self):
        local_matches = set([])
        match_report = self.parent.getMatchingReport()
        for function_match in match_report.function_matches:
            local_matches.add(function_match.function_id)
        return len(local_matches)

    def _countRemoteMatches(self):
        remote_matches = set([])
        match_report = self.parent.getMatchingReport()
        for function_match in match_report.function_matches:
            remote_matches.add(function_match.matched_function_id)
        return len(remote_matches)

    def ensureSpinBoxRange(self, match_report):
        # Set min/max value for score filter once
        if self.global_minimum_match_value is None:
            self.global_minimum_match_value = 100
            self.global_maximum_match_value = 0
            for function_match in match_report.function_matches:
                self.global_minimum_match_value = int(
                    min(self.global_minimum_match_value, function_match.matched_score)
                )
                self.global_maximum_match_value = int(
                    max(self.global_maximum_match_value, function_match.matched_score)
                )
            config_adjusted_lower_value = max(
                self.parent.config.OVERVIEW_MIN_SCORE, self.global_minimum_match_value
            )
            self.sb_minhash_threshold.setRange(
                config_adjusted_lower_value, self.global_maximum_match_value
            )
            self.sb_minhash_threshold.setValue(config_adjusted_lower_value)

    def _calculateLabelCriticality(self, label_list, has_function_name=False, is_resolved=False):
        criticality = 0
        if len(label_list) == 0:
            return criticality
        if has_function_name:
            criticality = 1
            return criticality
        if is_resolved:
            criticality = 2
            return criticality
        criticality = 3
        label_set = set([label_entry[1] for label_entry in label_list])
        top_score = max([label_entry[0] for label_entry in label_list])
        top_score_label_pool = [
            label_entry for label_entry in label_list if label_entry[0] == top_score
        ]
        if len(label_set) > 1:
            criticality += 1
            if len(set([label_entry[1] for label_entry in top_score_label_pool])) > 1:
                criticality += 1
        return criticality

    def generateFunctionTableCellItem(self, column_type, function_info):
        tmp_item = None
        if column_type == McritTableColumn.OFFSET:
            tmp_item = self.cc.QTableWidgetItem("0x%x" % function_info["offset"])
        elif column_type == McritTableColumn.FAMILIES:
            tmp_item = self.NumberQTableWidgetItem("%d" % len(function_info["families"]))
        elif column_type == McritTableColumn.SAMPLES:
            tmp_item = self.NumberQTableWidgetItem("%d" % len(function_info["samples"]))
        elif column_type == McritTableColumn.FUNCTIONS:
            tmp_item = self.NumberQTableWidgetItem("%d" % len(function_info["functions"]))
        elif column_type == McritTableColumn.IS_LIBRARY:
            library_value = "YES" if len(function_info["library_matches"]) > 0 else "NO"
            tmp_item = self.cc.QTableWidgetItem("%s" % library_value)
        elif column_type == McritTableColumn.SCORE_AND_LABEL:
            label_value = "-"
            tmp_item = self.cc.QTableWidgetItem("%s" % label_value)
        return tmp_item

    def populateFunctionTable(self, track_selection=True):
        """
        Populate the function table with information about matches of local functions.
        """
        header_view = self._QtShim.get_QHeaderView()
        qt = self._QtShim.get_Qt()

        match_report = self.parent.getMatchingReport()
        if match_report is None:
            return
        self.ensureSpinBoxRange(match_report)
        threshold_value = self.sb_minhash_threshold.value()

        # count matched functions with labels
        function_entries_with_labels = {}
        if self.parent.matched_function_entries:
            for function_id, function_entry in self.parent.matched_function_entries.items():
                if function_entry.function_labels:
                    function_entries_with_labels[function_id] = function_entry

        # count labels
        function_labels = []
        for function_id, entry in function_entries_with_labels.items():
            for label in entry.function_labels:
                function_labels.append(label)

        # count matched functions
        matched_function_ids_per_function_id = {}
        matches_beyond_filters = 0
        functions_beyond_filters = set()
        aggregated_matches = {}
        for function_match in match_report.function_matches:
            if function_match.function_id not in matched_function_ids_per_function_id:
                matched_function_ids_per_function_id[function_match.function_id] = []
            if (
                function_match.matched_function_id
                not in matched_function_ids_per_function_id[function_match.function_id]
            ):
                matched_function_ids_per_function_id[function_match.function_id].append(
                    function_match.matched_function_id
                )
            if function_match.matched_score >= threshold_value:
                if (
                    self.getSelectedFilter() != "none"
                    and function_match.matched_function_id not in function_entries_with_labels
                ):
                    continue
                matches_beyond_filters += 1
                functions_beyond_filters.add(function_match.function_id)
                if function_match.function_id not in aggregated_matches:
                    aggregated_matches[function_match.function_id] = {
                        "offset": function_match.offset,
                        "families": set(),
                        "samples": set(),
                        "functions": set(),
                        "library_matches": set(),
                        "labels": set(),
                    }
                aggregated_matches[function_match.function_id]["families"].add(
                    function_match.matched_family_id
                )
                aggregated_matches[function_match.function_id]["samples"].add(
                    function_match.matched_sample_id
                )
                aggregated_matches[function_match.function_id]["functions"].add(
                    function_match.matched_function_id
                )
                if function_match.match_is_library:
                    aggregated_matches[function_match.function_id]["library_matches"].add(
                        function_match.matched_function_id
                    )
                if function_match.matched_function_id in function_entries_with_labels:
                    for label in function_entries_with_labels[
                        function_match.matched_function_id
                    ].function_labels:
                        aggregated_matches[function_match.function_id]["labels"].add(
                            (
                                int(function_match.matched_score),
                                label.function_label,
                                label.username,
                                label.timestamp,
                            )
                        )

        # count filtered functions again
        filtered_list = {}
        crit_functions_beyond_filters = set()
        crit_matches_beyond_filters = 0
        crit_function_labels = []
        for function_id, function_info in sorted(aggregated_matches.items()):
            ida_function_name = ida_funcs.get_func_name(function_info["offset"])
            is_custom_name = re.match("sub_[0-9A-Fa-f]+$", ida_function_name) is None
            criticality = self._calculateLabelCriticality(
                list(sorted(function_info["labels"], reverse=True)),
                has_function_name=is_custom_name,
                is_resolved=function_info["offset"] in self.resolved_function_labels,
            )
            function_info["criticality"] = criticality
            if criticality > 0:
                if self.getSelectedFilter() == "applicable" and criticality < 2:
                    continue
                if self.getSelectedFilter() == "conflicted" and criticality < 4:
                    continue
                filtered_list[function_id] = function_info
                crit_functions_beyond_filters.add(function_id)
                crit_matches_beyond_filters += len(function_info["functions"])
                for label_entry in function_info["labels"]:
                    crit_function_labels.append(label_entry[1])
        if self.getSelectedFilter() in ["applicable", "conflicted"]:
            aggregated_matches = filtered_list
            functions_beyond_filters = crit_functions_beyond_filters
            matches_beyond_filters = crit_matches_beyond_filters
            function_labels = crit_function_labels

        # Update summary
        update_text = f"Showing {len(functions_beyond_filters)} functions with {matches_beyond_filters} matches and {len(function_labels)} labels ({len(matched_function_ids_per_function_id) - len(functions_beyond_filters)} functions and {len(match_report.function_matches) - matches_beyond_filters} matches filtered)"
        self.label_local_functions.setText(update_text)

        label_score_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        offset_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        self.local_function_header_labels = [
            McritTableColumn.MAP_COLUMN_TO_HEADER_STRING[col]
            for col in self.parent.config.OVERVIEW_TABLE_COLUMNS
        ]
        self.table_local_functions.setSortingEnabled(False)

        if track_selection:
            # maintain a registry of current selections made by the user
            new_selected_fields = {}
            for row in range(self.table_local_functions.rowCount()):
                offset = (
                    int(self.table_local_functions.item(row, offset_column_index).text(), 16)
                    if offset_column_index is not None
                    else None
                )
                item = (
                    self.table_local_functions.item(row, label_score_column_index).text()
                    if label_score_column_index is not None
                    else None
                )
                selected_item = None
                if item is not None:
                    if offset is not None:
                        if offset in self.last_selected_fields:
                            if item == "-":
                                selected_item = self.last_selected_fields[offset]
                            elif item != self.last_selected_fields[offset]:
                                selected_item = item
                            else:
                                selected_item = self.last_selected_fields[offset]
                            score = selected_item.split("|")[0] if "|" in selected_item else "-"
                            if score != "-":
                                if int(score) >= threshold_value:
                                    # selection is fine, keep it
                                    pass
                                else:
                                    # set to highest value instead
                                    selected_item = "-"
                            else:
                                selected_item = "-|-"
                        else:
                            selected_item = item
                if selected_item == "-" and self.function_name_mapping:
                    selected_item = self.function_name_mapping[(row, label_score_column_index)][0][
                        "text"
                    ]
                new_selected_fields[offset] = selected_item
            self.last_selected_fields = new_selected_fields

        self.table_local_functions.clear()
        self.table_local_functions.setColumnCount(len(self.local_function_header_labels))
        self.table_local_functions.setHorizontalHeaderLabels(self.local_function_header_labels)
        # Identify number of table entries and prepare addresses to display
        self.table_local_functions.setRowCount(len(aggregated_matches))
        self.table_local_functions.resizeRowToContents(0)
        row = 0
        self.function_name_mapping = {}
        self.row_criticality_mapping = {}
        self.current_rows = aggregated_matches

        if label_score_column_index is not None:
            for function_id, function_info in sorted(aggregated_matches.items()):
                # set label based on stored selection if available
                rows_labels = []
                preselected_label = self.last_selected_fields.get(function_info["offset"], None)
                if function_info["offset"] in self.resolved_function_labels:
                    resolved_label = self.resolved_function_labels[function_info["offset"]]
                    preselected_label = resolved_label
                label_assigned = False
                for label_entry in sorted(function_info["labels"], reverse=True):
                    formatted_label_entry = f"{label_entry[0]}|{label_entry[1]}"
                    if formatted_label_entry == preselected_label and not label_assigned:
                        rows_labels.append({"text": formatted_label_entry, "preselected": True})
                        label_assigned = True
                    else:
                        rows_labels.append({"text": formatted_label_entry, "preselected": False})
                rows_labels.append({"text": "-|-", "preselected": preselected_label == "-|-"})
                self.function_name_mapping[(row, label_score_column_index)] = rows_labels
                self.row_criticality_mapping[row] = function_info.get("criticality", 0)
                for column, column_name in enumerate(self.local_function_header_labels):
                    column_type = self.parent.config.OVERVIEW_TABLE_COLUMNS[column]
                    tmp_item = self.generateFunctionTableCellItem(column_type, function_info)
                    tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                    tmp_item.setTextAlignment(qt.AlignHCenter)
                    self.table_local_functions.setItem(row, column, tmp_item)
                self.table_local_functions.resizeRowToContents(row)
                row += 1
            # we need to set up rendering delegates for function names only if we have names at all
            if function_labels:
                # Set the delegate to create dropdown menus in the second column
                delegate = DropdownDelegate(
                    self.function_name_mapping, self.row_criticality_mapping, self
                )
                self.table_local_functions.setItemDelegateForColumn(
                    label_score_column_index, delegate
                )

                # Show the dropdown menus immediately
                for row in range(self.table_local_functions.rowCount()):
                    item = self.table_local_functions.item(
                        row, label_score_column_index
                    )  # Get the QTableWidgetItem for the cell
                    self.table_local_functions.openPersistentEditor(item)

        self.table_local_functions.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_local_functions.resizeColumnsToContents()
        self.table_local_functions.setSortingEnabled(True)
        header = self.table_local_functions.horizontalHeader()

        # Set column resize modes based on content type
        offset_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        label_score_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        families_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.FAMILIES, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        samples_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SAMPLES, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        functions_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.FUNCTIONS, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        library_column_index = McritTableColumn.columnTypeToIndex(
            McritTableColumn.IS_LIBRARY, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )

        for header_id in range(0, len(self.local_function_header_labels), 1):
            try:
                # Set minimal width for numeric and fixed-content columns
                if header_id in [
                    offset_column_index,
                    families_column_index,
                    samples_column_index,
                    functions_column_index,
                    library_column_index,
                ]:
                    header.setSectionResizeMode(header_id, header_view.ResizeToContents)
                # Let the score/label column stretch to fill remaining space
                elif header_id == label_score_column_index:
                    header.setSectionResizeMode(header_id, header_view.Stretch)
                else:
                    # Fallback for any other columns
                    header.setSectionResizeMode(header_id, header_view.ResizeToContents)
            except Exception:
                # Fallback for older Qt versions
                if header_id in [
                    offset_column_index,
                    families_column_index,
                    samples_column_index,
                    functions_column_index,
                    library_column_index,
                ]:
                    header.setResizeMode(header_id, header_view.ResizeToContents)
                elif header_id == label_score_column_index:
                    header.setResizeMode(header_id, header_view.Stretch)
                else:
                    header.setResizeMode(header_id, header_view.ResizeToContents)

        # Don't stretch the last section since we're handling it explicitly
        header.setStretchLastSection(False)

    ################################################################################
    # Buttons and Actions
    ################################################################################

    def _onTableFunctionsSelectionChanged(self, selected, deselected):
        try:
            self.table_local_functions.selectedItems()[0].row()
        except IndexError:
            # we can ignore this, as it may happen when a popup window is closed
            pass

    def _onTableFunctionsClicked(self, mi):
        """
        If a row in the best family match table is clicked, handle the selection
        """
        # For left click (default behavior), just handle the selection
        function_offset_column = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        if function_offset_column is not None:
            clicked_function_address = self.table_local_functions.item(
                mi.row(), function_offset_column
            ).text()
            as_int = int(clicked_function_address, 16)
            self.last_function_selected = as_int

    def _handleRightClickOnRow(self, row, column):
        """Handle right-click action for a specific row and column"""
        function_offset_column = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        function_label_column = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        if column == function_label_column and row >= 0:
            # For this column, get the specific function's labels from the current row
            function_ids = list(sorted(self.current_rows.keys()))
            if row < len(function_ids):
                function_id = function_ids[row]
                aggregated_result = self.current_rows[function_id]
                if False:  # Print detailed label information to console for debugging
                    print(
                        f"Labels for function id {function_id} @ {self.table_local_functions.item(row, function_offset_column).text()}"
                    )
                    for label in sorted(aggregated_result["labels"], reverse=True):
                        print(
                            f"  Score: {label[0]}, Label: {label[1]}, Username: {label[2]}, Timestamp: {label[3]}"
                        )
                function_offset = aggregated_result["offset"]
                if function_offset in self.resolved_function_labels:
                    self.resolved_function_labels.pop(function_offset)
                    self.update()
                else:
                    label_score_column_index = McritTableColumn.columnTypeToIndex(
                        McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
                    )
                    offset_column_index = McritTableColumn.columnTypeToIndex(
                        McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
                    )
                    for row in range(self.table_local_functions.rowCount()):
                        offset = (
                            int(
                                self.table_local_functions.item(row, offset_column_index).text(), 16
                            )
                            if offset_column_index is not None
                            else None
                        )

                        if offset == function_offset:
                            selected_item_value = self.getSelectedLabel(
                                row, label_score_column_index
                            )
                            if selected_item_value is not None:
                                self.resolved_function_labels[function_offset] = selected_item_value
                                self.update()
                                break

    def _onTableFunctionsDoubleClicked(self, mi):
        function_offset_column = McritTableColumn.columnTypeToIndex(
            McritTableColumn.OFFSET, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        function_label_column = McritTableColumn.columnTypeToIndex(
            McritTableColumn.SCORE_AND_LABEL, self.parent.config.OVERVIEW_TABLE_COLUMNS
        )
        clicked_function_address = self.table_local_functions.item(
            mi.row(), function_offset_column
        ).text()
        if mi.column() not in [function_offset_column, function_label_column]:
            self.cc.ida_proxy.Jump(int(clicked_function_address, 16))
            # change to function scope tab
            self.parent.main_widget.tabs.setCurrentIndex(1)
            self.parent.function_match_widget.queryCurrentFunction()
        elif mi.column() == function_offset_column:
            self.cc.ida_proxy.Jump(int(clicked_function_address, 16))

```

`widgets/LocalInfoWidget.py`:

```py
import datetime

import helpers.QtShim as QtShim

QMainWindow = QtShim.get_QMainWindow()


class LocalInfoWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        self._datetime = datetime
        print("[|] loading LocalInfoWidget")
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.name = "LocalInfo"
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "scan.png")
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.label_mcrit_activity_info = self.cc.QLabel("Activity Info: <PLACEHOLDER>")
        self.updateActivityInfo("MCRIT4IDA started.")
        self.label_mcrit_server_info = self.cc.QLabel("MCRIT Remote server: <not_active>")
        self.label_remote_sample_info = self.cc.QLabel("Remote sample: <unknown>")
        # horizontal line
        self.hline = self.cc.QFrame()
        self.hline.setFrameShape(self.cc.QFrameHLine)
        self.hline.setFrameShadow(self.cc.QFrameShadow.Sunken)
        # SMDA report info fields
        self.label_sha256 = self.cc.QLabel("SHA256: ")
        self.label_label_sha256_value = self.cc.QLabel("no data")
        self.label_architecture = self.cc.QLabel("Architecture: ")
        self.label_architecture_value = self.cc.QLabel("no data")
        self.label_bitness = self.cc.QLabel("Bitness: ")
        self.label_bitness_value = self.cc.QLabel("no data")
        self.label_image_base = self.cc.QLabel("ImageBase: ")
        self.label_image_base_value = self.cc.QLabel("no data")
        self.label_functions = self.cc.QLabel("Functions: ")
        self.label_functions_value = self.cc.QLabel("no data")
        self.label_instructions = self.cc.QLabel("Instructions: ")
        self.label_instructions_value = self.cc.QLabel("no data")
        self.label_size = self.cc.QLabel("Code Size: ")
        self.label_size_value = self.cc.QLabel("no data")
        self.label_family = self.cc.QLabel("Family: ")
        self.label_family_value = self.cc.QLabel("no data")
        self.label_version = self.cc.QLabel("Version: ")
        self.label_version_value = self.cc.QLabel("no data")
        self.label_library = self.cc.QLabel("Library: ")
        self.label_library_value = self.cc.QLabel("no data")
        self._createGui()

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # compose and layout the widget
        local_layout = self.cc.QVBoxLayout()
        local_layout.addWidget(self.label_mcrit_activity_info)
        local_layout.addWidget(self.label_mcrit_server_info)
        local_layout.addWidget(self.label_remote_sample_info)
        local_layout.addWidget(self.hline)
        local_info_widget = self.cc.QWidget()
        grid_layout = self.cc.QGridLayout()
        grid_layout.addWidget(self.label_sha256, 0, 0)
        grid_layout.addWidget(self.label_label_sha256_value, 0, 1)
        grid_layout.addWidget(self.label_architecture, 1, 0)
        grid_layout.addWidget(self.label_architecture_value, 1, 1)
        grid_layout.addWidget(self.label_bitness, 2, 0)
        grid_layout.addWidget(self.label_bitness_value, 2, 1)
        grid_layout.addWidget(self.label_image_base, 3, 0)
        grid_layout.addWidget(self.label_image_base_value, 3, 1)
        grid_layout.addWidget(self.label_functions, 4, 0)
        grid_layout.addWidget(self.label_functions_value, 4, 1)
        grid_layout.addWidget(self.label_instructions, 5, 0)
        grid_layout.addWidget(self.label_instructions_value, 5, 1)
        grid_layout.addWidget(self.label_size, 6, 0)
        grid_layout.addWidget(self.label_size_value, 6, 1)
        grid_layout.addWidget(self.label_family, 7, 0)
        grid_layout.addWidget(self.label_family_value, 7, 1)
        grid_layout.addWidget(self.label_version, 8, 0)
        grid_layout.addWidget(self.label_version_value, 8, 1)
        grid_layout.addWidget(self.label_library, 9, 0)
        grid_layout.addWidget(self.label_library_value, 9, 1)
        grid_layout.setColumnStretch(0, 1)
        grid_layout.setColumnStretch(1, 3)
        local_info_widget.setLayout(grid_layout)
        local_layout.addWidget(local_info_widget)
        self.central_widget.setLayout(local_layout)

    def _summarizeLocalReportInstructionBytes(self):
        num_bytes = 0
        local_smda_report = self.parent.getLocalSmdaReport()
        if local_smda_report:
            for smda_function in local_smda_report.getFunctions():
                for smda_ins in smda_function.getInstructions():
                    num_bytes += len(smda_ins.bytes) / 2
        return num_bytes

    def update(self):
        local_smda_report = self.parent.getLocalSmdaReport()
        if not local_smda_report:
            return
        self.label_label_sha256_value.setText(local_smda_report.sha256)
        self.label_architecture_value.setText(local_smda_report.architecture)
        self.label_bitness_value.setText("%d bit" % local_smda_report.bitness)
        self.label_image_base_value.setText("0x%x" % local_smda_report.base_addr)
        self.label_functions_value.setText(
            "%d (leaf: %d, recursive: %d)"
            % (
                local_smda_report.num_functions,
                local_smda_report.statistics.num_leaf_functions,
                local_smda_report.statistics.num_recursive_functions,
            )
        )
        self.label_instructions_value.setText(
            "%d" % (local_smda_report.statistics.num_instructions)
        )
        self.label_size_value.setText("%d bytes" % self._summarizeLocalReportInstructionBytes())
        self.label_family_value.setText(local_smda_report.family)
        self.label_version_value.setText(local_smda_report.version)
        is_library = "YES" if local_smda_report.is_library else "NO"
        self.label_library_value.setText(is_library)
        if self.parent.remote_sample_entry:
            self.label_remote_sample_info.setText(
                "Remote sample: %s (%s -- %s)"
                % (
                    self.parent.remote_sample_entry.sample_id,
                    self.parent.remote_sample_entry.family,
                    self.parent.remote_sample_entry.version,
                )
            )

    def updateActivityInfo(self, message):
        timestamp = self._datetime.datetime.utcnow().strftime("%Y-%m-%dT%H-%M-%SZ")
        self.label_mcrit_activity_info.setText("Activity Info: %s - %s" % (timestamp, message))

    def updateServerInfo(self, mcrit_server, version=None, statistics=None):
        if statistics:
            num_families = statistics["num_families"]
            fam_str = "families" if num_families != 1 else "family"
            num_samples = statistics["num_samples"]
            sam_str = "samples" if num_samples != 1 else "sample"
            num_functions = statistics["num_functions"]
            fun_str = "functions" if num_functions != 1 else "function"
        version_text = version if version is not None else "No connection"
        status_text = (
            "Content: %d %s with %d %s containing %d %s."
            % (num_families, fam_str, num_samples, sam_str, num_functions, fun_str)
            if statistics
            else "No statistics"
        )
        self.label_mcrit_server_info.setText(
            "Remote server: %s  -- %s -- %s." % (mcrit_server, version_text, status_text)
        )

```

`widgets/MainWidget.py`:

```py
import json
import os

import ida_kernwin
import idaapi

import helpers.QtShim as QtShim
from widgets.ResultChooserDialog import ResultChooserDialog
from widgets.SmdaInfoDialog import SmdaInfoDialog
from widgets.YaraStringBuilderDialog import YaraStringBuilderDialog

QMainWindow = QtShim.get_QMainWindow()


class MainWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        print("[|] loading MainWidget")
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.name = "Main"
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "mcrit.png")
        self.tabs = None
        self.tabbed_widgets = [
            self.parent.block_match_widget,
            self.parent.function_match_widget,
            self.parent.function_widget,
        ]
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.SmdaInfoDialog = SmdaInfoDialog
        self.ResultChooserDialog = ResultChooserDialog
        self.YaraStringBuilderDialog = YaraStringBuilderDialog
        self._createGui()
        self.parent.mcrit_interface.checkConnection()
        # IDA 6.x Windows workaronud to avoid lost imports
        self.os = os
        self.os_path = os.path

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # create the main toolbar
        self._createToolbar()
        # layout and fill the widget
        self.tabs = self.cc.QTabWidget()
        self.tabs.setTabsClosable(False)
        for widget in self.tabbed_widgets:
            self.tabs.addTab(widget, widget.icon, widget.name)
        layout = self.cc.QVBoxLayout()
        self.splitter = self.cc.QSplitter(self.cc.QtCore.Qt.Vertical)
        q_clean_style = self.cc.QStyleFactory.create("Plastique")
        self.splitter.setStyle(q_clean_style)
        self.splitter.addWidget(self.parent.local_widget)
        self.splitter.addWidget(self.tabs)
        self.splitter.setStretchFactor(1, 10)
        layout.addWidget(self.splitter)
        self.central_widget.setLayout(layout)
        self.setTabFocus("SampleInfo")

    def _createToolbar(self):
        """
        Creates the toolbar, containing buttons to control the widget.
        """
        # TODO for MCRIT 1.0.0 release, we hide the other buttons until they are properly developed
        self.toolbar = self.addToolBar("MCRIT4IDA Toobar")
        self._createParseSmdaAction()
        self.toolbar.addAction(self.parseSmdaAction)
        self._createUploadSmdaAction()
        self.toolbar.addAction(self.uploadSmdaAction)
        self._createGetMatchResultAction()
        self.toolbar.addAction(self.getMatchResultAction)
        self._createExportSmdaAction()
        self.toolbar.addAction(self.exportSmdaAction)
        self._createBuildYaraStringAction()
        self.toolbar.addAction(self.buildYaraStringAction)
        self._createModifySettingsAction()
        # self.toolbar.addAction(self.modifySettingsAction)

    def _createParseSmdaAction(self):
        """
        Create an action for parsing the IDB into a SMDA report.
        """
        self.parseSmdaAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "fingerprint_scan.png"),
            "Convert this IDB to a SMDA report which can then be used to query MCRIT.",
            self,
        )
        self.parseSmdaAction.triggered.connect(self._onConvertSmdaButtonClicked)

    def _createUploadSmdaAction(self):
        """
        Create an action for uploading the parsed SMDA report to the server.
        TODO: will require addition of some more meta data.
        """
        self.uploadSmdaAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "cloud-upload.png"),
            "Reparse and upload the SMDA report to the MCRIT server.",
            self,
        )
        self.uploadSmdaAction.setEnabled(False)
        self.uploadSmdaAction.triggered.connect(self._onUploadSmdaButtonClicked)

    def _createGetMatchResultAction(self):
        """
        Create an action for requesting a MatchReport for the given remote sample
        """
        self.getMatchResultAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "satellite_dish.png"),
            "Request the MatchResult for the uploaded sample.",
            self,
        )
        self.getMatchResultAction.setEnabled(False)
        self.getMatchResultAction.triggered.connect(self._onGetMatchResultButtonClicked)

    def _createExportSmdaAction(self):
        """
        Create an action for exporting the parsed SMDA report into json/smda format.
        """
        self.exportSmdaAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "export.png"),
            "Export the SMDA report to local disk.",
            self,
        )
        self.exportSmdaAction.setEnabled(False)
        self.exportSmdaAction.triggered.connect(self._onExportSmdaButtonClicked)

    def _createBuildYaraStringAction(self):
        """
        Create an action for building a YARA string from the current selection.
        """
        self.buildYaraStringAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "yara.png"),
            "Build a YARA string from the current selection.",
            self,
        )
        self.buildYaraStringAction.setEnabled(False)
        self.buildYaraStringAction.triggered.connect(self._onBuildYaraStringButtonClicked)

    def _createModifySettingsAction(self):
        """
        Create an action for sending a matching query to the MCRIT server.
        """
        self.modifySettingsAction = self.cc.QAction(
            self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "settings.png"),
            "Adjust MCRIT4IDA settings.",
            self,
        )
        self.modifySettingsAction.triggered.connect(self._onNopButtonClicked)

    def _onNopButtonClicked(self):
        return

    def getLocalSmdaReport(self):
        ida_converted_report = self.parent.mcrit_interface.convertIdbToSmda()
        local_report = ida_converted_report
        # check of we alternatively want to use SMDA for analysis
        smda_converted_report = None
        if self.parent.config.USE_SMDA_FOR_ANALYSIS:
            smda_converted_report = self.parent.mcrit_interface.convertIdbToSmdaUsingSmda()
        if smda_converted_report is not None:
            ida_report_offsets = [func.offset for func in ida_converted_report.getFunctions()]
            smda_report_offsets = [func.offset for func in smda_converted_report.getFunctions()]
            # output diagnostic information if function sets differ
            if set(ida_report_offsets) != set(smda_report_offsets):
                print(
                    f"[!] SMDA disassembly report function set ({len(smda_report_offsets)}) differs from IDA converted report function set ({len(ida_report_offsets)})!"
                )
                missing_in_smda = set(ida_report_offsets) - set(smda_report_offsets)
                missing_in_ida = set(smda_report_offsets) - set(ida_report_offsets)
                if missing_in_smda:
                    print(
                        "    Functions in IDA but not in SMDA report (%d): %s"
                        % (
                            len(missing_in_smda),
                            ", ".join([f"0x{off:x}" for off in missing_in_smda]),
                        )
                    )
                if missing_in_ida:
                    print(
                        "    Functions in SMDA but not in IDA report (%d): %s"
                        % (len(missing_in_ida), ", ".join([f"0x{off:x}" for off in missing_in_ida]))
                    )
                print("    Using SMDA converted report.")
            else:
                print(
                    "[|] SMDA converted report function set matches IDA converted report function set."
                )
            local_report = smda_converted_report
        if local_report is not None:
            # some information obtained from IDA directly
            local_report.sha256 = idaapi.retrieve_input_file_sha256().hex()
            local_report.filename = self.os_path.basename(idaapi.get_root_filename())
            local_report.buffer_size = idaapi.retrieve_input_file_size()
            local_report.smda_version = "MCRIT4IDA v%s via SMDA %s" % (
                self.parent.config.VERSION,
                local_report.smda_version,
            )
            # if yes, use information from it
            if self.parent.remote_sample_entry is not None:
                local_report.family = self.parent.remote_sample_entry.family
                local_report.version = self.parent.remote_sample_entry.version
                local_report.is_library = self.parent.remote_sample_entry.is_library
        return local_report

    def _onBuildYaraStringButtonClicked(self):
        ida_selection_start = self.cc.ida_proxy.ReadSelectionStart()
        ida_selection_end = self.cc.ida_proxy.ReadSelectionEnd()
        has_selection = (
            ida_selection_start is not None
            and ida_selection_end is not None
            and ida_selection_start != ida_selection_end
        )

        # fetch instruction, block, and function information based on current cursor position
        current_ea = ida_kernwin.get_screen_ea()
        current_function = self.parent.local_smda_report.findFunctionByContainedAddress(current_ea)
        current_block = self.parent.local_smda_report.findBlockByContainedAddress(current_ea)

        # for sequences of instructions, we need to emulate the procedure from SmdaFunction
        # this will allow us to correlate the individual escaped instructions with their disassembly representation
        selected_ins_sequence = []
        if has_selection:
            for smda_function in self.parent.local_smda_report.getFunctions():
                for smda_instruction in smda_function.getInstructions():
                    if (
                        smda_instruction.offset >= ida_selection_start
                        and smda_instruction.offset < ida_selection_end
                    ):
                        selected_ins_sequence.append(smda_instruction)
            selected_ins_sequence.sort(key=lambda ins: ins.offset)
        else:
            # If no selection, use single instruction at cursor
            for smda_function in self.parent.local_smda_report.getFunctions():
                for smda_instruction in smda_function.getInstructions():
                    if smda_instruction.offset == current_ea:
                        selected_ins_sequence = [smda_instruction]
                        break
                if selected_ins_sequence:
                    break
        functions_ins_sequence = (
            list(current_function.getInstructions()) if current_function else None
        )
        blocks_ins_sequence = list(current_block.getInstructions()) if current_block else None

        data_bytes = b""
        if not selected_ins_sequence and has_selection:
            data_bytes = self.cc.ida_proxy.GetBytes(
                ida_selection_start, ida_selection_end - ida_selection_start
            )
        # Create and show the dialog
        dialog = self.YaraStringBuilderDialog(
            self,
            data=data_bytes,
            selection_sequence=selected_ins_sequence if selected_ins_sequence else None,
            block_sequence=blocks_ins_sequence,
            function_sequence=functions_ins_sequence,
            sha256=self.parent.local_smda_report.sha256 if self.parent.local_smda_report else "",
            offset=current_ea,
            selection_start=ida_selection_start or current_ea,
            selection_end=ida_selection_end or current_ea,
        )
        dialog.exec_()

    def _onConvertSmdaButtonClicked(self):
        local_smda_report = self.getLocalSmdaReport()
        if self.parent.local_smda_report is None:
            self.parent.local_smda_report = local_smda_report
            self.parent.getRemoteSampleInformation()
        if self.parent.local_smda_report is not None:
            self.exportSmdaAction.setEnabled(True)
            self.uploadSmdaAction.setEnabled(True)
            self.buildYaraStringAction.setEnabled(True)
            # check if remote sample exists
            self.parent.mcrit_interface.querySampleSha256(self.parent.local_smda_report.sha256)
            # if yes, enable matching and use meta data
            if self.parent.remote_sample_entry is not None:
                self.getMatchResultAction.setEnabled(True)
                self.parent.local_smda_report.family = self.parent.remote_sample_entry.family
                self.parent.local_smda_report.version = self.parent.remote_sample_entry.version
                self.parent.local_smda_report.is_library = (
                    self.parent.remote_sample_entry.is_library
                )
            # else query for family, version, library instead
            else:
                dialog = self.SmdaInfoDialog(self)
                dialog.exec_()
                smda_info = dialog.getSmdaInfo()
                self.parent.local_smda_report.family = smda_info["family"]
                self.parent.local_smda_report.version = smda_info["version"]
                self.parent.local_smda_report.is_library = smda_info["is_library"]
            self.parent.block_match_widget.enable()
            self.parent.function_match_widget.enable()
        self.parent.local_widget.update()

    def _onExportSmdaButtonClicked(self):
        # save metadata before upload to not overwrite it
        local_family = self.parent.local_smda_report.family if self.parent.local_smda_report else ""
        local_version = (
            self.parent.local_smda_report.version if self.parent.local_smda_report else ""
        )
        local_library = (
            self.parent.local_smda_report.is_library if self.parent.local_smda_report else False
        )
        # update before export, to ensure we have all most recent function label information
        self.parent.local_smda_report = self.getLocalSmdaReport()
        self.parent.local_smda_report.family = local_family
        self.parent.local_smda_report.version = local_version
        self.parent.local_smda_report.is_library = local_library
        if self.parent.local_smda_report:
            filepath = ida_kernwin.ask_file(
                1, self.parent.local_smda_report.filename + ".smda", "Export SMDA report to file..."
            )
            if filepath:
                with open(filepath, "w") as fout:
                    json.dump(
                        self.parent.local_smda_report.toDict(), fout, indent=1, sort_keys=True
                    )
                self.parent.local_widget.updateActivityInfo('IDB exported to: "%s".' % filepath)
            else:
                self.parent.local_widget.updateActivityInfo("Export aborted.")
        else:
            self.parent.local_widget.updateActivityInfo(
                "IDB is not converted to SMDA report yet, can't export."
            )

    def _onUploadSmdaButtonClicked(self):
        # save metadata before upload to not overwrite it
        local_family = self.parent.local_smda_report.family if self.parent.local_smda_report else ""
        local_version = (
            self.parent.local_smda_report.version if self.parent.local_smda_report else ""
        )
        local_library = (
            self.parent.local_smda_report.is_library if self.parent.local_smda_report else False
        )
        # update before export, to ensure we have all most recent function label information
        self.parent.local_smda_report = self.getLocalSmdaReport()
        self.parent.local_smda_report.family = local_family
        self.parent.local_smda_report.version = local_version
        self.parent.local_smda_report.is_library = local_library
        if self.parent.local_smda_report:
            self.parent.mcrit_interface.uploadReport(self.parent.local_smda_report)
            # check if remote sample exists
            if self.parent.remote_sample_id is not None:
                self.getMatchResultAction.setEnabled(True)
        else:
            self.parent.local_widget.updateActivityInfo(
                "IDB is not converted to SMDA report yet, can't upload."
            )

    def _onGetMatchResultButtonClicked(self):
        if self.parent.remote_sample_id is not None:
            # fetch jobs
            jobs = self.parent.mcrit_interface.queryJobs(sample_id=self.parent.remote_sample_id)
            # check which job the user wants to use as reference
            dialog = self.ResultChooserDialog(self, job_infos=jobs)
            dialog.exec_()
            dialog_result = dialog.getResultChosen()
            # if user wants to request a new matching, schedule it via client
            if dialog_result["is_requesting_matching_job"]:
                self.parent.mcrit_interface.requestMatchingJob(
                    self.parent.remote_sample_id, force_update=True
                )
            # if otherwise a job was finished and a job_id selected, fetch the data
            elif dialog_result["selected_job_id"]:
                # we already have this matching data, so we can skip and save time
                if (
                    self.parent.matching_job_id is not None
                    and self.parent.matching_job_id == dialog_result["selected_job_id"]
                ):
                    pass
                else:
                    self.parent.mcrit_interface.getMatchingJobById(dialog_result["selected_job_id"])
                self.tabs.setCurrentIndex(2)
                self.hideLocalWidget()
            self.parent.function_widget.update()
            if self.parent.config.OVERVIEW_FETCH_LABELS_AUTOMATICALLY:
                self.parent.function_widget.fetchLabels()
            return
        else:
            self.parent.local_widget.updateActivityInfo(
                "No remote Sample present yet, can't request a matching or query results."
            )

    def hideLocalWidget(self):
        self.splitter.setSizes([0, 1])

    def setTabFocus(self, widget_name):
        """
        Can be used by MCRIT4IDA widgets to set focus to a widget, identified by name.
        @param widget_name: A widget name
        @type widget_name: str
        """
        for widget in self.tabbed_widgets:
            if widget.name == widget_name:
                tab_index = self.tabs.indexOf(widget)
                self.tabs.setCurrentIndex(tab_index)
        return

```

`widgets/NumberQTableWidgetItem.py`:

```py
#!/usr/bin/python
########################################################################
# Copyright (c) 2012
# Daniel Plohmann <daniel.plohmann<at>gmail<dot>com>
# Alexander Hanel <alexander.hanel<at>gmail<dot>com>
# All rights reserved.
########################################################################
#
#  This file is part of IDAscope
#
#  IDAscope is free software: you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see
#  <http://www.gnu.org/licenses/>.
#
########################################################################

import helpers.QtShim as QtShim

QTableWidgetItem = QtShim.get_QTableWidgetItem()


class NumberQTableWidgetItem(QTableWidgetItem):
    """
    A simple helper class that allows sorting by numeric values.
    """

    def __lt__(self, other):
        """
        Redefine function from QTableWidgetItem to allow sorting by numeric value instead of string value.
        @param other: another item of the same type
        @type other: I{NumberQTableWidgetItem}
        @return: (boolean) the numeric comparison of the items.
        """
        return float(self.text()) < float(other.text())

```

`widgets/ResultChooserDialog.py`:

```py
import helpers.QtShim as QtShim
from widgets.NumberQTableWidgetItem import NumberQTableWidgetItem

QDialog = QtShim.get_QDialog()
QStyledItemDelegate = QtShim.get_QStyledItemDelegate()
QColor = QtShim.get_QColor()
QPalette = QtShim.get_QPalette()


class StatusRowDelegate(QStyledItemDelegate):
    def __init__(self, queued_rows, progress_rows, finished_rows):
        super().__init__()
        self.queued_rows = queued_rows
        self.progress_rows = progress_rows
        self.finished_rows = finished_rows

    def paint_rect(self, painter, option, index, r, g, b):
        painter.save()
        palette = option.palette
        bg_color = QColor(r, g, b)
        palette.setColor(QPalette.Base, bg_color)
        painter.setPen(QColor(0, 0, 0))  # Set text color to black explicitly
        painter.fillRect(option.rect, bg_color)
        painter.drawText(option.rect, option.displayAlignment, index.data())
        painter.restore()

    def paint(self, painter, option, index):
        if index.row() in self.queued_rows:
            self.paint_rect(painter, option, index, 200, 50, 50)
        elif index.row() in self.progress_rows:
            self.paint_rect(painter, option, index, 200, 200, 50)
        elif index.row() in self.finished_rows:
            self.paint_rect(painter, option, index, 50, 200, 50)
        else:
            # Default painting for other rows
            super().paint(painter, option, index)


class ResultChooserDialog(QDialog):
    def __init__(self, parent, job_infos):
        self.cc = parent.cc
        self.cc.QDialog.__init__(self, parent)
        self.NumberQTableWidgetItem = NumberQTableWidgetItem
        self._QtShim = QtShim
        self.job_infos = job_infos
        # create GUI elements
        self._createInputWidget()
        self._createButtons()
        # glue everything together
        dialog_layout = self.cc.QVBoxLayout()
        dialog_layout.addWidget(self.input_widget)
        dialog_layout.addLayout(self.button_layout)
        self.setLayout(dialog_layout)
        self.setWindowTitle(self.tr("Remote Match Results"))
        self._sample_family = ""
        self._sample_version = ""
        self._sample_is_library = False
        self._is_requesting_matching_job = False
        self._selected_job_id = None

    def _createInputWidget(self):
        self.input_widget = self.cc.QWidget()
        input_layout = self.cc.QVBoxLayout()
        if self.job_infos:
            self.table_jobs = self.cc.QTableWidget()
            self.table_jobs.doubleClicked.connect(self._onTableJobRowDoubleClicked)
            self.populateJobsTable()
            # arrange in layout
            input_layout.addWidget(self.table_jobs)
            self.resize(self.table_jobs.width(), self.table_jobs.height())
        else:
            self.label_no_jobs = self.cc.QLabel("No Matching Results available yet.")
            input_layout.addWidget(self.label_no_jobs)
        self.input_widget.setLayout(input_layout)

    def populateJobsTable(self):
        """
        Populate the job table
        """
        self.table_jobs.setSortingEnabled(False)
        self.table_jobs_header_labels = ["ID", "Type", "Date", "Progress"]
        self.table_jobs.clear()
        self.table_jobs.setColumnCount(len(self.table_jobs_header_labels))
        self.table_jobs.setHorizontalHeaderLabels(self.table_jobs_header_labels)
        # Identify number of table entries and prepare addresses to display
        self.table_jobs.setRowCount(len(self.job_infos))
        self.table_jobs.resizeRowToContents(0)

        row = 0
        preselected = None
        finished_rows = []
        progress_rows = []
        queued_rows = []
        for job_info in self.job_infos:
            for column, column_name in enumerate(self.table_jobs_header_labels):
                tmp_item = None
                if column == 0:
                    tmp_item = self.NumberQTableWidgetItem("%d" % job_info.number)
                elif column == 1:
                    tmp_item = self.cc.QTableWidgetItem(job_info.parameters)
                elif column == 2:
                    date_str = "Not started yet."
                    if job_info.started_at is None:
                        queued_rows.append(row)
                    elif job_info.finished_at is not None:
                        date_str = job_info.finished_at[:19]
                        finished_rows.append(row)
                    elif job_info.started_at is not None:
                        date_str = job_info.started_at[:19]
                        progress_rows.append(row)
                    tmp_item = self.cc.QTableWidgetItem(date_str)
                elif column == 3:
                    progress_value = 0
                    if job_info.started_at is not None:
                        progress_value = 100 * job_info.progress
                        if progress_value == 100 and preselected is None:
                            preselected = row
                    tmp_item = self.NumberQTableWidgetItem("%5.2f" % progress_value)
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                self.table_jobs.setItem(row, column, tmp_item)
            row += 1

        delegate = StatusRowDelegate(queued_rows, progress_rows, finished_rows)
        self.table_jobs.setItemDelegate(delegate)
        if preselected:
            self.table_jobs.setCurrentCell(preselected, 0)
        self.table_jobs.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_jobs.resizeColumnsToContents()
        self.table_jobs.setSortingEnabled(True)
        header = self.table_jobs.horizontalHeader()
        header.setStretchLastSection(True)

    def _createButtons(self):
        self.button_layout = self.cc.QHBoxLayout()
        self.button_layout.addStretch(1)
        if self.job_infos:
            self.select_button = self.cc.QPushButton(self.tr("Select Result"))
            self.select_button.clicked.connect(self.accept_select)
            self.button_layout.addWidget(self.select_button)
        self.create_button = self.cc.QPushButton(self.tr("Create New Matching Job"))
        self.create_button.clicked.connect(self.accept_create)
        self.button_layout.addWidget(self.create_button)
        self.cancel_button = self.cc.QPushButton(self.tr("Cancel"))
        self.cancel_button.clicked.connect(self.reject)
        self.button_layout.addWidget(self.cancel_button)

    def _onTableJobRowDoubleClicked(self, mi):
        """
        Use the row with that was double clicked to directly select the job
        """
        selected_row = mi.row()
        if (
            self.job_infos[selected_row].finished_at is not None
            and self.job_infos[selected_row].progress == 1
        ):
            self._selected_job_id = self.job_infos[selected_row].job_id
            self.done(1)

    def accept_select(self):
        if self.job_infos:
            self._selected_job_id = None
            # fetch the row from the table
            if self.table_jobs.selectedItems():
                selected_row = self.table_jobs.selectedItems()[0].row()
                if (
                    self.job_infos[selected_row].finished_at is not None
                    and self.job_infos[selected_row].progress == 1
                ):
                    self._selected_job_id = self.job_infos[selected_row].job_id
                    self.done(1)

    def accept_create(self):
        self._is_requesting_matching_job = True
        self.done(1)

    def getResultChosen(self):
        return {
            "selected_job_id": self._selected_job_id,
            "is_requesting_matching_job": self._is_requesting_matching_job,
        }

```

`widgets/SampleInfoWidget.py`:

```py
import helpers.QtShim as QtShim
from widgets.NumberQTableWidgetItem import NumberQTableWidgetItem

QMainWindow = QtShim.get_QMainWindow()


class SampleInfoWidget(QMainWindow):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QMainWindow.__init__(self)
        print("[|] loading SampleInfoWidget")
        # enable access to shared MCRIT4IDA modules
        self.parent = parent
        self.name = "Sample Match Summary"
        self.last_family_selected = None
        self.icon = self.cc.QIcon(self.parent.config.ICON_FILE_PATH + "puzzle.png")
        self.central_widget = self.cc.QWidget()
        self.setCentralWidget(self.central_widget)
        self.cb_filter_library = self.cc.QCheckBox("Filter out Library Matches")
        self.cb_filter_library.setChecked(False)
        self.cb_filter_library.stateChanged.connect(self.populateBestMatchTable)
        # horizontal line
        self.hline = self.cc.QFrame()
        self.hline.setFrameShape(self.cc.QFrameHLine)
        self.hline.setFrameShadow(self.cc.QFrameShadow.Sunken)
        # upper table
        self.label_best_matches = self.cc.QLabel("Best Matches per Family")
        self.table_best_family_matches = self.cc.QTableWidget()
        self.table_best_family_matches.selectionModel().selectionChanged.connect(
            self._onTableBestFamilySelectionChanged
        )
        self.table_best_family_matches.clicked.connect(self._onTableBestFamilyClicked)
        self.table_best_family_matches.doubleClicked.connect(self._onTableBestFamilyDoubleClicked)
        # lower table
        self.label_sample_matches_family = self.cc.QLabel(
            "All Sample Matches within Family: <family_name>"
        )
        self.table_family_sample_matches = self.cc.QTableWidget()
        # static links to objects to help IDA
        self.NumberQTableWidgetItem = NumberQTableWidgetItem
        self._QtShim = QtShim
        self._createGui()

    def _createGui(self):
        """
        Setup function for the full GUI of this widget.
        """
        # layout and fill the widget
        sample_info_layout = self.cc.QVBoxLayout()
        sample_info_layout.addWidget(self.cb_filter_library)
        sample_info_layout.addWidget(self.hline)
        sample_info_layout.addWidget(self.label_best_matches)
        sample_info_layout.addWidget(self.table_best_family_matches)
        sample_info_layout.addWidget(self.label_sample_matches_family)
        sample_info_layout.addWidget(self.table_family_sample_matches)
        self.central_widget.setLayout(sample_info_layout)

    ################################################################################
    # Rendering and state keeping
    ################################################################################

    def update(self):
        self.populateBestMatchTable()
        self.updateFunctionsLabel()

    def _updateLabelBestMatches(self, text):
        self.label_best_matches.setText(text)

    def _updateLabelSampleMatches(self, text):
        self.label_sample_matches_family.setText(text)

    def _aggregatedMatchingData(self):
        """TODO refactor to somewhere else or re-use from mcrit core"""
        match_report = self.parent.getMatchingReport()
        sample_infos = self.parent.getSampleInfos()
        own_sample_num_bytes = match_report["sample_info"]["binweight"]
        function_num_bytes = {}
        matches_per_sample = {}
        for own_function_id, match_data in match_report["pichash"]["pichash_matches"].items():
            function_num_bytes[own_function_id] = match_data["num_bytes"]
            for foreign_sample_id, foreign_matches in match_data["matches"].items():
                foreign_sample_id = int(foreign_sample_id)
                for match in foreign_matches:
                    if foreign_sample_id not in matches_per_sample:
                        matches_per_sample[foreign_sample_id] = {}
                    if own_function_id not in matches_per_sample[foreign_sample_id]:
                        matches_per_sample[foreign_sample_id][own_function_id] = []
                    matches_per_sample[foreign_sample_id][own_function_id].append(
                        ("pichash", match[1])
                    )
                if match_data["has_library_match"]:
                    matches_per_sample[foreign_sample_id][own_function_id].append(("library", 0))
        for own_function_id, match_data in match_report["minhash"]["minhash_matches"].items():
            function_num_bytes[own_function_id] = match_data["num_bytes"]
            for foreign_sample_id, foreign_matches in match_data["matches"].items():
                foreign_sample_id = int(foreign_sample_id)
                for match in foreign_matches:
                    if foreign_sample_id not in matches_per_sample:
                        matches_per_sample[foreign_sample_id] = {}
                    if own_function_id not in matches_per_sample[foreign_sample_id]:
                        matches_per_sample[foreign_sample_id][own_function_id] = []
                    matches_per_sample[foreign_sample_id][own_function_id].append(
                        ("minhash", match[1])
                    )
                if match_data["has_library_match"]:
                    matches_per_sample[foreign_sample_id][own_function_id].append(("library", 0))

        sample_summary = {}
        for foreign_sample_id in matches_per_sample:
            sample_info = sample_infos[int(foreign_sample_id)]
            sample_summary[foreign_sample_id] = {
                "family": sample_info["family"],
                "version": sample_info["version"],
                "sha256": sample_info["sha256"],
                "filename": sample_info["filename"],
                "sample_id": foreign_sample_id,
                "minhash_matches": 0,
                "pichash_matches": 0,
                "combined_matches": 0,
                "library_matches": 0,
                "bytescore": 0,
                "bytescore_adjusted": 0,
                "percent": 0,
                "percent_adjusted": 0,
            }
            for own_function_id, matches in matches_per_sample[foreign_sample_id].items():
                has_library_match = "library" in [match[0] for match in matches]
                sample_summary[foreign_sample_id]["library_matches"] += (
                    1 if has_library_match else 0
                )
                if self.cb_filter_library.isChecked() and has_library_match:
                    continue
                sample_summary[foreign_sample_id]["minhash_matches"] += (
                    1 if "minhash" in [match[0] for match in matches] else 0
                )
                sample_summary[foreign_sample_id]["pichash_matches"] += (
                    1 if "pichash" in [match[0] for match in matches] else 0
                )
                sample_summary[foreign_sample_id]["combined_matches"] += 1
                sample_summary[foreign_sample_id]["bytescore"] += function_num_bytes[
                    own_function_id
                ]
                sample_summary[foreign_sample_id]["bytescore_adjusted"] += (
                    1.0
                    * function_num_bytes[own_function_id]
                    * max([match[1] for match in matches])
                    / 100.0
                )
            sample_summary[foreign_sample_id]["percent"] = (
                100.0 * sample_summary[foreign_sample_id]["bytescore"] / own_sample_num_bytes
            )
            sample_summary[foreign_sample_id]["percent_adjusted"] = (
                100.0
                * sample_summary[foreign_sample_id]["bytescore_adjusted"]
                / own_sample_num_bytes
            )
        return sample_summary

    def populateBestMatchTable(self):
        """
        Populate the function table with information from the last scan of I{SemanticIdentifier}.
        """
        header_view = self._QtShim.get_QHeaderView()
        qt = self._QtShim.get_Qt()

        matching_data = self._aggregatedMatchingData()
        self.table_best_family_matches.setSortingEnabled(False)
        self.best_family_matches_header_labels = [
            "ID",
            "Samples",
            "Family",
            "Version",
            "PicHash",
            "MinHash",
            "Combined",
            "Library",
            "Score",
            "Percent",
        ]
        self.table_best_family_matches.clear()
        self.table_best_family_matches.setColumnCount(len(self.best_family_matches_header_labels))
        self.table_best_family_matches.setHorizontalHeaderLabels(
            self.best_family_matches_header_labels
        )
        # Identify number of table entries and prepare addresses to display
        families_to_samples = {}
        for sample_id, sample_entry in matching_data.items():
            if sample_entry["family"] not in families_to_samples:
                families_to_samples[sample_entry["family"]] = 0
            families_to_samples[sample_entry["family"]] += 1
        self._updateLabelBestMatches("Best Matches per Family (%d)" % len(families_to_samples))
        self.table_best_family_matches.setRowCount(len(families_to_samples))
        self.table_best_family_matches.resizeRowToContents(0)
        row = 0
        families_covered = set([])
        best_family = ""
        for sample_id, sample_entry in sorted(
            matching_data.items(), key=lambda x: x[1]["bytescore"], reverse=True
        ):
            if sample_entry["family"] in families_covered:
                continue
            if not best_family:
                best_family = sample_entry["family"]
            families_covered.add(sample_entry["family"])
            for column, column_name in enumerate(self.best_family_matches_header_labels):
                tmp_item = None
                if column == 0:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_id)
                elif column == 1:
                    tmp_item = self.NumberQTableWidgetItem(
                        "%d" % families_to_samples[sample_entry["family"]]
                    )
                elif column == 2:
                    tmp_item = self.cc.QTableWidgetItem(sample_entry["family"])
                elif column == 3:
                    tmp_item = self.cc.QTableWidgetItem(sample_entry["version"])
                elif column == 4:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["minhash_matches"])
                elif column == 5:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["pichash_matches"])
                elif column == 6:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["combined_matches"])
                elif column == 7:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["library_matches"])
                elif column == 8:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["bytescore"])
                elif column == 9:
                    tmp_item = self.NumberQTableWidgetItem("%5.2f" % sample_entry["percent"])
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                tmp_item.setTextAlignment(qt.AlignHCenter)
                self.table_best_family_matches.setItem(row, column, tmp_item)
            self.table_best_family_matches.resizeRowToContents(row)
            row += 1
        self.table_best_family_matches.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_best_family_matches.resizeColumnsToContents()
        self.table_best_family_matches.setSortingEnabled(True)
        header = self.table_best_family_matches.horizontalHeader()
        for header_id in range(0, len(self.best_family_matches_header_labels), 1):
            try:
                header.setSectionResizeMode(header_id, header_view.Stretch)
            except Exception:
                header.setResizeMode(header_id, header_view.Stretch)
        # propagate family selection to family match table
        selected_family = self.last_family_selected if self.last_family_selected else best_family
        self._updateLabelSampleMatches("All Sample Matches within Family: %s" % selected_family)
        self.populateFamilyMatchTable(selected_family)

    def populateFamilyMatchTable(self, family):
        """
        Populate the function table with information from the last scan of I{SemanticIdentifier}.
        """
        matching_data = self._aggregatedMatchingData()
        self.table_family_sample_matches.setSortingEnabled(False)
        self.family_sample_matches_header_labels = [
            "ID",
            "SHA256",
            "Version",
            "PicHash",
            "MinHash",
            "Combined",
            "Library",
            "Score",
            "Percent",
        ]
        self.table_family_sample_matches.clear()
        self.table_family_sample_matches.setColumnCount(
            len(self.family_sample_matches_header_labels)
        )
        self.table_family_sample_matches.setHorizontalHeaderLabels(
            self.family_sample_matches_header_labels
        )
        # Identify number of table entries and prepare addresses to display
        num_entries = len(
            set([v["sample_id"] for k, v in matching_data.items() if v["family"] == family])
        )
        self._updateLabelSampleMatches(
            'All Sample Matches within Family: "%s" (%d)' % (family, num_entries)
        )
        self.table_family_sample_matches.setRowCount(num_entries)
        self.table_family_sample_matches.resizeRowToContents(0)
        row = 0
        for sample_id, sample_entry in sorted(
            matching_data.items(), key=lambda x: x[1]["bytescore"], reverse=True
        ):
            if sample_entry["family"] != family:
                continue
            for column, column_name in enumerate(self.family_sample_matches_header_labels):
                tmp_item = None
                if column == 0:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_id)
                elif column == 1:
                    tmp_item = self.cc.QTableWidgetItem("%s" % sample_entry["sha256"])
                elif column == 2:
                    tmp_item = self.cc.QTableWidgetItem(sample_entry["version"])
                elif column == 3:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["minhash_matches"])
                elif column == 4:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["pichash_matches"])
                elif column == 5:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["combined_matches"])
                elif column == 6:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["library_matches"])
                elif column == 7:
                    tmp_item = self.NumberQTableWidgetItem("%d" % sample_entry["bytescore"])
                elif column == 8:
                    tmp_item = self.NumberQTableWidgetItem("%5.2f" % sample_entry["percent"])
                tmp_item.setFlags(tmp_item.flags() & ~self.cc.QtCore.Qt.ItemIsEditable)
                self.table_family_sample_matches.setItem(row, column, tmp_item)
            self.table_family_sample_matches.resizeRowToContents(row)
            row += 1
        self.table_family_sample_matches.setSelectionMode(self.cc.QAbstractItemView.SingleSelection)
        self.table_family_sample_matches.resizeColumnsToContents()
        self.table_family_sample_matches.setSortingEnabled(True)
        header_view = self._QtShim.get_QHeaderView()
        header = self.table_family_sample_matches.horizontalHeader()
        for header_id in range(0, len(self.family_sample_matches_header_labels), 1):
            try:
                header.setSectionResizeMode(header_id, header_view.Stretch)
            except Exception:
                header.setResizeMode(header_id, header_view.Stretch)

    ################################################################################
    # Buttons and Actions
    ################################################################################

    def _onTableBestFamilySelectionChanged(self, selected, deselected):
        selected_row = self.table_best_family_matches.selectedItems()[0].row()
        family = self.table_best_family_matches.item(selected_row, 2).text()
        self.last_family_selected = family
        self.populateFamilyMatchTable(family)

    def _onTableBestFamilyClicked(self, mi):
        """
        If a row in the best family match table is clicked, adjust the family sample match table
        """
        family = self.table_best_family_matches.item(mi.row(), 2).text()
        self.last_family_selected = family
        self.populateFamilyMatchTable(family)

    def _onTableBestFamilyDoubleClicked(self, mi):
        """
        TODO: open a popup with the detailed sample info
        """
        pass

```

`widgets/SmdaGraphViewer.py`:

```py
# -----------------------------------------------------------------------
# This is an example illustrating how to use the user graphing functionality
# in Python
# (c) Hex-Rays
# adopted for rendering GraphDiffing in MCRIT

import ida_kernwin
import idaapi
from smda.common.SmdaFunction import SmdaFunction
from smda.common.SmdaReport import SmdaReport


class GraphCloser(ida_kernwin.action_handler_t):
    def __init__(self, graph):
        super().__init__()
        self.graph = graph

    def activate(self, ctx):
        self.graph.Close()
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS


class SmdaGraphViewer(idaapi.GraphViewer):
    def __init__(self, parent, sample_entry, function_entry, smda_function: SmdaFunction, coloring):
        self.title = "No Function"
        if smda_function is not None:
            self.title = f"CFG for sample {sample_entry.sample_id} ({sample_entry.family}); function: {function_entry.function_id}@0x{smda_function.offset:x}"
        idaapi.GraphViewer.__init__(self, self.title)
        self.parent = parent
        self.name = "SmdaGraphViewer"
        self.smda_function = smda_function
        self._offset_to_node_id = {}
        self._node_id_to_offset = {}
        self._offset_to_color = coloring
        self._close_action_name = None

    def draw(self):
        if self.smda_function is None:
            return
        self._offset_to_node_id = {}
        for block in self.smda_function.getBlocks():
            node_id = self.AddNode(block.offset)
            self._offset_to_node_id[block.offset] = node_id
            self._node_id_to_offset[node_id] = block.offset
            self.OnGetText(node_id)
        for src, dests in self.smda_function.blockrefs.items():
            for dest in dests:
                src_id = self._offset_to_node_id[src]
                dest_id = self._offset_to_node_id[dest]
                self.AddEdge(src_id, dest_id)

    def OnRefresh(self):
        self.Clear()
        self._offset_to_node_id = {}
        self._node_id_to_offset = {}
        self.draw()
        return True

    def OnGetText(self, node_id):
        """Render a rendered BB as single, multi-line string"""
        # TODO: if there is EVER a way to influence color of text in GraphViewer, use it to increase contrast...
        if self.smda_function is None:
            return
        block_offset = self._node_id_to_offset[node_id]
        rendered_ins = []
        if block_offset in self.smda_function.blocks:
            for smda_ins in self.smda_function.blocks[block_offset]:
                printable_api = ""
                apiref_str = self.smda_function.apirefs.get(smda_ins.offset, "")
                if apiref_str:
                    printable_api = f"[{apiref_str}]"
                if printable_api:
                    rendered_ins.append(f"{smda_ins.offset:x}: {smda_ins.mnemonic} {printable_api}")
                else:
                    rendered_ins.append(
                        f"{smda_ins.offset:x}: {smda_ins.mnemonic} {smda_ins.operands}"
                    )
        if self._node_id_to_offset[node_id] in self._offset_to_color:
            # IDA uses BBGGRR instead of RRGGBB
            remapped_color = (
                (self._offset_to_color[self._node_id_to_offset[node_id]] // (256 * 256))
                + (self._offset_to_color[self._node_id_to_offset[node_id]] & 0x00FF00)
                + ((self._offset_to_color[self._node_id_to_offset[node_id]] & 0x0000FF) * 256 * 256)
            )
            return ("\n".join(rendered_ins), remapped_color)
        else:
            return "\n".join(rendered_ins)

    def OnHint(self, node_id):
        if self.smda_function is None:
            return
        # TODO use this properly
        return "0x%x %s" % (self._node_id_to_offset[node_id], "some text")

    def Show(self):
        if not idaapi.GraphViewer.Show(self):
            return False
        self._close_action_name = "graph_closer:%d" % id(self)
        try:
            ida_kernwin.register_action(
                ida_kernwin.action_desc_t(
                    self._close_action_name,
                    "Close %s" % self.title,
                    GraphCloser(self),
                )
            )
            ida_kernwin.attach_action_to_popup(
                self.GetTCustomControl(),
                None,
                self._close_action_name,
            )
        except Exception as e:
            print("Failed to register action: %s" % str(e))
            self._close_action_name = None
        return True

    def OnClose(self):
        if self._close_action_name:
            ida_kernwin.unregister_action(self._close_action_name)
            self._close_action_name = None
        return True


def show_example():
    smda_report = SmdaReport.fromFile(
        "0e967868c1f693097857d6d1069a3efca1e50f4516bb2637a10761d9bf4992ff_unpacked.smda"
    )
    g = SmdaGraphViewer(smda_report.getFunction(0x40D77A))
    if g.Show():
        return g
    else:
        return None


if __name__ == "__main__":
    g = show_example()
    if g:
        print("Graph created and displayed!")

```

`widgets/SmdaInfoDialog.py`:

```py
import helpers.QtShim as QtShim

QDialog = QtShim.get_QDialog()


class SmdaInfoDialog(QDialog):
    def __init__(self, parent):
        self.cc = parent.cc
        self.cc.QDialog.__init__(self, parent)
        self.parent = parent
        self._sample_family = ""
        self._sample_version = ""
        self._sample_is_library = False
        # if we already have a report, use the same meta data information to prefill fields
        if parent.parent.local_smda_report is not None:
            self._sample_family = parent.parent.local_smda_report.family
            self._sample_version = parent.parent.local_smda_report.version
            self._sample_is_library = parent.parent.local_smda_report.is_library
        # create GUI elements
        self._createInputWidget()
        self._createButtons()
        # glue everything together
        dialog_layout = self.cc.QVBoxLayout()
        dialog_layout.addWidget(self.input_widget)
        dialog_layout.addLayout(self.button_layout)
        self.setLayout(dialog_layout)
        self.setWindowTitle(self.tr("Provide additional information about the sample"))

    def _createInputWidget(self):
        self.input_widget = self.cc.QWidget()
        # the respective fields
        self.label_family = self.cc.QLabel("Family:")
        self.old_family_chooser_text = ""
        self.edit_family = None
        self._createFamilyChooserLineedit()
        self.label_version = self.cc.QLabel("Version:")
        self.edit_version = self.cc.QLineEdit(self._sample_version)
        self._cb_is_library = self.cc.QCheckBox("Sample is a library?")
        self._cb_is_library.setChecked(self._sample_is_library)
        # arrange in layout
        grid_layout = self.cc.QGridLayout()
        grid_layout.addWidget(self.label_family, 0, 0)
        grid_layout.addWidget(self.edit_family, 0, 1)
        grid_layout.addWidget(self.label_version, 1, 0)
        grid_layout.addWidget(self.edit_version, 1, 1)
        grid_layout.addWidget(self._cb_is_library, 2, 0, 1, 2)
        self.input_widget.setLayout(grid_layout)

    def _createButtons(self):
        self.button_layout = self.cc.QHBoxLayout()
        self.ok_button = self.cc.QPushButton(self.tr("OK"))
        self.cancel_button = self.cc.QPushButton(self.tr("Cancel"))
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        self.button_layout.addStretch(1)
        self.button_layout.addWidget(self.ok_button)
        self.button_layout.addWidget(self.cancel_button)

    def accept(self):
        # display mode
        self._sample_family = self.edit_family.text()
        self._sample_version = self.edit_version.text()
        self._sample_is_library = self._cb_is_library.isChecked()
        self.done(1)

    def getSmdaInfo(self):
        return {
            "family": self._sample_family,
            "version": self._sample_version,
            "is_library": self._sample_is_library,
        }

    def _createFamilyChooserLineedit(self):
        """
        Create the I{QLineEdit }used for selecting family names. This includes a QCompleter to make suggestions based on
        the keyword database.
        """
        self.edit_family = self.cc.QLineEdit(self._sample_family)
        self.edit_family.textChanged.connect(self._updateCompleterModel)

        completer = self.cc.QCompleter()
        completer.setCaseSensitivity(self.cc.QtCore.Qt.CaseInsensitive)
        completer.setFilterMode(self.cc.QtCore.Qt.MatchContains)
        completer.setModelSorting(self.cc.QCompleter.UnsortedModel)
        self.completer_model = self.cc.QStringListModel([])
        completer.setModel(self.completer_model)
        self.edit_family.setCompleter(completer)

    def _updateCompleterModel(self):
        """
        Update the completer model used to make suggestions. The model is only updated if anything is entered into the
        search line and the initial character differs from the previous initial character.
        """
        keyword_data = []
        family_chooser_text = self.edit_family.text()
        if self.parent.parent.family_infos and len(family_chooser_text) > 0:
            if family_chooser_text != self.old_family_chooser_text:
                self.old_family_chooser_text = family_chooser_text
                keyword_data = sorted(
                    [
                        family_entry.family_name.lower()
                        for family_entry in self.parent.parent.family_infos.values()
                        if family_chooser_text.lower() in family_entry.family_name.lower()
                    ]
                )
                self.completer_model.setStringList(keyword_data)

```

`widgets/YaraStringBuilderDialog.py`:

```py
import datetime

import helpers.pyperclip as pyperclip
import helpers.QtShim as QtShim

QDialog = QtShim.get_QDialog()


class YaraStringBuilderDialog(QDialog):
    def __init__(
        self,
        parent,
        data=None,
        selection_sequence=None,
        block_sequence=None,
        function_sequence=None,
        sha256="",
        offset=0,
        selection_start=0,
        selection_end=0,
    ):
        self.cc = parent.cc
        self.cc.QDialog.__init__(self, parent)
        self.parent = parent

        # Store instruction sequences and escaped bytes
        self.data = data or b""
        self.selection_sequence = selection_sequence or []
        self.block_sequence = block_sequence or []
        self.function_sequence = function_sequence or []

        # Context information
        self.sha256 = sha256
        self.offset = offset
        self.selection_start = selection_start
        self.selection_end = selection_end

        # Determine if we're in data mode (no block or function available)
        self.is_data_mode = (
            data is not None and block_sequence is None and function_sequence is None
        )

        # Current selection for rule generation
        self.current_scope = "selection"
        self.use_wildcards = True

        # Create GUI elements
        self._createInputWidget()
        self._createButtons()

        # Layout
        dialog_layout = self.cc.QVBoxLayout()
        dialog_layout.addWidget(self.input_widget)
        dialog_layout.addLayout(self.button_layout)
        self.setLayout(dialog_layout)

        self.setWindowTitle(self.tr("YARA String Builder"))
        self.resize(800, 600)

        # Initial rule generation
        self._updateYaraRule()

    def _createInputWidget(self):
        self.input_widget = self.cc.QWidget()

        # Scope selection radio buttons
        self.label_scope = self.cc.QLabel("Scope:")
        self.radio_selection = self.cc.QRadioButton("Selection")
        self.radio_block = self.cc.QRadioButton("Current Block")
        self.radio_function = self.cc.QRadioButton("Current Function")

        # Set default selection
        self.radio_selection.setChecked(True)

        # Disable options in data mode or if sequences are empty
        if self.is_data_mode or not self.block_sequence:
            self.radio_block.setEnabled(False)
        if self.is_data_mode or not self.function_sequence:
            self.radio_function.setEnabled(False)
        if not self.selection_sequence:
            self.radio_selection.setEnabled(False)
            # Default to first available option
            if self.block_sequence:
                self.radio_block.setChecked(True)
                self.current_scope = "block"
            elif self.function_sequence:
                self.radio_function.setChecked(True)
                self.current_scope = "function"

        # Connect radio button signals
        self.radio_selection.toggled.connect(self._onScopeChanged)
        self.radio_block.toggled.connect(self._onScopeChanged)
        self.radio_function.toggled.connect(self._onScopeChanged)

        # Wildcards checkbox
        self.cb_wildcards = self.cc.QCheckBox("Use wildcards (show escaped version)")
        self.cb_wildcards.setChecked(self.use_wildcards)
        self.cb_wildcards.stateChanged.connect(self._onWildcardsChanged)

        # Disable wildcards in data mode
        if self.is_data_mode:
            self.cb_wildcards.setEnabled(False)

        # YARA rule text area
        self.label_yara = self.cc.QLabel("Generated YARA Rule:")
        self.text_yara = self.cc.QTextEdit()
        self.text_yara.setFont(self.cc.QFont("Courier", 9))
        self.text_yara.setReadOnly(True)

        # Layout
        grid_layout = self.cc.QGridLayout()
        grid_layout.addWidget(self.label_scope, 0, 0)
        grid_layout.addWidget(self.radio_selection, 0, 1)
        grid_layout.addWidget(self.radio_block, 0, 2)
        grid_layout.addWidget(self.radio_function, 0, 3)
        grid_layout.addWidget(self.cb_wildcards, 1, 0, 1, 4)
        grid_layout.addWidget(self.label_yara, 2, 0, 1, 4)
        grid_layout.addWidget(self.text_yara, 3, 0, 1, 4)

        self.input_widget.setLayout(grid_layout)

    def _createButtons(self):
        self.button_layout = self.cc.QHBoxLayout()

        # Copy buttons
        self.copy_escaped_button = self.cc.QPushButton(self.tr("Copy Escaped Bytes"))
        self.copy_yara_button = self.cc.QPushButton(self.tr("Copy YARA Rule"))
        self.ok_button = self.cc.QPushButton(self.tr("OK"))

        # Connect signals
        self.copy_escaped_button.clicked.connect(self._onCopyEscapedClicked)
        self.copy_yara_button.clicked.connect(self._onCopyYaraClicked)
        self.ok_button.clicked.connect(self.accept)

        # Layout
        self.button_layout.addWidget(self.copy_escaped_button)
        self.button_layout.addWidget(self.copy_yara_button)
        self.button_layout.addStretch(1)
        self.button_layout.addWidget(self.ok_button)

    def _onScopeChanged(self):
        """Handle scope radio button changes"""
        if self.radio_selection.isChecked():
            self.current_scope = "selection"
        elif self.radio_block.isChecked():
            self.current_scope = "block"
        elif self.radio_function.isChecked():
            self.current_scope = "function"
        self._updateYaraRule()

    def _onWildcardsChanged(self):
        """Handle wildcards checkbox change"""
        self.use_wildcards = self.cb_wildcards.isChecked()
        self._updateYaraRule()

    def _getCurrentSequenceInstructions(self):
        """Get current instruction sequence and escaped bytes based on scope"""
        if self.current_scope == "selection":
            return self.selection_sequence or []
        elif self.current_scope == "block":
            return self.block_sequence or []
        elif self.current_scope == "function":
            return self.function_sequence or []
        return []

    def _escapeInstruction(self, instruction):
        """Escape an instruction for YARA rule"""
        if not instruction:
            return b""
        # Escape the instruction bytes
        # Use escaped version with wildcards, annotated with disassembly
        from smda.common.BinaryInfo import BinaryInfo
        from smda.intel.IntelInstructionEscaper import IntelInstructionEscaper

        binary_info = BinaryInfo(b"")
        binary_info.architecture = self.parent.parent.local_smda_report.architecture
        binary_info.base_addr = self.parent.parent.local_smda_report.base_addr
        binary_info.binary_size = self.parent.parent.local_smda_report.binary_size
        escaped_bytes = instruction.getEscapedBinary(
            IntelInstructionEscaper,
            escape_intraprocedural_jumps=True,
            lower_addr=binary_info.base_addr,
            upper_addr=binary_info.base_addr + binary_info.binary_size,
        )
        return escaped_bytes

    def _formatHexBytes(self, instructions):
        """Format bytes as hex string for YARA rule"""
        if not instructions:
            return ""

        hex_string = ""
        hex_lines = []

        if self.use_wildcards:
            for instruction in instructions:
                try:
                    escaped_bytes = self._escapeInstruction(instruction)
                    # Convert escaped string to hex format
                    hex_bytes = "".join(escaped_bytes)
                    disasm = (
                        f"{instruction.mnemonic} {instruction.operands}"
                        if hasattr(instruction, "operands") and instruction.operands
                        else instruction.mnemonic
                    )
                    hex_lines.append((hex_bytes, f"0x{instruction.offset:08X}: {disasm}"))
                except Exception:
                    # Fallback to raw bytes if escaping fails
                    hex_bytes = instruction.bytes
                    disasm = (
                        f"{instruction.mnemonic} {instruction.operands}"
                        if hasattr(instruction, "operands") and instruction.operands
                        else instruction.mnemonic
                    )
                    hex_lines.append((hex_bytes, f"0x{instruction.offset:08X}: {disasm}"))
        else:
            # Use raw bytes without wildcards
            for instruction in instructions:
                hex_bytes = instruction.bytes
                disasm = (
                    f"{instruction.mnemonic} {instruction.operands}"
                    if hasattr(instruction, "operands") and instruction.operands
                    else instruction.mnemonic
                )
                hex_lines.append((hex_bytes, f"0x{instruction.offset:08X}: {disasm}"))

        # Find the longest hex string to align comments
        if hex_lines:
            max_hex_length = max(len(hex_bytes) for hex_bytes, _ in hex_lines)

            # Format each line with proper alignment
            for hex_bytes, comment in hex_lines:
                if comment:
                    padding = " " * (max_hex_length - len(hex_bytes))
                    hex_string += f"          {hex_bytes}{padding} // {comment}\n"
                else:
                    hex_string += f"          {hex_bytes}\n"

        return hex_string

    def _updateYaraRule(self):
        """Update the YARA rule text area"""
        instructions = self._getCurrentSequenceInstructions()

        if not instructions and not self.is_data_mode:
            self.text_yara.setText("No data available for selected scope.")
            return

        # Determine rule details
        scope_name = self.current_scope
        scope_offset = self.offset

        if self.current_scope == "selection" and self.selection_start != self.selection_end:
            scope_offset = self.selection_start
        elif instructions and len(instructions) > 0:
            scope_offset = instructions[0].offset

        # Generate rule name
        rule_name = f"{self.sha256[:8]}_0x{scope_offset:08X}"

        # Generate current date
        current_date = datetime.datetime.now().strftime("%Y-%m-%d")

        # Format hex bytes
        hex_content = ""
        if self.is_data_mode:
            hex_bytes = " ".join([f"{byte:02X}" for byte in self.data])
            # Format into lines of 16 bytes each
            hex_lines = [hex_bytes[i : i + 47] for i in range(0, len(hex_bytes), 48)]
            for line in hex_lines:
                hex_content += f"          {line}\n"
        else:
            hex_content = self._formatHexBytes(instructions)

        # Generate YARA rule
        yara_rule = f"""rule {rule_name} {{
    meta:
      date = "{current_date}"
      info = "Rule fragment created from {scope_name} found at offset 0x{scope_offset:08X} in file {self.sha256}."
    strings:
      $_0x{scope_offset:08X} = {{
{hex_content}      }}
    condition:
      any of them
}}"""

        self.text_yara.setText(yara_rule)

    def _onCopyEscapedClicked(self):
        """Copy escaped bytes to clipboard"""
        instructions = self._getCurrentSequenceInstructions()
        if self.is_data_mode:
            hex_string = self.data.hex()
        else:
            if self.use_wildcards:
                hex_string = " ".join(
                    [
                        "".join([self._escapeInstruction(instruction)])
                        for instruction in instructions
                    ]
                )
            else:
                hex_string = " ".join([instruction.bytes for instruction in instructions])
        pyperclip.copy(hex_string)
        self.parent.parent.local_widget.updateActivityInfo(
            f"Copied escaped bytes to clipboard: {len(hex_string)} bytes"
        )

    def _onCopyYaraClicked(self):
        """Copy YARA rule to clipboard"""
        yara_rule = self.text_yara.toPlainText()
        if yara_rule:
            pyperclip.copy(yara_rule)
            self.parent.parent.local_widget.updateActivityInfo("YARA rule copied to clipboard")

```