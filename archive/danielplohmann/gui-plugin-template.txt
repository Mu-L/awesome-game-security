Project Path: arc_danielplohmann_gui-plugin-template_g7u2riis

Source Tree:

```txt
arc_danielplohmann_gui-plugin-template_g7u2riis
├── LICENSE
├── README.md
└── template_plugin
    ├── PluginCutter.py
    ├── PluginGhidra.py
    ├── PluginIda.py
    ├── __init__.py
    ├── plugin
    │   ├── __init__.py
    │   ├── apis
    │   │   ├── ApiProxy.py
    │   │   ├── BinaryNinjaApi.py
    │   │   ├── CutterApi.py
    │   │   ├── GhidraApi.py
    │   │   ├── IdaApi.py
    │   │   └── __init__.py
    │   └── gui
    │       ├── PluginGui.py
    │       └── __init__.py
    └── plugin.json

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Daniel Plohmann

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


ORIGINAL LICENSE FOR HYARA:

MIT License

Copyright (c) 2021 Hyun Yi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# Binary Analysis Tools Plugin Template

The goal of this template is to provide means for creating GUI plugins compatible with multiple binary analysis tools at once (IDA, Ghidra, Binary Ninja, Cutter) in a convenient fashion.  

It is largely based on the code found in [hyara](https://github.com/hyuunnn/Hyara), which best to our knowledge was the first tool/plugin to achieve such cross-compatibility.  
Therefore, full credit and many thanks to its author [@hyuunnn](https://github.com/hyuunnn) for figuring out many of the irks related to such an endeavor.

## Approach

Common denominator for all platforms is availability of Python and PyQt / PySide in one way or another. 
This allows by separation of concerns to design GUIs that are independent from the concrete binary analysis tools.
"Only" their respective APIs are specific and need to be asbtracted through a common harmonized interface (found in `plugins/apis/`).

Right now the API encapsulation is in an infant state sufficient for demonstration and it will be expanded in future work as we port our own plugins to use this structure.

## Installation and Usage

### IDA Pro

To install as a plugin, copy `PluginIda.py` and folder `plugin` from `template_plugin` to `idapro-x.x/plugins` and simply run from `Edit/Plugins/` or via the assigned hotkey.

To run as a script, simply execute the `PluginIda.py`.

### Ghidra

After installing [Ghidraton 4.0](https://github.com/mandiant/Ghidrathon/releases/tag/v4.0.0) and opening its window in Ghidra, we need to manually add our plugin directory to Python's path and then run the plugin:

```
>>> import sys
>>> sys.path.append('/path/to/plugin-template/template_plugin')
>>> import PluginGhidra
>>> PluginGhidra.run()
```

Alternatively, we can also use the Script Manager, if we drop `PluginGhidra.py` and the `plugin` folder into the `Extensions/Ghidraton/ghidra_scripts/` folder (e.g. on Linux found in `~/.ghidra`).

### BinaryNinja

Install as a regular plugin by dropping the full `template_plugin` folder into Binary Ninja [plugins dir](https://github.com/Vector35/binaryninja-api/tree/dev/python/examples#loading-plugins), afterwards run as View/Other Docks/...

### Cutter

TBD.

### Version

* 2024-03-07 v1.1 -  Adapted [MalpediaFlossed](https://github.com/malpedia/malpedia-flossed/tree/main/plugins/) plugin as demonstration, added Strings() to APIs.
* 2024-02-26 v1.0 - Initial release
```

`template_plugin/PluginCutter.py`:

```py
from apis.CutterApi import CutterApi
from gui.PluginGui import PluginGui

import PySide2.QtWidgets as QtWidgets
import cutter


class PluginWidget(cutter.CutterDockWidget):
    def __init__(self, parent):
        super(PluginWidget, self).__init__(parent)
        self.main = parent
        self.setObjectName("TODO_PLUGIN_NAME")
        self.setWindowTitle("TODO_PLUGIN_NAME")

        self.api_proxy = CutterApi()
        self.plugin_gui = PluginGui(self.api_proxy)
        content = QtWidgets.QWidget()
        self.setWidget(content)
        content.setLayout(self.plugin_gui.layout)


class HyaraPlugin(cutter.CutterPlugin):
    name = "TODO_PLUGIN_NAME"
    description = "TODO_PLUGIN_DESCRIPTION"
    version = "TODO_PLUGIN_VERSION"
    author = "TODO_AUTHOR"
    plugin_widget = None

    def setupPlugin(self):
        pass

    def nop(self):
        return

    def setupActions(self):
        self.dummyAction = QtWidgets.QAction("Dummy Action")

        # context menu extensions / actions need to be registered here
        menu = self.plugin_widget.main.getContextMenuExtensions(
            cutter.MainWindow.ContextMenuType.Disassembly
        )
        menu.addSeparator()
        menu.addAction(self.dummyAction)
        self.startAddrAction.triggered.connect(self.nop)

    def setupInterface(self, main):
        self.plugin_widget = PluginWidget(main)
        self.setupActions()
        main.addPluginDockWidget(self.plugin_widget)

    def terminate(self):
        pass

```

`template_plugin/PluginGhidra.py`:

```py
# TODO_PLUGIN_DESCRIPTION
# @author TODO_AUTHOR
# @category Python 3
from plugin.apis.GhidraApi import GhidraApi
from plugin.gui.PluginGui import PluginGui

import sys
try:
    import PySide2.QtWidgets as QtWidgets
except:
    import PySide6.QtWidgets as QtWidgets

class PluginWidget(QtWidgets.QWidget):
    def __init__(self):
        QtWidgets.QWidget.__init__(self)

        self.api_proxy = GhidraApi()
        self.plugin_gui = PluginGui(self.api_proxy)
        self.setLayout(self.plugin_gui.layout)

def run():
    if not QtWidgets.QApplication.instance():
        app = QtWidgets.QApplication(sys.argv)
    else:
        app = QtWidgets.QApplication.instance()

    window = PluginWidget()
    window.show()
    app.exec()

if __name__ == "__main__":
    run()

```

`template_plugin/PluginIda.py`:

```py
from plugin.apis.IdaApi import IdaApi
from plugin.gui.PluginGui import PluginGui

import idaapi
import ida_nalt
import ida_kernwin


class Plugin_action_handler_t(idaapi.action_handler_t):
    def __init__(self, dummy_arg):
        idaapi.action_handler_t.__init__(self)
        return

    def activate(self, ctx):
        # some action
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class Hooks(ida_kernwin.UI_Hooks):
    def __init__(self):
        ida_kernwin.UI_Hooks.__init__(self)

    def finish_populating_widget_popup(self, widget, popup):
        ida_kernwin.attach_action_to_popup(widget, popup, "TODO_IDA_ACTION_NAME", None)


class PluginWidget(ida_kernwin.PluginForm):

    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)
        self.api_proxy = IdaApi()
        self.plugin_gui = PluginGui(self.api_proxy)
        self.parent.setLayout(self.plugin_gui.layout)

        # context menu extensions / actions need to be registered here
        idaapi.register_action(
            ida_kernwin.action_desc_t(
                "TODO_IDA_ACTION_NAME",
                "TODO_ACTION_DESCRIPTION",
                Plugin_action_handler_t("DummyArg"),
                "Ctrl+Shift+S",
                "TODO_ACTION_DESCRIPTION",
            )
        ),

    def OnClose(self, form):
        idaapi.unregister_action("TODO_IDA_ACTION_NAME")
        hooks.unhook()

    def Show(self):
        if ida_nalt.retrieve_input_file_md5() is not None:
            return ida_kernwin.PluginForm.Show(self, "TODO_PLUGIN_NAME", options=(ida_kernwin.PluginForm.WCLS_CLOSE_LATER | ida_kernwin.PluginForm.WOPN_RESTORE | ida_kernwin.PluginForm.WCLS_SAVE))
        return None


class TemplatePlugin(idaapi.plugin_t):
    # https://www.hex-rays.com/products/ida/support/sdkdoc/group___p_l_u_g_i_n__.html
    flags = idaapi.PLUGIN_UNL
    comment = "TODO_PLUGIN_DESCRIPTION"
    help = "help"
    wanted_name = "TODO_PLUGIN_NAME"
    wanted_hotkey = "Ctrl+Shift+Y"

    def init(self):
        global hooks
        hooks = Hooks()
        hooks.hook()
        return idaapi.PLUGIN_OK

    def run(self, arg):
        plg = PluginWidget()
        plg.Show("TODO_PLUGIN_NAME")

        try:
            widget_a = ida_kernwin.find_widget("IDA View-A")
            widget_template_plugin = ida_kernwin.find_widget("TODO_PLUGIN_NAME")
            if widget_template_plugin and widget_a:
                ida_kernwin.set_dock_pos("TODO_PLUGIN_NAME", "IDA View-A", ida_kernwin.DP_RIGHT)
        except:
            print("find_widget option is available version 7.0 or later")

    def term(self):
        pass


def PLUGIN_ENTRY():
    return TemplatePlugin()


def main():
    global TEMPLATE_WIDGET
    try:
        # TODO figure out why we can't reopen our form when it was closed once
        TEMPLATE_WIDGET = PluginWidget()
    except Exception:
        import traceback
        traceback.print_exc()
        TEMPLATE_WIDGET = PluginWidget()

    TEMPLATE_WIDGET.Show()


if __name__ == "__main__":
    main()


```

`template_plugin/__init__.py`:

```py
IS_BINJA_ENV = False
try:
    from binaryninjaui import DockHandler, DockContextHandler, UIActionHandler
    IS_BINJA_ENV = True
except:
    pass

if IS_BINJA_ENV:
    # TODO adjust this to your plugin name
    from template_plugin.plugin.apis.BinaryNinjaApi import BinaryNinjaApi
    from template_plugin.plugin.gui.PluginGui import PluginGui

    from binaryninjaui import DockHandler, DockContextHandler, UIActionHandler
    import PySide6.QtWidgets as QtWidgets
    from PySide6.QtCore import Qt


class PluginDockWidget(QtWidgets.QWidget, DockContextHandler):
    def __init__(self, parent, name, data):
        QtWidgets.QWidget.__init__(self, parent)
        DockContextHandler.__init__(self, self, name)

        self.actionHandler = UIActionHandler()
        self.actionHandler.setupActionHandler(self)

        self.api_proxy = BinaryNinjaApi()
        self.plugin_gui = PluginGui(self.api_proxy)

        self.setLayout(self.plugin_gui.layout)

    def shouldBeVisible(self, view_frame):
        if view_frame is None:
            return False
        else:
            return True

    def notifyViewChanged(self, view_frame):
        pass

    @staticmethod
    def create_widget(name, parent, data=None):
        return PluginDockWidget(parent, name, data)


if IS_BINJA_ENV:
    dock_handler = DockHandler.getActiveDockHandler()
    dock_handler.addDockWidget(
        "TODO_PLUGIN_NAME",
        PluginDockWidget.create_widget,
        Qt.RightDockWidgetArea,
        Qt.Horizontal,
        False,
    )

```

`template_plugin/plugin.json`:

```json
{
    "pluginmetadataversion": 2,
    "name": "TODO_PLUGIN_NAME",
    "type": [
        "ui"
    ],
    "api": [
        "python3"
    ],
    "description": "TODO_PLUGIN_DESCRIPTION",
    "license": {
        "name": "MIT",
        "text": "Copyright (c) TODO_YEAR TODO_AUTHOR\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    "platforms": [
        "Darwin",
        "Linux",
        "Windows"
    ],
    "installinstructions": {
        "Darwin": "",
        "Linux": "",
        "Windows": ""
    },
    "dependencies": {
    },
    "version": "TODO_PLUGIN_VERSION",
    "author": "TODO_AUTHOR",
    "minimumbinaryninjaversion": 3469
}

```

`template_plugin/plugin/apis/ApiProxy.py`:

```py
class ApiProxy(object):
    
    def __init__(self):
        pass

    def get_filepath(self) -> str:
        """ return the filepath of the input binary """
        raise NotImplementedError

    def get_md5(self) -> str:
        """ return the hexdigest of the MD5 of the input binary """
        raise NotImplementedError

    def jump_to(self, addr) -> None:
        """ Set view to the given address """
        raise NotImplementedError

    def Strings(self):
        """ 
        Return the list of identified strings, each being a tuple with entries:
        (addr, string_type, string)
        e.g.
        (0x1000, "UTF8", "a_string")
        """
        raise NotImplementedError
```

`template_plugin/plugin/apis/BinaryNinjaApi.py`:

```py
import binascii

from binaryninjaui import DockHandler
from binaryninja.transform import Transform

from .ApiProxy import ApiProxy


# https://github.com/gaasedelen/lighthouse/blob/master/plugins/lighthouse/util/disassembler/binja_api.py#L181
def binja_get_bv_from_dock():
    dh = DockHandler.getActiveDockHandler()
    if not dh:
        return None
    vf = dh.getViewFrame()
    if not vf:
        return None
    vi = vf.getCurrentViewInterface()
    bv = vi.getData()
    return bv


class BinaryNinjaApi(ApiProxy):
    def __init__(self):
        super(BinaryNinjaApi, self).__init__()

    @property
    def bv(self):
        return binja_get_bv_from_dock()

    def get_filepath(self) -> str:
        return self.bv.file.original_filename

    def get_md5(self) -> str:
        bv = self.bv
        return Transform["RawHex"].encode(
            Transform["MD5"].encode(bv.file.raw.read(0, len(bv.file.raw)))
        ).decode()

    def jump_to(self, addr):
        bv = self.bv
        bv.navigate(bv.view, addr)

    def Strings(self):
        bv = self.bv
        # TODO could be harmonized across all APIs
        strtype_map = {
            0: "C",
            1: "UTF16",
            2: "UTF32",
            3: "UTF8"
        }
        reformatted_strings = []
        for item in bv.get_strings():
            reformatted_tuple = (item.start, strtype_map.get(item.type, "unknown"), item.value)
            reformatted_strings.append(reformatted_tuple)
        return reformatted_strings

```

`template_plugin/plugin/apis/CutterApi.py`:

```py
import hashlib
import base64

import cutter

from apis.ApiProxy import ApiProxy


class CutterApi(ApiProxy):
    def __init__(self):
        super(CutterApi, self).__init__()

    def get_filepath(self) -> str:
        return cutter.cmdj("ij")['core']['file']

    def get_md5(self) -> str:
        return cutter.cmdj("itj").get("md5", None)

    def jump_to(self, addr):
        return cutter.cmd(f"s {addr}")

```

`template_plugin/plugin/apis/GhidraApi.py`:

```py
import binascii
import hashlib

import java.io

from .ApiProxy import ApiProxy


from ghidra.program.util import DefinedDataIterator
from ghidra.util import MD5Utilities

class GhidraApi(ApiProxy):
    def __init__(self):
        super(GhidraApi, self).__init__()

    def get_filepath(self) -> str:
        filepath = getState().getCurrentProgram().getExecutablePath()
        return filepath[1:]

    def get_md5(self) -> str:
        return MD5Utilities.getMD5Hash(java.io.File(self.get_filepath()))

    def jump_to(self, addr):
        goTo(toAddr(addr))

    def Strings(self):
        # TODO I don't know how to Ghidra with strings :D
        strtype_map = {
            "char": "ascii",
            "ds": "ascii",
            "unicode": "UTF16"
        }
        reformatted_strings = []
        # https://reverseengineering.stackexchange.com/a/26417
        for string in DefinedDataIterator.definedStrings(currentProgram()):
            string_offset = int(str(string.getMinAddress()), 16)
            string_type = str(string.getDataType()).split("[")[0]
            reformatted_tuple = (string_offset, strtype_map.get(string_type, "unknown"), string.getValue())
            print(reformatted_tuple)
            reformatted_strings.append(reformatted_tuple)
        return reformatted_strings

```

`template_plugin/plugin/apis/IdaApi.py`:

```py
import idc
import idautils
import ida_nalt

from .ApiProxy import ApiProxy

class IdaApi(ApiProxy):
    
    def __init__(self):
        pass

    def get_filepath(self) -> str:
        return ida_nalt.get_input_file_path()

    def get_md5(self) -> str:
        return idautils.GetInputFileMD5().hex()

    def jump_to(self, addr):
        idc.jumpto(addr)

    def Strings(self):
        # TODO there are some more types, add PASCAL-type strings
        strtype_map = {
            0: "C",
            1: "C32",
            2: "C16",
            33554433: "UTF16LE"
        }
        reformatted_strings = []
        for item in idautils.Strings():
            reformatted_tuple = (item.ea, strtype_map.get(item.strtype, "unknown"), str(item))
            reformatted_strings.append(reformatted_tuple)
        return reformatted_strings

```

`template_plugin/plugin/gui/PluginGui.py`:

```py
import traceback
from sys import modules


if "idaapi" in modules:
    # We are running inside IDA
    from PyQt5 import QtWidgets
else:
    # We are running inside Cutter, Binary Ninja or Ghidra
    try:
        import PySide2.QtWidgets as QtWidgets
    except:
        import PySide6.QtWidgets as QtWidgets


class PluginGui():

    def __init__(self, api_proxy) -> None:
        self.layout = QtWidgets.QVBoxLayout()
        self.api_proxy = api_proxy
        # just a single label showing the MD5 as demo
        md5_string = "Could't get MD5, probably a permissions issue"
        try:
            md5_string = f"The current binary has MD5: {self.api_proxy.get_md5()}"
        except Exception:
            print("While trying to obtain the MD5 through ApiProxy, we caught this exception:")
            traceback.print_exc()
        self.layout.addWidget(QtWidgets.QLabel(md5_string))

```