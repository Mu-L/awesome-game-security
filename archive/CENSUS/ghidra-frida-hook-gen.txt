Project Path: arc_CENSUS_ghidra-frida-hook-gen_s1uh4p5b

Source Tree:

```txt
arc_CENSUS_ghidra-frida-hook-gen_s1uh4p5b
├── LICENSE
├── Module.manifest
├── README.md
├── build.gradle
├── data
│   └── README.txt
├── dist
│   ├── ghidra_10.1.4_PUBLIC_20220804_frida_hook_generator.zip
│   ├── ghidra_10.2.2_PUBLIC_20221212_frida_hook_generator_BETA.zip
│   ├── ghidra_10.2.2_PUBLIC_20230825_FridaHookGenerator_BETA.zip
│   ├── ghidra_10.4_PUBLIC_20231007_FridaHookGenerator_BETA.zip
│   ├── ghidra_11.0.3_PUBLIC_20240508_FridaHookGenerator.zip
│   ├── ghidra_11.0.3_PUBLIC_20250110_FridaHookGenerator.zip
│   ├── ghidra_11.3.2_PUBLIC_20250527_FridaHookGenerator.zip
│   └── ghidra_11.3.2_PUBLIC_20250902_FridaHookGenerator.zip
├── extension.properties
├── ghidra_scripts
│   └── README.txt
├── images
│   ├── Hook_demo1.png
│   ├── Hook_demo2.png
│   ├── Hook_demo3.png
│   └── Hook_demo4.png
├── lib
│   └── README.txt
└── src
    ├── main
    │   ├── help
    │   │   └── help
    │   │       ├── TOC_Source.xml
    │   │       ├── shared
    │   │       │   └── DefaultStyle.css
    │   │       └── topics
    │   │           └── fridahookgenerator
    │   │               └── help.html
    │   ├── java
    │   │   └── fridahookgenerator
    │   │       ├── AdvancedHookOptionsDialog.java
    │   │       ├── ChatGPTAPICaller.java
    │   │       ├── ComputedCallHookGenerator.java
    │   │       ├── FridaHookGeneratorAPIHandler.java
    │   │       ├── FridaHookGeneratorPlugin.java
    │   │       ├── GenerateFridaHookScriptAction.java
    │   │       ├── HookGenerator.java
    │   │       ├── HookGeneratorUtils.java
    │   │       ├── InstructionSearchPatternHandler.java
    │   │       ├── InternalStructuresForHookGeneration.java
    │   │       ├── ParserOfComputedCalls.java
    │   │       ├── ParsersOfComputedCalls
    │   │       │   ├── ARM64ParserOfComputedCall.java
    │   │       │   └── X86ParserOfComputedCall.java
    │   │       ├── SelectionBatchHookGenerationTask.java
    │   │       ├── SelectionHookGenerationAction.java
    │   │       ├── SelectionHookGenerationTaskDispatcher.java
    │   │       ├── StandardHookGenerationTask.java
    │   │       ├── StructAccessCodeGenerationAction.java
    │   │       └── StructAccessCodeGenerator.java
    │   └── resources
    │       └── images
    │           └── README.txt
    └── test
        └── java
            └── README.test.txt

```

`LICENSE`:

```
BSD 2-Clause License

Copyright (c) 2022, CENSUS
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
## Frida Hook generator for Ghidra

This plugin provides three new options in the right-click menu of the Listing Window in Ghidra:

![Hook-demo](images/Hook_demo1.png)

- Copy Frida Hook Script: This one creates a valid frida script that generates a hook for the target address or function, and puts it into the clipboard. Usually this is supposed to be selected at first, to also generate the required skeleton code.
- Copy Frida Hook Snippet: This one creates a snippet that is meant to be put inside a generated script, and hooks the target address or function using the (assumed) predefined variables of that script. It is not a valid frida script in itself.
- Create Advanced Frida Hook: This one spawns a menu containing various options allowing for complex hook generation.

This extension supports both function-level hooking (when hooking the first address of a function), as well as arbitrary address hooking (when hooking inside a function).

It should be noted that the right-click should be done when hovering over the instruction address in the Listing Window. If for example it is done when hovering over a function name that the current instruction calls, the hook will be generated for that function, and not the current instruction.

#### Installation:

- Take the latest ghidra\_\<version\>\_PUBLIC\_\<date\>_frida_hook_generator.zip file which is inside the folder dist/ . Alternatively, grab the latest `gradle` version from [here](https://gradle.org/releases/), the latest `Ghidra` version from [here](https://github.com/NationalSecurityAgency/ghidra/releases), cd into the root directory of the project and run
```
/path/to/gradle -PGHIDRA_INSTALL_DIR=/path/to/ghidra
```
which will produce a .zip file to be installed inside the dist/ folder.
- From Ghidra (before opening a tool) -> File -> Install Extensions -> + sign -> Select the zip -> Make sure the FridaHookGenerator is checked in the list of extensions
- Restart Ghidra
- Open CodeBrowser tool and analyze a binary. When asked if the new plugin should be configured, press "Yes" and make sure it is ticked. 

#### Usage:

- Open CodeBrowser tool and analyze a binary. If it is the first time after the installation, you will be asked if the new plugin should be configured. Press "Yes" and make sure it is ticked. 
- Right click at the Listing Window on an address and select "Copy Frida Hook Script".
- Paste the copied text into a file. Typically the first hook will be generated by the "Copy Script" option, and subsequent hooks by the "Copy Snippet" option.
- Run the binary through frida, for example `frida -f <binary> -l script.js` 

#### Notes:

- The Advanced Frida Hooks dialog offers multiple useful options, for generation of hooks for multiple related addresses at once:

  ![Hook_demo3.png](images/Hook_demo3.png)


- The "Copy Script" option introduces a 2-second delay for registering the interceptors. The reason for that is that a typical mobile application will not have all the dynamic libraries readily available at launch, for frida to hook into. As a quick fix, the script waits for a little and then tries to register the interceptors.  In certain cases, this means that the functions may be executed before frida hooks on them. If that is not desirable, it is possible to create code that registers the hooks when a particular library is loaded though dlopen() or LoadLibrary() through the Advanced Options.


- The generated script attempts to display a hooked function's parameters when it is called. However, usually the "Listing" window which contains the assembly code, does not reflect that parameter number. As such, the generated script will not contain code to print the correct number of parameters (usually it does not recognize any parameter, and as such it does not print anything). The solution to fix this is to right click on a function's name on the Ghidra "Decompiler" window, and select "Commit Params/Return". Then, the "Listing" window will recognize the correct number of parameters.


- The plugin also offers the ability to generate hooks for multiple addresses, as they have been identified from Ghidra's Search or other grouping options . First a selection must be created (Right click -> Make Selection), and then a new option is provided that can generate hooks for all the selected addresses. In effect, an Advanced Hook Generation dialog will be spawned that takes all the selected addresses as inputs. If for example the option "Generate hooks for addresses (statically) referencing the current address" is selected, then hooks for all the references of all the selected addresses will be generated.
  
  
  
  ![Hook_demo2.png](images/Hook_demo2.png)
  
  

- Another option provided by the plugin is the generation of javascript code that describes structs, so as to make their fields easily accessible by later hook code. Ghidra must know about the structs, this is typically done by parsing debug symbols but it is outside the scope of the plugin.
  
  
  
  ![Hook_demo4.png](images/Hook_demo4.png)



- As an example of the output of the plugin, here's a sample of the output code, for a function that starts at the offset 0x32450. The option "Copy Frida Hook Script" was used:

```
var module_name_vlc_exe='vlc.exe';

function start_timer_for_intercept() {
  setTimeout(
    function() {
        console.log("Registering interceptors...");
        
        
        var offset_of_FUN_00432450_00432450=0x32450;
        var dynamic_address_of_FUN_00432450_00432450=Process.getModuleByName(module_name_vlc_exe).base.add(offset_of_FUN_00432450_00432450);
        Interceptor.attach(dynamic_address_of_FUN_00432450_00432450, {
                    onEnter: function(args) {
                        console.log("Entered FUN_00432450_00432450");
                        console.log('args[0]='+args[0]+' , args[1]='+args[1]+' , args[2]='+args[2]+' , args[3]='+args[3]);
                        // this.context.x0=0x1;
                    },
                    onLeave: function(retval) {
                        console.log("Exited FUN_00432450_00432450, retval:"+retval);
                        // retval.replace(0x1);
                    }
        }); 

        
        Interceptor.flush();
        console.log("Registered interceptors.");
    }, 2000);//milliseconds
}
start_timer_for_intercept();
```

If the option "Copy Frida Hook Snippet" is used, only the part in the middle will be returned (between the first `console.log()` and the `Interceptor.flush()`).  
The code when hooking a random address that is not the first address in a function looks like the following:

```
    var offset_of_0043246c=0x3246c;
    var dynamic_address_of_0043246c=Process.getModuleByName(module_name_vlc_exe).base.add(offset_of_0043246c);
    function function_to_call_when_code_reaches_0043246c(){
        console.log('Reached address 0x0043246c, which is inside function FUN_00432450');
        //this.context.x0=0x1;
    }
    Interceptor.attach(dynamic_address_of_0043246c, function_to_call_when_code_reaches_0043246c); 

```


The generated code that provides easy access to a struct's fields looks like the following:

```
class struct__time_h_timespec {
    constructor(baseaddr) {
        this.alignment = 8
        this.is_packed = true
        this.base = baseaddr
        this.total_size = 16
        this.layout = {
            tv_sec : this.base.add(0),   //__time_t, size:8 - Signed Long Integer (compiler-specific size)
            tv_nsec : this.base.add(8)   //long, size:8 - Signed Long Integer (compiler-specific size)
        }
        this.offsets = {
            tv_sec : 0,   //__time_t, size:8
            tv_nsec : 8   //long, size:8
        }
    }
}

class struct__time_h_itimerspec {
    constructor(baseaddr) {
        this.alignment = 8
        this.is_packed = true
        this.base = baseaddr
        this.total_size = 32
        this.layout = {
            it_interval : this.base.add(0),   //timespec, size:16 - 
            it_value : this.base.add(16)   //timespec, size:16 - 
        }
        this.offsets = {
            it_interval : 0,   //timespec, size:16
            it_value : 16   //timespec, size:16
        }
        this.members = {
            it_interval : new struct__time_h_timespec(this.layout.it_interval),  
            it_value : new struct__time_h_timespec(this.layout.it_value)  
        }
    }
}
```


#### Example usage videos :

- [Basic Usage](https://youtu.be/LYsQzS2YqxE)
- [Reference Hooking](https://youtu.be/dB5k1yc9ve0)
- [Hook Imports](https://youtu.be/y62RG7cSJ-s)
- [Hook multiple functions by regex](https://youtu.be/Pv4zg1Bmyr8)
- [Printing reasons for hooking](https://youtu.be/hMWGYJSCvtA)
```

`build.gradle`:

```gradle
/* BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
// Builds a Ghidra Extension for a given Ghidra installation.
//
// An absolute path to the Ghidra installation directory must be supplied either by setting the 
// GHIDRA_INSTALL_DIR environment variable or Gradle project property:
//
//     > export GHIDRA_INSTALL_DIR=<Absolute path to Ghidra> 
//     > gradle
//
//         or
//
//     > gradle -PGHIDRA_INSTALL_DIR=<Absolute path to Ghidra>
//
// Gradle should be invoked from the directory of the project to build.  Please see the
// application.gradle.version property in <GHIDRA_INSTALL_DIR>/Ghidra/application.properties
// for the correction version of Gradle to use for the Ghidra installation you specify.

//----------------------START "DO NOT MODIFY" SECTION------------------------------
def ghidraInstallDir

if (System.env.GHIDRA_INSTALL_DIR) {
	ghidraInstallDir = System.env.GHIDRA_INSTALL_DIR
}
else if (project.hasProperty("GHIDRA_INSTALL_DIR")) {
	ghidraInstallDir = project.getProperty("GHIDRA_INSTALL_DIR")
}

if (ghidraInstallDir) {
	apply from: new File(ghidraInstallDir).getCanonicalPath() + "/support/buildExtension.gradle"
}
else {
	throw new GradleException("GHIDRA_INSTALL_DIR is not defined!")
}
//----------------------END "DO NOT MODIFY" SECTION-------------------------------

repositories {
	// Declare dependency repositories here.  This is not needed if dependencies are manually 
	// dropped into the lib/ directory.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html for more info.
	// Ex: mavenCentral()
}

dependencies {
	// Any external dependencies added here will automatically be copied to the lib/ directory when
	// this extension is built.	
}

```

`data/README.txt`:

```txt
The "data" directory is intended to hold data files that will be used by this module and will
not end up in the .jar file, but will be present in the zip or tar file.  Typically, data
files are placed here rather than in the resources directory if the user may need to edit them.

An optional data/languages directory can exist for the purpose of containing various Sleigh language
specification files and importer opinion files.  

The data/buildLanguage.xml is used for building the contents of the data/languages directory.

The skel language definition has been commented-out within the skel.ldefs file so that the 
skeleton language does not show-up within Ghidra.

See the Sleigh language documentation (docs/languages/index.html) for details Sleigh language 
specification syntax.
 
```

`extension.properties`:

```properties
name=@extname@
description=This extension creates right-click options which allow for fast generation of Frida hook code.
author=
createdOn=
version=@extversion@

```

`ghidra_scripts/README.txt`:

```txt
Java source directory to hold module-specific Ghidra scripts.

```

`lib/README.txt`:

```txt
The "lib" directory is intended to hold Jar files which this module is dependent upon.  Jar files 
may be placed in this directory manually, or automatically by maven via the dependencies block
of this module's build.gradle file.
```

`src/main/help/help/TOC_Source.xml`:

```xml
<?xml version='1.0' encoding='ISO-8859-1' ?>
<!-- 

	This is an XML file intended to be parsed by the Ghidra help system.  It is loosely based 
	upon the JavaHelp table of contents document format.  The Ghidra help system uses a 
	TOC_Source.xml file to allow a module with help to define how its contents appear in the 
	Ghidra help viewer's table of contents.  The main document (in the Base module) 
	defines a basic structure for the 
	Ghidra table of contents system.  Other TOC_Source.xml files may use this structure to insert
	their files directly into this structure (and optionally define a substructure).
	
	
	In this document, a tag can be either a <tocdef> or a <tocref>.  The former is a definition
	of an XML item that may have a link and may contain other <tocdef> and <tocref> children.  
	<tocdef> items may be referred to in other documents by using a <tocref> tag with the 
	appropriate id attribute value.  Using these two tags allows any module to define a place 
	in the table of contents system (<tocdef>), which also provides a place for 
	other TOC_Source.xml files to insert content (<tocref>).  
	
	During the help build time, all TOC_Source.xml files will be parsed and	validated to ensure
	that all <tocref> tags point to valid <tocdef> tags.  From these files will be generated
	<module name>_TOC.xml files, which are table of contents files written in the format 
	desired by the JavaHelp system.   Additionally, the genated files will be merged together
	as they are loaded by the JavaHelp system.  In the end, when displaying help in the Ghidra
	help GUI, there will be on table of contents that has been created from the definitions in 
	all of the modules' TOC_Source.xml files.

	
	Tags and Attributes
	
	<tocdef>
	-id          - the name of the definition (this must be unique across all TOC_Source.xml files)	
	-text        - the display text of the node, as seen in the help GUI
	-target**    - the file to display when the node is clicked in the GUI
	-sortgroup   - this is a string that defines where a given node should appear under a given
	               parent.  The string values will be sorted by the JavaHelp system using
	               a javax.text.RulesBasedCollator.  If this attribute is not specified, then
	               the text of attribute will be used.

	<tocref>
	-id			 - The id of the <tocdef> that this reference points to 
	
	**The URL for the target is relative and should start with 'help/topics'.  This text is 
	used by the Ghidra help system to provide a universal starting point for all links so that
	they can be resolved at runtime, across modules.
	
	
-->


<tocroot>
	<!-- Uncomment and adjust fields to add help topic to help system's Table of Contents
	<tocref id="Ghidra Functionality">
		<tocdef id="HelpAnchor" text="My Feature" target="help/topics/my_topic/help.html" />
	</tocref>
	-->
</tocroot>

```

`src/main/help/help/shared/DefaultStyle.css`:

```css
/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
									WARNING!
    This file is copied to all help directories.  If you change this file, you must copy it 
    to each src/main/help/help/shared directory.									
									
	
	Java Help Note:  JavaHelp does not accept sizes (like in 'margin-top') in anything but 
	px (pixel) or with no type marking. 

*/ 

body { margin-bottom: 50px; margin-left: 10px; margin-right: 10px; margin-top: 10px; } /* some padding to improve readability */ 
li { font-family:times new roman; font-size:14pt; }
h1 { color:#000080; font-family:times new roman; font-size:36pt; font-style:italic; font-weight:bold; text-align:center; }
h2 { margin: 10px; margin-top: 20px; color:#984c4c; font-family:times new roman; font-size:18pt; font-weight:bold; }
h3 { margin-left: 10px; margin-top: 20px; color:#0000ff; font-family:times new roman; `font-size:14pt; font-weight:bold;  }
h4 { margin-left: 10px; margin-top: 20px; font-family:times new roman; font-size:14pt; font-style:italic; }
 
/*
	 P tag code.  Most of the help files nest P tags inside of blockquote tags (the was the 
	 way it had been done in the beginning).  The net effect is that the text is indented.  In 
	 modern HTML we would use CSS to do this.  We need to support the Ghidra P tags, nested in
	 blockquote tags, as well as naked P tags.  The following two lines accomplish this.  Note
	 that the 'blockquote p' definition will inherit from the first 'p' definition.
*/
p { margin-left: 40px; font-family:times new roman; font-size:14pt; }
blockquote p { margin-left: 10px; }

p.providedbyplugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px  }
p.ProvidedByPlugin { color:#7f7f7f; margin-left: 10px; font-size:14pt; margin-top:100px }
p.relatedtopic { color:#800080; margin-left: 10px; font-size:14pt; }
p.RelatedTopic { color:#800080; margin-left: 10px; font-size:14pt; }

/* 
	We wish for a tables to have space between it and the preceding element, so that text
	is not too close to the top of the table.  Also, nest the table a bit so that it is clear
	the table relates to the preceding text.
*/
table { margin-left: 20px; margin-top: 10px; width: 80%;}
td { font-family:times new roman; font-size:14pt; vertical-align: top; }
th { font-family:times new roman; font-size:14pt; font-weight:bold; background-color: #EDF3FE; }

/*
	Code-like formatting for things such as file system paths and proper names of classes, 
	methods, etc.  To apply this to a file path, use this syntax:
		<CODE CLASS="path">...</CODE>
*/
code { color: black; font-weight: bold; font-family: courier new, monospace; font-size: 14pt; white-space: nowrap; }
code.path { color: #4682B4; font-weight: bold; font-family: courier new, monospace; font-size: 14pt; white-space: nowrap; }

```

`src/main/help/help/topics/fridahookgenerator/help.html`:

```html
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <META name="generator" content=
    "HTML Tidy for Java (vers. 2009-12-01), see jtidy.sourceforge.net">
    <META http-equiv="Content-Language" content="en-us">
    <META http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <META name="GENERATOR" content="Microsoft FrontPage 4.0">
    <META name="ProgId" content="FrontPage.Editor.Document">

    <TITLE>Skeleton Help File for a Module</TITLE>
    <LINK rel="stylesheet" type="text/css" href="help/shared/DefaultStyle.css">
  </HEAD>

  <BODY>
    <H1><a name="HelpAnchor"></a>Skeleton Help File for a Module</H1>

    <P>This is a simple skeleton help topic. For a better description of what should and should not
    go in here, see the "sample" Ghidra extension in the Extensions/Ghidra directory, or see your 
    favorite help topic. In general, language modules do not have their own help topics.</P>
  </BODY>
</HTML>

```

`src/main/java/fridahookgenerator/AdvancedHookOptionsDialog.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import docking.DialogComponentProvider;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.TitledBorder;

import docking.ComponentProvider;
import docking.DialogComponentProvider;
import docking.widgets.OptionDialog;
import docking.widgets.button.GRadioButton;
import docking.widgets.checkbox.GCheckBox;
import docking.widgets.combobox.GhidraComboBox;
import docking.widgets.label.GLabel;
import ghidra.app.util.AddEditDialog.NamespaceWrapper;
import ghidra.framework.cmd.Command;
import ghidra.framework.cmd.CompoundCmd;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.database.symbol.FunctionSymbol;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.exception.AssertException;
import ghidra.util.layout.HorizontalLayout;
import ghidra.util.layout.VerticalLayout;


/*
 * This class is responsible for creating the window of the Advanced Hook options, but also serves as the object
 * that is passed around containing the user's advanced options, from which the hook is generated.
 */
public class AdvancedHookOptionsDialog extends DialogComponentProvider {
		
	private PluginTool tool;
	public Boolean isOKpressed;
	public Boolean is_invoked_from_selecting_multiple_addresses;
	
	/*Incoming References items*/
	public JCheckBox ReferencestoAddressCheckBox;
	public Boolean isReferencestoAddressCheckBoxchecked;
	public JCheckBox FunctionsReferencingAddressCheckBox;
	public Boolean isFunctionsReferencingAddressCheckBoxchecked;
	public JCheckBox ReferencestoFunctionCheckbox;
	public Boolean isReferencestoFunctionCheckboxchecked;
	public JCheckBox FunctionsReferencingFunctionCheckbox;
	public Boolean isFunctionsReferencingFunctionCheckboxchecked;
	public JComboBox<String> InFunctionReferenceDepthcomboBox;
	
	/*Outgoing References items*/
	public JCheckBox OutReferencesfromFunctionCheckBox;
	public Boolean isOutReferencesfromFunctionCheckBoxchecked;
	public JComboBox<String> OutFunctionReferenceDepthcomboBox;
	public JCheckBox OutReferencesfromAddressCheckBox;
	public Boolean isOutReferencesfromAddressCheckBoxchecked;
	public JCheckBox OutDynamicCallReferencesfromFunctionCheckBox;
	public Boolean isOutDynamicCallReferencesfromFunctionCheckBoxchecked;
	public JCheckBox OutDynamicCallReferencesfromAddressCheckBox;
	public Boolean isOutDynamicCallReferencesfromAddressCheckBoxchecked;
	
	/*Range items*/
	public JCheckBox HookThisAddressCheckBox;
	public Boolean isHookThisAddressCheckBoxchecked;
	public JCheckBox RangeAddressesCheckBox;
	public Boolean isRangeAddressesCheckBoxchecked;
	public JCheckBox RangeFunctionsCheckBox;
	public Boolean isRangeFunctionsCheckBoxchecked;
	public GLabel RangeAddressesNumLabel;
	public JTextField RangeAddressesNumTextField;
	public int RangeAddressesNum;
	public GLabel RangeFunctionsNumLabel;
	public JTextField RangeFunctionsNumTextField;
	public int RangeFunctionsNum;
	public ButtonGroup RangeAddressesButtonGroup;
	public GRadioButton RangeAddressesRadioButtonAddr;
	public GRadioButton RangeAddressesRadioButtonInstr;
	public GRadioButton RangeAddressesRadioButtonFun;
	public ButtonGroup RangeFunctionsButtonGroup;
	public GRadioButton RangeFunctionsRadioButtonAddr;
	public GRadioButton RangeFunctionsRadioButtonInstr;
	public GRadioButton RangeFunctionsRadioButtonFun;
	public GRadioButton RangeFunctionsRadioButtonFunBackwards;

	
	/*Output items*/
	public JCheckBox OutputReasonForHookGenCheckbox;
	public Boolean isOutputReasonForHookGenCheckboxchecked;
	public JComboBox<String> ReasonForHookGenAmountcomboBox;
	public JCheckBox GenerateScriptCheckbox;
	public Boolean isGenerateScriptCheckboxchecked;
	public JComboBox<String> TypeofScriptGenerationcomboBox;
	public JCheckBox CustomFunInterceptorHookOutputCheckbox;
	public Boolean isCustomFunInterceptorHookOutputCheckboxchecked;
	public JComboBox<String> CustomFunInterceptorHookOutputcomboBox;
	public JCheckBox DoNotIncludeFunParamscheckbox;
	public Boolean isDoNotIncludeFunParamscheckboxchecked;
	public JCheckBox IncludeFunParamNamescheckbox;
	public Boolean isIncludeFunParamNamescheckboxchecked;
	public JCheckBox GenerateBacktraceCheckbox;
	public Boolean isGenerateBacktraceCheckboxchecked;
	public JComboBox<String> GenerateBacktracecomboBox;
	public JCheckBox GenerateNormalAddressHooksForFunctionBeginningscheckbox;
	public Boolean isGenerateNormalAddressHooksForFunctionBeginningscheckboxchecked;

	/*Multi-Hook management items*/
	public JCheckBox FunctionRegexCheckBox;
	public Boolean isFunctionRegexCheckBoxchecked;
	public JTextField FunctionRegexTextField;
	public JCheckBox FunctionMangledNameRegexCheckBox;
	public Boolean isFunctionMangledNameRegexCheckBoxchecked;
	public JTextField FunctionMangledNameRegexTextField;
	public JCheckBox MemoryScanPatternCheckBox;
	public Boolean isMemoryScanPatternCheckBoxchecked;
	public JTextField MemoryScanPatternTextField;
	public JCheckBox HookExportsCheckBox;
	public Boolean isHookExportsCheckBoxchecked;
	public JCheckBox HookImportsCheckBox;
	public Boolean isHookImportsCheckBoxchecked;
	public JCheckBox CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox;
	public Boolean isCreateDataStructuresToLinkAddressesAndFunctionNamescheckboxchecked;
	public JCheckBox CreateDataStructureWithInterceptorAttachObjectscheckbox;
	public Boolean isCreateDataStructureWithInterceptorAttachObjectscheckboxchecked;
	public JCheckBox IncludeCustomTextcheckbox;
	public Boolean isIncludeCustomTextcheckboxchecked;
	public JTextField IncludeCustomTextTextField;
	public JCheckBox IncludeCustomTextAftercheckbox;
	public Boolean isIncludeCustomTextAftercheckboxchecked;
	public JTextField IncludeCustomTextAfterTextField;
	public JCheckBox IncludeInterceptorTryCatchcheckbox;
	public Boolean isIncludeInterceptorTryCatchcheckboxchecked;
	public JCheckBox IncludeTIDAndIndentationcheckbox;
	public Boolean isIncludeTIDAndIndentationcheckboxchecked;
	public JCheckBox DoNotHookThunkFunctionscheckbox;
	public Boolean isDoNotHookThunkFunctionscheckboxchecked;
	public JCheckBox DoNotHookExternalFunctionscheckbox;
	public Boolean isDoNotHookExternalFunctionscheckboxchecked;
	public JCheckBox AIChatFunctionRegexCheckBox;
	public Boolean isAIChatFunctionRegexCheckBoxchecked;
	public JTextField AIChatFunctionRegexTextField;
	
	private Program current_program;
	private Address addr;

	public AdvancedHookOptionsDialog(PluginTool tool, Program current_program)
	{
		/*Constructor that is used for API calling*/
		this("API-generated Advanced Hook Options Dialog", tool, current_program,true);
	}
	
	public AdvancedHookOptionsDialog(String title, PluginTool tool, Program current_program,Boolean is_invoked_from_selecting_multiple_addresses) {
		super(title, true, true, true, false);
		this.tool = tool;
		this.current_program=current_program;
		this.isOKpressed=false;
		this.is_invoked_from_selecting_multiple_addresses=is_invoked_from_selecting_multiple_addresses;
		this.isReferencestoAddressCheckBoxchecked=false;
		this.isFunctionsReferencingAddressCheckBoxchecked=false;
		this.isReferencestoFunctionCheckboxchecked=false;
		this.isFunctionsReferencingFunctionCheckboxchecked=false;
		this.isGenerateScriptCheckboxchecked=false;
		this.isHookThisAddressCheckBoxchecked=false;
		this.isRangeAddressesCheckBoxchecked=false;
		this.isRangeFunctionsCheckBoxchecked=false;
		this.isOutReferencesfromFunctionCheckBoxchecked=false;
		this.isOutReferencesfromAddressCheckBoxchecked=false;
		this.isOutputReasonForHookGenCheckboxchecked=false;
		this.isCustomFunInterceptorHookOutputCheckboxchecked=false;
		this.isDoNotIncludeFunParamscheckboxchecked=false;
		this.isIncludeFunParamNamescheckboxchecked=false;
		this.isFunctionRegexCheckBoxchecked=false;
		this.isFunctionMangledNameRegexCheckBoxchecked=false;
		this.isMemoryScanPatternCheckBoxchecked=false;
		this.isHookExportsCheckBoxchecked=false;
		this.isHookImportsCheckBoxchecked=false;
		this.isGenerateBacktraceCheckboxchecked=false;
		this.isIncludeCustomTextcheckboxchecked=false;
		this.isIncludeCustomTextAftercheckboxchecked=false;
		this.isOutDynamicCallReferencesfromFunctionCheckBoxchecked=false;
		this.isOutDynamicCallReferencesfromAddressCheckBoxchecked=false;
		this.isIncludeInterceptorTryCatchcheckboxchecked=false;
		this.isIncludeTIDAndIndentationcheckboxchecked=false;
		this.isDoNotHookThunkFunctionscheckboxchecked=false;
		this.isDoNotHookExternalFunctionscheckboxchecked=false;
		this.isCreateDataStructuresToLinkAddressesAndFunctionNamescheckboxchecked=false;
		this.isCreateDataStructureWithInterceptorAttachObjectscheckboxchecked=false;
		this.isGenerateNormalAddressHooksForFunctionBeginningscheckboxchecked=false;
		this.isAIChatFunctionRegexCheckBoxchecked=false;
		
		addWorkPanel(create());
		setFocusComponent(ReferencestoAddressCheckBox);
		addOKButton();
		addCancelButton();
		setDefaultButton(okButton);
	}
	

	

	/**
	 * Define the Main panel for the dialog.
	 */
	private JPanel create() {

		ReferencestoAddressCheckBox = new GCheckBox("Generate Hooks for addresses (statically) referencing the current address");
		ReferencestoAddressCheckBox.setToolTipText(
			"Generate Hooks for addresses referencing the current address");
		FunctionsReferencingAddressCheckBox = new GCheckBox("Generate Hooks for functions containing code that (statically) references the current address");
		FunctionsReferencingAddressCheckBox.setToolTipText("Generate Hooks for functions containing code that (statically) references the current address");
		ReferencestoFunctionCheckbox = new GCheckBox("Generate Hooks for addresses (statically) referencing the current function");
		ReferencestoFunctionCheckbox.setToolTipText("Generate Hooks for addresses referencing the current function");
		FunctionsReferencingFunctionCheckbox = new GCheckBox("Generate Hooks for functions (statically) referencing the current function for depth");
		FunctionsReferencingFunctionCheckbox.setMnemonic('R');
		FunctionsReferencingFunctionCheckbox.setToolTipText(
			"Generate Hooks for functions referencing the current function for a certain depth");
		String[] indepths_to_choose_from= {"1","2","3","4","5","6","7","8","9","10"};
		InFunctionReferenceDepthcomboBox=new JComboBox<>(indepths_to_choose_from);
		
		
		OutReferencesfromFunctionCheckBox = new GCheckBox("Generate Hooks for functions (statically) called by the current function for depth");
		OutReferencesfromFunctionCheckBox.setToolTipText(
				"Generate Hooks for functions (statically) called by the current function for a certain depth");
		String[] outdepths_to_choose_from= {"1","2","3","4","5","6","7","8","9","10"};
		OutFunctionReferenceDepthcomboBox=new JComboBox<>(outdepths_to_choose_from);
		OutReferencesfromAddressCheckBox = new GCheckBox("Generate Hooks for the addresses (statically) referenced by the current address");
		OutReferencesfromAddressCheckBox.setToolTipText(
				"Generate Hooks for the addresses (statically) referenced by the current address. Appears only during selection of multiple addresses");
		OutDynamicCallReferencesfromAddressCheckBox = new GCheckBox("For every instruction to be hooked, if it is a dynamic (computed) call, print which address the execution will land on (X64,AARCH64 only)");
		OutDynamicCallReferencesfromAddressCheckBox.setToolTipText("For every instruction to be hooked, if it is a dynamic (computed) call, print which address the execution will land on (X64,AARCH64 only)");
		OutDynamicCallReferencesfromFunctionCheckBox = new GCheckBox("For each dynamic (computed) call in current function, print which address the execution will land on when this call is executed (X64,AARCH64 only)");
		OutDynamicCallReferencesfromFunctionCheckBox.setToolTipText("For each dynamic (computed) call in current function, print which address the execution will land on when this call is executed (X64,AARCH64 only)");

		
		HookThisAddressCheckBox = new GCheckBox("Generate a Hook for this (the current) address, through which this dialog was spawned");
		RangeAddressesCheckBox = new GCheckBox("Generate Hooks for addresses (starting from current address, and moving forward for X elements)");
		RangeAddressesCheckBox.setToolTipText("This option includes the current address in the list of possible hooks, and counts it as the 1st");
		RangeFunctionsCheckBox = new GCheckBox("Generate Hooks for functions (starting from current address, and moving for X elements)");
		RangeFunctionsCheckBox.setToolTipText("This option includes the current function (if the current address is in one) in the list of possible hooks, and counts it as the 1st");
		RangeAddressesNumLabel=new GLabel("Number and type of elements:");
		RangeAddressesNumTextField=new JTextField(10);
		RangeFunctionsNumLabel=new GLabel("Number and type of elements:");
		RangeFunctionsNumTextField=new JTextField(10);
		RangeAddressesButtonGroup= new ButtonGroup();
		RangeFunctionsButtonGroup= new ButtonGroup();
		RangeAddressesRadioButtonAddr = new GRadioButton("Addresses (Bytes)");
		RangeAddressesRadioButtonInstr = new GRadioButton("Instructions");
		RangeAddressesRadioButtonFun = new GRadioButton("Functions");
		RangeAddressesButtonGroup.add(RangeAddressesRadioButtonAddr);
		RangeAddressesButtonGroup.add(RangeAddressesRadioButtonInstr);
		RangeAddressesButtonGroup.add(RangeAddressesRadioButtonFun);
		RangeFunctionsRadioButtonAddr = new GRadioButton("Addresses (Bytes) (forward)");
		RangeFunctionsRadioButtonInstr = new GRadioButton("Instructions");
		RangeFunctionsRadioButtonFun = new GRadioButton("Functions (forward)");
		RangeFunctionsRadioButtonFunBackwards = new GRadioButton("Functions (backwards)");
		RangeFunctionsButtonGroup.add(RangeFunctionsRadioButtonAddr);
		RangeFunctionsButtonGroup.add(RangeFunctionsRadioButtonInstr);
		RangeFunctionsButtonGroup.add(RangeFunctionsRadioButtonFun);
		RangeFunctionsButtonGroup.add(RangeFunctionsRadioButtonFunBackwards);
		RangeAddressesRadioButtonFun.setSelected(true);
		RangeFunctionsRadioButtonFun.setSelected(true);

		
		OutputReasonForHookGenCheckbox = new GCheckBox("Print the reason(s) why each hook is generated, maximum number of reasons:");
		OutputReasonForHookGenCheckbox.setToolTipText(
				"This option prints the reasons why every hook is generated. There might be multiple if an address is asked to be hooked multiple times in the same batch.");
		String[] Amount_of_reasons_choices= {"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30"};
		ReasonForHookGenAmountcomboBox=new JComboBox<>(Amount_of_reasons_choices);
		ReasonForHookGenAmountcomboBox.setSelectedIndex(9);
		
		CustomFunInterceptorHookOutputCheckbox = new GCheckBox("In case of hook generation for functions:");
		CustomFunInterceptorHookOutputCheckbox.setToolTipText("This option allows to modify the way the function interceptor hook generation is done. WARNING: If checked with the option that includes threadIDs and indentation, blocking of OnEnter()/OnLeave() will not happen.");
		String[] ways_to_alter_function_interceptor_hook= {"Do not include onEnter()","Do not include onLeave()","use Interceptor.replace() (Experimental)"};
		CustomFunInterceptorHookOutputcomboBox=new JComboBox<>(ways_to_alter_function_interceptor_hook);
		
		DoNotIncludeFunParamscheckbox=new GCheckBox("In case of hook generation for functions, do not print their parameters");
		DoNotIncludeFunParamscheckbox.setToolTipText("In case of hook generation for functions, do not print their parameters");	
		
		IncludeFunParamNamescheckbox=new GCheckBox("In case of function parameter printing, their names should be printed as well");
		IncludeFunParamNamescheckbox.setToolTipText("In case of function parameter printing, their names should be printed as well");	
		
		
		GenerateBacktraceCheckbox=new GCheckBox("Generate backtrace:");
		GenerateBacktraceCheckbox.setToolTipText("Generate a backtrace through the methods provided by frida (not present in function hook if onEnter() is removed)");	
		String[] ways_to_generate_backtrace= {"Backtracer.ACCURATE at function beginnings","Backtracer.FUZZY at function beginnings","Backtracer.ACCURATE in every hook","Backtracer.FUZZY in every hook"};
		GenerateBacktracecomboBox=new JComboBox<>(ways_to_generate_backtrace);

		
		GenerateScriptCheckbox = new GCheckBox("Generate Hook Script and not Snippet, registering interceptors through method ");
		GenerateScriptCheckbox.setMnemonic('S');
		GenerateScriptCheckbox.setToolTipText(
				"Generate Hook Script and not Snippet, that means, add prologue and epilogue");
		String[] ways_for_script_generation={"Default method that waits 2s", "dlopen() method", "LoadLibrary() method", "attachModuleObserver() method"};
		TypeofScriptGenerationcomboBox=new JComboBox<>(ways_for_script_generation);
		
		GenerateNormalAddressHooksForFunctionBeginningscheckbox= new GCheckBox("For function beginnings, do not use OnEnter()/OnLeave() methods at all, but generate hooks treating them as normal addresses");
		GenerateNormalAddressHooksForFunctionBeginningscheckbox.setToolTipText(
				"<html>If an adress is at the start of a function, then normally onEnter()/onLeave() methods are created in its hook. This option forces the address to be treated as any other address, without onEnter()/onLeave() methods. <br>This will also cause the execution to not follow any code paths that assume that the address is at the start of a function.<html>");
		
		
		FunctionRegexCheckBox=new GCheckBox("Generate hooks for functions whose name matches the following (case insensitive) regular expression:");
		FunctionRegexCheckBox.setToolTipText("In the case where the function names are known, similarly named functions may fall under the same functional block, and hooking all of them can be useful");
		FunctionRegexTextField=new JTextField(10);
		
		FunctionMangledNameRegexCheckBox=new GCheckBox("Generate hooks for functions whose *mangled* name matches the following (case insensitive) regular expression:");
		FunctionMangledNameRegexCheckBox.setToolTipText("In the case where the function names are known, similarly named functions may fall under the same functional block, and hooking all of them can be useful. This option makes the regex also apply in the parameters (through the mangled name)");
		FunctionMangledNameRegexTextField=new JTextField(10);
		
		MemoryScanPatternCheckBox=new GCheckBox("Generate hook skeleton for the following memory instruction pattern, being (Special) Copied from the Instruction Pattern Search window");
		MemoryScanPatternCheckBox.setToolTipText("Hooking by memory pattern may be the best way to port hooks to newer binary versions. Go to Instruction Pattern Search -> select some of the String Previews -> Copy Special -> Selected Instructions and paste in the text box");
		MemoryScanPatternTextField=new JTextField(10);
		
		HookExportsCheckBox=new GCheckBox("Generate hooks for all exported symbols");
		HookExportsCheckBox.setToolTipText("Generate hooks for all exported symbols which can be entry points. This is useful when you want to identify from which point a shared library is entered.");
		
		HookImportsCheckBox=new GCheckBox("Generate hooks for all imported symbols through ApiResolver('module')");
		HookImportsCheckBox.setToolTipText("Generate hooks for all imported symbols. This is useful when you want to identify what external functionalities this library calls and uses. Warning: The code generated does not adhere to the rest of the code generation options.");

		CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox=new GCheckBox("Create and initialize data structures that associate the hooked addresses with function names, accessible from javascript");
		CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox.setToolTipText("Create and initialize the relevant data structures, as it may be useful to be able to fetch the current function name (as visible in Ghidra) from the current address in javascript (accessible through \"this.context.pc\")");
		
		CreateDataStructureWithInterceptorAttachObjectscheckbox=new GCheckBox("In case of Interceptor.attach(), create and initialize a data structure that saves the returned objects from .attach() calls, on which we can later call .detach()");
		CreateDataStructureWithInterceptorAttachObjectscheckbox.setToolTipText("Create and initialize the relevant data structure, as it may be useful to be able to detach the created hook in javascript (using the \"this.context.pc\" as the key in the created dictionary)");

		IncludeCustomTextcheckbox=new GCheckBox("Add the following javascript code at the start of every hook generated:");
		IncludeCustomTextcheckbox.setToolTipText("Adds javascript code in every hook, at the start (not present in function hook if onEnter() is removed)");
		IncludeCustomTextTextField=new JTextField(30);
		
		IncludeCustomTextAftercheckbox=new GCheckBox("Add the following javascript code at the end of every hook generated:");
		IncludeCustomTextAftercheckbox.setToolTipText("Adds javascript code in every hook, at the end (not present in function hook if onLeave() is removed)");
		IncludeCustomTextAfterTextField=new JTextField(30);
		
		IncludeInterceptorTryCatchcheckbox=new GCheckBox("Add try/catch blocks for Interceptor calls in order to not stop in case of error");
		IncludeInterceptorTryCatchcheckbox.setToolTipText("If Frida fails to register an Interceptor, it stops and does not register any other hooks coming after the one that errors. By using a try/catch scheme, this can be bypassed. Warning: You might want to stop on error, use this option with caution.");
		
		
		IncludeTIDAndIndentationcheckbox=new GCheckBox("Include threadID and code indentation on function calls");
		IncludeTIDAndIndentationcheckbox.setToolTipText("<html>This option prints the current threadID for every function console output, and indents based on the call depth (relative to the currently hooked functions and not the total depth relative to all thread functions).<br> WARNING: If checked, the option that does not output OnEnter()/OnLeave() functions will be ignored.<html>");
		
		
		DoNotHookThunkFunctionscheckbox=new GCheckBox("Do not hook Thunk Functions even if they fall into the range of the addresses to be hooked");
		DoNotHookThunkFunctionscheckbox.setToolTipText("In case of multiple function calls, hooking Thunk functions may add too many or failed hooks, or even block the hooking of a larger function if the thunk code is close to its beginning");
		
		DoNotHookExternalFunctionscheckbox=new GCheckBox("Do not hook External Functions even if they fall into the range of the addresses to be hooked");
		DoNotHookExternalFunctionscheckbox.setToolTipText("In case of multiple function calls, hooking External functions may add too many or failed hooks, or even block the hooking of a larger function if the external function code is close to its beginning");
		

		AIChatFunctionRegexCheckBox=new GCheckBox("(Requires ChatGPT API Key) Generate hooks for functions, whose name is related to ");
		AIChatFunctionRegexCheckBox.setToolTipText("<html>This option reqires a ChatGPT API Key placed in the file ~/.ghidra/chatgpt_apikey.txt.<br> It queries the chatbot, *SENDS TO IT ALL THE FUNCTION NAMES*, and asks it to create a regular expression that matches the user-provided category.<br> For example, the category may be \"jailbreak detection\". <html>");
		AIChatFunctionRegexTextField=new JTextField(10);
		
		
		JPanel mainPanel = new JPanel(new VerticalLayout(30));
		//mainPanel.setPreferredSize(new Dimension(980,650));  //if not enough, make larger
		JPanel referencesPanel = new JPanel(new VerticalLayout(4));
		JPanel referencessubPanel = new JPanel(new HorizontalLayout(4));
		JPanel outreferencesPanel = new JPanel(new VerticalLayout(4));
		JPanel outreferencessubPanel = new JPanel(new HorizontalLayout(4));
		JPanel rangePanel = new JPanel(new VerticalLayout(4));
		JPanel rangeSubPanel1 = new JPanel(new HorizontalLayout(4));
		JPanel rangeSubPanel2 = new JPanel(new HorizontalLayout(4));
		JPanel outputPanel = new JPanel(new VerticalLayout(4));
		JPanel outputSubPanel1 = new JPanel(new HorizontalLayout(4));
		JPanel outputSubPanel2 = new JPanel(new HorizontalLayout(4));
		JPanel outputSubPanel3 = new JPanel(new HorizontalLayout(4));
		JPanel outputSubPanel4 = new JPanel(new HorizontalLayout(4));
		JPanel multihookPanel = new JPanel(new VerticalLayout(4));
		JPanel multihookSubPanel1 = new JPanel(new HorizontalLayout(4));
		JPanel multihookSubPanel2 = new JPanel(new HorizontalLayout(4));
		JPanel multihookSubPanel3 = new JPanel(new HorizontalLayout(4));
		JPanel multihookSubPanel4 = new JPanel(new HorizontalLayout(4));
		JPanel multihookSubPanel5 = new JPanel(new HorizontalLayout(4));
		JPanel multihookSubPanel6 = new JPanel(new HorizontalLayout(4));

		
		TitledBorder referenceBorder =
			BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), "Incoming Reference options");
		referencesPanel.setBorder(referenceBorder);
		
		TitledBorder outreferenceBorder =
				BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), "Outgoing Reference options");
			outreferencesPanel.setBorder(outreferenceBorder);
		
		TitledBorder rangeBorder =
				BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), "Range options");
		rangePanel.setBorder(rangeBorder);
		
		TitledBorder outputborder =
			BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), "Output Options");
		outputPanel.setBorder(outputborder);
		
		TitledBorder multihookborder =
				BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(), "Management Options for Multiple Hooks");
		multihookPanel.setBorder(multihookborder);
		

		mainPanel.add(referencesPanel);
		mainPanel.add(outreferencesPanel);
		mainPanel.add(rangePanel);
		mainPanel.add(outputPanel);
		mainPanel.add(multihookPanel);

		referencesPanel.add(ReferencestoAddressCheckBox,BorderLayout.NORTH);
		referencesPanel.add(FunctionsReferencingAddressCheckBox,BorderLayout.NORTH);
		referencesPanel.add(ReferencestoFunctionCheckbox,BorderLayout.NORTH);
		referencessubPanel.add(FunctionsReferencingFunctionCheckbox,BorderLayout.NORTH);
		referencessubPanel.add(InFunctionReferenceDepthcomboBox);
		referencesPanel.add(referencessubPanel);

		
		outreferencessubPanel.add(OutReferencesfromFunctionCheckBox,BorderLayout.NORTH);
		outreferencessubPanel.add(OutFunctionReferenceDepthcomboBox,BorderLayout.NORTH);
		outreferencesPanel.add(outreferencessubPanel);
		if (is_invoked_from_selecting_multiple_addresses)
		{
			outreferencesPanel.add(OutReferencesfromAddressCheckBox);
		}
		//currently, dynamic hooking is not provided
		if (false && (this.current_program.getLanguage().getLanguageID().toString().indexOf("AARCH64:LE:64")>=0 || this.current_program.getLanguage().getLanguageID().toString().indexOf("x86:LE:64")>=0))
		{
			outreferencesPanel.add(OutDynamicCallReferencesfromAddressCheckBox);
			outreferencesPanel.add(OutDynamicCallReferencesfromFunctionCheckBox);
		}
		
		
		rangePanel.add(HookThisAddressCheckBox);
		if (is_invoked_from_selecting_multiple_addresses)
		{
			rangePanel.add(RangeAddressesCheckBox);
			rangeSubPanel1.add(RangeAddressesNumLabel);
			rangeSubPanel1.add(RangeAddressesNumTextField);
			rangeSubPanel1.add(RangeAddressesRadioButtonAddr);
			rangeSubPanel1.add(RangeAddressesRadioButtonInstr);
			rangeSubPanel1.add(RangeAddressesRadioButtonFun);
			rangePanel.add(rangeSubPanel1);
		}
		rangePanel.add(RangeFunctionsCheckBox);
		rangeSubPanel2.add(RangeFunctionsNumLabel);
		rangeSubPanel2.add(RangeFunctionsNumTextField);
		rangeSubPanel2.add(RangeFunctionsRadioButtonAddr);
		//rangeSubPanel2.add(RangeFunctionsRadioButtonInstr);  //Not implemented
		rangeSubPanel2.add(RangeFunctionsRadioButtonFun);
		rangeSubPanel2.add(RangeFunctionsRadioButtonFunBackwards);
		rangePanel.add(rangeSubPanel2);

		
		outputSubPanel1.add(OutputReasonForHookGenCheckbox);
		outputSubPanel1.add(ReasonForHookGenAmountcomboBox);
		outputSubPanel2.add(CustomFunInterceptorHookOutputCheckbox);
		outputSubPanel2.add(CustomFunInterceptorHookOutputcomboBox);
		outputSubPanel3.add(GenerateBacktraceCheckbox);
		outputSubPanel3.add(GenerateBacktracecomboBox);
		outputSubPanel4.add(GenerateScriptCheckbox);
		outputSubPanel4.add(TypeofScriptGenerationcomboBox);
		outputPanel.add(outputSubPanel1,BorderLayout.NORTH);
		outputPanel.add(outputSubPanel2,BorderLayout.NORTH);
		outputPanel.add(outputSubPanel3,BorderLayout.NORTH);
		outputPanel.add(DoNotIncludeFunParamscheckbox,BorderLayout.NORTH);
		outputPanel.add(IncludeFunParamNamescheckbox,BorderLayout.NORTH);
		outputPanel.add(GenerateNormalAddressHooksForFunctionBeginningscheckbox,BorderLayout.NORTH);
		outputPanel.add(outputSubPanel4,BorderLayout.NORTH);
		
		
		if (!is_invoked_from_selecting_multiple_addresses)
		{
			multihookSubPanel1.add(FunctionRegexCheckBox);
			multihookSubPanel1.add(FunctionRegexTextField);
			multihookSubPanel2.add(FunctionMangledNameRegexCheckBox);
			multihookSubPanel2.add(FunctionMangledNameRegexTextField);
			multihookSubPanel3.add(MemoryScanPatternCheckBox);
			multihookSubPanel3.add(MemoryScanPatternTextField);
			multihookPanel.add(multihookSubPanel1);
			multihookPanel.add(multihookSubPanel2);
			multihookPanel.add(multihookSubPanel3);
			multihookPanel.add(HookExportsCheckBox);
			if (true) //Hooking imports toggle
			{
				multihookPanel.add(HookImportsCheckBox);
			}
		}
		
		//now get the preferred size before the window grows too large vertically
		Dimension preferred_sz=mainPanel.getPreferredSize();
		
		
		multihookPanel.add(CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox);
		multihookPanel.add(CreateDataStructureWithInterceptorAttachObjectscheckbox);
		multihookSubPanel4.add(IncludeCustomTextcheckbox);
		multihookSubPanel4.add(IncludeCustomTextTextField);
		multihookPanel.add(multihookSubPanel4);
		multihookSubPanel5.add(IncludeCustomTextAftercheckbox);
		multihookSubPanel5.add(IncludeCustomTextAfterTextField);
		multihookPanel.add(multihookSubPanel5);
		multihookPanel.add(IncludeInterceptorTryCatchcheckbox,BorderLayout.NORTH);
		multihookPanel.add(IncludeTIDAndIndentationcheckbox,BorderLayout.NORTH);
		multihookPanel.add(DoNotHookThunkFunctionscheckbox,BorderLayout.NORTH);
		multihookPanel.add(DoNotHookExternalFunctionscheckbox,BorderLayout.NORTH);
		
		//currently, ChatGPT cannot handle the amount of functions, the feature is not enabled 
		if (false && !is_invoked_from_selecting_multiple_addresses)
		{
			multihookSubPanel6.add(AIChatFunctionRegexCheckBox);
			multihookSubPanel6.add(AIChatFunctionRegexTextField);
			multihookPanel.add(multihookSubPanel6);
		}
		
		//mainPanel.setPreferredSize(mainPanel.getPreferredSize());
		mainPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
		
		JScrollPane scroller = new JScrollPane(mainPanel,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		scroller.getVerticalScrollBar().setUnitIncrement(10); //speed up scrolling a little bit
		JPanel PaneltoReturn = new JPanel();
		PaneltoReturn.setLayout(new BorderLayout());
		PaneltoReturn.add(scroller,BorderLayout.CENTER);
		PaneltoReturn.setPreferredSize(preferred_sz);
		
		return PaneltoReturn;
	}


	public void fetch_advanced_hook_options(Address address, Program prog) {
		fetch_advanced_hook_options(address, prog, tool.getActiveWindow());
	}
	
	
	public void fetch_advanced_hook_options(Address address, Program targetProgram, Component centeredOverComponent) {
		initDialogForAdvancedHookOptions(targetProgram, address);
		tool.showDialog(this, centeredOverComponent);
	}
	
		
	
	protected void initDialogForAdvancedHookOptions(Program p, Address address) {

		this.addr = address;
		this.current_program = p;

		if (!is_invoked_from_selecting_multiple_addresses && address!=null)
		{
			setTitle("Create advanced Frida Hook regarding address " + address);
		}
		else
		{
			//address will be null in this case
			setTitle("Generate advanced Frida Hooks for selection");
		}
		ReferencestoAddressCheckBox.setEnabled(true);
		FunctionsReferencingAddressCheckBox.setEnabled(true);
		ReferencestoFunctionCheckbox.setEnabled(true);
		OutReferencesfromFunctionCheckBox.setEnabled(true);
		OutReferencesfromAddressCheckBox.setEnabled(true);
		FunctionsReferencingFunctionCheckbox.setEnabled(true);
		GenerateScriptCheckbox.setEnabled(true);
		GenerateScriptCheckbox.setSelected(false);
		HookThisAddressCheckBox.setEnabled(true);
		HookThisAddressCheckBox.setSelected(true); //by default, this one is true
		RangeAddressesCheckBox.setEnabled(true);
		RangeFunctionsCheckBox.setEnabled(true);
		OutputReasonForHookGenCheckbox.setEnabled(true);
		CustomFunInterceptorHookOutputCheckbox.setEnabled(true);
		DoNotIncludeFunParamscheckbox.setEnabled(true);
		IncludeFunParamNamescheckbox.setEnabled(true);
		GenerateNormalAddressHooksForFunctionBeginningscheckbox.setEnabled(true);
		IncludeCustomTextcheckbox.setEnabled(true);
		FunctionRegexCheckBox.setEnabled(true);
		FunctionMangledNameRegexCheckBox.setEnabled(true);
		MemoryScanPatternCheckBox.setEnabled(true);
		HookExportsCheckBox.setEnabled(true);
		HookImportsCheckBox.setEnabled(true);
		GenerateBacktraceCheckbox.setEnabled(true);
		CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox.setEnabled(true);
		CreateDataStructureWithInterceptorAttachObjectscheckbox.setEnabled(true);
		IncludeCustomTextcheckbox.setEnabled(true);
		IncludeCustomTextAftercheckbox.setEnabled(true);
		IncludeInterceptorTryCatchcheckbox.setEnabled(true);
		IncludeTIDAndIndentationcheckbox.setEnabled(true);
		DoNotHookThunkFunctionscheckbox.setEnabled(true);
		DoNotHookExternalFunctionscheckbox.setEnabled(true);
		OutDynamicCallReferencesfromFunctionCheckBox.setEnabled(true);
		OutDynamicCallReferencesfromAddressCheckBox.setEnabled(true);
		AIChatFunctionRegexCheckBox.setEnabled(true);

		clearStatusText();

	}
		
	protected void okCallback() {
		this.isOKpressed=true;
		
		if (ReferencestoAddressCheckBox.isEnabled() && ReferencestoAddressCheckBox.isSelected()) {
			this.isReferencestoAddressCheckBoxchecked=true;
		}
		
		if (FunctionsReferencingAddressCheckBox.isEnabled() && FunctionsReferencingAddressCheckBox.isSelected()) {
			this.isFunctionsReferencingAddressCheckBoxchecked=true;
		}
		
		if (ReferencestoFunctionCheckbox.isEnabled() && ReferencestoFunctionCheckbox.isSelected()) {
			this.isReferencestoFunctionCheckboxchecked=true;
		}
		
		if (FunctionsReferencingFunctionCheckbox.isEnabled() && FunctionsReferencingFunctionCheckbox.isSelected()) {
			this.isFunctionsReferencingFunctionCheckboxchecked=true;
		}
		
		if (OutReferencesfromFunctionCheckBox.isEnabled() && OutReferencesfromFunctionCheckBox.isSelected()) {
			this.isOutReferencesfromFunctionCheckBoxchecked=true;
		}
		
		if (OutReferencesfromAddressCheckBox.isEnabled() && OutReferencesfromAddressCheckBox.isSelected()) {
			this.isOutReferencesfromAddressCheckBoxchecked=true;
		}
		if (OutDynamicCallReferencesfromAddressCheckBox.isEnabled() && OutDynamicCallReferencesfromAddressCheckBox.isSelected()) {
			this.isOutDynamicCallReferencesfromAddressCheckBoxchecked=true;
		}
		if (OutDynamicCallReferencesfromFunctionCheckBox.isEnabled() && OutDynamicCallReferencesfromFunctionCheckBox.isSelected()) {
			this.isOutDynamicCallReferencesfromFunctionCheckBoxchecked=true;
		}
		
		if (GenerateScriptCheckbox.isEnabled() && GenerateScriptCheckbox.isSelected()) {
			this.isGenerateScriptCheckboxchecked=true;
		}
		if (OutputReasonForHookGenCheckbox.isEnabled() && OutputReasonForHookGenCheckbox.isSelected()) {
			this.isOutputReasonForHookGenCheckboxchecked=true;
		}
		
		
		if (HookThisAddressCheckBox.isEnabled() && HookThisAddressCheckBox.isSelected())
		{
			this.isHookThisAddressCheckBoxchecked=true;
		}
		
		if (RangeAddressesCheckBox.isEnabled() && RangeAddressesCheckBox.isSelected()) {
			this.isRangeAddressesCheckBoxchecked=true;
			RangeAddressesNum=0;
			try {
				long tmplong=Long.parseLong(RangeAddressesNumTextField.getText());
				if (tmplong>2000000000)
				{
					RangeAddressesNum=2000000000;
				}
				else
				{
					RangeAddressesNum=(int)tmplong;
				}
			}
			catch (NumberFormatException ex)
			{
				RangeAddressesNum=0;
			}
			if (RangeAddressesNum<0)
			{
				RangeAddressesNum=0;
			}
		}
		
		if (RangeFunctionsCheckBox.isEnabled() && RangeFunctionsCheckBox.isSelected()) {
			this.isRangeFunctionsCheckBoxchecked=true;
			RangeFunctionsNum=0;
			try {
				long tmplong=Long.parseLong(RangeFunctionsNumTextField.getText());
				if (tmplong>2000000000)
				{
					RangeFunctionsNum=2000000000;
				}
				else
				{
					RangeFunctionsNum=(int)tmplong;
				}
			}
			catch (NumberFormatException ex)
			{
				RangeFunctionsNum=0;
			}
			if (RangeFunctionsNum<0)
			{
				RangeFunctionsNum=0;
			}
		}
		if (FunctionRegexCheckBox.isEnabled() && FunctionRegexCheckBox.isSelected()) {
			this.isFunctionRegexCheckBoxchecked=true;
		}
		if (FunctionMangledNameRegexCheckBox.isEnabled() && FunctionMangledNameRegexCheckBox.isSelected()) {
			this.isFunctionMangledNameRegexCheckBoxchecked=true;
		}
		if (MemoryScanPatternCheckBox.isEnabled() && MemoryScanPatternCheckBox.isSelected()) {
			this.isMemoryScanPatternCheckBoxchecked=true;
		}
		if (HookExportsCheckBox.isEnabled() && HookExportsCheckBox.isSelected())
		{
			this.isHookExportsCheckBoxchecked=true;
		}
		if (HookImportsCheckBox.isEnabled() && HookImportsCheckBox.isSelected())
		{
			this.isHookImportsCheckBoxchecked=true;
		}
		if (CustomFunInterceptorHookOutputCheckbox.isEnabled() && CustomFunInterceptorHookOutputCheckbox.isSelected()) {
			this.isCustomFunInterceptorHookOutputCheckboxchecked=true;
		}
		if (DoNotIncludeFunParamscheckbox.isEnabled() && DoNotIncludeFunParamscheckbox.isSelected()) {
			this.isDoNotIncludeFunParamscheckboxchecked=true;
		}
		if (IncludeFunParamNamescheckbox.isEnabled() && IncludeFunParamNamescheckbox.isSelected()) {
			this.isIncludeFunParamNamescheckboxchecked=true;
		}
		if (GenerateNormalAddressHooksForFunctionBeginningscheckbox.isEnabled() && GenerateNormalAddressHooksForFunctionBeginningscheckbox.isSelected())
		{
			this.isGenerateNormalAddressHooksForFunctionBeginningscheckboxchecked=true;
		}	
		if (CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox.isEnabled() && CreateDataStructuresToLinkAddressesAndFunctionNamescheckbox.isSelected()) {
			this.isCreateDataStructuresToLinkAddressesAndFunctionNamescheckboxchecked=true;
		}
		if (CreateDataStructureWithInterceptorAttachObjectscheckbox.isEnabled() && CreateDataStructureWithInterceptorAttachObjectscheckbox.isSelected()) {
			this.isCreateDataStructureWithInterceptorAttachObjectscheckboxchecked=true;
		}
		if (IncludeCustomTextcheckbox.isEnabled() && IncludeCustomTextcheckbox.isSelected()) {
			this.isIncludeCustomTextcheckboxchecked=true;
		}
		if (IncludeCustomTextAftercheckbox.isEnabled() && IncludeCustomTextAftercheckbox.isSelected()) {
			this.isIncludeCustomTextAftercheckboxchecked=true;
		}
		if (IncludeInterceptorTryCatchcheckbox.isEnabled() && IncludeInterceptorTryCatchcheckbox.isSelected())
		{
			this.isIncludeInterceptorTryCatchcheckboxchecked=true;
		}
		if (IncludeTIDAndIndentationcheckbox.isEnabled() && IncludeTIDAndIndentationcheckbox.isSelected())
		{
			this.isIncludeTIDAndIndentationcheckboxchecked=true;
		}
		if (DoNotHookThunkFunctionscheckbox.isEnabled() && DoNotHookThunkFunctionscheckbox.isSelected())
		{
			this.isDoNotHookThunkFunctionscheckboxchecked=true;
		}
		if (DoNotHookExternalFunctionscheckbox.isEnabled() && DoNotHookExternalFunctionscheckbox.isSelected())
		{
			this.isDoNotHookExternalFunctionscheckboxchecked=true;
		}

		if (GenerateBacktraceCheckbox.isEnabled() && GenerateBacktraceCheckbox.isSelected()) {
			this.isGenerateBacktraceCheckboxchecked=true;
		}
			
		if (AIChatFunctionRegexCheckBox.isEnabled() && AIChatFunctionRegexCheckBox.isSelected())
		{
			this.isAIChatFunctionRegexCheckBoxchecked=true;
		}
		
		//Mutual exclusion:
		if (this.isIncludeTIDAndIndentationcheckboxchecked && this.isCustomFunInterceptorHookOutputCheckboxchecked)
		{
			if (this.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==0 ||  //for OnEnter() blocking
				this.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==1 )   //for OnLeave() blocking
			{
				this.isCustomFunInterceptorHookOutputCheckboxchecked=false;
			}
		}

		
		close();
	}
	

}


```

`src/main/java/fridahookgenerator/ChatGPTAPICaller.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;

import ghidra.util.task.TaskMonitor;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * IMPORTANT: This does not work well.
 * In the general case, the number of functions is too large, and ChatGPT cannot process them all.
 * Ideally, a local GPT solution can be used but sufficiently powerful hardware will be needed, 
 * and it would also be good to have a model trained on very large inputs.
 * As of now, AI integration is not included in the functionality of the plugin.
 */
public class ChatGPTAPICaller {
	
	enum Errortype {
		NO_ERROR,
	    API_KEY_FILE_ERROR,
	    CANT_CONNECT,
	    UNEXPECTED_RESPONSE
	  };
	
	String url = "https://api.openai.com/v1/chat/completions";
    String apiKey = "API_KEY_PLACEHOLDER";
    String model = "gpt-3.5-turbo"; //"gpt-4o";
    String chatgpt_apikey_filepath=System.getProperty("user.home")+"/.ghidra/chatgpt_apikey.txt";
    TaskMonitor incoming_monitor;
    
    String prompt_for_many_functions1="First, disregard all previous messages as there is a new task for you. Also, clear any function name counters you were holding, set them to 0.\\n Here is the task. You will be given a list of function names, with numbers assigned to them. In the end you will be required to provide only the list of numbers corresponding to the function names that seem related to ";
    String prompt_for_many_functions2=". You will have to return only the numbers in the end (separated by commas), nothing else.\\n"
    		+ "The list of function names will start from the next message, may span across multiple messages, and will end when the string 'END_OF_LIST_OF_FUNCTIONS' is sent by me.\\n "
    		+ "For every intermediate message as the function names are being sent, only reply with the total number of function names you have ingested so far (not the names themselves), and don't say anything else. At the end, when the list of function names is complete, only output the list of  the corresponding numbers you have created. ";
    
    String prompt_for_intermediate_message1="Here are the function names for this intermediate message (which is the message at position ";
    String prompt_for_intermediate_message2="), each function name in a separate line, preceded by a number corresponding to it. Remember, do not answer just yet, only acknowlege the total number of function names you have received so far in this message, and in total for all the messages you have received from the beginning of this task. Do not send the canary string specified in the first message, at the start of the instructions.\\n```\\n";
    String finalmessage1="END_OF_LIST_OF_FUNCTIONS\\nNow, only provide the list of numbers you were instructed to create (and nothing else), separated by commas, and the numbers correspond to the function names that seem related to ";
    String finalmessage2="\\nDo not output anything else other than the list of numbers itself.\\n";
    
    ArrayList<String> pastprompts_user;
    ArrayList<String> pastprompts_assistant;
    
    public ChatGPTAPICaller(TaskMonitor incoming_monitor) {
    	this.incoming_monitor=incoming_monitor;
    	this.pastprompts_user=new ArrayList<String>();
    	this.pastprompts_assistant=new ArrayList<String>();
    	Errortype errortype;
    	errortype=this.get_api_key_from_disk();
    	if (errortype==Errortype.API_KEY_FILE_ERROR)
    	{
    		System.out.println("Error in reading chatgpt api key file");
    	}

    	
    }
    
    public String askchatGPT_multiplemessages(String category,ArrayList<String> function_names)
    {
    	String retval="";
    	String first_prompt=this.prompt_for_many_functions1+category+this.prompt_for_many_functions2;
    	
    	System.out.println(first_prompt);
    	String first_reply=askchatGPT_onemessage(first_prompt);
    	System.out.println(first_reply);
    	
    	int total_function_names=function_names.size();
    	int total_messages=1;
    	int function_names_to_be_sent_in_each_batch=300;
    	int num_of_names_included_in_this_batch=0;
    	String function_names_to_be_sent_in_this_batch="";
    	
    	//Iterate on all function names and send their names in batches
    	for (int i=0;i<total_function_names;i++)
    	{
    		if (i%20==0)
    		{
    			this.incoming_monitor.setMessage("Sending function names to ChatGPT..."+Integer.toString(i)+"/"+Integer.toString(total_function_names));
    			if (this.incoming_monitor.isCancelled()) {return "CANCELLED";} //check for cancellation by the user
    		}
    		num_of_names_included_in_this_batch++;
    		function_names_to_be_sent_in_this_batch+=i+" "+function_names.get(i)+"\\n";
    		if (num_of_names_included_in_this_batch==function_names_to_be_sent_in_each_batch || i==total_function_names-1)
    		{
    			try {
    				//sleep for a bit so that we don't hit the API too much
					Thread.sleep(200);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
    			total_messages++;
    			String intermediate_reply=askchatGPT_onemessage(this.prompt_for_intermediate_message1+total_messages+this.prompt_for_intermediate_message2+function_names_to_be_sent_in_this_batch+"\\n```");
    			System.out.println(intermediate_reply);
    			function_names_to_be_sent_in_this_batch="";
    			num_of_names_included_in_this_batch=0;
    		}
    	}
    	retval=askchatGPT_onemessage(this.finalmessage1+category+this.finalmessage2);
    	return retval;
    }
	
    //https://rollbar.com/blog/how-to-use-chatgpt-api-with-java/#
	 public String askchatGPT_onemessage(String prompt) {
	       
	       try {
	           URL obj = new URI(this.url).toURL();
	           HttpURLConnection connection = (HttpURLConnection) obj.openConnection();
	           connection.setRequestMethod("POST");
	           connection.setRequestProperty("Authorization", "Bearer " + apiKey);
	           connection.setRequestProperty("Content-Type", "application/json");

	           
	           this.pastprompts_user.add(prompt); //add the message to the past messages
	           
	           // The request body must also include the past conversation
	           String body = "{\"model\": \"" + model + "\", \"messages\": "+this.create_json_body_with_all_messages()+"}";
	           connection.setDoOutput(true);
	           OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
	           writer.write(body);
	           writer.flush();
	           writer.close();

	           // Response from ChatGPT
	           BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
	           String line;

	           StringBuffer response = new StringBuffer();

	           while ((line = br.readLine()) != null) {
	               response.append(line);
	           }
	           br.close();

	           // calls the method to extract the message.
	           String return_message=extractMessageFromJSONResponse(response.toString());
	           this.pastprompts_assistant.add(return_message); //add it to the list of received messages
	           return return_message;

	       } catch (IOException e) {
	           throw new RuntimeException(e);
	       } catch (URISyntaxException e)
	       {
	    	   //the URL is fixed so we won't go here
	    	   throw new RuntimeException(e);
	       }
	 	
	   }
	 
	   //Add all observed past messages
	   public String create_json_body_with_all_messages()
	   {
		   String retval="[";
		   for (int i=0;i<this.pastprompts_user.size();i++)
		   {
			   retval+="{\"role\": \"user\", \"content\": \"" + this.pastprompts_user.get(i) + "\"}";
			   if (i<this.pastprompts_assistant.size())
			   {
				   retval+=",{\"role\": \"assistant\", \"content\": \"" + this.pastprompts_assistant.get(i) + "\"},";
			   }
		   }
		   retval+="]";
		   return retval;
	   }

	   public String extractMessageFromJSONResponse(String response) {
	       int start = response.indexOf("content")+ 11;

	       int end = response.indexOf("\"", start);

	       return response.substring(start, end);

	   }
	   
	   public  Errortype get_api_key_from_disk()
	   {
		   BufferedReader reader;

			try {
				reader = new BufferedReader(new FileReader(chatgpt_apikey_filepath));
				String line = reader.readLine();
				this.apiKey=line;
				reader.close();
				return Errortype.NO_ERROR;
			} catch (IOException e) {
				return Errortype.API_KEY_FILE_ERROR;
			}
	   }

}

```

`src/main/java/fridahookgenerator/ComputedCallHookGenerator.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import fridahookgenerator.ParsersOfComputedCalls.ARM64ParserOfComputedCall;
import fridahookgenerator.ParsersOfComputedCalls.X86ParserOfComputedCall;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.listing.Program;

public class ComputedCallHookGenerator {

	private HookGenerator incoming_hook_generator;
	private Program incoming_program;
	private Language current_program_language;
	private Processor current_program_processor;
	private Address incoming_address;
	private String arg_of_call;
	private String mnemonic_of_command;
	private String incoming_module_name_sanitized;
	private ParserOfComputedCalls parser_of_computed_calls;
	
	public ComputedCallHookGenerator(HookGenerator incoming_hook_generator,Program incoming_program, Address incoming_address, String mnemonic_of_command, String arg_of_call, String incoming_module_name) {
		this.incoming_hook_generator=incoming_hook_generator;
		this.incoming_program=incoming_program;
		this.current_program_language = this.incoming_program.getLanguage();
		this.current_program_processor = this.current_program_language.getProcessor();
		this.incoming_address=incoming_address;
		this.mnemonic_of_command=mnemonic_of_command;
		this.arg_of_call=arg_of_call;
		this.incoming_module_name_sanitized=incoming_module_name;
		if (this.current_program_language.getLanguageID().toString().indexOf("x86:LE:")>=0)
		{
			parser_of_computed_calls=new X86ParserOfComputedCall(this.incoming_program,this.incoming_module_name_sanitized);
		}
		else if (this.current_program_language.getLanguageID().toString().indexOf("AARCH64:LE:64")>=0)
		{
			parser_of_computed_calls=new ARM64ParserOfComputedCall(this.incoming_program,this.incoming_module_name_sanitized);
		}
		else
		{
			parser_of_computed_calls=null;
		}
	}
	
	public String provide_hook_code(String spaces)
	{
		String retval="";
	
		if (this.parser_of_computed_calls==null)
		{
			//Unsupported architecture
			return "";
		}
			
		
		
		retval+= spaces+"var calculated_target_address_for_initial_address_"+this.incoming_address+"="+this.parser_of_computed_calls.create_frida_code_for_call_arg(this.mnemonic_of_command ,this.arg_of_call)+";\n";
		retval+= spaces+"//Find the module in which the target address falls\n";
		retval+= spaces+"var modulemap_for_all_modules=new ModuleMap();\n";
		retval+= spaces+"var module_containing_target_address=modulemap_for_all_modules.find(calculated_target_address_for_initial_address_"+this.incoming_address+");\n";
		retval+= spaces+"if (module_containing_target_address!=null)\n";
		retval+= spaces+"{\n";
		retval+= spaces+"    var offset_from_module_start_for_target_address_for_initial_address_"+this.incoming_address+"=calculated_target_address_for_initial_address_"+this.incoming_address+".sub(module_containing_target_address.base);\n";
		retval+= spaces+"    console.log("+this.incoming_hook_generator.utils.tid_and_indent_code()+"\"Next destination (after the "+this.mnemonic_of_command+" at address "+this.incoming_address+" ) will be to address \"+calculated_target_address_for_initial_address_"+this.incoming_address+"+\", which has offset \"+offset_from_module_start_for_target_address_for_initial_address_"+this.incoming_address+"+\" relative to the module \"+ JSON.stringify(module_containing_target_address));\n";
		retval+= spaces+"    console.log("+this.incoming_hook_generator.utils.tid_and_indent_code()+"\"Debug information on the target address: \"+JSON.stringify(DebugSymbol.fromAddress(calculated_target_address_for_initial_address_"+this.incoming_address+")));\n";
		retval+= spaces+"    //Interceptor.attach(calculated_target_address_for_initial_address_"+this.incoming_address+",function(){console.log(\"Reached target addess from computed call\")})\n";
		retval+= spaces+"}\n";
		retval+= spaces+"else\n";
		retval+= spaces+"{\n";
		retval+= spaces+"    console.log("+this.incoming_hook_generator.utils.tid_and_indent_code()+"\"calculated target address \"+calculated_target_address_for_initial_address_"+this.incoming_address+"+\" does not fall inside any of the known modules\");\n";
		retval+= spaces+"}\n";
		return retval;
	}
	
}

```

`src/main/java/fridahookgenerator/FridaHookGeneratorAPIHandler.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package fridahookgenerator;

import java.util.ArrayList;
import java.util.stream.Collectors;

import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.GenericAddress;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;

/*
 * This class gives an API to Ghidra Scripts to invoke the Hook Generator with a list of addresses.
 * Under the hood, it invokes the SelectionHookGenerationTaskDispatcher class with the provided addresses.
 *  
 */

/*Example in python scripting:
 
 
from fridahookgenerator import AdvancedHookOptionsDialog,FridaHookGeneratorAPIHandler
apihandler=FridaHookGeneratorAPIHandler(state.getTool(),currentProgram,"0073b575,0073b5a0");
hook_str=apihandler.perform_hook_generation()


The list of addresses must be given as a string of hex (Ghidra) addresses, without 0x in the front. If their negative value is given (e.g. -0073b575), then the address is explicitly excluded from hooking.
This will spawn an AdvancedHookOptionsDialog whose options will be used to hook all the addresses.

That dialog can also be customized programmatically (in that case, it will not be shown, and also the hook will not be shown into the console, as the user will have to print it):


from fridahookgenerator import AdvancedHookOptionsDialog,FridaHookGeneratorAPIHandler

advdialog=AdvancedHookOptionsDialog(state.getTool(),currentProgram)
advdialog.isReferencestoFunctionCheckboxchecked=True
advdialog.isFunctionsReferencingFunctionCheckboxchecked=True
advdialog.IncludeCustomTextTextField.setText("console.log('currentaddr:'+this.context.pc)")
advdialog.isIncludeCustomTextcheckboxchecked=True
apihandler=FridaHookGeneratorAPIHandler(state.getTool(),currentProgram,"0073b575,0073b5a0",advdialog);
hook_str=apihandler.perform_hook_generation()
print(hook_str)




The API can also be used to generate struct offsets. For example:

from fridahookgenerator import AdvancedHookOptionsDialog,FridaHookGeneratorAPIHandler
from ghidra.program.model.data import Structure;

datatypemanager=currentProgram.getDataTypeManager()
for dt in datatypemanager.getAllDataTypes():
	if "ELF" in dt.getPathName() and isinstance(dt,Structure):  #you can put any string here
		print(dt.getPathName())
		#here recursive struct offset is done (the first True), you might not want that. The "False" means "do not output"
		apihandler=FridaHookGeneratorAPIHandler(state.getTool(),currentProgram,dt,True,False);  
		hook_str=apihandler.perform_hook_generation()
		print(hook_str)

You can also put structure paths which will be explicitly excluded from the offset generation:
		apihandler=FridaHookGeneratorAPIHandler(state.getTool(),currentProgram,dt,"/ELF/Gnu_DebugLink,/ELF/Elf64_Sym",True,False);  

 */

public class FridaHookGeneratorAPIHandler {

	private ArrayList<CodeUnit> incoming_list_of_CodeUnits;
	private ArrayList<CodeUnit> incoming_list_of_CodeUnits_to_exclude;
	private Program current_program;
	private PluginTool incoming_plugintool;
	private AdvancedHookOptionsDialog advancedhookoptionsdialog;
	private Boolean was_invoked_with_defined_advancedhookoptionsdialog;
	private Boolean was_invoked_to_generate_offsets_for_struct;
	private Boolean was_invoked_to_generate_hook_for_addresses;
	private Structure incoming_structure;
	private String[] list_of_paths_to_be_excluded;
	private Boolean should_recurse_on_struct_offset_generation;
	private Boolean should_output_on_struct_offset_generation;
	
	
	
	public FridaHookGeneratorAPIHandler(PluginTool plugintool, Program incoming_program,String list_of_addresses) {
		
		this.current_program=incoming_program;
		this.incoming_plugintool=plugintool;
		this.was_invoked_with_defined_advancedhookoptionsdialog=false;
		this.was_invoked_to_generate_offsets_for_struct=false;
		this.was_invoked_to_generate_hook_for_addresses=true;
		this.incoming_list_of_CodeUnits=extract_codeunits_from_string_of_addresses(list_of_addresses);
		this.incoming_list_of_CodeUnits_to_exclude=extract_codeunits_to_be_excluded_from_string_of_addresses(list_of_addresses);
	}
	
	public FridaHookGeneratorAPIHandler(PluginTool plugintool, Program incoming_program,String list_of_addresses, AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog) {
		
		this.current_program=incoming_program;
		this.incoming_plugintool=plugintool;
		this.advancedhookoptionsdialog=incoming_advancedhookoptionsdialog;
		this.was_invoked_with_defined_advancedhookoptionsdialog=true;
		this.was_invoked_to_generate_offsets_for_struct=false;
		this.was_invoked_to_generate_hook_for_addresses=true;
		this.incoming_list_of_CodeUnits=extract_codeunits_from_string_of_addresses(list_of_addresses);
		this.incoming_list_of_CodeUnits_to_exclude=extract_codeunits_to_be_excluded_from_string_of_addresses(list_of_addresses);
	}
	
	public FridaHookGeneratorAPIHandler(PluginTool plugintool, Program incoming_program,Structure incoming_structure, Boolean should_recurse ,Boolean should_output ) {
		
		this.current_program=incoming_program;
		this.incoming_plugintool=plugintool;
		this.was_invoked_with_defined_advancedhookoptionsdialog=false;
		this.was_invoked_to_generate_offsets_for_struct=true;
		this.was_invoked_to_generate_hook_for_addresses=false;
		this.incoming_structure=incoming_structure;
		this.should_recurse_on_struct_offset_generation=should_recurse;
		this.should_output_on_struct_offset_generation=should_output;
		this.list_of_paths_to_be_excluded=new String[0];
	}
	
	public FridaHookGeneratorAPIHandler(PluginTool plugintool, Program incoming_program,Structure incoming_structure,String list_of_paths_to_be_excluded, Boolean should_recurse ,Boolean should_output ) {
		
		this.current_program=incoming_program;
		this.incoming_plugintool=plugintool;
		this.was_invoked_with_defined_advancedhookoptionsdialog=false;
		this.was_invoked_to_generate_offsets_for_struct=true;
		this.was_invoked_to_generate_hook_for_addresses=false;
		this.incoming_structure=incoming_structure;
		this.should_recurse_on_struct_offset_generation=should_recurse;
		this.should_output_on_struct_offset_generation=should_output;
		this.list_of_paths_to_be_excluded=list_of_paths_to_be_excluded.split(",");
		for (int i=0;i<this.list_of_paths_to_be_excluded.length;i++)
		{
			this.list_of_paths_to_be_excluded[i]=this.list_of_paths_to_be_excluded[i].strip();
		}
	}
	
	
	ArrayList<CodeUnit> extract_codeunits_from_string_of_addresses(String list_of_addresses)
	{
		ArrayList<CodeUnit> retval=new ArrayList<CodeUnit>(); 
		String[] str_parts=list_of_addresses.split(",");
		Listing current_program_listing=this.current_program.getListing();
		
		for (int i=0;i<str_parts.length;i++)
		{

			if (str_parts[i].indexOf("-")<0)  //if '-' is present, we must ignore the address
			{
				//try to decode 
				long tmplong=-1;
				try {
					tmplong=Long.parseLong(str_parts[i],16);
				}
				catch (NumberFormatException ex)
				{
					//nothing, this address will not be put into the list
				}
				if (tmplong!=-1)
				{
					//a Program may have multiple addresses spaces, but we will only take the address belonging to the first. TODO
					Address[] array_of_addresses_for_this_addr=this.current_program.parseAddress(str_parts[i]);
					if (array_of_addresses_for_this_addr.length>0 && current_program_listing.getCodeUnitAt(array_of_addresses_for_this_addr[0])!=null)
					{
						retval.add(current_program_listing.getCodeUnitAt(array_of_addresses_for_this_addr[0]));
					}
				}
			}
		}
		
		return retval;
	}
	
	ArrayList<CodeUnit> extract_codeunits_to_be_excluded_from_string_of_addresses(String list_of_addresses)
	{
		ArrayList<CodeUnit> retval=new ArrayList<CodeUnit>(); 
		String[] str_parts=list_of_addresses.split(",");
		Listing current_program_listing=this.current_program.getListing();
		
		for (int i=0;i<str_parts.length;i++)
		{

			if (str_parts[i].indexOf("-")==0)  //we must only put into the retval the addresses that have a negative number
			{
				//try to decode 
				long tmplong=-1;
				try {
					tmplong=Long.parseLong(str_parts[i],16);
				}
				catch (NumberFormatException ex)
				{
					//nothing, this address will not be put into the list
				}
				if (tmplong!=-1)
				{
					//a Program may have multiple addresses spaces, but we will only take the address belongng to the first. TODO
					Address[] array_of_addresses_for_this_addr=this.current_program.parseAddress(str_parts[i].substring(1));
					if (array_of_addresses_for_this_addr.length>0 && current_program_listing.getCodeUnitAt(array_of_addresses_for_this_addr[0])!=null)
					{
						retval.add(current_program_listing.getCodeUnitAt(array_of_addresses_for_this_addr[0]));
					}
				}
			}
		}
		
		//return the distinct code units
		return (ArrayList<CodeUnit>) retval.stream().distinct().collect(Collectors.toList());
	}
	
	
	
	public String perform_hook_generation()
	{
		String retval="";
		
		if (this.was_invoked_to_generate_hook_for_addresses)
		{
			SelectionHookGenerationTaskDispatcher dispatcher;
			if (this.was_invoked_with_defined_advancedhookoptionsdialog)
			{
				dispatcher= new SelectionHookGenerationTaskDispatcher(this.incoming_plugintool,this.current_program,this.incoming_list_of_CodeUnits,this.incoming_list_of_CodeUnits_to_exclude,this.advancedhookoptionsdialog);
			}
			else
			{
				dispatcher= new SelectionHookGenerationTaskDispatcher(this.incoming_plugintool,this.current_program,this.incoming_list_of_CodeUnits,this.incoming_list_of_CodeUnits_to_exclude);
			}
			
			retval= dispatcher.perform_selection_hook_action();
			
		}
		
		if (this.was_invoked_to_generate_offsets_for_struct)
		{
			StructAccessCodeGenerator structaccesscodegen=new StructAccessCodeGenerator(this.incoming_plugintool,this.current_program,this.incoming_structure,this.list_of_paths_to_be_excluded,this.should_recurse_on_struct_offset_generation,true,this.should_output_on_struct_offset_generation);
			retval=structaccesscodegen.generate_hook_str(); //will output if configured
		}
		
		
		return retval;
	}
	
	
}

```

`src/main/java/fridahookgenerator/FridaHookGeneratorPlugin.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;


import ghidra.app.plugin.PluginCategoryNames;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.services.ConsoleService;
import ghidra.framework.model.ToolServices;
import ghidra.framework.plugintool.*;
import ghidra.framework.plugintool.util.PluginStatus;
import ghidra.util.HelpLocation;
import ghidra.util.Msg;
import ghidra.util.table.GhidraTable;
import ghidra.util.task.TaskMonitor;
import resources.Icons;

import java.awt.datatransfer.StringSelection;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.awt.Toolkit;
import java.awt.Window;
import java.awt.datatransfer.Clipboard;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import docking.action.MenuData;

import ghidra.app.context.ListingActionContext;
import ghidra.app.context.ListingContextAction;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.CodeUnitIterator;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.program.util.OperandFieldLocation;
import ghidra.program.util.ProgramLocation;



//@formatter:off
@PluginInfo(
	status = PluginStatus.STABLE,
	packageName = "Frida Hook Generator",
	category = PluginCategoryNames.COMMON,
	shortDescription = "This plugin provides right-click options for fast generation of Frida hooks",
	description = "This plugin generates a right-click options for fast generation of Frida hook code, for specified addresses in the binary. That (Javascript) code can be run through Frida, and at the very least it will report when the code reaches the specified points. When the hooked address is the start of a function, the plugin generates a hook with Interceptor's onEnter()/onLeave() calls. When the code is not at the start of the function, the plugin generates hooks without these calls."
	//servicesRequired = { ConsoleService.class}
)
//@formatter:on
public class FridaHookGeneratorPlugin extends ProgramPlugin {

	GenerateFridaHookScriptAction FridaHookScriptAction;
	GenerateFridaHookScriptAction FridaHookSnippetAction;
	GenerateFridaHookScriptAction FridaHookAdvancedAction;
	SelectionHookGenerationAction SearchSelectionAction;
	StructAccessCodeGenerationAction StructAccessAction;
	
	/**
	 * Plugin constructor.
	 * 
	 * @param tool The plugin tool that this plugin is added to.
	 */
	public FridaHookGeneratorPlugin(PluginTool tool) {
		//super(tool, true, true);
		super(tool);

		String pluginName = getName();
		Boolean isSnippet=false;
		Boolean isAdvanced=false;
		//first, create the class for script
		FridaHookScriptAction = new GenerateFridaHookScriptAction(tool, pluginName,isSnippet,isAdvanced);
		tool.addAction(FridaHookScriptAction);
		
		isSnippet=true;
		//second, create the class for snippet
		FridaHookSnippetAction = new GenerateFridaHookScriptAction(tool, pluginName,isSnippet,isAdvanced);
		tool.addAction(FridaHookSnippetAction);
		
		
		isAdvanced=true;
		//third, create the option for the advanced hook generation
		FridaHookAdvancedAction = new GenerateFridaHookScriptAction(tool, pluginName,isSnippet,isAdvanced);
		tool.addAction(FridaHookAdvancedAction);
		

		// TODO: Customize help
		String topicName = this.getClass().getPackage().getName();
		String anchorName = "HelpAnchor for FridaHookAction";
		FridaHookScriptAction.setHelpLocation(new HelpLocation(topicName, anchorName));
		
		/*Now add the plugin part which allows for hook generation based on a selection*/
		SearchSelectionAction=new SelectionHookGenerationAction(this,this.getProgramSelection());
		tool.addAction(SearchSelectionAction);
		
		/*And the plugin part which allows for generation of code for struct getters and setters*/
		StructAccessAction=new StructAccessCodeGenerationAction(this,false);
		tool.addAction(StructAccessAction);
		
		/*And the same thing, but also recursively for substructs*/ 
		StructAccessAction=new StructAccessCodeGenerationAction(this,true);
		tool.addAction(StructAccessAction);
				
	}

	@Override
	public void init() {
		super.init();

		// TODO: Acquire services if necessary
	}
	
}



```

`src/main/java/fridahookgenerator/GenerateFridaHookScriptAction.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Pattern;

import docking.action.MenuData;
import ghidra.app.context.ListingActionContext;
import ghidra.app.context.ListingContextAction;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.CodeUnitIterator;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.program.util.OperandFieldLocation;
import ghidra.program.util.ProgramLocation;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;


public class GenerateFridaHookScriptAction extends ListingContextAction {

	private PluginTool incoming_plugintool;
	private Boolean isSnippet;
	private Boolean isAdvanced;
	protected String final_hook_str;
	private StandardHookGenerationTask hook_generation_task;
	private ConsoleService consoleService;
	private AdvancedHookOptionsDialog advancedhookoptionsdialog;
	private InternalStructuresForHookGeneration internal_structures_for_hook_generation;
	
	public GenerateFridaHookScriptAction(PluginTool tool, String owner, Boolean isSnippet, Boolean isAdvanced)
	{
		super("Copy Frida Hook Script or Snippet", owner);
		this.incoming_plugintool = tool;
		this.isSnippet = isSnippet;
		this.isAdvanced = isAdvanced;
		

		/*Create the 3 submenus*/
		if (isSnippet && !isAdvanced) {
			setPopupMenuData(new MenuData(new String[] { "Copy Frida Hook Snippet" },null,"Frida-Hook"));
		}
		else if (!isSnippet && !isAdvanced)
		{
			setPopupMenuData(new MenuData(new String[] { "Copy Frida Hook Script" },null,"Frida-Hook"));
			//setKeyBindingData(new KeyBindingData(KeyEvent.VK_H, 0));
		}
		else if (isAdvanced)
		{
			setPopupMenuData(new MenuData(new String[] { "Create Advanced Frida Hook..." },null,"Frida-Hook"));
		}
	}
	
	
	@Override
	protected boolean isEnabledForContext(ListingActionContext context) {
		return context.getAddress() != null;
	}

	@Override
	protected void actionPerformed(ListingActionContext context) {
		System.out.println("Called Action Performed");
		
		//Initialize the console
		this.consoleService=this.incoming_plugintool.getService(ConsoleService.class); //Note: If this line is called in the constructor, then the consoleService may be null
		//Next, initialize the dialog and the state for the hook generation
		this.internal_structures_for_hook_generation=new InternalStructuresForHookGeneration();
		
		Program current_program=context.getProgram();
		this.advancedhookoptionsdialog = new AdvancedHookOptionsDialog("Advanced Frida Hook Options",this.incoming_plugintool,current_program,false);
		String hook_str="";
		
		
		Address addr;
		ProgramLocation location;
		addr=context.getAddress();
		location = context.getLocation();
		/*Follow the location reference if it is present*/
		if (location instanceof OperandFieldLocation) {
			Address a = ((OperandFieldLocation) location).getRefAddress();
			if (a != null) {
				addr = a;
			}
		}
		System.out.println("Location:"+location);
		System.out.println("Program:"+current_program);
		System.out.println("Address:"+addr);
		
		if (this.isAdvanced)
		{
			System.gc(); //If advanced hooks are created many times, this may lead to a lot of memory being used
			this.advancedhookoptionsdialog.fetch_advanced_hook_options(addr, current_program);
			if (!this.advancedhookoptionsdialog.isOKpressed)
			{
				System.out.println("User clicked at advanced options but did not press OK");
				return;
			}
		}
		
		Function current_function = current_program.getFunctionManager().getFunctionContaining(addr);
		if (current_function==null && !this.isAdvanced)
		{
			//No advanced hooking, tried to hook address which is not in a function
			System.out.println("No hook generated, current function==NULL");
			Msg.showInfo(getClass(), context.getComponentProvider().getComponent(), "Hook generation error", "No hook generated, current function is NULL.");
			return;
		}
		

		if (this.isAdvanced && this.consoleService!=null)
		{
			this.consoleService.println("// Generating hooks... Please wait");
		}
		
		/*Create the task which will present a "Generating hooks..." message*/
		this.hook_generation_task=new StandardHookGenerationTask("Generating Hooks for address "+addr+"...",this.incoming_plugintool, current_program,addr, this.isAdvanced,this.isSnippet, 
				this.advancedhookoptionsdialog,this.internal_structures_for_hook_generation,this.consoleService,false); 
		this.incoming_plugintool.execute(this.hook_generation_task); //execute the task
		//Due to the way the task is constructed (modal = true, waitfortaskcompleted=true), the code will block here until the task is done.
		hook_str=hook_str.concat(this.hook_generation_task.result_of_standard_hook_generation); //The result is placed in advanced_hook_generation_task.result_of_advanced_hook_generation
				
		handle_output(hook_str); 
		
		//cleanup
		//Try to free as much memory as possible at the end
		this.internal_structures_for_hook_generation=null;
		this.advancedhookoptionsdialog=null;
		hook_str="";
		this.hook_generation_task=null;
		if (this.isAdvanced) {
			System.gc();
		}		
	}
	
	
	protected void handle_output(String hook_str)
	{
		Boolean user_has_cancelled_do_not_destroy_clipboard=false;
		if (this.isAdvanced && this.hook_generation_task.is_cancelled )
		{
			//This is the case where the user has manually cancelled
			hook_str="// User has cancelled\n";
			user_has_cancelled_do_not_destroy_clipboard=true;
		}
		if (this.isAdvanced && !this.hook_generation_task.is_cancelled )
		{
			if (this.consoleService!=null)
			{
				this.consoleService.println("// Hook Generated");
			}	
			hook_str=hook_str.concat("//Attempted to generate hooks for "+this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.size()+" different addresses\n");
		}
		//Print to eclipse console
		System.out.println(hook_str);
		
		if (!user_has_cancelled_do_not_destroy_clipboard)
		{
			//Copy to clipboard
			StringSelection stringSelection = new StringSelection(hook_str);
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(stringSelection, null);
		}				
		
		//Print to Ghidra Console	
		if (this.consoleService!=null)
		{
			this.consoleService.println(hook_str);
		}
		else
		{
			System.out.println("Can't print to console because consoleService is null");
		}
	}
	
}

```

`src/main/java/fridahookgenerator/HookGenerator.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import java.util.regex.Pattern;

import docking.action.MenuData;
import ghidra.app.context.ListingActionContext;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressIterator;
import ghidra.program.model.data.DataType;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.lang.Register;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.CodeUnitIterator;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.ExternalLocation;
import ghidra.program.model.symbol.ExternalManager;
import ghidra.program.model.symbol.FlowType;
import ghidra.program.model.symbol.Reference;
import ghidra.program.model.symbol.ReferenceIterator;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.program.model.symbol.SymbolType;
import ghidra.program.util.OperandFieldLocation;
import ghidra.program.util.ProgramLocation;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;


/*
 * This is the main class that performs the hook generation, iterating over all possible options and modifying
 * the hook code as configured. In the simple case (where isAdvanced is false), it simply calls the standard
 * generation function and returns.
 * It heavily depends on the sister class HookGeneratorUtils.
 */
public class HookGenerator {

	protected PluginTool incoming_plugintool;
	protected Boolean isSnippet;
	protected Boolean isAdvanced;
	protected String final_hook_str;
	Program incoming_program;
	Address incoming_address;
	protected AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog;
	protected Boolean we_are_in_the_first_hook_of_the_batch;
	protected Boolean we_are_in_the_final_hook_of_the_batch;
	protected InternalStructuresForHookGeneration internal_structures_for_hook_generation;
	protected ConsoleService consoleService;
	protected TaskMonitor incoming_monitor;
	protected Boolean print_debug;
	
	protected Boolean include_onEnter_in_function_hooks;
	protected Boolean include_onLeave_in_function_hooks;
	protected Boolean use_interceptor_attach_instead_of_replace_in_function_hooks;
	
	protected Program current_program; 
	protected String current_program_name;
	protected String current_program_name_sanitized;
	protected Listing current_program_listing;
	protected Language current_program_language;
	protected Address image_base;
	protected Processor current_program_processor;
	protected String characters_allowed_in_variable_name="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
	protected AdvancedHookOptionsDialog advancedhookoptionsdialog;
	protected int maximum_number_of_reasons_to_show=0;
	protected HookGeneratorUtils utils;
	protected String generated_hook_for_imported_functions=""; //this variable is populated in case the relevant option for imported function hooking is enabled
	protected Boolean problems_encountered_with_chatgpt=false;
	
	
	public HookGenerator(PluginTool tool, Program incoming_program, Address incoming_address, Boolean isAdvanced, Boolean isSnippet, AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog,
			TaskMonitor incoming_taskmonitor,InternalStructuresForHookGeneration incoming_internal_structures, Boolean we_are_in_the_first_hook_of_the_batch,Boolean we_are_in_the_final_hook_of_the_batch,
			ConsoleService consoleService,Boolean print_debug)
	{
		this.incoming_plugintool = tool;
		this.isSnippet = isSnippet;
		this.isAdvanced = isAdvanced;
		this.incoming_program=incoming_program;
		this.incoming_address=incoming_address;
		this.internal_structures_for_hook_generation=incoming_internal_structures;
		this.incoming_monitor=incoming_taskmonitor;
		this.incoming_advancedhookoptionsdialog=incoming_advancedhookoptionsdialog;
		this.final_hook_str="";
		this.we_are_in_the_final_hook_of_the_batch=we_are_in_the_final_hook_of_the_batch;
		this.we_are_in_the_first_hook_of_the_batch=we_are_in_the_first_hook_of_the_batch;
		this.consoleService=consoleService;
		this.print_debug=print_debug;
		this.utils=new HookGeneratorUtils(this);
	}
	

	protected void do_generate_hook() {
		
		this.include_onEnter_in_function_hooks=true;
		this.include_onLeave_in_function_hooks=true;
		this.use_interceptor_attach_instead_of_replace_in_function_hooks=true;
		
		if (this.isAdvanced)
		{
			this.advancedhookoptionsdialog=this.incoming_advancedhookoptionsdialog;
		}
		
		Address addr=this.incoming_address;
		this.current_program=this.incoming_program;
		
		
		if (this.isAdvanced)
		{
			//Set up the boolean variables affecting the function hook generation
			this.utils.interpret_user_custom_options_on_function_hook_generation();
		}
		
		/* Initialize some other useful things*/
		this.current_program_name = this.current_program.getName();
		Function current_function = this.current_program.getFunctionManager().getFunctionContaining(addr);
		this.current_program_listing = this.current_program.getListing();
		this.current_program_name_sanitized = this.current_program_name.replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
		this.image_base = this.current_program.getImageBase();
		this.current_program_language = this.current_program.getLanguage();
		this.current_program_processor = this.current_program_language.getProcessor();


		//Begin creating the hook
		String hook_str="";
		
		//Now, in case of Advanced Options, make sure to update the isSnippet variable
		if (this.isAdvanced)
		{
			if (this.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked)
			{
				this.isSnippet=false;
			}
			else
			{
				this.isSnippet=true;
			}
		}
		
		
		//Create the prologue
		if (!this.isSnippet && this.we_are_in_the_first_hook_of_the_batch)
		{
			hook_str+=this.utils.generate_prologue_for_address(addr,true);
		}
		
		//handle the simple right click case
		if (!this.isAdvanced)
		{
			handle_simple_right_click_hook_generation(addr,true);
		}
		//handle all Advanced cases
		if (this.isAdvanced)
		{
			handle_advanced_hook_generation(addr,false);
		}
		
		if (this.we_are_in_the_final_hook_of_the_batch && !this.incoming_monitor.isCancelled())
		{
			if (this.isAdvanced && this.advancedhookoptionsdialog.isHookImportsCheckBoxchecked)
			{
				hook_str+=this.generated_hook_for_imported_functions;  //this is a quick and dirty way
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isOutputReasonForHookGenCheckboxchecked)
			{
				this.utils.backpatch_reasons_for_advanced_hook_generation(); //this will update the reasons in the individual hooks
			}
			if (this.isAdvanced && !this.incoming_monitor.isCancelled() && this.utils.is_there_a_chance_that_some_hooks_generated_in_the_current_batch_require_code_that_is_later_added_in_the_hook())
			{
				this.utils.backpatch_hooks_that_need_code_to_be_added_at_a_later_stage(); //this will update the hooks that may need further additions to their code. Note: This should happen in any case that there is a chance that one address had such a hook, as placeholders will have been put. In other words, if any of the related advanced options is selected, call this function
			}
			if (!this.incoming_monitor.isCancelled())
			{
				hook_str=hook_str.concat(gather_all_generated_hooks());
			}
		}
		
		

		//Now, the epilogue
		if (!this.isSnippet && this.we_are_in_the_final_hook_of_the_batch && !this.incoming_monitor.isCancelled())
		{
			hook_str+=this.utils.generate_epilogue_for_address(addr,true);
		}
		
		handle_output(hook_str);
		
	
	}
	
	
	

	protected void handle_output(String hook_str)
	{
		if (this.incoming_monitor!=null && this.incoming_monitor.isCancelled() )
		{
			//This is the case where the user has manually cancelled
			hook_str="// User has cancelled\n";
		}
		this.final_hook_str=hook_str;  //Simply set the this.final_hook_str, the caller classes will take care of outputting to the user
	}
	
	
	
	
	
	
	protected void handle_simple_right_click_hook_generation(Address addr, Boolean print_debug)
	{
		generate_snippet_hook_for_address(addr,print_debug,"Simple Right Click");
	}
	
	
	
	
	/* This is a big and complex function, handling all sub-cases for the advanced hook generation*/
	protected void handle_advanced_hook_generation(Address addr, Boolean print_debug)
	{
		Function current_function = this.current_program.getFunctionManager().getFunctionContaining(addr);

		if (this.incoming_monitor.isCancelled()) {return ;} //check for cancellation by the user
		this.incoming_monitor.setMessage("Generating Hooks...");
		
		
		/*References to address*/
		if (this.advancedhookoptionsdialog.isReferencestoAddressCheckBoxchecked || this.advancedhookoptionsdialog.isFunctionsReferencingAddressCheckBoxchecked)
		{
			CodeUnit current_codeunit=this.current_program_listing.getCodeUnitAt(addr);
			Instruction current_instruction=this.current_program_listing.getInstructionAt(addr); //The current address may not be in code, careful
			if (current_codeunit!=null)
			{
				ReferenceIterator ref_iter= current_codeunit.getReferenceIteratorTo();
				while(ref_iter.hasNext())
				{
					Reference ref = ref_iter.next();
					Address newaddr=ref.getFromAddress();
					if (this.advancedhookoptionsdialog.isReferencestoAddressCheckBoxchecked)
					{
						generate_snippet_hook_for_address(newaddr,true,"Address referencing address "+addr+" , referenceType:"+ref.getReferenceType());
					}
					if (this.advancedhookoptionsdialog.isFunctionsReferencingAddressCheckBoxchecked)
					{
						Function newfun=this.current_program.getFunctionManager().getFunctionContaining(newaddr);
						if (newfun!=null)
						{
							generate_snippet_hook_for_address(newfun.getEntryPoint(),true,"Function containing address "+newaddr+" that references to initial address "+addr+" through referenceType:"+ref.getReferenceType());
					
						}	
					}
				}					
			}
		}
		
		if (this.incoming_monitor.isCancelled()) { return;} //check for cancellation by the user

		
		/*References to function*/
		if (this.advancedhookoptionsdialog.isReferencestoFunctionCheckboxchecked && current_function!=null)
		{
			Instruction instruction_of_current_function_start=this.current_program_listing.getInstructionAt(current_function.getEntryPoint());
		
			if (instruction_of_current_function_start!=null)
			{
				ReferenceIterator ref_iter= instruction_of_current_function_start.getReferenceIteratorTo();
				while(ref_iter.hasNext())
				{
					Reference ref = ref_iter.next();
					Address newaddr=ref.getFromAddress();
					generate_snippet_hook_for_address(newaddr,true,"Address referencing function at "+current_function.getEntryPoint()+" named "+current_function.getName(true).replace("\"", "_")+" containing address "+addr+", through referenceType:"+ref.getReferenceType());
				}
			}
			
		}
		
		if (this.incoming_monitor.isCancelled()) { return;} //check for cancellation by the user
	
		/*Incoming references, for a certain depth*/
		if (this.advancedhookoptionsdialog.isFunctionsReferencingFunctionCheckboxchecked && current_function!=null)
		{
			int i;
			int j;
			int depth=Integer.parseInt(this.advancedhookoptionsdialog.InFunctionReferenceDepthcomboBox.getItemAt(this.advancedhookoptionsdialog.InFunctionReferenceDepthcomboBox.getSelectedIndex()));
			
			/*
			 * Complex data type, the external ArrayList holds items for each depth level, and the internal ArrayList contains Functions for a specific depth, accompanied by helper values (all in a Container) . This entire data structure serves the purpose of keeping track of the reference arrows (who has called who), in order to follow them backwards
			 * At position all_depths_arraylists_of_function_references.get(i).get(j), the j'th caller Function for depth 'i' is held. (The j'th as returned by a set iterator, not necessarily being at the j'th position in the code).
			 */
			ArrayList<ArrayList<ContainerForFunctionReferences>> all_depths_arraylists_of_function_references=new ArrayList<ArrayList<ContainerForFunctionReferences>>();

			//initially for level 0
			ArrayList<ContainerForFunctionReferences> arraylist_for_level_i=new ArrayList<ContainerForFunctionReferences>();
			arraylist_for_level_i.add(new ContainerForFunctionReferences(current_function,-1,-1,0));
			all_depths_arraylists_of_function_references.add((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone());
			

			for (i=1;i<=depth;i++)
			{
				this.incoming_monitor.setMessage("Incoming references, level "+i);
				
				arraylist_for_level_i=this.utils.handle_incoming_references_for_one_depth_level((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone(),i);
				all_depths_arraylists_of_function_references.add((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone());
				for (j=0;j<arraylist_for_level_i.size();j++)
				{
					Function newfun=arraylist_for_level_i.get(j).fun;
					String reference_path_string=this.utils.get_incoming_reference_path_string(all_depths_arraylists_of_function_references,i,j);
					generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Incoming function call reference from function at "+newfun.getEntryPoint()+" named "+newfun.getName(true).replace("\"", "_")+", to final current function "+current_function.getName(true).replace("\"", "_")+" containing address "+addr+", after call depth="+i+", using call path:"+reference_path_string);
				
					if (j%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
				}
				if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
			
		}
		
		/*Outgoing references, for a certain depth*/
		if (this.advancedhookoptionsdialog.isOutReferencesfromFunctionCheckBoxchecked && current_function!=null)
		{
			int i;
			int j;
			int depth=Integer.parseInt(this.advancedhookoptionsdialog.OutFunctionReferenceDepthcomboBox.getItemAt(this.advancedhookoptionsdialog.OutFunctionReferenceDepthcomboBox.getSelectedIndex()));
			
			/*
			 * Complex data type, the external ArrayList holds items for each depth level, and the internal ArrayList contains Functions for a specific depth, accompanied by helper values (all in a Container) . This entire data structure serves the purpose of keeping track of the reference arrows (who has called who), in order to follow them backwards
			 * At position all_depths_arraylists_of_function_references.get(i).get(j), the j'th called Function for depth 'i' is held. (The j'th as returned by a set iterator, not necessarily being at the j'th position in the code).
			 */				
			ArrayList<ArrayList<ContainerForFunctionReferences>> all_depths_arraylists_of_function_references=new ArrayList<ArrayList<ContainerForFunctionReferences>>();

			//initially for level 0
			ArrayList<ContainerForFunctionReferences> arraylist_for_level_i=new ArrayList<ContainerForFunctionReferences>();
			arraylist_for_level_i.add(new ContainerForFunctionReferences(current_function,-1,-1,0));
			all_depths_arraylists_of_function_references.add((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone());
							
			for (i=1;i<=depth;i++)
			{
				this.incoming_monitor.setMessage("Outgoing calls, level "+i);
				arraylist_for_level_i=this.utils.handle_outgoing_references_for_one_depth_level((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone(),i);
				all_depths_arraylists_of_function_references.add((ArrayList<ContainerForFunctionReferences>) arraylist_for_level_i.clone());
				for (j=0;j<arraylist_for_level_i.size();j++)
				{
					Function newfun=arraylist_for_level_i.get(j).fun;
					String reference_path_string=this.utils.get_outgoing_reference_path_string(all_depths_arraylists_of_function_references,i,j);
					generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Outgoing function call reference to function at "+newfun.getEntryPoint()+" named "+newfun.getName(true).replace("\"", "_")+", from initial current function "+current_function.getName(true).replace("\"", "_")+" containing address "+addr+", after call depth="+i+", using call path:"+reference_path_string);
					
					if (j%100==0 && this.incoming_monitor.isCancelled()) { return;} //check for cancellation by the user
				}
				if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
			
		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		
		if (this.advancedhookoptionsdialog.isOutReferencesfromAddressCheckBoxchecked)
		{
			CodeUnit current_codeunit=this.current_program_listing.getCodeUnitAt(addr);
			Instruction current_instruction=this.current_program_listing.getInstructionAt(addr); //The current address may not be in code, careful
			if (current_codeunit!=null)
			{
				Reference[] references= current_codeunit.getReferencesFrom();
				for (int i=0;i<references.length;i++)
				{
					Reference ref = references[i];
					Address newaddr=ref.getToAddress();
					generate_snippet_hook_for_address(newaddr,true,"Address referenced from address "+addr+" , referenceType:"+ref.getReferenceType());
				}					
			}
		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		if (this.advancedhookoptionsdialog.isOutDynamicCallReferencesfromFunctionCheckBoxchecked && current_function!=null)
		{
			this.incoming_monitor.setMessage("Dynamic calls for function...");
			AddressIterator all_addresses_in_this_function=current_function.getBody().getAddresses(true);
			int addresses_processed=0;
			
			while (all_addresses_in_this_function.hasNext())
			{
				Address newaddr=all_addresses_in_this_function.next();
				Instruction newinstr=this.current_program_listing.getInstructionAt(newaddr);
				String reason_for_hook="Address "+newaddr+" containing a dynamic (computed) call/jump";
				if (newinstr!=null && this.utils.does_the_current_instruction_definitely_need_hook_code_to_also_be_added_later(newinstr,reason_for_hook))
				{	
					generate_snippet_hook_for_address(newaddr,true,reason_for_hook);		//Careful: This particular reason is used to check if internal data structures should be updated. If changed, update the  update_internal_data_structures()/does_the_current_instruction_definitely_need_hook_code_to_also_be_added_later() function		
				}
				
				if (addresses_processed%200==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
				addresses_processed++;
			}

		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		
		/*Hook this address checkbox*/
		if (this.advancedhookoptionsdialog.isHookThisAddressCheckBoxchecked)
		{
			this.incoming_monitor.setMessage("Hooking this address...");
			
			generate_snippet_hook_for_address(addr,true,"Asked to hook the current (selected) address, which was used to spawn the dialog");
		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user

		
		/* Range hooking, for addresses */
		// TODO: see if this can be done faster, perhaps by iterating over instructions only. Careful with the function endings
		if (this.advancedhookoptionsdialog.isRangeAddressesCheckBoxchecked && this.advancedhookoptionsdialog.RangeAddressesNum>0)
		{
			long max_address=this.current_program.getMaxAddress().getOffset();  //this does not work, keeping it here for future reference 
			long initial_addr_offset=addr.getOffset();
			long curraddr_offset=initial_addr_offset;
			int num_of_addresses_advanced=0;
			int num_of_instructions_advanced=0;
			int num_of_functions_advanced=0;
			int number_of_times_iterated=0;
			
			if (print_debug)
			{
				System.out.println("RangeAddressesNum: "+this.advancedhookoptionsdialog.RangeAddressesNum);
			}

			this.incoming_monitor.setMessage("Range for addresses...");
			
			CodeUnitIterator code_unit_iterator=this.current_program_listing.getCodeUnits(addr, true);

			if (code_unit_iterator!=null)
			{
				while (code_unit_iterator.hasNext())
				{
					CodeUnit newcodeunit=code_unit_iterator.next();
					Address newaddr=newcodeunit.getAddress();
					Boolean we_are_at_the_first_byte_of_an_instruction=false;
					Boolean we_have_reached_the_maxaddress_of_a_function=false;
					number_of_times_iterated++;
					
					/*
					 * A function may have its MaxAddress on something other than an instruction.
					 * Also, very important: The MaxAddress seems to be the last byte of the last code unit, not the start of the last code unit
					 */
					Function newfun = this.current_program.getFunctionManager().getFunctionContaining(newaddr);
					if (newfun!=null &&  this.current_program_listing.getCodeUnitContaining(newfun.getBody().getMaxAddress()).equals(newcodeunit)) //function has ended
					{
						we_have_reached_the_maxaddress_of_a_function=true;
					}
					
					Instruction newinstr=current_program_listing.getInstructionAt(newaddr);	
					if (newinstr!=null) 
					{
						we_are_at_the_first_byte_of_an_instruction=true;
					}
					

					
					if (we_have_reached_the_maxaddress_of_a_function)
					{
						//increase the function counter
						num_of_functions_advanced++;
					}
					if (we_are_at_the_first_byte_of_an_instruction)
					{
						//Increase the instruction counter
						num_of_instructions_advanced++;
					}
					
					//Increase the address counters
					curraddr_offset=newaddr.getOffset()-initial_addr_offset;
					num_of_addresses_advanced=(int) (newaddr.getOffset()-initial_addr_offset);
					
					
					/* Careful: if we have exceeded the allowed addresses, break. Else, continue and hook.*/
					if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonAddr.isSelected() && num_of_addresses_advanced>this.advancedhookoptionsdialog.RangeAddressesNum)
					{
						break;
					}
					
					if (we_are_at_the_first_byte_of_an_instruction)
					{
						//We can only hook instructions at their first byte
						generate_snippet_hook_for_address(newaddr,false,"Address hook in range of initial address "+addr+". Offset from that: "+num_of_addresses_advanced+" addresses, "+num_of_instructions_advanced+" instructions, "+num_of_functions_advanced+" functions.");
					}
					
					/*Now, the check is for >= , as both the instructions and the functions will always increase one by one*/
					if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonFun.isSelected() && num_of_functions_advanced>=this.advancedhookoptionsdialog.RangeAddressesNum)
					{
						break;
					}
					if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonInstr.isSelected() && num_of_instructions_advanced>=this.advancedhookoptionsdialog.RangeAddressesNum)
					{
						break;
					}

					if (number_of_times_iterated%100==0 && this.incoming_monitor.isCancelled()) { return;} //check for cancellation by the user
					if (number_of_times_iterated%2000==0) 
					{
						//update the "Generating hooks..." dialog
						if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonAddr.isSelected()) {this.incoming_monitor.setMessage("Range for addresses "+num_of_addresses_advanced+"...");}
						if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonInstr.isSelected()) {this.incoming_monitor.setMessage("Range for addresses "+num_of_instructions_advanced+"...");}
						if (this.advancedhookoptionsdialog.RangeAddressesRadioButtonFun.isSelected()) {this.incoming_monitor.setMessage("Range for addresses "+num_of_functions_advanced+"...");}
					}
				}
			}
		}
		
		
		/* Range hooking, for functions, only forward */
		if (this.advancedhookoptionsdialog.isRangeFunctionsCheckBoxchecked && this.advancedhookoptionsdialog.RangeFunctionsNum>0 && !this.advancedhookoptionsdialog.RangeFunctionsRadioButtonFunBackwards.isSelected())
		{
			//get all functions starting from this address
			FunctionIterator fun_iter=this.current_program_listing.getFunctions(addr, true);
			long initial_addr_offset=addr.getOffset();
			long curraddr_offset=initial_addr_offset;
			int num_of_addresses_advanced=0;
			//instructions will not be used as a counter, is there any way of using them, without iterating over all of the instructions? In other words, to get the number of instructions inside a function, without iterating over all of them.
			//int num_of_instructions_advanced=0;
			int num_of_functions_advanced=0;
			long offset_of_new_fun_end;
			long offset_of_new_fun_start;
			Boolean we_are_done_for_RangeFunctions=false;
			
			this.incoming_monitor.setMessage("Range for functions...");
			
			//if we are inside a function, we want to hook that one
			Function newfun = this.current_program.getFunctionManager().getFunctionContaining(addr);
			
			if (newfun!=null)
			{
				generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook in range of initial address "+addr+". Offset from that: "+num_of_addresses_advanced+" addresses, "+num_of_functions_advanced+" functions.");
				num_of_functions_advanced++; //in this case, 1 function means -> hook the present one
				if (newfun.getEntryPoint().equals(addr))
				{
					//consume the first of the iterator if we are at the start of the first function.
					if (fun_iter.hasNext()) {fun_iter.next();};
				}
			}
			
			while (!we_are_done_for_RangeFunctions && fun_iter.hasNext())
			{
				newfun=fun_iter.next();
				offset_of_new_fun_end=newfun.getBody().getMaxAddress().getOffset();
				offset_of_new_fun_start=newfun.getEntryPoint().getOffset();
				num_of_addresses_advanced=(int) (offset_of_new_fun_start-initial_addr_offset);
				num_of_functions_advanced++;
				if (this.advancedhookoptionsdialog.RangeFunctionsRadioButtonAddr.isSelected() && num_of_addresses_advanced>this.advancedhookoptionsdialog.RangeFunctionsNum) 
				{
					we_are_done_for_RangeFunctions=true;
					break;
				}
				if (this.advancedhookoptionsdialog.RangeFunctionsRadioButtonFun.isSelected() && num_of_functions_advanced>this.advancedhookoptionsdialog.RangeFunctionsNum)
				{
					we_are_done_for_RangeFunctions=true;
					break;
				}
				generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook in range of initial address "+addr+". Offset from that: "+num_of_addresses_advanced+" addresses, "+num_of_functions_advanced+" functions.");
			
				if (num_of_functions_advanced%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
				if (num_of_functions_advanced%1000==0) {this.incoming_monitor.setMessage("Range for functions "+num_of_functions_advanced+"...");}
			}

		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user

		
		/* Range hooking, for functions, only backwards */
		if (this.advancedhookoptionsdialog.isRangeFunctionsCheckBoxchecked && this.advancedhookoptionsdialog.RangeFunctionsNum>0 && this.advancedhookoptionsdialog.RangeFunctionsRadioButtonFunBackwards.isSelected())
		{
			//get all functions starting from this address, going backwards
			FunctionIterator fun_iter=this.current_program_listing.getFunctions(addr, false);
			long initial_addr_offset=addr.getOffset();
			long curraddr_offset=initial_addr_offset;
			int num_of_addresses_advanced=0;
			int num_of_functions_advanced=0;
			long offset_of_new_fun_end;
			long offset_of_new_fun_start;
			Boolean we_are_done_for_RangeFunctions=false;
			
			this.incoming_monitor.setMessage("Range for functions (backwards)...");
			
			//if we are inside a function, we want to hook that one
			Function newfun = this.current_program.getFunctionManager().getFunctionContaining(addr);
			
			if (newfun!=null)
			{
				generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook in range of initial address "+addr+" going backwards. Offset from that: "+num_of_addresses_advanced+" addresses, "+num_of_functions_advanced+" functions.");
				num_of_functions_advanced++; //in this case, 1 function means -> hook the present one
				//consume the first of the iterator, since when we are in a function, the first of the backwards iterator will give the function itself
				if (fun_iter.hasNext()) {fun_iter.next();};
			}
			
			while (!we_are_done_for_RangeFunctions && fun_iter.hasNext())
			{
				newfun=fun_iter.next();
				offset_of_new_fun_end=newfun.getBody().getMaxAddress().getOffset();
				offset_of_new_fun_start=newfun.getEntryPoint().getOffset();
				num_of_addresses_advanced=(int) (initial_addr_offset-offset_of_new_fun_start);
				num_of_functions_advanced++;

				if ( num_of_functions_advanced>this.advancedhookoptionsdialog.RangeFunctionsNum)
				{
					we_are_done_for_RangeFunctions=true;
					break;
				}
				generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook in range of initial address "+addr+" going backwards. Offset from that: "+num_of_addresses_advanced+" addresses, "+num_of_functions_advanced+" functions.");
			
				if (num_of_functions_advanced%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
				if (num_of_functions_advanced%1000==0) {this.incoming_monitor.setMessage("Range for functions (backwards) "+num_of_functions_advanced+"...");}
			}
		}
	
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user

		

		/* Function name regex hooking */
		if (this.advancedhookoptionsdialog.isFunctionRegexCheckBoxchecked)
		{
			String regex_for_fun_name=this.advancedhookoptionsdialog.FunctionRegexTextField.getText();
			Pattern pattern= Pattern.compile(regex_for_fun_name,Pattern.CASE_INSENSITIVE);
			FunctionIterator fun_iter=this.current_program_listing.getFunctions(true);
			int num_of_functions_processed=0;
			
			
			if (this.incoming_monitor.isCancelled()) {return;}
			this.incoming_monitor.setMessage("Function hooking by regex...");
			
			while(fun_iter!=null && fun_iter.hasNext())
			{
				Function newfun=fun_iter.next();
				num_of_functions_processed++;
				String name_of_newfun=newfun.getName(true).replace("\"", "_");
				
				if (pattern.matcher(name_of_newfun).matches())
				{
					generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook to function "+name_of_newfun+" due to matching regex:"+regex_for_fun_name);
				}
				if (num_of_functions_processed%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
			
		
		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		/* Hooking by regular expression provided by ChatGPT */
		if (this.advancedhookoptionsdialog.isAIChatFunctionRegexCheckBoxchecked)
		{
			String category_to_be_provided_to_chatgpt=this.advancedhookoptionsdialog.AIChatFunctionRegexTextField.getText();
			int num_of_functions_processed=0;
			
			if (this.incoming_monitor.isCancelled()) {return;}
			this.incoming_monitor.setMessage("Gathering function names for ChatGPT...");
			
			//First, gather all the function names
			ArrayList<String> arraylist_with_fun_names=new ArrayList<String>();
			ArrayList<Function> arraylist_with_functions=new ArrayList<Function>();
			FunctionIterator fun_iter=this.current_program_listing.getFunctions(true);
			
			while(fun_iter!=null && fun_iter.hasNext())
			{
				Function newfun=fun_iter.next();
				num_of_functions_processed++;
				//the name will be altered, ChatGPT may have problems with colons, dollar signs etc
				String name_of_newfun=newfun.getName(true).replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
				arraylist_with_fun_names.add(name_of_newfun);
				arraylist_with_functions.add(newfun);
				if (num_of_functions_processed%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
			
			//Now, send all the function names to chatGPT
			
			if (this.incoming_monitor.isCancelled()) {return;}
			this.incoming_monitor.setMessage("Sending function names to ChatGPT...");
			
			ChatGPTAPICaller gpt=new ChatGPTAPICaller(this.incoming_monitor);
			if (gpt.apiKey.equals("API_KEY_PLACEHOLDER"))
			{
				//the api key was not found
				System.out.println("ChatGPT API key not found.");
				this.problems_encountered_with_chatgpt=true;
			}
			else
			{
				String final_reply=gpt.askchatGPT_multiplemessages(category_to_be_provided_to_chatgpt,arraylist_with_fun_names);
				System.out.println(final_reply);
				if (final_reply=="CANCELLED")
				{
					//task monitor was cancelled
					return;
				}
				
				Boolean received_valid_reply=false;
				String final_list_of_nums_str="";
				if (final_reply.indexOf("\\n")<0)
				{
					final_list_of_nums_str=final_reply;
					received_valid_reply=true;
				}
				if (final_reply.split("\\\\n").length>=2)
				{
					final_list_of_nums_str=final_reply.split("\\\\n")[1];
					received_valid_reply=true;
				}
				
				if (received_valid_reply)
				{
					
					String[] arr_of_numbers=final_list_of_nums_str.split(",");
					System.out.println(final_list_of_nums_str);
					
					for (int i=0;i<arr_of_numbers.length;i++)
					{
						Function fun_to_include=arraylist_with_functions.get(Integer.parseInt(arr_of_numbers[i].trim()));
						String fun_name_to_include=arraylist_with_fun_names.get(Integer.parseInt(arr_of_numbers[i].trim()));
						generate_snippet_hook_for_address(fun_to_include.getEntryPoint(),false,"Function hook to function "+fun_name_to_include+" due to being related to category "+category_to_be_provided_to_chatgpt.replace("\"", "")+" according to ChatGPT");

					}
				}
				else {
					//The returned reply was not in the expected format
					System.out.println("The returned ChatGPT reply was not in the expected format.");
					this.problems_encountered_with_chatgpt=true;
				}
			}
		}
		
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		

		/* Function (mangled) name regex hooking */
		if (this.advancedhookoptionsdialog.isFunctionMangledNameRegexCheckBoxchecked)
		{
			String regex_for_fun_mangled_name=this.advancedhookoptionsdialog.FunctionMangledNameRegexTextField.getText();
			Pattern pattern= Pattern.compile(regex_for_fun_mangled_name,Pattern.CASE_INSENSITIVE);
			FunctionIterator fun_iter=this.current_program_listing.getFunctions(true);
			int num_of_functions_processed=0;
			
			if (this.incoming_monitor.isCancelled()) {return;}
			this.incoming_monitor.setMessage("Function hooking by regex...");
			
			while(fun_iter!=null && fun_iter.hasNext())
			{
				Function newfun=fun_iter.next();
				num_of_functions_processed++;
				String name_of_newfun=newfun.getName(true).replace("\"", "_");
				
				String find_mangled_name=this.utils.return_mangled_name_for_specific_address(this.incoming_program,newfun.getEntryPoint(),pattern);
				if (!find_mangled_name.equals(""))
				{
					generate_snippet_hook_for_address(newfun.getEntryPoint(),false,"Function hook to function "+name_of_newfun+" due to matching regex of mangled name:"+regex_for_fun_mangled_name);
				}

				
				if (num_of_functions_processed%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
		}
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user

		/*Hook all imported symbols*/
		if (this.advancedhookoptionsdialog.isHookImportsCheckBoxchecked)
		{
			SymbolTable symboltable=this.current_program.getSymbolTable();

			HashMap<Function,String> hashmap_of_functions=new HashMap<Function,String>();
			int num_of_symbols_processed=0;
			SymbolIterator symbol_interator=symboltable.getExternalSymbols();
			
			this.incoming_monitor.setMessage("Hooking imports...");
			
						
			String imports_hook_str="";
			String spaces="        ";
			String varstr_for_resolver_and_matches=this.utils.generate_random_string_from_pool(this.characters_allowed_in_variable_name,6);
			imports_hook_str+=spaces+"var resolver_"+varstr_for_resolver_and_matches+" =new ApiResolver('module');\n";
			imports_hook_str+=spaces+"var matches_"+varstr_for_resolver_and_matches+";\n";
			while(symbol_interator!=null && symbol_interator.hasNext())
			{
				num_of_symbols_processed++;
				
				Symbol next_symbol=symbol_interator.next();
				boolean found_in_hashmap_of_functions=false;
				if (next_symbol.getSymbolType()==SymbolType.FUNCTION && next_symbol.isExternal())
				{
					found_in_hashmap_of_functions=true;
					Address addr_of_symbol=next_symbol.getProgramLocation().getAddress();
					Function identified_function=this.current_program.getFunctionManager().getFunctionAt(addr_of_symbol);
					
															
					//If the function has been processed, and we don't have a mangled symbol or the stored symbol is mangled, continue
					//This is done to put preference in mangled symbols
					if (hashmap_of_functions.containsKey(identified_function) &&
							(!this.utils.is_symbol_name_mangled_name(next_symbol.getName()) ||
							 this.utils.is_symbol_name_mangled_name(hashmap_of_functions.get(identified_function))
							 )
						)
					{
						continue; //already processed that function
					}
					
					//However, if it is not processed OR the symbol is a mangled one and we haven't seen such a symbol before, then process
					
					
					//We must take into account a possible mangled name for that symbol
					ExternalManager extmanager=this.current_program.getExternalManager();
					ExternalLocation extlocation=extmanager.getExternalLocation(next_symbol);
					String effective_symbol_name=next_symbol.getName();
					if (extlocation!=null && extlocation.getOriginalImportedName()!=null && this.utils.is_symbol_name_mangled_name(extlocation.getOriginalImportedName()))
					{
						effective_symbol_name=extlocation.getOriginalImportedName();
					}
					hashmap_of_functions.put(identified_function,effective_symbol_name); //now, put into hashmap
					
					//See if symbol name contains illegal characters
					String sanitized_symbol_name_with_at_colon_tilde_qmark_dollar=effective_symbol_name.replaceAll("[^"+this.characters_allowed_in_variable_name+"\\:\\@\\~\\?\\$"+"]", "_");
					if (!sanitized_symbol_name_with_at_colon_tilde_qmark_dollar.equals(effective_symbol_name))
					{
						imports_hook_str+=spaces+"//Not creating import hook for function with sanitized name:"+sanitized_symbol_name_with_at_colon_tilde_qmark_dollar+" due to illegal characters\n";
						continue;
					}
					int parameter_count=identified_function.getParameterCount();
					String raw_function_name=sanitized_symbol_name_with_at_colon_tilde_qmark_dollar; //we have passed a sanitization process
					String properly_sanitized_function_name=identified_function.getName(true).replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_"); //this time, sanitize it properly so that it can get into a variable
					String sanitized_export_module_name_regex="*"; //can be anywhere
					
					if (next_symbol.getName(true).toLowerCase().contains(".dll::")) // in Windows, we may have the module name
					{
						sanitized_export_module_name_regex="*"+this.utils.return_sanitized_module_name_regex_for_dll_external_function_import(next_symbol.getName(true).toLowerCase());
					}
						
					//TODO: This should not call its own code, it should be integrated with the standard Interceptor.attach() hook code generator.
					imports_hook_str+=this.utils.generate_import_hook_str_for_function(raw_function_name,properly_sanitized_function_name,parameter_count,sanitized_export_module_name_regex,varstr_for_resolver_and_matches,spaces);
				}
				if (num_of_symbols_processed%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
			this.generated_hook_for_imported_functions=imports_hook_str;
		}
		
		
		if (this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
		
		
		/*Hook all exported symbols*/
		if (this.advancedhookoptionsdialog.isHookExportsCheckBoxchecked)
		{
			SymbolTable symboltable=this.current_program.getSymbolTable();
			AddressIterator addr_iter=symboltable.getExternalEntryPointIterator();
			int num_of_addresses_processed=0;
			
			this.incoming_monitor.setMessage("Hooking exports...");
			
			while (addr_iter!=null && addr_iter.hasNext())
			{
				Address external_entry_point=addr_iter.next();
				num_of_addresses_processed++;
				
				generate_snippet_hook_for_address(external_entry_point,false,"Exported symbol which is an entry point");
				if (num_of_addresses_processed%100==0 && this.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user
			}
		}

	}
	
	
		

	
	protected String gather_all_generated_hooks()
	{
		String hook_str="";
		StringBuffer sb=new StringBuffer(10000000); //Much faster than simple string concatenation when doing it for many strings
		
		if (this.incoming_monitor.isCancelled()) {return "";} //check for cancellation by the user)
		this.incoming_monitor.setMessage("Gathering all generated hooks in one...");
		

		//handling the case where it is requested to make a memory scan for a specific pattern
		if (this.isAdvanced && this.advancedhookoptionsdialog.isMemoryScanPatternCheckBoxchecked)
		{
			InstructionSearchPatternHandler pattern_handler= new InstructionSearchPatternHandler(this.incoming_plugintool,this.current_program,this.advancedhookoptionsdialog.MemoryScanPatternTextField.getText(),this.current_program_name_sanitized,"        ");
			sb.append(pattern_handler.return_frida_code_for_incoming_instruction_pattern());
			sb.append("\n");
		}
		
		if (this.incoming_monitor.isCancelled()) {return "";} //check for cancellation by the user)
		
		//Include the variables and functions that may need declaration and apply for all the hooks
		sb.append(this.utils.return_code_for_initialization_of_functions_and_variables_before_the_hooks());
		
		
		//Now iterate over all generated hooks
		int i;
		for (i=0;i<this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch;i++)
		{
			sb.append(this.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.get(i));
			if (this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.containsKey(i))
			{
				sb.append(this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.get(i));
			}
			
			if (i%100==0 && this.incoming_monitor.isCancelled()) {return "";} //check for cancellation by the user
			if (i%1000==0) {this.incoming_monitor.setMessage("Gathering all generated hooks in one "+(int)((i*100)/this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch)+"%...");}

		}
		/*Careful: There might be Messages_to_be_included_between_hooks after the last legitimate hook, which will have maxed out index*/
		if (this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.containsKey(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch))
		{
			sb.append(this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.get(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch));
		}
	
		
		//If we have many try/catch blocks, we should calculate the successes/failures and print them in the end
		if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeInterceptorTryCatchcheckboxchecked)
		{
			sb.append("\n");
			sb.append("        console.log('Successful Interceptor hooks:'+counter_for_successful_Interceptor_hooks+', failed Interceptor hooks:'+counter_for_failed_Interceptor_hooks);\n");
		}
		
		if (this.isAdvanced && this.advancedhookoptionsdialog.isAIChatFunctionRegexCheckBoxchecked && this.problems_encountered_with_chatgpt)
		{
			sb.append("\n");
			sb.append("        //A problem was encountered with ChatGPT communication, no hooks were generated by that option\n");
			sb.append("        //Please make sure that the API key is at the first line of the file ~/.ghidra/chatgpt_apikey.txt .\n");
		}
		
		
		hook_str=sb.toString();
		if (this.consoleService!=null)
		{
			this.consoleService.println("// Gathering generated hooks completed, outputting to the user...");
		}
		this.incoming_monitor.setMessage("Outputting to the user...");
		return hook_str;
	}
	

	protected String generate_interceptor_attach_hook(Address addr,Function current_function,String function_name_with_current_addr,int parameter_count)
	{
		String hook_str="";

		hook_str=hook_str.concat("        "+this.utils.generate_try_catch_text_before_interceptor_hook()+this.utils.populate_data_structure_that_holds_Interceptor_attach_objects("dynamic_address_of_"+function_name_with_current_addr)+"Interceptor.attach(dynamic_address_of_"+function_name_with_current_addr+", {\n");
		if (this.include_onEnter_in_function_hooks)
		{
			hook_str=hook_str.concat("                    onEnter: function(args) {\n")
							 .concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Entered "+function_name_with_current_addr+"\");\n");
			
			boolean include_names_of_arguments=false;
			if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeFunParamNamescheckboxchecked)
			{
				if (parameter_count>=1)
				{
					if (this.utils.do_sanitized_function_argument_names_result_in_name_conflicts(current_function))
					{
						include_names_of_arguments=false;
						hook_str+="                        // Conflicting sanitized names of function parameters, as such arguments will not be named\n";
					}
					else
					{
						include_names_of_arguments=true;
						//In this case, the names of the arguments must be put inside the function and variables should be declared
						for (int i=0;i<parameter_count;i++)
						{
							hook_str+="                        this.arg_"+this.utils.return_sanitized_name_of_parameter_for_function_at_position(current_function, i)+"=args["+i+"];\n";
						}
					}
				}
			}
			
				
			/* Put the parameters in the hook code*/
			if (parameter_count>=1 && this.utils.user_options_allow_printing_of_params()) {
						   hook_str+="                        console.log("+this.utils.tid_and_indent_code()+"'";
						   for (int i=0;i<parameter_count;i++)
						   {
							   if (include_names_of_arguments)
							   {
								   hook_str+="args["+i+"](this.arg_"+this.utils.return_sanitized_name_of_parameter_for_function_at_position(current_function, i)+")='+args["+i+"]";
							   }
							   else
							   {
								   hook_str+="args["+i+"]='+args["+i+"]";
							   }
							   if (i<parameter_count-1) { hook_str+="+' , "; }
							   else { hook_str+=");\n"; }
						   }
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isOutputReasonForHookGenCheckboxchecked)
			{
				//put the placeholder for the reasons of hooking. This will be replaced when backpatching
				hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Reasons for hooking: PLACEHOLDER_FOR_REASONS_FOR_HOOKING_"+addr+"\")\n");
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isGenerateBacktraceCheckboxchecked)
			{
				hook_str=hook_str.concat(this.utils.generate_backtrace_for_hook(true));
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextcheckboxchecked)
			{
				hook_str=hook_str.concat("                        "+this.advancedhookoptionsdialog.IncludeCustomTextTextField.getText()+"\n");
			}
			if (this.isAdvanced && this.utils.can_there_be_any_reason_why_this_address_may_need_code_that_is_later_added_in_the_hook(addr))
			{
				hook_str=hook_str.concat("PLACEHOLDER_FOR_HOOK_CODE_TO_BE_ADDED_LATER_"+addr);
			}
			hook_str=hook_str.concat("                        // this.context.x0=0x1;\n")
							 .concat(this.utils.increase_console_indent_if_chosen())
							 .concat("                    }");
		}
		if (this.include_onEnter_in_function_hooks && this.include_onLeave_in_function_hooks) 
		{
			hook_str=hook_str.concat(",\n");
		}
		if (this.include_onLeave_in_function_hooks)
		{
			hook_str=hook_str.concat("                    onLeave: function(retval) {\n")
							 .concat(this.utils.decrease_console_indent_if_chosen());
			
			if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextAftercheckboxchecked)
			{
				hook_str=hook_str.concat("                        "+this.advancedhookoptionsdialog.IncludeCustomTextAfterTextField.getText()+"\n");
			}
			
			hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Exited "+function_name_with_current_addr+", retval:\"+retval);\n")
						 	 .concat("                        // retval.replace(0x1);\n")
						 	 .concat("                    }\n");
		}
		else
		{
			hook_str=hook_str.concat("\n");
		}
		hook_str=hook_str.concat("        }); "+this.utils.generate_try_catch_text_after_interceptor_hook(addr)+"\n\n");
		
		return hook_str;
	}
	
	

	protected String generate_interceptor_replace_hook(Address addr,Function current_function,String function_name_with_current_addr,int parameter_count)
	{
		String hook_str="";
		
		/*Generate strings for params*/
		String str_for_types_of_params="";
		String str_for_params_in_nativecallback="";
		
		for (int i=0;i<parameter_count;i++)
		{
			DataType this_param_datatype=current_function.getParameter(i).getDataType();

			str_for_types_of_params+=this.utils.get_frida_nativefun_str_for_parameter(this_param_datatype);
			str_for_params_in_nativecallback+="arg_"+i;
			if (i<parameter_count -1)
			{
				str_for_types_of_params+=",";
				str_for_params_in_nativecallback+=",";
			}
		}
		str_for_types_of_params="["+str_for_types_of_params+"]";
		
		String str_for_return_type="";
		
		/*Generate string for return type*/
		if (current_function.getReturnType().toString()=="void")
		{
			str_for_return_type+="'void'";
		}
		else
		{
			str_for_return_type+=this.utils.get_frida_nativefun_str_for_parameter(current_function.getReturnType());
		}
		String nativefunction_str="dynamic_address_of_"+function_name_with_current_addr+","+str_for_return_type+","+str_for_types_of_params;
		
		hook_str=hook_str.concat("        var NativeFunction_of_"+function_name_with_current_addr+"= new NativeFunction("+nativefunction_str+");\n");
		
		hook_str=hook_str.concat("        "+this.utils.generate_try_catch_text_before_interceptor_hook()+"Interceptor.replace(dynamic_address_of_"+function_name_with_current_addr+",new NativeCallback(("+str_for_params_in_nativecallback+") => {\n");
		
		hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Entered "+function_name_with_current_addr+"\");\n");
		if (this.isAdvanced && this.advancedhookoptionsdialog.isOutputReasonForHookGenCheckboxchecked)
		{
			//put the placeholder for the reasons of hooking. This will be replaced when backpatching
			hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Reasons for hooking: PLACEHOLDER_FOR_REASONS_FOR_HOOKING_"+addr+"\")\n");
		}
		
		boolean include_names_of_arguments=false;
		if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeFunParamNamescheckboxchecked)
		{
			if (parameter_count>=1)
			{
				if (this.utils.do_sanitized_function_argument_names_result_in_name_conflicts(current_function))
				{
					include_names_of_arguments=false;
					hook_str+="                        // Conflicting sanitized names of function parameters, as such arguments will not be named\n";
				}
				else
				{
					include_names_of_arguments=true;
					//In this case, the names of the arguments must be put inside the function and variables should be declared
					for (int i=0;i<parameter_count;i++)
					{
						hook_str+="                        var arg_"+this.utils.return_sanitized_name_of_parameter_for_function_at_position(current_function, i)+"=args["+i+"];\n";
					}
				}
			}
		}

		
			if (parameter_count>=1 && this.utils.user_options_allow_printing_of_params()) {
						   hook_str+="                        console.log("+this.utils.tid_and_indent_code()+"'";
						   for (int i=0;i<parameter_count;i++)
						   {
							   if (include_names_of_arguments)
							   {
								   hook_str+="args["+i+"](arg_"+this.utils.return_sanitized_name_of_parameter_for_function_at_position(current_function, i)+")='+args["+i+"]";
							   }
							   else
							   {
								   hook_str+="args["+i+"]='+arg_"+i+"";
							   }
							   if (i<parameter_count-1) { hook_str+="+' , "; }
							   else { hook_str+=");\n"; }
						   }
			}
		if (this.isAdvanced && this.advancedhookoptionsdialog.isGenerateBacktraceCheckboxchecked)
		{
			hook_str=hook_str.concat(this.utils.generate_backtrace_for_hook(false));
		}
		if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextcheckboxchecked)
		{
			hook_str=hook_str.concat("                        "+this.advancedhookoptionsdialog.IncludeCustomTextTextField.getText()+"\n");
		}
		if (this.isAdvanced && this.utils.can_there_be_any_reason_why_this_address_may_need_code_that_is_later_added_in_the_hook(addr))
		{
			hook_str=hook_str.concat("PLACEHOLDER_FOR_HOOK_CODE_TO_BE_ADDED_LATER_"+addr);
		}
		
		hook_str=hook_str.concat(this.utils.increase_console_indent_if_chosen());
		//call the original function
		hook_str=hook_str.concat("                        var retval=NativeFunction_of_"+function_name_with_current_addr+"("+str_for_params_in_nativecallback+");\n");
		
		hook_str=hook_str.concat(this.utils.decrease_console_indent_if_chosen());

		if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextAftercheckboxchecked)
		{
			hook_str=hook_str.concat("                        "+this.advancedhookoptionsdialog.IncludeCustomTextAfterTextField.getText()+"\n");
		}
		
		if (current_function.getReturnType().toString()!="void")
		{
			hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Exited "+function_name_with_current_addr+", retval:\"+retval);\n");
			hook_str=hook_str.concat("                        return retval;\n");
		}
		else
		{
			hook_str=hook_str.concat("                        console.log("+this.utils.tid_and_indent_code()+"\"Exited "+function_name_with_current_addr+"\");\n");
		}
		hook_str=hook_str.concat("        },"+str_for_return_type+","+str_for_types_of_params+")); "+this.utils.generate_try_catch_text_after_interceptor_hook(addr)+"\n\n");
		
		return hook_str;
	}
	
	
	
	
	/*This function generates the snippet hook, and stores it into the internal data structures*/
	protected void generate_snippet_hook_for_address( Address addr, Boolean print_debug, String reason_for_hook_generation) {
		
		if (this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.containsKey(addr.toString()))
		{
			//Update the hashmap to reflect that another reason was added for the address to be hooked
			String tmpstr=this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.get(addr.toString());
			this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.put(addr.toString(),tmpstr.concat("|").concat(reason_for_hook_generation));
			
			//Set the intermediate message for this index
			if(this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.containsKey(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch))
			{
				String previous_contents= this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.get(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch);
				this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.put(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch, 
																										previous_contents+" //Address:"+addr+", already registered interceptor for that address\n");
			}
			else
			{
				this.internal_structures_for_hook_generation.Messages_to_be_included_between_hooks.put(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch, 
						" //Address:"+addr+", already registered interceptor for that address\n");
			}
			return;
		}
		
		//Try to recalculate some parameters
		Function current_function = this.current_program.getFunctionManager().getFunctionContaining(addr);
		Instruction current_instruction=this.current_program_listing.getInstructionAt(addr); //The current address may not be in an undefined function, but it may be in an instruction

		if (current_instruction==null)
		{
			//The data structures should be updated
			String in_place_of_hook=" //Address:"+addr+", not an instruction\n";
			this.utils.update_internal_data_structures(addr,in_place_of_hook,"not an instruction");
			return;
		}
		
		if (this.isAdvanced && this.advancedhookoptionsdialog.isDoNotHookThunkFunctionscheckboxchecked && 
				current_function!=null && current_function.isThunk() && addr.equals(current_function.getEntryPoint()) )
		{
			//Similarly, the data structures should be updated
			String in_place_of_hook=" //Address:"+addr+" is a thunk function, not hooking\n";
			this.utils.update_internal_data_structures(addr,in_place_of_hook,"thunk function, not hooking");
			return;
		}
		
		if (this.isAdvanced && this.advancedhookoptionsdialog.isDoNotHookExternalFunctionscheckboxchecked && 
				current_function!=null && current_function.isExternal() && addr.equals(current_function.getEntryPoint()) )
		{
			//Similarly, the data structures should be updated
			String in_place_of_hook=" //Address:"+addr+" is an external function, not hooking\n";
			this.utils.update_internal_data_structures(addr,in_place_of_hook,"external function, not hooking");
			return;
		}

		
		Address current_function_entry_point;
		Boolean we_are_at_start_of_function;
		String current_function_name_sanitized="";
		
		
		if (current_function!=null)
		{
			current_function_entry_point=current_function.getEntryPoint();
			we_are_at_start_of_function=current_function_entry_point.equals(addr);
			current_function_name_sanitized=current_function.getName(true).replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
		}
		else
		{
			we_are_at_start_of_function=false;
			current_function_entry_point=null;
		}

		
		if (print_debug)
		{
			System.out.println("Address:"+addr);
			System.out.println("Program name:"+this.current_program_name);
			System.out.println("Program base:"+this.image_base);
			System.out.println("Program language:"+this.current_program_language);
			System.out.println("Program processor:"+this.current_program_processor);
			if (current_function!=null)
			{
				System.out.println("Current function:"+current_function);
				System.out.println("Current function entry point:"+current_function_entry_point);
			}
		}

		
		String hook_str="";

		/*for when we are at the start of a function*/
		String function_name_with_current_addr="";
			
		if (we_are_at_start_of_function && !(this.isAdvanced && this.advancedhookoptionsdialog.isGenerateNormalAddressHooksForFunctionBeginningscheckboxchecked))
		{
			//If we are at the start of a function and we are not forced to treat the address as a normal, non function-beginning one
			function_name_with_current_addr=current_function_name_sanitized+"_"+addr;
			int parameter_count=current_function.getParameterCount(); //May not always work, decompiler must commit the params first
			DataType current_function_returntype=current_function.getReturnType();
			String current_function_callingconventionname=current_function.getCallingConventionName();

			if (print_debug)
			{
				System.out.println("Current function name sanitized:"+current_function_name_sanitized);
				System.out.println("function_name_with_current_addr:"+function_name_with_current_addr);
				System.out.println("Current function parameter count:"+parameter_count); 
				System.out.println("Current function return type:"+current_function_returntype); 
				System.out.println("Current function calling convention name:"+current_function_callingconventionname);
			}

			//String.concat() is the fastest, but "+" is also used for code clarity. 
			hook_str=hook_str.concat("        var offset_of_"+function_name_with_current_addr+"=0x"+Long.toHexString(addr.getOffset()-this.image_base.getOffset())+";\n")
							 //OLD_API:.concat("        var dynamic_address_of_"+function_name_with_current_addr+"=Module.findBaseAddress(module_name_"+this.current_program_name_sanitized+").add(offset_of_"+function_name_with_current_addr+");\n")
							 .concat("        var dynamic_address_of_"+function_name_with_current_addr+"=Process.getModuleByName(module_name_"+this.current_program_name_sanitized+").base.add(offset_of_"+function_name_with_current_addr+");\n")
							 .concat(this.utils.populate_data_structures_that_link_addresses_and_function_names("        ","dynamic_address_of_"+function_name_with_current_addr,current_function_name_sanitized,current_function));
			
			String errors_if_interceptor_replace_is_used=this.utils.identify_errors_if_interceptor_replace_is_used(current_function,parameter_count);
			//empty string means that no problems are identified
			if (errors_if_interceptor_replace_is_used=="" && !this.use_interceptor_attach_instead_of_replace_in_function_hooks)
			{
				hook_str=hook_str.concat(generate_interceptor_replace_hook(addr,current_function,function_name_with_current_addr,parameter_count));
			}
			else
			{
				hook_str=hook_str.concat(errors_if_interceptor_replace_is_used);// this is the error message from before if there is any
				hook_str=hook_str.concat(generate_interceptor_attach_hook(addr,current_function,function_name_with_current_addr,parameter_count));
			}
		}
		else
		{
			//this is the case for all non-function beginning addresses
			String str_for_current_function_if_any="";
			String str_in_place_of_current_function_name_sanitized="not in a function";
			if (current_function!=null && !current_function_name_sanitized.equals(""))
			{
				str_for_current_function_if_any=", which is inside function "+current_function_name_sanitized;
				str_in_place_of_current_function_name_sanitized=current_function_name_sanitized;
			}
					
			//String.concat() is the fastest, but "+" is also used for code clarity.
			hook_str=hook_str.concat("        var offset_of_"+addr+"=0x"+Long.toHexString(addr.getOffset()-this.image_base.getOffset())+";\n")
							 //OLD_API:.concat("        var dynamic_address_of_"+addr+"=Module.findBaseAddress(module_name_"+this.current_program_name_sanitized+").add(offset_of_"+addr+");\n")
							 .concat("        var dynamic_address_of_"+addr+"=Process.getModuleByName(module_name_"+this.current_program_name_sanitized+").base.add(offset_of_"+addr+");\n")
							 .concat(this.utils.populate_data_structures_that_link_addresses_and_function_names("      ","dynamic_address_of_"+addr,str_in_place_of_current_function_name_sanitized,current_function))

							 
							 .concat("        function function_to_call_when_code_reaches_"+addr+"(){\n")
							 .concat("            console.log("+this.utils.tid_and_indent_code()+"'Reached address 0x"+addr+str_for_current_function_if_any+"');\n");
			if (this.isAdvanced && this.advancedhookoptionsdialog.isOutputReasonForHookGenCheckboxchecked)
			{
				//put the placeholder for the reasons of hooking. This will be replaced when backpatching
				hook_str=hook_str.concat("            console.log("+this.utils.tid_and_indent_code()+"\"Reasons for hooking: PLACEHOLDER_FOR_REASONS_FOR_HOOKING_"+addr+"\")\n");
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isGenerateBacktraceCheckboxchecked)
			{
				hook_str=hook_str.concat(this.utils.generate_backtrace_for_hook(false));
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextcheckboxchecked)
			{
				hook_str=hook_str.concat("            "+this.advancedhookoptionsdialog.IncludeCustomTextTextField.getText()+"\n");
			}
			if (this.isAdvanced && this.utils.can_there_be_any_reason_why_this_address_may_need_code_that_is_later_added_in_the_hook(addr))
			{
				hook_str=hook_str.concat("PLACEHOLDER_FOR_HOOK_CODE_TO_BE_ADDED_LATER_"+addr);
			}
			if (this.isAdvanced && this.advancedhookoptionsdialog.isIncludeCustomTextAftercheckboxchecked)
			{
				hook_str=hook_str.concat("            "+this.advancedhookoptionsdialog.IncludeCustomTextAfterTextField.getText()+"\n");
			}
			hook_str=hook_str.concat("            //this.context.x0=0x1;\n")
							 .concat("        }\n")

							 .concat("        "+this.utils.generate_try_catch_text_before_interceptor_hook()+this.utils.populate_data_structure_that_holds_Interceptor_attach_objects("dynamic_address_of_"+addr)+"Interceptor.attach(dynamic_address_of_"+addr+", function_to_call_when_code_reaches_"+addr+"); "+this.utils.generate_try_catch_text_after_interceptor_hook(addr)+"\n\n");

		}
		
		this.utils.update_internal_data_structures(addr,hook_str,reason_for_hook_generation);
		
	}
	
	

}


/*Basically a 4-tuple of data, to be inserted to data structures for keeping track of function references*/
class ContainerForFunctionReferences
{
	public Function fun;
	public int index_of_source_at_previous_depth;
	public int first_index_of_dest_at_next_depth;
	public int current_depth;
	
	public ContainerForFunctionReferences(Function fun,int index_of_source_at_previous_depth, int first_index_of_dest_at_next_depth, int current_depth)
	{
		this.fun=fun;
		this.index_of_source_at_previous_depth=index_of_source_at_previous_depth;
		this.first_index_of_dest_at_next_depth=first_index_of_dest_at_next_depth;
		this.current_depth=current_depth; 
	}

}
```

`src/main/java/fridahookgenerator/HookGeneratorUtils.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Random;
import java.util.Set;
import java.util.regex.Pattern;

import ghidra.program.model.address.Address;
import ghidra.program.model.data.DataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Parameter;
import ghidra.program.model.listing.Program;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.symbol.SymbolTable;

/*
 * Sister class of HookGenerator, containing many useful functions that are called sometime in its code. 
 * It receives a reference to it and uses its internal variables.
 */
 
public class HookGeneratorUtils {

	private HookGenerator incoming_hook_generator;
	private String characters_allowed_in_variable_name="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
	
	public HookGeneratorUtils(HookGenerator incoming_hook_generator)
	{
		this.incoming_hook_generator = incoming_hook_generator;
	}
	

	protected String generate_epilogue_for_address(Address addr, Boolean print_debug) {
		
		String hook_str="";
		
		if (!this.incoming_hook_generator.isAdvanced || (this.incoming_hook_generator.isAdvanced && !this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked) || (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==0))
		{
			//default method
			hook_str+="        \n";
			hook_str+="        Interceptor.flush();\n"
					+ "        console.log(\"Registered interceptors.\");\n"
					+ "    }, 2000);//milliseconds\n"
					+ "}\n"
					+ "start_timer_for_intercept();\n";
		}
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==1 ||
				this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==2 ||
				this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==3 )
		{
			//dlopen(), LoadLibrary() or attachModuleObserver() method
			hook_str+="        \n"
					+ "    Interceptor.flush();\n"
					+ "    console.log(\"Registered interceptors.\");\n"
					+ "}\n";
		}
		
		return hook_str;
				
	}
	
	
	protected String generate_prologue_for_address(Address addr, Boolean print_debug) {
		
		String hook_str="";
		
		if (!this.incoming_hook_generator.isAdvanced || (this.incoming_hook_generator.isAdvanced && !this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked) || (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==0))
		{
			//default method
			hook_str+="var module_name_"+this.incoming_hook_generator.current_program_name_sanitized+"='"+this.incoming_hook_generator.current_program_name+"';\n";
			hook_str+="\n";
			hook_str+="function start_timer_for_intercept() {\n"
					+ "  setTimeout(\n"
					+ "    function() {\n"
					+ "        console.log(\"Registering interceptors...\");\n";
			hook_str+="        \n";
			hook_str+="        \n";
		}
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==1)
		{
			//dlopen() method
			hook_str+="var module_name_"+this.incoming_hook_generator.current_program_name_sanitized+"='"+this.incoming_hook_generator.current_program_name+"';\n";
			hook_str+="\n";
			hook_str+="function extract_libname_from_dlopen_arg(dlopen_arg)\n"
					+ "{\n"
					+ "    if (dlopen_arg!==null && dlopen_arg.indexOf(\"/\")>=0)\n"
					+ "    {\n"
					+ "        var array_of_subdirs=dlopen_arg.split(\"/\");\n"
					+ "        return array_of_subdirs[array_of_subdirs.length-1];\n"
					+ "    }\n"
					+ "    else\n"
					+ "    {\n"
					+ "        return dlopen_arg;\n"
					+ "    }\n"
					+ "}\n"
					+ "\n"
					+ "function do_the_dlopen_interception(incoming_export)\n"
					+ "{\n"
					+ "    try \n"
					+ "    {\n"
					+ "        Interceptor.attach(incoming_export.address, {\n"
					+ "            onEnter: function(args) {\n"
					+ "                console.log(\"DLOPEN: Entered dlopen related function: \"+incoming_export.name + \", lib to load:\"+args[0].readCString());\n"
					+ "                this.libname=args[0].readCString();\n"
					+ "            },\n"
					+ "            onLeave: function(retval) {\n"
					+ "                console.log(\"DLOPEN: Exited dlopen related function:\"+incoming_export.name+\" ,retval:\"+retval);\n"
					+ "                if (extract_libname_from_dlopen_arg(this.libname)==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+")\n"
					+ "                {\n"
					+ "                    console.log('FOUND LIBRARY THAT HAS JUST BEEN LOADED: '+this.libname+', hooking.');\n"
					+ "                    register_interceptors();\n"
					+ "                }\n"
					+ "            }\n"
					+ "        });\n"
					+ "    } catch (err) { console.log('ERROR: Could not hook function:'+incoming_export.name+' at '+incoming_export.address+','+JSON.stringify(DebugSymbol.fromAddress(incoming_export.address))+', continuing.')}\n"
					+ "}\n"
					+ "\n"
					+ "var process_modules = Process.enumerateModules();\n"
					+ "var we_have_encountered_at_least_one_dlopen=false;\n"
					+ "var we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules=false;\n"
					+ "for(var i=0;i<process_modules.length;i++){\n"
					+ "\n"
					+ "    if (process_modules[i].name==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+")\n"
					+ "    {\n"
					+ "        console.log(\"The module to register interceptors in, was found already loaded\");\n"
					+ "        we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules=true;\n"
					+ "        register_interceptors();\n"
					+ "        break;\n"
					+ "    }\n"
					+ "    var exports = process_modules[i].enumerateExports();\n"
					+ "    for(var j=0;j<exports.length;j++)\n"
					+ "    {\n"
					+ "        if (exports[j].name.indexOf(\"dlopen\")>=0) //there may be more than one dlopen related functions, like __libc_dlopen_mode()\n"
					+ "        //if (exports[j].name==\"dlopen\")\n"
					+ "        {\n"
					+ "            console.log(process_modules[i].name);\n"
					+ "            console.log(JSON.stringify(exports[j]));\n"
					+ "            do_the_dlopen_interception(exports[j]);\n"
					+ "            we_have_encountered_at_least_one_dlopen=true;\n"
					+ "        }\n"
					+ "    }\n"
					+ "}\n"
					+ "if (!we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules && !we_have_encountered_at_least_one_dlopen)\n"
					+ "{\n"
					+ "    console.log(\"DLOPEN: No dlopen found, exiting the frida script...\")\n"
					+ "    throw '';\n"
					+ "}\n"
					+ "\n"
					+ "\n"
					+ "function register_interceptors()\n"
					+ "{\n"
					+ "    console.log(\"Registering interceptors...\");\n"
					+ "    \n\n";
			
		}
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==2)
		{
			//LoadLibrary() method
			hook_str+="var module_name_"+this.incoming_hook_generator.current_program_name_sanitized+"='"+this.incoming_hook_generator.current_program_name+"';\n";
			hook_str+="\n";
			hook_str+="function extract_libname_from_loadlibrary_arg(loadlibrary_arg)\n"
					+ "{\n"
					+ "    if (loadlibrary_arg!==null && loadlibrary_arg.indexOf(\"\\\\\")>=0)\n"
					+ "    {\n"
					+ "        var array_of_subdirs=loadlibrary_arg.split(\"\\\\\");\n"
					+ "        return array_of_subdirs[array_of_subdirs.length-1]; \n"
					+ "    }\n"
					+ "    else\n"
					+ "    {\n"
					+ "        return loadlibrary_arg;\n"
					+ "    }\n"
					+ "}\n"
					+ "\n"
					+ "function do_the_loadlibrary_interception(incoming_export)\n"
					+ "{\n"
					+ "    try "
					+ "    {\n"
					+ "        Interceptor.attach(incoming_export.address, {\n"
					+ "            onEnter: function(args) {\n"
					+ "                if (incoming_export.name.charAt(incoming_export.name.length - 1)==\"A\")\n"
					+ "                {\n"
					+ "                    this.libname=args[0].readAnsiString();\n"
					+ "                }\n"
					+ "                else\n"
					+ "                {\n"
					+ "                    this.libname=args[0].readUtf16String();\n"
					+ "                }\n"
					+ "                console.log(\"LOADLIBRARY: Entered LoadLibrary related function: \"+incoming_export.name + \", lib to load:\"+this.libname);\n"
					+ "\n"
					+ "            },\n"
					+ "            onLeave: function(retval) {\n"
					+ "                console.log(\"LOADLIBRARY: Exited LoadLibrary related function:\"+incoming_export.name+\" ,retval:\"+retval);\n"
					+ "                if (extract_libname_from_loadlibrary_arg(this.libname).toLowerCase()==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+".toLowerCase() || (extract_libname_from_loadlibrary_arg(this.libname)+\".dll\").toLowerCase()==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+".toLowerCase())\n"
					+ "                {\n"
					+ "                    console.log('FOUND LIBRARY THAT HAS JUST BEEN LOADED: '+this.libname+', hooking.');\n"
					+ "                    register_interceptors();\n"
					+ "                }\n"
					+ "            }\n"
					+ "        });\n"
					+ "    } catch (err) { console.log('ERROR: Could not hook function:'+incoming_export.name+' at '+incoming_export.address+','+JSON.stringify(DebugSymbol.fromAddress(incoming_export.address))+', continuing.')}\n"
					+ "}\n"
					+ "\n"
					+ "var process_modules = Process.enumerateModules();\n"
					+ "var we_have_encountered_at_least_one_loadlibrary=false;\n"
					+ "var we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules=false;\n"
					+ "for(var i=0;i<process_modules.length;i++){\n"
					+ "\n"
					+ "    if (process_modules[i].name.toLowerCase()==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+".toLowerCase() || (process_modules[i].name+\".dll\").toLowerCase()==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+".toLowerCase() )\n"
					+ "    {\n"
					+ "        console.log(\"Encountered the module already loaded\");\n"
					+ "        we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules=true;\n"
					+ "        register_interceptors();\n"
					+ "        break;\n"
					+ "    }\n"
					+ "    var exports = process_modules[i].enumerateExports();\n"
					+ "    for(var j=0;j<exports.length;j++)\n"
					+ "    {\n"
					+ "        //if (exports[j].name==\"LoadLibrary\")\n"
					+ "        if (exports[j].name.indexOf(\"LoadLibrary\")>=0) //there may be more than one LoadLibrary related functions, like LoadLibraryEx(), LoadLibraryExW(), LoadLibraryExA() ....\n"
					+ "        {\n"
					+ "            console.log(process_modules[i].name);\n"
					+ "            console.log(JSON.stringify(exports[j]));\n"
					+ "            do_the_loadlibrary_interception(exports[j]);\n"
					+ "            we_have_encountered_at_least_one_loadlibrary=true;\n"
					+ "        }\n"
					+ "    }\n"
					+ "}\n"
					+ "if (!we_encountered_the_lib_in_the_initial_pass_of_the_loaded_modules && !we_have_encountered_at_least_one_loadlibrary)\n"
					+ "{\n"
					+ "    console.log(\"LOADLIBRARY: No LoadLibrary found, exiting the frida script...\")\n"
					+ "    throw '';\n"
					+ "}\n"
					+ "\n"
					+ "\n"
					+ "function register_interceptors()\n"
					+ "{\n"
					+ "    console.log(\"Registering interceptors...\");\n"
					+ "    \n\n";
		}
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateScriptCheckboxchecked && this.incoming_hook_generator.advancedhookoptionsdialog.TypeofScriptGenerationcomboBox.getSelectedIndex()==3)
		{
			//attachModuleObserver method
			String varstr_for_observer=this.generate_random_string_from_pool(this.characters_allowed_in_variable_name,6);
			hook_str+="var module_name_"+this.incoming_hook_generator.current_program_name_sanitized+"='"+this.incoming_hook_generator.current_program_name+"';\n";
			hook_str+="\n";
			hook_str+="var observer_"+varstr_for_observer+" = Process.attachModuleObserver({\n"
					+ "    onAdded(module) {\n"
					+ "        console.log('Module '+module.path+' was just loaded, with base address: '+module.base);\n"
					+ "        if (module.name==module_name_"+this.incoming_hook_generator.current_program_name_sanitized+")\n"
					+ "        {\n"
					+ "            console.log('Found our module!');\n"
					+ "            intercept_identified_module_"+this.incoming_hook_generator.current_program_name_sanitized+"();\n"
					+ "        }\n"
					+ "    },\n"
					+ "    onRemoved(module) {\n"
					+ "        console.log('Module '+module.path+' was  unloaded');\n"
					+ "    }\n"
					+ "});"
					+ "\n"
					+ "\n"
					+ "function intercept_identified_module_"+this.incoming_hook_generator.current_program_name_sanitized+"()\n"
					+ "{\n"
					+ "    console.log(\"Registering interceptors...\");\n";
			hook_str+="    \n";
			hook_str+="    \n";
		}
		
		return hook_str;
		
		
		
	}
	
	
	protected String return_code_for_initialization_of_functions_and_variables_before_the_hooks()
	{
		String retval="";

		//If we have many try/catch blocks, we should calculate the successes/failures and print them in the end
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeInterceptorTryCatchcheckboxchecked)
		{
			retval+="        var counter_for_successful_Interceptor_hooks=0;\n";
			retval+="        var counter_for_failed_Interceptor_hooks=0;\n";
			retval+="\n";
		}
		
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isCreateDataStructuresToLinkAddressesAndFunctionNamescheckboxchecked)
		{
			retval += "        var dict_from_current_addresses_to_function_names={}\n"
					+ "        var dict_from_function_names_to_function_start_addresses={}\n"
					+ "        var dict_from_current_addresses_to_function_start_addresses={}\n"
					+ "        var dict_from_function_start_addresses_to_function_names={}\n"
					+ "        var current_function_start_address=ptr(\"0x0\")\n"
					+ "        /*\n"
					+ "        access with: \n"
					+ "            var current_function_name=dict_from_current_addresses_to_function_names[this.context.pc]\n"
					+ "        check if current address is at the start of the function: \n"
					+ "            var is_current_addr_the_start_of_the_current_function=false;\n"
					+ "            if (this.context.pc in dict_from_current_addresses_to_function_start_addresses && dict_from_current_addresses_to_function_start_addresses[this.context.pc].equals(this.context.pc))\n"
					+ "            {\n"
					+ "                is_current_addr_the_start_of_the_current_function=true;\n"
					+ "            }  \n"
					+ "        */\n\n";
		}
		
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isCreateDataStructureWithInterceptorAttachObjectscheckboxchecked)
		{
			retval += "        var dict_with_objects_returned_from_attach={}\n\n";
		}
		
		
		//handling the case where threadID and indentation are requested
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeTIDAndIndentationcheckboxchecked)
		{
			retval += "        var dict_with_thread_indentation_levels={}\n"
					+ "        function tid_and_indent(thiz) {\n"
					+ "            var current_threadid=Process.getCurrentThreadId()\n"
					+ "            if (current_threadid in dict_with_thread_indentation_levels) {\n"
					+ "                return ('TID '+current_threadid+': ').padEnd(14)+dict_with_thread_indentation_levels[current_threadid]+'('+thiz.depth+')'\n"
					+ "            } else {\n"
					+ "                dict_with_thread_indentation_levels[current_threadid]=''\n"
					+ "                return ('TID '+current_threadid+': ').padEnd(14)+'('+thiz.depth+')'\n"
					+ "            } \n"
					+ "        }\n"
					+ "        function increase_indent() {\n"
					+ "            var current_threadid=Process.getCurrentThreadId()\n"
					+ "            if (current_threadid in dict_with_thread_indentation_levels) {\n"
					+ "                dict_with_thread_indentation_levels[current_threadid]=dict_with_thread_indentation_levels[current_threadid]+'  '\n"
					+ "            } else {\n"
					+ "                dict_with_thread_indentation_levels[current_threadid]=''\n"
					+ "            } \n"
					+ "        }\n"
					+ "        function decrease_indent() {\n"
					+ "            var current_threadid=Process.getCurrentThreadId()\n"
					+ "            if (current_threadid in dict_with_thread_indentation_levels) {\n"
					+ "                dict_with_thread_indentation_levels[current_threadid]=dict_with_thread_indentation_levels[current_threadid].slice(0,-2)\n"
					+ "            } else {  //we must never enter the else clause\n"
					+ "                dict_with_thread_indentation_levels[current_threadid]=''\n"
					+ "            } \n"
					+ "        }\n\n";
		}
		
		return retval;
	}
	
	protected String tid_and_indent_code()
	{
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeTIDAndIndentationcheckboxchecked)
		{
			return "tid_and_indent(this)+";
		}
		return "";
	}
	
	protected String increase_console_indent_if_chosen()
	{
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeTIDAndIndentationcheckboxchecked)
		{
			return "                        increase_indent()\n";
		}
		return "";
	}
	
	protected String decrease_console_indent_if_chosen()
	{
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeTIDAndIndentationcheckboxchecked)
		{
			return "                        decrease_indent()\n";
		}
		return "";
	}
	

	protected ArrayList<ContainerForFunctionReferences> handle_outgoing_references_for_one_depth_level(ArrayList<ContainerForFunctionReferences> incoming_functions_from_previous_level,int current_depth)
	{
		int i;
		ArrayList<ContainerForFunctionReferences> retval=new ArrayList<ContainerForFunctionReferences>();
		for (i=0;i<incoming_functions_from_previous_level.size();i++)
		{
			Function newfun=incoming_functions_from_previous_level.get(i).fun;
			Set<Function> called_functions=newfun.getCalledFunctions(null);
			if (called_functions!=null)
			{
				Iterator<Function> iter=called_functions.iterator();
				while (iter.hasNext())
				{
					Function newfun2=iter.next();
					ContainerForFunctionReferences newcontainer=new ContainerForFunctionReferences(newfun2,i,-1,current_depth);
					retval.add(newcontainer);
					if (incoming_functions_from_previous_level.get(i).first_index_of_dest_at_next_depth==-1)
					{
						incoming_functions_from_previous_level.get(i).first_index_of_dest_at_next_depth=retval.size()-1; //fix the container's index at the previous level if it is not set
					}
				}
			}
			
		}
		return retval;
	}
	
	

	//Try to move backwards in the data structure to see the reference path
	String get_outgoing_reference_path_string(ArrayList<ArrayList<ContainerForFunctionReferences>> all_depths_arraylists_of_function_references,int depth,int index_of_container_for_that_depth)
	{
		String retval="";
		
		int tmpdepth=depth;
		int index_of_caller_in_previous_level=index_of_container_for_that_depth;
		while(tmpdepth>=0)
		{
			ContainerForFunctionReferences tmpcontainer=all_depths_arraylists_of_function_references.get(tmpdepth).get(index_of_caller_in_previous_level);
			Function tmpfun=tmpcontainer.fun;
			index_of_caller_in_previous_level=tmpcontainer.index_of_source_at_previous_depth;
			if (tmpdepth>0)
			{
				retval="->".concat(tmpfun.getName(true).replace("\"", "_")).concat(retval);
			}
			else
			{
				retval=tmpfun.getName(true).replace("\"", "_").concat(retval);
			}
			tmpdepth--;
		}
		
		return retval;
	}
	
	

	protected ArrayList<ContainerForFunctionReferences> handle_incoming_references_for_one_depth_level(ArrayList<ContainerForFunctionReferences> called_functions_from_previous_level,int current_depth)
	{
		int i;
		ArrayList<ContainerForFunctionReferences> retval=new ArrayList<ContainerForFunctionReferences>();
		for (i=0;i<called_functions_from_previous_level.size();i++)
		{
			Function newfun=called_functions_from_previous_level.get(i).fun;
			Set<Function> calling_functions=newfun.getCallingFunctions(null);
			if (calling_functions!=null)
			{
				Iterator<Function> iter=calling_functions.iterator();
				while (iter.hasNext())
				{
					Function newfun2=iter.next();
					ContainerForFunctionReferences newcontainer=new ContainerForFunctionReferences(newfun2,i,-1,current_depth);
					retval.add(newcontainer);
					if (called_functions_from_previous_level.get(i).first_index_of_dest_at_next_depth==-1)
					{
						called_functions_from_previous_level.get(i).first_index_of_dest_at_next_depth=retval.size()-1; //fix the container's index at the previous level if it is not set
					}
				}
			}
			
		}
		return retval;
	}
	

	//Try to move backwards in the data structure to see the reference path
	String get_incoming_reference_path_string(ArrayList<ArrayList<ContainerForFunctionReferences>> all_depths_arraylists_of_function_references,int depth,int index_of_container_for_that_depth)
	{
		String retval="";
		
		int tmpdepth=depth;
		int index_of_callee_in_previous_level=index_of_container_for_that_depth;
		while(tmpdepth>=0)
		{
			ContainerForFunctionReferences tmpcontainer=all_depths_arraylists_of_function_references.get(tmpdepth).get(index_of_callee_in_previous_level);
			Function tmpfun=tmpcontainer.fun;
			index_of_callee_in_previous_level=tmpcontainer.index_of_source_at_previous_depth;
			if (tmpdepth == depth)
			{
				retval=retval.concat(tmpfun.getName(true).replace("\"", "_"));
			}
			else
			{
				retval=retval.concat("->").concat(tmpfun.getName(true).replace("\"", "_"));
			}
			tmpdepth--;
		}
		
		return retval;
	}
	
	protected Boolean user_options_allow_printing_of_params()
	{
		if (this.incoming_hook_generator.isAdvanced)
		{
			return (!this.incoming_hook_generator.advancedhookoptionsdialog.isDoNotIncludeFunParamscheckboxchecked);
		}
		return true;
	}
	
	protected void interpret_user_custom_options_on_function_hook_generation()
	{
		if (!this.incoming_hook_generator.isAdvanced || (this.incoming_hook_generator.isAdvanced && !this.incoming_hook_generator.advancedhookoptionsdialog.isCustomFunInterceptorHookOutputCheckboxchecked)) 
		{
			this.incoming_hook_generator.include_onEnter_in_function_hooks=true;
			this.incoming_hook_generator.include_onLeave_in_function_hooks=true;
			this.incoming_hook_generator.use_interceptor_attach_instead_of_replace_in_function_hooks=true;
			return;
		}
		if (this.incoming_hook_generator.advancedhookoptionsdialog.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==0)
		{
			this.incoming_hook_generator.include_onEnter_in_function_hooks=false;
		}
		if (this.incoming_hook_generator.advancedhookoptionsdialog.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==1)
		{
			this.incoming_hook_generator.include_onLeave_in_function_hooks=false;
		}
		if (this.incoming_hook_generator.advancedhookoptionsdialog.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==2)
		{
			this.incoming_hook_generator.use_interceptor_attach_instead_of_replace_in_function_hooks=false;
		}
	}

	String generate_try_catch_text_before_interceptor_hook()
	{
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeInterceptorTryCatchcheckboxchecked)
		{
			return "try { ";
		}
		return "";
	}
	
	String generate_try_catch_text_after_interceptor_hook(Address addr)
	{
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isIncludeInterceptorTryCatchcheckboxchecked)
		{
			return " counter_for_successful_Interceptor_hooks++;} catch(error) { counter_for_failed_Interceptor_hooks++; console.log('Error_'+counter_for_failed_Interceptor_hooks+': Could not hook address "+addr+"') }";
		}
		return "";
	}
	
	String populate_data_structures_that_link_addresses_and_function_names(String spaces,String current_addr_js_variable,String current_function_name_sanitized,Function current_function)
	{
		String retval="";
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isCreateDataStructuresToLinkAddressesAndFunctionNamescheckboxchecked)
		{
			retval+=spaces+"dict_from_current_addresses_to_function_names["+current_addr_js_variable+"]=\""+current_function_name_sanitized+"\";\n";
			if (!current_function_name_sanitized.equals("not in a function") && current_function!=null)
			{
				//OLD_API:retval+=spaces+"current_function_start_address=Module.findBaseAddress(module_name_"+this.incoming_hook_generator.current_program_name_sanitized+").add(0x"+Long.toHexString(current_function.getEntryPoint().getOffset()-this.incoming_hook_generator.image_base.getOffset())+");\n";
				retval+=spaces+"current_function_start_address=Process.getModuleByName(module_name_"+this.incoming_hook_generator.current_program_name_sanitized+").base.add(0x"+Long.toHexString(current_function.getEntryPoint().getOffset()-this.incoming_hook_generator.image_base.getOffset())+");\n";
				retval+=spaces+"dict_from_function_names_to_function_start_addresses[\""+current_function_name_sanitized+"\"]=current_function_start_address;\n";
				retval+=spaces+"dict_from_current_addresses_to_function_start_addresses["+current_addr_js_variable+"]=current_function_start_address;\n";
				retval+=spaces+"dict_from_function_start_addresses_to_function_names[current_function_start_address]=\""+current_function_name_sanitized+"\";\n";
			}
		}
		return retval;
	}
	
	
	String populate_data_structure_that_holds_Interceptor_attach_objects(String current_addr_js_variable)
	{
		String retval="";
		if (this.incoming_hook_generator.isAdvanced && this.incoming_hook_generator.advancedhookoptionsdialog.isCreateDataStructureWithInterceptorAttachObjectscheckboxchecked)
		{
			retval+="dict_with_objects_returned_from_attach["+current_addr_js_variable+"]=";
		}
		return retval;
	}
		
	

	
	protected String get_frida_nativefun_str_for_parameter(DataType param_datatype)
	{
		/* it is assumed that the input parameter has been checked to not be null*/
		String str_for_param="";
		int this_param_size=param_datatype.getLength();
		if (param_datatype.toString().indexOf(" *")>=0)
		{
			//pointer
			str_for_param+="'pointer'";
		}
		else if (param_datatype.toString()=="double")
		{
			str_for_param+="'double'";
		}
		else if (param_datatype.toString()=="float")
		{
			str_for_param+="'float'";
		}
		else if (param_datatype.toString()=="int")
		{
			str_for_param+="'int'";
		}
		else if (param_datatype.toString()=="long")
		{
			str_for_param+="'long'";
		}
		else
		{
			str_for_param+="'int"+this_param_size*8+"'"; //it is assumed that the size is checked to be in an accepted range
		}
		return str_for_param;
	}
	
	

	/*Any errors are returned with the hook str*/
	protected String identify_errors_if_interceptor_replace_is_used(Function current_function,int parameter_count)
	{
		String hook_str="";
		
		if (this.incoming_hook_generator.use_interceptor_attach_instead_of_replace_in_function_hooks)
		{
			return "";
		}
		if (current_function.hasVarArgs())
		{
			hook_str=hook_str.concat("        //Current function has variadic number of arguments, interceptor.replace not supported yet\n");
			return hook_str;
		}
		if (current_function.getReturnType()==null)
		{
			hook_str=hook_str.concat("        //Current function has undefined type of return value\n");
			return hook_str;
		}
		
		int size_of_returntype=current_function.getReturnType().getLength();
		//void is not ZeroLength, but getLength returns 0
		if (current_function.getReturnType().isZeroLength() || (current_function.getReturnType().toString()!="void" && size_of_returntype!=1 && size_of_returntype!=2 && size_of_returntype!=4 && size_of_returntype!=8)  )
		{
			hook_str=hook_str.concat("        //Current function has an unaccepted return type:"+current_function.getReturnType().toString()+"\n");
			return hook_str;
		}
		
		
		//check if the parameter sizes are valid
		Boolean all_param_sizes_are_valid=true;
		for (int i=0;i<parameter_count;i++)
		{
			int param_size=current_function.getParameter(i).getDataType().getLength();
			if (current_function.getParameter(i).getDataType().isZeroLength() || (param_size!=1 && param_size!=2 && param_size!=4 && param_size!=8))
			{
				all_param_sizes_are_valid=false;
				hook_str=hook_str.concat("      //Current function cannot be Interceptor.replace()'d as parameter at position "+i+" has size "+param_size+"\n");
				break;
			}
		}
		return hook_str;
	}
	
	
	
	protected String return_sanitized_name_of_parameter_for_function_at_position(Function incoming_function, int i)
	{
		String retval="";
		int num_of_params=incoming_function.getParameterCount();
		Parameter param;
		if (i>=0 && i<num_of_params)
		{
			param=incoming_function.getParameter(i);
		}
		else
		{
			retval= "invalid_param";
			return retval;
		}
		String sanitized_param_name=param.getName().replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
		retval=sanitized_param_name;
		return retval;
	}
	
	
	
	protected Boolean do_sanitized_function_argument_names_result_in_name_conflicts(Function incoming_function)
	{
		boolean retval=false;
		int num_of_params=incoming_function.getParameterCount();
		ArrayList<String> sanitized_param_names= new ArrayList<String>();
		for (int i=0;i<num_of_params;i++)
		{
			String new_param_name=return_sanitized_name_of_parameter_for_function_at_position(incoming_function,i);
			if (sanitized_param_names.contains(new_param_name))
			{
				return true;
			}
			sanitized_param_names.add(new_param_name);
		}
		return retval;
	}
	
	

	
	/* This function tries to predict, whether there might be a future reason for hooking the current address, for which special treatment (code that may later be needed to be added) is required.
	 * For example, if the current address is about a dynamic call instruction, then maybe, a later hook for the same address is asked to print the where the code will go.
	 * As the hook string is generated only once, that string will have to put a placeholder for the code that does the "special treatment". 
	 * This function only checks whether there is any chance that the current instruction may need a "special treatment" by iterating over all the implemented reasons for "special treatment", and checking if they may apply.
	 */
	protected Boolean can_there_be_any_reason_why_this_address_may_need_code_that_is_later_added_in_the_hook(Address addr)
	{
		if (this.incoming_hook_generator.isAdvanced && (this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromFunctionCheckBoxchecked || this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromAddressCheckBoxchecked))
		{
			Instruction current_instruction=this.incoming_hook_generator.current_program_listing.getInstructionAt(addr);
			if (current_instruction!=null && current_instruction.getFlowType().isComputed())// && current_instruction.getFlowType().isCall()) //Uncomment to restrict selection to computed hooks, do the same below
			{	
				String current_instruction_str_lowercase=current_instruction.toString().toLowerCase().trim();
				String current_instruction_mnemonic=current_instruction.getMnemonicString().toLowerCase().trim();
				if (this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("x86:LE:64")>=0 && 
						(current_instruction_mnemonic.equals("call") || current_instruction_mnemonic.equals("jmp"))
					)
				{
					return true;
				}
				
				if (this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("AARCH64:LE:64")>=0 && 
						(current_instruction_mnemonic.equals("blr") || current_instruction_mnemonic.equals("bx") ||
						 current_instruction_mnemonic.equals("br") || current_instruction_mnemonic.equals("blraaz") ||
						 current_instruction_mnemonic.equals("blrabz") )
					)
				{
					return true;
				}
			}
		}
		return false;
	}
	
	/*Used for efficiency*/
	protected Boolean is_there_a_chance_that_some_hooks_generated_in_the_current_batch_require_code_that_is_later_added_in_the_hook()
	{
		if (this.incoming_hook_generator.isAdvanced && (this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("x86:LE:64")>=0 || this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("AARCH64:LE:64")>=0) && 
				(this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromAddressCheckBoxchecked || this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromFunctionCheckBoxchecked))
		{
			return true;
		}
		return false;
	}
		
	protected Boolean does_the_current_instruction_definitely_need_hook_code_to_also_be_added_later(Instruction current_instruction,String reason_for_hook_generation)
	{
		if (this.incoming_hook_generator.isAdvanced && current_instruction!=null && current_instruction.getFlowType().isComputed())// && current_instruction.getFlowType().isCall()) //Uncomment to restrict selection to computed hooks, do the same above
		{
			if (this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromAddressCheckBoxchecked || (this.incoming_hook_generator.advancedhookoptionsdialog.isOutDynamicCallReferencesfromFunctionCheckBoxchecked && reason_for_hook_generation.indexOf("containing a dynamic (computed) call/jump")>=0))
			{
				String current_instruction_str_lowercase=current_instruction.toString().toLowerCase().trim();
				String current_instruction_mnemonic=current_instruction.getMnemonicString().toLowerCase().trim();
				
				if (this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("x86:LE:64")>=0 && 
						(current_instruction_mnemonic.equals("call") || current_instruction_mnemonic.equals("jmp"))
					)
					
				{
					return true;
				}
				
				if (this.incoming_hook_generator.current_program_language.getLanguageID().toString().indexOf("AARCH64:LE:64")>=0 && 
						(current_instruction_mnemonic.equals("blr") || current_instruction_mnemonic.equals("bx") ||
						 current_instruction_mnemonic.equals("br") || current_instruction_mnemonic.equals("blraaz") ||
						 current_instruction_mnemonic.equals("blrabz") )
					)
				{
					return true;
				}
			}
		}
		return false;
	}
	
	
	protected void update_internal_data_structures(Address addr,String hook_str, String reason_for_hook_generation)
	{
		this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch++;
		String tmpstr=String.valueOf(this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch)+"|"+reason_for_hook_generation;
		this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_for_current_hook_str.put(addr.toString(),tmpstr); //this is the initial placement of this address in the Addresses_for_current_hook_str data structure
		this.incoming_hook_generator.internal_structures_for_hook_generation.addresses_for_which_hook_is_generated_in_order_of_appearance.add(addr);
		this.incoming_hook_generator.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.add(hook_str);
		//if it fills the prerequisites for code to be added later, then update the Addresses_that_need_hook_code_to_be_added_at_a_later_stage
		if (this.incoming_hook_generator.isAdvanced && can_there_be_any_reason_why_this_address_may_need_code_that_is_later_added_in_the_hook(addr)) //first check
		{
			Instruction current_instruction=this.incoming_hook_generator.current_program_listing.getInstructionAt(addr);
			//Check for computed calls/jumps . This time we need to be certain that this address is supposed to contain code related to computed calls/jumps
			if (current_instruction!=null && does_the_current_instruction_definitely_need_hook_code_to_also_be_added_later(current_instruction,reason_for_hook_generation))
			{			
				HashMap<String,String> tmphm= new HashMap<String,String>();
				String reason_for_computed_call_or_jump="";
				if (this.incoming_hook_generator.current_program_listing.getFunctionContaining(addr)!=null && this.incoming_hook_generator.current_program_listing.getFunctionContaining(addr).getEntryPoint()==addr)
				{
					reason_for_computed_call_or_jump="start of function";
				}
				{
					reason_for_computed_call_or_jump="simple instruction";	
				}
				tmphm.put("Computed Call/Jump",reason_for_computed_call_or_jump);
				if (!this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.containsKey(addr))
				{
					this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.put(addr,tmphm );
				}
				else
				{
					//see if this address has already been registered as "Computed Call/Jump"
					if (this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.get(addr).containsKey("Computed Call/Jump"))
					{
						;//do nothing, it's already registered
					}
					else
					{
						this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.get(addr).put("Computed Call/Jump",reason_for_computed_call_or_jump);
					}
				}
			}
		}
	}
	
	protected String format_reason_for_hooking(String unformatted_reason)
	{
		String[] individual_reasons=unformatted_reason.split("\\|");
		int i;
		String retval="";
		int max_reasons_to_show=this.incoming_hook_generator.maximum_number_of_reasons_to_show;
		//starting from 1 as the first is not the reason, but the order of address, that is the increasing counter when it first appeared
		for (i=1;i<individual_reasons.length;i++)
		{
			if (i<=max_reasons_to_show)
			{
				retval=retval.concat(individual_reasons[i]);
				if (i<individual_reasons.length-1) //we haven't reached the end
				{
					retval=retval.concat("   ###   ");
				}
			}
			else
			{
				retval=retval.concat(", ... ");
				break;
			}
		}
		return retval;
	}
	
	protected String generate_random_string_from_pool(String pool,int length)
	{
		String retval="";
		Random random=new Random();
		for (int i=0;i<length;i++)
		{
			int select = random.nextInt(pool.length());
			retval+=pool.charAt(select);
		}
		return retval;
	}
	
	
	protected String generate_import_hook_str_for_function(String raw_function_name, String properly_sanitized_function_name, int parameter_count,String sanitized_export_module_name, String varstr_for_resolver_and_matches,String spaces)
	{
		String retval="";
		String sanitized_fun_name=properly_sanitized_function_name;
		retval+=spaces+"matches_"+varstr_for_resolver_and_matches+"=resolver_"+varstr_for_resolver_and_matches+".enumerateMatches('exports:"+sanitized_export_module_name+"!"+raw_function_name+"/i');\n"; //use the raw name in the exports search, it is sanitized enough from caller
		retval+=spaces+"if (matches_"+varstr_for_resolver_and_matches+".length>0)\n";
		retval+=spaces+"{\n";
		retval+=spaces+"    var first_match=matches_"+varstr_for_resolver_and_matches+"[0];\n";
		retval+=spaces+"    var dynamic_address_of_import_"+sanitized_fun_name+"=first_match.address;\n";
		retval+=spaces+"    Interceptor.attach(dynamic_address_of_import_"+sanitized_fun_name+", {\n"
			   +spaces+"                    onEnter: function(args) {\n"
			   +spaces+"                        console.log(\"Entered import_"+sanitized_fun_name+"\");\n";
		if (parameter_count>=1)
		{
			retval+=spaces+"                        console.log('";
			for (int i=0;i<parameter_count;i++)
			{
				retval+="args["+i+"]='+args["+i+"]";
				if (i<parameter_count-1) { retval+="+' , "; }
				else { retval+=");\n"; }
			}
		}
		retval+=spaces+"                        // this.context.x0=0x1;\n"
			  +spaces+ "                    },\n"
			  +spaces+ "                    onLeave: function(retval) {\n"
			  +spaces+ "                        console.log(\"Exited import_"+sanitized_fun_name+", retval:\"+retval);\n"
			  +spaces+ "                        // retval.replace(0x1);\n"
			  +spaces+ "                    }\n"
			  +spaces+ "        }); \n";
		retval+=spaces+"}\n";
		return retval;
	}
	
	boolean is_symbol_name_mangled_name(String symbol_name)
	{
		//Mangled Symbol. TODO: Provide a better check if a symbol is in a mangled form
		if (symbol_name.startsWith("_Z") || symbol_name.startsWith("?"))
		{
			return true;
		}
		return false;
	}

	String return_mangled_name_for_specific_address(Program incoming_program,Address incoming_address, Pattern pattern_to_match)
	{
		SymbolTable incoming_symbol_table=incoming_program.getSymbolTable();
		SymbolIterator symbol_interator=incoming_symbol_table.getSymbolsAsIterator(incoming_address);
		while(symbol_interator!=null && symbol_interator.hasNext())
		{
			Symbol next_symbol=symbol_interator.next();
			String symbol_name=next_symbol.getName();
			if (is_symbol_name_mangled_name(symbol_name))
			{
				
				if (pattern_to_match.matcher(symbol_name).matches())
				{
					return symbol_name;
				}
			}
		}
		return "";
	}
	
	String return_sanitized_module_name_regex_for_dll_external_function_import(String full_symbol_name)
	{
		String retval="*"; //match any module
		if (!full_symbol_name.toLowerCase().contains(".dll::"))
		{
			return retval;
		}
		String[] split_values=full_symbol_name.toLowerCase().split("\\.dll\\:\\:",0);
		String dll_name=split_values[0];
		String sanitized_dll_name_with_dot=dll_name.toLowerCase().replaceAll("[^"+this.characters_allowed_in_variable_name+"\\."+"]", "_");
		if (!sanitized_dll_name_with_dot.equals(dll_name.toLowerCase()))
		{
			return retval;
		}
		retval=sanitized_dll_name_with_dot+".dll";
		return retval;
	}
	
	protected void backpatch_reasons_for_advanced_hook_generation()
	{
		if (this.incoming_hook_generator.advancedhookoptionsdialog.isOutputReasonForHookGenCheckboxchecked)
		{
			this.incoming_hook_generator.maximum_number_of_reasons_to_show=Integer.parseInt(this.incoming_hook_generator.advancedhookoptionsdialog.ReasonForHookGenAmountcomboBox.getItemAt(this.incoming_hook_generator.advancedhookoptionsdialog.ReasonForHookGenAmountcomboBox.getSelectedIndex()));

			if (this.incoming_hook_generator.incoming_monitor.isCancelled()) {return ;} //check for cancellation by the user)
			this.incoming_hook_generator.incoming_monitor.setMessage("Backpatching reasons in hooks...");
			/*
			 * If that is the case, then the hook_str only has the prologue, as every other hook returned the empty string or a comment.
			 * Now it is time to go through all the hooks in the internal data structures and patch the reasons why they were hooked
			 */
			int i;
			for (i=0;i<this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch;i++)
			{
				Address current_addr =this.incoming_hook_generator.internal_structures_for_hook_generation.addresses_for_which_hook_is_generated_in_order_of_appearance.get(i);
				String current_hook_for_addr=this.incoming_hook_generator.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.get(i);
				String reason_str_for_current_hook=this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_for_current_hook_str.get(current_addr.toString());
				String formatted_reason_str_for_current_hook=format_reason_for_hooking(reason_str_for_current_hook);
				this.incoming_hook_generator.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.set(i,current_hook_for_addr.replace("PLACEHOLDER_FOR_REASONS_FOR_HOOKING_"+current_addr,formatted_reason_str_for_current_hook));
			
				if (i%100==0 && this.incoming_hook_generator.incoming_monitor.isCancelled()) {return ;} //check for cancellation by the user
				if (i%1000==0) {this.incoming_hook_generator.incoming_monitor.setMessage("Backpatching reasons in hooks "+(int)((i*100)/this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch)+"%...");}
			}
		}
		if (this.incoming_hook_generator.consoleService!=null)
		{
			this.incoming_hook_generator.consoleService.println("// Backpatching reasons completed");
		}
	}
	

	/*This function, effectively adds the code*/
	protected void backpatch_hooks_that_need_code_to_be_added_at_a_later_stage()
	{
		if (this.incoming_hook_generator.incoming_monitor.isCancelled()) {return;} //check for cancellation by the user)
		this.incoming_hook_generator.incoming_monitor.setMessage("Backpatching hooks that need more code...");
		
		int i;
		for (i=0;i<this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch;i++)
		{
			Address newaddr=this.incoming_hook_generator.internal_structures_for_hook_generation.addresses_for_which_hook_is_generated_in_order_of_appearance.get(i);
			if (this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.containsKey(newaddr))
			{
				
				
				Instruction newinstr=this.incoming_hook_generator.current_program_listing.getInstructionAt(newaddr);
				//newinstr will necessarily be not null, as a hook is supposed to be generated for it
				String current_hook_for_addr=this.incoming_hook_generator.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.get(i);
				String hook_to_replace_later_code_placeholder="";
				
				for (String reason: this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.get(newaddr).keySet())
				{
					if (reason=="Computed Call/Jump")
					{
						String options_for_computed_call_or_jump = this.incoming_hook_generator.internal_structures_for_hook_generation.Addresses_that_need_hook_code_to_be_added_at_a_later_stage.get(newaddr).get(reason);
						String spaces="";
						if (options_for_computed_call_or_jump=="simple instruction")
						{
							spaces="            ";
						}
						else
						{
							//options_for_computed_call_or_jump=="start of function"
							spaces="                        ";
						}
						String arg_of_call=newinstr.toString().split(" ",2)[1].toLowerCase().trim();  //remove of CALL/BLR... and get the rest, the argument
						String mnemonic_of_command=newinstr.getMnemonicString().toLowerCase().trim();
						ComputedCallHookGenerator hookgenerator=new ComputedCallHookGenerator(this.incoming_hook_generator,this.incoming_hook_generator.current_program,newaddr,mnemonic_of_command,arg_of_call,"module_name_"+this.incoming_hook_generator.current_program_name_sanitized);
						hook_to_replace_later_code_placeholder=hook_to_replace_later_code_placeholder.concat(hookgenerator.provide_hook_code(spaces));
					}
					//Other possible reasons can go here
				}

				this.incoming_hook_generator.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.set(i,current_hook_for_addr.replace("PLACEHOLDER_FOR_HOOK_CODE_TO_BE_ADDED_LATER_"+newaddr,hook_to_replace_later_code_placeholder));
				
				
				if (i%100==0 && this.incoming_hook_generator.incoming_monitor.isCancelled()) {return ;} //check for cancellation by the user
				if (i%1000==0) {this.incoming_hook_generator.incoming_monitor.setMessage("Backpatching hooks that need more code "+(int)((i*100)/this.incoming_hook_generator.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch)+"%...");}
			}
		}
				
	}
	
	
	
	

	
	protected String generate_backtrace_for_hook(Boolean called_from_function_start)
	{
		String hook_str="";
		String bt="";
		String ctx="";
		String spaces="";
		
		if (!this.incoming_hook_generator.isAdvanced || !this.incoming_hook_generator.advancedhookoptionsdialog.isGenerateBacktraceCheckboxchecked)
		{
			return "";
		}
		if ((this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==0 
				|| this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==1)
				&& !called_from_function_start)
		{
			return "";
		}
		
		if (called_from_function_start)
		{
			ctx="this.context";
			spaces="                        ";
		}
		else
		{ 
			ctx="null";
			spaces="            ";
		}
		
		//in case of Inerceptor.replace()
		if (this.incoming_hook_generator.advancedhookoptionsdialog.isCustomFunInterceptorHookOutputCheckboxchecked &&
				this.incoming_hook_generator.advancedhookoptionsdialog.CustomFunInterceptorHookOutputcomboBox.getSelectedIndex()==2)
		{
			ctx="null";
		}

		if (this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==0
			|| this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==2)
		{
			bt="Backtracer.ACCURATE";
		}
		if (this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==1
				|| this.incoming_hook_generator.advancedhookoptionsdialog.GenerateBacktracecomboBox.getSelectedIndex()==3)
		{
			bt="Backtracer.FUZZY";
		}
		
		hook_str=hook_str.concat(spaces+"console.log("+this.tid_and_indent_code()+"\"Backtrace:\"+");
		hook_str=hook_str.concat("Thread.backtrace("+ctx+", "+bt+")"
								+ ".map(DebugSymbol.fromAddress).join('\\n'+"+this.tid_and_indent_code()+"'') + '\\n');\n");
		return hook_str;
	}
	
	
	
	
	
}

```

`src/main/java/fridahookgenerator/InstructionSearchPatternHandler.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package fridahookgenerator;

import java.util.HashMap;

import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Program;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class InstructionSearchPatternHandler {
	
	private PluginTool incoming_plugintool;
	private Program current_program;
	private String incoming_instruction_pattern;
	private String incoming_module_name_sanitized;
	private String spaces;

	public InstructionSearchPatternHandler(PluginTool incoming_plugintool, Program current_program, String incoming_instruction_pattern , String incoming_module_name_sanitized, String spaces ) {
		this.incoming_plugintool=incoming_plugintool;
		this.current_program=current_program;
		this.incoming_instruction_pattern=incoming_instruction_pattern.toLowerCase().replace("\n"," ").replaceAll(" +", " ");
		this.incoming_module_name_sanitized=incoming_module_name_sanitized;
		this.spaces=spaces;
	}
	
	protected Boolean is_valid_incoming_instruction_pattern(String incoming_instruction_pattern)
	{
		String allowed_characters="0123456789abcdef[]. ";
		
		for (int i=0;i<incoming_instruction_pattern.length();i++)
		{
			char tmpchar=incoming_instruction_pattern.charAt(i);
			if (allowed_characters.indexOf(tmpchar)<0)
			{
				return false;
			}
		}
		return true;
	}

	protected Boolean is_valid_pattern_for_byte(String pattern_for_byte)
	{
		String hex_chars="0123456789abcdef";
		if (pattern_for_byte.length()==2)
		{
			if (hex_chars.indexOf(pattern_for_byte.charAt(0))>=0 && hex_chars.indexOf(pattern_for_byte.charAt(1))>=0)
			{
				return true;
			}
		}
		if (pattern_for_byte.length()==10)
		{
			if (pattern_for_byte.charAt(0)=='[' && pattern_for_byte.charAt(9)==']')
			{
				for (int i=1;i<=8;i++)
				{
					if (pattern_for_byte.charAt(i)!='0' && pattern_for_byte.charAt(i)!='1' && pattern_for_byte.charAt(i)!='.')
					{
						return false;
					}
				}
				return true;
			}
		}
		
		return false;
	}
	
	protected String return_frida_pattern_for_incoming_instruction_pattern(String incoming_instruction_pattern)
	{
		/*
		 * 5b 
		 * 5d 
         * [01001...] 8d 15 25 da 34 00 
		 */
		
		String res_pattern="";
		String mask_pattern="";
		
		if (!is_valid_incoming_instruction_pattern(incoming_instruction_pattern))
		{
			return "ERROR";
		}
		String[] parts_of_pattern=incoming_instruction_pattern.split(" ");
		for (int i=0;i<parts_of_pattern.length;i++)
		{
			String tmpbytepattern=parts_of_pattern[i];
			if (!is_valid_pattern_for_byte(tmpbytepattern))
			{
				return "ERROR";
			}
			if (tmpbytepattern.length()==2)
			{
				res_pattern+=tmpbytepattern+" ";
				mask_pattern+="ff ";
			}
			if (tmpbytepattern.length()==10)
			{
				String tmpres_for_byte="";
				String tmpmask_for_byte="";
				
				for (int j=1;j<=8;j++)
				{
					if (tmpbytepattern.charAt(j)=='.')
					{
						tmpres_for_byte+="0";
						tmpmask_for_byte+="0";
					}
					else
					{
						tmpres_for_byte+=tmpbytepattern.charAt(j);
						tmpmask_for_byte+="1";
					}
				}
				
				String byte_to_add_to_res=Integer.toString(Integer.parseInt(tmpres_for_byte,2),16);
				String byte_to_add_to_mask=Integer.toString(Integer.parseInt(tmpmask_for_byte,2),16);
				if (byte_to_add_to_res.length()==1)
				{
					byte_to_add_to_res="0"+byte_to_add_to_res;
				}
				if (byte_to_add_to_mask.length()==1)
				{
					byte_to_add_to_mask="0"+byte_to_add_to_mask;
				}
								
				res_pattern+=byte_to_add_to_res+" ";
				mask_pattern+=byte_to_add_to_mask+" ";
			}
		}
		return (res_pattern+": "+mask_pattern).trim();
	}
	
	
	protected String return_frida_code_for_incoming_instruction_pattern()
	{
		String frida_pattern=this.return_frida_pattern_for_incoming_instruction_pattern(this.incoming_instruction_pattern);
		if (frida_pattern.equals("ERROR"))
		{
			return "//Given pattern for Memory Scan is not valid\n";
		}
		String retval="";
		retval+=this.spaces+"var pattern_to_search_for= '"+frida_pattern+"'\n";
		retval+=this.spaces+"var loaded_modules= Process.enumerateModulesSync()\n";
		retval+=this.spaces+"for (var ind=0;ind<loaded_modules.length;ind++) {\n";
		retval+=this.spaces+"    if (loaded_modules[ind].name===module_name_"+this.incoming_module_name_sanitized+") //Comment out if you want to search in every loaded module\n";
		retval+=this.spaces+"    //if (loaded_modules[ind].name.toLowerCase().search('frida')===-1) //Comment out if you want to search in every loaded module\n";
		retval+=this.spaces+"    {\n";
		retval+=this.spaces+"        var m=loaded_modules[ind]\n";
		retval+=this.spaces+"        var ranges=m.enumerateRanges('r--')\n";
		retval+=this.spaces+"        var cnt_of_results_for_module=0\n";
		retval+=this.spaces+"        for (var rind=0;rind<ranges.length;rind++) {\n";
		retval+=this.spaces+"            var r=ranges[rind]\n";
		retval+=this.spaces+"            var res_of_memscan=Memory.scanSync(r.base,r.size,pattern_to_search_for)\n";
		retval+=this.spaces+"            if (res_of_memscan.length>0) {\n";
		retval+=this.spaces+"                //console.log('Found '+res_of_memscan.length+' results for pattern '+pattern_to_search_for+' inside module '+JSON.stringify(m)+' and range '+JSON.stringify(r))\n";
		retval+=this.spaces+"                cnt_of_results_for_module+=res_of_memscan.length\n";
		retval+=this.spaces+"                for (var j=0;j<res_of_memscan.length;j++) {\n";
		retval+=this.spaces+"                    console.log('Hooking address '+res_of_memscan[j].address+' from module '+JSON.stringify(m)+ ' with offset '+res_of_memscan[j].address.sub(m.base))\n";
		retval+=this.spaces+"                    var constructed_str_to_print='Reached address '+res_of_memscan[j].address+' inside module '+JSON.stringify(m)+ ' with offset '+res_of_memscan[j].address.sub(m.base)+' due to pattern '+ pattern_to_search_for \n";
		retval+=this.spaces+"                    Interceptor.attach(res_of_memscan[j].address, () => {\n";
		retval+=this.spaces+"                        console.log(constructed_str_to_print)\n";
		retval+=this.spaces+"				     })\n";
		retval+=this.spaces+"                }\n";
		retval+=this.spaces+"            }\n";
		retval+=this.spaces+"        }\n";
		retval+=this.spaces+"        if (cnt_of_results_for_module==0) {\n";
		retval+=this.spaces+"            console.log('Memory scan for pattern '+pattern_to_search_for+' did not give any results inside module '+JSON.stringify(m))\n";
		retval+=this.spaces+"        } else {\n";
		retval+=this.spaces+"            console.log('Memory scan for pattern '+pattern_to_search_for+' gave '+cnt_of_results_for_module+' results in total inside module '+JSON.stringify(m))\n";
		retval+=this.spaces+"        }\n";
		retval+=this.spaces+"    }\n";
		retval+=this.spaces+"}\n";
		
		return retval;
	}
	
	
}

```

`src/main/java/fridahookgenerator/InternalStructuresForHookGeneration.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.util.ArrayList;
import java.util.HashMap;

import ghidra.program.model.address.Address;

public class InternalStructuresForHookGeneration {
	
	//This is a hashmap that contains for which addresses a hook has been generated, in the current batch. It is a data structure held so that interceptor hooks are not being created for the same address twice. The value of the field will be in the following format: <index in sequence of addresses>|<reason for hook 1>|<reason for hook 2>|....
	protected HashMap<String, String> Addresses_for_current_hook_str;
	protected int how_many_addresses_have_been_hooked_so_far_in_this_batch;
	//This ArrayList keeps the addresses for which a hook is generated, by order of appearance. The reason is that when reasons of hooking are also printed in the console, we might need fast lookup for the address that came at position X.
	protected ArrayList<Address> addresses_for_which_hook_is_generated_in_order_of_appearance;
	//This ArrayList keeps the hooks which are generated for every individual address, in order of appearance.
	protected ArrayList<String> hooks_generated_per_address_in_order_of_appearance;
	//This HashMap keeps the addresses for which "special treatment" is requested. In other words, their hook will contain more things. For example, the computed call addresses will be in this list. The internal HashMap field contains the reasons for which special treatment is needed, in the following format: {"<reason1>":"<optional_info1>","<reason2>":"<optional_info2>"...}
	protected HashMap<Address,HashMap<String,String>> Addresses_that_need_hook_code_to_be_added_at_a_later_stage;
	//This HashMap keeps some messages that are to be output between the hooks, in the form <index,message>
	protected HashMap<Integer,String> Messages_to_be_included_between_hooks;
	
	public InternalStructuresForHookGeneration() {
		this.Addresses_for_current_hook_str= new HashMap<String, String>();
		this.how_many_addresses_have_been_hooked_so_far_in_this_batch=0;
		this.addresses_for_which_hook_is_generated_in_order_of_appearance=new ArrayList<Address>();
		this.hooks_generated_per_address_in_order_of_appearance=new ArrayList<String>();
		this.Addresses_that_need_hook_code_to_be_added_at_a_later_stage=new HashMap<Address,HashMap<String,String>>(); 
		this.Messages_to_be_included_between_hooks=new HashMap<Integer,String>();
	}
}

```

`src/main/java/fridahookgenerator/ParserOfComputedCalls.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

public interface ParserOfComputedCalls {

	public String create_frida_code_for_call_arg(String mnemonic,String arg);
}

```

`src/main/java/fridahookgenerator/ParsersOfComputedCalls/ARM64ParserOfComputedCall.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator.ParsersOfComputedCalls;

import java.util.ArrayList;

import docking.action.KeyBindingType;
import fridahookgenerator.ParserOfComputedCalls;
import ghidra.framework.plugintool.Plugin;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramSelection;

/*This class basically returns the argument to BLR <arg> in ARM64, translated into frida code. Much simpler than x64.*/
public class ARM64ParserOfComputedCall implements ParserOfComputedCalls{

	private Program incoming_program;
	private Language current_program_language;
	private Processor current_program_processor;
	private String incoming_module_name_sanitized;
	
	public ARM64ParserOfComputedCall(Program incoming_program, String incoming_module_name_sanitized) {
		this.incoming_program=incoming_program;
		this.current_program_language = this.incoming_program.getLanguage();
		this.current_program_processor = this.current_program_language.getProcessor();
		this.incoming_module_name_sanitized=incoming_module_name_sanitized;
	}
	
	
	public String create_frida_code_for_call_arg(String mnemonic,String arg)
	{
		String retval="";
		String arg_str_possibly_altered=arg;
		
		if (arg=="")
		{
			return "";
		}
		arg=arg.trim();
		
		if (mnemonic == "blr" || mnemonic == "br" || mnemonic == "bx")
		{
			arg_str_possibly_altered=arg;
		}
		if (mnemonic == "blraaz")
		{
			arg_str_possibly_altered=arg+".strip(\"ia\")";
		}
		if (mnemonic == "blrabz")
		{
			arg_str_possibly_altered=arg+".strip(\"ib\")";
		}
		//blraa, blrab not yet supported
		
		if (arg.matches("x[0-9]+$"))
		{
			retval+="(this.context."+arg_str_possibly_altered.toLowerCase()+")";
		}
		else
		{
			return "";
		}
		
		return retval;
	}	
}

```

`src/main/java/fridahookgenerator/ParsersOfComputedCalls/X86ParserOfComputedCall.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator.ParsersOfComputedCalls;

import java.util.ArrayList;

import docking.action.KeyBindingType;
import fridahookgenerator.ParserOfComputedCalls;
import ghidra.framework.plugintool.Plugin;
import ghidra.program.model.address.Address;
import ghidra.program.model.lang.Language;
import ghidra.program.model.lang.Processor;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramSelection;

/*This class tries to decode the argument to CALL <arg> in x86, and translate them into frida code*/
public class X86ParserOfComputedCall implements ParserOfComputedCalls{

	private Program incoming_program;
	private Language current_program_language;
	private Processor current_program_processor;
	private String incoming_module_name_sanitized;
	
	public X86ParserOfComputedCall(Program incoming_program, String incoming_module_name_sanitized) {
		this.incoming_program=incoming_program;
		this.current_program_language = this.incoming_program.getLanguage();
		this.current_program_processor = this.current_program_language.getProcessor();
		this.incoming_module_name_sanitized=incoming_module_name_sanitized;
	}
	
	
	public String create_frida_code_for_call_arg(String mnemonic,String arg)
	{
		String retval="";
		Boolean is_ptr_dereference=false;
		Boolean arg_is_a_number=false;
		if (arg=="")
		{
			return "";
		}
		arg=arg.replaceAll(".?word ptr","").trim();
		if (arg.charAt(0)=='[' && arg.charAt(arg.length()-1)==']')
		{
			is_ptr_dereference=true;
			arg=arg.substring(1, arg.length()-1); //Strip the dereference brackets and continue
			if (!arg.matches("[0-9a-zA-Z\\+\\*\\-\\ ]*")) //Allowed characters
			{
				return "";
			}
		}
		
		/*Check if arg is simply a hex number*/
		try {
			if (arg.strip().matches("^0x[a-fA-F0-9]+$"))
			{
				long tmplong=Long.parseLong(arg.substring(2),16);
				arg_is_a_number=true;
			}
		}
		catch (NumberFormatException ex)
		{
			arg_is_a_number=false;
		}

		if (arg_is_a_number)
		{
			/*Simply number, maybe in a dereference. No complex parsing needed*/
			//OLD_API:retval+="Module.findBaseAddress("+this.incoming_module_name_sanitized+").add("+arg+")";
			retval+="Process.getModuleByName("+this.incoming_module_name_sanitized+").base.add("+arg+")";
		}
		else
		{
			/*Do the parsing of the command */
			ArrayList<String> substrings_with_registers=new ArrayList<String>();
			String str_so_far="";
			for (int i=0;i<arg.length();i++)
			{
				if (arg.charAt(i)=='+' || arg.charAt(i)=='-' || arg.charAt(i)=='*' || i==arg.length()-1)
				{
					if (i==arg.length()-1 && arg.charAt(i)!='+' && arg.charAt(i)!='-' && arg.charAt(i)!='*')
					{
						//append
						str_so_far+=arg.charAt(i);
					}
					//create new entry in the arraylist
					substrings_with_registers.add(str_so_far);
					str_so_far=""; //reset
					if (arg.charAt(i)=='+' || arg.charAt(i)=='-' || arg.charAt(i)=='*')
					{
						substrings_with_registers.add(""+arg.charAt(i));
					}
				}
				else
				{
					//just append the character
					str_so_far+=arg.charAt(i);
				}
			}
			
			// Now try to construct the frida code
			int add_parentheses_because_of_previous_addition_or_subtraction=0; 
			for (int i=0;i<substrings_with_registers.size();i++)
			{
				if (substrings_with_registers.get(i).strip().equals("+"))
				{
					if (add_parentheses_because_of_previous_addition_or_subtraction>0)
					{
						//set the previous parentheses if any (created by previous additions or subtractions, but not inserted when encountering multiplication or a register)
						for (int j=0;j<add_parentheses_because_of_previous_addition_or_subtraction;j++)
						{
							retval+=")";
						}
						add_parentheses_because_of_previous_addition_or_subtraction=0;
					}
					
					retval+=".add(";
					add_parentheses_because_of_previous_addition_or_subtraction++;
				}
				else if (substrings_with_registers.get(i).strip().equals("-"))
				{
					
					if (add_parentheses_because_of_previous_addition_or_subtraction>0)
					{
						//set the previous parentheses if any (created by previous additions or subtractions, but not inserted when encountering multiplication or a register)
						for (int j=0;j<add_parentheses_because_of_previous_addition_or_subtraction;j++)
						{
							retval+=")";
						}
						add_parentheses_because_of_previous_addition_or_subtraction=0;
					}
					
					
					retval+=".sub(";
					add_parentheses_because_of_previous_addition_or_subtraction++;
				}
				else if (substrings_with_registers.get(i).strip().equals("*"))
				{
					retval+=".toInt32()*";  //if multiplies, it should be a small number
				}
				else
				{
					retval+=return_frida_register_if_str_is_register(substrings_with_registers.get(i).strip());
				}

			}
			//and set the remaining parentheses
			for (int i=0;i<add_parentheses_because_of_previous_addition_or_subtraction;i++)
			{
				retval+=")";
			}

		}
		
		retval="("+retval+")";
		if (is_ptr_dereference)
		{
			retval+=".readPointer()";
		}
		
		return retval;
	}
	
	
	private String return_frida_register_if_str_is_register(String in_str)
	{
		String retval="";
		in_str=in_str.toLowerCase();
		if (this.current_program_language.getLanguageID().toString().indexOf("x86:LE:64")>=0)
		{
			//case for x64
			if (in_str.indexOf("ax")>=0) retval="rax";
			if (in_str.indexOf("bx")>=0) retval="rbx";
			if (in_str.indexOf("cx")>=0) retval="rcx";
			if (in_str.indexOf("dx")>=0) retval="rdx";
			if (in_str.indexOf("si")>=0) retval="rsi";
			if (in_str.indexOf("di")>=0) retval="rdi";
			if (in_str.indexOf("sp")>=0) retval="sp";
			if (in_str.indexOf("bp")>=0) retval="rbp";
			if (in_str.indexOf("ip")>=0) retval="pc";
			if (in_str.indexOf("r8")>=0) retval="r8";
			if (in_str.indexOf("r9")>=0) retval="r9";
			if (in_str.indexOf("r10")>=0) retval="r10";
			if (in_str.indexOf("r11")>=0) retval="r11";
			if (in_str.indexOf("r12")>=0) retval="r12";
			if (in_str.indexOf("r13")>=0) retval="r13";
			if (in_str.indexOf("r14")>=0) retval="r14";
			if (in_str.indexOf("r15")>=0) retval="r15";
			if (in_str.indexOf("r16")>=0) retval="r16";
			if (in_str.indexOf("flags")>=0) retval="rflags";  //what sorcery is this
		}
		if (this.current_program_language.getLanguageID().toString().indexOf("x86:LE:32")>=0)
		{
			//case for x86, not ready yet. CALL far?
			if (in_str.indexOf("ax")>=0) retval="eax";
			if (in_str.indexOf("bx")>=0) retval="ebx";
			if (in_str.indexOf("cx")>=0) retval="ecx";
			if (in_str.indexOf("dx")>=0) retval="edx";
			if (in_str.indexOf("si")>=0) retval="esi";
			if (in_str.indexOf("di")>=0) retval="edi";
			if (in_str.indexOf("sp")>=0) retval="sp";
			if (in_str.indexOf("bp")>=0) retval="ebp";
			if (in_str.indexOf("ip")>=0) retval="pc";
			if (in_str.indexOf("flags")>=0) retval="eflags";  //If the code really does "call flags" flip table
		}
		
		if (retval=="")
		{
			//no substitution, probably a the in_str is a number
			retval=in_str;
		}
		else
		{
			retval="this.context."+retval;
		}
		return retval;
	}
	
}

```

`src/main/java/fridahookgenerator/SelectionBatchHookGenerationTask.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.util.ArrayList;
import java.util.Iterator;

import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Program;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.Task;
import ghidra.util.task.TaskMonitor;


/* 
 * This class handles the case where a selection of addresses is submitted for code generation.
 */
public class SelectionBatchHookGenerationTask extends Task {


	protected Boolean is_cancelled;
	private ArrayList<CodeUnit> code_units_to_try_to_hook_into;
	private PluginTool incoming_plugintool;
	private Boolean isSnippet;
	private Boolean isAdvanced;
	protected String final_hook_str;
	Program incoming_program;
	private AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog;
	protected InternalStructuresForHookGeneration internal_structures_for_hook_generation;
	private ConsoleService consoleService;
	private Boolean print_debug;
	protected String result_of_selectionbatch_hook_generation_task;
	
	public SelectionBatchHookGenerationTask(String title, ArrayList<CodeUnit> code_units_to_try_to_hook_into, PluginTool tool, Program incoming_program, 
											   AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog,InternalStructuresForHookGeneration incoming_internal_structures,
											   ConsoleService consoleService, Boolean print_debug)
	{
		super(title,true,false,true,true);  //Modal, takes the screen , also waitForTaskCompleted=true
		this.incoming_advancedhookoptionsdialog=incoming_advancedhookoptionsdialog;
		this.isSnippet=!this.incoming_advancedhookoptionsdialog.isGenerateScriptCheckboxchecked;
		this.isAdvanced=true;  //this is always an Advanced hook
		this.is_cancelled=false;
		this.incoming_program=incoming_program;
		this.internal_structures_for_hook_generation=incoming_internal_structures;
		this.final_hook_str="";
		this.consoleService=consoleService;
		this.print_debug=print_debug;
		this.code_units_to_try_to_hook_into=code_units_to_try_to_hook_into;
		this.incoming_plugintool=tool;
		this.print_debug=print_debug;
		this.result_of_selectionbatch_hook_generation_task="";
	}
	
	@Override
	public void run(TaskMonitor monitor) throws CancelledException {
		
		String hook_str="";
		this.result_of_selectionbatch_hook_generation_task="";
		
		//monitor.checkCancelled(); 
		if (monitor.isCancelled())
		{
			this.is_cancelled=true;
			this.result_of_selectionbatch_hook_generation_task="";
			monitor.cancel();
			System.out.println("Task is cancelled");
			return;
		}
		
		Boolean we_are_in_the_final_hook_of_the_batch=false;
		Boolean we_are_in_the_first_hook_of_the_batch=false;
		
		/*We will run multiple invocations of the Hook Generator, but these will share the internal data structures, and the end result will appear as one large invocation*/
		for (int i=0;i<code_units_to_try_to_hook_into.size();i++)
		{
			CodeUnit current_code_unit=this.code_units_to_try_to_hook_into.get(i);
			Address current_address=current_code_unit.getAddress();
			if (i==0)
			{
				//In case of script creation, which needs prologue/epilogue
				we_are_in_the_first_hook_of_the_batch=true;
			}
			else
			{
				we_are_in_the_first_hook_of_the_batch=false;
			}
			
			if (i==code_units_to_try_to_hook_into.size()-1)
			{
				//Backpatching of reasons should only be done in the last time. Also, in case of script creation, which needs prologue/epilogue
				we_are_in_the_final_hook_of_the_batch=true;
			}
			/*Initialize and run the hook generator for this iteration of the loop*/
			HookGenerator hook_generator=new HookGenerator(this.incoming_plugintool,this.incoming_program,current_address,this.isAdvanced,this.isSnippet,this.incoming_advancedhookoptionsdialog,
					monitor,this.internal_structures_for_hook_generation,we_are_in_the_first_hook_of_the_batch,we_are_in_the_final_hook_of_the_batch,this.consoleService,this.print_debug);
			hook_generator.do_generate_hook();
			if (monitor.isCancelled()) //check for cancellation
			{
				this.is_cancelled=true;
				this.result_of_selectionbatch_hook_generation_task="";
				monitor.cancel();
				System.out.println("Task is cancelled");
				return;
			}
			hook_str=hook_str.concat(hook_generator.final_hook_str); //If not, append the output
			if (i%400==0)
			{
				System.out.println("Completed "+i+"/"+code_units_to_try_to_hook_into.size()+" code units");
			}
		}

		if (monitor.isCancelled())
		{
			this.is_cancelled=true;
			this.result_of_selectionbatch_hook_generation_task="";
			monitor.cancel();
			System.out.println("Task is cancelled");
			return;
		}


		this.result_of_selectionbatch_hook_generation_task=hook_str; //Set the result
		System.out.println("Task is completed");
		return;
			
	}


}

```

`src/main/java/fridahookgenerator/SelectionHookGenerationAction.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package fridahookgenerator;

import java.awt.Component;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Objects;

import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.KeyBindingType;
import docking.action.MenuData;
import ghidra.app.context.ListingActionContext;
import ghidra.app.context.NavigatableActionContext;
import ghidra.app.context.ProgramActionContext;
import ghidra.app.plugin.ProgramPlugin;
import ghidra.app.plugin.core.symboltree.SymbolTreeActionContext;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressRange;
import ghidra.program.model.address.AddressSet;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramSelection;
import ghidra.util.table.GhidraTable;
import ghidra.util.task.TaskMonitor;

public class SelectionHookGenerationAction extends DockingAction {
	protected Plugin incoming_plugin;
	protected ProgramSelection incoming_selection;
	protected Program current_program;
	private SelectionHookGenerationTaskDispatcher selection_hook_generation_dispatcher;

	
	public SelectionHookGenerationAction(Plugin plugin, ProgramSelection current_selection) {
		super("Create_frida_hook_for_selection", plugin.getName(), KeyBindingType.SHARED);
		this.incoming_plugin = plugin;
		this.incoming_selection=current_selection; //will be null initially
		this.current_program=null;
		init();
	}
	
	
	private void init() {
		setPopupMenuData(
			new MenuData(new String[] { "Create Frida Hooks for selection..." }, null,"Frida-Hook"));
		setDescription("Generate Frida Hooks from the selected rows");
	}

	@Override
	public boolean isEnabledForContext(ActionContext context) {
		/*This function not only checks if the submenu should appear (be enabled), 
		 * it also initializes the variable it's based on, the "this.current_program"
		 */
		
		if (this.incoming_plugin==null)
		{
			return false;
		}
				
		/* The first allowed case, when we are invoked from a "Search..." menu, our ContextObject is a Ghidra Table*/
		if (context.getContextObject() instanceof GhidraTable)
		{
			this.current_program=((GhidraTable)context.getContextObject()).getProgram();
			if (this.current_program==null)
			{
				return false;
			}
		}
		
		/*The second allowed case, if we are in a ProgramActionContext. The ListingActionContext, in the typical (non-selection) invocation of the plugin, is a subclass of that*/
		if (context instanceof ProgramActionContext)
		{
			this.current_program=((ProgramActionContext) context).getProgram();
			if (this.current_program==null)
			{
				return false;
			}
		}
		
		if (this.current_program==null)
		{
			return false;
		}

		this.incoming_selection=((ProgramPlugin)incoming_plugin).getProgramSelection();  //The creator is a frida_hook_generatorPlugin, therefore a ProgramPlugin
		return (this.incoming_selection!=null && incoming_selection.getNumAddresses()>0);
	}
	
	
	@Override
	public void actionPerformed(ActionContext context) {
		
		ArrayList<CodeUnit> code_units_to_try_to_hook_into=new ArrayList<CodeUnit>(); //these will be the code units in the selection

		Listing current_program_listing=this.current_program.getListing();

		Iterator<Address> address_iterator= this.incoming_selection.getAddresses(true);
		/* Get all the code units */
		System.out.println("Getting all the code units for the selected addresses...");
		while (address_iterator!=null && address_iterator.hasNext())
		{
			Address current_address=address_iterator.next();
			CodeUnit current_code_unit=current_program_listing.getCodeUnitAt(current_address); //Is the current address at the start of a code unit?
			if (current_code_unit!=null)
			{
				code_units_to_try_to_hook_into.add(current_code_unit); //If yes, add it to the list
				int length_of_codeunit=current_code_unit.getLength();
				if (current_address.equals(current_code_unit.getMinAddress()))
				{
				    for (int i=0;i<length_of_codeunit-1;i++)
				    {
				        address_iterator.next(); //skip the rest of the addresses until the end of the codeunit
				    }
				}
			}
		}
		
		this.selection_hook_generation_dispatcher=new SelectionHookGenerationTaskDispatcher(this.incoming_plugin.getTool(),this.current_program,code_units_to_try_to_hook_into,new ArrayList<CodeUnit>());
		this.selection_hook_generation_dispatcher.perform_selection_hook_action();
	}
	
}

```

`src/main/java/fridahookgenerator/SelectionHookGenerationTaskDispatcher.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;

import docking.action.KeyBindingType;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.CodeUnit;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramSelection;

public class SelectionHookGenerationTaskDispatcher {
	
	private PluginTool incoming_plugintool;
	private ArrayList<CodeUnit> incoming_selection;
	private ArrayList<CodeUnit> incoming_selection_to_exclude;
	private Program current_program;
	private Boolean is_invoked_with_a_created_advancedhookoptions_dialog;
	private AdvancedHookOptionsDialog once_off_advanced_hook_options_dialog;
	private ConsoleService consoleService;
	private InternalStructuresForHookGeneration internal_structures_for_hook_generation;
	private SelectionBatchHookGenerationTask selectionbatch_hook_generation_task;
	
	public SelectionHookGenerationTaskDispatcher(PluginTool plugintool, Program incoming_program,ArrayList<CodeUnit> selected_code_units_to_hook, ArrayList<CodeUnit> selected_code_units_to_exclude) {
		this.incoming_plugintool = plugintool;
		this.incoming_selection=selected_code_units_to_hook;
		this.incoming_selection_to_exclude=selected_code_units_to_exclude;
		this.current_program=incoming_program;
		this.is_invoked_with_a_created_advancedhookoptions_dialog=false;
	}
	
	public SelectionHookGenerationTaskDispatcher(PluginTool plugintool, Program incoming_program,ArrayList<CodeUnit> selected_code_units_to_hook,ArrayList<CodeUnit> selected_code_units_to_exclude, AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog) {
		this.incoming_plugintool = plugintool;
		this.incoming_selection=selected_code_units_to_hook;
		this.incoming_selection_to_exclude=selected_code_units_to_exclude;
		this.current_program=incoming_program;
		this.is_invoked_with_a_created_advancedhookoptions_dialog=true;
		this.once_off_advanced_hook_options_dialog=incoming_advancedhookoptionsdialog;
	}

	

	public String perform_selection_hook_action()
	{
		String retval;
		ArrayList<CodeUnit> code_units_to_try_to_hook_into=this.incoming_selection; //these are the code units in the selection
		Listing current_program_listing=this.current_program.getListing();
		
		if (!is_invoked_with_a_created_advancedhookoptions_dialog)
		{
			/*Initialize the dialog, which will appear once and affect all the code units of the selection, one by one*/
			this.once_off_advanced_hook_options_dialog=new AdvancedHookOptionsDialog("Generate Hooks for selection",this.incoming_plugintool,this.current_program,true);
			this.once_off_advanced_hook_options_dialog.fetch_advanced_hook_options(null, this.current_program);  //show the dialog
		}
		else
		{
			/* The dialog is already initialized, make sure the values are set correctly*/
			this.once_off_advanced_hook_options_dialog.initDialogForAdvancedHookOptions(this.current_program, null);
			this.once_off_advanced_hook_options_dialog.okCallback();  //force the virtual pressing of the OK button
		}
		String entire_hook="";

		//Initialize the console
		this.consoleService=this.incoming_plugintool.getService(ConsoleService.class); 

		if (!this.once_off_advanced_hook_options_dialog.isOKpressed)
		{
			System.out.println("User clicked at advanced options but did not press OK");
			return "";
		}
		

		//use data structures that are common across all hook generation calls
		this.internal_structures_for_hook_generation=new InternalStructuresForHookGeneration();
		
		//put the addresses to be excluded inside the data structures (they are unique)
		for (int i=0;i<this.incoming_selection_to_exclude.size();i++)
		{
			Address tmpaddr=this.incoming_selection_to_exclude.get(i).getAddress();
			String in_place_of_hook=" //Address:"+tmpaddr+", explicitly excluded from hooking\n";
			String reason_for_hook_generation="Explicitly excluded from hooking";
			//manual insertion for the address in the structures. This code effectively clones the main part of the function HookGeneratorUtils::update_internal_data_structures() . TODO: do not repeat code 
			this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch++;
			String tmpstr=String.valueOf(this.internal_structures_for_hook_generation.how_many_addresses_have_been_hooked_so_far_in_this_batch)+"|"+reason_for_hook_generation;
			this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.put(tmpaddr.toString(),tmpstr); //this is the initial placement of this address in the Addresses_for_current_hook_str data structure
			this.internal_structures_for_hook_generation.addresses_for_which_hook_is_generated_in_order_of_appearance.add(tmpaddr);
			this.internal_structures_for_hook_generation.hooks_generated_per_address_in_order_of_appearance.add(in_place_of_hook);
		}
		
		if (this.consoleService!=null)
		{
			this.consoleService.println("// Generating hooks... Please wait");
		}

		//Initialize the task which will do the job. It will present a "Generating hooks..." window
		this.selectionbatch_hook_generation_task=new SelectionBatchHookGenerationTask("Generating Hooks for selection...",code_units_to_try_to_hook_into,this.incoming_plugintool,this.current_program, 
													   this.once_off_advanced_hook_options_dialog,this.internal_structures_for_hook_generation,this.consoleService,false);
		this.incoming_plugintool.execute(selectionbatch_hook_generation_task); //Execute the task
		//Due to the way the task is constructed (modal = true, waitfortaskcompleted=true), the code will block here until the task is done.
		entire_hook=entire_hook.concat(this.selectionbatch_hook_generation_task.result_of_selectionbatch_hook_generation_task);  //the result is put in result_of_selectionbatch_hook_generation_task

		/*Output*/
		retval=handle_output(entire_hook,code_units_to_try_to_hook_into);

		//Try to cleanup
		code_units_to_try_to_hook_into=null;
		this.once_off_advanced_hook_options_dialog=null;
		this.selectionbatch_hook_generation_task=null;
		this.internal_structures_for_hook_generation=null;
		entire_hook="";
		System.gc();
		
		return retval;
	}
	

	
	protected String handle_output(String hook_str,ArrayList<CodeUnit> code_units_to_try_to_hook_into)
	{
		Boolean user_has_cancelled_do_not_destroy_clipboard=false;
		if (this.selectionbatch_hook_generation_task.is_cancelled )
		{
			//This is the case where the user has manually cancelled
			hook_str="// User has cancelled\n";
			user_has_cancelled_do_not_destroy_clipboard=true;
		}
		else
		{
			if (this.consoleService!=null)
			{
				this.consoleService.println("// Hook Generated");
			}	
			hook_str=hook_str.concat("// Tried to generate hooks for "+this.internal_structures_for_hook_generation.Addresses_for_current_hook_str.size()+" different addresses, coming from a selection size of "+code_units_to_try_to_hook_into.size()+" code units\n");
		}
		//Print to eclipse console
		System.out.println(hook_str);
		
		if (!user_has_cancelled_do_not_destroy_clipboard)
		{
			//Copy to clipboard
			StringSelection stringSelection = new StringSelection(hook_str);
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(stringSelection, null);
		}				
		
		//Print to Ghidra Console, but do not print if it is invoked through the GhidraScript with a created AdvancedHookOptionsDialog. 
		//In that case, the hook string will be returned to the user. 
		if (this.consoleService!=null && (!this.is_invoked_with_a_created_advancedhookoptions_dialog))
		{
			this.consoleService.println(hook_str);
		}
		else
		{
			System.out.println("Can't print to console because consoleService is null");
		}
		return hook_str;
	}
	
	
}

```

`src/main/java/fridahookgenerator/StandardHookGenerationTask.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import ghidra.app.context.ListingActionContext;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Program;
import ghidra.util.exception.CancelledException;
import ghidra.util.task.Task;
import ghidra.util.task.TaskDialog;
import ghidra.util.task.TaskMonitor;

public class StandardHookGenerationTask extends Task {

	protected Boolean is_cancelled;
	private PluginTool incoming_plugintool;
	private Boolean isSnippet;
	private Boolean isAdvanced;
	protected String final_hook_str;
	Program incoming_program;
	Address incoming_address;
	private AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog;
	protected InternalStructuresForHookGeneration internal_structures_for_hook_generation;
	private ConsoleService consoleService;
	private Boolean print_debug;
	protected String result_of_standard_hook_generation;
	
	public StandardHookGenerationTask(String title, PluginTool tool, Program incoming_program, Address incoming_address, Boolean isAdvanced, Boolean isSnippet, 
			AdvancedHookOptionsDialog incoming_advancedhookoptionsdialog,InternalStructuresForHookGeneration incoming_internal_structures,
			ConsoleService consoleService, Boolean print_debug) 
	{
		super(title,true,false,true,true);  //Modal, takes the screen , also waitForTaskCompleted=true	
		this.incoming_plugintool = tool;
		this.isSnippet = isSnippet;
		this.isAdvanced = isAdvanced;
		this.incoming_program=incoming_program;
		this.incoming_address=incoming_address;
		this.internal_structures_for_hook_generation=incoming_internal_structures;
		this.incoming_advancedhookoptionsdialog=incoming_advancedhookoptionsdialog;
		this.final_hook_str="";
		this.consoleService=consoleService;
		this.print_debug=print_debug;
		this.is_cancelled=false;
		this.result_of_standard_hook_generation="";
	}
	
	@Override
	public void run(TaskMonitor monitor) throws CancelledException {
		
		this.result_of_standard_hook_generation="";
		String hook_str="";
		//Initialize the hook generator. The variables we_are_in_the_first/last_hook_of_the_batch are set to true, as the generator will only be invoked once
		HookGenerator hook_generator=new HookGenerator(this.incoming_plugintool,this.incoming_program,this.incoming_address,this.isAdvanced,this.isSnippet,this.incoming_advancedhookoptionsdialog,
				monitor,this.internal_structures_for_hook_generation,true,true,this.consoleService,this.print_debug);
		
		//monitor.checkCancelled();
		if (monitor.isCancelled())
		{
			this.is_cancelled=true;
			this.result_of_standard_hook_generation="";
			monitor.cancel();
			System.out.println("Task is cancelled");
			return;
		}
		
		
		hook_generator.do_generate_hook(); 
		
		if (monitor.isCancelled())
		{
			this.is_cancelled=true;
			this.result_of_standard_hook_generation="";
			monitor.cancel();
			System.out.println("Task is cancelled");
			return;
		}

		hook_str=hook_str.concat(hook_generator.final_hook_str);
		this.result_of_standard_hook_generation=hook_str; //put the result in result_of_standard_hook_generation
		System.out.println("Task is completed");
		return;
			
	}

}

```

`src/main/java/fridahookgenerator/StructAccessCodeGenerationAction.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package fridahookgenerator;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.tree.TreePath;

import org.apache.commons.lang3.StringUtils;

import docking.ActionContext;
import docking.action.DockingAction;
import docking.action.KeyBindingType;
import docking.action.MenuData;
import docking.widgets.tree.GTree;
import docking.widgets.tree.GTreeNode;
import ghidra.app.plugin.core.datamgr.DataTypesActionContext;
import ghidra.app.plugin.core.datamgr.tree.DataTypeNode;
import ghidra.app.plugin.core.navigation.FindAppliedDataTypesService;
import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.Plugin;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.data.Composite;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.Enum;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.listing.Program;
import ghidra.program.util.ProgramSelection;
import ghidra.util.table.GhidraTable;

public class StructAccessCodeGenerationAction extends DockingAction {

	protected Plugin incoming_plugin;
	protected Program current_program;
	protected Boolean is_recursive;
	private ConsoleService consoleService;
	private String characters_allowed_in_variable_name="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
	
	public StructAccessCodeGenerationAction(Plugin plugin, Boolean is_recursive) {
		super("Create_frida_offsets_for_struct", plugin.getName(), KeyBindingType.SHARED);
		this.incoming_plugin = plugin;
		this.current_program=null;
		this.is_recursive=is_recursive;
		init();
	}
	
	private void init() {
		if (this.is_recursive)
		{
			setPopupMenuData(
				new MenuData(new String[] { "Create Frida offsets for struct (and substructs)" }, null,"Frida-Hook"));
			setDescription("Generate Frida Offsets for this struct type and its contained substruct types (but not pointed struct types)");
		}
		else
		{
			setPopupMenuData(
					new MenuData(new String[] { "Create Frida offsets for struct (only this one)" }, null,"Frida-Hook"));
				setDescription("Generate Frida Offsets for this struct type");
		}
	}
	
	@Override
	public boolean isEnabledForContext(ActionContext context) {
		/*This function not only checks if the Struct offsets submenu should appear (be enabled), 
		 * it also initializes the the "this.current_program" variable
		 */
		
		if (this.incoming_plugin==null)
		{
			return false;
		}
		
		if (!(context instanceof DataTypesActionContext)) {
			return false;
		}

		DataTypesActionContext context_as_DataTypesActionContext=(DataTypesActionContext)context;
		this.current_program=context_as_DataTypesActionContext.getProgram();
		if (this.current_program==null)
		{
			return false;
		}
		
		
		Object contextObject = context.getContextObject();
		GTree gtree = (GTree) contextObject;
		TreePath[] selectionPaths = gtree.getSelectionPaths();
		if (selectionPaths.length != 1) {
			return false;
		}

		GTreeNode node = (GTreeNode) selectionPaths[0].getLastPathComponent();
		if (!(node instanceof DataTypeNode)) {
			return false;
		}
		DataTypeNode dtNode = (DataTypeNode) node;
		DataType dataType = dtNode.getDataType();
		//return dataType instanceof Composite || dataType instanceof Enum;
		return (dataType instanceof Composite && dataType instanceof Structure); 
	}

	@Override
	public void actionPerformed(ActionContext context) {

		GTree gTree = (GTree) context.getContextObject();
		TreePath[] selectionPaths = gTree.getSelectionPaths();
		final DataTypeNode dataTypeNode = (DataTypeNode) selectionPaths[0].getLastPathComponent();

		PluginTool tool = this.incoming_plugin.getTool();

		this.consoleService=tool.getService(ConsoleService.class); 
		
		
		DataType dt = dataTypeNode.getDataType();
		Structure dt_as_structure = (Structure) dt;
		
		
		StructAccessCodeGenerator structaccesscodegenerator=new StructAccessCodeGenerator(this.incoming_plugin.getTool(),this.current_program,dt_as_structure,new String[0],this.is_recursive,false,true);
		
		String hook_str=structaccesscodegenerator.generate_hook_str();  //this will also handle the output, as it is initialized with that option set to true
	}
	
	
	


}

```

`src/main/java/fridahookgenerator/StructAccessCodeGenerator.java`:

```java
/* 
 * BSD 2-Clause License
 *
 * Copyright (c) 2022, CENSUS
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package fridahookgenerator;

import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.HashMap;

import ghidra.app.services.ConsoleService;
import ghidra.framework.plugintool.PluginTool;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.Structure;
import ghidra.program.model.listing.Program;

/*
 * This class generates code for struct fields, to make their access easier from javascript.
 */

public class StructAccessCodeGenerator {

	private PluginTool incoming_plugintool;
	protected Program current_program;
	private ConsoleService consoleService;
	Structure incoming_structure;
	private String characters_allowed_in_variable_name="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
	Boolean is_recursive_call;
	HashMap <String,String> included_structures;
	Boolean is_invoked_programmatically_from_the_api;
	Boolean should_output;
	String[] list_of_paths_to_be_excluded;
	
	public StructAccessCodeGenerator(PluginTool incoming_plugintool, Program current_program, Structure incoming_structure, 
			String[] list_of_paths_to_be_excluded,Boolean is_recursive_call , Boolean is_invoked_programmatically , Boolean should_output ) {
		
		this.incoming_plugintool=incoming_plugintool;
		this.current_program=current_program;
		this.incoming_structure=incoming_structure;
		this.is_recursive_call=is_recursive_call;
		this.included_structures=new HashMap<String,String>();
		this.is_invoked_programmatically_from_the_api=is_invoked_programmatically;
		this.should_output=should_output;		
		this.consoleService=incoming_plugintool.getService(ConsoleService.class); 
		this.list_of_paths_to_be_excluded=new String[list_of_paths_to_be_excluded.length];
		for (int i=0;i<list_of_paths_to_be_excluded.length;i++)
		{
			this.list_of_paths_to_be_excluded[i]=list_of_paths_to_be_excluded[i];
			this.included_structures.put(list_of_paths_to_be_excluded[i], "already_included");
		}
	}
	
	
	protected Boolean is_structure_empty(Structure in_struct)
	{
		if (in_struct.getNumComponents()==0 || in_struct.isZeroLength())
		{
			return true;
		}
		return false;
	}
	
	
	protected String generate_recursive_hook_str(Structure in_struct)
	{
		String hook_str="";
		DataTypeComponent[] components = in_struct.getComponents(); //all components, even filler fields
		
		//generate recursive hooks for subcomponents
		for (int i=0;i<components.length;i++)
		{
			if (components[i].getDataType() instanceof Structure && !this.included_structures.containsKey(components[i].getDataType().getPathName())) 
			{
				String this_hook=generate_recursive_hook_str((Structure) components[i].getDataType());
				hook_str+=this_hook;
				this.included_structures.put(components[i].getDataType().getPathName(), this_hook);
			}
		}
		
		//now generate proper hook for ourselves
		if (!this.included_structures.containsKey(in_struct.getPathName()))
		{
			hook_str+=generate_hook_str_for_one_struct(in_struct,true);
		}
		
		return hook_str;
		
	}
	
	
	public String generate_hook_str()
	{
		String hook_str="";
		
		if (!this.is_recursive_call)
		{
			hook_str+=generate_hook_str_for_one_struct(this.incoming_structure,false); 
		}
		else
		{
			hook_str+=generate_recursive_hook_str(this.incoming_structure); 
		}
		
		if (this.should_output)
		{
			handle_output(hook_str);
		}
		
		return hook_str;
		
	}

	protected String generate_hook_str_for_one_struct(Structure dt_as_structure, Boolean initialize_subcomponent_members)
	{
		
		String hook_str="";
		
		
		String name_of_struct=dt_as_structure.getPathName().replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
		
		DataTypeComponent[] components = dt_as_structure.getComponents(); //all components, even filler fields
		int struct_alignment=dt_as_structure.getAlignment();
		int num_of_components=dt_as_structure.getNumComponents();
		int total_size=dt_as_structure.getLength();
		boolean is_packed=dt_as_structure.isPackingEnabled();
		
		if (is_structure_empty(dt_as_structure)) 
		{
			String str_to_ret="//Structure "+name_of_struct+" has 0 components or reported as having 0 length\n";
			return str_to_ret;
		}
		
		String[] fieldnames = new String[num_of_components];
		String[] field_displaynames_for_types = new String[num_of_components];
		String[] field_descriptions_for_types = new String[num_of_components];
		int[] list_of_offsets_in_bytes=new int[num_of_components];
		int[] list_of_lengths_in_bytes=new int[num_of_components];
		boolean[] is_bitfied= new boolean[num_of_components];
		boolean[] component_returns_valid_hook= new boolean[num_of_components];
		int last_position_of_component_which_returns_valid_hook=-1;
		
		/*Iterate over all components and store them into the arrays*/
		for (int i=0;i<num_of_components;i++)
		{
			DataTypeComponent dataTypeComponent=dt_as_structure.getComponent(i);
			String fieldname=dataTypeComponent.getFieldName();
			if ( fieldname==null || fieldname.strip().equals(""))
			{
				fieldnames[i]="unnamed_field_at_position_"+(i+1);
			}
			else
			{
				fieldnames[i]=fieldname.replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
			}
			field_displaynames_for_types[i]=dataTypeComponent.getDataType().getDisplayName().replace("\n", " ");
			field_descriptions_for_types[i]=dataTypeComponent.getDataType().getDescription().replace("\n", " ");
			list_of_offsets_in_bytes[i]=dataTypeComponent.getOffset();
			list_of_lengths_in_bytes[i]=dataTypeComponent.getLength();
			is_bitfied[i]=dataTypeComponent.isBitFieldComponent();
			if (dataTypeComponent.getDataType() instanceof Structure && !is_structure_empty((Structure) dataTypeComponent.getDataType()))
			{
				component_returns_valid_hook[i]=true;
				last_position_of_component_which_returns_valid_hook=i;
			}
			else
			{
				component_returns_valid_hook[i]=false;
			}
		}
		
		hook_str ="class struct_"+name_of_struct+" {\n";
		hook_str+="    constructor(baseaddr) {\n";
		hook_str+="        this.alignment = "+struct_alignment+"\n";
		hook_str+="        this.is_packed = "+is_packed+"\n";
		hook_str+="        this.base = baseaddr\n";
		hook_str+="        this.total_size = "+total_size+"\n";
		hook_str+="        this.layout = {\n";
		
		for (int i=0;i<num_of_components;i++)
		{
			if (is_bitfied[i])
			{
				hook_str+="            //caution: field '"+fieldnames[i]+"' is a bitfield, access it carefully \n";
			}
			String addcomma=",";
			if (i==num_of_components-1)
			{
				addcomma=""; //do not add it at the end
			}
			hook_str+="            "+fieldnames[i]+" : this.base.add("+list_of_offsets_in_bytes[i]+")"+addcomma+"   //"+field_displaynames_for_types[i]+", size:"+list_of_lengths_in_bytes[i]+" - "+field_descriptions_for_types[i]+"\n";
		}
	
		hook_str+="        }\n";
		hook_str+="        this.offsets = {\n";
		
		for (int i=0;i<num_of_components;i++)
		{
			if (is_bitfied[i])
			{
				hook_str+="            //caution: field '"+fieldnames[i]+"' is a bitfield, access it carefully \n";
			}
			String addcomma=",";
			if (i==num_of_components-1)
			{
				addcomma=""; //do not add it at the end
			}
			hook_str+="            "+fieldnames[i]+" : "+list_of_offsets_in_bytes[i]+addcomma+"   //"+field_displaynames_for_types[i]+", size:"+list_of_lengths_in_bytes[i]+"\n";
		}
	
		hook_str+="        }\n";
		if (initialize_subcomponent_members && last_position_of_component_which_returns_valid_hook>-1) //check if at least one component will return a valid hook
		{
			hook_str+="        this.members = {\n";
			
			for (int i=0;i<num_of_components;i++)
			{
				String addcomma=",";
				if (component_returns_valid_hook[i])
				{
					String full_name_of_component=dt_as_structure.getComponent(i).getDataType().getPathName().replaceAll("[^"+this.characters_allowed_in_variable_name+"]", "_");
					if (i==last_position_of_component_which_returns_valid_hook)
					{
						addcomma=""; //do not add it at the end
					}
					hook_str+="            "+fieldnames[i]+" : new struct_"+full_name_of_component+"(this.layout."+fieldnames[i]+")"+addcomma+"  \n";
				}		
			}
		
			hook_str+="        }\n";
		}
		hook_str+="    }\n";
		
		
		hook_str+="}\n\n";
		
		return hook_str;
	}
	
	public void handle_output(String incoming_hook_str)
	{
		//Print to eclipse console
		System.out.println(incoming_hook_str);

		//Copy to clipboard
		StringSelection stringSelection = new StringSelection(incoming_hook_str);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(stringSelection, null);
						
		//Print to Ghidra Console	
		if (this.consoleService!=null)
		{
			this.consoleService.println(incoming_hook_str);
		}
		else
		{
			System.out.println("Can't print to console because consoleService is null");
		}
	}
	
	
}

```

`src/main/resources/images/README.txt`:

```txt
The "src/resources/images" directory is intended to hold all image/icon files used by
this module.

```

`src/test/java/README.test.txt`:

```txt
The "test" directory is intended to hold unit test cases.  The package structure within
this folder should correspond to that found in the "src" folder.

```