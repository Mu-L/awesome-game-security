Project Path: arc_DeDf_WProtect_dhokljye

Source Tree:

```txt
arc_DeDf_WProtect_dhokljye
├── 1_main.cpp
├── AddressTable.hpp
├── Analysis.cpp
├── AsmJit
│   ├── ApiBegin.h
│   ├── ApiEnd.h
│   ├── AsmJit.h
│   ├── AsmJitEnlarge.cpp
│   ├── AsmJitEnlarge.h
│   ├── Assembl.cpp
│   ├── Assembler.h
│   ├── AssemblerX86X64.cpp
│   ├── AssemblerX86X64.h
│   ├── Build.h
│   ├── CodeGenerator.cpp
│   ├── CodeGenerator.h
│   ├── Compiler.cpp
│   ├── Compiler.h
│   ├── CompilerX86X64.cpp
│   ├── CompilerX86X64.h
│   ├── Config.h
│   ├── CpuInfo.cpp
│   ├── CpuInfo.h
│   ├── Defs.cpp
│   ├── Defs.h
│   ├── DefsX86X64.cpp
│   ├── DefsX86X64.h
│   ├── Logger.cpp
│   ├── Logger.h
│   ├── MemoryManager.cpp
│   ├── MemoryManager.h
│   ├── MemoryMarker.cpp
│   ├── MemoryMarker.h
│   ├── Operand.h
│   ├── OperandX86X64.cpp
│   ├── OperandX86X64.h
│   ├── Platform.cpp
│   ├── Platform.h
│   ├── Util.cpp
│   ├── Util.h
│   ├── Util_p.h
│   ├── assembl.h
│   ├── opcode_table.cpp
│   └── opcode_table.h
├── BuildCode.hpp
├── BuildVMByteCode.cpp
├── BuildVMByteCode.hpp
├── CombosVMCode.cpp
├── Libudis86
│   ├── decode.c
│   ├── decode.h
│   ├── extern.h
│   ├── itab.c
│   ├── itab.h
│   ├── stdint.h
│   ├── syn-att.c
│   ├── syn-intel.c
│   ├── syn.c
│   ├── syn.h
│   ├── types.h
│   ├── udint.h
│   ├── udis86.c
│   └── udis86.h
├── OutDetailedInformation.cpp
├── OutDetailedInformation.hpp
├── PCode.cpp
├── PCode.hpp
├── PE
│   ├── PEExport.cpp
│   ├── PEFile.cpp
│   ├── PEFile.h
│   ├── PEImport.cpp
│   ├── PEReloc.cpp
│   └── PESection.cpp
├── SeniorVMHandle.cpp
├── VMAddressTable.hpp
├── VMHandle.cpp
├── VMHandle.h
├── VirtualMachine.cpp
├── WProtect.vcproj
├── algorithms.hpp
├── analysis.hpp
├── clean.bat
├── combosvmcode.hpp
├── movzx_test.exe
├── movzx_test.wp.exe
├── seniorvmhandle.hpp
├── virtualmachine.h
├── vmcodebuffer.hpp
└── voperand.hpp

```

`1_main.cpp`:

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#pragma warning(disable:4311)
#include "AsmJit/AsmJit.h"
#define _STDINT_H
#include "Libudis86/udis86.h"
#include "PE/PEFile.h"
//
#include "algorithms.hpp"
#include "Analysis.hpp"
#include "VirtualMachine.h"
#include "VMHandle.h"
#include "CombosVMCode.hpp"
#include "PCode.hpp"
#include "SeniorVMHandle.hpp"
#include "BuildCode.hpp"
#include "VMAddressTable.hpp"
#include "BuildVMByteCode.hpp"

void add_jmp_addr(CPEFile pe,long base,long jmp_address)
{
    char * c = (char*)pe.VaToPtr(base);
    *(char*)c = (char)0xe9;
    *(long*)(c + 1) = jmp_address - base - 5;
}

void get_wprotect_sdk_address(CPESection & section,
                              BuildExeInfo & build_info,
                              char *sz_sdk_begin_name,
                              char *sz_sdk_end_name)
{
    int sdk_begin_count       = 0;
    int sdk_end_count         = 0;
    int protect_begin_address = 0;
    int protect_end_address   = 0;
    int section_count         = section.GetSectionCount();
    int sdk_begin_str_size    = (int)strlen(sz_sdk_begin_name) + 1;
    int sdk_end_str_size      = (int)strlen(sz_sdk_end_name)   + 1;

    for (int i = 0; i < section_count; i++)  // 每个区段
    {
        DWORD section_size;
        BYTE * p = section.GetSectionData(i, &section_size);

        for (DWORD offset = 0; offset+1 < section_size; offset++)
        {
            if ( !(section.GetCharacteristics(i) & 0x20000000) )  // IMAGE_SCN_MEM_EXECUTE
                continue;

            if (p[offset] == 0xeb)
            {
                if (p[offset+1] == sdk_begin_str_size &&
                    offset+2 + sdk_begin_str_size < section_size)
                {
                    if (!strcmp(sz_sdk_begin_name, (char*)p+offset+2))
                    {
                        sdk_begin_count++;
                        if (sdk_begin_count - sdk_end_count == 1)
                        {
                            memset(p+offset, 0x90, 2+sdk_begin_str_size);
                            protect_begin_address = (ULONG)(p+offset);
                        }
                        else
                        {
                            printf("sdk_begin_count Error!\n");
                        }
                    }
                }
                else if (p[offset+1] == sdk_end_str_size &&
                    offset+2 + sdk_end_str_size < section_size)
                {
                    if (!strcmp(sz_sdk_end_name, (char*)p+offset+2))
                    {
                        sdk_end_count++;
                        if (sdk_begin_count == sdk_end_count)
                        {
                            protect_end_address = (ULONG)(p+offset);
                            memset(p+offset, 0x90, 2+sdk_end_str_size);

                            Code_Piece piece;
                            piece.CodeStartAddr =
                                section.GetSectionVa(i, protect_begin_address - (ULONG)p);

                            piece.CodeSize = protect_end_address - protect_begin_address;
                            build_info.push_back(piece);

                            printf("保护地址%x - %x\n",
                                piece.CodeStartAddr,
                                piece.CodeStartAddr+piece.CodeSize);
                        }
                        else
                        {
                            printf("sdk_end_count Error!\n");
                        }
                    }
                }
            }
        }
    }
    if (sdk_begin_count != sdk_end_count)
    {
        printf("need last sdk_end_count!\n");
        exit(-1);
    }
}

void buildvm_test(BuildExeInfo & build_info)
{
    srand( (unsigned int)time( NULL ) );

    char * build_exec_name = build_info.get_filename();
    printf("待处理文件：%s\n", build_exec_name);

    CPEFile file;
    if (!file.LoadPEFile(build_exec_name))
    {
        printf("file is not find!\n");
        return;
    }

    CPEReloc reloc;
    reloc = file;
    reloc.DeleteReloc();

    CPESection section;
    section = file;
    get_wprotect_sdk_address(section,build_info,"WProtect Begin","WProtect End");
    printf("\n");

    ULONG NewSectionBase = section.GetNewSectionBase();
    printf("NewSectionBase : %x\n", NewSectionBase);

    VMAddressTable table( NewSectionBase, 1024, false );
    bool t_sign = table.get_sign();
    table.set_sign(true);
    long vm_address = table.assign_address(4096);
    table.set_sign(t_sign);

    VirtualMachine *pvm = new VirtualMachine(vm_address, false);
    //
    printf("vm_address : %x\n", vm_address);

    table.copy(vm_address, pvm->vm_info.buf, pvm->vm_info.size);

    CodeBufferInfo Code;
    for (BuildExeInfo::iterator iter = build_info.begin();
        iter != build_info.end();
        iter++)
    {
        long CodeStartAddr = iter->CodeStartAddr;

        Code.buf  = file.VaToPtr(CodeStartAddr);
        Code.addr = CodeStartAddr;
        Code.size = iter->CodeSize;
        if (Code.size < 5)
        {
            printf("编译内容不能小于5Byte,容不下一个跳转\n");
            return;
        }

        Analysis analysis;
        std::vector<long> addr_table;
        //
        analysis.analysis_address_table(&Code,
            addr_table,
            section.GetSectionMinAddress(),
            section.GetSectionMaxAddress());

        BuildVMByteCode build(pvm, &Code, &table);
        memset(Code.buf, 0, Code.size);                // 旧代码置零
        add_jmp_addr(file, CodeStartAddr, Code.addr);  // 旧代码处修改为jmp Code.addr
    }

    unsigned long section_size = (unsigned long)(table.buffer_size);
    section.AddSection(".WPro", section_size, 0xE0000020);
    section.WriteSectionData(file.GetSectionCount()-1,
        0,
        (unsigned char*)table.buffer,
        (unsigned long )table.buffer_size);

    char new_file_name[256];
    memcpy(new_file_name, build_exec_name, strlen(build_exec_name)-3); 
    strcat_s(new_file_name,256,"wp.exe");
    printf("Out File:%s\n", new_file_name);
    file.SavePEFile(new_file_name);
}

int main()
{
    BuildExeInfo build_pe("movzx_test.exe");
    buildvm_test(build_pe);
    getchar();
    return 0;
}
```

`AddressTable.hpp`:

```hpp
/*
 *   Copyright (C) Tue Jun 25 12:44:21 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _ADDRESSTABLE_H_
#define _ADDRESSTABLE_H_

#include <vector>
#include <list>
#include <windows.h>

using namespace std;

template <class T>
class AddressTable
{
public:
  typedef struct _space_
  {
    ULONG_PTR begin;
    ULONG_PTR end;
    T data;
    _space_():begin(0),end(0) { memset(&data,0,sizeof(data)); }
    ~_space_(){}
  }space;

  struct space_sort_cmp 
  { 
    bool operator () (const typename AddressTable<T>::space &a, const typename AddressTable<T>::space &b) 
    { 
      return a.begin < b.begin;
    }
  };

  AddressTable(long _base,unsigned long _size,bool _sign)
    :base(_base),size(_size),alignment(_size),sign(_sign)
  {
  }
  
  virtual ~AddressTable()
  {
  }
  
  ULONG_PTR base;
  unsigned long size;
  unsigned long alignment;
  bool sign;              //正增长还是负增长
  list <space> addr_used;  //已经使用的空间

  ULONG_PTR assign_address(unsigned long _size);
  ULONG_PTR assign_address(unsigned long _size,const T &_data);
  ULONG_PTR assign_address(unsigned long _size,const T &_data,bool _sign);

  void set_sign(bool _sign) { sign = _sign; }
  bool get_sign() { return sign; }

  void addr_used_sort()
  {
      addr_used.sort(AddressTable<T>::space_sort_cmp());
  } 
};

typedef struct _useful_space
{
  ULONG_PTR begin;
  ULONG_PTR end;
}useful_space;


template <class T>
ULONG_PTR AddressTable<T>::assign_address(unsigned long _size,const T  & _data,bool _sign)
{
    addr_used_sort();
    sign = _sign;
    vector <useful_space> useful_vec;
    useful_space t;
    t.begin = base;
    for (typename list<AddressTable<T>::space>::iterator iter = addr_used.begin(); iter != addr_used.end(); ++iter)
    {
      t.end = 0;
      if (t.begin != iter->begin)
      {
        t.end = iter->begin;
        useful_vec.push_back(t);
      }
      t.begin = iter->end;
    }
    t.end = base + size;
    if (t.begin != t.end)
      useful_vec.push_back(t);    //筛选出没有使用的空间
    long count = 0;  //符合要求的有多少个
    for (vector<useful_space>::iterator iter = useful_vec.begin(); iter != useful_vec.end(); ++iter)
    {
      //if (iter->begin - iter->end >= _size)
      if (iter->end - iter->begin >= _size)
      {
        //printf("空闲地址开始:%x\r\n",iter->begin);
        //printf("空闲地址结束:%x\r\n",iter->end);
        //printf("符合要求的空间:%x-%x,大小为:%d\r\n",iter->begin,iter->end,iter->end-iter->begin); 
        count++;
      }
    }
    if (!count)
    {
      size += alignment;
      //return assign_address(_size);
      return assign_address(_size,_data,_sign);
    }
    long r = rand()%count; //如果有多个就随机抽取一个
    count = 0;
    
    for (vector<useful_space>::iterator iter = useful_vec.begin(); iter != useful_vec.end(); ++iter)
    {                                  
      if (iter->end - iter->begin >= _size)
      {
        if (count == r)
        {
          space p;
          ////注释掉这句就只会在某些概率下随机了
          //不能和0取模
          int space_rand = 0;
          if (iter->end - iter->begin - _size)
          {
             space_rand = rand() % (iter->end - iter->begin - _size); 
          }
          p.begin = space_rand + iter->begin;        
          ////
          //p.begin = iter->begin;
          //p.end = iter->begin + _size;//iter->end;
          p.end = p.begin + _size;
          p.data = _data;
          addr_used.push_back(p);
          if (sign)
            return p.begin;// iter->begin;
          else 
            return p.end;
        }
        count++;
      }
    }  
}


template <class T>
ULONG_PTR AddressTable<T>::assign_address(unsigned long _size,const T  & _data)
{
    addr_used_sort();
    vector <useful_space> useful_vec;
    useful_space t;
    t.begin = base;
    for (typename list<AddressTable<T>::space>::iterator iter = addr_used.begin(); iter != addr_used.end(); ++iter)
    {
      t.end = 0;
      if (t.begin != iter->begin)
      {
        t.end = iter->begin;
        useful_vec.push_back(t);
      }
      t.begin = iter->end;
    }
    t.end = base + size;
    if (t.begin != t.end)
      useful_vec.push_back(t);    //筛选出没有使用的空间
    long count = 0;  //符合要求的有多少个
    for (vector<useful_space>::iterator iter = useful_vec.begin(); iter != useful_vec.end(); ++iter)
    {
      //if (iter->begin - iter->end >= _size)
      if (iter->end - iter->begin >= _size)
      {
        //printf("符合要求的空间:%x-%x,大小为:%d\r\n",iter->begin,iter->end,iter->end-iter->begin);  
        //printf("空闲地址开始:%x\r\n",iter->begin);
        //printf("空闲地址结束:%x\r\n",iter->end);
        count++;
      }
    }
    if (!count)
    {
      size += alignment;
      //return assign_address(_size);
      return assign_address(_size,_data);
    }
    long r = rand()%count; //如果有多个就随机抽取一个
    count = 0;
    
    for (vector<useful_space>::iterator iter = useful_vec.begin(); iter != useful_vec.end(); ++iter)
    {
      if (iter->end - iter->begin >= _size)
      {
        if (count == r)
        {
          space p;
          ////注释掉这句就只会在某些概率下随机了
          //不能和0取模
          unsigned long space_rand = 0;
          if (iter->end - iter->begin - _size)
          {
             space_rand = rand() % (unsigned long)(iter->end - iter->begin - _size); 
          }
          p.begin = space_rand + iter->begin;
          ////
          //p.begin = iter->begin;
          //p.end = iter->begin + _size;//iter->end;
          p.end = p.begin + _size;
          p.data = _data;
          addr_used.push_back(p);
          if (get_sign())
            return p.begin;
          else
            return p.end;
        }
        count++;
      }
    }
    return 0;
}

template <class T>
ULONG_PTR AddressTable<T>::assign_address(unsigned long _size)
{
    addr_used_sort();

    vector <useful_space> useful_vec;
    useful_space t;
    t.begin = base;

    for (typename list<AddressTable<T>::space>::iterator iter = addr_used.begin();
        iter != addr_used.end();
        ++iter)
    {
        t.end = 0;
        if (t.begin != iter->begin)
        {
            t.end = iter->begin;
            useful_vec.push_back(t);
        }
        t.begin = iter->end;
    }

    t.end = base + size;
    if (t.begin != t.end)
        useful_vec.push_back(t);    //筛选出没有使用的空间

    long count = 0;  //符合要求的有多少个
    for (vector<useful_space>::iterator iter = useful_vec.begin();
        iter != useful_vec.end();
        ++iter)
    {
        if (iter->end - iter->begin >= _size)
        {
            printf("符合要求的空间:%x-%x,大小为:%d\n",iter->begin,iter->end,iter->end-iter->begin);
            count++;
        }
    }

    if (!count)
    {
        size += alignment;
        return assign_address(_size);
    }

    long r = rand()%count; //如果有多个就随机抽取一个
    count = 0;

    for (vector<useful_space>::iterator iter = useful_vec.begin();
        iter != useful_vec.end();
        ++iter)
    {
        if (iter->end - iter->begin >= _size)
        {
            if (count == r)
            {
                space p;
                ////注释掉这句就只会在某些概率下随机了
                //不能和0取模
                int space_rand = 0;
                if (iter->end - iter->begin - _size)
                {
                    space_rand = rand() % (int)(iter->end - iter->begin - _size); 
                }

                p.begin = space_rand + iter->begin;         
                p.end = p.begin + _size;
                //memset(&(p.data),0,sizeof(p.data));//清空数据

                //printf("%s\naddress:%x","正增长" ,&p);

                addr_used.push_back(p);
                if (get_sign())
                    return p.begin;
                else
                    return p.end;
            }
            count++;
        }
    }
    return 0;
}

#endif /* _ADDRESSTABLE_H_ */

```

`Analysis.cpp`:

```cpp

#include "Analysis.hpp"
#pragma warning(disable:4244)

Analysis::Analysis()
  :L(false),R(true),block_count(0),base(0),size(0)
{
  root = NULL;
}

Analysis::~Analysis()
{
  clean_tree();
}

pAssemblerTree Analysis::add_tree(pAssemblerTree parent,pAssemblerTree child,bool l_r) //left and right
{
  if (child == root)
  {
    return root;
  }
  if (l_r == L)
  {
    parent->LeftChild = child;
  }
  else
  {
    parent->RightChild = child;
  }
  return child;
}


void show_tree(pAssemblerTree root,char note[256])
{
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    for (std::vector <ud_t>::iterator iter = nowtree->asmpiece.begin(); iter != nowtree->asmpiece.end(); ++iter)
    {
      ud_t ud = *iter;
      printf("%s:%x:",note,ud.insn_offset); 
      printf("%s \r\n",ud.insn_buffer);
      
    }
      printf("Left %p\n",  nowtree->LeftChild);
      printf("Right %p\n", nowtree->RightChild);
      //int n;
      //1scanf("%d",&n);    
      // printf("\r\n");
    /*
    if (nowtree->RightChild)
    {
      show_tree(nowtree->RightChild,"true:");
    }
    */
    nowtree = nowtree->LeftChild;
  }    
}

void show_tree(pAssemblerTree root)
{
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    printf ("base:%x,size:%x\r\n",nowtree->base,nowtree->size);
    
    for (std::vector <ud_t>::iterator iter = nowtree->asmpiece.begin(); iter != nowtree->asmpiece.end(); ++iter)
    {
      ud_t ud = *iter;
      printf("%x:",ud.insn_offset); 
      printf("%s \r\n",ud.insn_buffer);
    }
    printf("\r\n");
    nowtree = nowtree->LeftChild;
  }    
}

void Analysis::clean_tree()
{
  if (root)
  {
    pAssemblerTree nowtree = root;
    pAssemblerTree oldtree = NULL;
    while (nowtree)
    {
      oldtree = nowtree;
      nowtree = nowtree->LeftChild;
      delete oldtree;
    }
  }
}

pAssemblerTree Analysis::get_tree(long id)
{
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    if (nowtree->id == id)
    {
      return nowtree;
    }
    //nowtree = nowtree->RightChild;
    nowtree = nowtree->LeftChild;
  }
  return NULL;
}

pAssemblerTree Analysis::find_tree(long addr)
{
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    if (nowtree->base == addr)
    {
      return nowtree;
    }
    nowtree = nowtree->LeftChild;
  }
  return NULL;
}

size_t Analysis::reloc_asm_address(long old_address,long new_address) //返汇编块的地址
{
  size_t size;
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    if (nowtree->base == old_address)
    {
      nowtree->reloc_address = new_address;
      size++;
    }
    if (nowtree->jcc_addr == old_address)
    {
      nowtree->jcc_addr = new_address;
      size++;
    }
    if (nowtree->next_instruction == old_address)
    {
      nowtree->next_instruction = new_address;
      size++;
    }
    
    nowtree = nowtree->LeftChild;
  }
  return size;
}

void Analysis::reloc_asm_address()
{
  pAssemblerTree nowtree = root;
  
  while (nowtree)
  {
    if (-1 != nowtree->reloc_address)
    {
      pAssemblerTree nowtree2 = root;
      while (nowtree2)
      {
        if (nowtree2->jcc_addr == nowtree->base)
        {
          nowtree2->jcc_addr = nowtree->reloc_address;
        }
        if (nowtree2->next_instruction == nowtree->base)
        {
          nowtree2->next_instruction = nowtree->reloc_address;
        }
        nowtree2 = nowtree2->LeftChild;
      }
    }
    
    nowtree = nowtree->LeftChild;
  }  
}

void Analysis::link_tree()
{
  pAssemblerTree nowtree = root;
  while (nowtree)
  {
    ud_t ud = nowtree->asmpiece.back();
    if (ud.operand[0].type == UD_OP_JIMM && ud.mnemonic != UD_Icall)
    {
      long addr = ud.operand[0].size == 8 ?
          ((signed char)ud.operand[0].lval.sbyte + ud.pc) :
          (ud.operand[0].lval.sdword + ud.pc);

      pAssemblerTree tree_R= find_tree(addr);
      if (tree_R)
      {
         nowtree->RightChild = tree_R;
         nowtree->jcc_addr = addr;
      }
    }  
    nowtree = nowtree->LeftChild;
  }
}

void Analysis::set_eflag(  )
{
  /*
  pAssemblerTree nowtree = root;
  while ( nowtree )
  {
     switch ( ud_obj.mnemonic )
     {
     case UD_Itest:
       break;
     case UD_Icmp:
       break;
     case UD_Iand:
       break;
     case UD_Ior:
       break;
     case UD_Ixor:
       break;
       case UD_I
     }
     nowtree = nowtree->LeftChild;
  }
  */
}

bool Analysis::check_address(long addr)
{
  if (addr <= base + size && addr >= base)
  {
    return true;
  }
  else
    return false;
}
   

void Analysis::set_label_address(pCodeBufferInfo pinfo,
                                 AddressArray & _addra,
                                 std::map<long,int> & _map)
{
  ud_t ud_obj;
  ud_init(&ud_obj);

#ifndef PROTECT_X64
  ud_set_mode(&ud_obj,32);
#else
  ud_set_mode(&ud_obj,64);
#endif
  ud_set_pc(&ud_obj,pinfo->addr);
  ud_set_input_buffer(&ud_obj, (uint8_t*)pinfo->buf, pinfo->size);
  ud_set_syntax(&ud_obj,UD_SYN_INTEL);
  std::vector <ud_t> ud_obj_array;
  
  int label = 0;
  while (ud_disassemble(&ud_obj) != 0)
  {
     if (ud_obj.insn_offset > _addra[label])
     {
       printf("当前地址不可能比分支地址大\n");
     }
     if (ud_obj.insn_offset == _addra[label])
     {
       _map.insert(std::make_pair<long,int>(ud_obj.insn_offset,label));
       //printf("地址:%08x,标签:%d\n",ud_obj.insn_offset,label);
       label++;
     }
  }
}

void Analysis::disasm(pCodeBufferInfo pinfo,std::vector<CodePiece> & code)
{
    ud_t ud_obj;
    ud_init(&ud_obj);

#ifndef PROTECT_X64
    ud_set_mode(&ud_obj,32);
#else
    ud_set_mode(&ud_obj,64);
#endif

    ud_set_pc(&ud_obj,pinfo->addr);
    ud_set_input_buffer(&ud_obj, (uint8_t*)pinfo->buf, pinfo->size);
    ud_set_syntax(&ud_obj,UD_SYN_INTEL);

    base = pinfo->addr;
    size = pinfo->size;
    AddressArray a_array = analysis_code_piece_address(pinfo);

    unsigned int point = 0;
    const bool begin = true;
    const bool end = false;
    bool status = end;
    std::map<long,int> addr_id;

    set_label_address(pinfo,a_array,addr_id);
    CodePiece *piece = NULL;
    while (ud_disassemble(&ud_obj) != 0)
    {
        printf("%s\n",ud_insn_asm(&ud_obj));

        if (ud_obj.insn_offset == a_array[point] && status == end)
        {
            piece = new CodePiece;
            piece->set_label(point);
            point++;
            status = begin;
        }

        if (a_array.get_size() > point)
        {
            if (ud_obj.pc == a_array[point])
            {
                if (addr_id.find(ud_obj.pc) == addr_id.end()) //下条指令没有找到
                {
#ifdef _DEBUG
                    printf("没有查找到数据,地址%08x\n",ud_obj.pc);
#endif
                    if (ud_obj.mnemonic == UD_Iret)
                    {
                        //piece->set_jmplabel(PC_NONE);
                        piece->set_opcode_attribute(OPCODE_ATTRIBUTE_RET);
                    }
                    else if (ud_insn_mnemonic(&ud_obj) == UD_Ijmp)
                    {
                        long addr = ud_obj.operand[0].size == 8
                                            ? ((signed char)ud_obj.operand[0].lval.sbyte + ud_obj.pc) :
                                    (ud_obj.operand[0].lval.sdword + ud_obj.pc);
                        if (addr >= pinfo->addr && addr <= pinfo->addr + pinfo->size
                                && ud_obj.operand[0].type == UD_OP_JIMM)
                        {
                            piece->set_opcode_attribute(OPCODE_ATTRIBUTE_JMP);
                            piece->set_jmplabel(addr_id[addr]);
                        }
                        else
                        {
                           piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_JMP);
                           if (ud_obj.operand[0].type == UD_OP_JIMM)
                               piece->set_jmplabel(addr);
                           else
                               piece->set_jmplabel(PC_NONE);

                        }
                    }
                    else if (ud_insn_mnemonic(&ud_obj) == UD_Icall)
                    {
                        long addr = ud_obj.operand[0].size == 8 ?
                            ((signed char)ud_obj.operand[0].lval.sbyte  + ud_obj.pc) :
                                         (ud_obj.operand[0].lval.sdword + ud_obj.pc);

                        if (addr >= pinfo->addr && addr < pinfo->addr + pinfo->size &&
                                ud_obj.operand[0].type == UD_OP_JIMM)
                        {
                            piece->set_opcode_attribute(OPCODE_ATTRIBUTE_CALL);
                            piece->set_jmplabel(addr_id[addr]);
                        }
                        else
                        {
                           piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_CALL);
                           if (ud_obj.operand[0].type == UD_OP_JIMM)
                               piece->set_jmplabel(addr);
                           else
                               piece->set_jmplabel(PC_NONE);
                        }
                    }
                    else
                    {
                        piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXIT);
                        piece->set_jmplabel(ud_obj.pc);
                    }
                }
                else
                {
                    if (ud_obj.operand[0].type == UD_OP_JIMM
                            || ud_obj.mnemonic == UD_Icall
                            || ud_obj.mnemonic == UD_Ijmp)//&& ud_obj.mnemonic != UD_Icall)
                    {
                        piece->set_is_jcc(ud_obj.mnemonic != UD_Icall &&
                                        ud_obj.mnemonic != UD_Iret &&
                                        ud_obj.mnemonic != UD_Ijmp);
                        if (ud_obj.operand[0].type == UD_OP_MEM ||
                            ud_obj.operand[0].type == UD_OP_REG)
                        {
                            if (ud_insn_mnemonic(&ud_obj) == UD_Ijmp)
                            {
                                piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_JMP);
                            }
                            else if (ud_insn_mnemonic(&ud_obj) == UD_Icall)
                            {
                                piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_CALL);
                            }
                            else
                            {
                               //piece->set_opcode_attribute(OPCODE_ATTRIBUTE_JCC);
                            }
                            piece->set_jmplabel(PC_NONE);
                        }
                        else
                        {
                            long addr = ud_obj.operand[0].size == 8 ?
                                ((signed char)ud_obj.operand[0].lval.sbyte + ud_obj.pc) :
                                (ud_obj.operand[0].lval.sdword + ud_obj.pc);

                            //<=pinfo->addr + pinfo->size将导致跳转到最后一条指令的下一条还是在范围之内
                            if (addr >= pinfo->addr && addr < pinfo->addr + pinfo->size)
                            {
                                if (addr_id.find(addr) == addr_id.end())
                                {
                                    printf("没有找到跳转地址:%08x\n",addr );
                                }
                                if (ud_insn_mnemonic(&ud_obj) == UD_Ijmp)
                                {
                                   piece->set_opcode_attribute(OPCODE_ATTRIBUTE_JMP);
                                   piece->set_jmplabel(addr_id[addr]);
                                }
                                else if (ud_insn_mnemonic(&ud_obj) == UD_Icall)
                                {
                                   piece->set_opcode_attribute(OPCODE_ATTRIBUTE_CALL);
                                   piece->set_jmplabel(addr);
                                }
                                else
                                {
                                   piece->set_opcode_attribute(OPCODE_ATTRIBUTE_JCC);
                                   piece->set_jmplabel( addr_id[addr] );
                                }
                            }
                            else
                            {
                                if (ud_insn_mnemonic(&ud_obj) == UD_Ijmp)
                                {
                                   piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_JMP);
                                   //piece->set_jmplabel(addr_id[addr]);
                                }
                                else if (ud_insn_mnemonic(&ud_obj) == UD_Icall)
                                {
                                   piece->set_opcode_attribute(OPCODE_ATTRIBUTE_EXTERNAL_CALL);
                                   //piece->set_jmplabel(addr);
                                }
                                else
                                {
                                   //piece->set_opcode_attribute(OPCODE_ATTRIBUTE_JCC);
                                   printf("jcc不能跳转到虚拟机外部\n");
                                   //piece->set_jmplabel( addr_id[addr] );
                                }
                                piece->set_jmplabel(addr);
                            }
                        }
                    }
                    else
                    {
                        piece->set_jmplabel( addr_id[ud_obj.pc] );
                        piece->set_opcode_attribute(OPCODE_ATTRIBUTE_NORMAL);
                    }
                }
                if (ud_obj.mnemonic == UD_Iret)
                {
                    piece->set_jmplabel(PC_NONE);
                    piece->set_opcode_attribute(OPCODE_ATTRIBUTE_RET);
                    //piece->set_jmplabel(PC_RET);
                }
                piece->add_assemble(ud_obj);
                code.push_back(*piece);
                delete piece;
                piece = NULL;
                status = end;
            }
        }
        if (status == begin)
        {
            if (piece == NULL)
                printf("没有为piece分配空间");

            piece->add_assemble(ud_obj);
        }
    }
}

void Analysis::analysis_address_table(pCodeBufferInfo pinfo,
                                      std::vector<long> & addr_entry_table,
                                      long addr_min,
                                      long addr_max) //jmp [addr_table + reg] 查找addr_table里面的值
{
    ud_t ud_obj;
    ud_init(&ud_obj);

#ifndef PROTECT_X64
    ud_set_mode(&ud_obj,32);
#else
    ud_set_mode(&ud_obj,64);
#endif
    ud_set_pc(&ud_obj,pinfo->addr);
    ud_set_input_buffer(&ud_obj, (uint8_t*)pinfo->buf, pinfo->size);
    ud_set_syntax(&ud_obj,UD_SYN_INTEL);
    while(ud_disassemble(&ud_obj) != 0)
    {
        if (ud_obj.operand[0].type == UD_OP_MEM)
        {
            if (ud_obj.operand[0].offset == 32)
            {
                long addr = ud_obj.operand[0].lval.sdword;
                if (addr <= addr_max && addr >= addr_min)
                  addr_entry_table.push_back(addr);
            }
        }
        if (ud_obj.operand[1].type == UD_OP_MEM)
        {
            if (ud_obj.operand[1].offset == 32)
            {
                long addr = ud_obj.operand[1].lval.sdword;
                if (addr <= addr_max && addr >= addr_min)
                   addr_entry_table.push_back(addr);
            }
        }
    }
}

void Analysis::printf_piece(std::vector<CodePiece> & var_piece)
{
#ifdef _DEBUG
   for (std::vector<CodePiece>::iterator iter = var_piece.begin();
      iter != var_piece.end();iter++)
  {
    char * opcode_attribute = NULL;
    switch (iter->get_opcode_attribute())
    {
    case OPCODE_ATTRIBUTE_CALL:
        opcode_attribute = "OPCODE_ATTRIBUTE_CALL";
        break;
    case OPCODE_ATTRIBUTE_EXIT:
        opcode_attribute = "OPCODE_ATTRIBUTE_EXIT";
        break;
    case OPCODE_ATTRIBUTE_JCC:
        opcode_attribute = "OPCODE_ATTRIBBUTE_JCC";
        break;
    case OPCODE_ATTRIBUTE_NORMAL:
        opcode_attribute = "OPCODE_ATTRIBUTE_NORMAL";
        break;
    case OPCODE_ATTRIBUTE_RET:
        opcode_attribute = "OPCODE_ATTRIBUTE_RET";
        break;
    case OPCODE_ATTRIBUTE_JMP:
        opcode_attribute = "OPCODE_ATTRIBUTE_JMP";
        break;
    case OPCODE_ATTRIBUTE_EXTERNAL_JMP:
        opcode_attribute = "OPCODE_ATTRIBUTE_EXTERNAL_JMP";
        break;
    case OPCODE_ATTRIBUTE_EXTERNAL_JCC:
        opcode_attribute = "OPCODE_ATTRIBUTE_EXTERNAL_JCC";
        break;
    case OPCODE_ATTRIBUTE_EXTERNAL_CALL:
        opcode_attribute = "OPCODE_ATTRIBUTE_EXTERNAL_CALL";
        break;
    default:
        opcode_attribute = "NO_ATTRIBUTE";
        break;
    }
    printf("标签:%08x, 跳转到:%08x, 条件跳转:%d, 代码块属性:%s\n",
           iter->get_label(),
           iter->get_jmplabel(),
           iter->get_is_jcc(),
           opcode_attribute);
    for (std::list<ud_t>::iterator xiter = iter->get_piece().begin();
        xiter != iter->get_piece().end();xiter++)
    {
        printf("%s\n",xiter->insn_buffer);
    }
  }
#endif
}           

pAssemblerTree Analysis::disasm(pCodeBufferInfo pinfo)
{
  std::vector<CodePiece> piece_test;
  disasm(pinfo, piece_test);
  for (std::vector<CodePiece>::iterator iter = piece_test.begin();
      iter != piece_test.end();
      iter++)
  {
    printf("标签:%08x, 跳转到:%08x, 条件跳转:%d\n",
        iter->get_label(),
        iter->get_jmplabel(),
        iter->get_is_jcc());   
    for (std::list<ud_t>::iterator xiter = iter->get_piece().begin();
        xiter != iter->get_piece().end();xiter++)
    {
        printf("%s\n",xiter->insn_buffer);
    }
  }

  ud_t ud_obj;
  ud_init(&ud_obj);

#ifndef PROTECT_X64
  ud_set_mode(&ud_obj,32);
#else
  ud_set_mode(&ud_obj,64);
#endif
  ud_set_pc(&ud_obj,pinfo->addr);
  ud_set_input_buffer(&ud_obj, (uint8_t*)pinfo->buf, pinfo->size);
  ud_set_syntax(&ud_obj,UD_SYN_INTEL);

  base = pinfo->addr;
  size = pinfo->size;
  
  std::vector <long> address_array;
  //pAssemblerTree root =  new AssemblerTree;
  //  pAssemblerTree nowtree = root;
  std::vector <ud_t> ud_obj_array;
  address_array.push_back(pinfo->addr);
  address_array.push_back(pinfo->addr + pinfo->size);
  while (ud_disassemble(&ud_obj) != 0)
  {
    ud_obj_array.push_back(ud_obj);
    //    nowtree.asmpiect.push_back(ud_obj);
    if (ud_obj.operand[0].type == UD_OP_JIMM || ud_obj.mnemonic == UD_Icall )//&& ud_obj.mnemonic != UD_Icall)
    {
          long addr = ud_obj.operand[0].size == 8
            ? ((signed char)ud_obj.operand[0].lval.sbyte + ud_obj.pc) :
            (ud_obj.operand[0].lval.sdword + ud_obj.pc);
      if (addr >= pinfo->addr && addr <= pinfo->addr + pinfo->size)
      {
         address_array.push_back(addr);
         address_array.push_back(ud_obj.pc);        
      }
    }
  }

  long count = 0;
  long *a_array;
  size_t address_size = address_array.size();
  a_array = new long[address_size];

  // 排重
  for (std::vector <long>::iterator iter = address_array.begin();
       iter != address_array.end();
       ++iter)
  {
    bool fk = true;
    for (int i = 0; i < count; ++i)
    {
      if (*iter == a_array[i])
      {
        fk = false;
      }
    }
    if (fk)
      a_array[count++] = *iter;
  }

  // 从小到大排序
  for (int i = 0; i < count; ++i)
  {
    for (int j = i; j < count ; ++j)
    {
      if (a_array[i] > a_array[j])
      {
        long t = a_array[i];
        a_array[i] = a_array[j];
        a_array[j] = t;
      }
    }
  }

  for (int i = 0; i < count; ++i)
  {
    printf("%08x\n",a_array[i]);
  }
  int point = 0;
  pAssemblerTree nowtree = NULL;
  pAssemblerTree parent = NULL;
      const bool begin = true;
    const bool end = false;
    bool status = end;
  for (std::vector <ud_t>::iterator iter = ud_obj_array.begin();
       iter != ud_obj_array.end();
       ++iter)
  {
    //typedef  true begin;
    //typedef false end;
    // ud_t *p = iter;
    ud_t ud = *iter;
    if (ud.insn_offset == a_array[point] && status == end)
    {
      point++;
      status = begin;
      nowtree = new AssemblerTree;
      root ? NULL : root = nowtree;
      nowtree->LeftChild = NULL;
      nowtree->RightChild = NULL;

      nowtree->id = point - 1;


      //      nowtree.asmpiect.push_back(ud);
    }
    if (nowtree)
    {
      nowtree->asmpiece.push_back(ud);
    }
    if (ud.pc == a_array[point] && status == begin)
    {
      nowtree->base = a_array[point-1];
      
      //point++;
      nowtree->size = ud.pc - a_array[point-1]; //代码块大小
      status = end;
      parent = add_tree(parent,nowtree,L);
      
      //nowtree = new AssemblerTree;
      //nowtree->LeftChild = NULL;
      //nowtree->RightChild = NULL;
    }
    nowtree->reloc_address = -1;    
    nowtree->next_instruction = ud.pc;   
  }
  block_count = point;
  link_tree();
#ifdef _DEBUG
  show_tree(root,"false:");
#endif
  delete [] a_array;
  
  /*for (std::vector <long>::iterator iter = address_array.begin() ;
       iter != address_array.end() ; ++iter)
  {
    int addr = *iter;
    printf("%08x\r\n",addr);
    }*/
  return NULL;
}


// 分析代码块地址
AddressArray Analysis::analysis_code_piece_address(pCodeBufferInfo pinfo)
{
    ud_t ud_obj;
    ud_init(&ud_obj);

#ifndef PROTECT_X64
    ud_set_mode(&ud_obj,32);
#else
    ud_set_mode(&ud_obj,64);
#endif

    ud_set_pc(&ud_obj,pinfo->addr);
    ud_set_input_buffer(&ud_obj, (uint8_t*)pinfo->buf, pinfo->size);
    ud_set_syntax(&ud_obj,UD_SYN_INTEL);

    base = pinfo->addr;
    size = pinfo->size;

    std::vector <long> address_array;

    address_array.push_back(pinfo->addr);
    address_array.push_back(pinfo->addr + pinfo->size);

    while (ud_disassemble(&ud_obj) != 0)
    {
        if (ud_obj.pfx_rep != 0 || ud_obj.pfx_repe != 0 || ud_obj.pfx_repne != 0)   //有前缀
        {
            address_array.push_back(ud_obj.pc);
            address_array.push_back(ud_obj.insn_offset);
        }

        if (ud_obj.operand[0].type == UD_OP_JIMM )
        {
            long addr = ud_obj.operand[0].size == 8  // Size of the operand in number of bits
                ? ((signed char)ud_obj.operand[0].lval.sbyte + ud_obj.pc) :
            (ud_obj.operand[0].lval.sdword + ud_obj.pc);

            if (addr >= pinfo->addr && addr <= pinfo->addr + pinfo->size)
            {
                address_array.push_back(addr);
                address_array.push_back(ud_obj.pc);
            }
            else
            {
                //表示跳转地址是一个jcc指令
                if (ud_obj.mnemonic != UD_Icall && ud_obj.mnemonic != UD_Ijmp)
                {
                    printf("%x:跳转的地址无法找到:%x\n", ud_obj.insn_offset, addr);
                    __asm int 3;
                }
                else
                {
                    address_array.push_back(ud_obj.pc);
                }
            }
        }

        if (ud_obj.mnemonic == UD_Iret || ud_obj.mnemonic == UD_Icall || ud_obj.mnemonic == UD_Ijmp)
        {
            address_array.push_back(ud_obj.pc);
        }
    }

    long count = 0;
    size_t address_size = address_array.size();
    AddressArray a_array((int)address_size);

    // 排除重复的地址
    for (std::vector <long>::iterator iter = address_array.begin();
        iter != address_array.end();
        ++iter)
    {
        bool fk = true;
        for (int i = 0; i < count; ++i)
        {
            if (*iter == a_array[i])
            {
                fk = false;
            }
        }
        if (fk)
            a_array[count++] = *iter;
    }

    for (int i = 0; i < count; ++i)  // 从小到大排序
    {
        for (int j = i; j < count ; ++j)
        {
            if (a_array[i] > a_array[j])
            {
                long t = a_array[i];
                a_array[i] = a_array[j];
                a_array[j] = t;
            }
        }
    }

    a_array.set_size(count); 

#ifdef _DEBUG
    for (int i = 0; i < count - 1; ++i)
    {
        printf("标签%x,分支地址:%08x - %08x\n",i,a_array[i],a_array[i+1]-1);
    }
#endif

    return a_array;
}

```

`AsmJit/ApiBegin.h`:

```h

#if defined(_MSC_VER)

#pragma warning(push)
#pragma warning(disable: 4127) // conditional expression is constant
#pragma warning(disable: 4251) // struct needs to have dll-interface to be used by clients of struct
#pragma warning(disable: 4275) // non dll-interface struct ... used as base for dll-interface struct
#pragma warning(disable: 4355) // this used in base member initializer list
#pragma warning(disable: 4800) // forcing value to bool 'true' or 'false'
#pragma warning(disable: 4311)

#define vsnprintf _vsnprintf
#define  snprintf  _snprintf

#endif // _MSC_VER

```

`AsmJit/ApiEnd.h`:

```h

#if defined(_MSC_VER)

#pragma warning(pop)

#undef vsnprintf
#undef snprintf

#endif // _MSC_VER

```

`AsmJit/AsmJit.h`:

```h

#ifndef _ASMJIT_H
#define _ASMJIT_H

//! @mainpage
//!
//! @brief AsmJit is complete x86/x64 JIT Assembler for C++ language
//! 
//! It supports FPU, MMX, 3dNow, SSE, SSE2, SSE3 and SSE4 intrinsics, powerful
//! compiler that helps to write portable functions for 32-bit (x86) and 64-bit
//! (x64) architectures. AsmJit can be used to create functions at runtime that
//! can be called from existing (but also generated) C/C++ code.
//!
//! AsmJit is crossplatform library that supports various compilers and
//! operating systems. Currently only limitation is x86 (32-bit) or x64 (64-bit)
//! processor. Currently tested operating systems are Windows (32-bit and 64-bit),
//! Linux (32-bit and 64-bit) and MacOSX (32-bit).
//!
//! @section AsmJit_Main_Introduction Introduction
//!
//! AsmJit library contains two main classes for code generation with different
//! goals. First main code generation class is called @c AsmJit::Assembler and 
//! contains low level API that can be used to generate JIT binary code. It 
//! directly emits binary stream that represents encoded x86/x64 assembler 
//! opcodes. Together with operands and labels it can be used to generate 
//! complete code. For details look to @ref AsmJit_Core and @ref AsmJit_Compiler
//! sections.
//!
//! There is also class named @c AsmJit::Compiler that allows to develop 
//! cross-platform assembler code without worring about function calling
//! conventions and registers allocation. It can be also used to write 32-bit
//! and 64-bit portable code. Compiler is recommended class to use for code
//! generation.
//!
//! Everything in AsmJit library is in @c AsmJit namespace.
//!
//! @section AsmJit_Main_CodeGeneration Code Generation
//!
//! - @ref AsmJit_Core "Assembler core" - Operands, intrinsics and low-level assembler.
//! - @ref AsmJit_Compiler "Compiler" - High level code generation.
//! - @ref AsmJit_CpuInfo "Cpu Information" - Get information about host processor.
//! - @ref AsmJit_Logging "Logging" - Logging and error handling.
//! - @ref AsmJit_MemoryManagement "Memory Management" - Virtual memory management.
//!
//! @section AsmJit_Main_Configuration Configuration, Definitions and Utilities
//!
//! - @ref AsmJit_Config "Configuration" - Macros used to configure AsmJit.
//! - @ref AsmJit_Util "Utilities" - Utilities and helper classes.
//!
//! @section AsmJit_Main_HomePage AsmJit Homepage
//!
//! - http://code.google.com/p/asmjit/
//!
//! @section AsmJit_Main_X86X64Resources External X86/X64 Assembler Resources
//! - http://www.agner.org/optimize/
//! - http://www.mark.masmcode.com/ (Assembler Tips)
//! - http://avisynth.org/mediawiki/Filter_SDK/Assembler_optimizing (Optimizing)
//! - http://www.ragestorm.net/distorm/ (Disassembling)
//!
//! @section AsmJit_Main_Terminology Terminology
//!
//! - <b>Non-volatile (preserved) register</b> - Register that can't be changed
//!   by callee (callee must save and restore it if it want to use it inside).
//!
//! - <b>Volatile (non-preserved) register</b> - The opossite. Register that can
//!   be freely used by callee. The caller must free all registers before calling
//!   other function.


//! @defgroup AsmJit_Core Assembler core (operands, intrinsics and low-level assembler).
//!
//! Contains classes related to @c AsmJit::Assembler that're directly used 
//! to generate machine code stream. It's one of oldest and fastest method 
//! to generate machine code using AsmJit library.
//!
//! - See @c AsmJit::Assembler class for low level code generation 
//!   documentation.
//! - See @c AsmJit::Operand for AsmJit operand's overview.
//!
//! @section AsmJit_Core_Registers Registers
//!
//! There are static objects that represents X86 and X64 registers. They can 
//! be used directly (like @c eax, @c mm, @c xmm, ...) or created through 
//! these functions:
//!
//! - @c AsmJit::mk_gpb() - make general purpose byte register
//! - @c AsmJit::mk_gpw() - make general purpose word register
//! - @c AsmJit::mk_gpd() - make general purpose dword register
//! - @c AsmJit::mk_gpq() - make general purpose qword register
//! - @c AsmJit::mk_mm() - make mmx register
//! - @c AsmJit::mk_xmm() - make sse register
//! - @c AsmJit::st() - make x87 register
//!
//! @section AsmJit_Core_Addressing Addressing
//!
//! X86 and x64 architectures contains several addressing modes and most ones
//! are possible with AsmJit library. Memory represents are represented by
//! @c AsmJit::Mem class. These functions are used to make operands that 
//! represents memory addresses:
//!
//! - @c AsmJit::ptr()
//! - @c AsmJit::byte_ptr()
//! - @c AsmJit::word_ptr()
//! - @c AsmJit::dword_ptr()
//! - @c AsmJit::qword_ptr()
//! - @c AsmJit::tword_ptr()
//! - @c AsmJit::dqword_ptr()
//! - @c AsmJit::mmword_ptr()
//! - @c AsmJit::xmmword_ptr()
//! - @c AsmJit::sysint_ptr()
//!
//! Most useful function to make pointer should be @c AsmJit::ptr(). It creates
//! pointer to the target with unspecified size. Unspecified size works in all
//! intrinsics where are used registers (this means that size is specified by
//! register operand or by instruction itself). For example @c AsmJit::ptr() 
//! can't be used with @c AsmJit::Assembler::inc() instruction. In this case
//! size must be specified and it's also reason to make difference between 
//! pointer sizes.
//!
//! Supported are simple address forms (register + displacement) and complex
//! address forms (register + (register << shift) + displacement).
//!
//! @section AsmJit_Core_Immediates Immediates
//!
//! Immediate values are constants thats passed directly after instruction 
//! opcode. To create such value use @c AsmJit::imm() or @c AsmJit::uimm()
//! methods to create signed or unsigned immediate value.
//!
//! @sa @c AsmJit::Compiler.


//! @defgroup AsmJit_Compiler Compiler (high-level code generation).
//!
//! Contains classes related to @c AsmJit::Compiler that can be used
//! to generate code using high-level constructs.
//!
//! - See @c AsmJit::Compiler class for high level code generation 
//!   documentation - calling conventions, function declaration
//!   and variables management.

//! @defgroup AsmJit_Config Configuration.
//!
//! Contains macros that can be redefined to fit into any project.


//! @defgroup AsmJit_CpuInfo CPU information.
//!
//! X86 or x64 cpuid instruction allows to get information about processor 
//! vendor and it's features. It's always used to detect features like MMX, 
//! SSE and other newer ones.
//!
//! AsmJit library supports low level cpuid call implemented internally as 
//! C++ function using inline assembler or intrinsics and also higher level 
//! CPU features detection. The low level function (also used by higher level 
//! one) is @c AsmJit::cpuid().
//!
//! AsmJit library also contains higher level function @c AsmJit::getCpuInfo()
//! that returns features detected by the library. The detection process is
//! done only once and it's cached for all next calls. @c AsmJit::CpuInfo 
//! structure not contains only information through @c AsmJit::cpuid(), but
//! there is also small multiplatform code to detect number of processors 
//! (or cores) through operating system API.
//!
//! It's recommended to use @c AsmJit::cpuInfo to detect and check for
//! host processor features.
//!
//! Example how to use AsmJit::cpuid():
//!
//! @code
//! // All functions and structures are in AsmJit namesapce.
//! using namespace AsmJit;
//!
//! // Here will be retrieved result of cpuid call.
//! CpuId out;
//!
//! // Use cpuid function to do the job.
//! cpuid(0 /* eax */, &out /* eax, ebx, ecx, edx */);
//!
//! // Id eax argument to cpuid is 0, ebx, ecx and edx registers 
//! // are filled with cpu vendor.
//! char vendor[13];
//! memcpy(i->vendor, &out.ebx, 4);
//! memcpy(i->vendor + 4, &out.edx, 4);
//! memcpy(i->vendor + 8, &out.ecx, 4);
//! vendor[12] = '\0';
//! 
//! // Print vendor
//! puts(vendor);
//! @endcode
//!
//! If you want to use AsmJit::cpuid() function instead of higher level 
//! @c AsmJit::getCpuInfo(), please read processor manuals provided by Intel,
//! AMD or other manufacturers for cpuid instruction details.
//!
//! Example of using @c AsmJit::getCpuInfo():
//!
//! @code
//! // All functions and structures are in AsmJit namesapce.
//! using namespace AsmJit;
//!
//! // Call to cpuInfo return CpuInfo structure that shouldn't be modified.
//! // Make it const by default.
//! const CpuInfo *i = getCpuInfo();
//!
//! // Now you are able to get specific features.
//!
//! // Processor has SSE2
//! if (i->features & CPU_FEATURE_SSE2)
//! {
//!   // your code...
//! }
//! // Processor has MMX
//! else if (i->features & CPU_FEATURE__MMX)
//! {
//!   // your code...
//! }
//! // Processor is old, no SSE2 or MMX support.
//! else
//! {
//!   // your code...
//! }
//! @endcode
//!
//! Better example is in AsmJit/Test/testcpu.cpp file.
//!
//! @sa AsmJit::cpuid, @c AsmJit::cpuInfo.


//! @defgroup AsmJit_Logging Logging and error handling.
//!
//! Contains classes related to loging assembler output. Currently logging
//! is implemented in @c AsmJit::Logger class.You can override
//! @c AsmJit::Logger::log() to log messages into your stream. There is also
//! @c FILE based logger implemented in @c AsmJit::FileLogger class.
//!
//! To log your assembler output to FILE stream use this code:
//!
//! @code
//! // Create assembler
//! Assembler a;
//!
//! // Create and set file based logger
//! FileLogger logger(stderr);
//! a.setLogger(&logger);
//! @endcode
//!
//! You can see that logging goes through @c AsmJit::Assembler. If you are
//! using @c AsmJit::Compiler and you want to log messages in correct assembler
//! order, you should look at @c AsmJit::Compiler::comment() method. It allows 
//! you to insert text message into @c AsmJit::Emittable list and 
//! @c AsmJit::Compiler will send your message to @c AsmJit::Assembler in 
//! correct order.
//!
//! @sa @c AsmJit::Logger, @c AsmJit::FileLogger.


//! @defgroup AsmJit_MemoryManagement Virtual memory management.
//!
//! Using @c AsmJit::Assembler or @c AsmJit::Compiler to generate machine 
//! code is not final step. Each generated code needs to run in memory 
//! that is not protected against code execution. To alloc this code it's
//! needed to use operating system functions provided to enable execution
//! code in specified memory block or to allocate memory that is not
//! protected. The solution is always to use @c See AsmJit::Assembler::make() 
//! and @c AsmJit::Compiler::make() functions that can allocate memory and
//! relocate code for you. But AsmJit also contains classes for manual memory
//! management thats internally used by AsmJit but can be used by programmers
//! too.
//!
//! Memory management contains low level and high level classes related to
//! allocating and freeing virtual memory. Low level class is 
//! @c AsmJit::VirtualMemory that can allocate and free full pages of
//! virtual memory provided by operating system. Higher level class is
//! @c AsmJit::MemoryManager that is able to manage complete allocation and
//! free mechanism. It internally uses larger chunks of memory to make
//! allocation fast and effective.
//!
//! Using @c AsmJit::VirtualMemory::alloc() is crossplatform way how to 
//! allocate this kind of memory without worrying about operating system 
//! and it's API. Each memory block that is no longer needed should be 
//! freed by @c AsmJit::VirtualMemory::free() method. If you want better
//! comfort and malloc()/free() interface, look at the 
//! @c AsmJit::MemoryManager class.
//!
//! @sa @c AsmJit::VirtualMemory, @ AsmJit::MemoryManager.


//! @defgroup AsmJit_Util Utilities and helper classes.
//!
//! Contains some helper classes that's used by AsmJit library.



//! @addtogroup AsmJit_Config
//! @{

//! @def ASMJIT_WINDOWS
//! @brief Macro that is declared if AsmJit is compiled for Windows.

//! @def ASMJIT_POSIX
//! @brief Macro that is declared if AsmJit is compiled for unix like 
//! operating system.

//! @def ASMJIT_API
//! @brief Attribute that's added to classes that can be exported if AsmJit
//! is compiled as a dll library.

//! @def ASMJIT_MALLOC
//! @brief Function to call to allocate dynamic memory.

//! @def ASMJIT_REALLOC
//! @brief Function to call to reallocate dynamic memory.

//! @def ASMJIT_FREE
//! @brief Function to call to free dynamic memory.

//! @def ASMJIT_ASSERT
//! @brief Assertion macro. Default implementation calls 
//! @c AsmJit::assertionFailure() function.

#if defined(_MSC_VER)
#pragma warning(disable:4311)
#endif

#include "Build.h"
#include "Assembler.h"
#include "CodeGenerator.h"
#include "Compiler.h"
#include "CpuInfo.h"
#include "Defs.h"
#include "Logger.h"
#include "MemoryManager.h"
#include "MemoryMarker.h"
#include "Operand.h"
#include "Platform.h"
#include "Util.h"

#endif // _ASMJIT_H

```

`AsmJit/AsmJitEnlarge.cpp`:

```cpp
#include <stdio.h>
#include "AsmJit.h"
#include "AsmJitEnlarge.h"

GPReg  text_to_reg(char * src)
{
  _strupr( src );
  for ( int i = 0; i < 8*5; i++ ) {
    if (strcmp( src, ia86_reg[ i ] ) == 0)
    {
      return jit_reg[ i ];
    }
  }
}

```

`AsmJit/AsmJitEnlarge.h`:

```h
#include "AsmJit.h"

using namespace AsmJit;

#ifdef PROTECT_X64
GPReg jit_reg[  ] = {
  al,cl,dl,bl,ah,ch,dh,bh,
  ax,cx,dx,bx,bx,sp,si,di,
  eax,ecx,edx,ebx,esp,esi,edi,
  rax,rcx,rdx,rbx,rsp,rsi,rdi,
  r8,r9,r10,r11,r12,r13,r14,r15
};
char * ia86_reg[  ] = {
  "al","cl","dl","bl","ah","ch","dh","bh",
  "ax","cx","dx","bx","bx","sp","si","di",
  "eax","ecx","edx","ebx","esp","esi","edi",
  "rax","rcx","rdx","rbx3","rsp","rsi","rdi",
  "r8","r9","r10","r11","r12","r13","r14","r15"
};
#else
GPReg jit_reg[  ] = {
  al,cl,dl,bl,ah,ch,dh,bh,
  ax,cx,dx,bx,bx,sp,si,di,
  eax,ecx,edx,ebx,esp,esi,edi
};
char * ia86_reg[  ] = {
  "al","cl","dl","bl","ah","ch","dh","bh",
  "ax","cx","dx","bx","bx","sp","si","di",
  "eax","ecx","edx","ebx","esp","esi","edi"
};
#endif




GPReg text_to_reg( char *src );

```

`AsmJit/Assembl.cpp`:

```cpp

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>
#include "opcode_table.h"
#include "Assembl.h"

#if defined(_MSC_VER)
#pragma warning(disable:4312)
#pragma warning(disable:4996)
#endif

Assembl::Assembl()
{

}
Assembl::~Assembl()
{

}

using namespace AsmJit;

typedef struct t_addrdec {
	int            defseg;
	char           *descr;
} t_addrdec;

// Scanner modes.
#define SA_NAME        0x0001          // Don't try to decode labels
#define SA_IMPORT      0x0002          // Allow import pseudolabel

// Types of input tokens reported by scanner.
#define SCAN_EOL       0               // End of line
#define SCAN_REG8      1               // 8-bit register
#define SCAN_REG16     2               // 16-bit register
#define SCAN_REG32     3               // 32-bit register
#define SCAN_SEG       4               // Segment register
#define SCAN_FPU       5               // FPU register
#define SCAN_MMX       6               // MMX register
#define SCAN_CR        7               // Control register
#define SCAN_DR        8               // Debug register
#define SCAN_OPSIZE    9               // Operand size modifier
#define SCAN_JMPSIZE   10              // Jump size modifier
#define SCAN_LOCAL     11              // Address on stack in form LOCAL.decimal
#define SCAN_ARG       12              // Address on stack in form ARG.decimal
#define SCAN_PTR       20              // PTR in MASM addressing statements
#define SCAN_REP       21              // REP prefix
#define SCAN_REPE      22              // REPE prefix
#define SCAN_REPNE     23              // REPNE prefix
#define SCAN_LOCK      24              // LOCK prefix
#define SCAN_NAME      25              // Command or label
#define SCAN_ICONST    26              // Hexadecimal constant
#define SCAN_DCONST    27              // Decimal constant
#define SCAN_OFS       28              // Undefined constant
#define SCAN_FCONST    29              // Floating-point constant
#define SCAN_EIP       30              // Register EIP
#define SCAN_SIGNED    31              // Keyword "SIGNED" (in expressions)
#define SCAN_UNSIGNED  32              // Keyword "UNSIGNED" (in expressions)
#define SCAN_CHAR      33              // Keyword "CHAR" (in expressions)
#define SCAN_FLOAT     34              // Keyword "FLOAT" (in expressions)
#define SCAN_DOUBLE    35              // Keyword "DOUBLE" (in expressions)
#define SCAN_FLOAT10   36              // Keyword "FLOAT10" (in expressions)
#define SCAN_STRING    37              // Keyword "STRING" (in expressions)
#define SCAN_UNICODE   38              // Keyword "UNICODE" (in expressions)
#define SCAN_MSG       39              // Pseudovariable MSG (in expressions)

#define SCAN_LABEL     40              //是否是注释
#define SCAN_LABEL_BIND 41

#define SCAN_REG64     42               // 32-bit register

#define SCAN_SYMB      64              // Any other character
#define SCAN_IMPORT    65              // Import pseudolabel
#define SCAN_ERR       255             // Definitely bad item

#define SEG_UNDEF     -1
#define SEG_ES         0               // Indexes of segment/selector registers
#define SEG_CS         1
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

#ifdef PROTECT_X64
const char *w_regname[5][9] = {
	{ "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH", "REG8"  },
	{ "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI", "REG16" },
	{ "EAX","ECX","EDX","EBX","ESP","EBP","ESI","EDI","REG32" },
	{ "RAX","RCX","RDX","RBX","RSP","RBP","RSI","RDI","REG64" },
	{ "R8","R9","R10","R11","R12","R13","R14","R15","R64" }
};
#else
const char *w_regname[3][9] = {
	{ "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH", "REG8"  },
	{ "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI", "REG16" },
	{ "EAX","ECX","EDX","EBX","ESP","EBP","ESI","EDI","REG32" }
};
#endif


	const char *w_segname[8] = {
		"ES","CS","SS","DS","FS","GS","SEG?","SEG?" };

		const char *w_sizename[11] = {
			"(0-BYTE)", "BYTE", "WORD", "(3-BYTE)",
			"DWORD", "(5-BYTE)", "FWORD", "(7-BYTE)",
			"QWORD", "(9-BYTE)", "TBYTE" };

			const t_addrdec w_addr16[8] = {
				{ SEG_DS,"BX+SI" }, { SEG_DS,"BX+DI" },
				{ SEG_SS,"BP+SI" }, { SEG_SS,"BP+DI" },
				{ SEG_DS,"SI" },    { SEG_DS,"DI" },
				{ SEG_SS,"BP" },    { SEG_DS,"BX" } };

				const t_addrdec w_addr32[8] = {
					{ SEG_DS,"EAX" }, { SEG_DS,"ECX" },
					{ SEG_DS,"EDX" }, { SEG_DS,"EBX" },
					{ SEG_SS,"" },    { SEG_SS,"EBP" },
					{ SEG_DS,"ESI" }, { SEG_DS,"EDI" } };

					const char *w_fpuname[9] = {
						"ST0","ST1","ST2","ST3","ST4","ST5","ST6","ST7","FPU" };

						const char *w_mmxname[9] = {
							"MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7","MMX" };

							const char *w_crname[9] = {
								"CR0","CR1","CR2","CR3","CR4","CR5","CR6","CR7","CRX" };

								const char *w_drname[9] = {
									"DR0","DR1","DR2","DR3","DR4","DR5","DR6","DR7","DRX" };

#define NNN            0               // No operand
#define REG            1               // Integer register in Reg field
#define RCM            2               // Integer register in command byte
#define RG4            3               // Integer 4-byte register in Reg field
#define RAC            4               // Accumulator (AL/AX/EAX, implicit)
#define RAX            5               // AX (2-byte, implicit)
#define RDX            6               // DX (16-bit implicit port address)
#define RCL            7               // Implicit CL register (for shifts)
#define RS0            8               // Top of FPU stack (ST(0), implicit)
#define RST            9               // FPU register (ST(i)) in command byte
#define RMX            10              // MMX register MMx
#define R3D            11              // 3DNow! register MMx
#define MRG            12              // Memory/register in ModRM byte
#define MR1            13              // 1-byte memory/register in ModRM byte
#define MR2            14              // 2-byte memory/register in ModRM byte
#define MR4            15              // 4-byte memory/register in ModRM byte
#define RR4            16              // 4-byte memory/register (register only)
#define MR8            17              // 8-byte memory/MMX register in ModRM
#define RR8            18              // 8-byte MMX register only in ModRM
#define MRD            19              // 8-byte memory/3DNow! register in ModRM
#define RRD            20              // 8-byte memory/3DNow! (register only)
#define MRJ            21              // Memory/reg in ModRM as JUMP target
#define MMA            22              // Memory address in ModRM byte for LEA
#define MML            23              // Memory in ModRM byte (for LES)
#define MMS            24              // Memory in ModRM byte (as SEG:OFFS)
#define MM6            25              // Memory in ModRm (6-byte descriptor)
#define MMB            26              // Two adjacent memory locations (BOUND)
#define MD2            27              // Memory in ModRM (16-bit integer)
#define MB2            28              // Memory in ModRM (16-bit binary)
#define MD4            29              // Memory in ModRM byte (32-bit integer)
#define MD8            30              // Memory in ModRM byte (64-bit integer)
#define MDA            31              // Memory in ModRM byte (80-bit BCD)
#define MF4            32              // Memory in ModRM byte (32-bit float)
#define MF8            33              // Memory in ModRM byte (64-bit float)
#define MFA            34              // Memory in ModRM byte (80-bit float)
#define MFE            35              // Memory in ModRM byte (FPU environment)
#define MFS            36              // Memory in ModRM byte (FPU state)
#define MFX            37              // Memory in ModRM byte (ext. FPU state)
#define MSO            38              // Source in string op's ([ESI])
#define MDE            39              // Destination in string op's ([EDI])
#define MXL            40              // XLAT operand ([EBX+AL])
#define IMM            41              // Immediate data (8 or 16/32)
#define IMU            42              // Immediate unsigned data (8 or 16/32)
#define VXD            43              // VxD service
#define IMX            44              // Immediate sign-extendable byte
#define C01            45              // Implicit constant 1 (for shifts)
#define IMS            46              // Immediate byte (for shifts)
#define IM1            47              // Immediate byte
#define IM2            48              // Immediate word (ENTER/RET)
#define IMA            49              // Immediate absolute near data address
#define JOB            50              // Immediate byte offset (for jumps)
#define JOW            51              // Immediate full offset (for jumps)
#define JMF            52              // Immediate absolute far jump/call addr
#define SGM            53              // Segment register in ModRM byte
#define SCM            54              // Segment register in command byte
#define CRX            55              // Control register CRx
#define DRX            56              // Debug register DRx
#define LABEL          57              // 标签

#define REG_EAX        0               // Indexes of general-purpose registers
#define REG_ECX        1               // in t_reg.
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

void Assembl::Scanasm(int mode) {

	int i,j,base,maxdigit;
	long decimal,hex;
	long double floating,divisor;
	char s[TEXTLEN],*pcmd;
	sdata[0]='\0';
	idata=0;
	if (asmcmd==NULL) {
		asmerror="NULL input line"; scan=SCAN_ERR; return; };

		while (*asmcmd==' ' || *asmcmd=='\t')
			asmcmd++;                          // Skip leading spaces

		if (*asmcmd=='\0' || *asmcmd==';') {
			scan=SCAN_EOL; return; };          // Empty line


			char t_lable[256];
			strcpy(t_lable,asmcmd);
			char *is_lable = strchr(t_lable,':');  //判断是否标签
			char *check1 = strchr(asmcmd,'[');
			char *check2 = strchr(asmcmd,']');
			if (is_lable && !check1 && !check2)
			{
				strupr(t_lable);
				*is_lable = '\0';
				std::list <label_list> ::iterator labeliter;
				bool is_existing = false;
				for (labeliter = l_label.begin();labeliter!=l_label.end();++labeliter)
				{
					if (strcmp(labeliter->labelname,t_lable) == 0)
					{
						is_existing = true;
						a.bind(labeliter->label);
					}

				}
				if (is_existing == false)
				{
					label_list label;
					label.label = a.newLabel();
					strcpy(label.labelname,t_lable);
					l_label.push_back(label);
					a.bind(l_label.back().label);
				}
				scan = SCAN_LABEL_BIND;
				return;
			}

			if (isalpha(*asmcmd) || *asmcmd=='_' || *asmcmd=='@') {
				sdata[0]=*asmcmd++; i=1;           // Some keyword or identifier
				while ((isalnum(*asmcmd) || *asmcmd=='_' || *asmcmd=='@') &&
					i<sizeof(sdata))
					sdata[i++]=*asmcmd++;
				if (i>=sizeof(sdata)) {
					asmerror="Too long identifier"; scan=SCAN_ERR; return; };
					sdata[i]='\0';
					while (*asmcmd==' ' || *asmcmd=='\t')
						asmcmd++;                        // Skip trailing spaces
					strcpy(s,sdata); strupr(s);
					for (j=0; j<=8; j++) {             // j==8 means "any register"
						if (strcmp(s,w_regname[0][j])!=0) continue;
						idata=j; scan=SCAN_REG8;         // 8-bit register
						return; };
						for (j=0; j<=8; j++) {
							if (strcmp(s,w_regname[1][j])!=0) continue;
							idata=j; scan=SCAN_REG16;        // 16-bit register
							return; };
							for (j=0; j<=8; j++) {
								if (strcmp(s,w_regname[2][j])!=0) continue;
								idata=j; scan=SCAN_REG32;        // 32-bit register
								return; };
#ifdef PROTECT_X64
								for (j=0; j<=8; j++) {
									if (strcmp(s,w_regname[3][j])!=0) continue;
									idata=j; scan=SCAN_REG64;        // 64-bit register
									return; };
									for (j=0; j<=8; j++) {
										if (strcmp(s,w_regname[4][j])!=0) continue;
										idata=j+8; scan=SCAN_REG64;        // 64-bit register
										return; };
#endif
								for (j=0; j<6; j++) {
									if (strcmp(s,w_segname[j])!=0) continue;
									idata=j; scan=SCAN_SEG;          // Segment register
									while (*asmcmd==' ' || *asmcmd=='\t')
										asmcmd++;                      // Skip trailing spaces
									return; };
									if (strcmp(s,"ST")==0) {
										pcmd=asmcmd; Scanasm(SA_NAME);   // FPU register
										if (scan!=SCAN_SYMB || idata!='(') {
											asmcmd=pcmd;                   // Undo last scan
											idata=0; scan=SCAN_FPU; return; };
											Scanasm(SA_NAME); j=idata;
											if ((scan!=SCAN_ICONST && scan!=SCAN_DCONST) || idata<0 || idata>7) {
												asmerror="FPU registers have indexes 0 to 7";
												scan=SCAN_ERR; return; };
												Scanasm(SA_NAME);
												if (scan!=SCAN_SYMB || idata!=')') {
													asmerror="Closing parenthesis expected";
													scan=SCAN_ERR; return; };
													idata=j; scan=SCAN_FPU; return; };
													for (j=0; j<=8; j++) {
														if (strcmp(s,w_fpuname[j])!=0) continue;
														idata=j; scan=SCAN_FPU;          // FPU register (alternative coding)
														return; };
														for (j=0; j<=8; j++) {
															if (strcmp(s,w_mmxname[j])!=0) continue;
															idata=j; scan=SCAN_MMX;          // MMX register
															return; };
															for (j=0; j<=8; j++) {
																if (strcmp(s,w_crname[j])!=0) continue;
																idata=j; scan=SCAN_CR;           // Control register
																return; };
																for (j=0; j<=8; j++) {
																	if (strcmp(s,w_drname[j])!=0) continue;
																	idata=j; scan=SCAN_DR;           // Debug register
																	return; };
																	for (j=0; j<sizeof(w_sizename)/sizeof(w_sizename[0]); j++) {
																		if (strcmp(s,w_sizename[j])!=0) continue;
																		pcmd=asmcmd; Scanasm(SA_NAME);
																		if (scan!=SCAN_PTR)              // Fetch non-functional "PTR"
																			asmcmd=pcmd;
																		idata=j; scan=SCAN_OPSIZE;       // Operand (data) size in bytes
																		return; };
																		if (strcmp(s,"EIP")==0) {          // Register EIP
																			scan=SCAN_EIP; idata=0; return; };
																			if (strcmp(s,"SHORT")==0) {        // Relative jump has 1-byte offset
																				scan=SCAN_JMPSIZE; idata=1; return; };
																				if (strcmp(s,"LONG")==0) {         // Relative jump has 4-byte offset
																					scan=SCAN_JMPSIZE; idata=2; return; };
																					if (strcmp(s,"NEAR")==0) {         // Jump within same code segment
																						scan=SCAN_JMPSIZE; idata=4; return; };
																						if (strcmp(s,"FAR")==0) {          // Jump to different code segment
																							scan=SCAN_JMPSIZE; idata=8; return; };
																							if (strcmp(s,"LOCAL")==0 && *asmcmd=='.') {
																								asmcmd++;
																								while (*asmcmd==' ' || *asmcmd=='\t')
																									asmcmd++;                      // Skip trailing spaces
																								if (!isdigit(*asmcmd)) {
																									asmerror="Integer number expected";
																									scan=SCAN_ERR; return; };
																									while (isdigit(*asmcmd))         // LOCAL index is decimal number!
																										idata=idata*10+(*asmcmd++)-'0';
																									scan=SCAN_LOCAL; return; };
																									if (strcmp(s,"ARG")==0 && *asmcmd=='.') {
																										asmcmd++;
																										while (*asmcmd==' ' || *asmcmd=='\t')
																											asmcmd++;                      // Skip trailing spaces
																										if (!isdigit(*asmcmd)) {
																											asmerror="Integer number expected";
																											scan=SCAN_ERR; return; };
																											while (isdigit(*asmcmd))         // ARG index is decimal number!
																												idata=idata*10+(*asmcmd++)-'0';
																											scan=SCAN_ARG; return; };
																											if (strcmp(s,"REP")==0) {
																												scan=SCAN_REP; return; };        // REP prefix
																												if (strcmp(s,"REPE")==0 || strcmp(s,"REPZ")==0) {
																													scan=SCAN_REPE; return; };       // REPE prefix
																													if (strcmp(s,"REPNE")==0 || strcmp(s,"REPNZ")==0) {
																														scan=SCAN_REPNE; return; };      // REPNE prefix
																														if (strcmp(s,"LOCK")==0) {
																															scan=SCAN_LOCK; return; };       // LOCK prefix
																															if (strcmp(s,"PTR")==0) {
																																scan=SCAN_PTR; return; };        // PTR in MASM addressing statements
																																if (strcmp(s,"CONST")==0 || strcmp(s,"OFFSET")==0) {
																																	scan=SCAN_OFS; return; };        // Present but undefined offset/constant
																																	if (strcmp(s,"SIGNED")==0) {
																																		scan=SCAN_SIGNED; return; };     // Keyword "SIGNED" (in expressions)
																																		if (strcmp(s,"UNSIGNED")==0) {
																																			scan=SCAN_UNSIGNED; return; };   // Keyword "UNSIGNED" (in expressions)
																																			if (strcmp(s,"CHAR")==0) {
																																				scan=SCAN_CHAR; return; };       // Keyword "CHAR" (in expressions)
																																				if (strcmp(s,"FLOAT")==0) {
																																					scan=SCAN_FLOAT; return; };      // Keyword "FLOAT" (in expressions)
																																					if (strcmp(s,"DOUBLE")==0) {
																																						scan=SCAN_DOUBLE; return; };     // Keyword "DOUBLE" (in expressions)
																																						if (strcmp(s,"FLOAT10")==0) {
																																							scan=SCAN_FLOAT10; return; };    // Keyword "FLOAT10" (in expressions)
																																							if (strcmp(s,"STRING")==0) {
																																								scan=SCAN_STRING; return; };     // Keyword "STRING" (in expressions)
																																								if (strcmp(s,"UNICODE")==0) {
																																									scan=SCAN_UNICODE; return; };    // Keyword "UNICODE" (in expressions)
																																									if (strcmp(s,"MSG")==0) {
																																										scan=SCAN_MSG; return; };        // Pseudovariable MSG (in expressions)
																																										if (mode & SA_NAME) {            //标签
																																											idata=i; scan=SCAN_NAME;         // Don't try to decode symbolic label
																																											return; }
																																										std::list <label_list> ::iterator labeliter;
																																										bool is_existing = false;
																																										for (labeliter = l_label.begin();labeliter!=l_label.end();++labeliter)
																																										{
																																											if (strcmp(labeliter->labelname,s) == 0)
																																											{
																																												is_existing = true;
																																												now_label = &labeliter->label;
																																											//	a.bind(labeliter->label);
																																											}
																																										}
																																										if (is_existing == false)
																																										{
																																											label_list label;
																																											//label.label = a.newLabel();
																																											strcpy(label.labelname,s);
																																											l_label.push_back(label);
																																											l_label.back().label = a.newLabel();
																																											now_label = &l_label.back().label;
																																										}
																																										scan = SCAN_LABEL;
																																										return;
																																										/*asmerror="Unknown identifier";*/
																																										/*scan=SCAN_ERR; return; */}                //如过是不认识的东西就暂时把他当做标签
				else if (isdigit(*asmcmd)) {         // Constant
					base=0; maxdigit=0; decimal=hex=0L; floating=0.0;
					if (asmcmd[0]=='0' && toupper(asmcmd[1])=='X') {
						base=16; asmcmd+=2; };           // Force hexadecimal number
						while (1) {
							if (isdigit(*asmcmd)) {
								decimal=decimal*10+(*asmcmd)-'0';
								floating=floating*10.0+(*asmcmd)-'0';
								hex=hex*16+(*asmcmd)-'0';
								if (maxdigit==0) maxdigit=9;
								asmcmd++; }
							else if (isxdigit(*asmcmd)) {
								hex=hex*16+toupper(*asmcmd++)-'A'+10;
								maxdigit=15; }
							else break; };
							if (maxdigit==0) {
								asmerror="Hexadecimal digits after 0x... expected";
								scan=SCAN_ERR; return; };
								if (toupper(*asmcmd)=='H') {       // Force hexadecimal number
									if (base==16) {
										asmerror="Please don't mix 0xXXXX and XXXXh forms";
										scan=SCAN_ERR; return; };
										asmcmd++;
										idata=hex; scan=SCAN_ICONST;
										while (*asmcmd==' ' || *asmcmd=='\t') asmcmd++;
										return; };
										if (*asmcmd=='.') {                // Force decimal number
											if (base==16 || maxdigit>9) {
												asmerror="Not a decimal number"; scan=SCAN_ERR; return; };
												asmcmd++;
												if (isdigit(*asmcmd) || toupper(*asmcmd)=='E') {
													divisor=1.0;
													while (isdigit(*asmcmd)) {     // Floating-point number
														divisor/=10.0;
														floating+=divisor*(*asmcmd-'0');
														asmcmd++; };
														if (toupper(*asmcmd)=='E') {
															asmcmd++;
															if (*asmcmd=='-') { base=-1; asmcmd++; }
															else base=1;
															if (!isdigit(*asmcmd)) {
																asmerror="Invalid exponent"; scan=SCAN_ERR; return; };
																decimal=0;
																while (isdigit(*asmcmd)) {
																	if (decimal<65536L) decimal=decimal*10+(*asmcmd++)-'0'; };
																	floating*=pow(10.0,decimal*base); };
																	fdata=floating;
																	scan=SCAN_FCONST; return; }
												else {
													idata=decimal; scan=SCAN_DCONST;
													while (*asmcmd==' ' || *asmcmd=='\t') asmcmd++;
													return;
												};
										};
										idata=hex; scan=SCAN_ICONST;       // Default is hexadecimal
										while (*asmcmd==' ' || *asmcmd=='\t') asmcmd++;
										return; }
				else if (*asmcmd=='\'') {            // Character constant
					asmcmd++;
					if (*asmcmd=='\0' || (*asmcmd=='\\' && asmcmd[1]=='\0'))  {
						asmerror="Unterminated character constant"; scan=SCAN_ERR; return; };
						if (*asmcmd=='\'') {
							asmerror="Empty character constant"; scan=SCAN_ERR; return; };
							if (*asmcmd=='\\') asmcmd++;
							idata=*asmcmd++;
							if (*asmcmd!='\'')  {
								asmerror="Unterminated character constant"; scan=SCAN_ERR; return; };
								asmcmd++;
								while (*asmcmd==' ' || *asmcmd=='\t') asmcmd++;
								scan=SCAN_ICONST; return; }
				else {                               // Any other character or combination
					idata=sdata[0]=*asmcmd++; sdata[1]=sdata[2]='\0';
					if (idata=='|' && *asmcmd=='|') {
						idata='||'; prio=10;             // '||'
						sdata[1]=*asmcmd++; }
					else if (idata=='&' && *asmcmd=='&') {
						idata='&&'; prio=9;              // '&&'
						sdata[1]=*asmcmd++; }
					else if (idata=='=' && *asmcmd=='=') {
						idata='=='; prio=5;              // '=='
						sdata[1]=*asmcmd++; }
					else if (idata=='!' && *asmcmd=='=') {
						idata='!='; prio=5;              // '!='
						sdata[1]=*asmcmd++; }
					else if (idata=='<' && *asmcmd=='=') {
						idata='<='; prio=4;              // '<='
						sdata[1]=*asmcmd++; }
					else if (idata=='>' && *asmcmd=='=') {
						idata='>='; prio=4;              // '>='
						sdata[1]=*asmcmd++; }
					else if (idata=='<' && *asmcmd=='<') {
						idata='<<'; prio=3;              // '<<'
						sdata[1]=*asmcmd++; }
					else if (idata=='>' && *asmcmd=='>') {
						idata='>>'; prio=3;              // '>>'
						sdata[1]=*asmcmd++; }
					else if (idata=='|') prio=8;       // '|'
					else if (idata=='^') prio=7;       // '^'
					else if (idata=='&') prio=6;       // '&'
					else if (idata=='<') {
						if (*asmcmd=='&') {              // Import pseudolabel (for internal use)
							if ((mode & SA_IMPORT)==0) {
								asmerror="Syntax error"; scan=SCAN_ERR; return; };
								asmcmd++; i=0;
								while (*asmcmd!='\0' && *asmcmd!='>') {
									sdata[i++]=*asmcmd++;
									if (i>=sizeof(sdata)) {
										asmerror="Too long import name"; scan=SCAN_ERR; return;
									};
								};
								if (*asmcmd!='>') {
									asmerror="Unterminated import name"; scan=SCAN_ERR; return; };
									asmcmd++; sdata[i]='\0';
									scan=SCAN_IMPORT; return; }
						else prio=4; }                   // '<'
					else if (idata=='>') prio=4;       // '>'
					else if (idata=='+') prio=2;       // '+'
					else if (idata=='-') prio=2;       // '-'
					else if (idata=='*') prio=1;       // '*'
					else if (idata=='/') prio=1;       // '/'
					else if (idata=='%') prio=1;       // '%'
					else if (idata==']') {
						pcmd=asmcmd; Scanasm(SA_NAME);
						if (scan!=SCAN_SYMB || idata!='[') {
							idata=']'; asmcmd=pcmd; prio=0; }
						else {
							idata='+'; prio=2;             // Translate '][' to '+'
						};
					}
					else prio=0;                       // Any other character
					scan=SCAN_SYMB;
					return;
				};
};


 void Assembl::Parseasmoperand(asmoperand *op) {
	int i,j,bracket,sign,xlataddr;
	int reg,r[9+8];
	long offset;
	if (scan==SCAN_EOL || scan==SCAN_ERR)
		return;                            // No or bad operand

	//标签
	if (scan == SCAN_LABEL)
	{
		op->type = LABEL;
		op->label = now_label;
		return;
	}
	// Jump or call address may begin with address size modifier(s) SHORT, LONG,
	// NEAR and/or FAR. Not all combinations are allowed. After operand is
	// completely parsed, this function roughly checks whether modifier is
	// allowed. Exact check is done in Assemble().
	if (scan==SCAN_JMPSIZE) {
		j=0;
		while (scan==SCAN_JMPSIZE) {
			j|=idata;                        // Fetch all size modifiers
			Scanasm(0); };
			if (
				((j & 0x03)==0x03) ||            // Mixed SHORT and LONG
				((j & 0x0C)==0x0C) ||            // Mixed NEAR and FAR
				((j & 0x09)==0x09)               // Mixed FAR and SHORT
				) {
					asmerror="Invalid combination of jump address modifiers";
					scan=SCAN_ERR; return; };
					if ((j & 0x08)==0) j|=0x04;        // Force NEAR if not FAR
					op->jmpmode=j; };
					// Simple operands are either register or constant, their processing is
					// obvious and straightforward.
					if (scan==SCAN_REG8 || scan==SCAN_REG16 || scan==SCAN_REG32 || scan == SCAN_REG64) {
						op->type=REG; op->index=idata;     // Integer general-purpose register
						if (scan==SCAN_REG8) op->size=1;
						else if (scan==SCAN_REG16) op->size=2;
						else if (scan==SCAN_REG64) op->size=8; //64位寄存器
						else op->size=4; }
					else if (scan==SCAN_FPU) {           // FPU register
						op->type=RST; op->index=idata; }
					else if (scan==SCAN_MMX) {           // MMX or 3DNow! register
						op->type=RMX; op->index=idata; }
					else if (scan==SCAN_CR) {            // Control register
						op->type=CRX; op->index=idata; }
					else if (scan==SCAN_DR) {            // Debug register
						op->type=DRX; op->index=idata; }
					else if (scan==SCAN_SYMB && idata=='-') {
						Scanasm(0);                        // Negative constant
						if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS) {
							asmerror="Integer number expected";
							scan=SCAN_ERR; return; };
							op->type=IMM; op->offset=-idata;
							if (scan==SCAN_OFS) op->anyoffset=1; }
					else if (scan==SCAN_SYMB && idata=='+') {
						Scanasm(0);                        // Positive constant
						if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS) {
							asmerror="Integer number expected";
							scan=SCAN_ERR; return; };
							op->type=IMM; op->offset=idata;
							if (scan==SCAN_OFS) op->anyoffset=1; }
					else if (scan==SCAN_ICONST || scan==SCAN_DCONST || scan==SCAN_OFS) {
						j=idata;
						if (scan==SCAN_OFS) op->anyoffset=1;
						Scanasm(0);
						if (scan==SCAN_SYMB && idata==':') {
							Scanasm(0);                      // Absolute long address (seg:offset)
							if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS) {
								asmerror="Integer address expected";
								scan=SCAN_ERR; return; };
								op->type=JMF; op->offset=idata; op->segment=j;
								if (scan==SCAN_OFS) op->anyoffset=1; }
						else {
							op->type=IMM; op->offset=j;      // Constant without sign
							return;                          // Next token already scanned
						}; }
					else if (scan==SCAN_FCONST) {
						asmerror="Floating-point numbers are not allowed in command";
						scan=SCAN_ERR; return; }
					// Segment register or address.
					else if (scan==SCAN_SEG || scan==SCAN_OPSIZE ||
						(scan==SCAN_SYMB && idata=='[')
						) {                                  // Segment register or address
							bracket=0;
							if (scan==SCAN_SEG) {
								j=idata; Scanasm(0);
								if (scan!=SCAN_SYMB || idata!=':') {
									op->type=SGM; op->index=j;     // Segment register as operand
									return; };                     // Next token already scanned
									op->segment=j; Scanasm(0); };
									// Scan 32-bit address. This parser does not support 16-bit addresses.
									// First of all, get size of operand (optional), segment register (optional)
									// and opening bracket (required).
									while (1) {
										if (scan==SCAN_SYMB && idata=='[') {
											if (bracket) {                 // Bracket
												asmerror="Only one opening bracket allowed";
												scan=SCAN_ERR; return; };
												bracket=1; }
										else if (scan==SCAN_OPSIZE) {
											if (op->size!=0) {             // Size of operand
												asmerror="Duplicated size modifier";
												scan=SCAN_ERR; return; };
												op->size=idata; }
										else if (scan==SCAN_SEG) {
											if (op->segment!=SEG_UNDEF) {  // Segment register
												asmerror="Duplicated segment register";
												scan=SCAN_ERR; return; };
												op->segment=idata; Scanasm(0);
												if (scan!=SCAN_SYMB || idata!=':') {
													asmerror="Semicolon expected";
													scan=SCAN_ERR; return;
												}; }
										else if (scan == SCAN_LABEL)
										{
											if (scan == SCAN_LABEL)
											{
												op->type = MRG;
												op->label = now_label;
												Scanasm(0);
												//return;
												break;
											}
										}
										else if (scan==SCAN_ERR)
											return;
										else break;                      // None of expected address elements
										Scanasm(0); };
										if (bracket==0) {
											asmerror="Address expression requires brackets";
											scan=SCAN_ERR; return; };
											// Assembling a 32-bit address may be a kind of nigthmare, due to a large
											// number of allowed forms. Parser collects immediate offset in op->offset
											// and count for each register in array r[]. Then it decides whether this
											// combination is valid and determines scale, index and base. Assemble()
											// will use these numbers to select address form (with or without SIB byte,
											// 8- or 32-bit offset, use segment prefix or not). As a useful side effect
											// of this technique, one may specify, for example, [EAX*5] which will
											// correctly assemble to [EAX*4+EAX].
											for (i=0; i<=8; i++) r[i]=0;
											sign='+';                          // Default sign for the first operand
											xlataddr=0;
											while (1) {                        // Get SIB and offset
												if (scan==SCAN_SYMB && (idata=='+' || idata=='-')) {
													sign=idata; Scanasm(0); };
													if (scan==SCAN_ERR) return;
													if (sign=='?') {
														asmerror="Syntax error"; scan=SCAN_ERR; return; };
														// Register AL appears as part of operand of (seldom used) command XLAT.
														if (scan==SCAN_REG8 && idata==REG_EAX) {
															if (sign=='-') {
																asmerror="Unable to subtract register"; scan=SCAN_ERR; return; };
																if (xlataddr!=0) {
																	asmerror="Too many registers"; scan=SCAN_ERR; return; };
																	xlataddr=1;
																	Scanasm(0); }
														else if (scan==SCAN_REG16) {
															asmerror="Sorry, 16-bit addressing is not supported";
															scan=SCAN_ERR; return; }
														else if (scan==SCAN_REG32) {
															if (sign=='-') {
																asmerror="Unable to subtract register"; scan=SCAN_ERR; return; };
																reg=idata; Scanasm(0);
																if (scan==SCAN_SYMB && idata=='*') {
																	Scanasm(0);                  // Try index*scale
																	if (scan==SCAN_ERR) return;
																	if (scan==SCAN_OFS) {
																		asmerror="Undefined scale is not allowed"; scan=SCAN_ERR; return; };
																		if (scan!=SCAN_ICONST && scan!=SCAN_DCONST) {
																			asmerror="Syntax error"; scan=SCAN_ERR; return; };
																			if (idata==6 || idata==7 || idata>9) {
																				asmerror="Invalid scale"; scan=SCAN_ERR; return; };
																				r[reg]+=idata;
																				Scanasm(0); }
																else r[reg]++; }               // Simple register
														else if (scan==SCAN_REG64) {                              ////////////////////////////////////////////////////////////////////////// 64
															if (sign=='-') {
																asmerror="Unable to subtract register"; scan=SCAN_ERR; return; };
																reg=idata; Scanasm(0);
																if (scan==SCAN_SYMB && idata=='*') {
																	Scanasm(0);                  // Try index*scale
																	if (scan==SCAN_ERR) return;
																	if (scan==SCAN_OFS) {
																		asmerror="Undefined scale is not allowed"; scan=SCAN_ERR; return; };
																		if (scan!=SCAN_ICONST && scan!=SCAN_DCONST) {
																			asmerror="Syntax error"; scan=SCAN_ERR; return; };
																			if (idata==6 || idata==7 || idata>9) {
																				asmerror="Invalid scale"; scan=SCAN_ERR; return; };
																				r[reg]+=idata;
																				Scanasm(0); }
																else r[reg]++; }               // Simple register
														else if (scan==SCAN_LOCAL) {
															r[REG_EBP]++;
															op->offset-=idata*4;
															Scanasm(0); }
														else if (scan==SCAN_ARG) {
															r[REG_EBP]++;
															op->offset+=(idata+1)*4;
															Scanasm(0); }
														else if (scan==SCAN_ICONST || scan==SCAN_DCONST) {
															offset=idata; Scanasm(0);
															if (scan==SCAN_SYMB && idata=='*') {
																Scanasm(0);                  // Try scale*index
																if (scan==SCAN_ERR) return;
																if (sign=='-') {
																	asmerror="Unable to subtract register"; scan=SCAN_ERR; return; };
																	if (scan==SCAN_REG16) {
																		asmerror="Sorry, 16-bit addressing is not supported";
																		scan=SCAN_ERR; return; };
																		if (scan!=SCAN_REG32) {
																			asmerror="Syntax error"; scan=SCAN_ERR; return; };
																			if (offset==6 || offset==7 || offset>9) {
																				asmerror="Invalid scale"; scan=SCAN_ERR; return; };
																				r[idata]+=offset;
																				Scanasm(0); }
															else {
																if (sign=='-') op->offset-=offset;
																else op->offset+=offset;
															}; }
														else if (scan==SCAN_OFS) {
															Scanasm(0);
															if (scan==SCAN_SYMB && idata=='*') {
																asmerror="Undefined scale is not allowed"; scan=SCAN_ERR; return; }
															else {
																op->anyoffset=1;
															}; }
														else break;                      // None of expected address elements
														if (scan==SCAN_SYMB && idata==']') break;
														sign='?';
											};
											if (scan==SCAN_ERR) return;
											if (scan!=SCAN_SYMB || idata!=']') {
												asmerror="Syntax error";
												scan=SCAN_ERR; return; };
												// Process XLAT address separately.
												if (xlataddr!=0) {                 // XLAT address in form [EBX+AX]
													for (i=0; i<=8; i++) {           // Check which registers used
														if (i==REG_EBX) continue;
														if (r[i]!=0) break; };
														if (i<=8 || r[REG_EBX]!=1 || op->offset!=0 || op->anyoffset!=0) {
															asmerror="Invalid address"; scan=SCAN_ERR; return; };
															op->type=MXL; }
												// Determine scale, index and base.
												else {
													j=0;                             // Number of used registers
													for (i=0; i<=8; i++) {
														if (r[i]==0)
															continue;                    // Unused register
														if (r[i]==3 || r[i]==5 || r[i]==9) {
															if (op->index>=0 || op->base>=0) {
																if (j==0) asmerror="Invalid scale";
																else asmerror="Too many registers";
																scan=SCAN_ERR; return; };
																op->index=op->base=i;
																op->scale=r[i]-1; }
														else if (r[i]==2 || r[i]==4 || r[i]==8) {
															if (op->index>=0) {
																if (j<=1) asmerror="Only one register may be scaled";
																else asmerror="Too many registers";
																scan=SCAN_ERR; return; };
																op->index=i; op->scale=r[i]; }
														else if (r[i]==1) {
															if (op->base<0)
																op->base=i;
															else if (op->index<0) {
																op->index=i; op->scale=1; }
															else {
																asmerror="Too many registers";
																scan=SCAN_ERR; return;
															}; }
														else {
															asmerror="Invalid scale"; scan=SCAN_ERR; return; };
															j++;
													};
													op->type=MRG;
												}; }
					else {
						asmerror="Unrecognized operand"; scan=SCAN_ERR; return; };
						// In general, address modifier is allowed only with address expression which
						// is a constant, a far address or a memory expression. More precise check
						// will be done later in Assemble().
						if (op->jmpmode!=0 && op->type!=IMM && op->type!=JMF && op->type!=MRG) {
							asmerror="Jump address modifier is not allowed";
							scan=SCAN_ERR; return; };
							Scanasm(0);                          // Fetch next token from input line
};

const GPReg * Assembl::get_reg(int reg,int size)
{
	switch (size)
	{
	case 1:
		{
			switch (reg)
			{
			case REG_EAX:
				return &al;
				break;
			case REG_EBX:
				return &bl;
				break;
			case REG_ECX:
				return &cl;
				break;
			case REG_EDX:
				return &dl;
				break;
			case REG_ESP:
				return &ah;
				break;
			case REG_EBP:
				return &ch;
				break;
			case REG_ESI:
				return &dh;
				break;
			case REG_EDI:
				return &bh;
				break;
			}
		}
		break;
	case 2:
		switch (reg)
		{
		case REG_EAX:
			return &ax;
			break;
		case REG_EBX:
			return &bx;
			break;
		case REG_ECX:
			return &cx;
			break;
		case REG_EDX:
			return &dx;
			break;
		case REG_ESP:
			return &sp;
			break;
		case REG_EBP:
			return &bp;
			break;
		case REG_ESI:
			return &si;
			break;
		case REG_EDI:
			return &di;
			break;
		}
		break;
	case 4:
		{
			switch (reg)
			{
			case REG_EAX:
				return &eax;
				break;
			case REG_EBX:
				return &ebx;
				break;
			case REG_ECX:
				return &ecx;
				break;
			case REG_EDX:
				return &edx;
				break;
			case REG_ESP:
				return &esp;
				break;
			case REG_EBP:
				return &ebp;
				break;
			case REG_ESI:
				return &esi;
				break;
			case REG_EDI:
				return &edi;
				break;
			}
		}
		break;
#ifdef PROTECT_X64
	case 8:
		{
			switch (reg)
			{
			case REG_EAX:
				return &rax;
				break;
			case REG_EBX:
				return &rbx;
				break;
			case REG_ECX:
				return &rcx;
				break;
			case REG_EDX:
				return &rdx;
				break;
			case REG_ESP:
				return &rsp;
				break;
			case REG_EBP:
				return &rbp;
				break;
			case REG_ESI:
				return &rsi;
				break;
			case REG_EDI:
				return &rdi;
				break;
			case REG_EAX+8:
				return &r8;
				break;
			case REG_ECX+8:
				return &r9;
				break;
			case REG_EDX+8:
				return &r10;
				break;
			case REG_EBX+8:
				return &r11;
				break;
			case REG_ESP+8:
				return &r12;
				break;
			case REG_EBP+8:
				return &r13;
				break;
			case REG_ESI+8:
				return &r14;
				break;
			case REG_EDI+8:
				return &r15;
				break;
			}

		}
#endif
	}
	switch (reg)
	{
	case REG_EAX:
		return &eax;
		break;
	case REG_EBX:
		return &ebx;
		break;
	case REG_ECX:
		return &ecx;
		break;
	case REG_EDX:
		return &edx;
		break;
	case REG_ESP:
		return &esp;
		break;
	case REG_EBP:
		return &ebp;
		break;
	case REG_ESI:
		return &esi;
		break;
	case REG_EDI:
		return &edi;
		break;
	}
	return NULL;
}

#define ScaleState(Scale) (Scale>4?Scale/2-1:Scale/2)

const Operand Assembl::get_operand(asmoperand *op)
{
	if (op->mode == SCAN_FPU && op->type == SCAN_OPSIZE)
	{
		X87Reg x87reg = st(op->index);
		return x87reg;
	}

	switch (op->type)
	{
	case IMM:
		{
			const Imm imm = op->offset;
			return imm;
		}
		break;
	case REG:
		{
			GPReg reg = *get_reg(op->index,op->size);
			return reg;
		}
		break;
	case MRG:
		{
		  //  word_ptr(eax,0,SEGMENT_FS);
			Mem mem;
			const GPReg *base = NULL;
			const GPReg *index = NULL;
			if (op->base != -1)
			{
				base = get_reg(op->base,op->size);
			}
			if (op->index != -1)
			{
				index = get_reg(op->index,op->size);
			}
			if (op->label && index)
			{
				switch (op->size)
				{
				case 0:
					mem = ptr(*op->label,*index,ScaleState(op->scale),op->offset);
					break;
				case 1:
					mem = byte_ptr(*op->label,*index,ScaleState(op->scale),op->offset);
					break;
				case 2:
					mem = word_ptr(*op->label,*index,ScaleState(op->scale),op->offset);
					break;
				case 4:
					mem = dword_ptr(*op->label,*index,ScaleState(op->scale),op->offset);
					break;
				case 8:
					mem = qword_ptr(*op->label,*index,ScaleState(op->scale),op->offset);
					break;
				}
				return mem;
			}
			else if (op->label)
			{
				switch (op->size)
				{
				case 0:
					mem = ptr (*op->label,op->offset);
				case 1:
					mem = byte_ptr(*op->label,op->offset);
					break;
				case 2:
					mem = word_ptr(*op->label,op->offset);
					break;
				case 4:
					mem = dword_ptr(*op->label,op->offset);
					break;
				case 8:
					mem = qword_ptr(*op->label,op->offset);
					break;
				}
				return mem;
			}
			else if (base && index)
			{
				if (op->segment != -1) // 有段
				{
					switch (op->size)
					{
					case 0:
				//		mem = ptr(*base,*index,ScaleState(op->scale),op->offset,op->segment);
						break;
					case 1:
						mem = byte_ptr(*base,*index,ScaleState(op->scale),op->offset,op->segment);
						break;
					case 2:
						mem = word_ptr(*base,*index,ScaleState(op->scale),op->offset,op->segment);
						break;
					case 4:
						mem = dword_ptr(*base,*index,ScaleState(op->scale),op->offset,op->segment);
						break;
					case 8:
						mem = qword_ptr(*base,*index,ScaleState(op->scale),op->offset,op->segment);
						break;
					}
					return mem;
				}
				else
				{
					switch (op->size)
					{
					case 0:
						mem = ptr(*base,*index,ScaleState(op->scale),op->offset);
						break;
					case 1:
						mem = byte_ptr(*base,*index,ScaleState(op->scale),op->offset);
						break;
					case 2:
						mem = word_ptr(*base,*index,ScaleState(op->scale),op->offset);
						break;
					case 4:
						mem = dword_ptr(*base,*index,ScaleState(op->scale),op->offset);
						break;
					case 8:
						mem = qword_ptr(*base,*index,ScaleState(op->scale),op->offset);
						break;
					}
					return mem;
				}

			}
			else if (base)
			{
				if (op->segment != -1)
				{
					switch (op->size)
					{
					case 0:
				//		mem = ptr(*base,op->offset,op->segment);
						break;
					case 1:
						mem = byte_ptr(*base,op->offset,op->segment);
						break;
					case 2:
						mem = word_ptr(*base,op->offset,op->segment);
						break;
					case 4:
						mem = dword_ptr(*base,op->offset,op->segment);
						break;
					case 8:
						mem = qword_ptr(*base,op->offset,op->segment);
						break;
					}
				}
				else
				{
					switch (op->size)
					{
					case 0:
						mem = ptr(*base,op->offset);
						break;
					case 1:
						mem = byte_ptr(*base,op->offset);
						break;
					case 2:
						mem = word_ptr(*base,op->offset);
						break;
					case 4:
						mem = dword_ptr(*base,op->offset);
						break;
					case 8:
						mem = qword_ptr(*base,op->offset);
						break;
				     }
			//	mem = dword_ptr(*base,op->offset);
				}
				return mem;
			}
			else
			{
				if (op->segment != 0)
				{
					switch (op->size)
					{
					case 0:
						mem = ptr_abs((void *)op->offset,0,op->segment);
						break;
					case 1:
							mem = byte_ptr_abs((void *)op->offset,0,op->segment);
							break;
					case 2:
							mem = word_ptr_abs((void *)op->offset,0,op->segment);
						    break;
					case 4:
						mem = dword_ptr_abs((void *)op->offset,0,op->segment);
						break;
					case 8:
						mem = qword_ptr_abs((void *)op->offset,0,op->segment);
						break;
					}
				}
				else
				{
					switch (op->size)
					{
					case 1:
							mem = byte_ptr_abs((void *)op->offset);
							break;
					case 2:
							mem = word_ptr_abs((void *)op->offset);
							break;
					case 4:
						mem = dword_ptr_abs((void *)op->offset);
						break;
					case 8:
						mem = qword_ptr_abs((void *)op->offset);
						break;
					}
				}
				//mem = dword_ptr_abs((void*)op->offset,0,SEGMENT_CS);
				return mem;
			}
		}
		break;
	case LABEL:
		{
			Label label = *op->label;
			return label;
		}
		break;
	case SGM:
		{
			switch (op->index)
			{
			case SEG_CS:
				return cs;
			case SEG_DS:
				return ds;
			case SEG_ES:
				return es;
			case SEG_SS:
				return ss;
			case SEG_FS:
				return fs;
			case SEG_GS:
				return gs;
			default:
				return ds;
			}
		}
		break;
	}
    GPReg reg;
    return reg;
}



unsigned char * Assembl::get_code()
{
	return a.getCode();
}

int Assembl::get_code_size()
{
	return a.getCodeSize();
}
int Assembl::Assemble(char *cmd,ulong ip,asmmodel *model,char *error)
{
	Assembler a;
	FileLogger logger(stderr);
	a.setLogger(&logger);

	asmerror = NULL;
	//	int oldsize = a.getCodeSize();

	///////////////////注释//////
	char *note = strchr(cmd,';');
	if (note)
		*note = '\0';
	//////////////////判断是否是标签///


	asmcmd = cmd;

	Scanasm(SA_NAME);

	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}
	char name[20];
	strcpy(name,sdata);  //sdata就是指令前缀 比如mov
	strupr(sdata);
	//for (int i = 0;i<575;i++)
	//{
	//	printf("%d:%s\r\n",i,instruction_table[i]);
	//	if (strcmp(instruction_table[i],name) == 0)
	//	{
	//		a._emitInstruction(i);
	//	}
	//}
	char *asmend = asmcmd;
	Scanasm(0);
	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}
	asmoperand aop[3];
	for (int i=0; i<3; i++) {
		aop[i].type=NNN;                   // No operand
		aop[i].size=0;                     // Undefined size
		aop[i].index=-1;                   // No index
		aop[i].scale=0;                    // No scale
		aop[i].base=-1;                    // No base
		aop[i].offset=0;                   // No offset
		aop[i].anyoffset=0;                // No offset
		aop[i].segment=SEG_UNDEF;          // No segment
		aop[i].jmpmode=0;
		aop[i].label = NULL;
		aop[i].mode = 0;
	};               // No jump size modifier
	//	printf("%d",REG_EBX);
	aop[0].mode = scan;
	Parseasmoperand(aop + 0);
	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}

	if (scan==SCAN_SYMB && idata==',') {
		Scanasm(0);
		aop[1].mode = scan;
		if (scan == SCAN_LABEL_BIND)
		{
			return a.getCodeSize();
		}
		Parseasmoperand(aop+1);

		if (scan==SCAN_SYMB && idata==',') {
			Scanasm(0);
			aop[2].mode = scan;
			if (scan == SCAN_LABEL_BIND)
			{
				return a.getCodeSize();
			}
			Parseasmoperand(aop+2);
		};
	};

	if (asmerror)
	{
		strcpy(error,asmerror);
		return -1;
	}

	const Operand *o1 = NULL;
	const Operand *o2 = NULL;
	const Operand *o3 = NULL;

    Operand oo1 = get_operand(aop + 0);
    o1 = &oo1;
	Operand oo2 = get_operand(aop + 1);
	o2 = &oo2;
	Operand oo3 = get_operand(aop + 2);
    o3 = &oo3;

    const char * n = name;
	for (int i = 0;i<575;i++)
	{
		//		printf("%d:%s\r\n",i,instruction_table[i]);
        if (strcmp(instruction_table[i],name) == 0)
		{
			if (aop[0].type == 0)
				a._emitInstruction(i);
			else if (aop[1].type == 0)
				a._emitInstruction(i,o1);
			else if (aop[2].type == 0)
				a._emitInstruction(i,o1,o2);
			else
				a._emitInstruction(i,o1,o2,o2);
			memcpy(model->code,a.getCode(),a.getCodeSize());
			return a.getCodeSize();
		}
	}
	sprintf(error,"错误的汇编指令,没有找到:%s\r\n",name);
	return -1;
}

void Assembl::reloc(unsigned long relocaddr)
{
	a.relocCode((void*)a.getCode(),relocaddr);
}

int Assembl::Assemble(char *cmd)
{
	FileLogger logger(stderr);
	a.setLogger(&logger);

	asmerror = NULL;
//	int oldsize = a.getCodeSize();

	///////////////////注释//////
	char *note = strchr(cmd,';');
	if (note)
		*note = '\0';
    //////////////////判断是否是标签///


	asmcmd = cmd;

    Scanasm(SA_NAME);

	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}
	char name[20];
	strcpy(name,strupr(sdata));  //sdata就是指令前缀 比如mov

	//for (int i = 0;i<575;i++)
	//{
	//	printf("%d:%s\r\n",i,instruction_table[i]);
	//	if (strcmp(instruction_table[i],name) == 0)
	//	{
	//		a._emitInstruction(i);
	//	}
	//}
	char *asmend = asmcmd;
	Scanasm(0);
	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}
	asmoperand aop[3];
	for (int i=0; i<3; i++) {
		aop[i].type=NNN;                   // No operand
		aop[i].size=0;                     // Undefined size
		aop[i].index=-1;                   // No index
		aop[i].scale=0;                    // No scale
		aop[i].base=-1;                    // No base
		aop[i].offset=0;                   // No offset
		aop[i].anyoffset=0;                // No offset
		aop[i].segment=SEG_UNDEF;          // No segment
		aop[i].jmpmode=0;
		aop[i].label = NULL;
		aop[i].mode = 0;
	};               // No jump size modifier
//	printf("%d",REG_EBX);
	aop[0].mode = scan;
	Parseasmoperand(aop + 0);
	if (scan == SCAN_LABEL_BIND)
	{
		return a.getCodeSize();
	}

	if (scan==SCAN_SYMB && idata==',') {
		Scanasm(0);
		aop[1].mode = scan;
		if (scan == SCAN_LABEL_BIND)
		{
			return a.getCodeSize();
		}
		Parseasmoperand(aop+1);

		if (scan==SCAN_SYMB && idata==',') {
			Scanasm(0);
			aop[2].mode = scan;
			if (scan == SCAN_LABEL_BIND)
			{
				return a.getCodeSize();
			}
			Parseasmoperand(aop+2);
		};
	};

	if (asmerror)
	{
		printf(asmerror);
		return -1;
	}

	const Operand *o1 = NULL;
	const Operand *o2 = NULL;
	const Operand *o3 = NULL;

    Operand oo1 = get_operand(aop + 0);
    o1 = &oo1;
	Operand oo2 = get_operand(aop + 1);
	o2 = &oo2;
	Operand oo3 = get_operand(aop + 2);
    o3 = &oo3;
	for (int i = 0;i<575;i++)
	{
//		printf("%d:%s\r\n",i,instruction_table[i]);
		if (strcmp(instruction_table[i],name) == 0)
		{
			if (aop[0].type == 0)
				a._emitInstruction(i);
			else if (aop[1].type == 0)
				a._emitInstruction(i,o1);
		    else if (aop[2].type == 0)
			    a._emitInstruction(i,o1,o2);
		    else
			    a._emitInstruction(i,o1,o2,o2);
			return a.getCodeSize();
		}
	}
	printf("错误的汇编指令,没有找到:%s\r\n",name);
	return -1;
}

```

`AsmJit/Assembler.h`:

```h

#ifndef _ASMJIT_ASSEMBLER_H
#define _ASMJIT_ASSEMBLER_H

#include "Build.h"

namespace AsmJit {

struct Logger;
struct MemoryManager;
struct EInstruction;

}

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
#include "AssemblerX86X64.h"
#endif

#endif // _ASMJIT_ASSEMBLER_H

```

`AsmJit/AssemblerX86X64.cpp`:

```cpp


#if defined(_MSC_VER)
#pragma warning(disable:4312)
#endif

// We are using sprintf() here.
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif // _MSC_VER

// [Dependencies]
#include "Assembler.h"
#include "CodeGenerator.h"
#include "CpuInfo.h"
#include "Defs.h"
#include "Logger.h"
#include "MemoryManager.h"
#include "Platform.h"
#include "Util_p.h"

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

// A little bit C++.
#include <new>

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

#if defined(ASMJIT_X64)

// ============================================================================
// [AsmJit::TrampolineWriter]
// ============================================================================

//! @brief Class used to determine size of trampoline and as trampoline writer.
struct ASMJIT_HIDDEN TrampolineWriter
{
  // Size of trampoline
  enum {
    TRAMPOLINE_JMP = 6,
    TRAMPOLINE_ADDR = sizeof(sysint_t),

    TRAMPOLINE_SIZE = TRAMPOLINE_JMP + TRAMPOLINE_ADDR
  };

  // Write trampoline into code at address @a code that will jump to @a target.
  static void writeTrampoline(uint8_t* code, void* target)
  {
    code[0] = 0xFF;  // Jmp.
    code[1] = 0x25;  // ModM (RIP addressing).
    
    ((uint32_t*)(code + 2))[0] = 0;  // Offset (zero).
    // Absolute address.
    ((sysuint_t*)(code + TRAMPOLINE_JMP))[0] = (sysuint_t)target;
  }
};

#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::AssemblerCore - Construction / Destruction]
// ============================================================================

AssemblerCore::AssemblerCore(CodeGenerator* codeGenerator) :
  _zone(16384 - sizeof(Zone::Chunk) - 32),
  _codeGenerator(codeGenerator != NULL ? codeGenerator : CodeGenerator::getGlobal()),
  _logger(NULL),
  _error(0),
  _properties((1 << PROPERTY_OPTIMIZE_ALIGN)),
  _emitOptions(0),
  _buffer(32), // Max instruction length is 15, but we can align up to 32 bytes.
  _trampolineSize(0),
  _unusedLinks(NULL),
  _comment(NULL)
{
}

AssemblerCore::~AssemblerCore()
{
}

// ============================================================================
// [AsmJit::AssemblerCore - Logging]
// ============================================================================

void AssemblerCore::setLogger(Logger* logger)
{
  _logger = logger;
}

// ============================================================================
// [AsmJit::AssemblerCore - Error Handling]
// ============================================================================

void AssemblerCore::setError(uint32_t error)
{
    _error = error;
    if (_error)
    {
        if (_logger)
        {
            _logger->logFormat("*** ASSEMBLER ERROR: %s (%u).\n",
                getErrorString(error),
                (unsigned int)error);
        }
    }
}

// ============================================================================
// [AsmJit::AssemblerCore - Properties]
// ============================================================================

uint32_t AssemblerCore::getProperty(uint32_t propertyId)
{
  return (_properties & (1 << propertyId)) != 0;
}

void AssemblerCore::setProperty(uint32_t propertyId, uint32_t value)
{
  if (value)
    _properties |= (1 << propertyId);
  else
    _properties &= ~(1 << propertyId);
}

// ============================================================================
// [AsmJit::AssemblerCore - Buffer]
// ============================================================================

void AssemblerCore::clear()
{
  _buffer.clear();
  _relocData.clear();
  _zone.clear();
}

void AssemblerCore::free()
{
  _zone.freeAll();
  _buffer.free();
  _relocData.free();
}

uint8_t* AssemblerCore::takeCode()
{
  uint8_t* code = _buffer.take();
  _relocData.clear();
  _zone.clear();

  return code;
}

// ============================================================================
// [AsmJit::AssemblerCore - Stream Setters / Getters]
// ============================================================================

void AssemblerCore::setVarAt(sysint_t pos, sysint_t i, uint8_t isUnsigned, uint32_t size)
{
  if (size == 1 && !isUnsigned) setByteAt (pos, (int8_t  )i);
  else if (size == 1 &&  isUnsigned) setByteAt (pos, (uint8_t )i);
  else if (size == 2 && !isUnsigned) setWordAt (pos, (int16_t )i);
  else if (size == 2 &&  isUnsigned) setWordAt (pos, (uint16_t)i);
  else if (size == 4 && !isUnsigned) setDWordAt(pos, (int32_t )i);
  else if (size == 4 &&  isUnsigned) setDWordAt(pos, (uint32_t)i);
#if defined(ASMJIT_X64)
  else if (size == 8 && !isUnsigned) setQWordAt(pos, (int64_t )i);
  else if (size == 8 &&  isUnsigned) setQWordAt(pos, (uint64_t)i);
#endif // ASMJIT_X64
  else
    ASMJIT_ASSERT(0);
}

// ============================================================================
// [AsmJit::AssemblerCore - Assembler Emitters]
// ============================================================================

bool AssemblerCore::canEmit()
{
  // If there is an error, we can't emit another instruction until last error
  // is cleared by calling @c setError(ERROR_NONE). If something caused an error
  // while generating code it's probably fatal in all cases. You can't use 
  // generated code, because you are not sure about its status.
  if (_error) return false;

  // The ensureSpace() method returns true on success and false on failure. We
  // are catching return value and setting error code here.
  if (ensureSpace()) return true;

  // If we are here, there is memory allocation error. Note that this is HEAP
  // allocation error, virtual allocation error can be caused only by
  // AsmJit::VirtualMemory class!
  setError(ERROR_NO_HEAP_MEMORY);
  return false;
}

void AssemblerCore::_emitSegmentPrefix(const Operand& rm)
{
  static const uint8_t segmentPrefixCode[6] =
  {
    0x26, // ES
    0x2E, // SS
    0x36, // SS
    0x3E, // DS
    0x64, // FS
    0x65  // GS
  };

  uint32_t segmentPrefix;
  
  if (!rm.isMem())
    return;

  if ((segmentPrefix = reinterpret_cast<const Mem&>(rm).getSegmentPrefix()) >= REG_NUM_SEGMENT)
    return;

  _emitByte(segmentPrefixCode[segmentPrefix]);
}

void AssemblerCore::_emitModM(
  uint8_t opReg, const Mem& mem, sysint_t immSize)
{
  ASMJIT_ASSERT(mem.getType() == OPERAND_MEM);

  uint8_t baseReg = mem.getBase() & 0x7;
  uint8_t indexReg = mem.getIndex() & 0x7;
  sysint_t disp = mem.getDisplacement();
  uint32_t shift = mem.getShift();

  if (mem.getMemType() == OPERAND_MEM_NATIVE)
  {
    // [base + displacemnt]
    if (!mem.hasIndex())
    {
      // ESP/RSP/R12 == 4
      if (baseReg == 4)
      {
        uint8_t mod = 0;

        if (disp)
        {
          mod = Util::isInt8(disp) ? 1 : 2;
        }

        _emitMod(mod, opReg, 4);
        _emitSib(0, 4, 4);

        if (disp)
        {
          if (Util::isInt8(disp))
            _emitByte((int8_t)disp);
          else
            _emitInt32((int32_t)disp);
        }
      }
      // EBP/RBP/R13 == 5
      else if (baseReg != 5 && disp == 0)
      {
        _emitMod(0, opReg, baseReg);
      }
      else if (Util::isInt8(disp))
      {
        _emitMod(1, opReg, baseReg);
        _emitByte((int8_t)disp);
      }
      else
      {
        _emitMod(2, opReg, baseReg);
        _emitInt32((int32_t)disp);
      }
    }

    // [base + index * scale + displacemnt]
    else
    {
      // ASMJIT_ASSERT(indexReg != RID_ESP);

      // EBP/RBP/R13 == 5
      if (baseReg != 5 && disp == 0)
      {
        _emitMod(0, opReg, 4);
        _emitSib(shift, indexReg, baseReg);
      }
      else if (Util::isInt8(disp))
      {
        _emitMod(1, opReg, 4);
        _emitSib(shift, indexReg, baseReg);
        _emitByte((int8_t)disp);
      }
      else
      {
        _emitMod(2, opReg, 4);
        _emitSib(shift, indexReg, baseReg);
        _emitInt32((int32_t)disp);
      }
    }
  }

  // Address                       | 32-bit mode | 64-bit mode
  // ------------------------------+-------------+---------------
  // [displacement]                |   ABSOLUTE  | RELATIVE (RIP)
  // [index * scale + displacemnt] |   ABSOLUTE  | ABSOLUTE (ZERO EXTENDED)
  else
  {
    // - In 32-bit mode the absolute addressing model is used.
    // - In 64-bit mode the relative addressing model is used together with
    //   the absolute addressing. Main problem is that if instruction
    //   contains SIB then relative addressing (RIP) is not possible.

#if defined(ASMJIT_X86)

    if (mem.hasIndex())
    {
      // ASMJIT_ASSERT(mem.getMemIndex() != 4); // ESP/RSP == 4
      _emitMod(0, opReg, 4);
      _emitSib(shift, indexReg, 5);
    }
    else
    {
      _emitMod(0, opReg, 5);
    }

    // X86 uses absolute addressing model, all relative addresses will be
    // relocated to absolute ones.
    if (mem.getMemType() == OPERAND_MEM_LABEL)
    {
      LabelData& l_data = _labelData[mem._mem.base & OPERAND_ID_VALUE_MASK];
      RelocData r_data;
      uint32_t relocId = _relocData.getLength();

      // Relative addressing will be relocated to absolute address.
      r_data.type = RelocData::RELATIVE_TO_ABSOLUTE;
      r_data.size = 4;
      r_data.offset = getOffset();
      r_data.destination = disp;

      if (l_data.offset != -1)
      {
        // Bound label.
        r_data.destination += l_data.offset;

        // Add a dummy DWORD.
        _emitInt32(0);
      }
      else
      {
        // Non-bound label.
        _emitDisplacement(l_data, -4 - immSize, 4)->relocId = relocId;
      }

      _relocData.append(r_data);
    }
    else
    {
      // Absolute address
      _emitInt32( (int32_t)((uint8_t*)mem._mem.target + disp) );
    }

#else

    // X64 uses relative addressing model
    if (mem.getMemType() == OPERAND_MEM_LABEL)
    {
      LabelData& l_data = _labelData[mem._mem.base & OPERAND_ID_VALUE_MASK];

      if (mem.hasIndex())
      {
        // Indexing is not possible.
        setError(ERROR_ILLEGAL_ADDRESING);
        return;
      }

      // Relative address (RIP +/- displacement).
      _emitMod(0, opReg, 5);

      disp -= (4 + immSize);

      if (l_data.offset != -1)
      {
        // Bound label.
        disp += getOffset() - l_data.offset;

        // Displacement is known.
        _emitInt32((int32_t)disp);
      }
      else
      {
        // Non-bound label.
        _emitDisplacement(l_data, disp, 4);
      }
    }
    else
    {
      // Absolute address (truncated to 32-bits), this kind of address requires
      // SIB byte (4).
      _emitMod(0, opReg, 4);

      if (mem.hasIndex())
      {
        // ASMJIT_ASSERT(mem.getMemIndex() != 4); // ESP/RSP == 4
        _emitSib(shift, indexReg, 5);
      }
      else
      {
        _emitSib(0, 4, 5);
      }

      // Truncate to 32-bits.
      sysuint_t target = (sysuint_t)((uint8_t*)mem._mem.target + disp);

      if (target > (sysuint_t)0xFFFFFFFF)
      {
        if (_logger) 
        {
          _logger->logString("*** ASSEMBER WARNING - Absolute address truncated to 32-bits.\n");
        }
        target &= 0xFFFFFFFF;
      }

      _emitInt32( (int32_t)((uint32_t)target) );
    }

#endif // ASMJIT_X64

  }
}

void AssemblerCore::_emitModRM(
  uint8_t opReg, const Operand& op, sysint_t immSize)
{
  ASMJIT_ASSERT(op.getType() == OPERAND_REG || op.getType() == OPERAND_MEM);

  if (op.getType() == OPERAND_REG)
    _emitModR(opReg, reinterpret_cast<const BaseReg&>(op).getRegCode());
  else
    _emitModM(opReg, reinterpret_cast<const Mem&>(op), immSize);
}

void AssemblerCore::_emitX86Inl(
  uint32_t opCode, uint8_t i16bit, uint8_t rexw, uint8_t reg, bool forceRexPrefix)
{
  // 16-bit prefix.
  if (i16bit) _emitByte(0x66);

  // Instruction prefix.
  if (opCode & 0xFF000000) _emitByte((uint8_t)((opCode & 0xFF000000) >> 24));

  // REX prefix.
#if defined(ASMJIT_X64)
  _emitRexR(rexw, 0, reg, forceRexPrefix);
#endif // ASMJIT_X64

  // Instruction opcodes.
  if (opCode & 0x00FF0000) _emitByte((uint8_t)((opCode & 0x00FF0000) >> 16));
  if (opCode & 0x0000FF00) _emitByte((uint8_t)((opCode & 0x0000FF00) >>  8));

  _emitByte((uint8_t)(opCode & 0x000000FF) + (reg & 0x7));
}

void AssemblerCore::_emitX86RM(
  uint32_t opCode, uint8_t i16bit, uint8_t rexw, uint8_t o,
  const Operand& op, sysint_t immSize, bool forceRexPrefix)
{
  // 16-bit prefix.
  if (i16bit) _emitByte(0x66);

  // Segment prefix.
  _emitSegmentPrefix(op);

  // Instruction prefix.
  if (opCode & 0xFF000000) _emitByte((uint8_t)((opCode & 0xFF000000) >> 24));

  // REX prefix.
#if defined(ASMJIT_X64)
  _emitRexRM(rexw, o, op, forceRexPrefix);
#endif // ASMJIT_X64

  // Instruction opcodes.
  if (opCode & 0x00FF0000) _emitByte((uint8_t)((opCode & 0x00FF0000) >> 16));
  if (opCode & 0x0000FF00) _emitByte((uint8_t)((opCode & 0x0000FF00) >>  8));
  _emitByte((uint8_t)(opCode & 0x000000FF));

  // Mod R/M.
  _emitModRM(o, op, immSize);
}

void AssemblerCore::_emitFpu(uint32_t opCode)
{
  _emitOpCode(opCode);
}

void AssemblerCore::_emitFpuSTI(uint32_t opCode, uint32_t sti)
{
  // Illegal stack offset.
  ASMJIT_ASSERT(0 <= sti && sti < 8);
  _emitOpCode(opCode + sti);
}

void AssemblerCore::_emitFpuMEM(uint32_t opCode, uint8_t opReg, const Mem& mem)
{
  // Segment prefix.
  _emitSegmentPrefix(mem);

  // Instruction prefix.
  if (opCode & 0xFF000000) _emitByte((uint8_t)((opCode & 0xFF000000) >> 24));

  // REX prefix.
#if defined(ASMJIT_X64)
  _emitRexRM(0, opReg, mem, false);
#endif // ASMJIT_X64

  // Instruction opcodes.
  if (opCode & 0x00FF0000) _emitByte((uint8_t)((opCode & 0x00FF0000) >> 16));
  if (opCode & 0x0000FF00) _emitByte((uint8_t)((opCode & 0x0000FF00) >>  8));

  _emitByte((uint8_t)((opCode & 0x000000FF)));
  _emitModM(opReg, mem, 0);
}

void AssemblerCore::_emitMmu(uint32_t opCode, uint8_t rexw, uint8_t opReg,
  const Operand& src, sysint_t immSize)
{
  // Segment prefix.
  _emitSegmentPrefix(src);

  // Instruction prefix.
  if (opCode & 0xFF000000) _emitByte((uint8_t)((opCode & 0xFF000000) >> 24));

  // REX prefix.
#if defined(ASMJIT_X64)
  _emitRexRM(rexw, opReg, src, false);
#endif // ASMJIT_X64

  // Instruction opcodes.
  if (opCode & 0x00FF0000) _emitByte((uint8_t)((opCode & 0x00FF0000) >> 16));

  // No checking, MMX/SSE instructions have always two opcodes or more.
  _emitByte((uint8_t)((opCode & 0x0000FF00) >> 8));
  _emitByte((uint8_t)((opCode & 0x000000FF)));

  if (src.isReg())
    _emitModR(opReg, reinterpret_cast<const BaseReg&>(src).getRegCode());
  else
    _emitModM(opReg, reinterpret_cast<const Mem&>(src), immSize);
}

AssemblerCore::LabelLink* AssemblerCore::_emitDisplacement(
  LabelData& l_data, sysint_t inlinedDisplacement, int size)
{
  ASMJIT_ASSERT(l_data.offset == -1);
  ASMJIT_ASSERT(size == 1 || size == 4);

  // Chain with label.
  LabelLink* link = _newLabelLink();
  link->prev = l_data.links;
  link->offset = getOffset();
  link->displacement = inlinedDisplacement;

  l_data.links = link;

  // Emit label size as dummy data.
  if (size == 1)
    _emitByte(0x01);
  else // if (size == 4)
    _emitDWord(0x04040404);

  return link;
}

void AssemblerCore::_emitJmpOrCallReloc(uint32_t instruction, void* target)
{
  RelocData rd;

  rd.type = RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE;

#if defined(ASMJIT_X64)
  // If we are compiling in 64-bit mode, we can use trampoline if relative jump
  // is not possible.
  _trampolineSize += TrampolineWriter::TRAMPOLINE_SIZE;
#endif // ARCHITECTURE_SPECIFIC

  rd.size = 4;
  rd.offset = getOffset();
  rd.address = target;

  _relocData.append(rd);

  // Emit dummy 32-bit integer (will be overwritten by relocCode()).
  _emitInt32(0);
}

// Logging helpers.
static const char* operandSize[] =
{
  NULL,
  "byte ptr ",
  "word ptr ",
  NULL,
  "dword ptr ",
  NULL,
  NULL,
  NULL,
  "qword ptr ",
  NULL,
  "tword ptr ",
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  "dqword ptr "
};

static const char segmentPrefixName[] =
  "es:\0"
  "cs:\0"
  "ss:\0"
  "ds:\0"
  "fs:\0"
  "gs:\0"
  "\0\0\0\0";

ASMJIT_HIDDEN char* dumpInstructionName(char* buf, uint32_t code)
{
  ASMJIT_ASSERT(code < _INST_COUNT);
  return Util::mycpy(buf, instructionDescription[code].getName());
}

ASMJIT_HIDDEN char* dumpRegister(char* buf, uint32_t type, uint32_t index)
{
  // NE == Not-Encodable.
  const char reg8l[] = "al\0\0" "cl\0\0" "dl\0\0" "bl\0\0" "spl\0"  "bpl\0"  "sil\0"  "dil\0" ;
  const char reg8h[] = "ah\0\0" "ch\0\0" "dh\0\0" "bh\0\0" "NE\0\0" "NE\0\0" "NE\0\0" "NE\0\0";
  const char reg16[] = "ax\0\0" "cx\0\0" "dx\0\0" "bx\0\0" "sp\0\0" "bp\0\0" "si\0\0" "di\0\0";

  switch (type)
  {
    case REG_TYPE_GPB_LO:
      if (index < 8)
        return Util::mycpy(buf, &reg8l[index*4]);

      *buf++ = 'r';
      goto _EmitID;

    case REG_TYPE_GPB_HI:
      if (index < 4)
        return Util::mycpy(buf, &reg8h[index*4]);

_EmitNE:
      return Util::mycpy(buf, "NE");

    case REG_TYPE_GPW:
      if (index < 8)
        return Util::mycpy(buf, &reg16[index*4]);

      *buf++ = 'r';
      buf = Util::myutoa(buf, index);
      *buf++ = 'w';
      return buf;

    case REG_TYPE_GPD:
      if (index < 8)
      {
        *buf++ = 'e';
        return Util::mycpy(buf, &reg16[index*4]);
      }

      *buf++ = 'r';
      buf = Util::myutoa(buf, index);
      *buf++ = 'd';
      return buf;
    
    case REG_TYPE_GPQ:
      *buf++ = 'r';

      if (index < 8)
        return Util::mycpy(buf, &reg16[index*4]);

_EmitID:
      return Util::myutoa(buf, index);
    
    case REG_TYPE_X87:
      *buf++ = 's';
      *buf++ = 't';
      goto _EmitID;
    
    case REG_TYPE_MM:
      *buf++ = 'm';
      *buf++ = 'm';
      goto _EmitID;
    
    case REG_TYPE_XMM:
      *buf++ = 'x';
      *buf++ = 'm';
      *buf++ = 'm';
      goto _EmitID;
    
    case REG_TYPE_YMM:
      *buf++ = 'y';
      *buf++ = 'm';
      *buf++ = 'm';
      goto _EmitID;

    case REG_TYPE_SEGMENT:
      if (index < REG_NUM_SEGMENT)
        return Util::mycpy(buf, &segmentPrefixName[index*4], 2);
      
      goto _EmitNE;

    default:
      return buf;
  }
}

ASMJIT_HIDDEN char* dumpOperand(char* buf, const Operand* op, uint32_t memRegType)
{
  if (op->isReg())
  {
    const BaseReg& reg = reinterpret_cast<const BaseReg&>(*op);
    return dumpRegister(buf, reg.getRegType(), reg.getRegIndex());
  }
  else if (op->isMem())
  {
    const Mem& mem = reinterpret_cast<const Mem&>(*op);
    uint32_t segmentPrefix = mem.getSegmentPrefix();

    bool isAbsolute = false;

    if (op->getSize() <= 16)
    {
      buf = Util::mycpy(buf, operandSize[op->getSize()]);
    }

    if (segmentPrefix < REG_NUM_SEGMENT)
    {
      buf = Util::mycpy(buf, &segmentPrefixName[segmentPrefix * 4]);
    }

    *buf++ = '[';

    switch (mem.getMemType())
    {
      case OPERAND_MEM_NATIVE:
      {
        // [base + index*scale + displacement]
        buf = dumpRegister(buf, memRegType, mem.getBase());
        break;
      }
      case OPERAND_MEM_LABEL:
      {
        // [label + index*scale + displacement]
        buf += sprintf(buf, "L.%u", mem.getBase() & OPERAND_ID_VALUE_MASK);
        break;
      }
      case OPERAND_MEM_ABSOLUTE:
      {
        // [absolute]
        isAbsolute = true;
        buf = Util::myutoa(buf, (sysuint_t)mem.getTarget() + mem.getDisplacement(), 16);
        break;
      }
    }

    if (mem.hasIndex())
    {
      buf = Util::mycpy(buf, " + ");
      buf = dumpRegister(buf, memRegType, mem.getIndex());

      if (mem.getShift())
      {
        buf = Util::mycpy(buf, " * ");
        *buf++ = "1248"[mem.getShift() & 3];
      }
    }

    if (mem.getDisplacement() && !isAbsolute)
    {
      sysint_t d = mem.getDisplacement();
      *buf++ = ' ';
      *buf++ = (d < 0) ? '-' : '+';
      *buf++ = ' ';
      buf = Util::myutoa(buf, d < 0 ? -d : d);
    }

    *buf++ = ']';
    return buf;
  }
  else if (op->isImm())
  {
    const Imm& i = reinterpret_cast<const Imm&>(*op);
    return Util::myitoa(buf, (sysint_t)i.getValue());
  }
  else if (op->isLabel())
  {
    return buf + sprintf(buf, "L.%u", op->getId() & OPERAND_ID_VALUE_MASK);
  }
  else
  {
    return Util::mycpy(buf, "None");
  }
}

static char* dumpInstruction(char* buf,
  uint32_t code,
  uint32_t emitOptions,
  const Operand* o0,
  const Operand* o1,
  const Operand* o2,
  uint32_t memRegType)
{
  if (emitOptions & EMIT_OPTION_REX_PREFIX ) buf = Util::mycpy(buf, "rex ", 4);
  if (emitOptions & EMIT_OPTION_LOCK_PREFIX) buf = Util::mycpy(buf, "lock ", 5);
  if (emitOptions & EMIT_OPTION_SHORT_JUMP ) buf = Util::mycpy(buf, "short ", 6);

  // Dump instruction.
  buf = dumpInstructionName(buf, code);

  // Dump operands.
  if (!o0->isNone()) { *buf++ = ' '; buf = dumpOperand(buf, o0, memRegType); }
  if (!o1->isNone()) { *buf++ = ','; *buf++ = ' '; buf = dumpOperand(buf, o1, memRegType); }
  if (!o2->isNone()) { *buf++ = ','; *buf++ = ' '; buf = dumpOperand(buf, o2, memRegType); }

  return buf;
}

static char* dumpComment(char* buf, sysuint_t len, const uint8_t* binaryData, sysuint_t binaryLen, const char* comment)
{
  sysuint_t currentLength = len;
  sysuint_t commentLength = comment ? (sysuint_t)strlen(comment) : 0;

  if (binaryLen || commentLength)
  {
    sysuint_t align = 32;
    char sep = ';';

    // Truncate if comment is too long (it shouldn't be, larger than 80 seems to
    // be an exploit).
    if (commentLength > 80) commentLength = 80;

    for (sysuint_t i = (binaryLen == 0); i < 2; i++)
    {
      char* bufBegin = buf;

      // Append align.
      if (currentLength < align) 
      {
        buf = Util::myfill(buf, ' ', align - currentLength);
      }

      // Append separator.
      if (sep)
      {
        *buf++ = sep;
        *buf++ = ' ';
      }

      // Append binary data or comment.
      if (i == 0)
      {
        buf = Util::myhex(buf, binaryData, binaryLen);
        if (commentLength == 0) break;
      }
      else
      {
        buf = Util::mycpy(buf, comment, commentLength);
      }

      currentLength += (sysuint_t)(buf - bufBegin);
      align += 18;
      sep = '|';
    }
  }

  *buf++ = '\n';
  return buf;
}

// Used for NULL operands to translate them to OPERAND_NONE.
static const uint8_t _none[sizeof(Operand)] =
{
  0
};

static const Operand::RegData _patchedHiRegs[4] =
{// op         , size, { reserved0, reserved1 }, id           , code
  { OPERAND_REG, 1   , { 0        , 0         }, INVALID_VALUE, REG_TYPE_GPB_LO | 4 },
  { OPERAND_REG, 1   , { 0        , 0         }, INVALID_VALUE, REG_TYPE_GPB_LO | 5 },
  { OPERAND_REG, 1   , { 0        , 0         }, INVALID_VALUE, REG_TYPE_GPB_LO | 6 },
  { OPERAND_REG, 1   , { 0        , 0         }, INVALID_VALUE, REG_TYPE_GPB_LO | 7 }
};

void AssemblerCore::_emitInstruction(uint32_t code)
{
  _emitInstruction(code, NULL, NULL, NULL);
}

void AssemblerCore::_emitInstruction(uint32_t code, const Operand* o0)
{
  _emitInstruction(code, o0, NULL, NULL);
}

void AssemblerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1)
{
  _emitInstruction(code, o0, o1, NULL);
}

void AssemblerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2)
{
  const Operand* _loggerOperands[3];

  uint32_t bLoHiUsed = 0;
#if defined(ASMJIT_X86)
  uint32_t forceRexPrefix = false;
#else
  uint32_t forceRexPrefix = _emitOptions & EMIT_OPTION_REX_PREFIX;
#endif
  uint32_t memRegType = REG_TYPE_GPN;

#if defined(ASMJIT_DEBUG)
  bool assertIllegal = false;
#endif // ASMJIT_DEBUG

  const Imm* immOperand = NULL;
  uint32_t immSize;

#define _FINISHED() \
  goto end

#define _FINISHED_IMMEDIATE(_Operand_, _Size_) \
  do { \
    immOperand = reinterpret_cast<const Imm*>(_Operand_); \
    immSize = (_Size_); \
    goto emitImmediate; \
  } while (0)

  // Convert operands to OPERAND_NONE if needed.
  if (o0 == NULL) { o0 = reinterpret_cast<const Operand*>(_none); } else if (o0->isReg()) { bLoHiUsed |= o0->_reg.code & (REG_TYPE_GPB_LO | REG_TYPE_GPB_HI); }
  if (o1 == NULL) { o1 = reinterpret_cast<const Operand*>(_none); } else if (o1->isReg()) { bLoHiUsed |= o1->_reg.code & (REG_TYPE_GPB_LO | REG_TYPE_GPB_HI); }
  if (o2 == NULL) { o2 = reinterpret_cast<const Operand*>(_none); } else if (o2->isReg()) { bLoHiUsed |= o2->_reg.code & (REG_TYPE_GPB_LO | REG_TYPE_GPB_HI); }

  sysuint_t beginOffset = getOffset();
  const InstructionDescription* id = &instructionDescription[code];

  if (code >= _INST_COUNT)
  {
    setError(ERROR_UNKNOWN_INSTRUCTION);
    goto cleanup;
  }

  // Check if register operand is BPL, SPL, SIL, DIL and do action that depends
  // to current mode:
  //   - 64-bit: - Force REX prefix.
  //
  // Check if register operand is AH, BH, CH or DH and do action that depends
  // to current mode:
  //   - 32-bit: - Patch operand index (index += 4), because we are using
  //               different index what is used in opcode.
  //   - 64-bit: - Check whether there is REX prefix and raise error if it is.
  //             - Do the same as in 32-bit mode - patch register index.
  //
  // NOTE: This is a hit hacky, but I added this to older code-base and I have
  // no energy to rewrite it. Maybe in future all of this can be cleaned up!
  if (bLoHiUsed | forceRexPrefix)
  {
    _loggerOperands[0] = o0;
    _loggerOperands[1] = o1;
    _loggerOperands[2] = o2;

#if defined(ASMJIT_X64)
    // Check if there is register that makes this instruction un-encodable.

    forceRexPrefix |= (uint32_t)o0->isExtendedRegisterUsed();
    forceRexPrefix |= (uint32_t)o1->isExtendedRegisterUsed();
    forceRexPrefix |= (uint32_t)o2->isExtendedRegisterUsed();

    if      (o0->isRegType(REG_TYPE_GPB_LO) && (o0->_reg.code & REG_INDEX_MASK) >= 4) forceRexPrefix = true;
    else if (o1->isRegType(REG_TYPE_GPB_LO) && (o1->_reg.code & REG_INDEX_MASK) >= 4) forceRexPrefix = true;
    else if (o2->isRegType(REG_TYPE_GPB_LO) && (o2->_reg.code & REG_INDEX_MASK) >= 4) forceRexPrefix = true;

    if ((bLoHiUsed & REG_TYPE_GPB_HI) != 0 && forceRexPrefix)
    {
      goto illegalInstruction;
    }
#endif // ASMJIT_X64

    // Patch GPB.HI operand index.
    if ((bLoHiUsed & REG_TYPE_GPB_HI) != 0)
    {
      if (o0->isRegType(REG_TYPE_GPB_HI)) o0 = reinterpret_cast<const Operand*>(&_patchedHiRegs[o0->_reg.code & REG_INDEX_MASK]);
      if (o1->isRegType(REG_TYPE_GPB_HI)) o1 = reinterpret_cast<const Operand*>(&_patchedHiRegs[o1->_reg.code & REG_INDEX_MASK]);
      if (o2->isRegType(REG_TYPE_GPB_HI)) o2 = reinterpret_cast<const Operand*>(&_patchedHiRegs[o2->_reg.code & REG_INDEX_MASK]);
    }
  }

  // Check for buffer space (and grow if needed).
  if (!canEmit()) goto cleanup;

  if (_emitOptions & EMIT_OPTION_LOCK_PREFIX)
  {
    if (!id->isLockable())
      goto illegalInstruction;
    _emitByte(0xF0);
  }

  switch (id->group)
  {
    case InstructionDescription::G_EMIT:
    {
      _emitOpCode(id->opCode[0]);
      _FINISHED();
    }

    case InstructionDescription::G_ALU:
    {
      uint32_t opCode = id->opCode[0];
      uint8_t opReg = (uint8_t)id->opCodeR;

      // Mem <- Reg
      if (o0->isMem() && o1->isReg())
      {
        _emitX86RM(opCode + (o1->getSize() != 1),
          o1->getSize() == 2,
          o1->getSize() == 8,
          reinterpret_cast<const GPReg&>(*o1).getRegCode(),
          reinterpret_cast<const Operand&>(*o0),
          0, forceRexPrefix);
        _FINISHED();
      }

      // Reg <- Reg|Mem
      if (o0->isReg() && o1->isRegMem())
      {
        _emitX86RM(opCode + 2 + (o0->getSize() != 1),
          o0->getSize() == 2,
          o0->getSize() == 8,
          reinterpret_cast<const GPReg&>(*o0).getRegCode(),
          reinterpret_cast<const Operand&>(*o1),
          0, forceRexPrefix);
        _FINISHED();
      }

      // AL, AX, EAX, RAX register shortcuts
      if (o0->isRegIndex(0) && o1->isImm())
      {
        if (o0->getSize() == 2)
          _emitByte(0x66); // 16-bit.
        else if (o0->getSize() == 8)
          _emitByte(0x48); // REX.W.

        _emitByte((opReg << 3) | (0x04 + (o0->getSize() != 1)));
        _FINISHED_IMMEDIATE(o1, o0->getSize() <= 4 ? o0->getSize() : 4);
      }

      if (o0->isRegMem() && o1->isImm())
      {
        const Imm& imm = reinterpret_cast<const Imm&>(*o1);
        immSize = Util::isInt8(imm.getValue()) ? 1 : (o0->getSize() <= 4 ? o0->getSize() : 4);

        _emitX86RM(id->opCode[1] + (o0->getSize() != 1 ? (immSize != 1 ? 1 : 3) : 0),
          o0->getSize() == 2,
          o0->getSize() == 8,
          opReg, reinterpret_cast<const Operand&>(*o0),
          immSize, forceRexPrefix);
        _FINISHED_IMMEDIATE(&imm, immSize);
      }

      break;
    }

    case InstructionDescription::G_BSWAP:
    {
      if (o0->isReg())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);

#if defined(ASMJIT_X64)
        _emitRexR(dst.getRegType() == REG_TYPE_GPQ, 1, dst.getRegCode(), forceRexPrefix);
#endif // ASMJIT_X64
        _emitByte(0x0F);
        _emitModR(1, dst.getRegCode());
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_BT:
    {
      if (o0->isRegMem() && o1->isReg())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        const GPReg& src = reinterpret_cast<const GPReg&>(*o1);

        _emitX86RM(id->opCode[0],
          src.isRegType(REG_TYPE_GPW),
          src.isRegType(REG_TYPE_GPQ),
          src.getRegCode(),
          dst,
          0, forceRexPrefix);
        _FINISHED();
      }

      if (o0->isRegMem() && o1->isImm())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        const Imm& src = reinterpret_cast<const Imm&>(*o1);

        _emitX86RM(id->opCode[1],
          dst.getSize() == 2,
          dst.getSize() == 8,
          (uint8_t)id->opCodeR,
          dst,
          1, forceRexPrefix);
        _FINISHED_IMMEDIATE(o1, 1);
      }

      break;
    }

    case InstructionDescription::G_CALL:
    {
      if (o0->isRegTypeMem(REG_TYPE_GPN))
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        _emitX86RM(0xFF,
          0,
          0, 2, dst,
          0, forceRexPrefix);
        _FINISHED();
      }

      if (o0->isImm())
      {
        const Imm& imm = reinterpret_cast<const Imm&>(*o0);
        _emitByte(0xE8);
        _emitJmpOrCallReloc(InstructionDescription::G_CALL, (void*)imm.getValue());
        _FINISHED();
      }

      if (o0->isLabel())
      {
        LabelData& l_data = _labelData[reinterpret_cast<const Label*>(o0)->getId() & OPERAND_ID_VALUE_MASK];

        if (l_data.offset != -1)
        {
          // Bound label.
          static const sysint_t rel32_size = 5;
          sysint_t offs = l_data.offset - getOffset();

          ASMJIT_ASSERT(offs <= 0);

          _emitByte(0xE8);
          _emitInt32((int32_t)(offs - rel32_size));
        }
        else
        {
          // Non-bound label.
          _emitByte(0xE8);
          _emitDisplacement(l_data, -4, 4);
        }
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_CRC32:
    {
      if (o0->isReg() && o1->isRegMem())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Operand& src = reinterpret_cast<const Operand&>(*o1);
        ASMJIT_ASSERT(dst.getRegType() == REG_TYPE_GPD || dst.getRegType() == REG_TYPE_GPQ);

        _emitX86RM(id->opCode[0] + (src.getSize() != 1),
          src.getSize() == 2,
          dst.getRegType() == 8, dst.getRegCode(), src,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_ENTER:
    {
      if (o0->isImm() && o1->isImm())
      {
        _emitByte(0xC8);
        _emitWord((uint16_t)(sysuint_t)reinterpret_cast<const Imm&>(*o2).getValue());
        _emitByte((uint8_t )(sysuint_t)reinterpret_cast<const Imm&>(*o1).getValue());
        _FINISHED();
      }
      break;
    }

    case InstructionDescription::G_IMUL:
    {
      // 1 operand
      if (o0->isRegMem() && o1->isNone() && o2->isNone())
      {
        const Operand& src = reinterpret_cast<const Operand&>(*o0);
        _emitX86RM(0xF6 + (src.getSize() != 1),
          src.getSize() == 2,
          src.getSize() == 8, 5, src,
          0, forceRexPrefix);
        _FINISHED();
      }
      // 2 operands
      else if (o0->isReg() && !o1->isNone() && o2->isNone())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        ASMJIT_ASSERT(!dst.isRegType(REG_TYPE_GPW));

        if (o1->isRegMem())
        {
          const Operand& src = reinterpret_cast<const Operand&>(*o1);

          _emitX86RM(0x0FAF,
            dst.isRegType(REG_TYPE_GPW),
            dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), src,
            0, forceRexPrefix);
          _FINISHED();
        }
        else if (o1->isImm())
        {
          const Imm& imm = reinterpret_cast<const Imm&>(*o1);

          if (Util::isInt8(imm.getValue()))
          {
            _emitX86RM(0x6B,
              dst.isRegType(REG_TYPE_GPW),
              dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), dst,
              1, forceRexPrefix);
            _FINISHED_IMMEDIATE(&imm, 1);
          }
          else
          {
            immSize = dst.isRegType(REG_TYPE_GPW) ? 2 : 4;
            _emitX86RM(0x69,
              dst.isRegType(REG_TYPE_GPW),
              dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), dst,
              immSize, forceRexPrefix);
            _FINISHED_IMMEDIATE(&imm, immSize);
          }
        }
      }
      // 3 operands
      else if (o0->isReg() && o1->isRegMem() && o2->isImm())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Operand& src = reinterpret_cast<const Operand&>(*o1);
        const Imm& imm = reinterpret_cast<const Imm&>(*o2);

        if (Util::isInt8(imm.getValue()))
        {
          _emitX86RM(0x6B,
            dst.isRegType(REG_TYPE_GPW),
            dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), src,
            1, forceRexPrefix);
          _FINISHED_IMMEDIATE(&imm, 1);
        }
        else
        {
          immSize = dst.isRegType(REG_TYPE_GPW) ? 2 : 4;
          _emitX86RM(0x69,
            dst.isRegType(REG_TYPE_GPW),
            dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), src,
            immSize, forceRexPrefix);
          _FINISHED_IMMEDIATE(&imm, immSize);
        }
      }

      break;
    }

    case InstructionDescription::G_INC_DEC:
    {
      if (o0->isRegMem())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);

        // INC [r16|r32] in 64-bit mode is not encodable.
#if defined(ASMJIT_X86)
        if ((dst.isReg()) && (dst.isRegType(REG_TYPE_GPW) || dst.isRegType(REG_TYPE_GPD)))
        {
          _emitX86Inl(id->opCode[0],
            dst.isRegType(REG_TYPE_GPW),
            0, reinterpret_cast<const BaseReg&>(dst).getRegCode(),
            false);
          _FINISHED();
        }
#endif // ASMJIT_X86

        _emitX86RM(id->opCode[1] + (dst.getSize() != 1),
          dst.getSize() == 2,
          dst.getSize() == 8, (uint8_t)id->opCodeR, dst,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_J:
    {
      if (o0->isLabel())
      {
        LabelData& l_data = _labelData[reinterpret_cast<const Label*>(o0)->getId() & OPERAND_ID_VALUE_MASK];

        uint32_t hint = (uint32_t)(o1->isImm() ? reinterpret_cast<const Imm&>(*o1).getValue() : 0);
        bool isShortJump = (_emitOptions & EMIT_OPTION_SHORT_JUMP) != 0;

        // Emit jump hint if configured for that.
        if ((hint & (HINT_TAKEN | HINT_NOT_TAKEN)) && (_properties & (1 << PROPERTY_JUMP_HINTS)))
        {
          if (hint & HINT_TAKEN)
            _emitByte(HINT_BYTE_VALUE_TAKEN);
          else if (hint & HINT_NOT_TAKEN)
            _emitByte(HINT_BYTE_VALUE_NOT_TAKEN);
        }

        if (l_data.offset != -1)
        {
          // Bound label.
          static const sysint_t rel8_size = 2;
          static const sysint_t rel32_size = 6;
          sysint_t offs = l_data.offset - getOffset();

          ASMJIT_ASSERT(offs <= 0);

          if (Util::isInt8(offs - rel8_size))
          {
            _emitByte(0x70 | (uint8_t)id->opCode[0]);
            _emitByte((uint8_t)(int8_t)(offs - rel8_size));

            // Change the emit options so logger can log instruction correctly.
            _emitOptions |= EMIT_OPTION_SHORT_JUMP;
          }
          else
          {
            if (isShortJump && _logger)
            {
              _logger->logString("*** ASSEMBLER WARNING: Emitting long conditional jump, but short jump instruction forced!\n");
              _emitOptions &= ~EMIT_OPTION_SHORT_JUMP;
            }

            _emitByte(0x0F);
            _emitByte(0x80 | (uint8_t)id->opCode[0]);
            _emitInt32((int32_t)(offs - rel32_size));
          }
        }
        else
        {
          // Non-bound label.
          if (isShortJump)
          {
            _emitByte(0x70 | (uint8_t)id->opCode[0]);
            _emitDisplacement(l_data, -1, 1);
          }
          else
          {
            _emitByte(0x0F);
            _emitByte(0x80 | (uint8_t)id->opCode[0]);
            _emitDisplacement(l_data, -4, 4);
          }
        }
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_JMP:
    {
      if (o0->isRegMem())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);

        _emitX86RM(0xFF,
          0,
          0, 4, dst,
          0, forceRexPrefix);
        _FINISHED();
      }

      if (o0->isImm())
      {
        const Imm& imm = reinterpret_cast<const Imm&>(*o0);
        _emitByte(0xE9);
        _emitJmpOrCallReloc(InstructionDescription::G_JMP, (void*)imm.getValue());
        _FINISHED();
      }

      if (o0->isLabel())
      {
        LabelData& l_data = _labelData[reinterpret_cast<const Label*>(o0)->getId() & OPERAND_ID_VALUE_MASK];
        bool isShortJump = (_emitOptions & EMIT_OPTION_SHORT_JUMP) != 0;

        if (l_data.offset != -1)
        {
          // Bound label.
          const sysint_t rel8_size = 2;
          const sysint_t rel32_size = 5;
          sysint_t offs = l_data.offset - getOffset();

          if (Util::isInt8(offs - rel8_size))
          {
            _emitByte(0xEB);
            _emitByte((uint8_t)(int8_t)(offs - rel8_size));

            // Change the emit options so logger can log instruction correctly.
            _emitOptions |= EMIT_OPTION_SHORT_JUMP;
          }
          else
          {
            if (isShortJump)
            {
              if (_logger)
              {
                _logger->logString("*** ASSEMBLER WARNING: Emitting long jump, but short jump instruction forced!\n");
                _emitOptions &= ~EMIT_OPTION_SHORT_JUMP;
              }
            }

            _emitByte(0xE9);
            _emitInt32((int32_t)(offs - rel32_size));
          }
        }
        else
        {
          // Non-bound label.
          if (isShortJump)
          {
            _emitByte(0xEB);
            _emitDisplacement(l_data, -1, 1);
          }
          else
          {
            _emitByte(0xE9);
            _emitDisplacement(l_data, -4, 4);
          }
        }
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_LEA:
    {
      if (o0->isReg() && o1->isMem())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Mem& src = reinterpret_cast<const Mem&>(*o1);

        // Size override prefix support.
        if (src.getSizePrefix())
        {
          _emitByte(0x67);
#if defined(ASMJIT_X86)
          memRegType = REG_TYPE_GPW;
#else
          memRegType = REG_TYPE_GPD;
#endif
        }

        _emitX86RM(0x8D,
          dst.isRegType(REG_TYPE_GPW),
          dst.isRegType(REG_TYPE_GPQ), dst.getRegCode(), src,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_M:
    {
      if (o0->isMem())
      {
        _emitX86RM(id->opCode[0], 0, (uint8_t)id->opCode[1], (uint8_t)id->opCodeR, reinterpret_cast<const Mem&>(*o0), 0, forceRexPrefix);
        _FINISHED();
      }
      break;
    }

    case InstructionDescription::G_MOV:
    {
      const Operand& dst = *o0;
      const Operand& src = *o1;

      switch (dst.getType() << 4 | src.getType())
      {
        // Reg <- Reg/Mem
        case (OPERAND_REG << 4) | OPERAND_REG:
        {
          // Reg <- Sreg
          if (src.isRegType(REG_TYPE_SEGMENT))
          {
            ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPW) ||
                          dst.isRegType(REG_TYPE_GPD) ||
                          dst.isRegType(REG_TYPE_GPQ) );

            _emitX86RM(0x8C,
              dst.getSize() == 2,
              dst.getSize() == 8,
              reinterpret_cast<const SegmentReg&>(src).getRegCode(),
              reinterpret_cast<const Operand&>(dst),
              0, forceRexPrefix);
            _FINISHED();
          }

          // Sreg <- Reg/Mem
          if (dst.isRegType(REG_TYPE_SEGMENT))
          {
            ASMJIT_ASSERT(src.isRegType(REG_TYPE_GPW   ) ||
                          src.isRegType(REG_TYPE_GPD   ) ||
                          src.isRegType(REG_TYPE_GPQ   ) );

_Emit_Mov_Sreg_RM:
            _emitX86RM(0x8E,
              src.getSize() == 2,
              src.getSize() == 8,
              reinterpret_cast<const SegmentReg&>(dst).getRegCode(),
              reinterpret_cast<const Operand&>(src),
              0, forceRexPrefix);
            _FINISHED();
          }

          ASMJIT_ASSERT(src.isRegType(REG_TYPE_GPB_LO) ||
                        src.isRegType(REG_TYPE_GPB_HI) ||
                        src.isRegType(REG_TYPE_GPW   ) ||
                        src.isRegType(REG_TYPE_GPD   ) ||
                        src.isRegType(REG_TYPE_GPQ   ) );
          // ... fall through ...
        }
        case (OPERAND_REG << 4) | OPERAND_MEM:
        {
          // Sreg <- Mem
          if (dst.isRegType(REG_TYPE_SEGMENT))
          {
            goto _Emit_Mov_Sreg_RM;
          }

          ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPB_LO) ||
                        dst.isRegType(REG_TYPE_GPB_HI) ||
                        dst.isRegType(REG_TYPE_GPW   ) ||
                        dst.isRegType(REG_TYPE_GPD   ) ||
                        dst.isRegType(REG_TYPE_GPQ   ) );

          _emitX86RM(0x0000008A + (dst.getSize() != 1),
            dst.isRegType(REG_TYPE_GPW),
            dst.isRegType(REG_TYPE_GPQ),
            reinterpret_cast<const GPReg&>(dst).getRegCode(),
            reinterpret_cast<const Operand&>(src),
            0, forceRexPrefix);
          _FINISHED();
        }

        // Reg <- Imm
        case (OPERAND_REG << 4) | OPERAND_IMM:
        {
          const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
          const Imm& src = reinterpret_cast<const Imm&>(*o1);

          // In 64-bit mode the immediate can be 64-bits long if the
          // destination operand type is register (otherwise 32-bits).
          immSize = dst.getSize();

#if defined(ASMJIT_X64)
          // Optimize instruction size by using 32-bit immediate if value can
          // fit into it.
          if (immSize == 8 && Util::isInt32(src.getValue()))
          {
            _emitX86RM(0xC7,
              0, // 16BIT
              1, // REX.W
              0, // O
              dst,
              0, forceRexPrefix);
            immSize = 4;
          }
          else
          {
#endif // ASMJIT_X64
            _emitX86Inl((dst.getSize() == 1 ? 0xB0 : 0xB8),
              dst.isRegType(REG_TYPE_GPW),
              dst.isRegType(REG_TYPE_GPQ),
              dst.getRegCode(), forceRexPrefix);
#if defined(ASMJIT_X64)
          }
#endif // ASMJIT_X64

          _FINISHED_IMMEDIATE(&src, immSize);
        }

        // Mem <- Reg/Sreg
        case (OPERAND_MEM << 4) | OPERAND_REG:
        {
          if (src.isRegType(REG_TYPE_SEGMENT))
          {
            // Mem <- Sreg
            _emitX86RM(0x8C,
              dst.getSize() == 2,
              dst.getSize() == 8,
              reinterpret_cast<const SegmentReg&>(src).getRegCode(),
              reinterpret_cast<const Operand&>(dst),
              0, forceRexPrefix);
            _FINISHED();
          }
          else
          {
            // Mem <- Reg
            ASMJIT_ASSERT(src.isRegType(REG_TYPE_GPB_LO) ||
                          src.isRegType(REG_TYPE_GPB_HI) ||
                          src.isRegType(REG_TYPE_GPW   ) ||
                          src.isRegType(REG_TYPE_GPD   ) ||
                          src.isRegType(REG_TYPE_GPQ   ) );

            _emitX86RM(0x88 + (src.getSize() != 1),
              src.isRegType(REG_TYPE_GPW),
              src.isRegType(REG_TYPE_GPQ),
              reinterpret_cast<const GPReg&>(src).getRegCode(),
              reinterpret_cast<const Operand&>(dst),
              0, forceRexPrefix);
            _FINISHED();
          }
        }

        // Mem <- Imm
        case (OPERAND_MEM << 4) | OPERAND_IMM:
        {
          immSize = dst.getSize() <= 4 ? dst.getSize() : 4;

          _emitX86RM(0xC6 + (dst.getSize() != 1),
            dst.getSize() == 2,
            dst.getSize() == 8,
            0,
            reinterpret_cast<const Operand&>(dst),
            immSize, forceRexPrefix);
          _FINISHED_IMMEDIATE(&src, immSize);
        }
      }

      break;
    }

    case InstructionDescription::G_MOV_PTR:
    {
      if ((o0->isReg() && o1->isImm()) || (o0->isImm() && o1->isReg()))
      {
        bool reverse = o1->getType() == OPERAND_REG;
        uint8_t opCode = !reverse ? 0xA0 : 0xA2;
        const GPReg& reg = reinterpret_cast<const GPReg&>(!reverse ? *o0 : *o1);
        const Imm& imm = reinterpret_cast<const Imm&>(!reverse ? *o1 : *o0);

        if (reg.getRegIndex() != 0)
          goto illegalInstruction;

        if (reg.isRegType(REG_TYPE_GPW)) _emitByte(0x66);
#if defined(ASMJIT_X64)
        _emitRexR(reg.getSize() == 8, 0, 0, forceRexPrefix);
#endif // ASMJIT_X64
        _emitByte(opCode + (reg.getSize() != 1));
        _FINISHED_IMMEDIATE(&imm, sizeof(sysint_t));
      }

      break;
    }

    case InstructionDescription::G_MOVSX_MOVZX:
    {
      if (o0->isReg() && o1->isRegMem())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Operand& src = reinterpret_cast<const Operand&>(*o1);

        if (dst.getSize() == 1)
          goto illegalInstruction;
        
        if (src.getSize() != 1 && src.getSize() != 2)
          goto illegalInstruction;
        
        if (src.getSize() == 2 && dst.getSize() == 2)
          goto illegalInstruction;

        _emitX86RM(id->opCode[0] + (src.getSize() != 1),
          dst.isRegType(REG_TYPE_GPW),
          dst.isRegType(REG_TYPE_GPQ),
          dst.getRegCode(),
          src,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

#if defined(ASMJIT_X64)
    case InstructionDescription::G_MOVSXD:
    {
      if (o0->isReg() && o1->isRegMem())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Operand& src = reinterpret_cast<const Operand&>(*o1);
        _emitX86RM(0x00000063,
          0,
          1, dst.getRegCode(), src,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }
#endif // ASMJIT_X64

    case InstructionDescription::G_PUSH:
    {
      // This section is only for immediates, memory/register operands are handled in G_POP.
      if (o0->isImm())
      {
        const Imm& imm = reinterpret_cast<const Imm&>(*o0);

        if (Util::isInt8(imm.getValue()))
        {
          _emitByte(0x6A);
          _FINISHED_IMMEDIATE(&imm, 1);
        }
        else
        {
          _emitByte(0x68);
          _FINISHED_IMMEDIATE(&imm, 4);
        }
      }

      // ... goto G_POP ...
    }

    case InstructionDescription::G_POP:
    {
      if (o0->isReg())
      {
        ASMJIT_ASSERT(o0->isRegType(REG_TYPE_GPW) || o0->isRegType(REG_TYPE_GPN));
        _emitX86Inl(id->opCode[0], o0->isRegType(REG_TYPE_GPW), 0, reinterpret_cast<const GPReg&>(*o0).getRegCode(), forceRexPrefix);
        _FINISHED();
      }

      if (o0->isMem())
      {
        _emitX86RM(id->opCode[1], o0->getSize() == 2, 0, (uint8_t)id->opCodeR, reinterpret_cast<const Operand&>(*o0), 0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_R_RM:
    {
      if (o0->isReg() && o1->isRegMem())
      {
        const GPReg& dst = reinterpret_cast<const GPReg&>(*o0);
        const Operand& src = reinterpret_cast<const Operand&>(*o1);
        ASMJIT_ASSERT(dst.getSize() != 1);

        _emitX86RM(id->opCode[0],
          dst.getRegType() == REG_TYPE_GPW,
          dst.getRegType() == REG_TYPE_GPQ, dst.getRegCode(), src,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_RM_B:
    {
      if (o0->isRegMem())
      {
        const Operand& op = reinterpret_cast<const Operand&>(*o0);

        // Only BYTE register or BYTE/TYPELESS memory location can be used.
        ASMJIT_ASSERT(op.getSize() <= 1);
        
        _emitX86RM(id->opCode[0], false, false, 0, op, 0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_RM:
    {
      if (o0->isRegMem())
      {
        const Operand& op = reinterpret_cast<const Operand&>(*o0);
        _emitX86RM(id->opCode[0] + (op.getSize() != 1),
          op.getSize() == 2,
          op.getSize() == 8, (uint8_t)id->opCodeR, op,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_RM_R:
    {
      if (o0->isRegMem() && o1->isReg())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        const GPReg& src = reinterpret_cast<const GPReg&>(*o1);
        _emitX86RM(id->opCode[0] + (src.getSize() != 1),
          src.getRegType() == REG_TYPE_GPW,
          src.getRegType() == REG_TYPE_GPQ, src.getRegCode(), dst,
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_REP:
    {
      uint32_t opCode = id->opCode[0];
      uint32_t opSize = id->opCode[1];

      // Emit REP prefix (1 BYTE).
      _emitByte(opCode >> 24);

      if (opSize != 1) opCode++; // D, Q and W form.
      if (opSize == 2) _emitByte(0x66); // 16-bit prefix.
#if defined(ASMJIT_X64)
      else if (opSize == 8) _emitByte(0x48); // REX.W prefix.
#endif // ASMJIT_X64

      // Emit opcode (1 BYTE).
      _emitByte(opCode & 0xFF);
      _FINISHED();
    }

    case InstructionDescription::G_RET:
    {
      if (o0->isNone())
      {
        _emitByte(0xC3);
        _FINISHED();
      }
      else if (o0->isImm())
      {
        const Imm& imm = reinterpret_cast<const Imm&>(*o0);
        ASMJIT_ASSERT(Util::isUInt16(imm.getValue()));

        if (imm.getValue() == 0)
        {
          _emitByte(0xC3);
          _FINISHED();
        }
        else
        {
          _emitByte(0xC2);
          _FINISHED_IMMEDIATE(&imm, 2);
        }
      }

      break;
    }

    case InstructionDescription::G_ROT:
    {
      if (o0->isRegMem() && (o1->isRegCode(REG_CL) || o1->isImm()))
      {
        // generate opcode. For these operations is base 0xC0 or 0xD0.
        bool useImm8 = o1->isImm() && reinterpret_cast<const Imm&>(*o1).getValue() != 1;
        uint32_t opCode = useImm8 ? 0xC0 : 0xD0;

        // size and operand type modifies the opcode
        if (o0->getSize() != 1) opCode |= 0x01;
        if (o1->getType() == OPERAND_REG) opCode |= 0x02;

        _emitX86RM(opCode,
          o0->getSize() == 2,
          o0->getSize() == 8,
          (uint8_t)id->opCodeR, reinterpret_cast<const Operand&>(*o0),
          useImm8 ? 1 : 0, forceRexPrefix);

        if (useImm8)
          _FINISHED_IMMEDIATE(o1, 1);
        else
          _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_SHLD_SHRD:
    {
      if (o0->isRegMem() && o1->isReg() && (o2->isImm() || (o2->isReg() && o2->isRegCode(REG_CL))))
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        const GPReg& src1 = reinterpret_cast<const GPReg&>(*o1);
        const Operand& src2 = reinterpret_cast<const Operand&>(*o2);

        ASMJIT_ASSERT(dst.getSize() == src1.getSize());

        _emitX86RM(id->opCode[0] + src2.isReg(),
          src1.isRegType(REG_TYPE_GPW),
          src1.isRegType(REG_TYPE_GPQ),
          src1.getRegCode(), dst,
          src2.isImm() ? 1 : 0, forceRexPrefix);
        if (src2.isImm())
          _FINISHED_IMMEDIATE(&src2, 1);
        else
          _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_TEST:
    {
      if (o0->isRegMem() && o1->isReg())
      {
        ASMJIT_ASSERT(o0->getSize() == o1->getSize());
        _emitX86RM(0x84 + (o1->getSize() != 1),
          o1->getSize() == 2, o1->getSize() == 8,
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const Operand&>(*o0),
          0, forceRexPrefix);
        _FINISHED();
      }

      if (o0->isRegIndex(0) && o1->isImm())
      {
        immSize = o0->getSize() <= 4 ? o0->getSize() : 4;

        if (o0->getSize() == 2) _emitByte(0x66); // 16-bit.
#if defined(ASMJIT_X64)
        _emitRexRM(o0->getSize() == 8, 0, reinterpret_cast<const Operand&>(*o0), forceRexPrefix);
#endif // ASMJIT_X64
        _emitByte(0xA8 + (o0->getSize() != 1));
        _FINISHED_IMMEDIATE(o1, immSize);
      }

      if (o0->isRegMem() && o1->isImm())
      {
        immSize = o0->getSize() <= 4 ? o0->getSize() : 4;

        if (o0->getSize() == 2) _emitByte(0x66); // 16-bit.
        _emitSegmentPrefix(reinterpret_cast<const Operand&>(*o0)); // Segment prefix.
#if defined(ASMJIT_X64)
        _emitRexRM(o0->getSize() == 8, 0, reinterpret_cast<const Operand&>(*o0), forceRexPrefix);
#endif // ASMJIT_X64
        _emitByte(0xF6 + (o0->getSize() != 1));
        _emitModRM(0, reinterpret_cast<const Operand&>(*o0), immSize);
        _FINISHED_IMMEDIATE(o1, immSize);
      }

      break;
    }

    case InstructionDescription::G_XCHG:
    {
      if (o0->isRegMem() && o1->isReg())
      {
        const Operand& dst = reinterpret_cast<const Operand&>(*o0);
        const GPReg& src = reinterpret_cast<const GPReg&>(*o1);

        if (src.isRegType(REG_TYPE_GPW)) _emitByte(0x66); // 16-bit.
        _emitSegmentPrefix(dst); // segment prefix
#if defined(ASMJIT_X64)
        _emitRexRM(src.isRegType(REG_TYPE_GPQ), src.getRegCode(), dst, forceRexPrefix);
#endif // ASMJIT_X64

        // Special opcode for index 0 registers (AX, EAX, RAX vs register).
        if ((dst.getType() == OPERAND_REG && dst.getSize() > 1) &&
            (reinterpret_cast<const GPReg&>(dst).getRegCode() == 0 ||
             reinterpret_cast<const GPReg&>(src).getRegCode() == 0 ))
        {
          uint8_t index = reinterpret_cast<const GPReg&>(dst).getRegCode() | src.getRegCode();
          _emitByte(0x90 + index);
          _FINISHED();
        }

        _emitByte(0x86 + (src.getSize() != 1));
        _emitModRM(src.getRegCode(), dst, 0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_MOVBE:
    {
      if (o0->isReg() && o1->isMem())
      {
        _emitX86RM(0x000F38F0,
          o0->isRegType(REG_TYPE_GPW),
          o0->isRegType(REG_TYPE_GPQ),
          reinterpret_cast<const GPReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1),
          0, forceRexPrefix);
        _FINISHED();
      }

      if (o0->isMem() && o1->isReg())
      {
        _emitX86RM(0x000F38F1,
          o1->isRegType(REG_TYPE_GPW),
          o1->isRegType(REG_TYPE_GPQ),
          reinterpret_cast<const GPReg&>(*o1).getRegCode(),
          reinterpret_cast<const Mem&>(*o0),
          0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_X87_FPU:
    {
      if (o0->isRegType(REG_TYPE_X87))
      {
        uint8_t i1 = reinterpret_cast<const X87Reg&>(*o0).getRegIndex();
        uint8_t i2 = 0;

        if (code != INST_FCOM && code != INST_FCOMP)
        {
          if (!o1->isRegType(REG_TYPE_X87))
            goto illegalInstruction;
          i2 = reinterpret_cast<const X87Reg&>(*o1).getRegIndex();
        }
        else if (i1 != 0 && i2 != 0)
        {
          goto illegalInstruction;
        }

        _emitByte(i1 == 0
          ? ((id->opCode[0] & 0xFF000000) >> 24)
          : ((id->opCode[0] & 0x00FF0000) >> 16));
        _emitByte(i1 == 0
          ? ((id->opCode[0] & 0x0000FF00) >>  8) + i2
          : ((id->opCode[0] & 0x000000FF)      ) + i1);
        _FINISHED();
      }

      if (o0->isMem() && (o0->getSize() == 4 || o0->getSize() == 8) && o1->isNone())
      {
        const Mem& m = reinterpret_cast<const Mem&>(*o0);

        // segment prefix
        _emitSegmentPrefix(m);

        _emitByte(o0->getSize() == 4
          ? ((id->opCode[0] & 0xFF000000) >> 24)
          : ((id->opCode[0] & 0x00FF0000) >> 16));
        _emitModM((uint8_t)id->opCodeR, m, 0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_X87_STI:
    {
      if (o0->isRegType(REG_TYPE_X87))
      {
        uint8_t i = reinterpret_cast<const X87Reg&>(*o0).getRegIndex();
        _emitByte((uint8_t)((id->opCode[0] & 0x0000FF00) >> 8));
        _emitByte((uint8_t)((id->opCode[0] & 0x000000FF) + i));
        _FINISHED();
      }
      break;
    }

    case InstructionDescription::G_X87_FSTSW:
    {
      if (o0->isReg() &&
          reinterpret_cast<const BaseReg&>(*o0).getRegType() <= REG_TYPE_GPQ &&
          reinterpret_cast<const BaseReg&>(*o0).getRegIndex() == 0)
      {
        _emitOpCode(id->opCode[1]);
        _FINISHED();
      }

      if (o0->isMem())
      {
        _emitX86RM(id->opCode[0], 0, 0, (uint8_t)id->opCodeR, reinterpret_cast<const Mem&>(*o0), 0, forceRexPrefix);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_X87_MEM_STI:
    {
      if (o0->isRegType(REG_TYPE_X87))
      {
        _emitByte((uint8_t)((id->opCode[1] & 0xFF000000) >> 24));
        _emitByte((uint8_t)((id->opCode[1] & 0x00FF0000) >> 16) +
          reinterpret_cast<const X87Reg&>(*o0).getRegIndex());
        _FINISHED();
      }

      // ... fall through to G_X87_MEM ...
    }

    case InstructionDescription::G_X87_MEM:
    {
      if (!o0->isMem())
        goto illegalInstruction;
      const Mem& m = reinterpret_cast<const Mem&>(*o0);

      uint8_t opCode = 0x00, mod = 0;

      if (o0->getSize() == 2 && (id->oflags[0] & InstructionDescription::O_FM_2))
      {
        opCode = (uint8_t)((id->opCode[0] & 0xFF000000) >> 24);
        mod    = (uint8_t)id->opCodeR;
      }
      if (o0->getSize() == 4 && (id->oflags[0] & InstructionDescription::O_FM_4))
      {
        opCode = (uint8_t)((id->opCode[0] & 0x00FF0000) >> 16);
        mod    = (uint8_t)id->opCodeR;
      }
      if (o0->getSize() == 8 && (id->oflags[0] & InstructionDescription::O_FM_8))
      {
        opCode = (uint8_t)((id->opCode[0] & 0x0000FF00) >>  8);
        mod    = (uint8_t)((id->opCode[0] & 0x000000FF)      );
      }

      if (opCode)
      {
        _emitSegmentPrefix(m);
        _emitByte(opCode);
        _emitModM(mod, m, 0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_MMU_MOV:
    {
      ASMJIT_ASSERT(id->oflags[0] != 0);
      ASMJIT_ASSERT(id->oflags[1] != 0);

      // Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
      if ((o0->isMem()                 && (id->oflags[0] & InstructionDescription::O_MEM) == 0) ||
          (o0->isRegType(REG_TYPE_MM ) && (id->oflags[0] & InstructionDescription::O_MM ) == 0) ||
          (o0->isRegType(REG_TYPE_XMM) && (id->oflags[0] & InstructionDescription::O_XMM) == 0) ||
          (o0->isRegType(REG_TYPE_GPD) && (id->oflags[0] & InstructionDescription::O_GD ) == 0) ||
          (o0->isRegType(REG_TYPE_GPQ) && (id->oflags[0] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isRegType(REG_TYPE_MM ) && (id->oflags[1] & InstructionDescription::O_MM ) == 0) ||
          (o1->isRegType(REG_TYPE_XMM) && (id->oflags[1] & InstructionDescription::O_XMM) == 0) ||
          (o1->isRegType(REG_TYPE_GPD) && (id->oflags[1] & InstructionDescription::O_GD ) == 0) ||
          (o1->isRegType(REG_TYPE_GPQ) && (id->oflags[1] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isMem()                 && (id->oflags[1] & InstructionDescription::O_MEM) == 0) )
      {
        goto illegalInstruction;
      }

      // Illegal.
      if (o0->isMem() && o1->isMem())
        goto illegalInstruction;

      uint8_t rexw = ((id->oflags[0] | id->oflags[1]) & InstructionDescription::O_NOREX)
        ? 0
        : o0->isRegType(REG_TYPE_GPQ) | o1->isRegType(REG_TYPE_GPQ);

      // (X)MM|Reg <- (X)MM|Reg
      if (o0->isReg() && o1->isReg())
      {
        _emitMmu(id->opCode[0], rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const BaseReg&>(*o1),
          0);
        _FINISHED();
      }

      // (X)MM|Reg <- Mem
      if (o0->isReg() && o1->isMem())
      {
        _emitMmu(id->opCode[0], rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1),
          0);
        _FINISHED();
      }

      // Mem <- (X)MM|Reg
      if (o0->isMem() && o1->isReg())
      {
        _emitMmu(id->opCode[1], rexw,
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const Mem&>(*o0),
          0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_MMU_MOVD:
    {
      if ((o0->isRegType(REG_TYPE_MM) || o0->isRegType(REG_TYPE_XMM)) && (o1->isRegType(REG_TYPE_GPD) || o1->isMem()))
      {
        _emitMmu(o0->isRegType(REG_TYPE_XMM) ? 0x66000F6E : 0x00000F6E, 0,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Operand&>(*o1),
          0);
        _FINISHED();
      }

      if ((o0->isRegType(REG_TYPE_GPD) || o0->isMem()) && (o1->isRegType(REG_TYPE_MM) || o1->isRegType(REG_TYPE_XMM)))
      {
        _emitMmu(o1->isRegType(REG_TYPE_XMM) ? 0x66000F7E : 0x00000F7E, 0,
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const Operand&>(*o0),
          0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_MMU_MOVQ:
    {
      if (o0->isRegType(REG_TYPE_MM) && o1->isRegType(REG_TYPE_MM))
      {
        _emitMmu(0x00000F6F, 0,
          reinterpret_cast<const MMReg&>(*o0).getRegCode(),
          reinterpret_cast<const MMReg&>(*o1),
          0);
        _FINISHED();
      }

      if (o0->isRegType(REG_TYPE_XMM) && o1->isRegType(REG_TYPE_XMM))
      {
        _emitMmu(0xF3000F7E, 0,
          reinterpret_cast<const XMMReg&>(*o0).getRegCode(),
          reinterpret_cast<const XMMReg&>(*o1),
          0);
        _FINISHED();
      }

      // Convenience - movdq2q
      if (o0->isRegType(REG_TYPE_MM) && o1->isRegType(REG_TYPE_XMM))
      {
        _emitMmu(0xF2000FD6, 0,
          reinterpret_cast<const MMReg&>(*o0).getRegCode(),
          reinterpret_cast<const XMMReg&>(*o1),
          0);
        _FINISHED();
      }

      // Convenience - movq2dq
      if (o0->isRegType(REG_TYPE_XMM) && o1->isRegType(REG_TYPE_MM))
      {
        _emitMmu(0xF3000FD6, 0,
          reinterpret_cast<const XMMReg&>(*o0).getRegCode(),
          reinterpret_cast<const MMReg&>(*o1),
          0);
        _FINISHED();
      }

      if (o0->isRegType(REG_TYPE_MM) && o1->isMem())
      {
        _emitMmu(0x00000F6F, 0,
          reinterpret_cast<const MMReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1),
          0);
        _FINISHED();
      }

      if (o0->isRegType(REG_TYPE_XMM) && o1->isMem())
      {
        _emitMmu(0xF3000F7E, 0,
          reinterpret_cast<const XMMReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1),
          0);
        _FINISHED();
      }

      if (o0->isMem() && o1->isRegType(REG_TYPE_MM))
      {
        _emitMmu(0x00000F7F, 0,
          reinterpret_cast<const MMReg&>(*o1).getRegCode(),
          reinterpret_cast<const Mem&>(*o0),
          0);
        _FINISHED();
      }

      if (o0->isMem() && o1->isRegType(REG_TYPE_XMM))
      {
        _emitMmu(0x66000FD6, 0,
          reinterpret_cast<const XMMReg&>(*o1).getRegCode(),
          reinterpret_cast<const Mem&>(*o0),
          0);
        _FINISHED();
      }

#if defined(ASMJIT_X64)
      if ((o0->isRegType(REG_TYPE_MM) || o0->isRegType(REG_TYPE_XMM)) && (o1->isRegType(REG_TYPE_GPQ) || o1->isMem()))
      {
        _emitMmu(o0->isRegType(REG_TYPE_XMM) ? 0x66000F6E : 0x00000F6E, 1,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Operand&>(*o1),
          0);
        _FINISHED();
      }

      if ((o0->isRegType(REG_TYPE_GPQ) || o0->isMem()) && (o1->isRegType(REG_TYPE_MM) || o1->isRegType(REG_TYPE_XMM)))
      {
        _emitMmu(o1->isRegType(REG_TYPE_XMM) ? 0x66000F7E : 0x00000F7E, 1,
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const Operand&>(*o0),
          0);
        _FINISHED();
      }
#endif // ASMJIT_X64

      break;
    }

    case InstructionDescription::G_MMU_PREFETCH:
    {
      if (o0->isMem() && o1->isImm())
      {
        const Mem& mem = reinterpret_cast<const Mem&>(*o0);
        const Imm& hint = reinterpret_cast<const Imm&>(*o1);

        _emitMmu(0x00000F18, 0, (uint8_t)hint.getValue(), mem, 0);
        _FINISHED();
      }

      break;
    }

    case InstructionDescription::G_MMU_PEXTR:
    {
      if (!(o0->isRegMem() &&
           (o1->isRegType(REG_TYPE_XMM) || (code == INST_PEXTRW && o1->isRegType(REG_TYPE_MM))) &&
            o2->isImm()))
      {
        goto illegalInstruction;
      }

      uint32_t opCode = id->opCode[0];
      uint8_t isGpdGpq = o0->isRegType(REG_TYPE_GPD) | o0->isRegType(REG_TYPE_GPQ);

      if (code == INST_PEXTRB && (o0->getSize() != 0 && o0->getSize() != 1) && !isGpdGpq)
        goto illegalInstruction;
      if (code == INST_PEXTRW && (o0->getSize() != 0 && o0->getSize() != 2) && !isGpdGpq)
        goto illegalInstruction;
      if (code == INST_PEXTRD && (o0->getSize() != 0 && o0->getSize() != 4) && !isGpdGpq)
        goto illegalInstruction;
      if (code == INST_PEXTRQ && (o0->getSize() != 0 && o0->getSize() != 8) && !isGpdGpq)
        goto illegalInstruction;

      if (o1->isRegType(REG_TYPE_XMM)) opCode |= 0x66000000;

      if (o0->isReg())
      {
        _emitMmu(opCode, id->opCodeR | (uint8_t)o0->isRegType(REG_TYPE_GPQ),
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const BaseReg&>(*o0), 1);
        _FINISHED_IMMEDIATE(o2, 1);
      }

      if (o0->isMem())
      {
        _emitMmu(opCode, (uint8_t)id->opCodeR,
          reinterpret_cast<const BaseReg&>(*o1).getRegCode(),
          reinterpret_cast<const Mem&>(*o0), 1);
        _FINISHED_IMMEDIATE(o2, 1);
      }

      break;
    }

    case InstructionDescription::G_MMU_RMI:
    {
      ASMJIT_ASSERT(id->oflags[0] != 0);
      ASMJIT_ASSERT(id->oflags[1] != 0);

      // Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
      if (!o0->isReg() ||
          (o0->isRegType(REG_TYPE_MM ) && (id->oflags[0] & InstructionDescription::O_MM ) == 0) ||
          (o0->isRegType(REG_TYPE_XMM) && (id->oflags[0] & InstructionDescription::O_XMM) == 0) ||
          (o0->isRegType(REG_TYPE_GPD) && (id->oflags[0] & InstructionDescription::O_GD ) == 0) ||
          (o0->isRegType(REG_TYPE_GPQ) && (id->oflags[0] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isRegType(REG_TYPE_MM ) && (id->oflags[1] & InstructionDescription::O_MM ) == 0) ||
          (o1->isRegType(REG_TYPE_XMM) && (id->oflags[1] & InstructionDescription::O_XMM) == 0) ||
          (o1->isRegType(REG_TYPE_GPD) && (id->oflags[1] & InstructionDescription::O_GD ) == 0) ||
          (o1->isRegType(REG_TYPE_GPQ) && (id->oflags[1] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isMem()                 && (id->oflags[1] & InstructionDescription::O_MEM) == 0) ||
          (o1->isImm()                 && (id->oflags[1] & InstructionDescription::O_IMM) == 0))
      {
        goto illegalInstruction;
      }

      uint32_t prefix =
        ((id->oflags[0] & InstructionDescription::O_MM_XMM) == InstructionDescription::O_MM_XMM && o0->isRegType(REG_TYPE_XMM)) ||
        ((id->oflags[1] & InstructionDescription::O_MM_XMM) == InstructionDescription::O_MM_XMM && o1->isRegType(REG_TYPE_XMM))
          ? 0x66000000
          : 0x00000000;

      uint8_t rexw = ((id->oflags[0] | id->oflags[1]) & InstructionDescription::O_NOREX)
        ? 0
        : o0->isRegType(REG_TYPE_GPQ) | o1->isRegType(REG_TYPE_GPQ);

      // (X)MM <- (X)MM (opcode0)
      if (o1->isReg())
      {
        if ((id->oflags[1] & (InstructionDescription::O_MM_XMM | InstructionDescription::O_GQD)) == 0)
          goto illegalInstruction;
        _emitMmu(id->opCode[0] | prefix, rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const BaseReg&>(*o1), 0);
        _FINISHED();
      }
      // (X)MM <- Mem (opcode0)
      if (o1->isMem())
      {
        if ((id->oflags[1] & InstructionDescription::O_MEM) == 0)
          goto illegalInstruction;
        _emitMmu(id->opCode[0] | prefix, rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1), 0);
        _FINISHED();
      }
      // (X)MM <- Imm (opcode1+opcodeR)
      if (o1->isImm())
      {
        if ((id->oflags[1] & InstructionDescription::O_IMM) == 0)
          goto illegalInstruction;
        _emitMmu(id->opCode[1] | prefix, rexw,
          (uint8_t)id->opCodeR,
          reinterpret_cast<const BaseReg&>(*o0), 1);
        _FINISHED_IMMEDIATE(o1, 1);
      }

      break;
    }

    case InstructionDescription::G_MMU_RM_IMM8:
    {
      ASMJIT_ASSERT(id->oflags[0] != 0);
      ASMJIT_ASSERT(id->oflags[1] != 0);

      // Check parameters (X)MM|GP32_64 <- (X)MM|GP32_64|Mem|Imm
      if (!o0->isReg() ||
          (o0->isRegType(REG_TYPE_MM ) && (id->oflags[0] & InstructionDescription::O_MM ) == 0) ||
          (o0->isRegType(REG_TYPE_XMM) && (id->oflags[0] & InstructionDescription::O_XMM) == 0) ||
          (o0->isRegType(REG_TYPE_GPD) && (id->oflags[0] & InstructionDescription::O_GD ) == 0) ||
          (o0->isRegType(REG_TYPE_GPQ) && (id->oflags[0] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isRegType(REG_TYPE_MM ) && (id->oflags[1] & InstructionDescription::O_MM ) == 0) ||
          (o1->isRegType(REG_TYPE_XMM) && (id->oflags[1] & InstructionDescription::O_XMM) == 0) ||
          (o1->isRegType(REG_TYPE_GPD) && (id->oflags[1] & InstructionDescription::O_GD ) == 0) ||
          (o1->isRegType(REG_TYPE_GPQ) && (id->oflags[1] & InstructionDescription::O_GQ ) == 0) ||
          (o1->isMem()                 && (id->oflags[1] & InstructionDescription::O_MEM) == 0) ||
          !o2->isImm())
      {
        goto illegalInstruction;
      }

      uint32_t prefix =
        ((id->oflags[0] & InstructionDescription::O_MM_XMM) == InstructionDescription::O_MM_XMM && o0->isRegType(REG_TYPE_XMM)) ||
        ((id->oflags[1] & InstructionDescription::O_MM_XMM) == InstructionDescription::O_MM_XMM && o1->isRegType(REG_TYPE_XMM))
          ? 0x66000000
          : 0x00000000;

      uint8_t rexw = ((id->oflags[0]|id->oflags[1]) & InstructionDescription::O_NOREX)
        ? 0
        : o0->isRegType(REG_TYPE_GPQ) | o1->isRegType(REG_TYPE_GPQ);

      // (X)MM <- (X)MM (opcode0)
      if (o1->isReg())
      {
        if ((id->oflags[1] & (InstructionDescription::O_MM_XMM | InstructionDescription::O_GQD)) == 0)
goto illegalInstruction;
        _emitMmu(id->opCode[0] | prefix, rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const BaseReg&>(*o1), 1);
        _FINISHED_IMMEDIATE(o2, 1);
      }
      // (X)MM <- Mem (opcode0)
      if (o1->isMem())
      {
        if ((id->oflags[1] & InstructionDescription::O_MEM) == 0)
          goto illegalInstruction;
        _emitMmu(id->opCode[0] | prefix, rexw,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1), 1);
        _FINISHED_IMMEDIATE(o2, 1);
      }

      break;
    }

    case InstructionDescription::G_MMU_RM_3DNOW:
    {
      if (o0->isRegType(REG_TYPE_MM) && (o1->isRegType(REG_TYPE_MM) || o1->isMem()))
      {
        _emitMmu(id->opCode[0], 0,
          reinterpret_cast<const BaseReg&>(*o0).getRegCode(),
          reinterpret_cast<const Mem&>(*o1), 1);
        _emitByte((uint8_t)id->opCode[1]);
        _FINISHED();
      }

      break;
    }
  }

illegalInstruction:
  // Set an error. If we run in release mode assertion will be not used, so we
  // must inform about invalid state.
  setError(ERROR_ILLEGAL_INSTRUCTION);

#if defined(ASMJIT_DEBUG)
  assertIllegal = true;
#endif // ASMJIT_DEBUG
  goto end;

emitImmediate:
  {
    sysint_t value = immOperand->getValue();
    switch (immSize)
    {
      case 1: _emitByte ((uint8_t )(sysuint_t)value); break;
      case 2: _emitWord ((uint16_t)(sysuint_t)value); break;
      case 4: _emitDWord((uint32_t)(sysuint_t)value); break;
#if defined(ASMJIT_X64)
      case 8: _emitQWord((uint64_t)(sysuint_t)value); break;
#endif // ASMJIT_X64
      default: ASMJIT_ASSERT(0);
    }
  }

end:
  if (_logger
#if defined(ASMJIT_DEBUG)
      || assertIllegal
#endif // ASMJIT_DEBUG
     )
  {
    char bufStorage[512];
    char* buf = bufStorage;

    // Detect truncated operand.
    Imm immTemporary(0);

    // Use the original operands, because BYTE some of them were replaced.
    if (bLoHiUsed)
    {
      o0 = _loggerOperands[0];
      o1 = _loggerOperands[1];
      o2 = _loggerOperands[2];
    }

    if (immOperand)
    {
      sysint_t value = immOperand->getValue();
      bool isUnsigned = immOperand->isUnsigned();

      switch (immSize)
      {
        case 1: if ( isUnsigned && !Util::isUInt8 (value)) { immTemporary.setValue((uint8_t)(sysuint_t)value, true ); break; }
                if (!isUnsigned && !Util::isInt8  (value)) { immTemporary.setValue((uint8_t)(sysuint_t)value, false); break; }
                break;
        case 2: if ( isUnsigned && !Util::isUInt16(value)) { immTemporary.setValue((uint16_t)(sysuint_t)value, true ); break; }
                if (!isUnsigned && !Util::isInt16 (value)) { immTemporary.setValue((uint16_t)(sysuint_t)value, false); break; }
                break;
        case 4: if ( isUnsigned && !Util::isUInt32(value)) { immTemporary.setValue((uint32_t)(sysuint_t)value, true ); break; }
                if (!isUnsigned && !Util::isInt32 (value)) { immTemporary.setValue((uint32_t)(sysuint_t)value, false); break; }
                break;
      }

      if (immTemporary.getValue() != 0)
      {
        if (o0 == immOperand) o0 = &immTemporary;
        if (o1 == immOperand) o1 = &immTemporary;
        if (o2 == immOperand) o2 = &immTemporary;
      }
    }

    buf = dumpInstruction(buf, code, _emitOptions, o0, o1, o2, memRegType);

    if (_logger->getLogBinary())
      buf = dumpComment(buf, (sysuint_t)(buf - bufStorage), getCode() + beginOffset, getOffset() - beginOffset, _comment);
    else
      buf = dumpComment(buf, (sysuint_t)(buf - bufStorage), NULL, 0, _comment);

    // We don't need to NULL terminate the resulting string.
#if defined(ASMJIT_DEBUG)
    if (_logger)
#endif // ASMJIT_DEBUG
      _logger->logString(bufStorage, (sysuint_t)(buf - bufStorage));

#if defined(ASMJIT_DEBUG)
    if (assertIllegal)
    {
      // Here we need to NULL terminate.
      buf[0] = '\0';

      // Raise an assertion failure, because this situation shouldn't happen.
      assertionFailure(__FILE__, __LINE__, bufStorage);
    }
#endif // ASMJIT_DEBUG
  }

cleanup:
  _comment = NULL;
  _emitOptions = 0;
}

void AssemblerCore::_emitJcc(uint32_t code, const Label* label, uint32_t hint)
{
  if (!hint)
  {
    _emitInstruction(code, label, NULL, NULL);
  }
  else
  {
    Imm imm(hint);
    _emitInstruction(code, label, &imm, NULL);
  }
}

// ============================================================================
// [AsmJit::AssemblerCore - Relocation helpers]
// ============================================================================

sysuint_t AssemblerCore::relocCode(void* _dst, sysuint_t addressBase) const
{
  // Copy code to virtual memory (this is a given _dst pointer).
  uint8_t* dst = reinterpret_cast<uint8_t*>(_dst);

  sysint_t coff = _buffer.getOffset();
  sysint_t csize = getCodeSize();

  // We are copying the exact size of the generated code. Extra code for trampolines
  // is generated on-the-fly by relocator (this code doesn't exist at the moment).
  memcpy(dst, _buffer.getData(), coff);

#if defined(ASMJIT_X64)
  // Trampoline pointer.
  uint8_t* tramp = dst + coff;
#endif // ASMJIT_X64

  // Relocate all recorded locations.
  sysint_t i;
  sysint_t len = _relocData.getLength();

  for (i = 0; i < len; i++)
  {
    const RelocData& r = _relocData[i];
    sysint_t val;

#if defined(ASMJIT_X64)
    // Whether to use trampoline, can be only used if relocation type is
    // ABSOLUTE_TO_RELATIVE_TRAMPOLINE.
    bool useTrampoline = false;
#endif // ASMJIT_X64

    // Be sure that reloc data structure is correct.
    ASMJIT_ASSERT((sysint_t)(r.offset + r.size) <= csize);

    switch (r.type)
    {
      case RelocData::ABSOLUTE_TO_ABSOLUTE:
        val = (sysint_t)(r.address);
        break;

      case RelocData::RELATIVE_TO_ABSOLUTE:
        val = (sysint_t)(addressBase + r.destination);
        break;

      case RelocData::ABSOLUTE_TO_RELATIVE:
      case RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE:
        val = (sysint_t)( (sysuint_t)r.address - (addressBase + (sysuint_t)r.offset + 4) );

#if defined(ASMJIT_X64)
        if (r.type == RelocData::ABSOLUTE_TO_RELATIVE_TRAMPOLINE && !Util::isInt32(val))
        {
          val = (sysint_t)( (sysuint_t)tramp - ((sysuint_t)_dst + (sysuint_t)r.offset + 4) );
          useTrampoline = true;
        }
#endif // ASMJIT_X64
        break;

      default:
        ASMJIT_ASSERT(0);
    }

    switch (r.size)
    {
      case 4:
        *reinterpret_cast<int32_t*>(dst + r.offset) = (int32_t)val;
        break;

      case 8:
        *reinterpret_cast<int64_t*>(dst + r.offset) = (int64_t)val;
        break;

      default:
        ASMJIT_ASSERT(0);
    }

#if defined(ASMJIT_X64)
    if (useTrampoline)
    {
      if (getLogger())
      {
        getLogger()->logFormat("; Trampoline from %p -> %p\n", (int8_t*)addressBase + r.offset, r.address);
      }

      TrampolineWriter::writeTrampoline(tramp, r.address);
      tramp += TrampolineWriter::TRAMPOLINE_SIZE;
    }
#endif // ASMJIT_X64
  }

#if defined(ASMJIT_X64)
  return (sysuint_t)(tramp - dst);
#else
  return (sysuint_t)coff;
#endif // ASMJIT_X64
}

// ============================================================================
// [AsmJit::AssemblerCore - Embed]
// ============================================================================

void AssemblerCore::embed(const void* data, sysuint_t size)
{
  if (!canEmit()) return;

  if (_logger)
  {
    sysuint_t i, j;
    sysuint_t max;
    char buf[128];
    char dot[] = ".data ";
    char* p;

    memcpy(buf, dot, ASMJIT_ARRAY_SIZE(dot) - 1);

    for (i = 0; i < size; i += 16)
    {
      max = (size - i < 16) ? size - i : 16;
      p = buf + ASMJIT_ARRAY_SIZE(dot) - 1;

      for (j = 0; j < max; j++)
        p += sprintf(p, "%0.2X", reinterpret_cast<const uint8_t *>(data)[i+j]);

      *p++ = '\n';
      *p = '\0';

      _logger->logString(buf);
    }
  }

  _buffer.emitData(data, size);
}

void AssemblerCore::embedLabel(const Label& label)
{
  ASMJIT_ASSERT(label.getId() != INVALID_VALUE);
  if (!canEmit()) return;

  LabelData& l_data = _labelData[label.getId() & OPERAND_ID_VALUE_MASK];
  RelocData r_data;

  if (_logger)
  {
    _logger->logFormat(sizeof(sysint_t) == 4 ? ".dd L.%u\n" : ".dq L.%u\n", (uint32_t)label.getId() & OPERAND_ID_VALUE_MASK);
  }

  r_data.type = RelocData::RELATIVE_TO_ABSOLUTE;
  r_data.size = sizeof(sysint_t);
  r_data.offset = getOffset();
  r_data.destination = 0;

  if (l_data.offset != -1)
  {
    // Bound label.
    r_data.destination = l_data.offset;
  }
  else
  {
    // Non-bound label. Need to chain.
    LabelLink* link = _newLabelLink();

    link->prev = (LabelLink*)l_data.links;
    link->offset = getOffset();
    link->displacement = 0;
    link->relocId = _relocData.getLength();

    l_data.links = link;
  }

  _relocData.append(r_data);

  // Emit dummy sysint (4 or 8 bytes that depends on address size).
  _emitSysInt(0);
}

// ============================================================================
// [AsmJit::AssemblerCore - Align]
// ============================================================================

void AssemblerCore::align(uint32_t m)
{
  if (!canEmit()) return;
  if (_logger) _logger->logFormat(".align %u", (uint)m);

  if (!m) return;

  if (m > 64)
  {
    ASMJIT_ASSERT(0);
    return;
  }

  sysint_t i = m - (getOffset() % m);
  if (i == m) return;

  if (_properties & (1 << PROPERTY_OPTIMIZE_ALIGN))
  {
    const CpuInfo* ci = getCpuInfo();

    // NOPs optimized for Intel:
    //   Intel 64 and IA-32 Architectures Software Developer's Manual
    //   - Volume 2B 
    //   - Instruction Set Reference N-Z
    //     - NOP

    // NOPs optimized for AMD:
    //   Software Optimization Guide for AMD Family 10h Processors (Quad-Core)
    //   - 4.13 - Code Padding with Operand-Size Override and Multibyte NOP

    // Intel and AMD.
    static const uint8_t nop1[] = { 0x90 };
    static const uint8_t nop2[] = { 0x66, 0x90 };
    static const uint8_t nop3[] = { 0x0F, 0x1F, 0x00 };
    static const uint8_t nop4[] = { 0x0F, 0x1F, 0x40, 0x00 };
    static const uint8_t nop5[] = { 0x0F, 0x1F, 0x44, 0x00, 0x00 };
    static const uint8_t nop6[] = { 0x66, 0x0F, 0x1F, 0x44, 0x00, 0x00 };
    static const uint8_t nop7[] = { 0x0F, 0x1F, 0x80, 0x00, 0x00, 0x00, 0x00 };
    static const uint8_t nop8[] = { 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
    static const uint8_t nop9[] = { 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };

    // AMD.
    static const uint8_t nop10[] = { 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };
    static const uint8_t nop11[] = { 0x66, 0x66, 0x66, 0x0F, 0x1F, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00 };

    const uint8_t* p;
    sysint_t n;

    if (ci->vendorId == CPU_VENDOR_INTEL && 
       ((ci->family & 0x0F) == 6 || 
        (ci->family & 0x0F) == 15)
       )
    {
      do {
        switch (i)
        {
          case  1: p = nop1; n = 1; break;
          case  2: p = nop2; n = 2; break;
          case  3: p = nop3; n = 3; break;
          case  4: p = nop4; n = 4; break;
          case  5: p = nop5; n = 5; break;
          case  6: p = nop6; n = 6; break;
          case  7: p = nop7; n = 7; break;
          case  8: p = nop8; n = 8; break;
          default: p = nop9; n = 9; break;
        }

        i -= n;
        do { _emitByte(*p++); } while(--n);
      } while (i);

      return;
    }

    if (ci->vendorId == CPU_VENDOR_AMD && 
        ci->family >= 0x0F)
    {
      do {
        switch (i)
        {
          case  1: p = nop1 ; n =  1; break;
          case  2: p = nop2 ; n =  2; break;
          case  3: p = nop3 ; n =  3; break;
          case  4: p = nop4 ; n =  4; break;
          case  5: p = nop5 ; n =  5; break;
          case  6: p = nop6 ; n =  6; break;
          case  7: p = nop7 ; n =  7; break;
          case  8: p = nop8 ; n =  8; break;
          case  9: p = nop9 ; n =  9; break;
          case 10: p = nop10; n = 10; break;
          default: p = nop11; n = 11; break;
        }

        i -= n;
        do { _emitByte(*p++); } while(--n);
      } while (i);

      return;
    }
#if defined(ASMJIT_X86)
    // legacy NOPs, 0x90 with 0x66 prefix.
    do {
      switch (i)
      {
        default: _emitByte(0x66); i--;
        case  3: _emitByte(0x66); i--;
        case  2: _emitByte(0x66); i--;
        case  1: _emitByte(0x90); i--;
      }
    } while(i);
#endif
  }

  // legacy NOPs, only 0x90
  // In 64-bit mode, we can't use 0x66 prefix
  do {
    _emitByte(0x90);
  } while(--i);
}

// ============================================================================
// [AsmJit::AssemblerCore - Label]
// ============================================================================

Label AssemblerCore::newLabel()
{
  Label label;
  label._base.id = (uint32_t)_labelData.getLength() | OPERAND_ID_TYPE_LABEL;

  LabelData l_data;
  l_data.offset = -1;
  l_data.links = NULL;
  _labelData.append(l_data);

  return label;
}

void AssemblerCore::registerLabels(sysuint_t count)
{
  // Duplicated newLabel() code, but we are not creating Label instances.
  LabelData l_data;
  l_data.offset = -1;
  l_data.links = NULL;

  for (sysuint_t i = 0; i < count; i++) _labelData.append(l_data);
}

void AssemblerCore::bind(const Label& label)
{
  // Only labels created by newLabel() can be used by Assembler.
  ASMJIT_ASSERT(label.getId() != INVALID_VALUE);
  // Never go out of bounds.
  ASMJIT_ASSERT((label.getId() & OPERAND_ID_VALUE_MASK) < _labelData.getLength());

  // Get label data based on label id.
  LabelData& l_data = _labelData[label.getId() & OPERAND_ID_VALUE_MASK];

  // Label can be bound only once.
  ASMJIT_ASSERT(l_data.offset == -1);

  // Log.
  if (_logger) _logger->logFormat("L.%u:\n", (uint32_t)label.getId() & OPERAND_ID_VALUE_MASK);

  sysint_t pos = getOffset();

  LabelLink* link = l_data.links;
  LabelLink* prev = NULL;

  while (link)
  {
    sysint_t offset = link->offset;

    if (link->relocId != -1)
    {
      // If linked label points to RelocData then instead of writing relative
      // displacement to assembler stream, we will write it to RelocData.
      _relocData[link->relocId].destination += pos;
    }
    else
    {
      // Not using relocId, this means that we overwriting real displacement
      // in assembler stream.
      int32_t patchedValue = (int32_t)(pos - offset + link->displacement);
      uint32_t size = getByteAt(offset);

      // Only these size specifiers are allowed.
      ASMJIT_ASSERT(size == 1 || size == 4);

      if (size == 4)
      {
        setInt32At(offset, patchedValue);
      }
      else // if (size == 1)
      {
        if (Util::isInt8(patchedValue))
        {
          setByteAt(offset, (uint8_t)(int8_t)patchedValue);
        }
        else
        {
          // Fatal error.
          setError(ERROR_ILLEGAL_SHORT_JUMP);
        }
      }
    }

    prev = link->prev;
    link = prev;
  }

  // Chain unused links.
  link = l_data.links;
  if (link)
  {
    if (prev == NULL) prev = link;

    prev->prev = _unusedLinks;
    _unusedLinks = link;
  }

  // Unlink label if it was linked.
  l_data.offset = pos;
  l_data.links = NULL;
}

// ============================================================================
// [AsmJit::AssemblerCore - Make]
// ============================================================================

void* AssemblerCore::make()
{
  // Do nothing on error state or when no instruction was emitted.
  if (_error || getCodeSize() == 0)
    return NULL;

  void* p;
  _error = _codeGenerator->generate(&p, reinterpret_cast<Assembler*>(this));
  return p;
}

// ============================================================================
// [AsmJit::AssemblerCore - Links]
// ============================================================================

AssemblerCore::LabelLink* AssemblerCore::_newLabelLink()
{
  LabelLink* link = _unusedLinks;

  if (link)
  {
    _unusedLinks = link->prev;
  }
  else
  {
    link = (LabelLink*)_zone.zalloc(sizeof(LabelLink));
    if (link == NULL) return NULL;
  }

  // clean link
  link->prev = NULL;
  link->offset = 0;
  link->displacement = 0;
  link->relocId = -1;

  return link;
}

// ============================================================================
// [AsmJit::Assembler - Construction / Destruction]
// ============================================================================

Assembler::Assembler(CodeGenerator* codeGenerator) :
  AssemblerIntrinsics(codeGenerator)
{
}

Assembler::~Assembler()
{
}

} // AsmJit namespace


#include "ApiEnd.h"    // [Api-End]

```

`AsmJit/AssemblerX86X64.h`:

```h

#ifndef _ASMJIT_ASSEMBLERX86X64_H
#define _ASMJIT_ASSEMBLERX86X64_H

#if !defined(_ASMJIT_ASSEMBLER_H)
#warning "AsmJit/AssemblerX86X64.h can be only included by AsmJit/Assembler.h"
#endif

#include "Build.h"
#include "Defs.h"
#include "Operand.h"
#include "Util.h"

#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

struct CodeGenerator;

// ============================================================================
// [AsmJit::AssemblerCore]
// ============================================================================

//! @brief AssemblerCore is part of @c Assembler class.
//!
//! @c AssemblerCore class implements part of assembler serializing API. The
//! reason why @c Assembler class was split is that we want to hide exported
//! symbols in dynamically linked libraries.
//!
//! Please always use @c Assembler class instead.
//!
//! @sa @c Assembler.
struct ASMJIT_API AssemblerCore
{
  AssemblerCore(CodeGenerator* codeGenerator);
  virtual ~AssemblerCore();

  struct LabelLink  // Used to link linked-labels.
  {
    LabelLink* prev;
    sysint_t offset;
    sysint_t displacement;  // Inlined displacement.
    sysint_t relocId;       // RelocId if link must be absolute when relocated.
  };

  struct LabelData
  {
    sysint_t offset;
    LabelLink* links;       // Label links chain.
  };

  // --------------------------------------------------------------------------
  // [RelocData]
  // --------------------------------------------------------------------------

  // X86 architecture uses 32-bit absolute addressing model by memory operands,
  // but 64-bit mode uses relative addressing model (RIP + displacement). In
  // code we are always using relative addressing model for referencing labels
  // and embedded data. In 32-bit mode we must patch all references to absolute
  // address before we can call generated function. We are patching only memory
  // operands.

  //! @brief Code relocation data (relative vs absolute addresses).
  struct RelocData
  {
    enum Type
    {
      ABSOLUTE_TO_ABSOLUTE = 0,
      RELATIVE_TO_ABSOLUTE = 1,
      ABSOLUTE_TO_RELATIVE = 2,
      ABSOLUTE_TO_RELATIVE_TRAMPOLINE = 3
    };

    //! @brief Type of relocation.
    uint32_t type;

    //! @brief Size of relocation (4 or 8 bytes).
    uint32_t size;

    //! @brief Offset from code begin address.
    sysint_t offset;

    //! @brief Relative displacement or absolute address.
    union
    {
      //! @brief Relative displacement from code begin address (not to @c offset).
      sysint_t destination;
      //! @brief Absolute address where to jump;
      void* address;
    };
  };

  // --------------------------------------------------------------------------
  // [Code Generator]
  // --------------------------------------------------------------------------

  //! @brief Get code generator.
  inline CodeGenerator* getCodeGenerator() const { return _codeGenerator; }

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

  //! @brief Get zone memory manager.
  inline Zone& getZone() ASMJIT_NOTHROW { return _zone; }

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  //! @brief Get logger.
  inline Logger* getLogger() const ASMJIT_NOTHROW { return _logger; }

  //! @brief Set logger to @a logger.
  virtual void setLogger(Logger* logger) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Error Handling]
  // --------------------------------------------------------------------------

  //! @brief Get error code.
  inline uint32_t getError() const ASMJIT_NOTHROW { return _error; }

  //! @brief Set error code.
  //!
  //! This method is virtual, because higher classes can use it to catch all
  //! errors.
  virtual void setError(uint32_t error) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Properties]
  // --------------------------------------------------------------------------

  //! @brief Get assembler property.
  uint32_t getProperty(uint32_t propertyId);
  //! @brief Set assembler property.
  void setProperty(uint32_t propertyId, uint32_t value);

  // --------------------------------------------------------------------------
  // [Buffer Getters / Setters]
  // --------------------------------------------------------------------------

  //! @brief Return start of assembler code buffer.
  //!
  //! Note that buffer address can change if you emit instruction or something
  //! else. Use this pointer only when you finished or make sure you do not
  //! use returned pointer after emitting.
  inline uint8_t* getCode() const ASMJIT_NOTHROW
  { return _buffer.getData(); }

  //! @brief Ensure space for next instruction.
  //!
  //! Note that this method can return false. It's rare and probably you never
  //! get this, but in some situations it's still possible.
  inline bool ensureSpace() ASMJIT_NOTHROW
  { return _buffer.ensureSpace(); }

  //! @brief Return current offset in buffer).
  inline sysint_t getOffset() const ASMJIT_NOTHROW
  { return _buffer.getOffset(); }

  //! @brief Return current offset in buffer (same as getCffset() + getTramplineSize()).
  inline sysint_t getCodeSize() const ASMJIT_NOTHROW
  { return _buffer.getOffset() + getTrampolineSize(); }

  //! @brief Get size of all possible trampolines needed to successfuly generate
  //! relative jumps to absolute addresses. This value is only non-zero if jmp
  //! of call instructions were used with immediate operand (this means jump or
  //! call absolute address directly).
  //!
  //! Currently only _emitJmpOrCallReloc() method can increase trampoline size
  //! value.
  inline sysint_t getTrampolineSize() const ASMJIT_NOTHROW
  { return _trampolineSize; }

  //! @brief Set offset to @a o and returns previous offset.
  //!
  //! This method can be used to truncate code (previous offset is not
  //! recorded) or to overwrite instruction stream at position @a o.
  //!
  //! @return Previous offset value that can be uset to set offset back later.
  inline sysint_t toOffset(sysint_t o) ASMJIT_NOTHROW
  { return _buffer.toOffset(o); }

  //! @brief Get capacity of internal code buffer.
  inline sysint_t getCapacity() const ASMJIT_NOTHROW
  { return _buffer.getCapacity(); }

  //! @brief Clear everything, but not deallocate buffers.
  void clear() ASMJIT_NOTHROW;

  //! @brief Free internal buffer and NULL all pointers.
  void free() ASMJIT_NOTHROW;

  //简短的带内部代码缓冲和空所有指针(你把所有权)。  汇编代码的指针比如55 74 07
  //! @brief Take internal code buffer and NULL all pointers (you take the ownership).
  uint8_t* takeCode() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Stream Setters / Getters]
  // --------------------------------------------------------------------------

  //! @brief Set byte at position @a pos.
  inline uint8_t getByteAt(sysint_t pos) const ASMJIT_NOTHROW
  { return _buffer.getByteAt(pos); }
  
  //! @brief Set word at position @a pos.
  inline uint16_t getWordAt(sysint_t pos) const ASMJIT_NOTHROW
  { return _buffer.getWordAt(pos); }
  
  //! @brief Set word at position @a pos.
  inline uint32_t getDWordAt(sysint_t pos) const ASMJIT_NOTHROW
  { return _buffer.getDWordAt(pos); }
  
  //! @brief Set word at position @a pos.
  inline uint64_t getQWordAt(sysint_t pos) const ASMJIT_NOTHROW
  { return _buffer.getQWordAt(pos); }

  //! @brief Set byte at position @a pos.
  inline void setByteAt(sysint_t pos, uint8_t x) ASMJIT_NOTHROW
  { _buffer.setByteAt(pos, x); }
  
  //! @brief Set word at position @a pos.
  inline void setWordAt(sysint_t pos, uint16_t x) ASMJIT_NOTHROW
  { _buffer.setWordAt(pos, x); }
  
  //! @brief Set word at position @a pos.
  inline void setDWordAt(sysint_t pos, uint32_t x) ASMJIT_NOTHROW
  { _buffer.setDWordAt(pos, x); }
  
  //! @brief Set word at position @a pos.
  inline void setQWordAt(sysint_t pos, uint64_t x) ASMJIT_NOTHROW
  { _buffer.setQWordAt(pos, x); }

  //! @brief Set word at position @a pos.
  inline int32_t getInt32At(sysint_t pos) const ASMJIT_NOTHROW
  { return (int32_t)_buffer.getDWordAt(pos); }
  
  //! @brief Set int32 at position @a pos.
  inline void setInt32At(sysint_t pos, int32_t x) ASMJIT_NOTHROW
  { _buffer.setDWordAt(pos, (int32_t)x); }

  //! @brief Set custom variable @a imm at position @a pos.
  //!
  //! @note This function is used to patch existing code.
  void setVarAt(sysint_t pos, sysint_t i, uint8_t isUnsigned, uint32_t size) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Assembler Emitters]
  //
  // These emitters are not protecting buffer from overrun, this must be 
  // done is emitX86() methods by:
  //   if (!canEmit()) return;
  // --------------------------------------------------------------------------

  //! @brief Get whether next instruction can be emitted.
  //!
  //! This function behaves like @c ensureSpace(), but it also checks if
  //! assembler is in error state and in that case it returns @c false.
  //! Assembler internally always uses this function before new instruction is
  //! emitted.
  //!
  //! It's implemented like:
  //!   <code>return ensureSpace() && !getError();</code>
  bool canEmit() ASMJIT_NOTHROW;

  //! @brief Emit Byte to internal buffer.
  inline void _emitByte(uint8_t x) ASMJIT_NOTHROW
  { _buffer.emitByte(x); }

  //! @brief Emit Word (2 bytes) to internal buffer.
  inline void _emitWord(uint16_t x) ASMJIT_NOTHROW
  { _buffer.emitWord(x); }

  //! @brief Emit DWord (4 bytes) to internal buffer.
  inline void _emitDWord(uint32_t x) ASMJIT_NOTHROW
  { _buffer.emitDWord(x); }

  //! @brief Emit QWord (8 bytes) to internal buffer.
  inline void _emitQWord(uint64_t x) ASMJIT_NOTHROW
  { _buffer.emitQWord(x); }

  //! @brief Emit Int32 (4 bytes) to internal buffer.
  inline void _emitInt32(int32_t x) ASMJIT_NOTHROW
  { _buffer.emitDWord((uint32_t)x); }

  //! @brief Emit system signed integer (4 or 8 bytes) to internal buffer.
  inline void _emitSysInt(sysint_t x) ASMJIT_NOTHROW
  { _buffer.emitSysInt(x); }

  //! @brief Emit system unsigned integer (4 or 8 bytes) to internal buffer.
  inline void _emitSysUInt(sysuint_t x) ASMJIT_NOTHROW
  { _buffer.emitSysUInt(x); }

  //! @brief Emit single @a opCode without operands.
  inline void _emitOpCode(uint32_t opCode) ASMJIT_NOTHROW
  {
    // instruction prefix
    if (opCode & 0xFF000000) _emitByte((uint8_t)((opCode & 0xFF000000) >> 24));
    // instruction opcodes
    if (opCode & 0x00FF0000) _emitByte((uint8_t)((opCode & 0x00FF0000) >> 16));
    if (opCode & 0x0000FF00) _emitByte((uint8_t)((opCode & 0x0000FF00) >>  8));
    // last opcode is always emitted (can be also 0x00)
    _emitByte((uint8_t)(opCode & 0x000000FF));
  }

  //! @brief Emit CS (code segmend) prefix.
  //!
  //! Behavior of this function is to emit code prefix only if memory operand
  //! address uses code segment. Code segment is used through memory operand
  //! with attached @c AsmJit::Label.
  void _emitSegmentPrefix(const Operand& rm) ASMJIT_NOTHROW;

  //! @brief Emit MODR/M byte.
  inline void _emitMod(uint8_t m, uint8_t o, uint8_t r) ASMJIT_NOTHROW
  { _emitByte(((m & 0x03) << 6) | ((o & 0x07) << 3) | (r & 0x07)); }

  //! @brief Emit SIB byte.
  inline void _emitSib(uint8_t s, uint8_t i, uint8_t b) ASMJIT_NOTHROW
  { _emitByte(((s & 0x03) << 6) | ((i & 0x07) << 3) | (b & 0x07)); }

  //! @brief Emit REX prefix (64-bit mode only).
  inline void _emitRexR(uint8_t w, uint8_t opReg, uint8_t regCode, bool forceRexPrefix) ASMJIT_NOTHROW
  {
#if defined(ASMJIT_X64)
    uint8_t r = (opReg & 0x8) != 0;
    uint8_t b = (regCode & 0x8) != 0;

    // w Default operand size(0=Default, 1=64-bit).
    // r Register field (1=high bit extension of the ModR/M REG field).
    // x Index field not used in RexR
    // b Base field (1=high bit extension of the ModR/M or SIB Base field).
    if (w || r || b || forceRexPrefix)
    {
      _emitByte(0x40 | (w << 3) | (r << 2) | b);
    }
#else
    ASMJIT_UNUSED(w);
    ASMJIT_UNUSED(opReg);
    ASMJIT_UNUSED(regCode);
    ASMJIT_UNUSED(forceRexPrefix);
#endif // ASMJIT_X64
  }

  //! @brief Emit REX prefix (64-bit mode only).
  inline void _emitRexRM(uint8_t w, uint8_t opReg, const Operand& rm, bool forceRexPrefix) ASMJIT_NOTHROW
  {
#if defined(ASMJIT_X64)
    uint8_t r = (opReg & 0x8) != 0;
    uint8_t x = 0;
    uint8_t b = 0;

    if (rm.isReg())
    {
      b = (reinterpret_cast<const BaseReg&>(rm).getRegCode() & 0x8) != 0;
    }
    else if (rm.isMem())
    {
      x = ((reinterpret_cast<const Mem&>(rm).getIndex() & 0x8) != 0) & (reinterpret_cast<const Mem&>(rm).getIndex() != INVALID_VALUE);
      b = ((reinterpret_cast<const Mem&>(rm).getBase()  & 0x8) != 0) & (reinterpret_cast<const Mem&>(rm).getBase()  != INVALID_VALUE);
    }

    // w Default operand size(0=Default, 1=64-bit).
    // r Register field (1=high bit extension of the ModR/M REG field).
    // x Index field (1=high bit extension of the SIB Index field).
    // b Base field (1=high bit extension of the ModR/M or SIB Base field).
    if (w || r || x || b || forceRexPrefix)
    {
      _emitByte(0x40 | (w << 3) | (r << 2) | (x << 1) | b);
    }
#else
    ASMJIT_UNUSED(w);
    ASMJIT_UNUSED(opReg);
    ASMJIT_UNUSED(rm);
#endif // ASMJIT_X64
  }

  //! @brief Emit Register / Register - calls _emitMod(3, opReg, r)
  inline void _emitModR(uint8_t opReg, uint8_t r) ASMJIT_NOTHROW
  { _emitMod(3, opReg, r); }

  //! @brief Emit Register / Register - calls _emitMod(3, opReg, r.code())
  inline void _emitModR(uint8_t opReg, const BaseReg& r) ASMJIT_NOTHROW
  { _emitMod(3, opReg, r.getRegCode()); }

  //! @brief Emit register / memory address combination to buffer.
  //!
  //! This method can hangle addresses from simple to complex ones with
  //! index and displacement.
  void _emitModM(uint8_t opReg, const Mem& mem, sysint_t immSize) ASMJIT_NOTHROW;

  //! @brief Emit Reg<-Reg or Reg<-Reg|Mem ModRM (can be followed by SIB 
  //! and displacement) to buffer.
  //!
  //! This function internally calls @c _emitModM() or _emitModR() that depends
  //! to @a op type.
  //!
  //! @note @a opReg is usually real register ID (see @c R) but some instructions
  //! have specific format and in that cases @a opReg is part of opcode.
  void _emitModRM(uint8_t opReg, const Operand& op, sysint_t immSize) ASMJIT_NOTHROW;

  //! @brief Emit instruction where register is inlined to opcode.
  void _emitX86Inl(uint32_t opCode, uint8_t i16bit, uint8_t rexw, uint8_t reg, bool forceRexPrefix) ASMJIT_NOTHROW;

  //! @brief Emit instruction with reg/memory operand.
  void _emitX86RM(uint32_t opCode, uint8_t i16bit, uint8_t rexw, uint8_t o,
    const Operand& op, sysint_t immSize, bool forceRexPrefix) ASMJIT_NOTHROW;

  //! @brief Emit FPU instruction with no operands.
  void _emitFpu(uint32_t opCode) ASMJIT_NOTHROW;

  //! @brief Emit FPU instruction with one operand @a sti (index of FPU register).
  void _emitFpuSTI(uint32_t opCode, uint32_t sti) ASMJIT_NOTHROW;

  //! @brief Emit FPU instruction with one operand @a opReg and memory operand @a mem.
  void _emitFpuMEM(uint32_t opCode, uint8_t opReg, const Mem& mem) ASMJIT_NOTHROW;

  //! @brief Emit MMX/SSE instruction.
  void _emitMmu(uint32_t opCode, uint8_t rexw, uint8_t opReg, const Operand& src,
    sysint_t immSize) ASMJIT_NOTHROW;

  //! @brief Emit displacement.
  LabelLink* _emitDisplacement(LabelData& l_data, sysint_t inlinedDisplacement, int size) ASMJIT_NOTHROW;

  //! @brief Emit relative relocation to absolute pointer @a target. It's needed
  //! to add what instruction is emitting this, because in x64 mode the relative
  //! displacement can be impossible to calculate and in this case the trampoline
  //! is used.
  void _emitJmpOrCallReloc(uint32_t instruction, void* target) ASMJIT_NOTHROW;

  // Helpers to decrease binary code size. These four emit methods are just
  // helpers thats used by assembler. They call emitX86() adding NULLs
  // to first, second and third operand, if needed.

  //! @brief Emit X86/FPU or MM/XMM instruction.
  void _emitInstruction(uint32_t code) ASMJIT_NOTHROW;

  //! @brief Emit X86/FPU or MM/XMM instruction.
  void _emitInstruction(uint32_t code, const Operand* o0) ASMJIT_NOTHROW;

  //! @brief Emit X86/FPU or MM/XMM instruction.
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1) ASMJIT_NOTHROW;

  //! @brief Emit X86/FPU or MM/XMM instruction.
  //!
  //! Operands @a o1, @a o2 or @a o3 can be @c NULL if they are not used.
  //!
  //! Hint: Use @c emitX86() helpers to emit instructions.
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2) ASMJIT_NOTHROW;

  //! @brief Private method for emitting jcc.
  void _emitJcc(uint32_t code, const Label* label, uint32_t hint) ASMJIT_NOTHROW;

  //! @brief Private method for emitting short jcc.
  inline void _emitShortJcc(uint32_t code, const Label* label, uint32_t hint)
  {
    _emitOptions |= EMIT_OPTION_SHORT_JUMP;
    _emitJcc(code, label, hint);
  }

  // --------------------------------------------------------------------------
  // [Relocation helpers]
  // --------------------------------------------------------------------------

  //介绍一个给定的地址的DST移居他处代码。
  //! @brief Relocate code to a given address @a dst.
  //!
  //参数测试的代码应该我存储迁移。指针可以返回的虚拟内存分配的地址或地址如果你自己
  //! @param dst Where the relocated code should me stored. The pointer can be
  //返回的地址，如果你的虚拟内存分配器或您自己的地址
  //! address returned by virtual memory allocator or your own address if you
  //只是想存储代码,以备重用 
  //! want only to store the code for later reuse (or load, etc...).
  //param addressBase 用于搬迁的基址。当使用 JIT 代码
  //! @param addressBase Base address used for relocation. When using JIT code
  //! generation, this will be the same as @a dst, only casted to system
  //! integer type. But when generating code for remote process then the value
  //! can be different.
  //!
  //! @retval The bytes used. Code-generator can create trampolines which are
  //! used when calling other functions inside the JIT code. However, these
  //! trampolines can be unused so the relocCode() returns the exact size needed
  //! for the function.
  //!
  //! A given buffer will be overwritten, to get number of bytes required use
  //! @c getCodeSize() .
  virtual sysuint_t relocCode(void* dst, sysuint_t addressBase) const ASMJIT_NOTHROW;

  //! @brief Simplifed version of @c relocCode() method.
  inline sysuint_t relocCode(void* dst) const ASMJIT_NOTHROW
  {
    return relocCode(dst, (sysuint_t)dst);
  }

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  //简短的数据嵌入到指令流
  //! @brief Embed data into instruction stream.
  void embed(const void* data, sysuint_t length) ASMJIT_NOTHROW;
  //简要嵌入绝对标签指针（4或8字节）。
  //! @brief Embed absolute label pointer (4 or 8 bytes).
  void embedLabel(const Label& label) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Align]
  // --------------------------------------------------------------------------

  //简短的对齐目标缓冲区@a m字节。
  //! @brief Align target buffer to @a m bytes.
  //!
  //这是典型的使用对齐标签开始的内部循环。
  //! Typical usage of this is to align labels at start of the inner loops.
  //!
  //插入@c nop()指示或CPU优化空操作
  //! Inserts @c nop() instructions or CPU optimized NOPs.
  void align(uint32_t m) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Label]
  // --------------------------------------------------------------------------

  //介绍创建并返回新的标签
  //! @brief Create and return new label.
  Label newLabel() ASMJIT_NOTHROW;

  //简短的注册标签（用于通过@ C编译器） 
  //! @brief Register labels (used by @c Compiler).
  void registerLabels(sysuint_t count) ASMJIT_NOTHROW;

  //简短的绑定标签的电流偏移
  //! @brief Bind label to the current offset.
  //!
  //注释标签只能绑定一次！
  //! @note Label can be bound only once!
  void bind(const Label& label) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Make]
  // --------------------------------------------------------------------------

  //简作方便的方法使目前的序列化代码
  //! @brief Make is convenience method to make currently serialized code and
  //返回指向生成的函数
  //! return pointer to generated function.
  //!
  //你需要的只是把这个函数指针类型并调用 
  //! What you need is only to cast this pointer to your function type and call
  //请注意如果有错误我们调用getError()方法
  //! it. Note that if there was an error and calling @c getError() method not
  //返回@ Ç ERROR_NONE （零），此函数总是返回@ C NULL
  //! returns @c ERROR_NONE (zero) then this function always return @c NULL and
  //误差值是相同的。 
  //! error value remains the same.
  virtual void* make() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Links]
  // --------------------------------------------------------------------------

  LabelLink* _newLabelLink() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //简短的区域内存管理
  //! @brief Zone memory management.
  Zone _zone;

  //简短代码生成器实例
  //! @brief Code generator instance.
  CodeGenerator* _codeGenerator;

  //简短的记录器
  //! @brief Logger.
  Logger* _logger;

  //简短的上一个错误代码。
  //! @brief Last error code.
  uint32_t _error;

  //简短的属性
  //! @brief Properties.
  uint32_t _properties;

  //简短的下一条指令（清除后发出）发出标志。
  //! @brief Emit flags for next instruction (cleared after emit).
  uint32_t _emitOptions;

  //简短的二进制代码的缓冲区。
  //! @brief Binary code buffer.
  Buffer _buffer;

  //简短的尺寸可能蹦床
  //! @brief Size of possible trampolines.
  sysint_t _trampolineSize;

  //@简述未使用的链接@C LabelLink *结构的链表）
  //! @brief Linked list of unused links (@c LabelLink* structures)
  LabelLink* _unusedLinks;

  //简短的标签数据
  //! @brief Labels data.
  PodVector<LabelData> _labelData;

  //简短的重定位数据
  //! @brief Relocations data.
  PodVector<RelocData> _relocData;

  //简短的评论，将记录下发出的指令 后
  //! @brief Comment that will be logger by next emitted instruction. After
  //指令是日志记录器评论被设置为NULL
  //! instruction is logger the _comment is set to NULL.
  const char* _comment;

  friend struct CompilerCore;
  friend struct EInstruction;
};

// ============================================================================
// [AsmJit::AssemblerIntrinsics]
// ============================================================================

//! @brief AssemblerIntrinsics is part of @c Assembler class.
//!
//! @c AssemblerIntrinsics class implements part of assembler serializing API.
//! The reason why @c Assembler class was split is that we want to hide exported
//! symbols in dynamically linked libraries.
//!
//! Please always use @c Assembler class instead.
//!
//! @sa @c Assembler.
struct ASMJIT_HIDDEN AssemblerIntrinsics : public AssemblerCore
{
  inline AssemblerIntrinsics(CodeGenerator* codeGenerator) : AssemblerCore(codeGenerator)
  {
  }

  //! @brief Add 8-bit integer data to the instuction stream.
  inline void db(uint8_t  x) ASMJIT_NOTHROW { embed(&x, 1); }
  //! @brief Add 16-bit integer data to the instuction stream.
  inline void dw(uint16_t x) ASMJIT_NOTHROW { embed(&x, 2); }
  //! @brief Add 32-bit integer data to the instuction stream.
  inline void dd(uint32_t x) ASMJIT_NOTHROW { embed(&x, 4); }
  //! @brief Add 64-bit integer data to the instuction stream.
  inline void dq(uint64_t x) ASMJIT_NOTHROW { embed(&x, 8); }

  //! @brief Add 8-bit integer data to the instuction stream.
  inline void dint8(int8_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int8_t)); }
  //! @brief Add 8-bit integer data to the instuction stream.
  inline void duint8(uint8_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint8_t)); }

  //! @brief Add 16-bit integer data to the instuction stream.
  inline void dint16(int16_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int16_t)); }
  //! @brief Add 16-bit integer data to the instuction stream.
  inline void duint16(uint16_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint16_t)); }

  //! @brief Add 32-bit integer data to the instuction stream.
  inline void dint32(int32_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int32_t)); }
  //! @brief Add 32-bit integer data to the instuction stream.
  inline void duint32(uint32_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint32_t)); }

  //! @brief Add 64-bit integer data to the instuction stream.
  inline void dint64(int64_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int64_t)); }
  //! @brief Add 64-bit integer data to the instuction stream.
  inline void duint64(uint64_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint64_t)); }

  //! @brief Add system-integer data to the instuction stream.
  inline void dsysint(sysint_t x) ASMJIT_NOTHROW { embed(&x, sizeof(sysint_t)); }
  //! @brief Add system-integer data to the instuction stream.
  inline void dsysuint(sysuint_t x) ASMJIT_NOTHROW { embed(&x, sizeof(sysuint_t)); }

  //! @brief Add float data to the instuction stream.
  inline void dfloat(float x) ASMJIT_NOTHROW { embed(&x, sizeof(float)); }
  //! @brief Add double data to the instuction stream.
  inline void ddouble(double x) ASMJIT_NOTHROW { embed(&x, sizeof(double)); }

  //! @brief Add pointer data to the instuction stream.
  inline void dptr(void* x) ASMJIT_NOTHROW { embed(&x, sizeof(void*)); }

  //! @brief Add MM data to the instuction stream.
  inline void dmm(const MMData& x) ASMJIT_NOTHROW { embed(&x, sizeof(MMData)); }
  //! @brief Add XMM data to the instuction stream.
  inline void dxmm(const XMMData& x) ASMJIT_NOTHROW { embed(&x, sizeof(XMMData)); }

  //! @brief Add data to the instuction stream.
  inline void data(const void* data, sysuint_t size) ASMJIT_NOTHROW { embed(data, size); }

  //! @brief Add data in a given structure instance to the instuction stream.
  template<typename T>
  inline void dstruct(const T& x) ASMJIT_NOTHROW { embed(&x, sizeof(T)); }

  // --------------------------------------------------------------------------
  // [X86 Instructions]
  // --------------------------------------------------------------------------

  //! @brief Add with Carry.
  inline void adc(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }

  //! @brief Add.
  inline void add(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }

  //! @brief Logical And.
  inline void and_(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }

  //! @brief Bit Scan Forward.
  inline void bsf(const GPReg& dst, const GPReg& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSF, &dst, &src);
  }
  //! @brief Bit Scan Forward.
  inline void bsf(const GPReg& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSF, &dst, &src);
  }

  //! @brief Bit Scan Reverse.
  inline void bsr(const GPReg& dst, const GPReg& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSR, &dst, &src);
  }
  //! @brief Bit Scan Reverse.
  inline void bsr(const GPReg& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSR, &dst, &src);
  }

  //! @brief Byte swap (32-bit or 64-bit registers only) (i486).
  inline void bswap(const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.getRegType() == REG_TYPE_GPD || dst.getRegType() == REG_TYPE_GPQ);
    _emitInstruction(INST_BSWAP, &dst);
  }

  //! @brief Bit test.
  inline void bt(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }

  //! @brief Bit test and complement.
  inline void btc(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }

  //! @brief Bit test and reset.
  inline void btr(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }

  //! @brief Bit test and set.
  inline void bts(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }

  //! @brief Call Procedure.
  inline void call(const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPN));
    _emitInstruction(INST_CALL, &dst);
  }
  //! @brief Call Procedure.
  inline void call(const Mem& dst)
  {
    _emitInstruction(INST_CALL, &dst);
  }
  //! @brief Call Procedure.
  inline void call(const Imm& dst)
  {
    _emitInstruction(INST_CALL, &dst);
  }
  //! @brief Call Procedure.
  //! @overload
  inline void call(void* dst)
  {
    Imm imm((sysint_t)dst);
    _emitInstruction(INST_CALL, &imm);
  }

  //! @brief Call Procedure.
  inline void call(const Label& label)
  {
    _emitInstruction(INST_CALL, &label);
  }

  //! @brief Convert Byte to Word (Sign Extend).
  //!
  //! AX <- Sign Extend AL
  inline void cbw()
  {
    _emitInstruction(INST_CBW);
  }

  //! @brief Convert Word to DWord (Sign Extend).
  //!
  //! EAX <- Sign Extend AX
  inline void cwde()
  {
    _emitInstruction(INST_CWDE);
  }

#if defined(ASMJIT_X64)
  //! @brief Convert DWord to QWord (Sign Extend).
  //!
  //! RAX <- Sign Extend EAX
  inline void cdqe()
  {
    _emitInstruction(INST_CDQE);
  }
#endif // ASMJIT_X64

  //! @brief Clear Carry flag
  //!
  //! This instruction clears the CF flag in the EFLAGS register.
  inline void clc()
  {
    _emitInstruction(INST_CLC);
  }

  //! @brief Clear Direction flag
  //!
  //! This instruction clears the DF flag in the EFLAGS register.
  inline void cld()
  {
    _emitInstruction(INST_CLD);
  }

  //! @brief Complement Carry Flag.
  //!
  //! This instruction complements the CF flag in the EFLAGS register.
  //! (CF = NOT CF)
  inline void cmc()
  {
    _emitInstruction(INST_CMC);
  }

  //! @brief Conditional Move.
  inline void cmov(CONDITION cc, const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(ConditionToInstruction::toCMovCC(cc), &dst, &src);
  }

  //! @brief Conditional Move.
  inline void cmov(CONDITION cc, const GPReg& dst, const Mem& src)
  {
    _emitInstruction(ConditionToInstruction::toCMovCC(cc), &dst, &src);
  }

  //! @brief Conditional Move.
  inline void cmova  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVA  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmova  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVA  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovae (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVAE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovae (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVAE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovb  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVB  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovb  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVB  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovbe (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVBE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovbe (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVBE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovc  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVC  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovc  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVC  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmove  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVE  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmove  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVE  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovg  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVG  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovg  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVG  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovge (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVGE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovge (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVGE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovl  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVL  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovl  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVL  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovle (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVLE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovle (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVLE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovna (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNA , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovna (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNA , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnae(const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNAE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnae(const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNAE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnb (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNB , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnb (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNB , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnbe(const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNBE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnbe(const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNBE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnc (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNC , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnc (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNC , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovne (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovne (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovng (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNG , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovng (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNG , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnge(const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNGE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnge(const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNGE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnl (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNL , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnl (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNL , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnle(const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNLE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnle(const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNLE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovno (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovno (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnp (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNP , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnp (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNP , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovns (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNS , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovns (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNS , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnz (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVNZ , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnz (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVNZ , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovo  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVO  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovo  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVO  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovp  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVP  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovp  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVP  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpe (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVPE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpe (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVPE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpo (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVPO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpo (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVPO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovs  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVS  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovs  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVS  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovz  (const GPReg& dst, const GPReg& src) { _emitInstruction(INST_CMOVZ  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovz  (const GPReg& dst, const Mem& src)   { _emitInstruction(INST_CMOVZ  , &dst, &src); }

  //! @brief Compare Two Operands.
  inline void cmp(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }

  //! @brief Compare and Exchange (i486).
  inline void cmpxchg(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_CMPXCHG, &dst, &src);
  }
  //! @brief Compare and Exchange (i486).
  inline void cmpxchg(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_CMPXCHG, &dst, &src);
  }

  //! @brief Compares the 64-bit value in EDX:EAX with the memory operand (Pentium).
  //!
  //! If the values are equal, then this instruction stores the 64-bit value
  //! in ECX:EBX into the memory operand and sets the zero flag. Otherwise,
  //! this instruction copies the 64-bit memory operand into the EDX:EAX
  //! registers and clears the zero flag.
  inline void cmpxchg8b(const Mem& dst)
  {
    _emitInstruction(INST_CMPXCHG8B, &dst);
  }

#if defined(ASMJIT_X64)
  //! @brief Compares the 128-bit value in RDX:RAX with the memory operand (X64).
  //!
  //! If the values are equal, then this instruction stores the 128-bit value
  //! in RCX:RBX into the memory operand and sets the zero flag. Otherwise,
  //! this instruction copies the 128-bit memory operand into the RDX:RAX
  //! registers and clears the zero flag.
  inline void cmpxchg16b(const Mem& dst)
  {
    _emitInstruction(INST_CMPXCHG16B, &dst);
  }
#endif // ASMJIT_X64

  //! @brief CPU Identification (i486).
  inline void cpuid()
  {
    _emitInstruction(INST_CPUID);
  }

#if defined(ASMJIT_X86)
  //! @brief Decimal adjust AL after addition
  //!
  //! This instruction adjusts the sum of two packed BCD values to create
  //! a packed BCD result.
  //!
  //! @note This instruction is only available in 32-bit mode.
  inline void daa()
  {
    _emitInstruction(INST_DAA);
  }
#endif // ASMJIT_X86

#if defined(ASMJIT_X86)
  //! @brief Decimal adjust AL after subtraction
  //!
  //! This instruction adjusts the result of the subtraction of two packed
  //! BCD values to create a packed BCD result.
  //!
  //! @note This instruction is only available in 32-bit mode.
  inline void das()
  {
    _emitInstruction(INST_DAS);
  }
#endif // ASMJIT_X86

  //! @brief Decrement by 1.
  //! @note This instruction can be slower than sub(dst, 1)
  inline void dec(const GPReg& dst)
  {
    _emitInstruction(INST_DEC, &dst);
  }
  //! @brief Decrement by 1.
  //! @note This instruction can be slower than sub(dst, 1)
  inline void dec(const Mem& dst)
  {
    _emitInstruction(INST_DEC, &dst);
  }

  //! @brief Unsigned divide.
  //!
  //! This instruction divides (unsigned) the value in the AL, AX, or EAX
  //! register by the source operand and stores the result in the AX,
  //! DX:AX, or EDX:EAX registers.
  inline void div(const GPReg& src)
  {
    _emitInstruction(INST_DIV, &src);
  }
  //! @brief Unsigned divide.
  //! @overload
  inline void div(const Mem& src)
  {
    _emitInstruction(INST_DIV, &src);
  }

  //! @brief Make Stack Frame for Procedure Parameters.
  inline void enter(const Imm& imm16, const Imm& imm8)
  {
    _emitInstruction(INST_ENTER, &imm16, &imm8);
  }

  //! @brief Signed divide.
  //!
  //! This instruction divides (signed) the value in the AL, AX, or EAX
  //! register by the source operand and stores the result in the AX,
  //! DX:AX, or EDX:EAX registers.
  inline void idiv(const GPReg& src)
  {
    _emitInstruction(INST_IDIV, &src);
  }
  //! @brief Signed divide.
  //! @overload
  inline void idiv(const Mem& src)
  {
    _emitInstruction(INST_IDIV, &src);
  }

  //! @brief Signed multiply.
  //!
  //! Source operand (in a general-purpose register or memory location)
  //! is multiplied by the value in the AL, AX, or EAX register (depending
  //! on the operand size) and the product is stored in the AX, DX:AX, or
  //! EDX:EAX registers, respectively.
  inline void imul(const GPReg& src)
  {
    _emitInstruction(INST_IMUL, &src);
  }
  //! @overload
  inline void imul(const Mem& src)
  {
    _emitInstruction(INST_IMUL, &src);
  }

  //! @brief Signed multiply.
  //!
  //! Destination operand (the first operand) is multiplied by the source
  //! operand (second operand). The destination operand is a general-purpose
  //! register and the source operand is an immediate value, a general-purpose
  //! register, or a memory location. The product is then stored in the
  //! destination operand location.
  inline void imul(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }
  //! @brief Signed multiply.
  //! @overload
  inline void imul(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }
  //! @brief Signed multiply.
  //! @overload
  inline void imul(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }

  //! @brief Signed multiply.
  //!
  //! source operand (which can be a general-purpose register or a memory
  //! location) is multiplied by the second source operand (an immediate
  //! value). The product is then stored in the destination operand
  //! (a general-purpose register).
  inline void imul(const GPReg& dst, const GPReg& src, const Imm& imm)
  {
    _emitInstruction(INST_IMUL, &dst, &src, &imm);
  }
  //! @overload
  inline void imul(const GPReg& dst, const Mem& src, const Imm& imm)
  {
    _emitInstruction(INST_IMUL, &dst, &src, &imm);
  }

  //! @brief Increment by 1.
  //! @note This instruction can be slower than add(dst, 1)
  inline void inc(const GPReg& dst)
  {
    _emitInstruction(INST_INC, &dst);
  }
  //! @brief Increment by 1.
  //! @note This instruction can be slower than add(dst, 1)
  inline void inc(const Mem& dst)
  {
    _emitInstruction(INST_INC, &dst);
  }

  //! @brief Interrupt 3 - trap to debugger.
  inline void int3()
  {
    _emitInstruction(INST_INT3);
  }

  //! @brief Jump to label @a label if condition @a cc is met.
  //!
  //! This instruction checks the state of one or more of the status flags in
  //! the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the
  //! specified state (condition), performs a jump to the target instruction
  //! specified by the destination operand. A condition code (cc) is associated
  //! with each instruction to indicate the condition being tested for. If the
  //! condition is not satisfied, the jump is not performed and execution
  //! continues with the instruction following the Jcc instruction.
  inline void j(CONDITION cc, const Label& label, uint32_t hint = HINT_NONE)
  {
    _emitJcc(ConditionToInstruction::toJCC(cc), &label, hint);
  }

  //! @brief Jump to label @a label if condition is met.
  inline void ja  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JA  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jae (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JAE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jb  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JB  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jbe (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JBE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jc  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JC  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void je  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JE  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jg  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JG  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jge (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JGE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jl  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JL  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jle (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JLE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jna (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNA , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnae(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNAE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnb (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNB , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnbe(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNBE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnc (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNC , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jne (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jng (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNG , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnge(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNGE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnl (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNL , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnle(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNLE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jno (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNO , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnp (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNP , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jns (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNS , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnz (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNZ , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jo  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JO  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jp  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JP  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jpe (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JPE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jpo (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JPO , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void js  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JS  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jz  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JZ  , &label, hint); }

  //! @brief Short jump to label @a label if condition @a cc is met.
  //! @sa j()
  inline void short_j(CONDITION cc, const Label& label, uint32_t hint = HINT_NONE)
  {
    _emitOptions |= EMIT_OPTION_SHORT_JUMP;
    j(cc, label, hint);
  }

  //! @brief Short jump to label @a label if condition is met.
  inline void short_ja  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JA  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jae (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JAE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jb  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JB  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jbe (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JBE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jc  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JC  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_je  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JE  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jg  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JG  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jge (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JGE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jl  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JL  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jle (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JLE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jna (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNA , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnae(const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNAE, &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnb (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNB , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnbe(const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNBE, &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnc (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNC , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jne (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jng (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNG , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnge(const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNGE, &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnl (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNL , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnle(const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNLE, &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jno (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNO , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnp (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNP , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jns (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNS , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jnz (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JNZ , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jo  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JO  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jp  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JP  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jpe (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JPE , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jpo (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JPO , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_js  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JS  , &label, hint); }
  //! @brief Short jump to label @a label if condition is met.
  inline void short_jz  (const Label& label, uint32_t hint = HINT_NONE) { _emitShortJcc(INST_JZ  , &label, hint); }

  //! @brief Jump.
  //! @overload
  inline void jmp(const GPReg& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }
  //! @brief Jump.
  //! @overload
  inline void jmp(const Mem& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }
  //! @brief Jump.
  //! @overload
  inline void jmp(const Imm& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }

  //! @brief Jump.
  //! @overload
  inline void jmp(void* dst)
  {
    Imm imm((sysint_t)dst);
    _emitInstruction(INST_JMP, &imm);
  }
  
  //! @brief Jump.
  //!
  //! This instruction transfers program control to a different point
  //! in the instruction stream without recording return information.
  //! The destination (target) operand specifies the label of the
  //! instruction being jumped to.
  inline void jmp(const Label& label)
  {
    _emitInstruction(INST_JMP, &label);
  }

  //! @brief Short jump.
  //! @sa jmp()
  inline void short_jmp(const Label& label)
  {
    _emitOptions |= EMIT_OPTION_SHORT_JUMP;
    _emitInstruction(INST_JMP, &label);
  }

  //! @brief Load Effective Address
  //!
  //! This instruction computes the effective address of the second
  //! operand (the source operand) and stores it in the first operand
  //! (destination operand). The source operand is a memory address
  //! (offset part) specified with one of the processors addressing modes.
  //! The destination operand is a general-purpose register.
  inline void lea(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_LEA, &dst, &src);
  }

  //! @brief High Level Procedure Exit.
  inline void leave()
  {
    _emitInstruction(INST_LEAVE);
  }

  //! @brief Move.
  //!
  //! This instruction copies the second operand (source operand) to the first
  //! operand (destination operand). The source operand can be an immediate
  //! value, general-purpose register, segment register, or memory location.
  //! The destination register can be a general-purpose register, segment
  //! register, or memory location. Both operands must be the same size, which
  //! can be a byte, a word, or a DWORD.
  //!
  //! @note To move MMX or SSE registers to/from GP registers or memory, use
  //! corresponding functions: @c movd(), @c movq(), etc. Passing MMX or SSE
  //! registers to @c mov() is illegal.
  inline void mov(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move from segment register.
  //! @overload.
  inline void mov(const GPReg& dst, const SegmentReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move from segment register.
  //! @overload.
  inline void mov(const Mem& dst, const SegmentReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move to segment register.
  //! @overload.
  inline void mov(const SegmentReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move to segment register.
  //! @overload.
  inline void mov(const SegmentReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move byte, word, dword or qword from absolute address @a src to
  //! AL, AX, EAX or RAX register.
  inline void mov_ptr(const GPReg& dst, void* src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0);
    Imm imm((sysint_t)src);
    _emitInstruction(INST_MOV_PTR, &dst, &imm);
  }

  //! @brief Move byte, word, dword or qword from AL, AX, EAX or RAX register
  //! to absolute address @a dst.
  inline void mov_ptr(void* dst, const GPReg& src)
  {
    ASMJIT_ASSERT(src.getRegIndex() == 0);
    Imm imm((sysint_t)dst);
    _emitInstruction(INST_MOV_PTR, &imm, &src);
  }

  //! @brief Move with Sign-Extension.
  //!
  //! This instruction copies the contents of the source operand (register
  //! or memory location) to the destination operand (register) and sign
  //! extends the value to 16, 32 or 64-bits.
  //!
  //! @sa movsxd().
  void movsx(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVSX, &dst, &src);
  }
  //! @brief Move with Sign-Extension.
  //! @overload
  void movsx(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSX, &dst, &src);
  }

#if defined(ASMJIT_X64)
  //! @brief Move DWord to QWord with sign-extension.
  inline void movsxd(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVSXD, &dst, &src);
  }
  //! @brief Move DWord to QWord with sign-extension.
  //! @overload
  inline void movsxd(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSXD, &dst, &src);
  }
#endif // ASMJIT_X64

  //! @brief Move with Zero-Extend.
  //!
  //! This instruction copies the contents of the source operand (register
  //! or memory location) to the destination operand (register) and zero
  //! extends the value to 16 or 32-bits. The size of the converted value
  //! depends on the operand-size attribute.
  inline void movzx(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVZX, &dst, &src);
  }
  //! @brief Move with Zero-Extend.
  //! @brief Overload
  inline void movzx(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVZX, &dst, &src);
  }

  //! @brief Unsigned multiply.
  //!
  //! Source operand (in a general-purpose register or memory location)
  //! is multiplied by the value in the AL, AX, or EAX register (depending
  //! on the operand size) and the product is stored in the AX, DX:AX, or
  //! EDX:EAX registers, respectively.
  inline void mul(const GPReg& src)
  {
    _emitInstruction(INST_MUL, &src);
  }
  //! @brief Unsigned multiply.
  //! @overload
  inline void mul(const Mem& src)
  {
    _emitInstruction(INST_MUL, &src);
  }

  //! @brief Two's Complement Negation.
  inline void neg(const GPReg& dst)
  {
    _emitInstruction(INST_NEG, &dst);
  }
  //! @brief Two's Complement Negation.
  inline void neg(const Mem& dst)
  {
    _emitInstruction(INST_NEG, &dst);
  }

  //! @brief No Operation.
  //!
  //! This instruction performs no operation. This instruction is a one-byte
  //! instruction that takes up space in the instruction stream but does not
  //! affect the machine context, except the EIP register. The NOP instruction
  //! is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
  inline void nop()
  {
    _emitInstruction(INST_NOP);
  }

  //! @brief One's Complement Negation.
  inline void not_(const GPReg& dst)
  {
    _emitInstruction(INST_NOT, &dst);
  }
  //! @brief One's Complement Negation.
  inline void not_(const Mem& dst)
  {
    _emitInstruction(INST_NOT, &dst);
  }

  //! @brief Logical Inclusive OR.
  inline void or_(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }

  //! @brief Pop a Value from the Stack.
  //!
  //! This instruction loads the value from the top of the stack to the location
  //! specified with the destination operand and then increments the stack pointer.
  //! The destination operand can be a general purpose register, memory location,
  //! or segment register.
  inline void pop(const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPW) || dst.isRegType(REG_TYPE_GPN));
    _emitInstruction(INST_POP, &dst);
  }

  inline void pop(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 2 || dst.getSize() == sizeof(sysint_t));
    _emitInstruction(INST_POP, &dst);
  }

#if defined(ASMJIT_X86)
  //! @brief Pop All General-Purpose Registers.
  //!
  //! Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
  inline void popad()
  {
    _emitInstruction(INST_POPAD);
  }
#endif // ASMJIT_X86

  //! @brief Pop Stack into EFLAGS Register (32-bit or 64-bit).
  inline void popf()
  {
#if defined(ASMJIT_X86)
    popfd();
#else
    popfq();
#endif
  }

#if defined(ASMJIT_X86)
  //! @brief Pop Stack into EFLAGS Register (32-bit).
  inline void popfd() { _emitInstruction(INST_POPFD); }
#else
  //! @brief Pop Stack into EFLAGS Register (64-bit).
  inline void popfq() { _emitInstruction(INST_POPFQ); }
#endif

  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  //!
  //! @note 32-bit architecture pushed DWORD while 64-bit
  //! pushes QWORD. 64-bit mode not provides instruction to
  //! push 32-bit register/memory.
  inline void push(const GPReg& src)
  {
    ASMJIT_ASSERT(src.isRegType(REG_TYPE_GPW) || src.isRegType(REG_TYPE_GPN));
    _emitInstruction(INST_PUSH, &src);
  }
  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  inline void push(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == sizeof(sysint_t));
    _emitInstruction(INST_PUSH, &src);
  }
  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  inline void push(const Imm& src)
  {
    _emitInstruction(INST_PUSH, &src);
  }

#if defined(ASMJIT_X86)
  //! @brief Push All General-Purpose Registers.
  //!
  //! Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.
  inline void pushad()
  {
    _emitInstruction(INST_PUSHAD);
  }
#endif // ASMJIT_X86

  //! @brief Push EFLAGS Register (32-bit or 64-bit) onto the Stack.
  inline void pushf()
  {
#if defined(ASMJIT_X86)
    pushfd();
#else
    pushfq();
#endif
  }

#if defined(ASMJIT_X86)
  //! @brief Push EFLAGS Register (32-bit) onto the Stack.
  inline void pushfd() { _emitInstruction(INST_PUSHFD); }
#else
  //! @brief Push EFLAGS Register (64-bit) onto the Stack.
  inline void pushfq() { _emitInstruction(INST_PUSHFQ); }
#endif // ASMJIT_X86

  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rcl(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rcl(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rcl(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rcl(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }

  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void rcr(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void rcr(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void rcr(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void rcr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }

  //! @brief Read Time-Stamp Counter (Pentium).
  inline void rdtsc()
  {
    _emitInstruction(INST_RDTSC);
  }

  //! @brief Read Time-Stamp Counter and Processor ID (New).
  inline void rdtscp()
  {
    _emitInstruction(INST_RDTSCP);
  }

  //! @brief Load ECX/RCX BYTEs from DS:[ESI/RSI] to AL.
  inline void rep_lodsb()
  {
    _emitInstruction(INST_REP_LODSB);
  }

  //! @brief Load ECX/RCX DWORDs from DS:[ESI/RSI] to EAX.
  inline void rep_lodsd()
  {
    _emitInstruction(INST_REP_LODSD);
  }

#if defined(ASMJIT_X64)
  //! @brief Load ECX/RCX QWORDs from DS:[ESI/RSI] to RAX.
  inline void rep_lodsq()
  {
    _emitInstruction(INST_REP_LODSQ);
  }
#endif // ASMJIT_X64

  //! @brief Load ECX/RCX WORDs from DS:[ESI/RSI] to AX.
  inline void rep_lodsw()
  {
    _emitInstruction(INST_REP_LODSW);
  }

  //! @brief Move ECX/RCX BYTEs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsb()
  {
    _emitInstruction(INST_REP_MOVSB);
  }

  //! @brief Move ECX/RCX DWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsd()
  {
    _emitInstruction(INST_REP_MOVSD);
  }

#if defined(ASMJIT_X64)
  //! @brief Move ECX/RCX QWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsq()
  {
    _emitInstruction(INST_REP_MOVSQ);
  }
#endif // ASMJIT_X64

  //! @brief Move ECX/RCX WORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsw()
  {
    _emitInstruction(INST_REP_MOVSW);
  }

  //! @brief Fill ECX/RCX BYTEs at ES:[EDI/RDI] with AL.
  inline void rep_stosb()
  {
    _emitInstruction(INST_REP_STOSB);
  }

  //! @brief Fill ECX/RCX DWORDs at ES:[EDI/RDI] with EAX.
  inline void rep_stosd()
  {
    _emitInstruction(INST_REP_STOSD);
  }

#if defined(ASMJIT_X64)
  //! @brief Fill ECX/RCX QWORDs at ES:[EDI/RDI] with RAX.
  inline void rep_stosq()
  {
    _emitInstruction(INST_REP_STOSQ);
  }
#endif // ASMJIT_X64

  //! @brief Fill ECX/RCX WORDs at ES:[EDI/RDI] with AX.
  inline void rep_stosw()
  {
    _emitInstruction(INST_REP_STOSW);
  }

  //! @brief Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsb()
  {
    _emitInstruction(INST_REPE_CMPSB);
  }
  
  //! @brief Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsd()
  {
    _emitInstruction(INST_REPE_CMPSD);
  }

#if defined(ASMJIT_X64)
  //! @brief Repeated find nonmatching QWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsq()
  {
    _emitInstruction(INST_REPE_CMPSQ);
  }
#endif // ASMJIT_X64
  
  //! @brief Repeated find nonmatching WORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsw()
  {
    _emitInstruction(INST_REPE_CMPSW);
  }

  //! @brief Find non-AL BYTE starting at ES:[EDI/RDI].
  inline void repe_scasb()
  {
    _emitInstruction(INST_REPE_SCASB);
  }
  
  //! @brief Find non-EAX DWORD starting at ES:[EDI/RDI].
  inline void repe_scasd()
  {
    _emitInstruction(INST_REPE_SCASD);
  }

#if defined(ASMJIT_X64)
  //! @brief Find non-RAX QWORD starting at ES:[EDI/RDI].
  inline void repe_scasq()
  {
    _emitInstruction(INST_REPE_SCASQ);
  }
#endif // ASMJIT_X64

  //! @brief Find non-AX WORD starting at ES:[EDI/RDI].
  inline void repe_scasw()
  {
    _emitInstruction(INST_REPE_SCASW);
  }

  //! @brief Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repne_cmpsb()
  {
    _emitInstruction(INST_REPNE_CMPSB);
  }

  //! @brief Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repne_cmpsd()
  {
    _emitInstruction(INST_REPNE_CMPSD);
  }

#if defined(ASMJIT_X64)
  //! @brief Repeated find nonmatching QWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repne_cmpsq()
  {
    _emitInstruction(INST_REPNE_CMPSQ);
  }
#endif // ASMJIT_X64

  //! @brief Repeated find nonmatching WORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repne_cmpsw()
  {
    _emitInstruction(INST_REPNE_CMPSW);
  }

  //! @brief Find AL, starting at ES:[EDI/RDI].
  inline void repne_scasb()
  {
    _emitInstruction(INST_REPNE_SCASB);
  }

  //! @brief Find EAX, starting at ES:[EDI/RDI].
  inline void repne_scasd()
  {
    _emitInstruction(INST_REPNE_SCASD);
  }

#if defined(ASMJIT_X64)
  //! @brief Find RAX, starting at ES:[EDI/RDI].
  inline void repne_scasq()
  {
    _emitInstruction(INST_REPNE_SCASQ);
  }
#endif // ASMJIT_X64

  //! @brief Find AX, starting at ES:[EDI/RDI].
  inline void repne_scasw()
  {
    _emitInstruction(INST_REPNE_SCASW);
  }

  //! @brief Return from Procedure.
  inline void ret()
  {
    _emitInstruction(INST_RET);
  }

  //! @brief Return from Procedure.
  inline void ret(const Imm& imm16)
  {
    _emitInstruction(INST_RET, &imm16);
  }

  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rol(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rol(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rol(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rol(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }

  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void ror(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void ror(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void ror(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void ror(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }

#if defined(ASMJIT_X86)
  //! @brief Store AH into Flags.
  inline void sahf()
  {
    _emitInstruction(INST_SAHF);
  }
#endif // ASMJIT_X86

  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }

  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void sal(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void sal(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void sal(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void sal(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }

  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void sar(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void sar(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void sar(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void sar(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }

  //! @brief Set Byte on Condition.
  inline void set(CONDITION cc, const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 1);
    _emitInstruction(ConditionToInstruction::toSetCC(cc), &dst);
  }

  //! @brief Set Byte on Condition.
  inline void set(CONDITION cc, const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() <= 1);
    _emitInstruction(ConditionToInstruction::toSetCC(cc), &dst);
  }

  //! @brief Set Byte on Condition.
  inline void seta  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETA  , &dst); }
  //! @brief Set Byte on Condition.
  inline void seta  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETA  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setae (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETAE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setae (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETAE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setb  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETB  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setb  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETB  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setbe (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETBE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setbe (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETBE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setc  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETC  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setc  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETC  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sete  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETE  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sete  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETE  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setg  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETG  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setg  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETG  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setge (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETGE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setge (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETGE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setl  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETL  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setl  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETL  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setle (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETLE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setle (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETLE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setna (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNA , &dst); }
  //! @brief Set Byte on Condition.
  inline void setna (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNA , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnae(const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNAE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnae(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNAE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnb (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNB , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnb (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNB , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnbe(const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNBE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnbe(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNBE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnc (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNC , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnc (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNC , &dst); }
  //! @brief Set Byte on Condition.
  inline void setne (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setne (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setng (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNG , &dst); }
  //! @brief Set Byte on Condition.
  inline void setng (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNG , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnge(const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNGE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnge(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNGE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnl (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNL , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnl (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNL , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnle(const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNLE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnle(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNLE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setno (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setno (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnp (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNP , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnp (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNP , &dst); }
  //! @brief Set Byte on Condition.
  inline void setns (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNS , &dst); }
  //! @brief Set Byte on Condition.
  inline void setns (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNS , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnz (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNZ , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnz (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNZ , &dst); }
  //! @brief Set Byte on Condition.
  inline void seto  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETO  , &dst); }
  //! @brief Set Byte on Condition.
  inline void seto  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETO  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setp  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETP  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setp  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETP  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpe (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETPE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpe (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETPE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpo (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETPO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpo (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETPO , &dst); }
  //! @brief Set Byte on Condition.
  inline void sets  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETS  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sets  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETS  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setz  (const GPReg& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETZ  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setz  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETZ  , &dst); }

  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void shl(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void shl(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void shl(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void shl(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }

  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void shr(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void shr(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void shr(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void shr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }

  //! @brief Double Precision Shift Left.
  //! @note src2 register can be only @c cl register.
  inline void shld(const GPReg& dst, const GPReg& src1, const GPReg& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  inline void shld(const GPReg& dst, const GPReg& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  //! @note src2 register can be only @c cl register.
  inline void shld(const Mem& dst, const GPReg& src1, const GPReg& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  inline void shld(const Mem& dst, const GPReg& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }

  //! @brief Double Precision Shift Right.
  //! @note src2 register can be only @c cl register.
  inline void shrd(const GPReg& dst, const GPReg& src1, const GPReg& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  inline void shrd(const GPReg& dst, const GPReg& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  //! @note src2 register can be only @c cl register.
  inline void shrd(const Mem& dst, const GPReg& src1, const GPReg& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  inline void shrd(const Mem& dst, const GPReg& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }

  //! @brief Set Carry Flag to 1.
  inline void stc()
  {
    _emitInstruction(INST_STC);
  }

  //! @brief Set Direction Flag to 1.
  inline void std()
  {
    _emitInstruction(INST_STD);
  }

  //! @brief Subtract.
  inline void sub(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }

  //! @brief Logical Compare.
  inline void test(const GPReg& op1, const GPReg& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const GPReg& op1, const Imm& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const Mem& op1, const GPReg& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const Mem& op1, const Imm& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }

  //! @brief Undefined instruction - Raise invalid opcode exception.
  inline void ud2()
  {
    _emitInstruction(INST_UD2);
  }

  //! @brief Exchange and Add.
  inline void xadd(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_XADD, &dst, &src);
  }
  //! @brief Exchange and Add.
  inline void xadd(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_XADD, &dst, &src);
  }

  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_XCHG, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_XCHG, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_XCHG, &src, &dst);
  }

  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPReg& dst, const Imm& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [X87 Instructions (FPU)]
  // --------------------------------------------------------------------------

  //! @brief Compute 2^x - 1 (FPU).
  inline void f2xm1()
  {
    _emitInstruction(INST_F2XM1);
  }

  //! @brief Absolute Value of st(0) (FPU).
  inline void fabs()
  {
    _emitInstruction(INST_FABS);
  }

  //! @brief Add @a src to @a dst and store result in @a dst (FPU).
  //!
  //! @note One of dst or src must be st(0).
  inline void fadd(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FADD, &dst, &src);
  }

  //! @brief Add @a src to st(0) and store result in st(0) (FPU).
  //!
  //! @note SP-FP or DP-FP determined by @a adr size.
  inline void fadd(const Mem& src)
  {
    _emitInstruction(INST_FADD, &src);
  }

  //! @brief Add st(0) to @a dst and POP register stack (FPU).
  inline void faddp(const X87Reg& dst = st(1))
  {
    _emitInstruction(INST_FADDP, &dst);
  }

  //! @brief Load Binary Coded Decimal (FPU).
  inline void fbld(const Mem& src)
  {
    _emitInstruction(INST_FBLD, &src);
  }

  //! @brief Store BCD Integer and Pop (FPU).
  inline void fbstp(const Mem& dst)
  {
    _emitInstruction(INST_FBSTP, &dst);
  }

  //! @brief Change st(0) Sign (FPU).
  inline void fchs()
  {
    _emitInstruction(INST_FCHS);
  }

  //! @brief Clear Exceptions (FPU).
  //!
  //! Clear floating-point exception flags after checking for pending unmasked
  //! floating-point exceptions.
  //!
  //! Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE),
  //! the exception summary status flag (ES), the stack fault flag (SF), and
  //! the busy flag (B) in the FPU status word. The FCLEX instruction checks
  //! for and handles any pending unmasked floating-point exceptions before
  //! clearing the exception flags.
  inline void fclex()
  {
    _emitInstruction(INST_FCLEX);
  }

  //! @brief FP Conditional Move (FPU).
  inline void fcmovb(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVB, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovbe(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVBE, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmove(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVE, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovnb(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVNB, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovnbe(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVNBE, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovne(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVNE, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovnu(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVNU, &src);
  }
  //! @brief FP Conditional Move (FPU).
  inline void fcmovu(const X87Reg& src)
  {
    _emitInstruction(INST_FCMOVU, &src);
  }

  //! @brief Compare st(0) with @a reg (FPU).
  inline void fcom(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FCOM, &reg);
  }
  //! @brief Compare st(0) with 4-byte or 8-byte FP at @a src (FPU).
  inline void fcom(const Mem& src)
  {
    _emitInstruction(INST_FCOM, &src);
  }

  //! @brief Compare st(0) with @a reg and pop the stack (FPU).
  inline void fcomp(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FCOMP, &reg);
  }
  //! @brief Compare st(0) with 4-byte or 8-byte FP at @a adr and pop the
  //! stack (FPU).
  inline void fcomp(const Mem& mem)
  {
    _emitInstruction(INST_FCOMP, &mem);
  }

  //! @brief Compare st(0) with st(1) and pop register stack twice (FPU).
  inline void fcompp()
  {
    _emitInstruction(INST_FCOMPP);
  }

  //! @brief Compare st(0) and @a reg and Set EFLAGS (FPU).
  inline void fcomi(const X87Reg& reg)
  {
    _emitInstruction(INST_FCOMI, &reg);
  }

  //! @brief Compare st(0) and @a reg and Set EFLAGS and pop the stack (FPU).
  inline void fcomip(const X87Reg& reg)
  {
    _emitInstruction(INST_FCOMIP, &reg);
  }

  //! @brief Cosine (FPU).
  //!
  //! This instruction calculates the cosine of the source operand in
  //! register st(0) and stores the result in st(0).
  inline void fcos()
  {
    _emitInstruction(INST_FCOS);
  }

  //! @brief Decrement Stack-Top Pointer (FPU).
  //!
  //! Subtracts one from the TOP field of the FPU status word (decrements
  //! the top-ofstack pointer). If the TOP field contains a 0, it is set
  //! to 7. The effect of this instruction is to rotate the stack by one
  //! position. The contents of the FPU data registers and tag register
  //! are not affected.
  inline void fdecstp()
  {
    _emitInstruction(INST_FDECSTP);
  }

  //! @brief Divide @a dst by @a src (FPU).
  //!
  //! @note One of @a dst or @a src register must be st(0).
  inline void fdiv(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FDIV, &dst, &src);
  }
  //! @brief Divide st(0) by 32-bit or 64-bit FP value (FPU).
  inline void fdiv(const Mem& src)
  {
    _emitInstruction(INST_FDIV, &src);
  }

  //! @brief Divide @a reg by st(0) (FPU).
  inline void fdivp(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FDIVP, &reg);
  }

  //! @brief Reverse Divide @a dst by @a src (FPU).
  //!
  //! @note One of @a dst or @a src register must be st(0).
  inline void fdivr(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FDIVR, &dst, &src);
  }
  //! @brief Reverse Divide st(0) by 32-bit or 64-bit FP value (FPU).
  inline void fdivr(const Mem& src)
  {
    _emitInstruction(INST_FDIVR, &src);
  }

  //! @brief Reverse Divide @a reg by st(0) (FPU).
  inline void fdivrp(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FDIVRP, &reg);
  }

  //! @brief Free Floating-Point Register (FPU).
  //!
  //! Sets the tag in the FPU tag register associated with register @a reg
  //! to empty (11B). The contents of @a reg and the FPU stack-top pointer
  //! (TOP) are not affected.
  inline void ffree(const X87Reg& reg)
  {
    _emitInstruction(INST_FFREE, &reg);
  }

  //! @brief Add 16-bit or 32-bit integer to st(0) (FPU).
  inline void fiadd(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FIADD, &src);
  }

  //! @brief Compare st(0) with 16-bit or 32-bit Integer (FPU).
  inline void ficom(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FICOM, &src);
  }

  //! @brief Compare st(0) with 16-bit or 32-bit Integer and pop the stack (FPU).
  inline void ficomp(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FICOMP, &src);
  }

  //! @brief Divide st(0) by 32-bit or 16-bit integer (@a src) (FPU).
  inline void fidiv(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FIDIV, &src);
  }

  //! @brief Reverse Divide st(0) by 32-bit or 16-bit integer (@a src) (FPU).
  inline void fidivr(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FIDIVR, &src);
  }

  //! @brief Load 16-bit, 32-bit or 64-bit Integer and push it to the stack (FPU).
  //!
  //! Converts the signed-integer source operand into double extended-precision
  //! floating point format and pushes the value onto the FPU register stack.
  //! The source operand can be a word, doubleword, or quadword integer. It is
  //! loaded without rounding errors. The sign of the source operand is
  //! preserved.
  inline void fild(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4 || src.getSize() == 8);
    _emitInstruction(INST_FILD, &src);
  }

  //! @brief Multiply st(0) by 16-bit or 32-bit integer and store it
  //! to st(0) (FPU).
  inline void fimul(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FIMUL, &src);
  }

  //! @brief Increment Stack-Top Pointer (FPU).
  //!
  //! Adds one to the TOP field of the FPU status word (increments the
  //! top-of-stack pointer). If the TOP field contains a 7, it is set to 0.
  //! The effect of this instruction is to rotate the stack by one position.
  //! The contents of the FPU data registers and tag register are not affected.
  //! This operation is not equivalent to popping the stack, because the tag
  //! for the previous top-of-stack register is not marked empty.
  inline void fincstp()
  {
    _emitInstruction(INST_FINCSTP);
  }

  //! @brief Initialize Floating-Point Unit (FPU).
  //!
  //! Initialize FPU after checking for pending unmasked floating-point
  //! exceptions.
  inline void finit()
  {
    _emitInstruction(INST_FINIT);
  }

  //! @brief Subtract 16-bit or 32-bit integer from st(0) and store result to
  //! st(0) (FPU).
  inline void fisub(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FISUB, &src);
  }

  //! @brief Reverse Subtract 16-bit or 32-bit integer from st(0) and
  //! store result to  st(0) (FPU).
  inline void fisubr(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == 4);
    _emitInstruction(INST_FISUBR, &src);
  }

  //! @brief Initialize Floating-Point Unit (FPU).
  //!
  //! Initialize FPU without checking for pending unmasked floating-point
  //! exceptions.
  inline void fninit()
  {
    _emitInstruction(INST_FNINIT);
  }

  //! @brief Store st(0) as 16-bit or 32-bit Integer to @a dst (FPU).
  inline void fist(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 2 || dst.getSize() == 4);
    _emitInstruction(INST_FIST, &dst);
  }

  //! @brief Store st(0) as 16-bit, 32-bit or 64-bit Integer to @a dst and pop
  //! stack (FPU).
  inline void fistp(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 2 || dst.getSize() == 4 || dst.getSize() == 8);
    _emitInstruction(INST_FISTP, &dst);
  }

  //! @brief Push 32-bit, 64-bit or 80-bit Floating Point Value onto the FPU
  //! register stack (FPU).
  inline void fld(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 4 || src.getSize() == 8 || src.getSize() == 10);
    _emitInstruction(INST_FLD, &src);
  }

  //! @brief Push @a reg onto the FPU register stack (FPU).
  inline void fld(const X87Reg& reg)
  {
    _emitInstruction(INST_FLD, &reg);
  }

  //! @brief Push +1.0 onto the FPU register stack (FPU).
  inline void fld1()
  {
    _emitInstruction(INST_FLD1);
  }

  //! @brief Push log2(10) onto the FPU register stack (FPU).
  inline void fldl2t()
  {
    _emitInstruction(INST_FLDL2T);
  }

  //! @brief Push log2(e) onto the FPU register stack (FPU).
  inline void fldl2e()
  {
    _emitInstruction(INST_FLDL2E);
  }

  //! @brief Push pi onto the FPU register stack (FPU).
  inline void fldpi()
  {
    _emitInstruction(INST_FLDPI);
  }

  //! @brief Push log10(2) onto the FPU register stack (FPU).
  inline void fldlg2()
  {
    _emitInstruction(INST_FLDLG2);
  }

  //! @brief Push ln(2) onto the FPU register stack (FPU).
  inline void fldln2()
  {
    _emitInstruction(INST_FLDLN2);
  }

  //! @brief Push +0.0 onto the FPU register stack (FPU).
  inline void fldz()
  {
    _emitInstruction(INST_FLDZ);
  }

  //! @brief Load x87 FPU Control Word (2 bytes) (FPU).
  inline void fldcw(const Mem& src)
  {
    _emitInstruction(INST_FLDCW, &src);
  }

  //! @brief Load x87 FPU Environment (14 or 28 bytes) (FPU).
  inline void fldenv(const Mem& src)
  {
    _emitInstruction(INST_FLDENV, &src);
  }

  //! @brief Multiply @a dst by @a src and store result in @a dst (FPU).
  //!
  //! @note One of dst or src must be st(0).
  inline void fmul(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FMUL, &dst, &src);
  }
  //! @brief Multiply st(0) by @a src and store result in st(0) (FPU).
  //!
  //! @note SP-FP or DP-FP determined by @a adr size.
  inline void fmul(const Mem& src)
  {
    _emitInstruction(INST_FMUL, &src);
  }

  //! @brief Multiply st(0) by @a dst and POP register stack (FPU).
  inline void fmulp(const X87Reg& dst = st(1))
  {
    _emitInstruction(INST_FMULP, &dst);
  }

  //! @brief Clear Exceptions (FPU).
  //!
  //! Clear floating-point exception flags without checking for pending
  //! unmasked floating-point exceptions.
  //!
  //! Clears the floating-point exception flags (PE, UE, OE, ZE, DE, and IE),
  //! the exception summary status flag (ES), the stack fault flag (SF), and
  //! the busy flag (B) in the FPU status word. The FCLEX instruction does
  //! not checks for and handles any pending unmasked floating-point exceptions
  //! before clearing the exception flags.
  inline void fnclex()
  {
    _emitInstruction(INST_FNCLEX);
  }

  //! @brief No Operation (FPU).
  inline void fnop()
  {
    _emitInstruction(INST_FNOP);
  }

  //! @brief Save FPU State (FPU).
  //!
  //! Store FPU environment to m94byte or m108byte without
  //! checking for pending unmasked FP exceptions.
  //! Then re-initialize the FPU.
  inline void fnsave(const Mem& dst)
  {
    _emitInstruction(INST_FNSAVE, &dst);
  }

  //! @brief Store x87 FPU Environment (FPU).
  //!
  //! Store FPU environment to @a dst (14 or 28 Bytes) without checking for
  //! pending unmasked floating-point exceptions. Then mask all floating
  //! point exceptions.
  inline void fnstenv(const Mem& dst)
  {
    _emitInstruction(INST_FNSTENV, &dst);
  }

  //! @brief Store x87 FPU Control Word (FPU).
  //!
  //! Store FPU control word to @a dst (2 Bytes) without checking for pending
  //! unmasked floating-point exceptions.
  inline void fnstcw(const Mem& dst)
  {
    _emitInstruction(INST_FNSTCW, &dst);
  }

  //! @brief Store x87 FPU Status Word (2 Bytes) (FPU).
  inline void fnstsw(const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.isRegCode(REG_AX));
    _emitInstruction(INST_FNSTSW, &dst);
  }
  //! @brief Store x87 FPU Status Word (2 Bytes) (FPU).
  inline void fnstsw(const Mem& dst)
  {
    _emitInstruction(INST_FNSTSW, &dst);
  }

  //! @brief Partial Arctangent (FPU).
  //!
  //! Replace st(1) with arctan(st(1)/st(0)) and pop the register stack.
  inline void fpatan()
  {
    _emitInstruction(INST_FPATAN);
  }

  //! @brief Partial Remainder (FPU).
  //!
  //! Replace st(0) with the remainder obtained from dividing st(0) by st(1).
  inline void fprem()
  {
    _emitInstruction(INST_FPREM);
  }

  //! @brief Partial Remainder (FPU).
  //!
  //! Replace st(0) with the IEEE remainder obtained from dividing st(0) by
  //! st(1).
  inline void fprem1()
  {
    _emitInstruction(INST_FPREM1);
  }

  //! @brief Partial Tangent (FPU).
  //!
  //! Replace st(0) with its tangent and push 1 onto the FPU stack.
  inline void fptan()
  {
    _emitInstruction(INST_FPTAN);
  }

  //! @brief Round to Integer (FPU).
  //!
  //! Rount st(0) to an Integer.
  inline void frndint()
  {
    _emitInstruction(INST_FRNDINT);
  }

  //! @brief Restore FPU State (FPU).
  //!
  //! Load FPU state from src (94 or 108 bytes).
  inline void frstor(const Mem& src)
  {
    _emitInstruction(INST_FRSTOR, &src);
  }

  //! @brief Save FPU State (FPU).
  //!
  //! Store FPU state to 94 or 108-bytes after checking for
  //! pending unmasked FP exceptions. Then reinitialize
  //! the FPU.
  inline void fsave(const Mem& dst)
  {
    _emitInstruction(INST_FSAVE, &dst);
  }

  //! @brief Scale (FPU).
  //!
  //! Scale st(0) by st(1).
  inline void fscale()
  {
    _emitInstruction(INST_FSCALE);
  }

  //! @brief Sine (FPU).
  //!
  //! This instruction calculates the sine of the source operand in
  //! register st(0) and stores the result in st(0).
  inline void fsin()
  {
    _emitInstruction(INST_FSIN);
  }

  //! @brief Sine and Cosine (FPU).
  //!
  //! Compute the sine and cosine of st(0); replace st(0) with
  //! the sine, and push the cosine onto the register stack.
  inline void fsincos()
  {
    _emitInstruction(INST_FSINCOS);
  }

  //! @brief Square Root (FPU).
  //!
  //! Calculates square root of st(0) and stores the result in st(0).
  inline void fsqrt()
  {
    _emitInstruction(INST_FSQRT);
  }

  //! @brief Store Floating Point Value (FPU).
  //!
  //! Store st(0) as 32-bit or 64-bit floating point value to @a dst.
  inline void fst(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 4 || dst.getSize() == 8);
    _emitInstruction(INST_FST, &dst);
  }

  //! @brief Store Floating Point Value (FPU).
  //!
  //! Store st(0) to @a reg.
  inline void fst(const X87Reg& reg)
  {
    _emitInstruction(INST_FST, &reg);
  }

  //! @brief Store Floating Point Value and Pop Register Stack (FPU).
  //!
  //! Store st(0) as 32-bit or 64-bit floating point value to @a dst
  //! and pop register stack.
  inline void fstp(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 4 || dst.getSize() == 8 || dst.getSize() == 10);
    _emitInstruction(INST_FSTP, &dst);
  }

  //! @brief Store Floating Point Value and Pop Register Stack (FPU).
  //!
  //! Store st(0) to @a reg and pop register stack.
  inline void fstp(const X87Reg& reg)
  {
    _emitInstruction(INST_FSTP, &reg);
  }

  //! @brief Store x87 FPU Control Word (FPU).
  //!
  //! Store FPU control word to @a dst (2 Bytes) after checking for pending
  //! unmasked floating-point exceptions.
  inline void fstcw(const Mem& dst)
  {
    _emitInstruction(INST_FSTCW, &dst);
  }

  //! @brief Store x87 FPU Environment (FPU).
  //!
  //! Store FPU environment to @a dst (14 or 28 Bytes) after checking for
  //! pending unmasked floating-point exceptions. Then mask all floating
  //! point exceptions.
  inline void fstenv(const Mem& dst)
  {
    _emitInstruction(INST_FSTENV, &dst);
  }

  //! @brief Store x87 FPU Status Word (2 Bytes) (FPU).
  inline void fstsw(const GPReg& dst)
  {
    ASMJIT_ASSERT(dst.isRegCode(REG_AX));
    _emitInstruction(INST_FSTSW, &dst);
  }
  //! @brief Store x87 FPU Status Word (2 Bytes) (FPU).
  inline void fstsw(const Mem& dst)
  {
    _emitInstruction(INST_FSTSW, &dst);
  }

  //! @brief Subtract @a src from @a dst and store result in @a dst (FPU).
  //!
  //! @note One of dst or src must be st(0).
  inline void fsub(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FSUB, &dst, &src);
  }
  //! @brief Subtract @a src from st(0) and store result in st(0) (FPU).
  //!
  //! @note SP-FP or DP-FP determined by @a adr size.
  inline void fsub(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 4 || src.getSize() == 8);
    _emitInstruction(INST_FSUB, &src);
  }

  //! @brief Subtract st(0) from @a dst and POP register stack (FPU).
  inline void fsubp(const X87Reg& dst = st(1))
  {
    _emitInstruction(INST_FSUBP, &dst);
  }

  //! @brief Reverse Subtract @a src from @a dst and store result in @a dst (FPU).
  //!
  //! @note One of dst or src must be st(0).
  inline void fsubr(const X87Reg& dst, const X87Reg& src)
  {
    ASMJIT_ASSERT(dst.getRegIndex() == 0 || src.getRegIndex() == 0);
    _emitInstruction(INST_FSUBR, &dst, &src);
  }

  //! @brief Reverse Subtract @a src from st(0) and store result in st(0) (FPU).
  //!
  //! @note SP-FP or DP-FP determined by @a adr size.
  inline void fsubr(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 4 || src.getSize() == 8);
    _emitInstruction(INST_FSUBR, &src);
  }

  //! @brief Reverse Subtract st(0) from @a dst and POP register stack (FPU).
  inline void fsubrp(const X87Reg& dst = st(1))
  {
    _emitInstruction(INST_FSUBRP, &dst);
  }

  //! @brief Floating point test - Compare st(0) with 0.0. (FPU).
  inline void ftst()
  {
    _emitInstruction(INST_FTST);
  }

  //! @brief Unordered Compare st(0) with @a reg (FPU).
  inline void fucom(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FUCOM, &reg);
  }

  //! @brief Unordered Compare st(0) and @a reg, check for ordered values
  //! and Set EFLAGS (FPU).
  inline void fucomi(const X87Reg& reg)
  {
    _emitInstruction(INST_FUCOMI, &reg);
  }

  //! @brief UnorderedCompare st(0) and @a reg, Check for ordered values
  //! and Set EFLAGS and pop the stack (FPU).
  inline void fucomip(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FUCOMIP, &reg);
  }

  //! @brief Unordered Compare st(0) with @a reg and pop register stack (FPU).
  inline void fucomp(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FUCOMP, &reg);
  }

  //! @brief Unordered compare st(0) with st(1) and pop register stack twice
  //! (FPU).
  inline void fucompp()
  {
    _emitInstruction(INST_FUCOMPP);
  }

  inline void fwait()
  {
    _emitInstruction(INST_FWAIT);
  }

  //! @brief Examine st(0) (FPU).
  //!
  //! Examines the contents of the ST(0) register and sets the condition code
  //! flags C0, C2, and C3 in the FPU status word to indicate the class of
  //! value or number in the register.
  inline void fxam()
  {
    _emitInstruction(INST_FXAM);
  }

  //! @brief Exchange Register Contents (FPU).
  //!
  //! Exchange content of st(0) with @a reg.
  inline void fxch(const X87Reg& reg = st(1))
  {
    _emitInstruction(INST_FXCH, &reg);
  }

  //! @brief Restore FP And MMX(tm) State And Streaming SIMD Extension State
  //! (FPU, MMX, SSE).
  //!
  //! Load FP and MMX(tm) technology and Streaming SIMD Extension state from
  //! src (512 bytes).
  inline void fxrstor(const Mem& src)
  {
    _emitInstruction(INST_FXRSTOR, &src);
  }

  //! @brief Store FP and MMX(tm) State and Streaming SIMD Extension State
  //! (FPU, MMX, SSE).
  //!
  //! Store FP and MMX(tm) technology state and Streaming SIMD Extension state
  //! to dst (512 bytes).
  inline void fxsave(const Mem& dst)
  {
    _emitInstruction(INST_FXSAVE, &dst);
  }

  //! @brief Extract Exponent and Significand (FPU).
  //!
  //! Separate value in st(0) into exponent and significand, store exponent
  //! in st(0), and push the significand onto the register stack.
  inline void fxtract()
  {
    _emitInstruction(INST_FXTRACT);
  }

  //! @brief Compute y * log2(x).
  //!
  //! Replace st(1) with (st(1) * log2st(0)) and pop the register stack.
  inline void fyl2x()
  {
    _emitInstruction(INST_FYL2X);
  }

  //! @brief Compute y * log_2(x+1).
  //!
  //! Replace st(1) with (st(1) * (log2st(0) + 1.0)) and pop the register stack.
  inline void fyl2xp1()
  {
    _emitInstruction(INST_FYL2XP1);
  }

  // --------------------------------------------------------------------------
  // [MMX]
  // --------------------------------------------------------------------------

  //! @brief Empty MMX state.
  inline void emms()
  {
    _emitInstruction(INST_EMMS);
  }

  //! @brief Move DWord (MMX).
  inline void movd(const Mem& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const GPReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const MMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }

  //! @brief Move QWord (MMX).
  inline void movq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
  //! @brief Move QWord (MMX).
  inline void movq(const Mem& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (MMX).
  inline void movq(const GPReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif
  //! @brief Move QWord (MMX).
  inline void movq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (MMX).
  inline void movq(const MMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif

  //! @brief Pack with Signed Saturation (MMX).
  inline void packsswb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (MMX).
  inline void packsswb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (MMX).
  inline void packssdw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (MMX).
  inline void packssdw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }

  //! @brief Pack with Unsigned Saturation (MMX).
  inline void packuswb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (MMX).
  inline void packuswb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }

  //! @brief Packed BYTE Add (MMX).
  inline void paddb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }
  //! @brief Packed BYTE Add (MMX).
  inline void paddb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }

  //! @brief Packed WORD Add (MMX).
  inline void paddw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }
  //! @brief Packed WORD Add (MMX).
  inline void paddw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }

  //! @brief Packed DWORD Add (MMX).
  inline void paddd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }
  //! @brief Packed DWORD Add (MMX).
  inline void paddd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }

  //! @brief Packed Add with Saturation (MMX).
  inline void paddsb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }
  //! @brief Packed Add with Saturation (MMX).
  inline void paddsb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }

  //! @brief Packed Add with Saturation (MMX).
  inline void paddsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }
  //! @brief Packed Add with Saturation (MMX).
  inline void paddsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }

  //! @brief Logical AND (MMX).
  inline void pand(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }
  //! @brief Logical AND (MMX).
  inline void pand(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }

  //! @brief Logical AND Not (MMX).
  inline void pandn(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }
  //! @brief Logical AND Not (MMX).
  inline void pandn(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }

  //! @brief Packed Compare for Equal (BYTES) (MMX).
  inline void pcmpeqb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }
  //! @brief Packed Compare for Equal (BYTES) (MMX).
  inline void pcmpeqb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }

  //! @brief Packed Compare for Equal (WORDS) (MMX).
  inline void pcmpeqw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }
  //! @brief Packed Compare for Equal (WORDS) (MMX).
  inline void pcmpeqw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (DWORDS) (MMX).
  inline void pcmpeqd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }
  //! @brief Packed Compare for Equal (DWORDS) (MMX).
  inline void pcmpeqd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (BYTES) (MMX).
  inline void pcmpgtb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (BYTES) (MMX).
  inline void pcmpgtb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (WORDS) (MMX).
  inline void pcmpgtw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (WORDS) (MMX).
  inline void pcmpgtw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (DWORDS) (MMX).
  inline void pcmpgtd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (DWORDS) (MMX).
  inline void pcmpgtd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }

  //! @brief Packed Multiply High (MMX).
  inline void pmulhw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }
  //! @brief Packed Multiply High (MMX).
  inline void pmulhw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }

  //! @brief Packed Multiply Low (MMX).
  inline void pmullw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }
  //! @brief Packed Multiply Low (MMX).
  inline void pmullw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }

  //! @brief Bitwise Logical OR (MMX).
  inline void por(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }
  //! @brief Bitwise Logical OR (MMX).
  inline void por(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }

  //! @brief Packed Multiply and Add (MMX).
  inline void pmaddwd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }
  //! @brief Packed Multiply and Add (MMX).
  inline void pmaddwd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhbw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhbw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhwd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhwd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhdq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhdq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklbw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklbw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklwd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklwd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckldq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckldq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }

  //! @brief Bitwise Exclusive OR (MMX).
  inline void pxor(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }
  //! @brief Bitwise Exclusive OR (MMX).
  inline void pxor(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }

  // -------------------------------------------------------------------------
  // [3dNow]
  // -------------------------------------------------------------------------

  //! @brief Faster EMMS (3dNow!).
  //!
  //! @note Use only for early AMD processors where is only 3dNow! or SSE. If
  //! CPU contains SSE2, it's better to use @c emms() ( @c femms() is mapped
  //! to @c emms() ).
  inline void femms()
  {
    _emitInstruction(INST_FEMMS);
  }

  //! @brief Packed SP-FP to Integer Convert (3dNow!).
  inline void pf2id(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PF2ID, &dst, &src);
  }
  //! @brief Packed SP-FP to Integer Convert (3dNow!).
  inline void pf2id(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PF2ID, &dst, &src);
  }

  //! @brief  Packed SP-FP to Integer Word Convert (3dNow!).
  inline void pf2iw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PF2IW, &dst, &src);
  }
  //! @brief  Packed SP-FP to Integer Word Convert (3dNow!).
  inline void pf2iw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PF2IW, &dst, &src);
  }

  //! @brief Packed SP-FP Accumulate (3dNow!).
  inline void pfacc(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFACC, &dst, &src);
  }
  //! @brief Packed SP-FP Accumulate (3dNow!).
  inline void pfacc(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFACC, &dst, &src);
  }

  //! @brief Packed SP-FP Addition (3dNow!).
  inline void pfadd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFADD, &dst, &src);
  }
  //! @brief Packed SP-FP Addition (3dNow!).
  inline void pfadd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFADD, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst == src (3dNow!).
  inline void pfcmpeq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFCMPEQ, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst == src (3dNow!).
  inline void pfcmpeq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPEQ, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst >= src (3dNow!).
  inline void pfcmpge(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFCMPGE, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst >= src (3dNow!).
  inline void pfcmpge(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPGE, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst > src (3dNow!).
  inline void pfcmpgt(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFCMPGT, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst > src (3dNow!).
  inline void pfcmpgt(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPGT, &dst, &src);
  }

  //! @brief Packed SP-FP Maximum (3dNow!).
  inline void pfmax(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFMAX, &dst, &src);
  }
  //! @brief Packed SP-FP Maximum (3dNow!).
  inline void pfmax(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMAX, &dst, &src);
  }

  //! @brief Packed SP-FP Minimum (3dNow!).
  inline void pfmin(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFMIN, &dst, &src);
  }
  //! @brief Packed SP-FP Minimum (3dNow!).
  inline void pfmin(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMIN, &dst, &src);
  }

  //! @brief Packed SP-FP Multiply (3dNow!).
  inline void pfmul(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFMUL, &dst, &src);
  }
  //! @brief Packed SP-FP Multiply (3dNow!).
  inline void pfmul(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMUL, &dst, &src);
  }

  //! @brief Packed SP-FP Negative Accumulate (3dNow!).
  inline void pfnacc(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFNACC, &dst, &src);
  }
  //! @brief Packed SP-FP Negative Accumulate (3dNow!).
  inline void pfnacc(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFNACC, &dst, &src);
  }

  //! @brief Packed SP-FP Mixed Accumulate (3dNow!).
  inline void pfpnaxx(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFPNACC, &dst, &src);
  }
  //! @brief Packed SP-FP Mixed Accumulate (3dNow!).
  inline void pfpnacc(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFPNACC, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Approximation (3dNow!).
  inline void pfrcp(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFRCP, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Approximation (3dNow!).
  inline void pfrcp(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCP, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
  inline void pfrcpit1(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFRCPIT1, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
  inline void pfrcpit1(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCPIT1, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
  inline void pfrcpit2(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFRCPIT2, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
  inline void pfrcpit2(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCPIT2, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
  inline void pfrsqit1(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFRSQIT1, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
  inline void pfrsqit1(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRSQIT1, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
  inline void pfrsqrt(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFRSQRT, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
  inline void pfrsqrt(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRSQRT, &dst, &src);
  }

  //! @brief Packed SP-FP Subtract (3dNow!).
  inline void pfsub(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFSUB, &dst, &src);
  }
  //! @brief Packed SP-FP Subtract (3dNow!).
  inline void pfsub(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFSUB, &dst, &src);
  }

  //! @brief Packed SP-FP Reverse Subtract (3dNow!).
  inline void pfsubr(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PFSUBR, &dst, &src);
  }
  //! @brief Packed SP-FP Reverse Subtract (3dNow!).
  inline void pfsubr(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PFSUBR, &dst, &src);
  }

  //! @brief Packed DWords to SP-FP (3dNow!).
  inline void pi2fd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PI2FD, &dst, &src);
  }
  //! @brief Packed DWords to SP-FP (3dNow!).
  inline void pi2fd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PI2FD, &dst, &src);
  }

  //! @brief Packed Words to SP-FP (3dNow!).
  inline void pi2fw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PI2FW, &dst, &src);
  }
  //! @brief Packed Words to SP-FP (3dNow!).
  inline void pi2fw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PI2FW, &dst, &src);
  }

  //! @brief Packed swap DWord (3dNow!)
  inline void pswapd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSWAPD, &dst, &src);
  }
  //! @brief Packed swap DWord (3dNow!)
  inline void pswapd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSWAPD, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE]
  // --------------------------------------------------------------------------

  //! @brief Packed SP-FP Add (SSE).
  inline void addps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDPS, &dst, &src);
  }
  //! @brief Packed SP-FP Add (SSE).
  inline void addps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Add (SSE).
  inline void addss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Add (SSE).
  inline void addss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSS, &dst, &src);
  }

  //! @brief Bit-wise Logical And Not For SP-FP (SSE).
  inline void andnps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ANDNPS, &dst, &src);
  }
  //! @brief Bit-wise Logical And Not For SP-FP (SSE).
  inline void andnps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDNPS, &dst, &src);
  }

  //! @brief Bit-wise Logical And For SP-FP (SSE).
  inline void andps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ANDPS, &dst, &src);
  }
  //! @brief Bit-wise Logical And For SP-FP (SSE).
  inline void andps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDPS, &dst, &src);
  }

  //! @brief Packed SP-FP Compare (SSE).
  inline void cmpps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPS, &dst, &src, &imm8);
  }
  //! @brief Packed SP-FP Compare (SSE).
  inline void cmpps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPS, &dst, &src, &imm8);
  }

  //! @brief Compare Scalar SP-FP Values (SSE).
  inline void cmpss(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSS, &dst, &src, &imm8);
  }
  //! @brief Compare Scalar SP-FP Values (SSE).
  inline void cmpss(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSS, &dst, &src, &imm8);
  }

  //! @brief Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
  inline void comiss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_COMISS, &dst, &src);
  }
  //! @brief Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
  inline void comiss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_COMISS, &dst, &src);
  }

  //! @brief Packed Signed INT32 to Packed SP-FP Conversion (SSE).
  inline void cvtpi2ps(const XMMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_CVTPI2PS, &dst, &src);
  }
  //! @brief Packed Signed INT32 to Packed SP-FP Conversion (SSE).
  inline void cvtpi2ps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPI2PS, &dst, &src);
  }

  //! @brief Packed SP-FP to Packed INT32 Conversion (SSE).
  inline void cvtps2pi(const MMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPS2PI, &dst, &src);
  }
  //! @brief Packed SP-FP to Packed INT32 Conversion (SSE).
  inline void cvtps2pi(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2PI, &dst, &src);
  }

  //! @brief Scalar Signed INT32 to SP-FP Conversion (SSE).
  inline void cvtsi2ss(const XMMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_CVTSI2SS, &dst, &src);
  }
  //! @brief Scalar Signed INT32 to SP-FP Conversion (SSE).
  inline void cvtsi2ss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSI2SS, &dst, &src);
  }

  //! @brief Scalar SP-FP to Signed INT32 Conversion (SSE).
  inline void cvtss2si(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTSS2SI, &dst, &src);
  }
  //! @brief Scalar SP-FP to Signed INT32 Conversion (SSE).
  inline void cvtss2si(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSS2SI, &dst, &src);
  }

  //! @brief Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
  inline void cvttps2pi(const MMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTPS2PI, &dst, &src);
  }
  //! @brief Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
  inline void cvttps2pi(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPS2PI, &dst, &src);
  }

  //! @brief Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
  inline void cvttss2si(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTSS2SI, &dst, &src);
  }
  //! @brief Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
  inline void cvttss2si(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTSS2SI, &dst, &src);
  }

  //! @brief Packed SP-FP Divide (SSE).
  inline void divps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_DIVPS, &dst, &src);
  }
  //! @brief Packed SP-FP Divide (SSE).
  inline void divps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Divide (SSE).
  inline void divss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_DIVSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Divide (SSE).
  inline void divss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVSS, &dst, &src);
  }

  //! @brief Load Streaming SIMD Extension Control/Status (SSE).
  inline void ldmxcsr(const Mem& src)
  {
    _emitInstruction(INST_LDMXCSR, &src);
  }

  //! @brief Byte Mask Write (SSE).
  //!
  //! @note The default memory location is specified by DS:EDI.
  inline void maskmovq(const MMReg& data, const MMReg& mask)
  {
    _emitInstruction(INST_MASKMOVQ, &data, &mask);
  }

  //! @brief Packed SP-FP Maximum (SSE).
  inline void maxps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MAXPS, &dst, &src);
  }
  //! @brief Packed SP-FP Maximum (SSE).
  inline void maxps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Maximum (SSE).
  inline void maxss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MAXSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Maximum (SSE).
  inline void maxss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXSS, &dst, &src);
  }

  //! @brief Packed SP-FP Minimum (SSE).
  inline void minps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MINPS, &dst, &src);
  }
  //! @brief Packed SP-FP Minimum (SSE).
  inline void minps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MINPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Minimum (SSE).
  inline void minss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MINSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Minimum (SSE).
  inline void minss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MINSS, &dst, &src);
  }

  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }
  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }

  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }

  //! @brief Move DWord.
  inline void movd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const XMMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }

  //! @brief Move QWord (SSE).
  inline void movq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
  //! @brief Move QWord (SSE).
  inline void movq(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (SSE).
  inline void movq(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif // ASMJIT_X64
  //! @brief Move QWord (SSE).
  inline void movq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (SSE).
  inline void movq(const XMMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif // ASMJIT_X64

  //! @brief Move 64 Bits Non Temporal (SSE).
  inline void movntq(const Mem& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVNTQ, &dst, &src);
  }

  //! @brief High to Low Packed SP-FP (SSE).
  inline void movhlps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVHLPS, &dst, &src);
  }

  //! @brief Move High Packed SP-FP (SSE).
  inline void movhps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVHPS, &dst, &src);
  }

  //! @brief Move High Packed SP-FP (SSE).
  inline void movhps(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVHPS, &dst, &src);
  }

  //! @brief Move Low to High Packed SP-FP (SSE).
  inline void movlhps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVLHPS, &dst, &src);
  }

  //! @brief Move Low Packed SP-FP (SSE).
  inline void movlps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVLPS, &dst, &src);
  }

  //! @brief Move Low Packed SP-FP (SSE).
  inline void movlps(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVLPS, &dst, &src);
  }

  //! @brief Move Aligned Four Packed SP-FP Non Temporal (SSE).
  inline void movntps(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVNTPS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }
  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }

  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }

  //! @brief Packed SP-FP Multiply (SSE).
  inline void mulps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MULPS, &dst, &src);
  }
  //! @brief Packed SP-FP Multiply (SSE).
  inline void mulps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MULPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Multiply (SSE).
  inline void mulss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MULSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Multiply (SSE).
  inline void mulss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MULSS, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for SP-FP Data (SSE).
  inline void orps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ORPS, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for SP-FP Data (SSE).
  inline void orps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ORPS, &dst, &src);
  }

  //! @brief Packed Average (SSE).
  inline void pavgb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }
  //! @brief Packed Average (SSE).
  inline void pavgb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }

  //! @brief Packed Average (SSE).
  inline void pavgw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }
  //! @brief Packed Average (SSE).
  inline void pavgw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }

  //! @brief Extract Word (SSE).
  inline void pextrw(const GPReg& dst, const MMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }

  //! @brief Insert Word (SSE).
  inline void pinsrw(const MMReg& dst, const GPReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }
  //! @brief Insert Word (SSE).
  inline void pinsrw(const MMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }

  //! @brief Packed Signed Integer Word Maximum (SSE).
  inline void pmaxsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Maximum (SSE).
  inline void pmaxsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Maximum (SSE).
  inline void pmaxub(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Maximum (SSE).
  inline void pmaxub(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }

  //! @brief Packed Signed Integer Word Minimum (SSE).
  inline void pminsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Minimum (SSE).
  inline void pminsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Minimum (SSE).
  inline void pminub(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Minimum (SSE).
  inline void pminub(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }

  //! @brief Move Byte Mask To Integer (SSE).
  inline void pmovmskb(const GPReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMOVMSKB, &dst, &src);
  }

  //! @brief Packed Multiply High Unsigned (SSE).
  inline void pmulhuw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }
  //! @brief Packed Multiply High Unsigned (SSE).
  inline void pmulhuw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }

  //! @brief Packed Sum of Absolute Differences (SSE).
  inline void psadbw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }
  //! @brief Packed Sum of Absolute Differences (SSE).
  inline void psadbw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }

  //! @brief Packed Shuffle word (SSE).
  inline void pshufw(const MMReg& dst, const MMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFW, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle word (SSE).
  inline void pshufw(const MMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFW, &dst, &src, &imm8);
  }

  //! @brief Packed SP-FP Reciprocal (SSE).
  inline void rcpps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_RCPPS, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal (SSE).
  inline void rcpps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_RCPPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Reciprocal (SSE).
  inline void rcpss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_RCPSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Reciprocal (SSE).
  inline void rcpss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_RCPSS, &dst, &src);
  }

  //! @brief Prefetch (SSE).
  inline void prefetch(const Mem& mem, const Imm& hint)
  {
    _emitInstruction(INST_PREFETCH, &mem, &hint);
  }

  //! @brief Compute Sum of Absolute Differences (SSE).
  inline void psadbw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }
  //! @brief Compute Sum of Absolute Differences (SSE).
  inline void psadbw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }

  //! @brief Packed SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_RSQRTPS, &dst, &src);
  }
  //! @brief Packed SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_RSQRTPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_RSQRTSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_RSQRTSS, &dst, &src);
  }

  //! @brief Store fence (SSE).
  inline void sfence()
  {
    _emitInstruction(INST_SFENCE);
  }

  //! @brief Shuffle SP-FP (SSE).
  inline void shufps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPS, &dst, &src, &imm8);
  }
  //! @brief Shuffle SP-FP (SSE).
  inline void shufps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPS, &dst, &src, &imm8);
  }

  //! @brief Packed SP-FP Square Root (SSE).
  inline void sqrtps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SQRTPS, &dst, &src);
  }
  //! @brief Packed SP-FP Square Root (SSE).
  inline void sqrtps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Square Root (SSE).
  inline void sqrtss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SQRTSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Square Root (SSE).
  inline void sqrtss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTSS, &dst, &src);
  }

  //! @brief Store Streaming SIMD Extension Control/Status (SSE).
  inline void stmxcsr(const Mem& dst)
  {
    _emitInstruction(INST_STMXCSR, &dst);
  }

  //! @brief Packed SP-FP Subtract (SSE).
  inline void subps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Subtract (SSE).
  inline void subps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Subtract (SSE).
  inline void subss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SUBSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Subtract (SSE).
  inline void subss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBSS, &dst, &src);
  }

  //! @brief Unordered Scalar SP-FP compare and set EFLAGS (SSE).
  inline void ucomiss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UCOMISS, &dst, &src);
  }
  //! @brief Unordered Scalar SP-FP compare and set EFLAGS (SSE).
  inline void ucomiss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UCOMISS, &dst, &src);
  }

  //! @brief Unpack High Packed SP-FP Data (SSE).
  inline void unpckhps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UNPCKHPS, &dst, &src);
  }
  //! @brief Unpack High Packed SP-FP Data (SSE).
  inline void unpckhps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKHPS, &dst, &src);
  }

  //! @brief Unpack Low Packed SP-FP Data (SSE).
  inline void unpcklps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UNPCKLPS, &dst, &src);
  }
  //! @brief Unpack Low Packed SP-FP Data (SSE).
  inline void unpcklps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKLPS, &dst, &src);
  }

  //! @brief Bit-wise Logical Xor for SP-FP Data (SSE).
  inline void xorps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_XORPS, &dst, &src);
  }
  //! @brief Bit-wise Logical Xor for SP-FP Data (SSE).
  inline void xorps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_XORPS, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE2]
  // --------------------------------------------------------------------------

  //! @brief Packed DP-FP Add (SSE2).
  inline void addpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDPD, &dst, &src);
  }
  //! @brief Packed DP-FP Add (SSE2).
  inline void addpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Add (SSE2).
  inline void addsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Add (SSE2).
  inline void addsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSD, &dst, &src);
  }

  //! @brief Bit-wise Logical And Not For DP-FP (SSE2).
  inline void andnpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ANDNPD, &dst, &src);
  }
  //! @brief Bit-wise Logical And Not For DP-FP (SSE2).
  inline void andnpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDNPD, &dst, &src);
  }

  //! @brief Bit-wise Logical And For DP-FP (SSE2).
  inline void andpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ANDPD, &dst, &src);
  }
  //! @brief Bit-wise Logical And For DP-FP (SSE2).
  inline void andpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDPD, &dst, &src);
  }

  //! @brief Flush Cache Line (SSE2).
  inline void clflush(const Mem& mem)
  {
    _emitInstruction(INST_CLFLUSH, &mem);
  }

  //! @brief Packed DP-FP Compare (SSE2).
  inline void cmppd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPD, &dst, &src, &imm8);
  }
  //! @brief Packed DP-FP Compare (SSE2).
  inline void cmppd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPD, &dst, &src, &imm8);
  }

  //! @brief Compare Scalar SP-FP Values (SSE2).
  inline void cmpsd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSD, &dst, &src, &imm8);
  }
  //! @brief Compare Scalar SP-FP Values (SSE2).
  inline void cmpsd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSD, &dst, &src, &imm8);
  }

  //! @brief Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void comisd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_COMISD, &dst, &src);
  }
  //! @brief Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void comisd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_COMISD, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtdq2pd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTDQ2PD, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtdq2pd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTDQ2PD, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
  inline void cvtdq2ps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTDQ2PS, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
  inline void cvtdq2ps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTDQ2PS, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2dq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPD2DQ, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2dq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2DQ, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2pi(const MMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPD2PI, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2pi(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2PI, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
  inline void cvtpd2ps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPD2PS, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
  inline void cvtpd2ps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2PS, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtpi2pd(const XMMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_CVTPI2PD, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtpi2pd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPI2PD, &dst, &src);
  }

  //! @brief Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtps2dq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPS2DQ, &dst, &src);
  }
  //! @brief Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtps2dq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2DQ, &dst, &src);
  }

  //! @brief Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
  inline void cvtps2pd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTPS2PD, &dst, &src);
  }
  //! @brief Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
  inline void cvtps2pd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2PD, &dst, &src);
  }

  //! @brief Convert Scalar DP-FP Value to Dword Integer (SSE2).
  inline void cvtsd2si(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTSD2SI, &dst, &src);
  }
  //! @brief Convert Scalar DP-FP Value to Dword Integer (SSE2).
  inline void cvtsd2si(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSD2SI, &dst, &src);
  }

  //! @brief Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
  inline void cvtsd2ss(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTSD2SS, &dst, &src);
  }
  //! @brief Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
  inline void cvtsd2ss(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSD2SS, &dst, &src);
  }

  //! @brief Convert Dword Integer to Scalar DP-FP Value (SSE2).
  inline void cvtsi2sd(const XMMReg& dst, const GPReg& src)
  {
    _emitInstruction(INST_CVTSI2SD, &dst, &src);
  }
  //! @brief Convert Dword Integer to Scalar DP-FP Value (SSE2).
  inline void cvtsi2sd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSI2SD, &dst, &src);
  }

  //! @brief Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
  inline void cvtss2sd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTSS2SD, &dst, &src);
  }
  //! @brief Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
  inline void cvtss2sd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSS2SD, &dst, &src);
  }

  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2pi(const MMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTPD2PI, &dst, &src);
  }
  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2pi(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPD2PI, &dst, &src);
  }

  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2dq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTPD2DQ, &dst, &src);
  }
  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2dq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPD2DQ, &dst, &src);
  }

  //! @brief Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttps2dq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTPS2DQ, &dst, &src);
  }
  //! @brief Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttps2dq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPS2DQ, &dst, &src);
  }

  //! @brief Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
  inline void cvttsd2si(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_CVTTSD2SI, &dst, &src);
  }
  //! @brief Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
  inline void cvttsd2si(const GPReg& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTSD2SI, &dst, &src);
  }

  //! @brief Packed DP-FP Divide (SSE2).
  inline void divpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_DIVPD, &dst, &src);
  }
  //! @brief Packed DP-FP Divide (SSE2).
  inline void divpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Divide (SSE2).
  inline void divsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_DIVSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Divide (SSE2).
  inline void divsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVSD, &dst, &src);
  }

  //! @brief Load Fence (SSE2).
  inline void lfence()
  {
    _emitInstruction(INST_LFENCE);
  }

  //! @brief Store Selected Bytes of Double Quadword (SSE2).
  //!
  //! @note Target is DS:EDI.
  inline void maskmovdqu(const XMMReg& src, const XMMReg& mask)
  {
    _emitInstruction(INST_MASKMOVDQU, &src, &mask);
  }

  //! @brief Return Maximum Packed Double-Precision FP Values (SSE2).
  inline void maxpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MAXPD, &dst, &src);
  }
  //! @brief Return Maximum Packed Double-Precision FP Values (SSE2).
  inline void maxpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXPD, &dst, &src);
  }

  //! @brief Return Maximum Scalar Double-Precision FP Value (SSE2).
  inline void maxsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MAXSD, &dst, &src);
  }
  //! @brief Return Maximum Scalar Double-Precision FP Value (SSE2).
  inline void maxsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXSD, &dst, &src);
  }

  //! @brief Memory Fence (SSE2).
  inline void mfence()
  {
    _emitInstruction(INST_MFENCE);
  }

  //! @brief Return Minimum Packed DP-FP Values (SSE2).
  inline void minpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MINPD, &dst, &src);
  }
  //! @brief Return Minimum Packed DP-FP Values (SSE2).
  inline void minpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MINPD, &dst, &src);
  }

  //! @brief Return Minimum Scalar DP-FP Value (SSE2).
  inline void minsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MINSD, &dst, &src);
  }
  //! @brief Return Minimum Scalar DP-FP Value (SSE2).
  inline void minsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MINSD, &dst, &src);
  }

  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }
  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }

  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }

  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }
  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }

  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }

  //! @brief Extract Packed SP-FP Sign Mask (SSE2).
  inline void movmskps(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVMSKPS, &dst, &src);
  }

  //! @brief Extract Packed DP-FP Sign Mask (SSE2).
  inline void movmskpd(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVMSKPD, &dst, &src);
  }

  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }
  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }

  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Quadword from XMM to MMX Technology Register (SSE2).
  inline void movdq2q(const MMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDQ2Q, &dst, &src);
  }

  //! @brief Move Quadword from MMX Technology to XMM Register (SSE2).
  inline void movq2dq(const XMMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_MOVQ2DQ, &dst, &src);
  }

  //! @brief Move High Packed Double-Precision FP Value (SSE2).
  inline void movhpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVHPD, &dst, &src);
  }

  //! @brief Move High Packed Double-Precision FP Value (SSE2).
  inline void movhpd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVHPD, &dst, &src);
  }

  //! @brief Move Low Packed Double-Precision FP Value (SSE2).
  inline void movlpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVLPD, &dst, &src);
  }

  //! @brief Move Low Packed Double-Precision FP Value (SSE2).
  inline void movlpd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVLPD, &dst, &src);
  }

  //! @brief Store Double Quadword Using Non-Temporal Hint (SSE2).
  inline void movntdq(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVNTDQ, &dst, &src);
  }

  //! @brief Store Store DWORD Using Non-Temporal Hint (SSE2).
  inline void movnti(const Mem& dst, const GPReg& src)
  {
    _emitInstruction(INST_MOVNTI, &dst, &src);
  }

  //! @brief Store Packed Double-Precision FP Values Using Non-Temporal Hint (SSE2).
  inline void movntpd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVNTPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const Mem& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Packed DP-FP Multiply (SSE2).
  inline void mulpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MULPD, &dst, &src);
  }
  //! @brief Packed DP-FP Multiply (SSE2).
  inline void mulpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MULPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Multiply (SSE2).
  inline void mulsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MULSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Multiply (SSE2).
  inline void mulsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MULSD, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void orpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ORPD, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void orpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ORPD, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (SSE2).
  inline void packsswb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (SSE2).
  inline void packsswb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (SSE2).
  inline void packssdw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (SSE2).
  inline void packssdw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }

  //! @brief Pack with Unsigned Saturation (SSE2).
  inline void packuswb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (SSE2).
  inline void packuswb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }

  //! @brief Packed BYTE Add (SSE2).
  inline void paddb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }
  //! @brief Packed BYTE Add (SSE2).
  inline void paddb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }

  //! @brief Packed WORD Add (SSE2).
  inline void paddw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }
  //! @brief Packed WORD Add (SSE2).
  inline void paddw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }

  //! @brief Packed DWORD Add (SSE2).
  inline void paddd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }
  //! @brief Packed DWORD Add (SSE2).
  inline void paddd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }

  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }
  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }

  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }
  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }

  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }
  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }

  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }
  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }

  //! @brief Logical AND (SSE2).
  inline void pand(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }
  //! @brief Logical AND (SSE2).
  inline void pand(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }

  //! @brief Logical AND Not (SSE2).
  inline void pandn(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }
  //! @brief Logical AND Not (SSE2).
  inline void pandn(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }

  //! @brief Spin Loop Hint (SSE2).
  inline void pause()
  {
    _emitInstruction(INST_PAUSE);
  }

  //! @brief Packed Average (SSE2).
  inline void pavgb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }
  //! @brief Packed Average (SSE2).
  inline void pavgb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }

  //! @brief Packed Average (SSE2).
  inline void pavgw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }
  //! @brief Packed Average (SSE2).
  inline void pavgw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (BYTES) (SSE2).
  inline void pcmpeqb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }
  //! @brief Packed Compare for Equal (BYTES) (SSE2).
  inline void pcmpeqb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }

  //! @brief Packed Compare for Equal (WORDS) (SSE2).
  inline void pcmpeqw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }
  //! @brief Packed Compare for Equal (WORDS) (SSE2).
  inline void pcmpeqw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (DWORDS) (SSE2).
  inline void pcmpeqd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }
  //! @brief Packed Compare for Equal (DWORDS) (SSE2).
  inline void pcmpeqd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (BYTES) (SSE2).
  inline void pcmpgtb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (BYTES) (SSE2).
  inline void pcmpgtb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (WORDS) (SSE2).
  inline void pcmpgtw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (WORDS) (SSE2).
  inline void pcmpgtw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (DWORDS) (SSE2).
  inline void pcmpgtd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (DWORDS) (SSE2).
  inline void pcmpgtd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }

  //! @brief Packed Signed Integer Word Maximum (SSE2).
  inline void pmaxsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Maximum (SSE2).
  inline void pmaxsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Maximum (SSE2).
  inline void pmaxub(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Maximum (SSE2).
  inline void pmaxub(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }

  //! @brief Packed Signed Integer Word Minimum (SSE2).
  inline void pminsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Minimum (SSE2).
  inline void pminsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Minimum (SSE2).
  inline void pminub(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Minimum (SSE2).
  inline void pminub(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }

  //! @brief Move Byte Mask (SSE2).
  inline void pmovmskb(const GPReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVMSKB, &dst, &src);
  }

  //! @brief Packed Multiply High (SSE2).
  inline void pmulhw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }
  //! @brief Packed Multiply High (SSE2).
  inline void pmulhw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }

  //! @brief Packed Multiply High Unsigned (SSE2).
  inline void pmulhuw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }
  //! @brief Packed Multiply High Unsigned (SSE2).
  inline void pmulhuw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }

  //! @brief Packed Multiply Low (SSE2).
  inline void pmullw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }
  //! @brief Packed Multiply Low (SSE2).
  inline void pmullw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }

  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }
  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }

  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }
  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }

  //! @brief Bitwise Logical OR (SSE2).
  inline void por(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }
  //! @brief Bitwise Logical OR (SSE2).
  inline void por(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslldq(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLDQ, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubq(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubq(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }

  //! @brief Packed Multiply and Add (SSE2).
  inline void pmaddwd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }
  //! @brief Packed Multiply and Add (SSE2).
  inline void pmaddwd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }

  //! @brief Shuffle Packed DWORDs (SSE2).
  inline void pshufd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFD, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed DWORDs (SSE2).
  inline void pshufd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFD, &dst, &src, &imm8);
  }

  //! @brief Shuffle Packed High Words (SSE2).
  inline void pshufhw(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFHW, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed High Words (SSE2).
  inline void pshufhw(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFHW, &dst, &src, &imm8);
  }

  //! @brief Shuffle Packed Low Words (SSE2).
  inline void pshuflw(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFLW, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed Low Words (SSE2).
  inline void pshuflw(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFLW, &dst, &src, &imm8);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }

  //! @brief DQWord Shift Right Logical (MMX).
  inline void psrldq(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLDQ, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMReg& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhbw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhbw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhwd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhwd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhdq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhdq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhqdq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKHQDQ, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhqdq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHQDQ, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklbw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklbw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklwd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklwd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpckldq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpckldq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklqdq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PUNPCKLQDQ, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklqdq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLQDQ, &dst, &src);
  }

  //! @brief Bitwise Exclusive OR (SSE2).
  inline void pxor(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }
  //! @brief Bitwise Exclusive OR (SSE2).
  inline void pxor(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }

  //! @brief Shuffle DP-FP (SSE2).
  inline void shufpd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPD, &dst, &src, &imm8);
  }
  //! @brief Shuffle DP-FP (SSE2).
  inline void shufpd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPD, &dst, &src, &imm8);
  }

  //! @brief Compute Square Roots of Packed DP-FP Values (SSE2).
  inline void sqrtpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SQRTPD, &dst, &src);
  }
  //! @brief Compute Square Roots of Packed DP-FP Values (SSE2).
  inline void sqrtpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTPD, &dst, &src);
  }

  //! @brief Compute Square Root of Scalar DP-FP Value (SSE2).
  inline void sqrtsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SQRTSD, &dst, &src);
  }
  //! @brief Compute Square Root of Scalar DP-FP Value (SSE2).
  inline void sqrtsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTSD, &dst, &src);
  }

  //! @brief Packed DP-FP Subtract (SSE2).
  inline void subpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Subtract (SSE2).
  inline void subpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Subtract (SSE2).
  inline void subsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_SUBSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Subtract (SSE2).
  inline void subsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBSD, &dst, &src);
  }

  //! @brief Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void ucomisd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UCOMISD, &dst, &src);
  }
  //! @brief Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void ucomisd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UCOMISD, &dst, &src);
  }

  //! @brief Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
  inline void unpckhpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UNPCKHPD, &dst, &src);
  }
  //! @brief Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
  inline void unpckhpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKHPD, &dst, &src);
  }

  //! @brief Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
  inline void unpcklpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_UNPCKLPD, &dst, &src);
  }
  //! @brief Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
  inline void unpcklpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKLPD, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void xorpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_XORPD, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void xorpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_XORPD, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE3]
  // --------------------------------------------------------------------------

  //! @brief Packed DP-FP Add/Subtract (SSE3).
  inline void addsubpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDSUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Add/Subtract (SSE3).
  inline void addsubpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSUBPD, &dst, &src);
  }

  //! @brief Packed SP-FP Add/Subtract (SSE3).
  inline void addsubps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_ADDSUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Add/Subtract (SSE3).
  inline void addsubps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSUBPS, &dst, &src);
  }

  //! @brief Store Integer with Truncation (SSE3).
  inline void fisttp(const Mem& dst)
  {
    _emitInstruction(INST_FISTTP, &dst);
  }

  //! @brief Packed DP-FP Horizontal Add (SSE3).
  inline void haddpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_HADDPD, &dst, &src);
  }
  //! @brief Packed DP-FP Horizontal Add (SSE3).
  inline void haddpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_HADDPD, &dst, &src);
  }

  //! @brief Packed SP-FP Horizontal Add (SSE3).
  inline void haddps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_HADDPS, &dst, &src);
  }
  //! @brief Packed SP-FP Horizontal Add (SSE3).
  inline void haddps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_HADDPS, &dst, &src);
  }

  //! @brief Packed DP-FP Horizontal Subtract (SSE3).
  inline void hsubpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_HSUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Horizontal Subtract (SSE3).
  inline void hsubpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_HSUBPD, &dst, &src);
  }

  //! @brief Packed SP-FP Horizontal Subtract (SSE3).
  inline void hsubps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_HSUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Horizontal Subtract (SSE3).
  inline void hsubps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_HSUBPS, &dst, &src);
  }

  //! @brief Load Unaligned Integer 128 Bits (SSE3).
  inline void lddqu(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_LDDQU, &dst, &src);
  }

  //! @brief Set Up Monitor Address (SSE3).
  inline void monitor()
  {
    _emitInstruction(INST_MONITOR);
  }

  //! @brief Move One DP-FP and Duplicate (SSE3).
  inline void movddup(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVDDUP, &dst, &src);
  }
  //! @brief Move One DP-FP and Duplicate (SSE3).
  inline void movddup(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDDUP, &dst, &src);
  }

  //! @brief Move Packed SP-FP High and Duplicate (SSE3).
  inline void movshdup(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSHDUP, &dst, &src);
  }
  //! @brief Move Packed SP-FP High and Duplicate (SSE3).
  inline void movshdup(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSHDUP, &dst, &src);
  }

  //! @brief Move Packed SP-FP Low and Duplicate (SSE3).
  inline void movsldup(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_MOVSLDUP, &dst, &src);
  }
  //! @brief Move Packed SP-FP Low and Duplicate (SSE3).
  inline void movsldup(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSLDUP, &dst, &src);
  }

  //! @brief Monitor Wait (SSE3).
  inline void mwait()
  {
    _emitInstruction(INST_MWAIT);
  }

  // --------------------------------------------------------------------------
  // [SSSE3]
  // --------------------------------------------------------------------------

  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }

  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }
  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }

  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }
  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }

  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }
  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }

  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }
  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }

  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }
  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }

  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }
  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const MMReg& dst, const MMReg& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const MMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const MMReg& dst, const MMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const MMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }

  // --------------------------------------------------------------------------
  // [SSE4.1]
  // --------------------------------------------------------------------------

  //! @brief Blend Packed DP-FP Values (SSE4.1).
  inline void blendpd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPD, &dst, &src, &imm8);
  }
  //! @brief Blend Packed DP-FP Values (SSE4.1).
  inline void blendpd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPD, &dst, &src, &imm8);
  }

  //! @brief Blend Packed SP-FP Values (SSE4.1).
  inline void blendps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPS, &dst, &src, &imm8);
  }
  //! @brief Blend Packed SP-FP Values (SSE4.1).
  inline void blendps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPS, &dst, &src, &imm8);
  }

  //! @brief Variable Blend Packed DP-FP Values (SSE4.1).
  inline void blendvpd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_BLENDVPD, &dst, &src);
  }
  //! @brief Variable Blend Packed DP-FP Values (SSE4.1).
  inline void blendvpd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_BLENDVPD, &dst, &src);
  }

  //! @brief Variable Blend Packed SP-FP Values (SSE4.1).
  inline void blendvps(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_BLENDVPS, &dst, &src);
  }
  //! @brief Variable Blend Packed SP-FP Values (SSE4.1).
  inline void blendvps(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_BLENDVPS, &dst, &src);
  }

  //! @brief Dot Product of Packed DP-FP Values (SSE4.1).
  inline void dppd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPD, &dst, &src, &imm8);
  }
  //! @brief Dot Product of Packed DP-FP Values (SSE4.1).
  inline void dppd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPD, &dst, &src, &imm8);
  }

  //! @brief Dot Product of Packed SP-FP Values (SSE4.1).
  inline void dpps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPS, &dst, &src, &imm8);
  }
  //! @brief Dot Product of Packed SP-FP Values (SSE4.1).
  inline void dpps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPS, &dst, &src, &imm8);
  }

  //! @brief Extract Packed SP-FP Value (SSE4.1).
  inline void extractps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_EXTRACTPS, &dst, &src, &imm8);
  }
  //! @brief Extract Packed SP-FP Value (SSE4.1).
  inline void extractps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_EXTRACTPS, &dst, &src, &imm8);
  }

  //! @brief Load Double Quadword Non-Temporal Aligned Hint (SSE4.1).
  inline void movntdqa(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVNTDQA, &dst, &src);
  }

  //! @brief Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
  inline void mpsadbw(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_MPSADBW, &dst, &src, &imm8);
  }
  //! @brief Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
  inline void mpsadbw(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_MPSADBW, &dst, &src, &imm8);
  }

  //! @brief Pack with Unsigned Saturation (SSE4.1).
  inline void packusdw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PACKUSDW, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (SSE4.1).
  inline void packusdw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSDW, &dst, &src);
  }

  //! @brief Variable Blend Packed Bytes (SSE4.1).
  inline void pblendvb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PBLENDVB, &dst, &src);
  }
  //! @brief Variable Blend Packed Bytes (SSE4.1).
  inline void pblendvb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PBLENDVB, &dst, &src);
  }

  //! @brief Blend Packed Words (SSE4.1).
  inline void pblendw(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PBLENDW, &dst, &src, &imm8);
  }
  //! @brief Blend Packed Words (SSE4.1).
  inline void pblendw(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PBLENDW, &dst, &src, &imm8);
  }

  //! @brief Compare Packed Qword Data for Equal (SSE4.1).
  inline void pcmpeqq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPEQQ, &dst, &src);
  }
  //! @brief Compare Packed Qword Data for Equal (SSE4.1).
  inline void pcmpeqq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQQ, &dst, &src);
  }

  //! @brief Extract Byte (SSE4.1).
  inline void pextrb(const GPReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRB, &dst, &src, &imm8);
  }
  //! @brief Extract Byte (SSE4.1).
  inline void pextrb(const Mem& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRB, &dst, &src, &imm8);
  }

  //! @brief Extract Dword (SSE4.1).
  inline void pextrd(const GPReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRD, &dst, &src, &imm8);
  }
  //! @brief Extract Dword (SSE4.1).
  inline void pextrd(const Mem& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRD, &dst, &src, &imm8);
  }

  //! @brief Extract Dword (SSE4.1).
  inline void pextrq(const GPReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRQ, &dst, &src, &imm8);
  }
  //! @brief Extract Dword (SSE4.1).
  inline void pextrq(const Mem& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRQ, &dst, &src, &imm8);
  }

  //! @brief Extract Word (SSE4.1).
  inline void pextrw(const GPReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }
  //! @brief Extract Word (SSE4.1).
  inline void pextrw(const Mem& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }

  //! @brief Packed Horizontal Word Minimum (SSE4.1).
  inline void phminposuw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PHMINPOSUW, &dst, &src);
  }
  //! @brief Packed Horizontal Word Minimum (SSE4.1).
  inline void phminposuw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PHMINPOSUW, &dst, &src);
  }

  //! @brief Insert Byte (SSE4.1).
  inline void pinsrb(const XMMReg& dst, const GPReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRB, &dst, &src, &imm8);
  }
  //! @brief Insert Byte (SSE4.1).
  inline void pinsrb(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRB, &dst, &src, &imm8);
  }

  //! @brief Insert Dword (SSE4.1).
  inline void pinsrd(const XMMReg& dst, const GPReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRD, &dst, &src, &imm8);
  }
  //! @brief Insert Dword (SSE4.1).
  inline void pinsrd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRD, &dst, &src, &imm8);
  }

  //! @brief Insert Dword (SSE4.1).
  inline void pinsrq(const XMMReg& dst, const GPReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRQ, &dst, &src, &imm8);
  }
  //! @brief Insert Dword (SSE4.1).
  inline void pinsrq(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRQ, &dst, &src, &imm8);
  }

  //! @brief Insert Word (SSE2).
  inline void pinsrw(const XMMReg& dst, const GPReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }
  //! @brief Insert Word (SSE2).
  inline void pinsrw(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }

  //! @brief Maximum of Packed Word Integers (SSE4.1).
  inline void pmaxuw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXUW, &dst, &src);
  }
  //! @brief Maximum of Packed Word Integers (SSE4.1).
  inline void pmaxuw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUW, &dst, &src);
  }

  //! @brief Maximum of Packed Signed Byte Integers (SSE4.1).
  inline void pmaxsb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXSB, &dst, &src);
  }
  //! @brief Maximum of Packed Signed Byte Integers (SSE4.1).
  inline void pmaxsb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSB, &dst, &src);
  }

  //! @brief Maximum of Packed Signed Dword Integers (SSE4.1).
  inline void pmaxsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXSD, &dst, &src);
  }
  //! @brief Maximum of Packed Signed Dword Integers (SSE4.1).
  inline void pmaxsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSD, &dst, &src);
  }

  //! @brief Maximum of Packed Unsigned Dword Integers (SSE4.1).
  inline void pmaxud(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMAXUD, &dst, &src);
  }
  //! @brief Maximum of Packed Unsigned Dword Integers (SSE4.1).
  inline void pmaxud(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUD, &dst, &src);
  }

  //! @brief Minimum of Packed Signed Byte Integers (SSE4.1).
  inline void pminsb(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINSB, &dst, &src);
  }
  //! @brief Minimum of Packed Signed Byte Integers (SSE4.1).
  inline void pminsb(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSB, &dst, &src);
  }

  //! @brief Minimum of Packed Word Integers (SSE4.1).
  inline void pminuw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINUW, &dst, &src);
  }
  //! @brief Minimum of Packed Word Integers (SSE4.1).
  inline void pminuw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUW, &dst, &src);
  }

  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminud(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINUD, &dst, &src);
  }
  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminud(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUD, &dst, &src);
  }

  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminsd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMINSD, &dst, &src);
  }
  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminsd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSD, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXBW, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBW, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXBD, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBD, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXBQ, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBQ, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxwd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXWD, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxwd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXWD, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovsxwq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXWQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovsxwq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXWQ, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovsxdq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVSXDQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovsxdq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXDQ, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbw(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXBW, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbw(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBW, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXBD, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBD, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXBQ, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBQ, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxwd(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXWD, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxwd(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXWD, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovzxwq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXWQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovzxwq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXWQ, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovzxdq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMOVZXDQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovzxdq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXDQ, &dst, &src);
  }

  //! @brief Multiply Packed Signed Dword Integers (SSE4.1).
  inline void pmuldq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULDQ, &dst, &src);
  }
  //! @brief Multiply Packed Signed Dword Integers (SSE4.1).
  inline void pmuldq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULDQ, &dst, &src);
  }

  //! @brief Multiply Packed Signed Integers and Store Low Result (SSE4.1).
  inline void pmulld(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PMULLD, &dst, &src);
  }
  //! @brief Multiply Packed Signed Integers and Store Low Result (SSE4.1).
  inline void pmulld(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLD, &dst, &src);
  }

  //! @brief Logical Compare (SSE4.1).
  inline void ptest(const XMMReg& op1, const XMMReg& op2)
  {
    _emitInstruction(INST_PTEST, &op1, &op2);
  }
  //! @brief Logical Compare (SSE4.1).
  inline void ptest(const XMMReg& op1, const Mem& op2)
  {
    _emitInstruction(INST_PTEST, &op1, &op2);
  }

  //! Round Packed SP-FP Values @brief (SSE4.1).
  inline void roundps(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPS, &dst, &src, &imm8);
  }
  //! Round Packed SP-FP Values @brief (SSE4.1).
  inline void roundps(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPS, &dst, &src, &imm8);
  }

  //! @brief Round Scalar SP-FP Values (SSE4.1).
  inline void roundss(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSS, &dst, &src, &imm8);
  }
  //! @brief Round Scalar SP-FP Values (SSE4.1).
  inline void roundss(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSS, &dst, &src, &imm8);
  }

  //! @brief Round Packed DP-FP Values (SSE4.1).
  inline void roundpd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPD, &dst, &src, &imm8);
  }
  //! @brief Round Packed DP-FP Values (SSE4.1).
  inline void roundpd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPD, &dst, &src, &imm8);
  }

  //! @brief Round Scalar DP-FP Values (SSE4.1).
  inline void roundsd(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSD, &dst, &src, &imm8);
  }
  //! @brief Round Scalar DP-FP Values (SSE4.1).
  inline void roundsd(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSD, &dst, &src, &imm8);
  }

  // --------------------------------------------------------------------------
  // [SSE4.2]
  // --------------------------------------------------------------------------

  //! @brief Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
  inline void crc32(const GPReg& dst, const GPReg& src)
  {
    ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPD) || dst.isRegType(REG_TYPE_GPQ));
    _emitInstruction(INST_CRC32, &dst, &src);
  }
  //! @brief Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
  inline void crc32(const GPReg& dst, const Mem& src)
  {
    ASMJIT_ASSERT(dst.isRegType(REG_TYPE_GPD) || dst.isRegType(REG_TYPE_GPQ));
    _emitInstruction(INST_CRC32, &dst, &src);
  }

  //! @brief Packed Compare Explicit Length Strings, Return Index (SSE4.2).
  inline void pcmpestri(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRI, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Explicit Length Strings, Return Index (SSE4.2).
  inline void pcmpestri(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRI, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpestrm(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRM, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpestrm(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRM, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Implicit Length Strings, Return Index (SSE4.2).
  inline void pcmpistri(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRI, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Implicit Length Strings, Return Index (SSE4.2).
  inline void pcmpistri(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRI, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpistrm(const XMMReg& dst, const XMMReg& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRM, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpistrm(const XMMReg& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRM, &dst, &src, &imm8);
  }

  //! @brief Compare Packed Data for Greater Than (SSE4.2).
  inline void pcmpgtq(const XMMReg& dst, const XMMReg& src)
  {
    _emitInstruction(INST_PCMPGTQ, &dst, &src);
  }
  //! @brief Compare Packed Data for Greater Than (SSE4.2).
  inline void pcmpgtq(const XMMReg& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTQ, &dst, &src);
  }

  //! @brief Return the Count of Number of Bits Set to 1 (SSE4.2).
  inline void popcnt(const GPReg& dst, const GPReg& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    ASMJIT_ASSERT(src.getRegType() == dst.getRegType());
    _emitInstruction(INST_POPCNT, &dst, &src);
  }
  //! @brief Return the Count of Number of Bits Set to 1 (SSE4.2).
  inline void popcnt(const GPReg& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_POPCNT, &dst, &src);
  }

  // -------------------------------------------------------------------------
  // [AMD only]
  // -------------------------------------------------------------------------

  //! @brief Prefetch (3dNow - Amd).
  //!
  //! Loads the entire 64-byte aligned memory sequence containing the
  //! specified memory address into the L1 data cache. The position of
  //! the specified memory address within the 64-byte cache line is
  //! irrelevant. If a cache hit occurs, or if a memory fault is detected,
  //! no bus cycle is initiated and the instruction is treated as a NOP.
  inline void amd_prefetch(const Mem& mem)
  {
    _emitInstruction(INST_AMD_PREFETCH, &mem);
  }

  //! @brief Prefetch and set cache to modified (3dNow - Amd).
  //!
  //! The PREFETCHW instruction loads the prefetched line and sets the
  //! cache-line state to Modified, in anticipation of subsequent data
  //! writes to the line. The PREFETCH instruction, by contrast, typically
  //! sets the cache-line state to Exclusive (depending on the hardware
  //! implementation).
  inline void amd_prefetchw(const Mem& mem)
  {
    _emitInstruction(INST_AMD_PREFETCHW, &mem);
  }

  // -------------------------------------------------------------------------
  // [Intel only]
  // -------------------------------------------------------------------------

  //! @brief Move Data After Swapping Bytes (SSE3 - Intel Atom).
  inline void movbe(const GPReg& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_MOVBE, &dst, &src);
  }

  //! @brief Move Data After Swapping Bytes (SSE3 - Intel Atom).
  inline void movbe(const Mem& dst, const GPReg& src)
  {
    ASMJIT_ASSERT(!src.isGPB());
    _emitInstruction(INST_MOVBE, &dst, &src);
  }

  // -------------------------------------------------------------------------
  // [Emit Options]
  // -------------------------------------------------------------------------

  //! @brief Assert LOCK# Signal Prefix.
  //!
  //! This instruction causes the processor's LOCK# signal to be asserted
  //! during execution of the accompanying instruction (turns the
  //! instruction into an atomic instruction). In a multiprocessor environment,
  //! the LOCK# signal insures that the processor has exclusive use of any shared
  //! memory while the signal is asserted.
  //!
  //! The LOCK prefix can be prepended only to the following instructions and
  //! to those forms of the instructions that use a memory operand: ADD, ADC,
  //! AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,
  //! and XCHG. An undefined opcode exception will be generated if the LOCK
  //! prefix is used with any other instruction. The XCHG instruction always
  //! asserts the LOCK# signal regardless of the presence or absence of the LOCK
  //! prefix.
  //!
  //! @sa @c EMIT_OPTION_LOCK_PREFIX.
  inline void lock()
  {
    _emitOptions |= EMIT_OPTION_LOCK_PREFIX;
  }

  //! @brief Force REX prefix to be emitted.
  //!
  //! This option should be used carefully, because there are unencodable
  //! combinations. If you want to access ah, bh, ch or dh registers then you
  //! can't emit REX prefix and it will cause an illegal instruction error.
  //!
  //! @note REX prefix is only valid for X64/AMD64 platform.
  //!
  //! @sa @c EMIT_OPTION_REX_PREFIX.
  inline void rex()
  {
    _emitOptions |= EMIT_OPTION_REX_PREFIX;
  }
};

// ============================================================================
// [AsmJit::Assembler]
// ============================================================================

//! @brief Assembler - low level code generation.
//!
//! @c Assembler is the main class in AsmJit for generating low level x86/x64
//! binary stream. It creates internal buffer where opcodes are stored and
//! contains methods that mimics x86/x64 assembler instructions. Code generation
//! should be safe, because basic type-checks are done by the C++ compiler. It's
//! nearly impossible to create invalid instruction (for example
//! <code>mov [eax], [eax]</code> that will not be detected at compile time.
//!
//! Each call to assembler intrinsics directly emits instruction to internal
//! binary stream. Instruction emitting also contains runtime checks so it's
//! impossible to create instruction that is not valid.
//!
//! @c AsmJit::Assembler contains internal buffer where all emitted
//! instructions are stored. Look at @c AsmJit::Buffer for buffer
//! implementation. To generate and allocate memory for function use
//! @c AsmJit::Assembler::make() method that will allocate memory using
//! provided memory manager ( see @c AsmJit::MemoryManager::getGlobal() ) and
//! relocates code to provided address. If you want to create your function
//! manually, you should look at @c AsmJit::VirtualMemory and use
//! @c AsmJit::Assembler::relocCode() method to relocate emitted code into
//! provided memory location. You can also take emitted buffer by @c take()
//! method to do something else with it. If you take buffer, you must free it
//! manually by @c ASMJIT_FREE() macro.
//!
//! @note Always use this class and never use @c AssemblerCore or
//! @c AssemblerIntrinsics classes directly.
//!
//! @section AsmJit_Assembler_CodeGeneration Code Generation
//!
//! To generate code is only needed to create instance of @c AsmJit::Assembler
//! and to use intrinsics. See example how to do that:
//!
//! @code
//! // Use AsmJit namespace.
//! using namespace AsmJit;
//!
//! // Create Assembler instance.
//! Assembler a;
//!
//! // Prolog.
//! a.push(ebp);
//! a.mov(ebp, esp);
//!
//! // Mov 1024 to EAX, EAX is also return value.
//! a.mov(eax, imm(1024));
//!
//! // Epilog.
//! a.mov(esp, ebp);
//! a.pop(ebp);
//!
//! // Return.
//! a.ret();
//! @endcode
//!
//! You can see that syntax is very close to Intel one. Only difference is that
//! you are calling functions that emits the binary code for you. All registers
//! are in @c AsmJit namespace, so it's very comfortable to use it (look at
//! first line). There is also used method @c AsmJit::imm() to create an
//! immediate value. Use @c AsmJit::uimm() to create unsigned immediate value.
//!
//! There is also possibility to use memory addresses and immediates. To build
//! memory address use @c ptr(), @c byte_ptr(), @c word_ptr(), @c dword_ptr()
//! or other friend methods. In most cases you needs only @c ptr() method, but
//! there are instructions where you must specify address size,
//!
//! for example (a is @c AsmJit::Assembler instance):
//!
//! @code
//! a.mov(ptr(eax), imm(0));                   // mov ptr [eax], 0
//! a.mov(ptr(eax), edx);                      // mov ptr [eax], edx
//! @endcode
//!
//! But it's also possible to create complex addresses:
//!
//! @code
//! // eax + ecx*x addresses
//! a.mov(ptr(eax, ecx, TIMES_1), imm(0));     // mov ptr [eax + ecx], 0
//! a.mov(ptr(eax, ecx, TIMES_2), imm(0));     // mov ptr [eax + ecx * 2], 0
//! a.mov(ptr(eax, ecx, TIMES_4), imm(0));     // mov ptr [eax + ecx * 4], 0
//! a.mov(ptr(eax, ecx, TIMES_8), imm(0));     // mov ptr [eax + ecx * 8], 0
//! // eax + ecx*x + disp addresses
//! a.mov(ptr(eax, ecx, TIMES_1,  4), imm(0)); // mov ptr [eax + ecx     +  4], 0
//! a.mov(ptr(eax, ecx, TIMES_2,  8), imm(0)); // mov ptr [eax + ecx * 2 +  8], 0
//! a.mov(ptr(eax, ecx, TIMES_4, 12), imm(0)); // mov ptr [eax + ecx * 4 + 12], 0
//! a.mov(ptr(eax, ecx, TIMES_8, 16), imm(0)); // mov ptr [eax + ecx * 8 + 16], 0
//! @endcode
//!
//! All addresses shown are using @c AsmJit::ptr() to make memory operand.
//! Some assembler instructions (single operand ones) needs to specify memory
//! operand size. For example calling <code>a.inc(ptr(eax))</code> can't be
//! used. @c AsmJit::Assembler::inc(), @c AsmJit::Assembler::dec() and similar
//! instructions can't be serialized without specifying how bytes they are
//! operating on. See next code how assembler works:
//!
//! @code
//! // [byte] address
//! a.inc(byte_ptr(eax));                      // inc byte ptr [eax]
//! a.dec(byte_ptr(eax));                      // dec byte ptr [eax]
//! // [word] address
//! a.inc(word_ptr(eax));                      // inc word ptr [eax]
//! a.dec(word_ptr(eax));                      // dec word ptr [eax]
//! // [dword] address
//! a.inc(dword_ptr(eax));                     // inc dword ptr [eax]
//! a.dec(dword_ptr(eax));                     // dec dword ptr [eax]
//! @endcode
//!
//! @section AsmJit_Assembler_CallingJitCode Calling JIT Code
//!
//! While you are over from emitting instructions, you can make your function
//! using @c AsmJit::Assembler::make() method. This method will use memory
//! manager to allocate virtual memory and relocates generated code to it. For
//! memory allocation is used global memory manager by default and memory is
//! freeable, but of course this default behavior can be overridden specifying
//! your memory manager and allocation type. If you want to do with code
//! something else you can always override make() method and do what you want.
//!
//! You can get size of generated code by @c getCodeSize() or @c getOffset()
//! methods. These methods returns you code size (or more precisely current code 
//! offset) in bytes. Use takeCode() to take internal buffer (all pointers in
//! @c AsmJit::Assembler instance will be zeroed and current buffer returned)
//! to use it. If you don't take it,  @c AsmJit::Assembler destructor will
//! free it automatically. To alloc and run code manually don't use
//! @c malloc()'ed memory, but instead use @c AsmJit::VirtualMemory::alloc()
//! to get memory for executing (specify @c canExecute to @c true) or
//! @c AsmJit::MemoryManager that provides more effective and comfortable way
//! to allocate virtual memory.
//!
//! See next example how to allocate memory where you can execute code created
//! by @c AsmJit::Assembler:
//!
//! @code
//! using namespace AsmJit;
//!
//! Assembler a;
//!
//! // ... your code generation
//!
//! // your function prototype
//! typedef void (*MyFn)();
//!
//! // make your function
//! MyFn fn = function_cast<MyFn>(a.make());
//!
//! // call your function
//! fn();
//!
//! // If you don't need your function again, free it.
//! MemoryManager::getGlobal()->free(fn);
//! @endcode
//!
//! There is also low level alternative how to allocate virtual memory and
//! relocate code to it:
//!
//! @code
//! using namespace AsmJit;
//!
//! Assembler a;
//! // Your code generation ...
//!
//! // Your function prototype.
//! typedef void (*MyFn)();
//!
//! // Alloc memory for your function.
//! MyFn fn = function_cast<MyFn>(
//!   MemoryManager::getGlobal()->alloc(a.getCodeSize());
//!
//! // Relocate the code (will make the function).
//! a.relocCode(fn);
//!
//! // Call the generated function.
//! fn();
//!
//! // If you don't need your function anymore, it should be freed.
//! MemoryManager::getGlobal()->free(fn);
//! @endcode
//!
//! @c note This was very primitive example how to call generated code.
//! In real production code you will never alloc and free code for one run,
//! you will usually use generated code many times.
//!
//! @section AsmJit_Assembler_Labels Labels
//!
//! While generating assembler code, you will usually need to create complex
//! code with labels. Labels are fully supported and you can call @c jmp or
//! @c je (and similar) instructions to initialized or yet uninitialized label.
//! Each label expects to be bound into offset. To bind label to specific
//! offset, use @c bind() method.
//!
//! See next example that contains complete code that creates simple memory
//! copy function (in DWORD entities).
//!
//! @code
//! // Example: Usage of Label (32-bit code).
//! //
//! // Create simple DWORD memory copy function:
//! // ASMJIT_STDCALL void copy32(uint32_t* dst, const uint32_t* src, sysuint_t count);
//! using namespace AsmJit;
//!
//! // Assembler instance.
//! Assembler a;
//!
//! // Constants.
//! const int arg_offset = 8; // Arguments offset (STDCALL EBP).
//! const int arg_size = 12;  // Arguments size.
//!
//! // Labels.
//! Label L_Loop = a.newLabel();
//!
//! // Prolog.
//! a.push(ebp);
//! a.mov(ebp, esp);
//! a.push(esi);
//! a.push(edi);
//!
//! // Fetch arguments
//! a.mov(esi, dword_ptr(ebp, arg_offset + 0)); // Get dst.
//! a.mov(edi, dword_ptr(ebp, arg_offset + 4)); // Get src.
//! a.mov(ecx, dword_ptr(ebp, arg_offset + 8)); // Get count.
//!
//! // Bind L_Loop label to here.
//! a.bind(L_Loop);
//!
//! Copy 4 bytes.
//! a.mov(eax, dword_ptr(esi));
//! a.mov(dword_ptr(edi), eax);
//!
//! // Increment pointers.
//! a.add(esi, 4);
//! a.add(edi, 4);
//!
//! // Repeat loop until (--ecx != 0).
//! a.dec(ecx);
//! a.jz(L_Loop);
//!
//! // Epilog.
//! a.pop(edi);
//! a.pop(esi);
//! a.mov(esp, ebp);
//! a.pop(ebp);
//!
//! // Return: STDCALL convention is to pop stack in called function.
//! a.ret(arg_size);
//! @endcode
//!
//! If you need more abstraction for generating assembler code and you want
//! to hide calling conventions between 32-bit and 64-bit operating systems,
//! look at @c Compiler class that is designed for higher level code
//! generation.
//!
//! @section AsmJit_Assembler_AdvancedCodeGeneration Advanced Code Generation
//!
//! This section describes some advanced generation features of @c Assembler
//! class which can be simply overlooked. The first thing that is very likely
//! needed is generic register support. In previous example the named registers
//! were used. AsmJit contains functions which can convert register index into
//! operand and back.
//!
//! Let's define function which can be used to generate some abstract code:
//!
//! @code
//! // Simple function that generates dword copy.
//! void genCopyDWord(
//!   Assembler& a,
//!   const GPReg& dst, const GPReg& src, const GPReg& tmp)
//! {
//!   a.mov(tmp, dword_ptr(src));
//!   a.mov(dword_ptr(dst), tmp);
//! }
//! @endcode
//!
//! This function can be called like <code>genCopyDWord(a, edi, esi, ebx)</code>
//! or by using existing @ref GPReg instances. This abstraction allows to join
//! more code sections together without rewriting each to use specific registers.
//! You need to take care only about implicit registers which may be used by 
//! several instructions (like mul, imul, div, idiv, shifting, etc...).
//!
//! Next, more advanced, but often needed technique is that you can build your
//! own registers allocator. X86 architecture contains 8 general purpose registers,
//! 8 MMX (MM) registers and 8 SSE (XMM) registers. The X64 (AMD64) architecture
//! extends count of general purpose registers and SSE2 registers to 16. Use the
//! @c REG_NUM_BASE constant to get count of GP or XMM registers or @c REG_NUM_GP,
//! @c REG_NUM_MM and @c REG_NUM_XMM constants individually.
//!
//! To build register from index (value from 0 inclusive to REG_NUM_XXX 
//! exclusive) use @ref gpd(), @ref gpq() or @ref gpn() functions. To create
//! a 8 or 16-bit register use @ref gpw(), @ref gpb_lo() or @ref gpb_hi(). 
//! To create other registers there are similar methods @ref mm(), @ref xmm() and
//! @ref st().
//!
//! So our function call to genCopyDWord can be also used like this:
//!
//! @code
//! genCopyDWord(a, gpd(REG_INDEX_EDI), gpd(REG_INDEX_ESI), gpd(REG_INDEX_EBX));
//! @endcode
//!
//! REG_INDEX_XXX are constants defined by @ref REG_INDEX enum. You can use your
//! own register allocator (or register slot manager) to alloc / free registers
//! so REG_INDEX_XXX values can be replaced by your variables (0 to REG_NUM_XXX-1).
//!
//! @sa @c AssemblerCore, @c AssemblerIntrinsics, @c Operand, @c Compiler.
struct ASMJIT_API Assembler : public AssemblerIntrinsics
{
  Assembler(CodeGenerator* codeGenerator = NULL);
  virtual ~Assembler();
};

} // AsmJit namespace

#include "ApiEnd.h"    // [Api-End]

#endif // _ASMJIT_ASSEMBLERX86X64_H

```

`AsmJit/Build.h`:

```h

#ifndef _ASMJIT_BUILD_H
#define _ASMJIT_BUILD_H

#include "Config.h"
#include <stdio.h>
#include <stdlib.h>

// ----------------------------------------------------------------------------
// [AsmJit - OS]
// ----------------------------------------------------------------------------

#if defined(WINDOWS) || defined(__WINDOWS__) || defined(_WIN32) || defined(_WIN64)
# define ASMJIT_WINDOWS
#elif defined(__linux__)     || defined(__unix__)    || \
      defined(__OpenBSD__)   || defined(__FreeBSD__) || defined(__NetBSD__) || \
      defined(__DragonFly__) || defined(__BSD__)     || defined(__FREEBSD__) || \
      defined(__APPLE__)
# define ASMJIT_POSIX
#else
# warning "AsmJit - Can't match operating system, using ASMJIT_POSIX"
# define ASMJIT_POSIX
#endif

// ----------------------------------------------------------------------------
// [AsmJit - Architecture]
// ----------------------------------------------------------------------------

#ifdef PROTECT_X64
# warning "PROTECT_X64"
#define ASMJIT_X64
#else
#define ASMJIT_X86
#endif

// ----------------------------------------------------------------------------
// [AsmJit - API]
// ----------------------------------------------------------------------------

// Hide AsmJit symbols that we don't want to export (AssemblerIntrinsics class for example).
#if !defined(ASMJIT_HIDDEN)
# if defined(__GNUC__) && __GNUC__ >= 4
#  define ASMJIT_HIDDEN __attribute__((visibility("hidden")))
# endif // __GNUC__ && __GNUC__ >= 4
#endif // ASMJIT_HIDDEN

// Make AsmJit as shared library by default.
#if !defined(ASMJIT_API)
# if defined(ASMJIT_WINDOWS)
#  if defined(__GNUC__)
#   if defined(AsmJit_EXPORTS)
#    define ASMJIT_API __attribute__((dllexport))
#   else
#    define ASMJIT_API __attribute__((dllimport))
#   endif // AsmJit_EXPORTS
#  else
#   if defined(AsmJit_EXPORTS)
#    define ASMJIT_API __declspec(dllexport)
#   else
#    define ASMJIT_API //__declspec(dllimport)// __declspec(dllimport)
#   endif // AsmJit_EXPORTS
#  endif // __GNUC__
# else
#  if defined(__GNUC__)
#   if __GNUC__ >= 4
#    define ASMJIT_API __attribute__((visibility("default")))
#    define ASMJIT_VAR extern ASMJIT_API
#   endif // __GNUC__ >= 4
#  endif // __GNUC__
# endif
#endif // ASMJIT_API

#if defined(ASMJIT_API)
# define ASMJIT_VAR extern ASMJIT_API
#else
# define ASMJIT_API
# define ASMJIT_VAR
#endif // ASMJIT_API

// If not detected, fallback to nothing.
#if !defined(ASMJIT_HIDDEN)
# define ASMJIT_HIDDEN
#endif // ASMJIT_HIDDEN

#if !defined(ASMJIT_NOTHROW)
#define ASMJIT_NOTHROW throw()
#endif // ASMJIT_NOTHROW

// [AsmJit - Memory Management]
#if !defined(ASMJIT_MALLOC)
# define ASMJIT_MALLOC ::malloc
#endif // ASMJIT_MALLOC

#if !defined(ASMJIT_REALLOC)
# define ASMJIT_REALLOC ::realloc
#endif // ASMJIT_REALLOC

#if !defined(ASMJIT_FREE)
# define ASMJIT_FREE ::free
#endif // ASMJIT_FREE

// ----------------------------------------------------------------------------
// [AsmJit - Calling Conventions]
// ----------------------------------------------------------------------------

#if defined(ASMJIT_X86)
# if defined(__GNUC__)
#  define ASMJIT_REGPARM_1 __attribute__((regparm(1)))
#  define ASMJIT_REGPARM_2 __attribute__((regparm(2)))
#  define ASMJIT_REGPARM_3 __attribute__((regparm(3)))
#  define ASMJIT_FASTCALL  __attribute__((fastcall))
#  define ASMJIT_STDCALL   __attribute__((stdcall))
#  define ASMJIT_CDECL     __attribute__((cdecl))
# else
#  define ASMJIT_FASTCALL   __fastcall
#  define ASMJIT_STDCALL    __stdcall
#  define ASMJIT_CDECL      __cdecl
# endif
#else
# define ASMJIT_FASTCALL
# define ASMJIT_STDCALL
# define ASMJIT_CDECL
#endif // ASMJIT_X86

#if !defined(ASMJIT_UNUSED)
# define ASMJIT_UNUSED(var) ((void)var)
#endif // ASMJIT_UNUSED

#if !defined(ASMJIT_NOP)
# define ASMJIT_NOP() ((void)0)
#endif // ASMJIT_NOP

// [AsmJit - C++ Compiler Support]
#define ASMJIT_TYPE_TO_TYPE(type) type 
#define ASMJIT_HAS_STANDARD_DEFINE_OPTIONS
#define ASMJIT_HAS_PARTIAL_TEMPLATE_SPECIALIZATION

// Support for VC6
#if defined(_MSC_VER) && (_MSC_VER < 1400)
#undef ASMJIT_TYPE_TO_TYPE
namespace AsmJit {
  template<typename T>
  struct _Type2Type { typedef T Type; };
}
#define ASMJIT_TYPE_TO_TYPE(T) _Type2Type<T>::Type

#undef ASMJIT_HAS_STANDARD_DEFINE_OPTIONS
#undef ASMJIT_HAS_PARTIAL_TEMPLATE_SPECIALIZATION

#endif

// ----------------------------------------------------------------------------
// [AsmJit - Types]
// ----------------------------------------------------------------------------

#if defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1600)

#include <stdint.h>

#else

#if defined(_MSC_VER)
#if (_MSC_VER < 1300)
typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
typedef __int8 int8_t;
typedef __int16 int16_t;
typedef __int32 int32_t;
typedef __int64 int64_t;
typedef unsigned __int8 uint8_t;
typedef unsigned __int16 uint16_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#endif
#endif // _MSC_VER
#endif // STDINT.H

typedef unsigned char  uchar;
typedef unsigned short ushort;
typedef unsigned int   uint;
typedef unsigned long  ulong;

#if defined(ASMJIT_X86)
typedef int32_t  sysint_t;
typedef uint32_t sysuint_t;
#else
typedef int64_t  sysint_t;
typedef uint64_t sysuint_t;
#endif

#if defined(_MSC_VER)
# define ASMJIT_INT64_C(num) num##i64
# define ASMJIT_UINT64_C(num) num##ui64
#else
# define ASMJIT_INT64_C(num) num##LL
# define ASMJIT_UINT64_C(num) num##ULL
#endif

// ----------------------------------------------------------------------------
// [AsmJit - C++ Macros]
// ----------------------------------------------------------------------------

#define ASMJIT_ARRAY_SIZE(A) (sizeof(A) / sizeof(*A))

#define ASMJIT_DISABLE_COPY(__type__) \
private: \
  inline __type__(const __type__& other); \
  inline __type__& operator=(const __type__& other);

// ----------------------------------------------------------------------------
// [AsmJit - Debug]
// ----------------------------------------------------------------------------

#if !defined(ASMJIT_DEBUG) && !defined(ASMJIT_NO_DEBUG)

#if defined(_DEBUG)
#define ASMJIT_DEBUG
#endif

#endif // !ASMJIT_DEBUG && !ASMJIT_NO_DEBUG
  
// ----------------------------------------------------------------------------
// [AsmJit - Assert]
// ----------------------------------------------------------------------------

namespace AsmJit {
ASMJIT_API void assertionFailure(const char* file, int line, const char* exp);
} // AsmJit namespace

#if defined(ASMJIT_DEBUG)
# if !defined(ASMJIT_ASSERT)
#  define ASMJIT_ASSERT(exp) do { if (!(exp)) ::AsmJit::assertionFailure(__FILE__, __LINE__, #exp); } while(0)
# endif
#else
# if !defined(ASMJIT_ASSERT)
#  define ASMJIT_ASSERT(exp) ASMJIT_NOP()
# endif
#endif // DEBUG

#if defined(ASMJIT_WINDOWS)
#include <windows.h>
#endif

#endif // _ASMJIT_BUILD_H

```

`AsmJit/CodeGenerator.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "Assembler.h"
#include "CodeGenerator.h"
#include "Defs.h"
#include "MemoryManager.h"
#include "MemoryMarker.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::CodeGenerator - Construction / Destruction]
// ============================================================================

CodeGenerator::CodeGenerator()
{
}

CodeGenerator::~CodeGenerator()
{
}

// ============================================================================
// [AsmJit::CodeGenerator - GetGlobal]
// ============================================================================

JitCodeGenerator* CodeGenerator::getGlobal()
{
  static JitCodeGenerator global;
  return &global;
}

// ============================================================================
// [AsmJit::JitCodeGenerator - Construction / Destruction]
// ============================================================================

JitCodeGenerator::JitCodeGenerator() :
  _memoryManager(NULL),
  _memoryMarker(NULL),
  _allocType(MEMORY_ALLOC_FREEABLE)
{
}

JitCodeGenerator::~JitCodeGenerator()
{
}

// ============================================================================
// [AsmJit::JitCodeGenerator - Generate]
// ============================================================================

uint32_t JitCodeGenerator::generate(void** dest, Assembler* assembler)
{
  // Disallow empty code generation.
  sysuint_t codeSize = assembler->getCodeSize();
  if (codeSize == 0)
  {
    *dest = NULL;
    return AsmJit::ERROR_NO_FUNCTION;
  }

  // Switch to global memory manager if not provided.
  MemoryManager* memmgr = getMemoryManager();

  if (memmgr == NULL)
  {
    memmgr = MemoryManager::getGlobal();
  }

  void* p = memmgr->alloc(codeSize, getAllocType());
  if (p == NULL)
  {
    *dest = NULL;
    return ERROR_NO_VIRTUAL_MEMORY;
  }

  // Relocate the code.
  sysuint_t relocatedSize = assembler->relocCode(p);

  // Return unused memory to MemoryManager.
  if (relocatedSize < codeSize)
  {
    memmgr->shrink(p, relocatedSize);
  }

  // Mark memory if MemoryMarker provided.
  if (_memoryMarker)
  {
    _memoryMarker->mark(p, relocatedSize);
  }

  // Return the code.
  *dest = p;
  return ERROR_NONE;
}

} // AsmJit namespace

```

`AsmJit/CodeGenerator.h`:

```h

#ifndef _ASMJIT_CODEGENERATOR_H
#define _ASMJIT_CODEGENERATOR_H

#include "Build.h"

namespace AsmJit {

struct Assembler;
struct JitCodeGenerator;
struct MemoryManager;
struct MemoryMarker;

// ============================================================================
// [AsmJit::CodeGenerator]
// ============================================================================

//! @brief Code generator is core class for changing behavior of code generated
//! by @c Assembler or @c Compiler.
struct ASMJIT_API CodeGenerator
{
  CodeGenerator();
  virtual ~CodeGenerator();

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! @brief Allocate memory for code generated in @a assembler and reloc it
  //! to target location.
  //!
  //! This method is universal allowing any pre-process / post-process work
  //! with code generated by @c Assembler or @c Compiler. Because @c Compiler
  //! always uses @c Assembler it's allowed to access only the @c Assembler
  //! instance.
  //!
  //! This method is always last step when using code generation. You can use
  //! it to allocate memory for JIT code, saving code to remote process or a 
  //! shared library.
  //!
  //! @retrurn Error value, see @c ERROR_CODE.
  virtual uint32_t generate(void** dest, Assembler* assembler) = 0;

  static JitCodeGenerator* getGlobal();

private:
  ASMJIT_DISABLE_COPY(CodeGenerator)
};

// ============================================================================
// [AsmJit::JitCodeGenerator]
// ============================================================================

struct JitCodeGenerator : public CodeGenerator
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a @c JitCodeGenerator instance.
  JitCodeGenerator();
  //! @brief Destroy the @c JitCodeGenerator instance.
  virtual ~JitCodeGenerator();

  // --------------------------------------------------------------------------
  // [Memory Manager and Alloc Type]
  // --------------------------------------------------------------------------

  // Note: These members can be ignored by all derived classes. They are here
  // only to privide default implementation. All other implementations (remote
  // code patching or making dynamic loadable libraries/executables) ignore
  // members accessed by these accessors.

  //! @brief Get the @c MemoryManager instance.
  inline MemoryManager* getMemoryManager() const { return _memoryManager; }
  //! @brief Set the @c MemoryManager instance.
  inline void setMemoryManager(MemoryManager* memoryManager) { _memoryManager = memoryManager; }

  //! @brief Get the type of allocation.
  inline uint32_t getAllocType() const { return _allocType; }
  //! @brief Set the type of allocation.
  inline void setAllocType(uint32_t allocType) { _allocType = allocType; }

  // --------------------------------------------------------------------------
  // [Memory Marker]
  // --------------------------------------------------------------------------

  //! @brief Get the @c MemoryMarker instance.
  inline MemoryMarker* getMemoryMarker() const { return _memoryMarker; }
  //! @brief Set the @c MemoryMarker instance.
  inline void setMemoryMarker(MemoryMarker* memoryMarker) { _memoryMarker = memoryMarker; }

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  virtual uint32_t generate(void** dest, Assembler* assembler);

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Memory manager.
  MemoryManager* _memoryManager;
  //! @brief Memory marker.
  MemoryMarker* _memoryMarker;

  //! @brief Type of allocation.
  uint32_t _allocType;

private:
  ASMJIT_DISABLE_COPY(JitCodeGenerator)
};

} // AsmJit namespace

// [Guard]
#endif // _ASMJIT_CODEGENERATOR_H

```

`AsmJit/Compiler.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// We are using sprintf() here.
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif // _MSC_VER

// [Dependencies]
#include "Assembler.h"
#include "Compiler.h"
#include "CpuInfo.h"
#include "Logger.h"
#include "Util.h"

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::Emittable]
// ============================================================================

Emittable::Emittable(Compiler* c, uint32_t type) ASMJIT_NOTHROW :
  _compiler(c),
  _next(NULL),
  _prev(NULL),
  _comment(NULL),
  _type((uint8_t)type),
  _translated(false),
  _reserved0(0),
  _reserved1(0),
  _offset(INVALID_VALUE)
{
}

Emittable::~Emittable() ASMJIT_NOTHROW
{
}

void Emittable::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset;
}

Emittable* Emittable::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  return translated();
}

void Emittable::emit(Assembler& a) ASMJIT_NOTHROW
{
}

void Emittable::post(Assembler& a) ASMJIT_NOTHROW
{
}

int Emittable::getMaxSize() const ASMJIT_NOTHROW
{
  // Default maximum size is -1 which means that it's not known.
  return -1;
}

bool Emittable::_tryUnuseVar(VarData* v) ASMJIT_NOTHROW
{
  return false;
}

void Emittable::setComment(const char* str) ASMJIT_NOTHROW
{
  _comment = _compiler->getZone().zstrdup(str);
}

void Emittable::setCommentF(const char* fmt, ...) ASMJIT_NOTHROW
{
  // I'm really not expecting larger inline comments:)
  char buf[256];

  va_list ap;
  va_start(ap, fmt);
  vsnprintf(buf, 255, fmt, ap);
  va_end(ap);

  // I don't know if vsnprintf can produce non-null terminated string, in case
  // it can, we terminate it here.
  buf[255] = '\0';

  setComment(buf);
}

// ============================================================================
// [AsmJit::EDummy]
// ============================================================================

EDummy::EDummy(Compiler* c) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_DUMMY)
{
}

EDummy::~EDummy() ASMJIT_NOTHROW
{
}

int EDummy::getMaxSize() const ASMJIT_NOTHROW
{
  return 0;
}

// ============================================================================
// [AsmJit::EFunctionEnd]
// ============================================================================

EFunctionEnd::EFunctionEnd(Compiler* c) ASMJIT_NOTHROW :
  EDummy(c)
{
  _type = EMITTABLE_FUNCTION_END;
}

EFunctionEnd::~EFunctionEnd() ASMJIT_NOTHROW
{
}

Emittable* EFunctionEnd::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  _translated = true;
  return NULL;
}

// ============================================================================
// [AsmJit::EComment]
// ============================================================================

EComment::EComment(Compiler* c, const char* str) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_COMMENT)
{
  setComment(str);
}

EComment::~EComment() ASMJIT_NOTHROW
{
}

void EComment::emit(Assembler& a) ASMJIT_NOTHROW
{
  if (a.getLogger())
  {
    a.getLogger()->logString(getComment());
  }
}

int EComment::getMaxSize() const ASMJIT_NOTHROW
{
  return 0;
}

// ============================================================================
// [AsmJit::EData]
// ============================================================================

EData::EData(Compiler* c, const void* data, sysuint_t length) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_EMBEDDED_DATA)
{
  _length = length;
  memcpy(_data, data, length);
}

EData::~EData() ASMJIT_NOTHROW
{
}

void EData::emit(Assembler& a) ASMJIT_NOTHROW
{
  a.embed(_data, _length);
}

int EData::getMaxSize() const ASMJIT_NOTHROW
{
  return (int)_length;;
}

// ============================================================================
// [AsmJit::EAlign]
// ============================================================================

EAlign::EAlign(Compiler* c, uint32_t size) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_ALIGN), _size(size)
{
}

EAlign::~EAlign() ASMJIT_NOTHROW
{
}

void EAlign::emit(Assembler& a) ASMJIT_NOTHROW
{
  a.align(_size);
}

int EAlign::getMaxSize() const ASMJIT_NOTHROW
{
  return (_size > 0) ? (int)_size - 1 : 0;
}

// ============================================================================
// [AsmJit::ETarget]
// ============================================================================

ETarget::ETarget(Compiler* c, const Label& label) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_TARGET),
  _label(label),
  _from(NULL),
  _state(NULL),
  _jumpsCount(0)
{
}

ETarget::~ETarget() ASMJIT_NOTHROW
{
}

void ETarget::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset++;
}

Emittable* ETarget::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  // If this ETarget was already translated, it's needed to change the current
  // state and return NULL to tell CompilerContext to process next untranslated
  // emittable.
  if (_translated)
  {
    cc._restoreState(_state);
    return NULL;
  }

  if (cc._unreachable)
  {
    cc._unreachable = 0;

    // Assign state to the compiler context. 
    ASMJIT_ASSERT(_state != NULL);
    cc._assignState(_state);
  }
  else
  {
    _state = cc._saveState();
  }

  return translated();
}

void ETarget::emit(Assembler& a) ASMJIT_NOTHROW
{
  a.bind(_label);
}

int ETarget::getMaxSize() const ASMJIT_NOTHROW
{
  return 0;
}

} // AsmJit namespace

```

`AsmJit/Compiler.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_COMPILER_H
#define _ASMJIT_COMPILER_H

// [Dependencies]
#include "Build.h"
#include "Defs.h"
#include "Operand.h"
#include "Util.h"

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [Forward Declarations]
// ============================================================================

struct Assembler;
struct CodeGenerator;
struct Compiler;
struct CompilerContext;
struct CompilerCore;
struct CompilerIntrinsics;
struct MemoryManager;

struct FunctionDefinition;

struct ForwardJumpData;

struct VarData;
struct VarAllocRecord;
struct StateData;

struct Emittable;
struct EAlign;
struct ECall;
struct EComment;
struct EData;
struct EEpilog;
struct EFunction;
struct EFunctionEnd;
struct EInstruction;
struct EJmp;
struct EProlog;
struct ERet;

// ============================================================================
// [AsmJit::TypeToId]
// ============================================================================

#if !defined(ASMJIT_NODOC)

#if defined(ASMJIT_HAS_PARTIAL_TEMPLATE_SPECIALIZATION)

template<typename T>
struct TypeToId
{
#if defined(ASMJIT_NODOC)
  enum { Id = INVALID_VALUE };
#endif // ASMJIT_NODOC
};

template<typename T>
struct TypeToId<T*> { enum { Id = VARIABLE_TYPE_INTPTR }; };

#else

// Same trict is used in Qt, Boost, Fog and all other libraries that need
// something similar.
//
// It's easy. It's needed to use sizeof() to determine the size
// of return value of this function. If size will be sizeof(char)
// (this is our type) then type is pointer, otherwise it's not.
template<typename T>
char TypeToId_NoPtiHelper(T*(*)());
// And specialization.
void* TypeToId_NoPtiHelper(...);

template<typename T>
struct TypeToId
{
  // TypeInfo constants
  enum
  {
    // This is the hackery result.
    Id = (sizeof(char) == sizeof( TypeToId_NoPtiHelper((T(*)())0) )
      ? VARIABLE_TYPE_INTPTR
      : INVALID_VALUE)
  };
};

#endif // ASMJIT_HAS_PARTIAL_TEMPLATE_SPECIALIZATION

#define ASMJIT_DECLARE_TYPE_AS_ID(__T__, __Id__) \
  template<> \
  struct TypeToId<__T__> { enum { Id = __Id__ }; }

// Declare void type and alternative.
struct Void {};
ASMJIT_DECLARE_TYPE_AS_ID(void, INVALID_VALUE);
ASMJIT_DECLARE_TYPE_AS_ID(Void, INVALID_VALUE);

#endif // ASMJIT_NODOC

// ============================================================================
// [AsmJit::Function Builder]
// ============================================================================

struct FunctionDefinition
{
  //! @brief Get function arguments IDs.
  inline const uint32_t* getArguments() const
  {
    return _arguments;
  }

  //! @brief Get function arguments count.
  inline uint32_t getArgumentsCount() const
  {
    return _argumentsCount;
  }

  inline uint32_t getArgument(uint32_t id) const
  {
    ASMJIT_ASSERT(id < _argumentsCount);
    return _arguments[id];
  }

  //! @brief Get function return value.
  inline uint32_t getReturnValue() const
  {
    return _returnValue;
  }

protected:
  inline void _setDefinition(const uint32_t* arguments, uint32_t argumentsCount, uint32_t returnValue)
  {
    _arguments = arguments;
    _argumentsCount = argumentsCount;
    _returnValue = returnValue;
  }

  const uint32_t* _arguments;
  uint32_t _argumentsCount;
  uint32_t _returnValue;
};

//! @brief Custom function builder for up to 32 function arguments.
struct FunctionBuilderX : public FunctionDefinition
{
  inline FunctionBuilderX()
  {
    _setDefinition(_argumentsData, 0, INVALID_VALUE);
  }

  template<typename T>
  inline void addArgument()
  {
    addArgumentRaw(TypeToId<ASMJIT_TYPE_TO_TYPE(T)>::Id);
  }

  template<typename T>
  inline void setArgument(uint32_t id)
  {
    setArgumentRaw(id, TypeToId<ASMJIT_TYPE_TO_TYPE(T)>::Id);
  }

  template<typename T>
  inline void setReturnValue()
  {
    setReturnValueRaw(TypeToId<ASMJIT_TYPE_TO_TYPE(T)>::Id);
  }

  inline void addArgumentRaw(uint32_t type)
  {
    ASMJIT_ASSERT(_argumentsCount < FUNC_MAX_ARGS);
    _argumentsData[_argumentsCount++] = type;
  }

  inline void setArgumentRaw(uint32_t id, uint32_t type)
  {
    ASMJIT_ASSERT(id < _argumentsCount);
    _argumentsData[id] = type;
  }

  inline void setReturnValueRaw(uint32_t returnValue)
  {
    _returnValue = returnValue;
  }

protected:
  uint32_t _argumentsData[FUNC_MAX_ARGS];
};

//! @brief Class used to build function without arguments.
template<typename RET>
struct FunctionBuilder0 : public FunctionDefinition
{
  inline FunctionBuilder0()
  {
    _setDefinition(NULL, 0, TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 1 argument.
template<typename RET, typename P0>
struct FunctionBuilder1 : public FunctionDefinition
{
  inline FunctionBuilder1()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 2 arguments.
template<typename RET, typename P0, typename P1>
struct FunctionBuilder2 : public FunctionDefinition
{
  inline FunctionBuilder2()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 3 arguments.
template<typename RET, typename P0, typename P1, typename P2>
struct FunctionBuilder3 : public FunctionDefinition
{
  inline FunctionBuilder3()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 4 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3>
struct FunctionBuilder4 : public FunctionDefinition
{
  inline FunctionBuilder4()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 5 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4>
struct FunctionBuilder5 : public FunctionDefinition
{
  inline FunctionBuilder5()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 6 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5>
struct FunctionBuilder6 : public FunctionDefinition
{
  inline FunctionBuilder6()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id,
      TypeToId<P5>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 7 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
struct FunctionBuilder7 : public FunctionDefinition
{
  inline FunctionBuilder7()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id,
      TypeToId<P5>::Id,
      TypeToId<P6>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 8 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7>
struct FunctionBuilder8 : public FunctionDefinition
{
  inline FunctionBuilder8()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id,
      TypeToId<P5>::Id,
      TypeToId<P6>::Id,
      TypeToId<P7>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 9 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8>
struct FunctionBuilder9 : public FunctionDefinition
{
  inline FunctionBuilder9()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id,
      TypeToId<P5>::Id,
      TypeToId<P6>::Id,
      TypeToId<P7>::Id,
      TypeToId<P8>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

//! @brief Class used to build function with 10 arguments.
template<typename RET, typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9>
struct FunctionBuilder10 : public FunctionDefinition
{
  inline FunctionBuilder10()
  {
    static const uint32_t args[] =
    {
      TypeToId<P0>::Id,
      TypeToId<P1>::Id,
      TypeToId<P2>::Id,
      TypeToId<P3>::Id,
      TypeToId<P4>::Id,
      TypeToId<P5>::Id,
      TypeToId<P6>::Id,
      TypeToId<P7>::Id,
      TypeToId<P8>::Id,
      TypeToId<P9>::Id
    };
    _setDefinition(args, ASMJIT_ARRAY_SIZE(args), TypeToId<RET>::Id);
  }
};

// ============================================================================
// [AsmJit::Emittable]
// ============================================================================

//! @brief Emmitable.
//!
//! Emittable is object that can emit single or more instructions. To
//! create your custom emittable it's needed to override the abstract virtual
//! method @c emit().
//!
//! When you are finished serializing instructions to the @c Compiler and you
//! call @c Compiler::make(), it will first call @c prepare() method for each
//! emittable in list, then @c translate(), @c emit() and @c post() is the last.
//! Prepare can be used to calculate something that can be only calculated when
//! emitting instructions is finished (for example @c Function uses @c prepare()
//! to relocate memory home for all memory/spilled variables). The @c emit() should 
//! be used to emit instruction or multiple instructions into @a Assembler stream,
//! and the @c post() is here to allow emitting embedded data (after function
//! declaration), etc.
struct ASMJIT_API Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new emittable.
  //!
  //! Never create @c Emittable by @c new operator or on the stack, use
  //! @c Compiler::newObject template to do that.
  Emittable(Compiler* c, uint32_t type) ASMJIT_NOTHROW;

  //! @brief Destroy emittable.
  //!
  //! @note Never destroy emittable using @c delete keyword, @c Compiler
  //! manages all emittables in internal memory pool and it will destroy
  //! all emittables after you destroy it.
  virtual ~Emittable() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit and Helpers]
  // --------------------------------------------------------------------------

  //! @brief Step 1. Extract emittable variables, update statistics, ...
  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  //! @brief Step 2. Translate instruction, alloc variables, ...
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;
  //! @brief Step 3. Emit to @c Assembler.
  virtual void emit(Assembler& a) ASMJIT_NOTHROW;
  //! @brief Step 4. Last post step (verify, add data, etc).
  virtual void post(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  //! @brief Get maximum size in bytes of this emittable (in binary).
  virtual int getMaxSize() const ASMJIT_NOTHROW;

  //! @brief Try to unuse the variable @a.
  //!
  //! Returns @c true only if the variable will be unused by the instruction,
  //! otherwise @c false is returned.
  virtual bool _tryUnuseVar(VarData* v) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Compiler]
  // --------------------------------------------------------------------------

  //! @brief Get associated compiler instance.
  inline Compiler* getCompiler() const ASMJIT_NOTHROW { return _compiler; }

  // --------------------------------------------------------------------------
  // [Type / Offset]
  // --------------------------------------------------------------------------

  //! @brief Get emittable type, see @c EMITTABLE_TYPE.
  inline uint32_t getType() const ASMJIT_NOTHROW { return _type; }

  //! @brief Get whether the emittable was translated.
  inline uint8_t isTranslated() const ASMJIT_NOTHROW { return _translated; }

  //! @brief Get emittable offset in the stream
  //!
  //! Emittable offset is not byte offset, each emittable increments offset by 1
  //! and this value is then used by register allocator. Emittable offset is
  //! set by compiler by the register allocator, don't use it in your code.
  inline uint32_t getOffset() const ASMJIT_NOTHROW { return _offset; }

  // --------------------------------------------------------------------------
  // [Emittables List]
  // --------------------------------------------------------------------------

  //! @brief Get previous emittable in list.
  inline Emittable* getPrev() const ASMJIT_NOTHROW { return _prev; }
  //! @brief Get next emittable in list.
  inline Emittable* getNext() const ASMJIT_NOTHROW { return _next; }

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  //! @brief Get comment string.
  inline const char* getComment() const ASMJIT_NOTHROW { return _comment; }

  //! @brief Set comment string to @a str.
  void setComment(const char* str) ASMJIT_NOTHROW;

  //! @brief Format comment string using @a fmt string and variable argument list.
  void setCommentF(const char* fmt, ...) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Protected]
  // --------------------------------------------------------------------------

protected:
  //! @brief Mark emittable as translated and return next.
  inline Emittable* translated() ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(_translated == false);

    _translated = true;
    return _next;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Compiler where this emittable is connected to.
  Compiler* _compiler;

  //! @brief Type of emittable, see @c EMITTABLE_TYPE.
  uint8_t _type;
  //! @brief Whether the emittable was translated, see @c translate().
  uint8_t _translated;
  //! @brief Reserved flags for future use.
  uint8_t _reserved0;
  //! @brief Reserved flags for future use.
  uint8_t _reserved1;

  //! @brief Emittable offset.
  uint32_t _offset;

  //! @brief Previous emittable.
  Emittable* _prev;
  //! @brief Next emittable.
  Emittable* _next;

  //! @brief Embedded comment string (also used by a @c Comment emittable).
  const char* _comment;

private:
  friend struct CompilerCore;

  ASMJIT_DISABLE_COPY(Emittable)
};

// ============================================================================
// [AsmJit::EDummy]
// ============================================================================

//! @brief Dummy emittable, used as a mark.
//!
//! This emittable does nothing and it's only used by @ref Compiler to mark 
//! specific location in the code.
struct ASMJIT_API EDummy : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EDummy instance.
  EDummy(Compiler* c) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EDummy instance.
  virtual ~EDummy() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

private:
  ASMJIT_DISABLE_COPY(EDummy)
};

// ============================================================================
// [AsmJit::EFunctionEnd]
// ============================================================================

//! @brief End of function.
//!
//! This emittable does nothing and it's only used by @ref Compiler to mark 
//! specific location in the code. The @c EFunctionEnd is similar to @c EDummy,
//! except that it overrides @c translate() to return @c NULL.
struct ASMJIT_API EFunctionEnd : public EDummy
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EDummy instance.
  EFunctionEnd(Compiler* c) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EDummy instance.
  virtual ~EFunctionEnd() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit and Helpers]
  // --------------------------------------------------------------------------

  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

private:
  ASMJIT_DISABLE_COPY(EFunctionEnd)
};

// ============================================================================
// [AsmJit::EComment]
// ============================================================================

//! @brief Emittable used to emit comment into @c Assembler logger.
//!
//! Comments allows to comment your assembler stream for better debugging
//! and visualization what's happening. Comments are ignored if logger is
//! not set.
//!
//! Comment string can't be modified after comment was created.
struct ASMJIT_API EComment : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EComment instance.
  EComment(Compiler* c, const char* comment) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EComment instance.
  virtual ~EComment() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

private:
  friend struct CompilerCore;

  ASMJIT_DISABLE_COPY(EComment)
};

// ============================================================================
// [AsmJit::EData]
// ============================================================================

//! @brief Emittable used to emit comment into @c Assembler logger.
//!
//! @note This class is always allocated by @c AsmJit::Compiler.
struct ASMJIT_API EData : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EData instance.
  EData(Compiler* c, const void* data, sysuint_t length) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EData instance.
  virtual ~EData() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Data]
  // --------------------------------------------------------------------------

  //! @brief Get pointer to embedded data.
  uint8_t* getData() const ASMJIT_NOTHROW { return (uint8_t*)_data; }

  //! @brief Get length of embedded data.
  sysuint_t getLength() const ASMJIT_NOTHROW { return _length; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Data length.
  sysuint_t _length;
  //! @brief Data buffer (that will be embedded to the assembler stream).
  uint8_t _data[sizeof(void*)];

private:
  friend struct CompilerCore;

  ASMJIT_DISABLE_COPY(EData)
};

// ============================================================================
// [AsmJit::EAlign]
// ============================================================================

//! @brief Emittable used to align assembler code.
struct ASMJIT_API EAlign : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EAlign instance.
  EAlign(Compiler* c, uint32_t size = 0) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EAlign instance.
  virtual ~EAlign() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Align Size]
  // --------------------------------------------------------------------------

  //! @brief Get align size in bytes.
  inline uint32_t getSize() const ASMJIT_NOTHROW { return _size; }
  //! @brief Set align size in bytes to @a size.
  inline void setSize(uint32_t size) ASMJIT_NOTHROW { _size = size; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Align size.
  uint32_t _size;

private:
  friend struct CompilerCore;

  ASMJIT_DISABLE_COPY(EAlign)
};

// ============================================================================
// [AsmJit::ETarget]
// ============================================================================

//! @brief Target - the bound label.
struct ASMJIT_API ETarget : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref ETarget instance.
  ETarget(Compiler* c, const Label& target) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref ETarget instance.
  virtual ~ETarget() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Return label bound to this target.
  inline const Label& getLabel() const ASMJIT_NOTHROW { return _label; }

  //! @brief Get first jmp instruction.
  inline EJmp* getFrom() const ASMJIT_NOTHROW { return _from; }

  //! @brief Get register allocator state for this target.
  inline StateData* getState() const ASMJIT_NOTHROW { return _state; }

  //! @brief Get number of jumps to this target.
  inline uint32_t getJumpsCount() const ASMJIT_NOTHROW { return _jumpsCount; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Label.
  Label _label;
  //! @brief First jump instruction that points to this target (label).
  EJmp* _from;
  //! @brief State at this location.
  StateData* _state;

  //! @brief Count of jumps to this target (label).
  uint32_t _jumpsCount;

private:
  friend struct CompilerContext;
  friend struct CompilerCore;
  friend struct EInstruction;
  friend struct EJmp;

  ASMJIT_DISABLE_COPY(ETarget)
};

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

// ============================================================================
// [Platform Specific]
// ============================================================================

// [X86 / X64]
#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
#include "CompilerX86X64.h"
#endif // ASMJIT_X86 || ASMJIT_X64

// [Guard]
#endif // _ASMJIT_COMPILER_H

```

`AsmJit/CompilerX86X64.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// We are using sprintf() here.
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif // _MSC_VER

// [Dependencies]
#include "Assembler.h"
#include "CodeGenerator.h"
#include "Compiler.h"
#include "CpuInfo.h"
#include "Logger.h"
#include "Util_p.h"

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [Helpers - Logging]
// ============================================================================

// Defined in AssemblerX86X64.cpp.
ASMJIT_HIDDEN char* dumpRegister(char* buf, uint32_t type, uint32_t index) ASMJIT_NOTHROW;
ASMJIT_HIDDEN char* dumpOperand(char* buf, const Operand* op, uint32_t memRegType) ASMJIT_NOTHROW;

// ============================================================================
// [Helpers - Variables]
// ============================================================================

struct VariableInfo
{
  enum CLASS_INFO
  {
    CLASS_NONE   = 0x00,
    CLASS_GP     = 0x01,
    CLASS_X87    = 0x02,
    CLASS_MM     = 0x04,
    CLASS_XMM    = 0x08,
  };

  enum FLAGS
  {
    FLAG_SP_FP  = 0x10,
    FLAG_DP_FP  = 0x20,
    FLAG_VECTOR = 0x40
  };

  uint32_t code;
  uint8_t size;
  uint8_t clazz;
  uint8_t flags;
  uint8_t reserved_0;
  char name[8];
};

#define C(c) VariableInfo::CLASS_##c
#define F(f) VariableInfo::FLAG_##f
static const VariableInfo variableInfo[] =
{
  /*  0 */ { REG_TYPE_GPD   , 4 , C(GP) , 0                   , 0, "GP.D"        },
  /*  1 */ { REG_TYPE_GPQ   , 8 , C(GP) , 0                   , 0, "GP.Q"        },
  /*  2 */ { REG_TYPE_X87   , 4 , C(X87), F(SP_FP)            , 0, "X87"         },
  /*  3 */ { REG_TYPE_X87   , 4 , C(X87), F(SP_FP)            , 0, "X87.1F"      },
  /*  4 */ { REG_TYPE_X87   , 8 , C(X87), F(DP_FP)            , 0, "X87.1D"      },
  /*  5 */ { REG_TYPE_MM    , 8 , C(MM) ,            F(VECTOR), 0, "MM"          },
  /*  6 */ { REG_TYPE_XMM   , 16, C(XMM), 0                   , 0, "XMM"         },
  /*  7 */ { REG_TYPE_XMM   , 4 , C(XMM), F(SP_FP)            , 0, "XMM.1F"      },
  /*  8 */ { REG_TYPE_XMM   , 8 , C(XMM), F(DP_FP)            , 0, "XMM.1D"      },
  /*  9 */ { REG_TYPE_XMM   , 16, C(XMM), F(SP_FP) | F(VECTOR), 0, "XMM.4F"      },
  /* 10 */ { REG_TYPE_XMM   , 16, C(XMM), F(DP_FP) | F(VECTOR), 0, "XMM.2D"      }
};
#undef F
#undef C

static uint32_t getVariableClass(uint32_t type)
{
  ASMJIT_ASSERT(type < ASMJIT_ARRAY_SIZE(variableInfo));
  return variableInfo[type].clazz;
}

static uint32_t getVariableSize(uint32_t type)
{
  ASMJIT_ASSERT(type < ASMJIT_ARRAY_SIZE(variableInfo));
  return variableInfo[type].size;
}

static uint32_t getVariableRegisterCode(uint32_t type, uint32_t index)
{
  ASMJIT_ASSERT(type < ASMJIT_ARRAY_SIZE(variableInfo));
  return variableInfo[type].code | index;
}

static bool isVariableInteger(uint32_t type)
{
  ASMJIT_ASSERT(type < ASMJIT_ARRAY_SIZE(variableInfo));
  return (variableInfo[type].clazz & VariableInfo::CLASS_GP) != 0;
}

static bool isVariableFloat(uint32_t type)
{
  ASMJIT_ASSERT(type < ASMJIT_ARRAY_SIZE(variableInfo));
  return (variableInfo[type].flags & (VariableInfo::FLAG_SP_FP | VariableInfo::FLAG_DP_FP)) != 0;
}

static GPVar GPVarFromData(VarData* vdata)
{
  GPVar var;
  var._var.id = vdata->id;
  var._var.size = vdata->size;
  var._var.registerCode = variableInfo[vdata->type].code;
  var._var.variableType = vdata->type;
  return var;
}

static MMVar MMVarFromData(VarData* vdata)
{
  MMVar var;
  var._var.id = vdata->id;
  var._var.size = vdata->size;
  var._var.registerCode = variableInfo[vdata->type].code;
  var._var.variableType = vdata->type;
  return var;
}

static XMMVar XMMVarFromData(VarData* vdata)
{
  XMMVar var;
  var._var.id = vdata->id;
  var._var.size = vdata->size;
  var._var.registerCode = variableInfo[vdata->type].code;
  var._var.variableType = vdata->type;
  return var;
}

// ============================================================================
// [Helpers - Emittables]
// ============================================================================

static void delAll(Emittable* first) ASMJIT_NOTHROW
{
  Emittable* cur = first;

  while (cur)
  {
    Emittable* next = cur->getNext();
    cur->~Emittable();
    cur = next;
  }
}

// ============================================================================
// [Helpers - Compiler]
// ============================================================================

template<typename T>
inline T* Compiler_newObject(CompilerCore* self) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self));
}

template<typename T, typename P1>
inline T* Compiler_newObject(CompilerCore* self, P1 p1) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self), p1);
}

template<typename T, typename P1, typename P2>
inline T* Compiler_newObject(CompilerCore* self, P1 p1, P2 p2) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self), p1, p2);
}

template<typename T, typename P1, typename P2, typename P3>
inline T* Compiler_newObject(CompilerCore* self, P1 p1, P2 p2, P3 p3) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self), p1, p2, p3);
}

template<typename T, typename P1, typename P2, typename P3, typename P4>
inline T* Compiler_newObject(CompilerCore* self, P1 p1, P2 p2, P3 p3, P4 p4) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self), p1, p2, p3, p4);
}

template<typename T, typename P1, typename P2, typename P3, typename P4, typename P5>
inline T* Compiler_newObject(CompilerCore* self, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5) ASMJIT_NOTHROW
{
  void* addr = self->getZone().zalloc(sizeof(T));
  return new(addr) T(reinterpret_cast<Compiler*>(self), p1, p2, p3, p4, p5);
}

// ============================================================================
// [AsmJit::FunctionPrototype]
// ============================================================================

FunctionPrototype::FunctionPrototype() ASMJIT_NOTHROW
{
  // Safe defaults.
  _clear();
}

FunctionPrototype::~FunctionPrototype() ASMJIT_NOTHROW
{
}

void FunctionPrototype::setPrototype(
  uint32_t callingConvention,
  const uint32_t* arguments,
  uint32_t argumentsCount,
  uint32_t returnValue) ASMJIT_NOTHROW
{
  _setCallingConvention(callingConvention);

  if (argumentsCount > 32) argumentsCount = 32;
  _setPrototype(arguments, argumentsCount, returnValue);
}

uint32_t FunctionPrototype::findArgumentByRegisterCode(uint32_t regCode) const ASMJIT_NOTHROW
{
  uint32_t type = regCode & REG_TYPE_MASK;
  uint32_t idx = regCode & REG_INDEX_MASK;

  uint32_t clazz;
  uint32_t i;

  switch (type)
  {
    case REG_TYPE_GPD:
    case REG_TYPE_GPQ:
      clazz = VariableInfo::CLASS_GP;
      break;

    case REG_TYPE_MM:
      clazz = VariableInfo::CLASS_MM;
      break;

    case REG_TYPE_XMM:
      clazz = VariableInfo::CLASS_XMM;
      break;

    default:
      return INVALID_VALUE;
  }

  for (i = 0; i < _argumentsCount; i++)
  {
    const Argument& arg = _arguments[i];
    if ((getVariableClass(arg.variableType) & clazz) != 0 && (arg.registerIndex == idx))
      return i;
  }

  return INVALID_VALUE;
}

void FunctionPrototype::_clear() ASMJIT_NOTHROW
{
  _callingConvention = CALL_CONV_NONE;
  _calleePopsStack = false;

  _argumentsCount = 0;
  _argumentsDirection = ARGUMENT_DIR_RIGHT_TO_LEFT;
  _argumentsStackSize = 0;

  _returnValue = INVALID_VALUE;

  Util::memset32(_argumentsGPList , INVALID_VALUE, ASMJIT_ARRAY_SIZE(_argumentsGPList ));
  Util::memset32(_argumentsXMMList, INVALID_VALUE, ASMJIT_ARRAY_SIZE(_argumentsXMMList));

  _argumentsGP  = 0;
  _argumentsMM  = 0;
  _argumentsXMM = 0;

  _preservedGP  = 0;
  _preservedMM  = 0;
  _preservedXMM = 0;

  _passedGP  = 0;
  _passedMM  = 0;
  _passedXMM = 0;
}

void FunctionPrototype::_setCallingConvention(uint32_t callingConvention) ASMJIT_NOTHROW
{
  // Safe defaults.
  _clear();

  _callingConvention = callingConvention;

  // --------------------------------------------------------------------------
  // [X86 Calling Conventions]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_X86)
  _preservedGP  = (1 << REG_INDEX_EBX) |
                  (1 << REG_INDEX_ESP) |
                  (1 << REG_INDEX_EBP) |
                  (1 << REG_INDEX_ESI) |
                  (1 << REG_INDEX_EDI) ;
  _preservedXMM = 0;

  switch (_callingConvention)
  {
    case CALL_CONV_CDECL:
      break;

    case CALL_CONV_STDCALL:
      _calleePopsStack = true;
      break;

    case CALL_CONV_MSTHISCALL:
      _calleePopsStack = true;
      _argumentsGPList[0] = REG_INDEX_ECX;

      _argumentsGP =  (1 << REG_INDEX_ECX);
      break;

    case CALL_CONV_MSFASTCALL:
      _calleePopsStack = true;
      _argumentsGPList[0] = REG_INDEX_ECX;
      _argumentsGPList[1] = REG_INDEX_EDX;

      _argumentsGP =  (1 << REG_INDEX_ECX) |
                      (1 << REG_INDEX_EDX) ;
      break;

    case CALL_CONV_BORLANDFASTCALL:
      _calleePopsStack = true;
      _argumentsDirection = ARGUMENT_DIR_LEFT_TO_RIGHT;
      _argumentsGPList[0] = REG_INDEX_EAX;
      _argumentsGPList[1] = REG_INDEX_EDX;
      _argumentsGPList[2] = REG_INDEX_ECX;

      _argumentsGP =  (1 << REG_INDEX_EAX) |
                      (1 << REG_INDEX_EDX) |
                      (1 << REG_INDEX_ECX) ;
      break;

    case CALL_CONV_GCCFASTCALL:
      _calleePopsStack = true;
      _argumentsGPList[0] = REG_INDEX_ECX;
      _argumentsGPList[1] = REG_INDEX_EDX;

      _argumentsGP =  (1 << REG_INDEX_ECX) |
                      (1 << REG_INDEX_EDX) ;
      break;

    case CALL_CONV_GCCREGPARM_1:
      _calleePopsStack = false;
      _argumentsGPList[0] = REG_INDEX_EAX;

      _argumentsGP =  (1 << REG_INDEX_EAX) ;
      break;

    case CALL_CONV_GCCREGPARM_2:
      _calleePopsStack = false;
      _argumentsGPList[0] = REG_INDEX_EAX;
      _argumentsGPList[1] = REG_INDEX_EDX;

      _argumentsGP =  (1 << REG_INDEX_EAX) |
                      (1 << REG_INDEX_EDX) ;
      break;

    case CALL_CONV_GCCREGPARM_3:
      _calleePopsStack = false;
      _argumentsGPList[0] = REG_INDEX_EAX;
      _argumentsGPList[1] = REG_INDEX_EDX;
      _argumentsGPList[2] = REG_INDEX_ECX;

      _argumentsGP =  (1 << REG_INDEX_EAX) |
                      (1 << REG_INDEX_EDX) |
                      (1 << REG_INDEX_ECX) ;
      break;

    default:
      // Illegal calling convention.
      ASMJIT_ASSERT(0);
  }
#endif // ASMJIT_X86

  // --------------------------------------------------------------------------
  // [X64 Calling Conventions]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_X64)
  switch (_callingConvention)
  {
    case CALL_CONV_X64W:
      _argumentsGPList[0] = REG_INDEX_RCX;
      _argumentsGPList[1] = REG_INDEX_RDX;
      _argumentsGPList[2] = REG_INDEX_R8;
      _argumentsGPList[3] = REG_INDEX_R9;

      _argumentsXMMList[0] = REG_INDEX_XMM0;
      _argumentsXMMList[1] = REG_INDEX_XMM1;
      _argumentsXMMList[2] = REG_INDEX_XMM2;
      _argumentsXMMList[3] = REG_INDEX_XMM3;

      _argumentsGP =  (1 << REG_INDEX_RCX  ) |
                      (1 << REG_INDEX_RDX  ) |
                      (1 << REG_INDEX_R8   ) |
                      (1 << REG_INDEX_R9   ) ;

      _argumentsXMM = (1 << REG_INDEX_XMM0 ) |
                      (1 << REG_INDEX_XMM1 ) |
                      (1 << REG_INDEX_XMM2 ) |
                      (1 << REG_INDEX_XMM3 ) ;

      _preservedGP =  (1 << REG_INDEX_RBX  ) |
                      (1 << REG_INDEX_RSP  ) |
                      (1 << REG_INDEX_RBP  ) |
                      (1 << REG_INDEX_RSI  ) |
                      (1 << REG_INDEX_RDI  ) |
                      (1 << REG_INDEX_R12  ) |
                      (1 << REG_INDEX_R13  ) |
                      (1 << REG_INDEX_R14  ) |
                      (1 << REG_INDEX_R15  ) ;

      _preservedXMM = (1 << REG_INDEX_XMM6 ) |
                      (1 << REG_INDEX_XMM7 ) |
                      (1 << REG_INDEX_XMM8 ) |
                      (1 << REG_INDEX_XMM9 ) |
                      (1 << REG_INDEX_XMM10) |
                      (1 << REG_INDEX_XMM11) |
                      (1 << REG_INDEX_XMM12) |
                      (1 << REG_INDEX_XMM13) |
                      (1 << REG_INDEX_XMM14) |
                      (1 << REG_INDEX_XMM15) ;
      break;

    case CALL_CONV_X64U:
      _argumentsGPList[0] = REG_INDEX_RDI;
      _argumentsGPList[1] = REG_INDEX_RSI;
      _argumentsGPList[2] = REG_INDEX_RDX;
      _argumentsGPList[3] = REG_INDEX_RCX;
      _argumentsGPList[4] = REG_INDEX_R8;
      _argumentsGPList[5] = REG_INDEX_R9;

      _argumentsXMMList[0] = REG_INDEX_XMM0;
      _argumentsXMMList[1] = REG_INDEX_XMM1;
      _argumentsXMMList[2] = REG_INDEX_XMM2;
      _argumentsXMMList[3] = REG_INDEX_XMM3;
      _argumentsXMMList[4] = REG_INDEX_XMM4;
      _argumentsXMMList[5] = REG_INDEX_XMM5;
      _argumentsXMMList[6] = REG_INDEX_XMM6;
      _argumentsXMMList[7] = REG_INDEX_XMM7;

      _argumentsGP =  (1 << REG_INDEX_RDI  ) |
                      (1 << REG_INDEX_RSI  ) |
                      (1 << REG_INDEX_RDX  ) |
                      (1 << REG_INDEX_RCX  ) |
                      (1 << REG_INDEX_R8   ) |
                      (1 << REG_INDEX_R9   ) ;

      _argumentsXMM = (1 << REG_INDEX_XMM0 ) |
                      (1 << REG_INDEX_XMM1 ) |
                      (1 << REG_INDEX_XMM2 ) |
                      (1 << REG_INDEX_XMM3 ) |
                      (1 << REG_INDEX_XMM4 ) |
                      (1 << REG_INDEX_XMM5 ) |
                      (1 << REG_INDEX_XMM6 ) |
                      (1 << REG_INDEX_XMM7 ) ;

      _preservedGP =  (1 << REG_INDEX_RBX  ) |
                      (1 << REG_INDEX_RSP  ) |
                      (1 << REG_INDEX_RBP  ) |
                      (1 << REG_INDEX_R12  ) |
                      (1 << REG_INDEX_R13  ) |
                      (1 << REG_INDEX_R14  ) |
                      (1 << REG_INDEX_R15  ) ;
      break;

    default:
      // Illegal calling convention.
      ASMJIT_ASSERT(0);
  }
#endif // ASMJIT_X64
}

void FunctionPrototype::_setPrototype(
  const uint32_t* argumentsData,
  uint32_t argumentsCount,
  uint32_t returnValue) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(argumentsCount <= 32);

  int32_t i;

  int32_t posGP = 0;
  int32_t posXMM = 0;
  int32_t stackOffset = 0;

  _returnValue = returnValue;

  for (i = 0; i < (sysint_t)argumentsCount; i++)
  {
    Argument& a = _arguments[i];
    a.variableType = argumentsData[i];
    a.registerIndex = INVALID_VALUE;
    a.stackOffset = INVALID_VALUE;
  }

  _argumentsCount = (uint32_t)argumentsCount;
  if (_argumentsCount == 0) return;

  // --------------------------------------------------------------------------
  // [X86 Calling Conventions (32-bit)]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_X86)
  // Register arguments (Integer), always left-to-right.
  for (i = 0; i != argumentsCount; i++)
  {
    Argument& a = _arguments[i];
    if (isVariableInteger(a.variableType) && posGP < 16 && _argumentsGPList[posGP] != INVALID_VALUE)
    {
      a.registerIndex = _argumentsGPList[posGP++];
      _passedGP |= Util::maskFromIndex(a.registerIndex);
    }
  }

  // Stack arguments.
  bool ltr = _argumentsDirection == ARGUMENT_DIR_LEFT_TO_RIGHT;
  sysint_t istart = ltr ? 0 : (sysint_t)argumentsCount - 1;
  sysint_t iend   = ltr ? (sysint_t)argumentsCount : -1;
  sysint_t istep  = ltr ? 1 : -1;

  for (i = istart; i != iend; i += istep)
  {
    Argument& a = _arguments[i];
    if (a.registerIndex != INVALID_VALUE) continue;

    if (isVariableInteger(a.variableType))
    {
      stackOffset -= 4;
      a.stackOffset = stackOffset;
    }
    else if (isVariableFloat(a.variableType))
    {
      int32_t size = (int32_t)variableInfo[a.variableType].size;
      stackOffset -= size;
      a.stackOffset = stackOffset;
    }
  }
#endif // ASMJIT_X86

  // --------------------------------------------------------------------------
  // [X64 Calling Conventions (64-bit)]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_X64)
  // Windows 64-bit specific.
  if (_callingConvention == CALL_CONV_X64W)
  {
    sysint_t max = argumentsCount < 4 ? argumentsCount : 4;

    // Register arguments (Integer / FP), always left to right.
    for (i = 0; i != max; i++)
    {
      Argument& a = _arguments[i];

      if (isVariableInteger(a.variableType))
      {
        a.registerIndex = _argumentsGPList[i];
        _passedGP |= Util::maskFromIndex(a.registerIndex);
      }
      else if (isVariableFloat(a.variableType))
      {
        a.registerIndex = _argumentsXMMList[i];
        _passedXMM |= Util::maskFromIndex(a.registerIndex);
      }
    }

    // Stack arguments (always right-to-left).
    for (i = argumentsCount - 1; i != -1; i--)
    {
      Argument& a = _arguments[i];
      if (a.isAssigned()) continue;

      if (isVariableInteger(a.variableType))
      {
        stackOffset -= 8; // Always 8 bytes.
        a.stackOffset = stackOffset;
      }
      else if (isVariableFloat(a.variableType))
      {
        int32_t size = (int32_t)variableInfo[a.variableType].size;
        stackOffset -= size;
        a.stackOffset = stackOffset;
      }
    }

    // 32 bytes shadow space (X64W calling convention specific).
    stackOffset -= 4 * 8;
  }
  // Linux/Unix 64-bit (AMD64 calling convention).
  else
  {
    // Register arguments (Integer), always left to right.
    for (i = 0; i != argumentsCount; i++)
    {
      Argument& a = _arguments[i];
      if (isVariableInteger(a.variableType) && posGP < 32 && _argumentsGPList[posGP] != INVALID_VALUE)
      {
        a.registerIndex = _argumentsGPList[posGP++];
        _passedGP |= Util::maskFromIndex(a.registerIndex);
      }
    }

    // Register arguments (FP), always left to right.
    for (i = 0; i != argumentsCount; i++)
    {
      Argument& a = _arguments[i];
      if (isVariableFloat(a.variableType))
      {
        a.registerIndex = _argumentsXMMList[posXMM++];
        _passedXMM |= Util::maskFromIndex(a.registerIndex);
      }
    }

    // Stack arguments.
    for (i = argumentsCount - 1; i != -1; i--)
    {
      Argument& a = _arguments[i];
      if (a.isAssigned()) continue;

      if (isVariableInteger(a.variableType))
      {
        stackOffset -= 8;
        a.stackOffset = stackOffset;
      }
      else if (isVariableFloat(a.variableType))
      {
        int32_t size = (int32_t)variableInfo[a.variableType].size;

        stackOffset -= size;
        a.stackOffset = stackOffset;
      }
    }
  }
#endif // ASMJIT_X64

  // Modify stack offset (all function parameters will be in positive stack
  // offset that is never zero).
  for (i = 0; i < (sysint_t)argumentsCount; i++)
  {
    if (_arguments[i].registerIndex == INVALID_VALUE)
      _arguments[i].stackOffset += sizeof(sysint_t) - stackOffset;
  }

  _argumentsStackSize = (uint32_t)(-stackOffset);
}

void FunctionPrototype::_setReturnValue(uint32_t valueId) ASMJIT_NOTHROW
{
  // TODO.
}

// ============================================================================
// [AsmJit::EVariableHint]
// ============================================================================

EVariableHint::EVariableHint(Compiler* c, VarData* vdata, uint32_t hintId, uint32_t hintValue) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_VARIABLE_HINT),
  _vdata(vdata),
  _hintId(hintId),
  _hintValue(hintValue)
{
  ASMJIT_ASSERT(_vdata != NULL);
}

EVariableHint::~EVariableHint() ASMJIT_NOTHROW
{
}

void EVariableHint::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset;

  // First emittable (begin of variable scope).
  if (_vdata->firstEmittable == NULL) _vdata->firstEmittable = this;

  Emittable* oldLast = _vdata->lastEmittable;

  // Last emittable (end of variable scope).
  _vdata->lastEmittable = this;

  switch (_hintId)
  {
    case VARIABLE_HINT_ALLOC:
    case VARIABLE_HINT_SPILL:
    case VARIABLE_HINT_SAVE:
      if (!cc._isActive(_vdata)) cc._addActive(_vdata);
      break;
    case VARIABLE_HINT_SAVE_AND_UNUSE:
      if (!cc._isActive(_vdata)) cc._addActive(_vdata);
      break;
    case VARIABLE_HINT_UNUSE:
      if (oldLast) oldLast->_tryUnuseVar(_vdata);
      break;
  }
}

Emittable* EVariableHint::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  switch (_hintId)
  {
    case VARIABLE_HINT_ALLOC:
      cc.allocVar(_vdata, _hintValue, VARIABLE_ALLOC_READ);
      break;
    case VARIABLE_HINT_SPILL:
      if (_vdata->state == VARIABLE_STATE_REGISTER)
        cc.spillVar(_vdata);
      break;
    case VARIABLE_HINT_SAVE:
    case VARIABLE_HINT_SAVE_AND_UNUSE:
      if (_vdata->state == VARIABLE_STATE_REGISTER && _vdata->changed)
      {
        cc.emitSaveVar(_vdata, _vdata->registerIndex);
        _vdata->changed = false;
      }
      if (_hintId == VARIABLE_HINT_SAVE_AND_UNUSE) goto unuse;
      break;
    case VARIABLE_HINT_UNUSE:
unuse:
      cc.unuseVar(_vdata, VARIABLE_STATE_UNUSED);
      goto end;
  }

  cc._unuseVarOnEndOfScope(this, _vdata);

end:
  return translated();
}

int EVariableHint::getMaxSize() const ASMJIT_NOTHROW
{
  // Variable hint is NOP, but it can generate other emittables which can do
  // something.
  return 0;
}

// ============================================================================
// [AsmJit::EInstruction]
// ============================================================================

EInstruction::EInstruction(Compiler* c, uint32_t code, Operand* operandsData, uint32_t operandsCount) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_INSTRUCTION)
{
  _code = code;
  _emitOptions = c->_emitOptions;
  // Each created instruction takes emit options and clears it.
  c->_emitOptions = 0;

  _operands = operandsData;
  _operandsCount = operandsCount;
  _memOp = NULL;

  _variables = NULL;
  _variablesCount = 0;

  uint32_t i;
  for (i = 0; i < operandsCount; i++)
  {
    if (_operands[i].isMem())
    {
      _memOp = reinterpret_cast<Mem*>(&_operands[i]);
      break;
    }
  }

  const InstructionDescription* id = &instructionDescription[_code];
  _isSpecial = id->isSpecial();
  _isFPU = id->isFPU();
  _isGPBLoUsed = false;
  _isGPBHiUsed = false;

  if (_isSpecial)
  {
    // ${SPECIAL_INSTRUCTION_HANDLING_BEGIN}
    switch (_code)
    {
      case INST_CPUID:
        // Special...
        break;

      case INST_CBW:
      case INST_CDQE:
      case INST_CWDE:
        // Special...
        break;

      case INST_CMPXCHG:
      case INST_CMPXCHG8B:
#if defined(ASMJIT_X64)
      case INST_CMPXCHG16B:
#endif // ASMJIT_X64
        // Special...
        break;

#if defined(ASMJIT_X86)
      case INST_DAA:
      case INST_DAS:
        // Special...
        break;
#endif // ASMJIT_X86

      case INST_IMUL:
        switch (operandsCount)
        {
          case 2:
            // IMUL dst, src is not special instruction.
            _isSpecial = false;
            break;
          case 3:
            if (!(_operands[0].isVar() && _operands[1].isVar() && _operands[2].isVarMem()))
            {
              // Only IMUL dst_hi, dst_lo, reg/mem is special, all others don't.
              _isSpecial = false;
            }
            break;
        }
        break;
      case INST_MUL:
      case INST_IDIV:
      case INST_DIV:
        // Special...
        break;

      case INST_MOV_PTR:
        // Special...
        break;

      case INST_LAHF:
      case INST_SAHF:
        // Special...
        break;

      case INST_MASKMOVQ:
      case INST_MASKMOVDQU:
        // Special...
        break;

      case INST_ENTER:
      case INST_LEAVE:
        // Special...
        break;

      case INST_RET:
        // Special...
        break;

      case INST_MONITOR:
      case INST_MWAIT:
        // Special...
        break;

      case INST_POP:
      case INST_POPAD:
      case INST_POPFD:
      case INST_POPFQ:
        // Special...
        break;

      case INST_PUSH:
      case INST_PUSHAD:
      case INST_PUSHFD:
      case INST_PUSHFQ:
        // Special...
        break;

      case INST_RCL:
      case INST_RCR:
      case INST_ROL:
      case INST_ROR:
      case INST_SAL:
      case INST_SAR:
      case INST_SHL:
      case INST_SHR:
        // Rot instruction is special only if last operand is variable (register).
        _isSpecial = _operands[1].isVar();
        break;

      case INST_SHLD:
      case INST_SHRD:
        // Shld/Shrd instruction is special only if last operand is variable (register).
        _isSpecial = _operands[2].isVar();
        break;

      case INST_RDTSC:
      case INST_RDTSCP:
        // Special...
        break;

      case INST_REP_LODSB:
      case INST_REP_LODSD:
      case INST_REP_LODSQ:
      case INST_REP_LODSW:
      case INST_REP_MOVSB:
      case INST_REP_MOVSD:
      case INST_REP_MOVSQ:
      case INST_REP_MOVSW:
      case INST_REP_STOSB:
      case INST_REP_STOSD:
      case INST_REP_STOSQ:
      case INST_REP_STOSW:
      case INST_REPE_CMPSB:
      case INST_REPE_CMPSD:
      case INST_REPE_CMPSQ:
      case INST_REPE_CMPSW:
      case INST_REPE_SCASB:
      case INST_REPE_SCASD:
      case INST_REPE_SCASQ:
      case INST_REPE_SCASW:
      case INST_REPNE_CMPSB:
      case INST_REPNE_CMPSD:
      case INST_REPNE_CMPSQ:
      case INST_REPNE_CMPSW:
      case INST_REPNE_SCASB:
      case INST_REPNE_SCASD:
      case INST_REPNE_SCASQ:
      case INST_REPNE_SCASW:
        // Special...
        break;

      default:
        ASMJIT_ASSERT(0);
    }
    // ${SPECIAL_INSTRUCTION_HANDLING_END}
  }
}

EInstruction::~EInstruction() ASMJIT_NOTHROW
{
}

void EInstruction::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
#define __GET_VARIABLE(__vardata__) \
  { \
    VarData* _candidate = __vardata__; \
    \
    for (var = cur; ;) \
    { \
      if (var == _variables) \
      { \
        var = cur++; \
        var->vdata = _candidate; \
        var->vflags = 0; \
        var->regMask = 0xFFFFFFFF; \
        break; \
      } \
      \
      var--; \
      \
      if (var->vdata == _candidate) \
      { \
        break; \
      } \
    } \
    \
    ASMJIT_ASSERT(var != NULL); \
  }

  _offset = cc._currentOffset;

  const InstructionDescription* id = &instructionDescription[_code];

  uint32_t i, len = _operandsCount;
  uint32_t variablesCount = 0;

  for (i = 0; i < len; i++)
  {
    Operand& o = _operands[i];

    if (o.isVar())
    {
      ASMJIT_ASSERT(o.getId() != INVALID_VALUE);
      VarData* vdata = _compiler->_getVarData(o.getId());
      ASMJIT_ASSERT(vdata != NULL);

      if (reinterpret_cast<BaseVar*>(&o)->isGPVar())
      {
        if (reinterpret_cast<GPVar*>(&o)->isGPBLo()) { _isGPBLoUsed = true; vdata->registerGPBLoCount++; };
        if (reinterpret_cast<GPVar*>(&o)->isGPBHi()) { _isGPBHiUsed = true; vdata->registerGPBHiCount++; };
      }

      if (vdata->workOffset != _offset)
      {
        if (!cc._isActive(vdata)) cc._addActive(vdata);

        vdata->workOffset = _offset;
        variablesCount++;
      }
    }
    else if (o.isMem())
    {
      if ((o.getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        cc._markMemoryUsed(vdata);

        if (vdata->workOffset != _offset)
        {
          if (!cc._isActive(vdata)) cc._addActive(vdata);

          vdata->workOffset = _offset;
          variablesCount++;
        }
      }
      else if ((o._mem.base & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.base);
        ASMJIT_ASSERT(vdata != NULL);

        if (vdata->workOffset != _offset)
        {
          if (!cc._isActive(vdata)) cc._addActive(vdata);

          vdata->workOffset = _offset;
          variablesCount++;
        }
      }

      if ((o._mem.index & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.index);
        ASMJIT_ASSERT(vdata != NULL);

        if (vdata->workOffset != _offset)
        {
          if (!cc._isActive(vdata)) cc._addActive(vdata);

          vdata->workOffset = _offset;
          variablesCount++;
        }
      }
    }
  }

  if (!variablesCount)
  {
    cc._currentOffset++;
    return;
  }

  _variables = reinterpret_cast<VarAllocRecord*>(_compiler->getZone().zalloc(sizeof(VarAllocRecord) * variablesCount));
  if (!_variables)
  {
    _compiler->setError(ERROR_NO_HEAP_MEMORY);
    cc._currentOffset++;
    return;
  }

  _variablesCount = variablesCount;

  VarAllocRecord* cur = _variables;
  VarAllocRecord* var = NULL;

  bool _isGPBUsed = _isGPBLoUsed | _isGPBHiUsed;
  uint32_t gpRestrictMask = Util::maskUpToIndex(REG_NUM_GP);

#if defined(ASMJIT_X64)
  if (_isGPBHiUsed)
  {
    gpRestrictMask &= Util::maskFromIndex(REG_INDEX_EAX) |
                      Util::maskFromIndex(REG_INDEX_EBX) |
                      Util::maskFromIndex(REG_INDEX_ECX) |
                      Util::maskFromIndex(REG_INDEX_EDX) |
                      Util::maskFromIndex(REG_INDEX_EBP) |
                      Util::maskFromIndex(REG_INDEX_ESI) |
                      Util::maskFromIndex(REG_INDEX_EDI) ;
  }
#endif // ASMJIT_X64

  for (i = 0; i < len; i++)
  {
    Operand& o = _operands[i];

    if (o.isVar())
    {
      VarData* vdata = _compiler->_getVarData(o.getId());
      ASMJIT_ASSERT(vdata != NULL);

      __GET_VARIABLE(vdata)
      var->vflags |= VARIABLE_ALLOC_REGISTER;

      if (_isGPBUsed)
      {
#if defined(ASMJIT_X86)
        if (reinterpret_cast<GPVar*>(&o)->isGPB())
        {
          var->regMask &= Util::maskFromIndex(REG_INDEX_EAX) |
                          Util::maskFromIndex(REG_INDEX_EBX) |
                          Util::maskFromIndex(REG_INDEX_ECX) |
                          Util::maskFromIndex(REG_INDEX_EDX) ;
        }
#else
        // Restrict all BYTE registers to RAX/RBX/RCX/RDX if HI BYTE register
        // is used (REX prefix makes HI BYTE addressing unencodable).
        if (_isGPBHiUsed)
        {
          if (reinterpret_cast<GPVar*>(&o)->isGPB())
          {
            var->regMask &= Util::maskFromIndex(REG_INDEX_EAX) |
                            Util::maskFromIndex(REG_INDEX_EBX) |
                            Util::maskFromIndex(REG_INDEX_ECX) |
                            Util::maskFromIndex(REG_INDEX_EDX) ;
          }
        }
#endif // ASMJIT_X86/X64
      }

      if (isSpecial())
      {
        // ${SPECIAL_INSTRUCTION_HANDLING_BEGIN}
        switch (_code)
        {
          case INST_CPUID:
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EBX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 3:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_CBW:
          case INST_CDQE:
          case INST_CWDE:
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_CMPXCHG:
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE;
                break;
              case 2:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_CMPXCHG8B:
#if defined(ASMJIT_X64)
          case INST_CMPXCHG16B:
#endif // ASMJIT_X64
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 3:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EBX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

#if defined(ASMJIT_X86)
          case INST_DAA:
          case INST_DAS:
            ASMJIT_ASSERT(i == 0);
            vdata->registerRWCount++;
            var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
            var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
            gpRestrictMask &= ~var->regMask;
            break;
#endif // ASMJIT_X86

          case INST_IMUL:
          case INST_MUL:
          case INST_IDIV:
          case INST_DIV:
            switch (i)
            {
              case 0:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_MOV_PTR:
            switch (i)
            {
              case 0:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_LAHF:
            ASMJIT_ASSERT(i == 0);
            vdata->registerWriteCount++;
            var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
            var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
            gpRestrictMask &= ~var->regMask;
            break;

          case INST_SAHF:
            ASMJIT_ASSERT(i == 0);
            vdata->registerReadCount++;
            var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
            var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
            gpRestrictMask &= ~var->regMask;
            break;

          case INST_MASKMOVQ:
          case INST_MASKMOVDQU:
            switch (i)
            {
              case 0:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
              case 2:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ;
                break;
            }
            break;

          case INST_ENTER:
          case INST_LEAVE:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_RET:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_MONITOR:
          case INST_MWAIT:
            // TODO: MONITOR/MWAIT (COMPILER).
            break;

          case INST_POP:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_POPAD:
          case INST_POPFD:
          case INST_POPFQ:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_PUSH:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_PUSHAD:
          case INST_PUSHFD:
          case INST_PUSHFQ:
            // TODO: SPECIAL INSTRUCTION.
            break;

          case INST_RCL:
          case INST_RCR:
          case INST_ROL:
          case INST_ROR:
          case INST_SAL:
          case INST_SAR:
          case INST_SHL:
          case INST_SHR:
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_SHLD:
          case INST_SHRD:
            switch (i)
            {
              case 0:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ;
                break;
              case 2:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_RDTSC:
          case INST_RDTSCP:
            switch (i)
            {
              case 0:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                ASMJIT_ASSERT(_code == INST_RDTSCP);
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;

              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_REP_LODSB:
          case INST_REP_LODSD:
          case INST_REP_LODSQ:
          case INST_REP_LODSW:
            switch (i)
            {
              case 0:
                vdata->registerWriteCount++;
                var->vflags |= VARIABLE_ALLOC_WRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ESI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_REP_MOVSB:
          case INST_REP_MOVSD:
          case INST_REP_MOVSQ:
          case INST_REP_MOVSW:
          case INST_REPE_CMPSB:
          case INST_REPE_CMPSD:
          case INST_REPE_CMPSQ:
          case INST_REPE_CMPSW:
          case INST_REPNE_CMPSB:
          case INST_REPNE_CMPSD:
          case INST_REPNE_CMPSQ:
          case INST_REPNE_CMPSW:
            switch (i)
            {
              case 0:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ESI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_REP_STOSB:
          case INST_REP_STOSD:
          case INST_REP_STOSQ:
          case INST_REP_STOSW:
            switch (i)
            {
              case 0:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              default:
                ASMJIT_ASSERT(0);
            }
            break;

          case INST_REPE_SCASB:
          case INST_REPE_SCASD:
          case INST_REPE_SCASQ:
          case INST_REPE_SCASW:
          case INST_REPNE_SCASB:
          case INST_REPNE_SCASD:
          case INST_REPNE_SCASQ:
          case INST_REPNE_SCASW:
            switch (i)
            {
              case 0:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EDI);
                gpRestrictMask &= ~var->regMask;
                break;
              case 1:
                vdata->registerReadCount++;
                var->vflags |= VARIABLE_ALLOC_READ | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_EAX);
                gpRestrictMask &= ~var->regMask;
                break;
              case 2:
                vdata->registerRWCount++;
                var->vflags |= VARIABLE_ALLOC_READWRITE | VARIABLE_ALLOC_SPECIAL;
                var->regMask = Util::maskFromIndex(REG_INDEX_ECX);
                gpRestrictMask &= ~var->regMask;
                break;
              default:
                ASMJIT_ASSERT(0);
            }
            break;

          default:
            ASMJIT_ASSERT(0);
        }
        // ${SPECIAL_INSTRUCTION_HANDLING_END}
      }
      else
      {
        if (i == 0)
        {
          // CMP/TEST instruction.
          if (id->code == INST_CMP || id->code == INST_TEST)
          {
            // Read-only case.
            vdata->registerReadCount++;
            var->vflags |= VARIABLE_ALLOC_READ;
          }
          // CVTTSD2SI/CVTTSS2SI instructions.
          else if (id->code == INST_CVTTSD2SI || id->code == INST_CVTTSS2SI)
          {
            // In 32-bit mode the whole destination is replaced. In 64-bit mode
            // we need to check whether the destination operand size is 64-bits.
#if defined(ASMJIT_X64)
            if (_operands[0].isRegType(REG_TYPE_GPQ))
            {
#endif // ASMJIT_X64
              // Write-only case.
              vdata->registerWriteCount++;
              var->vflags |= VARIABLE_ALLOC_WRITE;
#if defined(ASMJIT_X64)
            }
            else
            {
              // Read/Write.
              vdata->registerRWCount++;
              var->vflags |= VARIABLE_ALLOC_READWRITE;
            }
#endif // ASMJIT_X64
          }
          // MOV/MOVSS/MOVSD instructions.
          //
          // If instruction is MOV (source replaces the destination) or 
          // MOVSS/MOVSD and source operand is memory location then register
          // allocator should know that previous destination value is lost 
          // (write only operation).
          else if ((id->isMov()) ||
                  ((id->code == INST_MOVSS || id->code == INST_MOVSD) /* && _operands[1].isMem() */) ||
                  (id->code == INST_IMUL && _operandsCount == 3 && !isSpecial()))
          {
            // Write-only case.
            vdata->registerWriteCount++;
            var->vflags |= VARIABLE_ALLOC_WRITE;
          }
          else if (id->code == INST_LEA)
          {
            // Write.
            vdata->registerWriteCount++;
            var->vflags |= VARIABLE_ALLOC_WRITE;
          }
          else
          {
            // Read/Write.
            vdata->registerRWCount++;
            var->vflags |= VARIABLE_ALLOC_READWRITE;
          }
        }
        else
        {
          // Second, third, ... operands are read-only.
          vdata->registerReadCount++;
          var->vflags |= VARIABLE_ALLOC_READ;
        }

        if (!_memOp && i < 2 && (id->oflags[i] & InstructionDescription::O_MEM) != 0)
        {
          var->vflags |= VARIABLE_ALLOC_MEMORY;
        }
      }

      // If variable must be in specific register we could add some hint to allocator.
      if (var->vflags & VARIABLE_ALLOC_SPECIAL)
      {
        vdata->prefRegisterMask |= Util::maskFromIndex(var->regMask);
        cc._newRegisterHomeIndex(vdata, Util::findFirstBit(var->regMask));
      }
    }
    else if (o.isMem())
    {
      if ((o.getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        __GET_VARIABLE(vdata)

        if (i == 0)
        {
          // If variable is MOV instruction type (source replaces the destination)
          // or variable is MOVSS/MOVSD instruction then register allocator should
          // know that previous destination value is lost (write only operation).
          if (id->isMov() || ((id->code == INST_MOVSS || id->code == INST_MOVSD)))
          {
            // Write only case.
            vdata->memoryWriteCount++;
          }
          else
          {
            vdata->memoryRWCount++;
          }
        }
        else
        {
          vdata->memoryReadCount++;
        }
      }
      else if ((o._mem.base & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(reinterpret_cast<Mem&>(o).getBase());
        ASMJIT_ASSERT(vdata != NULL);

        __GET_VARIABLE(vdata)
        vdata->registerReadCount++;
        var->vflags |= VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_READ;
        var->regMask &= gpRestrictMask;
      }

      if ((o._mem.index & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(reinterpret_cast<Mem&>(o).getIndex());
        ASMJIT_ASSERT(vdata != NULL);

        __GET_VARIABLE(vdata)
        vdata->registerReadCount++;
        var->vflags |= VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_READ;
        var->regMask &= gpRestrictMask;
      }
    }
  }

  // Traverse all variables and update firstEmittable / lastEmittable. This
  // function is called from iterator that scans emittables using forward
  // direction so we can use this knowledge to optimize the process.
  //
  // Similar to ECall::prepare().
  for (i = 0; i < _variablesCount; i++)
  {
    VarData* v = _variables[i].vdata;

    // Update GP register allocator restrictions.
    if (isVariableInteger(v->type))
    {
      if (_variables[i].regMask == 0xFFFFFFFF) _variables[i].regMask &= gpRestrictMask;
    }

    // Update first/last emittable (begin of variable scope).
    if (v->firstEmittable == NULL) v->firstEmittable = this;
    v->lastEmittable = this;
  }

  // There are some instructions that can be used to clear register or to set
  // register to some value (ideal case is all zeros or all ones).
  //
  // xor/pxor reg, reg    ; Set all bits in reg to 0.
  // sub/psub reg, reg    ; Set all bits in reg to 0.
  // andn reg, reg        ; Set all bits in reg to 0.
  // pcmpgt reg, reg      ; Set all bits in reg to 0.
  // pcmpeq reg, reg      ; Set all bits in reg to 1.

  if (_variablesCount == 1 &&
      _operandsCount > 1 &&
      _operands[0].isVar() &&
      _operands[1].isVar() &&
      !_memOp)
  {
    switch (_code)
    {
      // XOR Instructions.
      case INST_XOR:
      case INST_XORPD:
      case INST_XORPS:
      case INST_PXOR:

      // ANDN Instructions.
      case INST_PANDN:

      // SUB Instructions.
      case INST_SUB:
      case INST_PSUBB:
      case INST_PSUBW:
      case INST_PSUBD:
      case INST_PSUBQ:
      case INST_PSUBSB:
      case INST_PSUBSW:
      case INST_PSUBUSB:
      case INST_PSUBUSW:

      // PCMPEQ Instructions.
      case INST_PCMPEQB:
      case INST_PCMPEQW:
      case INST_PCMPEQD:
      case INST_PCMPEQQ:

      // PCMPGT Instructions.
      case INST_PCMPGTB:
      case INST_PCMPGTW:
      case INST_PCMPGTD:
      case INST_PCMPGTQ:
        // Clear the read flag. This prevents variable alloc/spill.
        _variables[0].vflags = VARIABLE_ALLOC_WRITE;
        _variables[0].vdata->registerReadCount--;
        break;
    }
  }
  cc._currentOffset++;

#undef __GET_VARIABLE
}

Emittable* EInstruction::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i;
  uint32_t variablesCount = _variablesCount;

  if (variablesCount > 0)
  {
    // These variables are used by the instruction and we set current offset
    // to their work offsets -> getSpillCandidate never return the variable
    // used this instruction.
    for (i = 0; i < variablesCount; i++)
    {
      _variables->vdata->workOffset = cc._currentOffset;
    }

    // Alloc variables used by the instruction (special first).
    for (i = 0; i < variablesCount; i++)
    {
      VarAllocRecord& r = _variables[i];
      // Alloc variables with specific register first.
      if ((r.vflags & VARIABLE_ALLOC_SPECIAL) != 0)
        cc.allocVar(r.vdata, r.regMask, r.vflags);
    }

    for (i = 0; i < variablesCount; i++)
    {
      VarAllocRecord& r = _variables[i];
      // Alloc variables without specific register last.
      if ((r.vflags & VARIABLE_ALLOC_SPECIAL) == 0)
        cc.allocVar(r.vdata, r.regMask, r.vflags);
    }

    cc.translateOperands(_operands, _operandsCount);
  }

  if (_memOp && (_memOp->getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
  {
    VarData* vdata = _compiler->_getVarData(_memOp->getId());
    ASMJIT_ASSERT(vdata != NULL);

    switch (vdata->state)
    {
      case VARIABLE_STATE_UNUSED:
        vdata->state = VARIABLE_STATE_MEMORY;
        break;
      case VARIABLE_STATE_REGISTER:
        vdata->changed = false;
        cc.unuseVar(vdata, VARIABLE_STATE_MEMORY);
        break;
    }
  }

  for (i = 0; i < variablesCount; i++)
  {
    cc._unuseVarOnEndOfScope(this, &_variables[i]);
  }

  return translated();
}

void EInstruction::emit(Assembler& a) ASMJIT_NOTHROW
{
  a._comment = _comment;
  a._emitOptions = _emitOptions;

  if (isSpecial())
  {
    // ${SPECIAL_INSTRUCTION_HANDLING_BEGIN}
    switch (_code)
    {
      case INST_CPUID:
        a._emitInstruction(_code);
        return;

      case INST_CBW:
      case INST_CDQE:
      case INST_CWDE:
        a._emitInstruction(_code);
        return;

      case INST_CMPXCHG:
        a._emitInstruction(_code, &_operands[1], &_operands[2]);
        return;

      case INST_CMPXCHG8B:
#if defined(ASMJIT_X64)
      case INST_CMPXCHG16B:
#endif // ASMJIT_X64
        a._emitInstruction(_code, &_operands[4]);
        return;

#if defined(ASMJIT_X86)
      case INST_DAA:
      case INST_DAS:
        a._emitInstruction(_code);
        return;
#endif // ASMJIT_X86

      case INST_IMUL:
      case INST_MUL:
      case INST_IDIV:
      case INST_DIV:
        // INST dst_lo (implicit), dst_hi (implicit), src (explicit)
        ASMJIT_ASSERT(_operandsCount == 3);
        a._emitInstruction(_code, &_operands[2]);
        return;

      case INST_MOV_PTR:
        break;

      case INST_LAHF:
      case INST_SAHF:
        a._emitInstruction(_code);
        return;

      case INST_MASKMOVQ:
      case INST_MASKMOVDQU:
        a._emitInstruction(_code, &_operands[1], &_operands[2]);
        return;

      case INST_ENTER:
      case INST_LEAVE:
        // TODO: SPECIAL INSTRUCTION.
        break;

      case INST_RET:
        // TODO: SPECIAL INSTRUCTION.
        break;

      case INST_MONITOR:
      case INST_MWAIT:
        // TODO: MONITOR/MWAIT (COMPILER).
        break;

      case INST_POP:
      case INST_POPAD:
      case INST_POPFD:
      case INST_POPFQ:
        // TODO: SPECIAL INSTRUCTION.
        break;

      case INST_PUSH:
      case INST_PUSHAD:
      case INST_PUSHFD:
      case INST_PUSHFQ:
        // TODO: SPECIAL INSTRUCTION.
        break;

      case INST_RCL:
      case INST_RCR:
      case INST_ROL:
      case INST_ROR:
      case INST_SAL:
      case INST_SAR:
      case INST_SHL:
      case INST_SHR:
        a._emitInstruction(_code, &_operands[0], &cl);
        return;

      case INST_SHLD:
      case INST_SHRD:
        a._emitInstruction(_code, &_operands[0], &_operands[1], &cl);
        return;

      case INST_RDTSC:
      case INST_RDTSCP:
        a._emitInstruction(_code);
        return;

      case INST_REP_LODSB:
      case INST_REP_LODSD:
      case INST_REP_LODSQ:
      case INST_REP_LODSW:
      case INST_REP_MOVSB:
      case INST_REP_MOVSD:
      case INST_REP_MOVSQ:
      case INST_REP_MOVSW:
      case INST_REP_STOSB:
      case INST_REP_STOSD:
      case INST_REP_STOSQ:
      case INST_REP_STOSW:
      case INST_REPE_CMPSB:
      case INST_REPE_CMPSD:
      case INST_REPE_CMPSQ:
      case INST_REPE_CMPSW:
      case INST_REPE_SCASB:
      case INST_REPE_SCASD:
      case INST_REPE_SCASQ:
      case INST_REPE_SCASW:
      case INST_REPNE_CMPSB:
      case INST_REPNE_CMPSD:
      case INST_REPNE_CMPSQ:
      case INST_REPNE_CMPSW:
      case INST_REPNE_SCASB:
      case INST_REPNE_SCASD:
      case INST_REPNE_SCASQ:
      case INST_REPNE_SCASW:
        a._emitInstruction(_code);
        return;

      default:
        ASMJIT_ASSERT(0);
    }
    // ${SPECIAL_INSTRUCTION_HANDLING_END}
  }

  switch (_operandsCount)
  {
    case 0:
      a._emitInstruction(_code);
      break;
    case 1:
      a._emitInstruction(_code, &_operands[0]);
      break;
    case 2:
      a._emitInstruction(_code, &_operands[0], &_operands[1]);
      break;
    case 3:
      a._emitInstruction(_code, &_operands[0], &_operands[1], &_operands[2]);
      break;
    default:
      ASMJIT_ASSERT(0);
      break;
  }
}

int EInstruction::getMaxSize() const ASMJIT_NOTHROW
{
  // TODO: Do something more exact.
  return 15;
}

bool EInstruction::_tryUnuseVar(VarData* v) ASMJIT_NOTHROW
{
  for (uint32_t i = 0; i < _variablesCount; i++)
  {
    if (_variables[i].vdata == v)
    {
      _variables[i].vflags |= VARIABLE_ALLOC_UNUSE_AFTER_USE;
      return true;
    }
  }

  return false;
}

ETarget* EInstruction::getJumpTarget() const ASMJIT_NOTHROW
{
  return NULL;
}

// ============================================================================
// [AsmJit::EJmp]
// ============================================================================

EJmp::EJmp(Compiler* c, uint32_t code, Operand* operandsData, uint32_t operandsCount) ASMJIT_NOTHROW :
  EInstruction(c, code, operandsData, operandsCount)
{
  _jumpTarget = _compiler->_getTarget(_operands[0].getId());
  _jumpTarget->_jumpsCount++;

  _jumpNext = _jumpTarget->_from;
  _jumpTarget->_from = this;

  // The 'jmp' is always taken, conditional jump can contain hint, we detect it.
  _isTaken = (getCode() == INST_JMP) || 
             (operandsCount > 1 &&
              operandsData[1].isImm() &&
              reinterpret_cast<Imm*>(&operandsData[1])->getValue() == HINT_TAKEN);
}

EJmp::~EJmp() ASMJIT_NOTHROW
{
}

void EJmp::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset;

  // Update _isTaken to true if this is conditional backward jump. This behavior
  // can be overridden by using HINT_NOT_TAKEN when using the instruction.
  if (getCode() != INST_JMP &&
      _operandsCount == 1 &&
      _jumpTarget->getOffset() < getOffset())
  {
    _isTaken = true;
  }

  // Now patch all variables where jump location is in the active range.
  if (_jumpTarget->getOffset() != INVALID_VALUE && cc._active)
  {
    VarData* first = cc._active;
    VarData* var = first;
    uint32_t jumpOffset = _jumpTarget->getOffset();

    do {
      if (var->firstEmittable)
      {
        ASMJIT_ASSERT(var->lastEmittable != NULL);
        uint32_t start = var->firstEmittable->getOffset();
        uint32_t end = var->lastEmittable->getOffset();

        if (jumpOffset >= start && jumpOffset <= end) var->lastEmittable = this;
      }
      var = var->nextActive;
    } while (var != first);
  }

  cc._currentOffset++;
}

Emittable* EJmp::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  // Translate using EInstruction.
  Emittable* ret = EInstruction::translate(cc);

  // We jump with emittable if its INST_JUMP (not based on condiiton) and it
  // points into yet unknown location.
  if (_code == INST_JMP && !_jumpTarget->isTranslated())
  {
    cc.addBackwardCode(this);
    ret = _jumpTarget;
  }
  else
  {
    _state = cc._saveState();
    if (_jumpTarget->isTranslated())
    {
      _doJump(cc);
    }
    else
    {
      // State is not known, so we need to call _doJump() later. Compiler will
      // do it for us.
      cc.addForwardJump(this);
      _jumpTarget->_state = _state;
    }

    // Mark next code as unreachable, cleared by a next label (ETarget).
    if (_code == INST_JMP) cc._unreachable = 1;
  }

  // Need to traverse over all active variables and unuse them if their scope ends
  // here. 
  if (cc._active)
  {
    VarData* first = cc._active;
    VarData* var = first;

    do {
      cc._unuseVarOnEndOfScope(this, var);
      var = var->nextActive;
    } while (var != first);
  }

  return ret;
}

void EJmp::emit(Assembler& a) ASMJIT_NOTHROW
{
  static const uint MAXIMUM_SHORT_JMP_SIZE = 127;

  // Try to minimize size of jump using SHORT jump (8-bit displacement) by 
  // traversing into the target and calculating the maximum code size. We
  // end when code size reaches MAXIMUM_SHORT_JMP_SIZE.
  if (!(_emitOptions & EMIT_OPTION_SHORT_JUMP) && getJumpTarget()->getOffset() > getOffset())
  {
    // Calculate the code size.
    uint codeSize = 0;
    Emittable* cur = this->getNext();
    Emittable* target = getJumpTarget();

    while (cur)
    {
      if (cur == target)
      {
        // Target found, we can tell assembler to generate short form of jump.
        _emitOptions |= EMIT_OPTION_SHORT_JUMP;
        goto end;
      }

      int s = cur->getMaxSize();
      if (s == -1) break;

      codeSize += (uint)s;
      if (codeSize > MAXIMUM_SHORT_JMP_SIZE) break;

      cur = cur->getNext();
    }
  }

end:
  EInstruction::emit(a);
}

void EJmp::_doJump(CompilerContext& cc) ASMJIT_NOTHROW
{
  // The state have to be already known. The _doJump() method is called by
  // translate() or by Compiler in case that it's forward jump.
  ASMJIT_ASSERT(_jumpTarget->getState());

  if (getCode() == INST_JMP || (isTaken() && _jumpTarget->getOffset() < getOffset()))
  {
    // Instruction type is JMP or conditional jump that should be taken (likely).
    // We can set state here instead of jumping out, setting state and jumping
    // to _jumpTarget.
    //
    // NOTE: We can't use this technique if instruction is forward conditional
    // jump. The reason is that when generating code we can't change state here,
    // because the next instruction depends on it.
    cc._restoreState(_jumpTarget->getState(), _jumpTarget->getOffset());
  }
  else
  {
    // Instruction type is JMP or conditional jump that should be not normally
    // taken. If we need add code that will switch between different states we
    // add it after the end of function body (after epilog, using 'ExtraBlock').
    Compiler* compiler = cc.getCompiler();

    Emittable* ext = cc.getExtraBlock();
    Emittable* old = compiler->setCurrentEmittable(ext);

    cc._restoreState(_jumpTarget->getState(), _jumpTarget->getOffset());

    if (compiler->getCurrentEmittable() != ext)
    {
      // Add the jump to the target.
      compiler->jmp(_jumpTarget->_label);
      ext = compiler->getCurrentEmittable();

      // The cc._restoreState() method emitted some instructions so we need to
      // patch the jump.
      Label L = compiler->newLabel();
      compiler->setCurrentEmittable(cc.getExtraBlock());
      compiler->bind(L);

      // Finally, patch the jump target.
      ASMJIT_ASSERT(_operandsCount > 0);
      _operands[0] = L;                              // Operand part (Label).
      _jumpTarget = compiler->_getTarget(L.getId()); // Emittable part (ETarget).
    }

    cc.setExtraBlock(ext);
    compiler->setCurrentEmittable(old);

    // Assign state back.
    cc._assignState(_state);
  }
}

ETarget* EJmp::getJumpTarget() const ASMJIT_NOTHROW
{
  return _jumpTarget;
}

// ============================================================================
// [AsmJit::EFunction]
// ============================================================================

EFunction::EFunction(Compiler* c) ASMJIT_NOTHROW : Emittable(c, EMITTABLE_FUNCTION)
{
  _argumentVariables = NULL;
  Util::memset32(_hints, INVALID_VALUE, ASMJIT_ARRAY_SIZE(_hints));

  // Stack is always aligned to 16-bytes when using 64-bit OS.
  _isStackAlignedByOsTo16Bytes = CompilerUtil::isStack16ByteAligned();

  // Manual aligning is autodetected by prepare() method.
  _isStackAlignedByFnTo16Bytes = false;

  // Just clear to safe defaults.
  _isNaked = false;
  _isEspAdjusted = false;
  _isCaller = false;

  _pePushPop = true;
  _emitEMMS = false;
  _emitSFence = false;
  _emitLFence = false;

  _finished = false;

  _modifiedAndPreservedGP = 0;
  _modifiedAndPreservedMM = 0;
  _modifiedAndPreservedXMM = 0;

  _pePushPopStackSize = 0;
  _peMovStackSize = 0;
  _peAdjustStackSize = 0;

  _memStackSize = 0;
  _memStackSize16 = 0;

  _functionCallStackSize = 0;

  _entryLabel = c->newLabel();
  _exitLabel = c->newLabel();

  _prolog = Compiler_newObject<EProlog>(c, this);
  _epilog = Compiler_newObject<EEpilog>(c, this);
  _end = Compiler_newObject<EFunctionEnd>(c);
}

EFunction::~EFunction() ASMJIT_NOTHROW
{
}

void EFunction::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset++;
}

int EFunction::getMaxSize() const ASMJIT_NOTHROW
{
  // EFunction is NOP.
  return 0;
}

void EFunction::setPrototype(
  uint32_t callingConvention,
  const uint32_t* arguments,
  uint32_t argumentsCount,
  uint32_t returnValue) ASMJIT_NOTHROW
{
  _functionPrototype.setPrototype(callingConvention, arguments, argumentsCount, returnValue);
}

void EFunction::setHint(uint32_t hint, uint32_t value) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(hint < ASMJIT_ARRAY_SIZE(_hints));
  _hints[hint] = value;
}

void EFunction::_createVariables() ASMJIT_NOTHROW
{
  uint32_t i, count = _functionPrototype.getArgumentsCount();
  if (count == 0) return;

  _argumentVariables = reinterpret_cast<VarData**>(_compiler->getZone().zalloc(count * sizeof(VarData*)));
  if (_argumentVariables == NULL)
  {
    _compiler->setError(ERROR_NO_HEAP_MEMORY);
    return;
  }

  char argNameStorage[64];
  char* argName = NULL;

  bool debug = _compiler->getLogger() != NULL;
  if (debug) argName = argNameStorage;

  for (i = 0; i < count; i++)
  {
    FunctionPrototype::Argument& a = _functionPrototype.getArguments()[i];
    if (debug) snprintf(argName, ASMJIT_ARRAY_SIZE(argNameStorage), "arg_%u", i);

    uint32_t size = getVariableSize(a.variableType);
    VarData* vdata = _compiler->_newVarData(argName, a.variableType, size);

    if (a.registerIndex != (uint32_t)INVALID_VALUE)
    {
      vdata->isRegArgument = true;
      vdata->registerIndex = a.registerIndex;
    }

    if (a.stackOffset != (int32_t)INVALID_VALUE)
    {
      vdata->isMemArgument = true;
      vdata->homeMemoryOffset = a.stackOffset;
    }

    _argumentVariables[i] = vdata;
  }
}

void EFunction::_prepareVariables(Emittable* first) ASMJIT_NOTHROW
{
  uint32_t i, count = _functionPrototype.getArgumentsCount();
  if (count == 0) return;

  for (i = 0; i < count; i++)
  {
    VarData* vdata = _argumentVariables[i];

    // This is where variable scope starts.
    vdata->firstEmittable = first;
    // If this will not be changed then it will be deallocated immediately.
    vdata->lastEmittable = first;
  }
}

void EFunction::_allocVariables(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i, count = _functionPrototype.getArgumentsCount();
  if (count == 0) return;

  for (i = 0; i < count; i++)
  {
    VarData* vdata = _argumentVariables[i];

    if (vdata->firstEmittable != NULL ||
        vdata->isRegArgument ||
        vdata->isMemArgument)
    {
      // Variable is used.
      if (vdata->registerIndex != INVALID_VALUE)
      {
        vdata->state = VARIABLE_STATE_REGISTER;
        // If variable is in register -> mark it as changed so it will not be
        // lost by first spill.
        vdata->changed = true;
        cc._allocatedVariable(vdata);
      }
      else if (vdata->isMemArgument)
      {
        vdata->state = VARIABLE_STATE_MEMORY;
      }
    }
    else
    {
      // Variable is not used.
      vdata->registerIndex = INVALID_VALUE;
    }
  }
}

void EFunction::_preparePrologEpilog(CompilerContext& cc) ASMJIT_NOTHROW
{
  const CpuInfo* cpuInfo = getCpuInfo();

  _pePushPop = true;
  _emitEMMS = false;
  _emitSFence = false;
  _emitLFence = false;

  uint32_t accessibleMemoryBelowStack = 0;
  if (_functionPrototype.getCallingConvention() == CALL_CONV_X64U) 
    accessibleMemoryBelowStack = 128;

  if (_isCaller && (cc._memBytesTotal > 0 || _isStackAlignedByOsTo16Bytes))
    _isEspAdjusted = true;

  if (cc._memBytesTotal > accessibleMemoryBelowStack)
    _isEspAdjusted = true;

  if (_hints[FUNCTION_HINT_NAKED] != INVALID_VALUE)
    _isNaked = (bool)_hints[FUNCTION_HINT_NAKED];

  if (_hints[FUNCTION_HINT_PUSH_POP_SEQUENCE] != INVALID_VALUE)
    _pePushPop = (bool)_hints[FUNCTION_HINT_PUSH_POP_SEQUENCE];

  if (_hints[FUNCTION_HINT_EMMS] != INVALID_VALUE)
    _emitEMMS = (bool)_hints[FUNCTION_HINT_EMMS];

  if (_hints[FUNCTION_HINT_SFENCE] != INVALID_VALUE)
    _emitSFence = (bool)_hints[FUNCTION_HINT_SFENCE];

  if (_hints[FUNCTION_HINT_LFENCE] != INVALID_VALUE)
    _emitLFence = (bool)_hints[FUNCTION_HINT_LFENCE];

  // Updated to respect comment from issue #47, align also when using MMX code.
  if (!_isStackAlignedByOsTo16Bytes && !_isNaked && (cc._mem16BlocksCount + (cc._mem8BlocksCount > 0)))
  {
    // Have to align stack to 16-bytes.
    _isStackAlignedByFnTo16Bytes = true;
    _isEspAdjusted = true;
  }

  _modifiedAndPreservedGP  = cc._modifiedGPRegisters  & _functionPrototype.getPreservedGP() & ~Util::maskFromIndex(REG_INDEX_ESP);
  _modifiedAndPreservedMM  = cc._modifiedMMRegisters  & _functionPrototype.getPreservedMM();
  _modifiedAndPreservedXMM = cc._modifiedXMMRegisters & _functionPrototype.getPreservedXMM();

  _movDqaInstruction = (_isStackAlignedByOsTo16Bytes || !_isNaked) ? INST_MOVDQA : INST_MOVDQU;

  // Prolog & Epilog stack size.
  {
    int32_t memGP = Util::bitCount(_modifiedAndPreservedGP) * sizeof(sysint_t);
    int32_t memMM = Util::bitCount(_modifiedAndPreservedMM) * 8;
    int32_t memXMM = Util::bitCount(_modifiedAndPreservedXMM) * 16;

    if (_pePushPop)
    {
      _pePushPopStackSize = memGP;
      _peMovStackSize = memXMM + Util::alignTo16(memMM);
    }
    else
    {
      _pePushPopStackSize = 0;
      _peMovStackSize = memXMM + Util::alignTo16(memMM + memGP);
    }
  }

  if (_isStackAlignedByFnTo16Bytes)
  {
    _peAdjustStackSize += Util::deltaTo16(_pePushPopStackSize);
  }
  else
  {
    int32_t v = 16 - sizeof(sysint_t);
    if (!_isNaked) v -= sizeof(sysint_t);

    v -= _pePushPopStackSize & 15;
    if (v < 0) v += 16;
    _peAdjustStackSize = v;

    //_peAdjustStackSize += Util::deltaTo16(_pePushPopStackSize + v);
  }

  // Memory stack size.
  _memStackSize = cc._memBytesTotal;
  _memStackSize16 = Util::alignTo16(_memStackSize);

  if (_isNaked)
  {
    cc._argumentsBaseReg = REG_INDEX_ESP;
    cc._argumentsBaseOffset = (_isEspAdjusted)
      ? (_functionCallStackSize + _memStackSize16 + _peMovStackSize + _pePushPopStackSize + _peAdjustStackSize)
      : (_pePushPopStackSize);
  }
  else
  {
    cc._argumentsBaseReg = REG_INDEX_EBP;
    cc._argumentsBaseOffset = sizeof(sysint_t);
  }

  cc._variablesBaseReg = REG_INDEX_ESP;
  cc._variablesBaseOffset = _functionCallStackSize;
  if (!_isEspAdjusted)
    cc._variablesBaseOffset = -_memStackSize16 - _peMovStackSize - _peAdjustStackSize;
}

void EFunction::_dumpFunction(CompilerContext& cc) ASMJIT_NOTHROW
{
  Logger* logger = _compiler->getLogger();
  ASMJIT_ASSERT(logger != NULL);

  uint32_t i;
  char _buf[1024];
  char* p;

  // Log function prototype.
  {
    uint32_t argumentsCount = _functionPrototype.getArgumentsCount();
    bool first = true;

    logger->logString("; Function Prototype:\n");
    logger->logString(";\n");

    for (i = 0; i < argumentsCount; i++)
    {
      const FunctionPrototype::Argument& a = _functionPrototype.getArguments()[i];
      VarData* vdata = _argumentVariables[i];

      if (first)
      {
        logger->logString("; IDX| Type     | Sz | Home           |\n");
        logger->logString("; ---+----------+----+----------------+\n");
      }

      char* memHome = memHome = _buf;

      if (a.registerIndex != INVALID_VALUE)
      {
        BaseReg regOp(a.registerIndex | REG_TYPE_GPN, 0);
        dumpOperand(memHome, &regOp, REG_TYPE_GPN)[0] = '\0';
      }
      else
      {
        Mem memOp;
        memOp._mem.base = REG_INDEX_ESP;
        memOp._mem.displacement = a.stackOffset;
        dumpOperand(memHome, &memOp, REG_TYPE_GPN)[0] = '\0';
      }

      logger->logFormat("; %-3u| %-9s| %-3u| %-15s|\n",
        // Argument index.
        i,
        // Argument type.
        vdata->type < _VARIABLE_TYPE_COUNT ? variableInfo[vdata->type].name : "invalid",
        // Argument size.
        vdata->size,
        // Argument memory home.
        memHome
      );

      first = false;
    }
    logger->logString(";\n");
  }

  // Log variables.
  {
    uint32_t variablesCount = (uint32_t)_compiler->_varData.getLength();
    bool first = true;

    logger->logString("; Variables:\n");
    logger->logString(";\n");

    for (i = 0; i < variablesCount; i++)
    {
      VarData* vdata = _compiler->_varData[i];

      // If this variable is not related to this function then skip it.
      if (vdata->scope != this) continue;

      // Get some information about variable type.
      const VariableInfo& vinfo = variableInfo[vdata->type];

      if (first)
      {
        logger->logString("; ID | Type     | Sz | Home           | Register Access   | Memory Access     |\n");
        logger->logString("; ---+----------+----+----------------+-------------------+-------------------+\n");
      }

      char* memHome = (char*)"[None]";
      if (vdata->homeMemoryData != NULL)
      {
        VarMemBlock* memBlock = reinterpret_cast<VarMemBlock*>(vdata->homeMemoryData);
        memHome = _buf;

        Mem memOp;
        if (vdata->isMemArgument)
        {
          const FunctionPrototype::Argument& a = _functionPrototype.getArguments()[i];

          memOp._mem.base = cc._argumentsBaseReg;
          memOp._mem.displacement += cc._argumentsBaseOffset;
          memOp._mem.displacement += a.stackOffset;
        }
        else
        {
          memOp._mem.base = cc._variablesBaseReg;
          memOp._mem.displacement += cc._variablesBaseOffset;
          memOp._mem.displacement += memBlock->offset;
        }
        dumpOperand(memHome, &memOp, REG_TYPE_GPN)[0] = '\0';
      }

      logger->logFormat("; %-3u| %-9s| %-3u| %-15s| r=%-4uw=%-4ux=%-4u| r=%-4uw=%-4ux=%-4u|\n",
        // Variable id.
        (uint)(i & OPERAND_ID_VALUE_MASK),
        // Variable type.
        vdata->type < _VARIABLE_TYPE_COUNT ? vinfo.name : "invalid",
        // Variable size.
        vdata->size,
        // Variable memory home.
        memHome,
        // Register access count.
        (unsigned int)vdata->registerReadCount,
        (unsigned int)vdata->registerWriteCount,
        (unsigned int)vdata->registerRWCount,
        // Memory access count.
        (unsigned int)vdata->memoryReadCount,
        (unsigned int)vdata->memoryWriteCount,
        (unsigned int)vdata->memoryRWCount
      );
      first = false;
    }
    logger->logString(";\n");
  }

  // Log modified registers.
  {
    p = _buf;

    uint32_t r;
    uint32_t modifiedRegisters = 0;

    for (r = 0; r < 3; r++)
    {
      bool first = true;
      uint32_t regs;
      uint32_t type;

      switch (r)
      {
        case 0:
          regs = cc._modifiedGPRegisters;
          type = REG_TYPE_GPN;
          p = Util::mycpy(p, "; GP : ");
          break;
        case 1:
          regs = cc._modifiedMMRegisters;
          type = REG_TYPE_MM;
          p = Util::mycpy(p, "; MM : ");
          break;
        case 2:
          regs = cc._modifiedXMMRegisters;
          type = REG_TYPE_XMM;
          p = Util::mycpy(p, "; XMM: ");
          break;
        default:
          ASMJIT_ASSERT(0);
      }

      for (i = 0; i < REG_NUM_BASE; i++)
      {
        if ((regs & Util::maskFromIndex(i)) != 0)
        {
          if (!first) { *p++ = ','; *p++ = ' '; }
          p = dumpRegister(p, type, i);
          first = false;
          modifiedRegisters++;
        }
      }
      *p++ = '\n';
    }
    *p = '\0';

    logger->logFormat("; Modified registers (%u):\n", (unsigned int)modifiedRegisters);
    logger->logString(_buf);
  }

  logger->logString("\n");
}

void EFunction::_emitProlog(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i, mask;
  uint32_t preservedGP  = _modifiedAndPreservedGP;
  uint32_t preservedMM  = _modifiedAndPreservedMM;
  uint32_t preservedXMM = _modifiedAndPreservedXMM;

  int32_t stackSubtract =
    _functionCallStackSize +
    _memStackSize16 + 
    _peMovStackSize + 
    _peAdjustStackSize;
  int32_t nspPos;

  if (_compiler->getLogger())
  {
    // Here function prolog starts.
    _compiler->comment("Prolog");
  }

  // Emit standard prolog entry code (but don't do it if function is set to be
  // naked).
  //
  // Also see the _prologEpilogStackAdjust variable. If function is naked (so
  // prolog and epilog will not contain "push ebp" and "mov ebp, esp", we need
  // to adjust stack by 8 bytes in 64-bit mode (this will give us that stack
  // will remain aligned to 16 bytes).
  if (!_isNaked)
  {
    _compiler->emit(INST_PUSH, nbp);
    _compiler->emit(INST_MOV, nbp, nsp);
  }

  // Align manually stack-pointer to 16-bytes.
  if (_isStackAlignedByFnTo16Bytes)
  {
    ASMJIT_ASSERT(!_isNaked);
    _compiler->emit(INST_AND, nsp, imm(-16));
  }

  // Save GP registers using PUSH/POP.
  if (preservedGP && _pePushPop)
  {
    for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
    {
      if (preservedGP & mask) _compiler->emit(INST_PUSH, gpn(i));
    }
  }

  if (_isEspAdjusted)
  {
    nspPos = _memStackSize16;
    if (stackSubtract) _compiler->emit(INST_SUB, nsp, imm(stackSubtract));
  }
  else
  {
    nspPos = -(_peMovStackSize + _peAdjustStackSize);
    //if (_pePushPop) nspPos += Util::bitCount(preservedGP) * sizeof(sysint_t);
  }

  // Save XMM registers using MOVDQA/MOVDQU.
  if (preservedXMM)
  {
    for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
    {
      if (preservedXMM & mask)
      {
        _compiler->emit(_movDqaInstruction, dqword_ptr(nsp, nspPos), xmm(i));
        nspPos += 16;
      }
    }
  }

  // Save MM registers using MOVQ.
  if (preservedMM)
  {
    for (i = 0, mask = 1; i < 8; i++, mask <<= 1)
    {
      if (preservedMM & mask)
      {
        _compiler->emit(INST_MOVQ, qword_ptr(nsp, nspPos), mm(i));
        nspPos += 8;
      }
    }
  }

  // Save GP registers using MOV.
  if (preservedGP && !_pePushPop)
  {
    for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
    {
      if (preservedGP & mask)
      {
        _compiler->emit(INST_MOV, sysint_ptr(nsp, nspPos), gpn(i));
        nspPos += sizeof(sysint_t);
      }
    }
  }

  if (_compiler->getLogger())
  {
    _compiler->comment("Body");
  }
}

void EFunction::_emitEpilog(CompilerContext& cc) ASMJIT_NOTHROW
{
  const CpuInfo* cpuInfo = getCpuInfo();

  uint32_t i, mask;
  uint32_t preservedGP  = _modifiedAndPreservedGP;
  uint32_t preservedMM  = _modifiedAndPreservedMM;
  uint32_t preservedXMM = _modifiedAndPreservedXMM;

  int32_t stackAdd =
    _functionCallStackSize +
    _memStackSize16 +
    _peMovStackSize +
    _peAdjustStackSize;
  int32_t nspPos;

  nspPos = (_isEspAdjusted)
    ? (_memStackSize16)
    : -(_peMovStackSize + _peAdjustStackSize);

  if (_compiler->getLogger())
  {
    _compiler->comment("Epilog");
  }

  // Restore XMM registers using MOVDQA/MOVDQU.
  if (preservedXMM)
  {
    for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
    {
      if (preservedXMM & mask)
      {
        _compiler->emit(_movDqaInstruction, xmm(i), dqword_ptr(nsp, nspPos));
        nspPos += 16;
      }
    }
  }

  // Restore MM registers using MOVQ.
  if (preservedMM)
  {
    for (i = 0, mask = 1; i < 8; i++, mask <<= 1)
    {
      if (preservedMM & mask)
      {
        _compiler->emit(INST_MOVQ, mm(i), qword_ptr(nsp, nspPos));
        nspPos += 8;
      }
    }
  }

  // Restore GP registers using MOV.
  if (preservedGP && !_pePushPop)
  {
    for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
    {
      if (preservedGP & mask)
      {
        _compiler->emit(INST_MOV, gpn(i), sysint_ptr(nsp, nspPos));
        nspPos += sizeof(sysint_t);
      }
    }
  }

  if (_isEspAdjusted && stackAdd != 0)
    _compiler->emit(INST_ADD, nsp, imm(stackAdd));

  // Restore GP registers using POP.
  if (preservedGP && _pePushPop)
  {
    for (i = REG_NUM_GP - 1, mask = 1 << i; (int32_t)i >= 0; i--, mask >>= 1)
    {
      if (preservedGP & mask)
      {
        _compiler->emit(INST_POP, gpn(i));
      }
    }
  }

  // Emit Emms.
  if (_emitEMMS) _compiler->emit(INST_EMMS);

  // Emit SFence / LFence / MFence.
  if ( _emitSFence &&  _emitLFence) _compiler->emit(INST_MFENCE); // MFence == SFence & LFence.
  if ( _emitSFence && !_emitLFence) _compiler->emit(INST_SFENCE); // Only SFence.
  if (!_emitSFence &&  _emitLFence) _compiler->emit(INST_LFENCE); // Only LFence.

  // Emit standard epilog leave code (if needed).
  if (!_isNaked)
  {
    if (cpuInfo->vendorId == CPU_VENDOR_AMD)
    {
      // AMD seems to prefer LEAVE instead of MOV/POP sequence.
      _compiler->emit(INST_LEAVE);
    }
    else
    {
      _compiler->emit(INST_MOV, nsp, nbp);
      _compiler->emit(INST_POP, nbp);
    }
  }

  // Emit return using correct instruction.
  if (_functionPrototype.getCalleePopsStack())
    _compiler->emit(INST_RET, imm((int16_t)_functionPrototype.getArgumentsStackSize()));
  else
    _compiler->emit(INST_RET);
}

void EFunction::reserveStackForFunctionCall(int32_t size)
{
  size = Util::alignTo16(size);

  if (size > _functionCallStackSize) _functionCallStackSize = size;
  _isCaller = true;
}

// ============================================================================
// [AsmJit::EProlog]
// ============================================================================

EProlog::EProlog(Compiler* c, EFunction* f) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_PROLOG),
  _function(f)
{
}

EProlog::~EProlog() ASMJIT_NOTHROW
{
}

void EProlog::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset++;
  _function->_prepareVariables(this);
}

Emittable* EProlog::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  _function->_allocVariables(cc);
  return translated();
}

// ============================================================================
// [AsmJit::EEpilog]
// ============================================================================

EEpilog::EEpilog(Compiler* c, EFunction* f) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_EPILOG),
  _function(f)
{
}

EEpilog::~EEpilog() ASMJIT_NOTHROW
{
}

void EEpilog::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset++;
}

Emittable* EEpilog::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  return translated();
}

// ============================================================================
// [AsmJit::ECall]
// ============================================================================

ECall::ECall(Compiler* c, EFunction* caller, const Operand* target) ASMJIT_NOTHROW : 
  Emittable(c, EMITTABLE_CALL),
  _caller(caller),
  _target(*target),
  _args(NULL),
  _gpParams(0),
  _mmParams(0),
  _xmmParams(0),
  _variablesCount(0),
  _variables(NULL)
{
}

ECall::~ECall() ASMJIT_NOTHROW
{
  memset(_argumentToVarRecord, 0, sizeof(VarCallRecord*) * FUNC_MAX_ARGS);
}

void ECall::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  // Prepare is similar to EInstruction::prepare(). We collect unique variables
  // and update statistics, but we don't use standard alloc/free register calls.
  //
  // The calling function is also unique in variable allocator point of view,
  // because we need to alloc some variables that may be destroyed be the 
  // callee (okay, may not, but this is not guaranteed).
  _offset = cc._currentOffset;

  // Tell EFunction that another function will be called inside. It needs this
  // information to reserve stack for the call and to mark esp adjustable.
  getCaller()->reserveStackForFunctionCall(
    (int32_t)getPrototype().getArgumentsStackSize());

  uint32_t i;
  uint32_t argumentsCount = getPrototype().getArgumentsCount();
  uint32_t operandsCount = argumentsCount;
  uint32_t variablesCount = 0;

  // Create registers used as arguments mask.
  for (i = 0; i < argumentsCount; i++)
  {
    const FunctionPrototype::Argument& fArg = getPrototype().getArguments()[i];

    if (fArg.registerIndex != INVALID_VALUE)
    {
      switch (fArg.variableType)
      {
        case VARIABLE_TYPE_GPD:
        case VARIABLE_TYPE_GPQ:
          _gpParams |= Util::maskFromIndex(fArg.registerIndex);
          break;
        case VARIABLE_TYPE_MM:
          _mmParams |= Util::maskFromIndex(fArg.registerIndex);
          break;
        case VARIABLE_TYPE_XMM:
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          _xmmParams |= Util::maskFromIndex(fArg.registerIndex);
          break;
        default:
          ASMJIT_ASSERT(0);
      }
    }
    else
    {
      cc.getFunction()->mustAdjustEsp();
    }
  }

  // Call address.
  operandsCount++;

  // The first and the second return value.
  if (!_ret[0].isNone()) operandsCount++;
  if (!_ret[1].isNone()) operandsCount++;

#define __GET_VARIABLE(__vardata__) \
  { \
    VarData* _candidate = __vardata__; \
    \
    for (var = cur; ;) \
    { \
      if (var == _variables) \
      { \
        var = cur++; \
        var->vdata = _candidate; \
        break; \
      } \
      \
      var--; \
      \
      if (var->vdata == _candidate) \
      { \
        break; \
      } \
    } \
    \
    ASMJIT_ASSERT(var != NULL); \
  }

  for (i = 0; i < operandsCount; i++)
  {
    Operand& o = (i < argumentsCount) 
      ? (_args[i])
      : (i == argumentsCount ? _target : _ret[i - argumentsCount - 1]);

    if (o.isVar())
    {
      ASMJIT_ASSERT(o.getId() != INVALID_VALUE);
      VarData* vdata = _compiler->_getVarData(o.getId());
      ASMJIT_ASSERT(vdata != NULL);

      if (vdata->workOffset == _offset) continue;
      if (!cc._isActive(vdata)) cc._addActive(vdata);

      vdata->workOffset = _offset;
      variablesCount++;
    }
    else if (o.isMem())
    {
      if ((o.getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        cc._markMemoryUsed(vdata);
        if (!cc._isActive(vdata)) cc._addActive(vdata);

        continue;
      }
      else if ((o._mem.base & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.base);
        ASMJIT_ASSERT(vdata != NULL);

        if (vdata->workOffset == _offset) continue;
        if (!cc._isActive(vdata)) cc._addActive(vdata);

        vdata->workOffset = _offset;
        variablesCount++;
      }

      if ((o._mem.index & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.index);
        ASMJIT_ASSERT(vdata != NULL);

        if (vdata->workOffset == _offset) continue;
        if (!cc._isActive(vdata)) cc._addActive(vdata);

        vdata->workOffset = _offset;
        variablesCount++;
      }
    }
  }

  // Traverse all active variables and set their firstCallable pointer to this
  // call. This information can be used to choose between the preserved-first
  // and preserved-last register allocation.
  if (cc._active)
  {
    VarData* first = cc._active;
    VarData* active = first;
    do {
      if (active->firstCallable == NULL) active->firstCallable = this;
      active = active->nextActive;
    } while (active != first);
  }

  if (!variablesCount)
  {
    cc._currentOffset++;
    return;
  }

  _variables = reinterpret_cast<VarCallRecord*>(_compiler->getZone().zalloc(sizeof(VarCallRecord) * variablesCount));
  if (!_variables)
  {
    _compiler->setError(ERROR_NO_HEAP_MEMORY);
    cc._currentOffset++;
    return;
  }

  _variablesCount = variablesCount;
  memset(_variables, 0, sizeof(VarCallRecord) * variablesCount);

  VarCallRecord* cur = _variables;
  VarCallRecord* var = NULL;

  for (i = 0; i < operandsCount; i++)
  {
    Operand& o = (i < argumentsCount) 
      ? (_args[i])
      : (i == argumentsCount ? _target : _ret[i - argumentsCount - 1]);

    if (o.isVar())
    {
      VarData* vdata = _compiler->_getVarData(o.getId());
      ASMJIT_ASSERT(vdata != NULL);

      __GET_VARIABLE(vdata)
      _argumentToVarRecord[i] = var;

      if (i < argumentsCount)
      {
        const FunctionPrototype::Argument& fArg = getPrototype().getArguments()[i];

        if (fArg.registerIndex != INVALID_VALUE)
        {
          cc._newRegisterHomeIndex(vdata, fArg.registerIndex);

          switch (fArg.variableType)
          {
            case VARIABLE_TYPE_GPD:
            case VARIABLE_TYPE_GPQ:
              var->flags |= VarCallRecord::FLAG_IN_GP;
              var->inCount++;
              break;

            case VARIABLE_TYPE_MM:
              var->flags |= VarCallRecord::FLAG_IN_MM;
              var->inCount++;
              break;

            case VARIABLE_TYPE_XMM:
            case VARIABLE_TYPE_XMM_1F:
            case VARIABLE_TYPE_XMM_4F:
            case VARIABLE_TYPE_XMM_1D:
            case VARIABLE_TYPE_XMM_2D:
              var->flags |= VarCallRecord::FLAG_IN_XMM;
              var->inCount++;
              break;

            default:
              ASMJIT_ASSERT(0);
          }
        }
        else
        {
          var->inCount++;
        }

        vdata->registerReadCount++;
      }
      else if (i == argumentsCount)
      {
        uint32_t mask = ~getPrototype().getPreservedGP() &
                        ~getPrototype().getPassedGP()    & 
                        Util::maskUpToIndex(REG_NUM_GP);

        cc._newRegisterHomeIndex(vdata, Util::findFirstBit(mask));
        cc._newRegisterHomeMask(vdata, mask);

        var->flags |= VarCallRecord::FLAG_CALL_OPERAND_REG;
        vdata->registerReadCount++;
      }
      else
      {
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
          case VARIABLE_TYPE_GPQ:
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_EAX;
            else
              var->flags |= VarCallRecord::FLAG_OUT_EDX;
            break;

          case VARIABLE_TYPE_X87:
          case VARIABLE_TYPE_X87_1F:
          case VARIABLE_TYPE_X87_1D:
#if defined(ASMJIT_X86)
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_ST0;
            else
              var->flags |= VarCallRecord::FLAG_OUT_ST1;
#else
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_XMM0;
            else
              var->flags |= VarCallRecord::FLAG_OUT_XMM1;
#endif
            break;

          case VARIABLE_TYPE_MM:
            var->flags |= VarCallRecord::FLAG_OUT_MM0;
            break;

          case VARIABLE_TYPE_XMM:
          case VARIABLE_TYPE_XMM_4F:
          case VARIABLE_TYPE_XMM_2D:
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_XMM0;
            else
              var->flags |= VarCallRecord::FLAG_OUT_XMM1;
            break;

          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_1D:
#if defined(ASMJIT_X86)
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_ST0;
            else
              var->flags |= VarCallRecord::FLAG_OUT_ST1;
#else
            if (i == argumentsCount+1)
              var->flags |= VarCallRecord::FLAG_OUT_XMM0;
            else
              var->flags |= VarCallRecord::FLAG_OUT_XMM1;
#endif
            break;

          default:
            ASMJIT_ASSERT(0);
        }

        vdata->registerWriteCount++;
      }
    }
    else if (o.isMem())
    {
      ASMJIT_ASSERT(i == argumentsCount);

      if ((o.getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        vdata->memoryReadCount++;
      }
      else if ((o._mem.base & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(reinterpret_cast<Mem&>(o).getBase());
        ASMJIT_ASSERT(vdata != NULL);

        vdata->registerReadCount++;

        __GET_VARIABLE(vdata)
        var->flags |= VarCallRecord::FLAG_CALL_OPERAND_REG | VarCallRecord::FLAG_CALL_OPERAND_MEM;
      }

      if ((o._mem.index & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(reinterpret_cast<Mem&>(o).getIndex());
        ASMJIT_ASSERT(vdata != NULL);

        vdata->registerReadCount++;

        __GET_VARIABLE(vdata)
        var->flags |= VarCallRecord::FLAG_CALL_OPERAND_REG | VarCallRecord::FLAG_CALL_OPERAND_MEM;
      }
    }
  }

  // Traverse all variables and update firstEmittable / lastEmittable. This
  // function is called from iterator that scans emittables using forward
  // direction so we can use this knowledge to optimize the process.
  //
  // Same code is in EInstruction::prepare().
  for (i = 0; i < _variablesCount; i++)
  {
    VarData* v = _variables[i].vdata;

    // First emittable (begin of variable scope).
    if (v->firstEmittable == NULL) v->firstEmittable = this;

    // Last emittable (end of variable scope).
    v->lastEmittable = this;
  }

  cc._currentOffset++;

#undef __GET_VARIABLE
}

Emittable* ECall::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i;
  uint32_t preserved, mask;

  uint32_t temporaryGpReg;
  uint32_t temporaryXmmReg;

  uint32_t offset = cc._currentOffset;
  Compiler* compiler = cc.getCompiler();

  // Constants.
  const FunctionPrototype::Argument* targs = getPrototype().getArguments();

  uint32_t argumentsCount = getPrototype().getArgumentsCount();
  uint32_t variablesCount = _variablesCount;

  // Processed arguments.
  uint8_t processed[FUNC_MAX_ARGS] = { 0 };

  compiler->comment("Function Call");

  // These variables are used by the instruction and we set current offset
  // to their work offsets -> The getSpillCandidate() method never returns 
  // the variable used by this instruction.
  for (i = 0; i < variablesCount; i++)
  {
    _variables[i].vdata->workOffset = offset;

    // Init back-reference to VarCallRecord.
    _variables[i].vdata->tempPtr = &_variables[i];
  }

  // --------------------------------------------------------------------------
  // STEP 1:
  //
  // Spill variables which are not used by the function call and have to
  // be destroyed. These registers may be used by callee.
  // --------------------------------------------------------------------------

  preserved = getPrototype().getPreservedGP();
  for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.gp[i];
    if (vdata && vdata->workOffset != offset && (preserved & mask) == 0)
    {
      cc.spillGPVar(vdata);
    }
  }

  preserved = getPrototype().getPreservedMM();
  for (i = 0, mask = 1; i < REG_NUM_MM; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.mm[i];
    if (vdata && vdata->workOffset != offset && (preserved & mask) == 0)
    {
      cc.spillMMVar(vdata);
    }
  }

  preserved = getPrototype().getPreservedXMM();
  for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.xmm[i];
    if (vdata && vdata->workOffset != offset && (preserved & mask) == 0)
    {
      cc.spillXMMVar(vdata);
    }
  }

  // --------------------------------------------------------------------------
  // STEP 2:
  //
  // Move all arguments to the stack which all already in registers.
  // --------------------------------------------------------------------------

  for (i = 0; i < argumentsCount; i++)
  {
    if (processed[i]) continue;

    const FunctionPrototype::Argument& argType = targs[i];
    if (argType.registerIndex != INVALID_VALUE) continue;

    Operand& operand = _args[i];

    if (operand.isVar())
    {
      VarCallRecord* rec = _argumentToVarRecord[i];
      VarData* vdata = compiler->_getVarData(operand.getId());

      if (vdata->registerIndex != INVALID_VALUE)
      {
        _moveAllocatedVariableToStack(cc,
          vdata, argType);

        rec->inDone++;
        processed[i] = true;
      }
    }
  }

  // --------------------------------------------------------------------------
  // STEP 3:
  //
  // Spill all non-preserved variables we moved to stack in STEP #2.
  // --------------------------------------------------------------------------

  for (i = 0; i < argumentsCount; i++)
  {
    VarCallRecord* rec = _argumentToVarRecord[i];
    if (!rec || processed[i]) continue;

    if (rec->inDone >= rec->inCount)
    {
      VarData* vdata = rec->vdata;
      if (vdata->registerIndex == INVALID_VALUE) continue;

      if (rec->outCount)
      {
        // Variable will be rewritten by function return value, it's not needed
        // to spill it. It will be allocated again by ECall.
        cc.unuseVar(rec->vdata, VARIABLE_STATE_UNUSED);
      }
      else
      {
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
          case VARIABLE_TYPE_GPQ:
            if ((getPrototype().getPreservedGP() & Util::maskFromIndex(vdata->registerIndex)) == 0)
              cc.spillGPVar(vdata);
            break;
          case VARIABLE_TYPE_MM:
            if ((getPrototype().getPreservedMM() & Util::maskFromIndex(vdata->registerIndex)) == 0)
              cc.spillMMVar(vdata);
            break;
          case VARIABLE_TYPE_XMM:
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_4F:
          case VARIABLE_TYPE_XMM_2D:
            if ((getPrototype().getPreservedXMM() & Util::maskFromIndex(vdata->registerIndex)) == 0)
              cc.spillXMMVar(vdata);
            break;
        }
      }
    }
  }

  // --------------------------------------------------------------------------
  // STEP 4:
  //
  // Get temporary register that we can use to pass input function arguments.
  // Now it's safe to do, because the non-needed variables should be spilled.
  // --------------------------------------------------------------------------

  temporaryGpReg = _findTemporaryGpRegister(cc);
  temporaryXmmReg = _findTemporaryXmmRegister(cc);

  // If failed to get temporary register then we need just to pick one.
  if (temporaryGpReg == INVALID_VALUE)
  {
    // TODO.
  }
  if (temporaryXmmReg == INVALID_VALUE)
  {
    // TODO.
  }

  // --------------------------------------------------------------------------
  // STEP 5:
  //
  // Move all remaining arguments to the stack (we can use temporary register).
  // or allocate it to the primary register. Also move immediates.
  // --------------------------------------------------------------------------

  for (i = 0; i < argumentsCount; i++)
  {
    if (processed[i]) continue;

    const FunctionPrototype::Argument& argType = targs[i];
    if (argType.registerIndex != INVALID_VALUE) continue;

    Operand& operand = _args[i];

    if (operand.isVar())
    {
      VarCallRecord* rec = _argumentToVarRecord[i];
      VarData* vdata = compiler->_getVarData(operand.getId());

      _moveSpilledVariableToStack(cc,
        vdata, argType,
        temporaryGpReg, temporaryXmmReg);

      rec->inDone++;
      processed[i] = true;
    }
    else if (operand.isImm())
    {
      // TODO.
    }
  }

  // --------------------------------------------------------------------------
  // STEP 6:
  //
  // Allocate arguments to registers.
  // --------------------------------------------------------------------------

  bool didWork;

  do {
    didWork = false;

    for (i = 0; i < argumentsCount; i++)
    {
      if (processed[i]) continue;

      VarCallRecord* rsrc = _argumentToVarRecord[i];

      Operand& osrc = _args[i];
      ASMJIT_ASSERT(osrc.isVar());
      VarData* vsrc = compiler->_getVarData(osrc.getId());

      const FunctionPrototype::Argument& srcArgType = targs[i];
      VarData* vdst = _getOverlappingVariable(cc, srcArgType);

      if (vsrc == vdst)
      {
        rsrc->inDone++;
        processed[i] = true;

        didWork = true;
        continue;
      }
      else if (vdst != NULL)
      {
        VarCallRecord* rdst = reinterpret_cast<VarCallRecord*>(vdst->tempPtr);

        if (rdst->inDone >= rdst->inCount && (rdst->flags & VarCallRecord::FLAG_CALL_OPERAND_REG) == 0)
        {
          // Safe to spill.
          if (rdst->outCount || vdst->lastEmittable == this)
            cc.unuseVar(vdst, VARIABLE_STATE_UNUSED);
          else
            cc.spillVar(vdst);
          vdst = NULL;
        }
        else
        {
          uint32_t x = getPrototype().findArgumentByRegisterCode(
            getVariableRegisterCode(vsrc->type, vsrc->registerIndex));
          bool doSpill = true;

          if ((getVariableClass(vdst->type) & VariableInfo::CLASS_GP) != 0)
          {
            // Try to emit mov to register which is possible for call() operand.
            if (x == INVALID_VALUE && (rdst->flags & VarCallRecord::FLAG_CALL_OPERAND_REG) != 0)
            {
              uint32_t rIndex;
              uint32_t rBit;

              // The mask which contains registers which are not-preserved
              // (these that might be clobbered by the callee) and which are
              // not used to pass function arguments. Each register contained
              // in this mask is ideal to be used by call() instruction.
              uint32_t possibleMask = ~getPrototype().getPreservedGP() &
                                      ~getPrototype().getPassedGP()    & 
                                      Util::maskUpToIndex(REG_NUM_GP);

              if (possibleMask != 0)
              {
                for (rIndex = 0, rBit = 1; rIndex < REG_NUM_GP; rIndex++, rBit <<= 1)
                {
                  if ((possibleMask & rBit) != 0)
                  {
                    if (cc._state.gp[rIndex] == NULL) 
                    {
                      // This is the best possible solution, the register is
                      // free. We do not need to continue with this loop, the
                      // rIndex will be used by the call().
                      break;
                    }
                    else
                    {
                      // Wait until the register is freed or try to find another.
                      doSpill = false;
                      didWork = true;
                    }
                  }
                }
              }
              else
              {
                // Try to find a register which is free and which is not used
                // to pass a function argument.
                possibleMask = getPrototype().getPreservedGP();

                for (rIndex = 0, rBit = 1; rIndex < REG_NUM_GP; rIndex++, rBit <<= 1)
                {
                  if ((possibleMask & rBit) != 0)
                  {
                    // Found one.
                    if (cc._state.gp[rIndex] == NULL) break;
                  }
                }
              }

              if (rIndex < REG_NUM_GP)
              {
                if (temporaryGpReg == vsrc->registerIndex) temporaryGpReg = rIndex;
                compiler->emit(INST_MOV, gpn(rIndex), gpn(vsrc->registerIndex));

                cc._state.gp[vsrc->registerIndex] = NULL;
                cc._state.gp[rIndex] = vsrc;

                vsrc->registerIndex = rIndex;
                cc._allocatedGPRegister(rIndex);

                doSpill = false;
                didWork = true;
              }
            }
            // Emit xchg instead of spill/alloc if possible.
            else if (x != INVALID_VALUE)
            {
              const FunctionPrototype::Argument& dstArgType = targs[x];
              if (getVariableClass(dstArgType.variableType) == getVariableClass(srcArgType.variableType))
              {
                uint32_t dstIndex = vdst->registerIndex;
                uint32_t srcIndex = vsrc->registerIndex;

                if (srcIndex == dstArgType.registerIndex)
                {
#if defined(ASMJIT_X64)
                  if (vdst->type != VARIABLE_TYPE_GPD || vsrc->type != VARIABLE_TYPE_GPD)
                    compiler->emit(INST_XCHG, gpq(dstIndex), gpq(srcIndex));
                  else
#endif
                    compiler->emit(INST_XCHG, gpd(dstIndex), gpd(srcIndex));

                  cc._state.gp[srcIndex] = vdst;
                  cc._state.gp[dstIndex] = vsrc;

                  vdst->registerIndex = srcIndex;
                  vsrc->registerIndex = dstIndex;

                  rdst->inDone++;
                  rsrc->inDone++;

                  processed[i] = true;
                  processed[x] = true;

                  doSpill = false;
                }
              }
            }
          }

          if (doSpill)
          {
            cc.spillVar(vdst);
            vdst = NULL;
          }
        }
      }

      if (vdst == NULL)
      {
        VarCallRecord* rec = reinterpret_cast<VarCallRecord*>(vsrc->tempPtr);

        _moveSrcVariableToRegister(cc, vsrc, srcArgType);

        switch (srcArgType.variableType)
        {
          case VARIABLE_TYPE_GPD:
          case VARIABLE_TYPE_GPQ:
            cc._markGPRegisterModified(srcArgType.registerIndex);
            break;
          case VARIABLE_TYPE_MM:
            cc._markMMRegisterModified(srcArgType.registerIndex);
            break;
          case VARIABLE_TYPE_XMM:
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_4F:
          case VARIABLE_TYPE_XMM_2D:
            cc._markMMRegisterModified(srcArgType.registerIndex);
            break;
        }

        rec->inDone++;
        processed[i] = true;
      }
    }
  } while (didWork);

  // --------------------------------------------------------------------------
  // STEP 7:
  //
  // Allocate operand used by CALL instruction.
  // --------------------------------------------------------------------------

  for (i = 0; i < variablesCount; i++)
  {
    VarCallRecord& r = _variables[i];
    if ((r.flags & VarCallRecord::FLAG_CALL_OPERAND_REG) &&
        (r.vdata->registerIndex == INVALID_VALUE))
    {
      // If the register is not allocated and the call form is 'call reg' then
      // it's possible to keep it in memory.
      if ((r.flags & VarCallRecord::FLAG_CALL_OPERAND_MEM) == 0)
      {
        _target = GPVarFromData(r.vdata).m();
        break;
      }

      if (temporaryGpReg == INVALID_VALUE)
        temporaryGpReg = _findTemporaryGpRegister(cc);

      cc.allocGPVar(r.vdata, 
        Util::maskFromIndex(temporaryGpReg),
        VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_READ);
    }
  }

  cc.translateOperands(&_target, 1);

  // --------------------------------------------------------------------------
  // STEP 8:
  //
  // Spill all preserved variables.
  // --------------------------------------------------------------------------

  preserved = getPrototype().getPreservedGP();
  for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.gp[i];
    if (vdata && (preserved & mask) == 0)
    {
      VarCallRecord* rec = reinterpret_cast<VarCallRecord*>(vdata->tempPtr);
      if (rec && (rec->outCount || rec->flags & VarCallRecord::FLAG_UNUSE_AFTER_USE || vdata->lastEmittable == this))
        cc.unuseVar(vdata, VARIABLE_STATE_UNUSED);
      else
        cc.spillGPVar(vdata);
    }
  }

  preserved = getPrototype().getPreservedMM();
  for (i = 0, mask = 1; i < REG_NUM_MM; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.mm[i];
    if (vdata && (preserved & mask) == 0)
    {
      VarCallRecord* rec = reinterpret_cast<VarCallRecord*>(vdata->tempPtr);
      if (rec && (rec->outCount || vdata->lastEmittable == this))
        cc.unuseVar(vdata, VARIABLE_STATE_UNUSED);
      else
        cc.spillMMVar(vdata);
    }
  }

  preserved = getPrototype().getPreservedXMM();
  for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
  {
    VarData* vdata = cc._state.xmm[i];
    if (vdata && (preserved & mask) == 0)
    {
      VarCallRecord* rec = reinterpret_cast<VarCallRecord*>(vdata->tempPtr);
      if (rec && (rec->outCount || vdata->lastEmittable == this))
        cc.unuseVar(vdata, VARIABLE_STATE_UNUSED);
      else
        cc.spillXMMVar(vdata);
    }
  }

  // --------------------------------------------------------------------------
  // STEP 9:
  //
  // Emit CALL instruction.
  // --------------------------------------------------------------------------

  compiler->emit(INST_CALL, _target);

  // Restore the stack offset.
  if (getPrototype().getCalleePopsStack())
  {
    int32_t s = (int32_t)getPrototype().getArgumentsStackSize();
    if (s) compiler->emit(INST_SUB, nsp, imm(s));
  }

  // --------------------------------------------------------------------------
  // STEP 10:
  //
  // Prepare others for return value(s) and cleanup.
  // --------------------------------------------------------------------------

  // Clear temp data, see AsmJit::VarData::temp why it's needed.
  for (i = 0; i < variablesCount; i++)
  {
    VarCallRecord* rec = &_variables[i];
    VarData* vdata = rec->vdata;

    if (rec->flags & (VarCallRecord::FLAG_OUT_EAX | VarCallRecord::FLAG_OUT_EDX))
    {
      if (getVariableClass(vdata->type) & VariableInfo::CLASS_GP)
      {
        cc.allocGPVar(vdata, 
          Util::maskFromIndex((rec->flags & VarCallRecord::FLAG_OUT_EAX) != 0
            ? REG_INDEX_EAX
            : REG_INDEX_EDX),
          VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_WRITE);
        vdata->changed = true;
      }
    }

    if (rec->flags & (VarCallRecord::FLAG_OUT_MM0))
    {
      if (getVariableClass(vdata->type) & VariableInfo::CLASS_MM)
      {
        cc.allocMMVar(vdata, Util::maskFromIndex(REG_INDEX_MM0),
          VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_WRITE);
        vdata->changed = true;
      }
    }

    if (rec->flags & (VarCallRecord::FLAG_OUT_XMM0 | VarCallRecord::FLAG_OUT_XMM1))
    {
      if (getVariableClass(vdata->type) & VariableInfo::CLASS_XMM)
      {
        cc.allocXMMVar(vdata, 
          Util::maskFromIndex((rec->flags & VarCallRecord::FLAG_OUT_XMM0) != 0
            ? REG_INDEX_XMM0
            : REG_INDEX_XMM1),
          VARIABLE_ALLOC_REGISTER | VARIABLE_ALLOC_WRITE);
        vdata->changed = true;
      }
    }

    if (rec->flags & (VarCallRecord::FLAG_OUT_ST0 | VarCallRecord::FLAG_OUT_ST1))
    {
      if (getVariableClass(vdata->type) & VariableInfo::CLASS_XMM)
      {
        Mem mem(cc._getVarMem(vdata));
        cc.unuseVar(vdata, VARIABLE_STATE_MEMORY);

        switch (vdata->type)
        {
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
          {
            mem.setSize(4);
            compiler->emit(INST_FSTP, mem);
            break;
          }
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
          {
            mem.setSize(8);
            compiler->emit(INST_FSTP, mem);
            break;
          }
          default:
          {
            compiler->comment("*** WARNING: Can't convert float return value to untyped XMM\n");
            break;
          }
        }
      }
    }

    // Cleanup.
    vdata->tempPtr = NULL;
  }

  for (i = 0; i < variablesCount; i++)
  {
    cc._unuseVarOnEndOfScope(this, &_variables[i]);
  }

  return translated();
}

int ECall::getMaxSize() const ASMJIT_NOTHROW
{
  // TODO: Not optimal.
  return 15;
}

bool ECall::_tryUnuseVar(VarData* v) ASMJIT_NOTHROW
{
  for (uint32_t i = 0; i < _variablesCount; i++)
  {
    if (_variables[i].vdata == v)
    {
      _variables[i].flags |= VarCallRecord::FLAG_UNUSE_AFTER_USE;
      return true;
    }
  }

  return false;
}

uint32_t ECall::_findTemporaryGpRegister(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i;
  uint32_t mask;

  uint32_t passedGP = getPrototype().getPassedGP();
  uint32_t candidate = INVALID_VALUE;

  // Find all registers used to pass function arguments. We shouldn't use these
  // if possible.
  for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
  {
    if (cc._state.gp[i] == NULL)
    {
      // If this register is used to pass arguments to function, we will mark
      // it and use it only if there is no other one.
      if ((passedGP & mask) != 0)
        candidate = i;
      else
        return i;
    }
  }

  return candidate;
}

uint32_t ECall::_findTemporaryXmmRegister(CompilerContext& cc) ASMJIT_NOTHROW
{
  uint32_t i;
  uint32_t mask;

  uint32_t passedXMM = getPrototype().getPassedXMM();
  uint32_t candidate = INVALID_VALUE;

  // Find all registers used to pass function arguments. We shouldn't use these
  // if possible.
  for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
  {
    if (cc._state.xmm[i] == NULL)
    {
      // If this register is used to pass arguments to function, we will mark
      // it and use it only if there is no other one.
      if ((passedXMM & mask) != 0)
        candidate = i;
      else
        return i;
    }
  }

  return candidate;
}

VarData* ECall::_getOverlappingVariable(CompilerContext& cc,
  const FunctionPrototype::Argument& argType) const ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(argType.variableType != INVALID_VALUE);

  switch (argType.variableType)
  {
    case VARIABLE_TYPE_GPD:
    case VARIABLE_TYPE_GPQ:
      return cc._state.gp[argType.registerIndex];
    case VARIABLE_TYPE_MM:
      return cc._state.mm[argType.registerIndex];
    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_2D:
      return cc._state.xmm[argType.registerIndex];
  }

  return NULL;
}

void ECall::_moveAllocatedVariableToStack(CompilerContext& cc, VarData* vdata, const FunctionPrototype::Argument& argType) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(argType.registerIndex == INVALID_VALUE);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  Compiler* compiler = cc.getCompiler();

  uint32_t src = vdata->registerIndex;
  Mem dst = ptr(nsp, -(int)sizeof(sysint_t) + argType.stackOffset);

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
          compiler->emit(INST_MOV, dst, gpd(src));
          return;
#if defined(ASMJIT_X64)
        case VARIABLE_TYPE_GPQ:
        case VARIABLE_TYPE_MM:
          compiler->emit(INST_MOV, dst, gpq(src));
          return;
#endif // ASMJIT_X64
      }
      break;

#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
          compiler->emit(INST_MOV, dst, gpd(src));
          return;
        case VARIABLE_TYPE_GPQ:
          compiler->emit(INST_MOV, dst, gpq(src));
          return;
        case VARIABLE_TYPE_MM:
          compiler->emit(INST_MOVQ, dst, gpq(src));
          return;
      }
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_MM:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
        case VARIABLE_TYPE_X87_1F:
        case VARIABLE_TYPE_XMM_1F:
          compiler->emit(INST_MOVD, dst, mm(src));
          return;
        case VARIABLE_TYPE_GPQ:
        case VARIABLE_TYPE_MM:
        case VARIABLE_TYPE_X87_1D:
        case VARIABLE_TYPE_XMM_1D:
          compiler->emit(INST_MOVQ, dst, mm(src));
          return;
      }
      break;

    // We allow incompatible types here, because the called can convert them
    // to correct format before function is called.

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_2D:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_XMM:
          compiler->emit(INST_MOVDQU, dst, xmm(src));
          return;
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
          compiler->emit(INST_MOVUPS, dst, xmm(src));
          return;
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVUPD, dst, xmm(src));
          return;
      }
      break;

    case VARIABLE_TYPE_XMM_1F:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_X87_1F:
        case VARIABLE_TYPE_XMM:
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVSS, dst, xmm(src));
          return;
      }
      break;

    case VARIABLE_TYPE_XMM_1D:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_X87_1D:
        case VARIABLE_TYPE_XMM:
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVSD, dst, xmm(src));
          return;
      }
      break;
  }

  compiler->setError(ERROR_INCOMPATIBLE_ARGUMENT);
}

void ECall::_moveSpilledVariableToStack(CompilerContext& cc,
  VarData* vdata, const FunctionPrototype::Argument& argType,
  uint32_t temporaryGpReg,
  uint32_t temporaryXmmReg) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(argType.registerIndex == INVALID_VALUE);
  ASMJIT_ASSERT(vdata->registerIndex == INVALID_VALUE);

  Compiler* compiler = cc.getCompiler();

  Mem src = cc._getVarMem(vdata);
  Mem dst = ptr(nsp, -(int)sizeof(sysint_t) + argType.stackOffset);

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
          compiler->emit(INST_MOV, gpd(temporaryGpReg), src);
          compiler->emit(INST_MOV, dst, gpd(temporaryGpReg));
          return;
#if defined(ASMJIT_X64)
        case VARIABLE_TYPE_GPQ:
        case VARIABLE_TYPE_MM:
          compiler->emit(INST_MOV, gpd(temporaryGpReg), src);
          compiler->emit(INST_MOV, dst, gpq(temporaryGpReg));
          return;
#endif // ASMJIT_X64
      }
      break;

#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
          compiler->emit(INST_MOV, gpd(temporaryGpReg), src);
          compiler->emit(INST_MOV, dst, gpd(temporaryGpReg));
          return;
        case VARIABLE_TYPE_GPQ:
        case VARIABLE_TYPE_MM:
          compiler->emit(INST_MOV, gpq(temporaryGpReg), src);
          compiler->emit(INST_MOV, dst, gpq(temporaryGpReg));
          return;
      }
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_MM:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_GPD:
        case VARIABLE_TYPE_X87_1F:
        case VARIABLE_TYPE_XMM_1F:
          compiler->emit(INST_MOV, gpd(temporaryGpReg), src);
          compiler->emit(INST_MOV, dst, gpd(temporaryGpReg));
          return;
        case VARIABLE_TYPE_GPQ:
        case VARIABLE_TYPE_MM:
        case VARIABLE_TYPE_X87_1D:
        case VARIABLE_TYPE_XMM_1D:
          // TODO
          return;
      }
      break;

    // We allow incompatible types here, because the called can convert them
    // to correct format before function is called.

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_2D:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_XMM:
          compiler->emit(INST_MOVDQU, xmm(temporaryXmmReg), src);
          compiler->emit(INST_MOVDQU, dst, xmm(temporaryXmmReg));
          return;
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
          compiler->emit(INST_MOVUPS, xmm(temporaryXmmReg), src);
          compiler->emit(INST_MOVUPS, dst, xmm(temporaryXmmReg));
          return;
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVUPD, xmm(temporaryXmmReg), src);
          compiler->emit(INST_MOVUPD, dst, xmm(temporaryXmmReg));
          return;
      }
      break;

    case VARIABLE_TYPE_XMM_1F:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_X87_1F:
        case VARIABLE_TYPE_XMM:
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVSS, xmm(temporaryXmmReg), src);
          compiler->emit(INST_MOVSS, dst, xmm(temporaryXmmReg));
          return;
      }
      break;

    case VARIABLE_TYPE_XMM_1D:
      switch (argType.variableType)
      {
        case VARIABLE_TYPE_X87_1D:
        case VARIABLE_TYPE_XMM:
        case VARIABLE_TYPE_XMM_1F:
        case VARIABLE_TYPE_XMM_4F:
        case VARIABLE_TYPE_XMM_1D:
        case VARIABLE_TYPE_XMM_2D:
          compiler->emit(INST_MOVSD, xmm(temporaryXmmReg), src);
          compiler->emit(INST_MOVSD, dst, xmm(temporaryXmmReg));
          return;
      }
      break;
  }

  compiler->setError(ERROR_INCOMPATIBLE_ARGUMENT);
}

void ECall::_moveSrcVariableToRegister(CompilerContext& cc,
  VarData* vdata, const FunctionPrototype::Argument& argType) ASMJIT_NOTHROW
{
  uint32_t dst = argType.registerIndex;
  uint32_t src = vdata->registerIndex;

  Compiler* compiler = cc.getCompiler();

  if (src != INVALID_VALUE)
  {
    switch (argType.variableType)
    {
      case VARIABLE_TYPE_GPD:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
            compiler->emit(INST_MOV, gpd(dst), gpd(src));
            return;
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVD, gpd(dst), mm(src));
            return;
        }
        break;

#if defined(ASMJIT_X64)
      case VARIABLE_TYPE_GPQ:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOV, gpd(dst), gpd(src));
            return;
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOV, gpq(dst), gpq(src));
            return;
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, gpq(dst), mm(src));
            return;
        }
        break;
#endif // ASMJIT_X64

      case VARIABLE_TYPE_MM:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOVD, gpd(dst), gpd(src));
            return;
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOVQ, gpq(dst), gpq(src));
            return;
#endif // ASMJIT_X64
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, mm(dst), mm(src));
            return;
        }
        break;

      case VARIABLE_TYPE_XMM:
      case VARIABLE_TYPE_XMM_4F:
      case VARIABLE_TYPE_XMM_2D:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOVD, xmm(dst), gpd(src));
            return;
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOVQ, xmm(dst), gpq(src));
            return;
#endif // ASMJIT_X64
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mm(src));
            return;
          case VARIABLE_TYPE_XMM:
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_MOVDQA, xmm(dst), xmm(src));
            return;
        }
        break;

      case VARIABLE_TYPE_XMM_1F:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mm(src));
            return;

          case VARIABLE_TYPE_XMM:
            compiler->emit(INST_MOVDQA, xmm(dst), xmm(src));
            return;
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
            compiler->emit(INST_MOVSS, xmm(dst), xmm(src));
            return;
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_CVTSD2SS, xmm(dst), xmm(src));
            return;
        }
        break;

      case VARIABLE_TYPE_XMM_1D:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mm(src));
            return;

          case VARIABLE_TYPE_XMM:
            compiler->emit(INST_MOVDQA, xmm(dst), xmm(src));
            return;
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
            compiler->emit(INST_CVTSS2SD, xmm(dst), xmm(src));
            return;
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_MOVSD, xmm(dst), xmm(src));
            return;
        }
        break;
    }
  }
  else
  {
    Mem mem = cc._getVarMem(vdata);

    switch (argType.variableType)
    {
      case VARIABLE_TYPE_GPD:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
            compiler->emit(INST_MOV, gpd(dst), mem);
            return;
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVD, gpd(dst), mem);
            return;
        }
        break;

#if defined(ASMJIT_X64)
      case VARIABLE_TYPE_GPQ:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOV, gpd(dst), mem);
            return;
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOV, gpq(dst), mem);
            return;
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, gpq(dst), mem);
            return;
        }
        break;
#endif // ASMJIT_X64

      case VARIABLE_TYPE_MM:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOVD, gpd(dst), mem);
            return;
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOVQ, gpq(dst), mem);
            return;
#endif // ASMJIT_X64
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, mm(dst), mem);
            return;
        }
        break;

      case VARIABLE_TYPE_XMM:
      case VARIABLE_TYPE_XMM_4F:
      case VARIABLE_TYPE_XMM_2D:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_GPD:
            compiler->emit(INST_MOVD, xmm(dst), mem);
            return;
#if defined(ASMJIT_X64)
          case VARIABLE_TYPE_GPQ:
            compiler->emit(INST_MOVQ, xmm(dst), mem);
            return;
#endif // ASMJIT_X64
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mem);
            return;
          case VARIABLE_TYPE_XMM:
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_MOVDQA, xmm(dst), mem);
            return;
        }
        break;

      case VARIABLE_TYPE_XMM_1F:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mem);
            return;

          case VARIABLE_TYPE_XMM:
            compiler->emit(INST_MOVDQA, xmm(dst), mem);
            return;
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
            compiler->emit(INST_MOVSS, xmm(dst), mem);
            return;
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_CVTSD2SS, xmm(dst), mem);
            return;
        }
        break;

      case VARIABLE_TYPE_XMM_1D:
        switch (vdata->type)
        {
          case VARIABLE_TYPE_MM:
            compiler->emit(INST_MOVQ, xmm(dst), mem);
            return;

          case VARIABLE_TYPE_XMM:
            compiler->emit(INST_MOVDQA, xmm(dst), mem);
            return;
          case VARIABLE_TYPE_XMM_1F:
          case VARIABLE_TYPE_XMM_4F:
            compiler->emit(INST_CVTSS2SD, xmm(dst), mem);
            return;
          case VARIABLE_TYPE_XMM_1D:
          case VARIABLE_TYPE_XMM_2D:
            compiler->emit(INST_MOVSD, xmm(dst), mem);
            return;
        }
        break;
    }
  }

  compiler->setError(ERROR_INCOMPATIBLE_ARGUMENT);
}

// Prototype & Arguments Management.
void ECall::_setPrototype(
  uint32_t callingConvention,
  const uint32_t* arguments,
  uint32_t argumentsCount,
  uint32_t returnValue) ASMJIT_NOTHROW
{
  _functionPrototype.setPrototype(callingConvention, arguments, argumentsCount, returnValue);

  _args = reinterpret_cast<Operand*>(
    getCompiler()->getZone().zalloc(sizeof(Operand) * argumentsCount));
  memset(_args, 0, sizeof(Operand) * argumentsCount);
}

bool ECall::setArgument(uint32_t i, const BaseVar& var) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(i < _functionPrototype.getArgumentsCount());
  if (i >= _functionPrototype.getArgumentsCount()) return false;

  _args[i] = var;
  return true;
}

bool ECall::setArgument(uint32_t i, const Imm& imm) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(i < _functionPrototype.getArgumentsCount());
  if (i >= _functionPrototype.getArgumentsCount()) return false;

  _args[i] = imm;
  return true;
}

bool ECall::setReturn(const Operand& first, const Operand& second) ASMJIT_NOTHROW
{
  _ret[0] = first;
  _ret[1] = second;

  return true;
}

// ============================================================================
// [AsmJit::ERet]
// ============================================================================

ERet::ERet(Compiler* c, EFunction* function, const Operand* first, const Operand* second) ASMJIT_NOTHROW :
  Emittable(c, EMITTABLE_RET),
  _function(function)
{
  if (first ) _ret[0] = *first;
  if (second) _ret[1] = *second;

/*
  // TODO:?

  // Check whether the return value is compatible.
  uint32_t retValType = function->getPrototype().getReturnValue();
  bool valid = false;

  switch (retValType)
  {
    case VARIABLE_TYPE_GPD:
    case VARIABLE_TYPE_GPQ:
      if ((_ret[0].isVar() && (reinterpret_cast<const BaseVar&>(_ret[0]).isGPVar())) ||
          (_ret[0].isImm()))
      {
        valid = true;
      }
      break;

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      if ((_ret[0].isVar() && (reinterpret_cast<const BaseVar&>(_ret[0]).isX87Var() ||
                               reinterpret_cast<const BaseVar&>(_ret[0]).isXMMVar() )) )
      {
        valid = true;
      }
      break;

    case VARIABLE_TYPE_MM:
      break;

    case INVALID_VALUE:
      if (_ret[0].isNone() && 
          _ret[1].isNone())
      {
        valid = true;
      }
      break;

    default:
      break;
  }

  // Incompatible return value.
  if (!valid)
  {
    c->setError(ERROR_INCOMPATIBLE_RETURN_VALUE);
  }
*/
}

ERet::~ERet() ASMJIT_NOTHROW
{
}

void ERet::prepare(CompilerContext& cc) ASMJIT_NOTHROW
{
  _offset = cc._currentOffset;

  uint32_t retValType = getFunction()->getPrototype().getReturnValue();
  if (retValType != INVALID_VALUE)
  {
    uint32_t i;
    for (i = 0; i < 2; i++)
    {
      Operand& o = _ret[i];

      if (o.isVar())
      {
        ASMJIT_ASSERT(o.getId() != INVALID_VALUE);
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        // First emittable (begin of variable scope).
        if (vdata->firstEmittable == NULL) vdata->firstEmittable = this;

        // Last emittable (end of variable scope).
        vdata->lastEmittable = this;

        if (vdata->workOffset == _offset) continue;
        if (!cc._isActive(vdata)) cc._addActive(vdata);

        vdata->workOffset = _offset;
        vdata->registerReadCount++;

        if (isVariableInteger(vdata->type) && isVariableInteger(retValType))
        {
          cc._newRegisterHomeIndex(vdata, (i == 0) ? REG_INDEX_EAX : REG_INDEX_EDX);
        }
      }
    }
  }

  cc._currentOffset++;
}

Emittable* ERet::translate(CompilerContext& cc) ASMJIT_NOTHROW
{
  Compiler* compiler = cc.getCompiler();

  // Check whether the return value is compatible.
  uint32_t retValType = getFunction()->getPrototype().getReturnValue();
  uint32_t i;

  switch ((int)retValType)
  {
    case VARIABLE_TYPE_GPD:
    case VARIABLE_TYPE_GPQ:
      for (i = 0; i < 2; i++)
      {
        uint32_t dstIndex = (i == 0) ? REG_INDEX_EAX : REG_INDEX_EDX;
        uint32_t srcIndex;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isGPVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srcIndex = vdata->registerIndex;
            if (srcIndex == INVALID_VALUE)
              compiler->emit(INST_MOV, gpn(dstIndex), cc._getVarMem(vdata));
            else if (dstIndex != srcIndex)
              compiler->emit(INST_MOV, gpn(dstIndex), gpn(srcIndex));
          }
        }
        else if (_ret[i].isImm())
        {
          compiler->emit(INST_MOV, gpn(dstIndex), _ret[i]);
        }
      }
      break;

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // There is case that we need to return two values (Unix-ABI specific):
      // - FLD #2
      //-  FLD #1
      i = 2;
      do {
        i--;
        uint32_t dsti = i;
        uint32_t srci;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isX87Var())
          {
            // TODO: X87.
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isXMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            if (srci != INVALID_VALUE) cc.saveXMMVar(vdata);

            switch (vdata->type)
            {
              case VARIABLE_TYPE_XMM_1F:
              case VARIABLE_TYPE_XMM_4F:
                compiler->emit(INST_FLD, _BaseVarMem(reinterpret_cast<BaseVar&>(_ret[i]), 4));
                break;
              case VARIABLE_TYPE_XMM_1D:
              case VARIABLE_TYPE_XMM_2D:
                compiler->emit(INST_FLD, _BaseVarMem(reinterpret_cast<BaseVar&>(_ret[i]), 8));
                break;
            }
          }
        }
      } while (i != 0);
      break;

    case VARIABLE_TYPE_MM:
      for (i = 0; i < 2; i++)
      {
        uint32_t dsti = i;
        uint32_t srci;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isGPVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            uint32_t inst = _ret[i].isRegType(REG_TYPE_GPQ) ? INST_MOVQ : INST_MOVD;

            if (srci == INVALID_VALUE)
              compiler->emit(inst, mm(dsti), cc._getVarMem(vdata));
            else
#if defined(ASMJIT_X86)
              compiler->emit(inst, mm(dsti), gpd(srci));
#else
              compiler->emit(inst, mm(dsti), _ret[i].isRegType(REG_TYPE_GPQ) ? gpq(srci) : gpd(srci));
#endif
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            uint32_t inst = INST_MOVQ;

            if (srci == INVALID_VALUE)
              compiler->emit(inst, mm(dsti), cc._getVarMem(vdata));
            else if (dsti != srci)
              compiler->emit(inst, mm(dsti), mm(srci));
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isXMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            uint32_t inst = INST_MOVQ;
            if (reinterpret_cast<const BaseVar&>(_ret[i]).getVariableType() == VARIABLE_TYPE_XMM_1F) inst = INST_MOVD;

            if (srci == INVALID_VALUE)
              compiler->emit(inst, mm(dsti), cc._getVarMem(vdata));
            else
              compiler->emit(inst, mm(dsti), xmm(srci));
          }
        }
      }
      break;

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_2D:
      for (i = 0; i < 2; i++)
      {
        uint32_t dsti = i;
        uint32_t srci;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isGPVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            uint32_t inst = _ret[i].isRegType(REG_TYPE_GPQ) ? INST_MOVQ : INST_MOVD;

            if (srci == INVALID_VALUE)
              compiler->emit(inst, xmm(dsti), cc._getVarMem(vdata));
            else
#if defined(ASMJIT_X86)
              compiler->emit(inst, xmm(dsti), gpd(srci));
#else
              compiler->emit(inst, xmm(dsti), _ret[i].isRegType(REG_TYPE_GPQ) ? gpq(srci) : gpd(srci));
#endif
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isX87Var())
          {
            // TODO: X87.
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            if (srci == INVALID_VALUE)
              compiler->emit(INST_MOVQ, xmm(dsti), cc._getVarMem(vdata));
            else
              compiler->emit(INST_MOVQ, xmm(dsti), mm(srci));
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isXMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            if (srci == INVALID_VALUE)
              compiler->emit(INST_MOVDQA, xmm(dsti), cc._getVarMem(vdata));
            else if (dsti != srci)
              compiler->emit(INST_MOVDQA, xmm(dsti), xmm(srci));
          }
        }
      }
      break;

    case VARIABLE_TYPE_XMM_1F:
      for (i = 0; i < 2; i++)
      {
        uint32_t dsti = i;
        uint32_t srci;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isX87Var())
          {
            // TODO: X87.
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isXMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            switch (vdata->type)
            {
              case VARIABLE_TYPE_XMM:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_MOVDQA, xmm(dsti), cc._getVarMem(vdata));
                else if (dsti != srci)
                  compiler->emit(INST_MOVDQA, xmm(dsti), xmm(srci));
                break;
              case VARIABLE_TYPE_XMM_1F:
              case VARIABLE_TYPE_XMM_4F:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_MOVSS, xmm(dsti), cc._getVarMem(vdata));
                else
                  compiler->emit(INST_MOVSS, xmm(dsti), xmm(srci));
                break;
              case VARIABLE_TYPE_XMM_1D:
              case VARIABLE_TYPE_XMM_2D:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_CVTSD2SS, xmm(dsti), cc._getVarMem(vdata));
                else if (dsti != srci)
                  compiler->emit(INST_CVTSD2SS, xmm(dsti), xmm(srci));
                break;
            }
          }
        }
      }
      break;

    case VARIABLE_TYPE_XMM_1D:
      for (i = 0; i < 2; i++)
      {
        uint32_t dsti = i;
        uint32_t srci;

        if (_ret[i].isVar())
        {
          if (reinterpret_cast<const BaseVar&>(_ret[i]).isX87Var())
          {
            // TODO: X87.
          }
          else if (reinterpret_cast<const BaseVar&>(_ret[i]).isXMMVar())
          {
            VarData* vdata = compiler->_getVarData(_ret[i].getId());
            ASMJIT_ASSERT(vdata != NULL);

            srci = vdata->registerIndex;
            switch (vdata->type)
            {
              case VARIABLE_TYPE_XMM:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_MOVDQA, xmm(dsti), cc._getVarMem(vdata));
                else if (dsti != srci)
                  compiler->emit(INST_MOVDQA, xmm(dsti), xmm(srci));
                break;
              case VARIABLE_TYPE_XMM_1F:
              case VARIABLE_TYPE_XMM_4F:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_CVTSS2SD, xmm(dsti), cc._getVarMem(vdata));
                else
                  compiler->emit(INST_CVTSS2SD, xmm(dsti), xmm(srci));
                break;
              case VARIABLE_TYPE_XMM_1D:
              case VARIABLE_TYPE_XMM_2D:
                if (srci == INVALID_VALUE)
                  compiler->emit(INST_MOVSD, xmm(dsti), cc._getVarMem(vdata));
                else
                  compiler->emit(INST_MOVSD, xmm(dsti), xmm(srci));
                break;
            }
          }
        }
      }
      break;

    case INVALID_VALUE:
    default:
      break;
  }

  if (shouldEmitJumpToEpilog())
  {
    cc._unreachable = 1;
  }

  for (i = 0; i < 2; i++)
  {
    if (_ret[i].isVar())
    {
      VarData* vdata = compiler->_getVarData(_ret[i].getId());
      cc._unuseVarOnEndOfScope(this, vdata);
    }
  }

  return translated();
}

void ERet::emit(Assembler& a) ASMJIT_NOTHROW
{
  if (shouldEmitJumpToEpilog())
  {
    a.jmp(getFunction()->getExitLabel());
  }
}

int ERet::getMaxSize() const ASMJIT_NOTHROW
{
  return shouldEmitJumpToEpilog() ? 15 : 0;
}

bool ERet::shouldEmitJumpToEpilog() const ASMJIT_NOTHROW
{
  // Iterate over next emittables. If we found emittable that emits real 
  // instruction then we must return @c true.
  Emittable* e = this->getNext();

  while (e)
  {
    switch (e->getType())
    {
      // Non-interesting emittables.
      case EMITTABLE_COMMENT:
      case EMITTABLE_DUMMY:
      case EMITTABLE_ALIGN:
      case EMITTABLE_BLOCK:
      case EMITTABLE_VARIABLE_HINT:
      case EMITTABLE_TARGET:
        break;

      // Interesting emittables.
      case EMITTABLE_EMBEDDED_DATA:
      case EMITTABLE_INSTRUCTION:
      case EMITTABLE_JUMP_TABLE:
      case EMITTABLE_CALL:
      case EMITTABLE_RET:
        return true;

      // These emittables shouldn't be here. We are inside function, after
      // prolog.
      case EMITTABLE_FUNCTION:
      case EMITTABLE_PROLOG:
        break;

      // Stop station, we can't go forward from here.
      case EMITTABLE_EPILOG:
        return false;
    }
    e = e->getNext();
  }

  return false;
}

// ============================================================================
// [AsmJit::CompilerContext - Construction / Destruction]
// ============================================================================

CompilerContext::CompilerContext(Compiler* compiler) ASMJIT_NOTHROW :
  _zone(8192 - sizeof(Zone::Chunk) - 32)
{
  _compiler = compiler;
  _clear();

  _emitComments = compiler->getLogger() != NULL;
}

CompilerContext::~CompilerContext() ASMJIT_NOTHROW
{
}

// ============================================================================
// [AsmJit::CompilerContext - Clear]
// ============================================================================

void CompilerContext::_clear() ASMJIT_NOTHROW
{
  _zone.clear();
  _function = NULL;

  _start = NULL;
  _stop = NULL;

  _state.clear();
  _active = NULL;

  _forwardJumps = NULL;

  _currentOffset = 0;
  _unreachable = 0;

  _modifiedGPRegisters = 0;
  _modifiedMMRegisters = 0;
  _modifiedXMMRegisters = 0;

  _allocableEBP = false;

  _adjustESP = 0;

  _argumentsBaseReg = INVALID_VALUE; // Used by patcher.
  _argumentsBaseOffset = 0;          // Used by patcher.
  _argumentsActualDisp = 0;          // Used by translate().

  _variablesBaseReg = INVALID_VALUE; // Used by patcher.
  _variablesBaseOffset = 0;          // Used by patcher.
  _variablesActualDisp = 0;          // Used by translate()

  _memUsed = NULL;
  _memFree = NULL;

  _mem4BlocksCount = 0;
  _mem8BlocksCount = 0;
  _mem16BlocksCount = 0;

  _memBytesTotal = 0;

  _backCode.clear();
  _backPos = 0;
}

// ============================================================================
// [AsmJit::CompilerContext - Construction / Destruction]
// ============================================================================

void CompilerContext::allocVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW
{
  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
      allocGPVar(vdata, regMask, vflags);
      break;

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      allocMMVar(vdata, regMask, vflags);
      break;

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_2D:
      allocXMMVar(vdata, regMask, vflags);
      break;
  }

  _postAlloc(vdata, vflags);
}

void CompilerContext::saveVar(VarData* vdata) ASMJIT_NOTHROW
{
  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
      saveGPVar(vdata);
      break;

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      saveMMVar(vdata);
      break;

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_2D:
      saveXMMVar(vdata);
      break;
  }
}

void CompilerContext::spillVar(VarData* vdata) ASMJIT_NOTHROW
{
  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
      spillGPVar(vdata);
      break;

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      spillMMVar(vdata);
      break;

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_2D:
      spillXMMVar(vdata);
      break;
  }
}

void CompilerContext::unuseVar(VarData* vdata, uint32_t toState) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(toState != VARIABLE_STATE_REGISTER);

  if (vdata->state == VARIABLE_STATE_REGISTER)
  {
    uint32_t registerIndex = vdata->registerIndex;
    switch (vdata->type)
    {
      case VARIABLE_TYPE_GPD:
#if defined(ASMJIT_X64)
      case VARIABLE_TYPE_GPQ:
#endif // ASMJIT_X64
        _state.gp[registerIndex] = NULL;
        _freedGPRegister(registerIndex);
        break;

      case VARIABLE_TYPE_X87:
      case VARIABLE_TYPE_X87_1F:
      case VARIABLE_TYPE_X87_1D:
        // TODO: X87 VARIABLES NOT IMPLEMENTED.
        break;

      case VARIABLE_TYPE_MM:
        _state.mm[registerIndex] = NULL;
        _freedMMRegister(registerIndex);
        break;

      case VARIABLE_TYPE_XMM:
      case VARIABLE_TYPE_XMM_1F:
      case VARIABLE_TYPE_XMM_4F:
      case VARIABLE_TYPE_XMM_1D:
      case VARIABLE_TYPE_XMM_2D:
        _state.xmm[registerIndex] = NULL;
        _freedXMMRegister(registerIndex);
        break;
    }
  }

  vdata->state = toState;
  vdata->changed = false;
  vdata->registerIndex = INVALID_VALUE;
}

void CompilerContext::allocGPVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW
{
  // Fix the regMask (0 or full bit-array means that any register may be used).
  if (regMask == 0) regMask = Util::maskUpToIndex(REG_NUM_GP);
  regMask &= Util::maskUpToIndex(REG_NUM_GP);

  // Working variables.
  uint32_t i;
  uint32_t mask;

  // Last register code (aka home).
  uint32_t home = vdata->homeRegisterIndex;
  // New register code.
  uint32_t idx = INVALID_VALUE;

  // Preserved GP variables.
  uint32_t preservedGP = vdata->scope->getPrototype().getPreservedGP();

  // Spill candidate.
  VarData* spillCandidate = NULL;

  // Whether to alloc the non-preserved variables first.
  bool nonPreservedFirst = true;
  if (getFunction()->_isCaller)
  {
    nonPreservedFirst = vdata->firstCallable == NULL || 
                        vdata->firstCallable->getOffset() >= vdata->lastEmittable->getOffset();
  }

  // --------------------------------------------------------------------------
  // [Already Allocated]
  // --------------------------------------------------------------------------

  // Go away if variable is already allocated.
  if (vdata->state == VARIABLE_STATE_REGISTER)
  {
    uint32_t oldIndex = vdata->registerIndex;

    // Already allocated in the right register.
    if (Util::maskFromIndex(oldIndex) & regMask) return;

    // Try to find unallocated register first.
    mask = regMask & ~_state.usedGP;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedGP) != 0) ? mask & ~preservedGP : mask);
    }
    // Then find the allocated and later exchange.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedGP);
    }
    ASMJIT_ASSERT(idx != INVALID_VALUE);

    VarData* other = _state.gp[idx];
    emitExchangeVar(vdata, idx, vflags, other);

    _state.gp[oldIndex] = other;
    _state.gp[idx     ] = vdata;

    if (other)
      other->registerIndex = oldIndex;
    else
      _freedGPRegister(oldIndex);

    // Update VarData.
    vdata->state = VARIABLE_STATE_REGISTER;
    vdata->registerIndex = idx;
    vdata->homeRegisterIndex = idx;

    _allocatedGPRegister(idx);
    return;
  }

  // --------------------------------------------------------------------------
  // [Find Unused GP]
  // --------------------------------------------------------------------------

  // If regMask contains restricted registers which may be used then everything
  // is handled in this block.
  if (regMask != Util::maskUpToIndex(REG_NUM_GP))
  {
    // Try to find unallocated register first.
    mask = regMask & ~_state.usedGP;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedGP) != 0) ? (mask & ~preservedGP) : mask);
      ASMJIT_ASSERT(idx != INVALID_VALUE);
    }
    // Then find the allocated and later spill.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedGP);
      ASMJIT_ASSERT(idx != INVALID_VALUE);

      // Spill register we need.
      spillCandidate = _state.gp[idx];

      // Jump to spill part of allocation.
      goto L_Spill;
    }
  }

  // Home register code.
  if (idx == INVALID_VALUE && home != INVALID_VALUE)
  {
    if ((_state.usedGP & (1U << home)) == 0) idx = home;
  }

  // We start from 1, because EAX/RAX register is sometimes explicitly
  // needed. So we trying to prevent reallocation in near future.
  if (idx == INVALID_VALUE)
  {
    for (i = 1, mask = (1 << i); i < REG_NUM_GP; i++, mask <<= 1)
    {
      if ((_state.usedGP & mask) == 0 && (i != REG_INDEX_EBP || _allocableEBP) && (i != REG_INDEX_ESP))
      {
        // Convenience to alloc non-preserved first or non-preserved last.
        if (nonPreservedFirst)
        {
          if (idx != INVALID_VALUE && (preservedGP & mask) != 0) continue;
          idx = i;
          // If current register is preserved, we should try to find different
          // one that is not. This can save one push / pop in prolog / epilog.
          if ((preservedGP & mask) == 0) break;
        }
        else
        {
          if (idx != INVALID_VALUE && (preservedGP & mask) == 0) continue;
          idx = i;
          // The opposite.
          if ((preservedGP & mask) != 0) break;
        }
      }
    }
  }

  // If not found, try EAX/RAX.
  if (idx == INVALID_VALUE && (_state.usedGP & 1) == 0)
  {
    idx = REG_INDEX_EAX;
  }

  // --------------------------------------------------------------------------
  // [Spill]
  // --------------------------------------------------------------------------

  // If register is still not found, spill other variable.
  if (idx == INVALID_VALUE)
  {
    if (spillCandidate == NULL)
    {
      spillCandidate = _getSpillCandidateGP();
    }

    // Spill candidate not found?
    if (spillCandidate == NULL)
    {
      _compiler->setError(ERROR_NOT_ENOUGH_REGISTERS);
      return;
    }

L_Spill:

    // Prevented variables can't be spilled. _getSpillCandidate() never returns
    // prevented variables, but when jumping to L_spill it can happen.
    if (spillCandidate->workOffset == _currentOffset)
    {
      _compiler->setError(ERROR_REGISTERS_OVERLAP);
      return;
    }

    idx = spillCandidate->registerIndex;
    spillGPVar(spillCandidate);
  }

  // --------------------------------------------------------------------------
  // [Alloc]
  // --------------------------------------------------------------------------

  if (vdata->state == VARIABLE_STATE_MEMORY && (vflags & VARIABLE_ALLOC_READ) != 0)
  {
    emitLoadVar(vdata, idx);
  }

  // Update VarData.
  vdata->state = VARIABLE_STATE_REGISTER;
  vdata->registerIndex = idx;
  vdata->homeRegisterIndex = idx;

  // Update StateData.
  _allocatedVariable(vdata);
}

void CompilerContext::saveGPVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't save variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;
  emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->changed = false;
}

void CompilerContext::spillGPVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't spill variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;

  if (vdata->changed) emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->registerIndex = INVALID_VALUE;
  vdata->state = VARIABLE_STATE_MEMORY;
  vdata->changed = false;

  // Update StateData.
  _state.gp[idx] = NULL;
  _freedGPRegister(idx);
}

void CompilerContext::allocMMVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW
{
  // Fix the regMask (0 or full bit-array means that any register may be used).
  if (regMask == 0) regMask = Util::maskUpToIndex(REG_NUM_MM);
  regMask &= Util::maskUpToIndex(REG_NUM_MM);

  // Working variables.
  uint32_t i;
  uint32_t mask;

  // Last register code (aka home).
  uint32_t home = vdata->homeRegisterIndex;
  // New register code.
  uint32_t idx = INVALID_VALUE;

  // Preserved MM variables.
  //
  // NOTE: Currently MM variables are not preserved and there is no calling
  // convention known to me that does that. But on the other side it's possible
  // to write such calling convention.
  uint32_t preservedMM = vdata->scope->getPrototype().getPreservedMM();

  // Spill candidate.
  VarData* spillCandidate = NULL;

  // Whether to alloc non-preserved first or last.
  bool nonPreservedFirst = true;
  if (this->getFunction()->_isCaller)
  {
    nonPreservedFirst = vdata->firstCallable == NULL || 
                        vdata->firstCallable->getOffset() >= vdata->lastEmittable->getOffset();
  }

  // --------------------------------------------------------------------------
  // [Already Allocated]
  // --------------------------------------------------------------------------

  // Go away if variable is already allocated.
  if (vdata->state == VARIABLE_STATE_REGISTER)
  {
    uint32_t oldIndex = vdata->registerIndex;

    // Already allocated in the right register.
    if (Util::maskFromIndex(oldIndex) & regMask) return;

    // Try to find unallocated register first.
    mask = regMask & ~_state.usedMM;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedMM) != 0) ? mask & ~preservedMM : mask);
    }
    // Then find the allocated and later exchange.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedMM);
    }
    ASMJIT_ASSERT(idx != INVALID_VALUE);

    VarData* other = _state.mm[idx];
    if (other) spillMMVar(other);

    emitMoveVar(vdata, idx, vflags);
    _freedMMRegister(oldIndex);
    _state.mm[idx] = vdata;

    // Update VarData.
    vdata->state = VARIABLE_STATE_REGISTER;
    vdata->registerIndex = idx;
    vdata->homeRegisterIndex = idx;

    _allocatedMMRegister(idx);
    return;
  }

  // --------------------------------------------------------------------------
  // [Find Unused MM]
  // --------------------------------------------------------------------------

  // If regMask contains restricted registers which may be used then everything
  // is handled in this block.
  if (regMask != Util::maskUpToIndex(REG_NUM_MM))
  {
    // Try to find unallocated register first.
    mask = regMask & ~_state.usedMM;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedMM) != 0) ? mask & ~preservedMM : mask);
      ASMJIT_ASSERT(idx != INVALID_VALUE);
    }
    // Then find the allocated and later spill.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedMM);
      ASMJIT_ASSERT(idx != INVALID_VALUE);

      // Spill register we need.
      spillCandidate = _state.mm[idx];

      // Jump to spill part of allocation.
      goto L_Spill;
    }
  }

  // Home register code.
  if (idx == INVALID_VALUE && home != INVALID_VALUE)
  {
    if ((_state.usedMM & (1U << home)) == 0) idx = home;
  }

  if (idx == INVALID_VALUE)
  {
    for (i = 0, mask = (1 << i); i < REG_NUM_MM; i++, mask <<= 1)
    {
      if ((_state.usedMM & mask) == 0)
      {
        // Convenience to alloc non-preserved first or non-preserved last.
        if (nonPreservedFirst)
        {
          if (idx != INVALID_VALUE && (preservedMM & mask) != 0) continue;
          idx = i;
          // If current register is preserved, we should try to find different
          // one that is not. This can save one push / pop in prolog / epilog.
          if ((preservedMM & mask) == 0) break;
        }
        else
        {
          if (idx != INVALID_VALUE && (preservedMM & mask) == 0) continue;
          idx = i;
          // The opposite.
          if ((preservedMM & mask) != 0) break;
        }
      }
    }
  }

  // --------------------------------------------------------------------------
  // [Spill]
  // --------------------------------------------------------------------------

  // If register is still not found, spill other variable.
  if (idx == INVALID_VALUE)
  {
    if (spillCandidate == NULL) spillCandidate = _getSpillCandidateMM();

    // Spill candidate not found?
    if (spillCandidate == NULL)
    {
      _compiler->setError(ERROR_NOT_ENOUGH_REGISTERS);
      return;
    }

L_Spill:

    // Prevented variables can't be spilled. _getSpillCandidate() never returns
    // prevented variables, but when jumping to L_spill it can happen.
    if (spillCandidate->workOffset == _currentOffset)
    {
      _compiler->setError(ERROR_REGISTERS_OVERLAP);
      return;
    }

    idx = spillCandidate->registerIndex;
    spillMMVar(spillCandidate);
  }

  // --------------------------------------------------------------------------
  // [Alloc]
  // --------------------------------------------------------------------------

  if (vdata->state == VARIABLE_STATE_MEMORY && (vflags & VARIABLE_ALLOC_READ) != 0)
  {
    emitLoadVar(vdata, idx);
  }

  // Update VarData.
  vdata->state = VARIABLE_STATE_REGISTER;
  vdata->registerIndex = idx;
  vdata->homeRegisterIndex = idx;

  // Update StateData.
  _allocatedVariable(vdata);
}

void CompilerContext::saveMMVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't save variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;
  emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->changed = false;
}

void CompilerContext::spillMMVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't spill variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;

  if (vdata->changed) emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->registerIndex = INVALID_VALUE;
  vdata->state = VARIABLE_STATE_MEMORY;
  vdata->changed = false;

  // Update StateData.
  _state.mm[idx] = NULL;
  _freedMMRegister(idx);
}

void CompilerContext::allocXMMVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW
{
  // Fix the regMask (0 or full bit-array means that any register may be used).
  if (regMask == 0) regMask = Util::maskUpToIndex(REG_NUM_XMM);
  regMask &= Util::maskUpToIndex(REG_NUM_XMM);

  // Working variables.
  uint32_t i;
  uint32_t mask;

  // Last register code (aka home).
  uint32_t home = vdata->homeRegisterIndex;
  // New register code.
  uint32_t idx = INVALID_VALUE;

  // Preserved XMM variables.
  uint32_t preservedXMM = vdata->scope->getPrototype().getPreservedXMM();

  // Spill candidate.
  VarData* spillCandidate = NULL;

  // Whether to alloc non-preserved first or last.
  bool nonPreservedFirst = true;
  if (this->getFunction()->_isCaller)
  {
    nonPreservedFirst = vdata->firstCallable == NULL || 
                        vdata->firstCallable->getOffset() >= vdata->lastEmittable->getOffset();
  }

  // --------------------------------------------------------------------------
  // [Already Allocated]
  // --------------------------------------------------------------------------

  // Go away if variable is already allocated.
  if (vdata->state == VARIABLE_STATE_REGISTER)
  {
    uint32_t oldIndex = vdata->registerIndex;

    // Already allocated in the right register.
    if (Util::maskFromIndex(oldIndex) & regMask) return;

    // Try to find unallocated register first.
    mask = regMask & ~_state.usedXMM;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedXMM) != 0) ? mask & ~preservedXMM : mask);
    }
    // Then find the allocated and later exchange.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedXMM);
    }
    ASMJIT_ASSERT(idx != INVALID_VALUE);

    VarData* other = _state.xmm[idx];
    if (other) spillXMMVar(other);

    emitMoveVar(vdata, idx, vflags);
    _freedXMMRegister(oldIndex);
    _state.xmm[idx] = vdata;

    // Update VarData.
    vdata->state = VARIABLE_STATE_REGISTER;
    vdata->registerIndex = idx;
    vdata->homeRegisterIndex = idx;

    _allocatedXMMRegister(idx);
    return;
  }

  // --------------------------------------------------------------------------
  // [Find Unused XMM]
  // --------------------------------------------------------------------------

  // If regMask contains restricted registers which may be used then everything
  // is handled in this block.
  if (regMask != Util::maskUpToIndex(REG_NUM_XMM))
  {
    // Try to find unallocated register first.
    mask = regMask & ~_state.usedXMM;
    if (mask != 0)
    {
      idx = Util::findFirstBit(
        (nonPreservedFirst && (mask & ~preservedXMM) != 0) ? mask & ~preservedXMM : mask);
      ASMJIT_ASSERT(idx != INVALID_VALUE);
    }
    // Then find the allocated and later spill.
    else
    {
      idx = Util::findFirstBit(regMask & _state.usedXMM);
      ASMJIT_ASSERT(idx != INVALID_VALUE);

      // Spill register we need.
      spillCandidate = _state.xmm[idx];

      // Jump to spill part of allocation.
      goto L_Spill;
    }
  }

  // Home register code.
  if (idx == INVALID_VALUE && home != INVALID_VALUE)
  {
    if ((_state.usedXMM & (1U << home)) == 0) idx = home;
  }

  if (idx == INVALID_VALUE)
  {
    for (i = 0, mask = (1 << i); i < REG_NUM_XMM; i++, mask <<= 1)
    {
      if ((_state.usedXMM & mask) == 0)
      {
        // Convenience to alloc non-preserved first or non-preserved last.
        if (nonPreservedFirst)
        {
          if (idx != INVALID_VALUE && (preservedXMM & mask) != 0) continue;
          idx = i;
          // If current register is preserved, we should try to find different
          // one that is not. This can save one push / pop in prolog / epilog.
          if ((preservedXMM & mask) == 0) break;
        }
        else
        {
          if (idx != INVALID_VALUE && (preservedXMM & mask) == 0) continue;
          idx = i;
          // The opposite.
          if ((preservedXMM & mask) != 0) break;
        }
      }
    }
  }

  // --------------------------------------------------------------------------
  // [Spill]
  // --------------------------------------------------------------------------

  // If register is still not found, spill other variable.
  if (idx == INVALID_VALUE)
  {
    if (spillCandidate == NULL) spillCandidate = _getSpillCandidateXMM();

    // Spill candidate not found?
    if (spillCandidate == NULL)
    {
      _compiler->setError(ERROR_NOT_ENOUGH_REGISTERS);
      return;
    }

L_Spill:

    // Prevented variables can't be spilled. _getSpillCandidate() never returns
    // prevented variables, but when jumping to L_spill it can happen.
    if (spillCandidate->workOffset == _currentOffset)
    {
      _compiler->setError(ERROR_REGISTERS_OVERLAP);
      return;
    }

    idx = spillCandidate->registerIndex;
    spillXMMVar(spillCandidate);
  }

  // --------------------------------------------------------------------------
  // [Alloc]
  // --------------------------------------------------------------------------

  if (vdata->state == VARIABLE_STATE_MEMORY && (vflags & VARIABLE_ALLOC_READ) != 0)
  {
    emitLoadVar(vdata, idx);
  }

  // Update VarData.
  vdata->state = VARIABLE_STATE_REGISTER;
  vdata->registerIndex = idx;
  vdata->homeRegisterIndex = idx;

  // Update StateData.
  _allocatedVariable(vdata);
}

void CompilerContext::saveXMMVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't save variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;
  emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->changed = false;
}

void CompilerContext::spillXMMVar(VarData* vdata) ASMJIT_NOTHROW
{
  // Can't spill variable that isn't allocated.
  ASMJIT_ASSERT(vdata->state == VARIABLE_STATE_REGISTER);
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  uint32_t idx = vdata->registerIndex;

  if (vdata->changed) emitSaveVar(vdata, idx);

  // Update VarData.
  vdata->registerIndex = INVALID_VALUE;
  vdata->state = VARIABLE_STATE_MEMORY;
  vdata->changed = false;

  // Update StateData.
  _state.xmm[idx] = NULL;
  _freedXMMRegister(idx);
}

void CompilerContext::emitLoadVar(VarData* vdata, uint32_t regIndex) ASMJIT_NOTHROW
{
  Mem m = _getVarMem(vdata);

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      _compiler->emit(INST_MOV, gpd(regIndex), m);
      if (_emitComments) goto addComment;
      break;
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      _compiler->emit(INST_MOV, gpq(regIndex), m);
      if (_emitComments) goto addComment;
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      _compiler->emit(INST_MOVQ, mm(regIndex), m);
      if (_emitComments) goto addComment;
      break;

    case VARIABLE_TYPE_XMM:
      _compiler->emit(INST_MOVDQA, xmm(regIndex), m);
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_1F:
      _compiler->emit(INST_MOVSS, xmm(regIndex), m);
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_1D:
      _compiler->emit(INST_MOVSD, xmm(regIndex), m);
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_4F:
      _compiler->emit(INST_MOVAPS, xmm(regIndex), m);
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_2D:
      _compiler->emit(INST_MOVAPD, xmm(regIndex), m);
      if (_emitComments) goto addComment;
      break;
  }
  return;

addComment:
  _compiler->getCurrentEmittable()->setCommentF("Alloc %s", vdata->name);
}

void CompilerContext::emitSaveVar(VarData* vdata, uint32_t regIndex) ASMJIT_NOTHROW
{
  // Caller must ensure that variable is allocated.
  ASMJIT_ASSERT(regIndex != INVALID_VALUE);

  Mem m = _getVarMem(vdata);

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      _compiler->emit(INST_MOV, m, gpd(regIndex));
      if (_emitComments) goto addComment;
      break;
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      _compiler->emit(INST_MOV, m, gpq(regIndex));
      if (_emitComments) goto addComment;
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      _compiler->emit(INST_MOVQ, m, mm(regIndex));
      if (_emitComments) goto addComment;
      break;

    case VARIABLE_TYPE_XMM:
      _compiler->emit(INST_MOVDQA, m, xmm(regIndex));
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_1F:
      _compiler->emit(INST_MOVSS, m, xmm(regIndex));
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_1D:
      _compiler->emit(INST_MOVSD, m, xmm(regIndex));
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_4F:
      _compiler->emit(INST_MOVAPS, m, xmm(regIndex));
      if (_emitComments) goto addComment;
      break;
    case VARIABLE_TYPE_XMM_2D:
      _compiler->emit(INST_MOVAPD, m, xmm(regIndex));
      if (_emitComments) goto addComment;
      break;
  }
  return;

addComment:
  _compiler->getCurrentEmittable()->setCommentF("Spill %s", vdata->name);
}

void CompilerContext::emitMoveVar(VarData* vdata, uint32_t regIndex, uint32_t vflags) ASMJIT_NOTHROW
{
  // Caller must ensure that variable is allocated.
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  if ((vflags & VARIABLE_ALLOC_READ) == 0) return;

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      _compiler->emit(INST_MOV, gpd(regIndex), gpd(vdata->registerIndex));
      break;
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      _compiler->emit(INST_MOV, gpq(regIndex), gpq(vdata->registerIndex));
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    case VARIABLE_TYPE_MM:
      _compiler->emit(INST_MOVQ, mm(regIndex), mm(vdata->registerIndex));
      break;

    case VARIABLE_TYPE_XMM:
      _compiler->emit(INST_MOVDQA, xmm(regIndex), xmm(vdata->registerIndex));
      break;
    case VARIABLE_TYPE_XMM_1F:
      _compiler->emit(INST_MOVSS, xmm(regIndex), xmm(vdata->registerIndex));
      break;
    case VARIABLE_TYPE_XMM_1D:
      _compiler->emit(INST_MOVSD, xmm(regIndex), xmm(vdata->registerIndex));
      break;
    case VARIABLE_TYPE_XMM_4F:
      _compiler->emit(INST_MOVAPS, xmm(regIndex), xmm(vdata->registerIndex));
      break;
    case VARIABLE_TYPE_XMM_2D:
      _compiler->emit(INST_MOVAPD, xmm(regIndex), xmm(vdata->registerIndex));
      break;
  }
}

void CompilerContext::emitExchangeVar(VarData* vdata, uint32_t regIndex, uint32_t vflags, VarData* other) ASMJIT_NOTHROW
{
  // Caller must ensure that variable is allocated.
  ASMJIT_ASSERT(vdata->registerIndex != INVALID_VALUE);

  // If other is not valid then we can just emit MOV (or other similar instruction).
  if (other == NULL)
  {
    emitMoveVar(vdata, regIndex, vflags);
    return;
  }

  // If we need to alloc for write-only operation then we can move other
  // variable away instead of exchanging them.
  if ((vflags & VARIABLE_ALLOC_READ) == 0)
  {
    emitMoveVar(other, vdata->registerIndex, VARIABLE_ALLOC_READ);
    return;
  }

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
      _compiler->emit(INST_XCHG, gpd(regIndex), gpd(vdata->registerIndex));
      break;
#if defined(ASMJIT_X64)
    case VARIABLE_TYPE_GPQ:
      _compiler->emit(INST_XCHG, gpq(regIndex), gpq(vdata->registerIndex));
      break;
#endif // ASMJIT_X64

    case VARIABLE_TYPE_X87:
    case VARIABLE_TYPE_X87_1F:
    case VARIABLE_TYPE_X87_1D:
      // TODO: X87 VARIABLES NOT IMPLEMENTED.
      break;

    // NOTE: MM and XMM registers shoudln't be exchanged using this way, it's
    // correct, but it sucks.

    case VARIABLE_TYPE_MM:
    {
      MMReg a = mm(regIndex);
      MMReg b = mm(vdata->registerIndex);

      _compiler->emit(INST_PXOR, a, b);
      _compiler->emit(INST_PXOR, b, a);
      _compiler->emit(INST_PXOR, a, b);
      break;
    }

    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_4F:
    {
      XMMReg a = xmm(regIndex);
      XMMReg b = xmm(vdata->registerIndex);

      _compiler->emit(INST_XORPS, a, b);
      _compiler->emit(INST_XORPS, b, a);
      _compiler->emit(INST_XORPS, a, b);
      break;
    }

    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_2D:
    {
      XMMReg a = xmm(regIndex);
      XMMReg b = xmm(vdata->registerIndex);

      _compiler->emit(INST_XORPD, a, b);
      _compiler->emit(INST_XORPD, b, a);
      _compiler->emit(INST_XORPD, a, b);
      break;
    }

    case VARIABLE_TYPE_XMM:
    {
      XMMReg a = xmm(regIndex);
      XMMReg b = xmm(vdata->registerIndex);

      _compiler->emit(INST_PXOR, a, b);
      _compiler->emit(INST_PXOR, b, a);
      _compiler->emit(INST_PXOR, a, b);
      break;
    }
  }
}

void CompilerContext::_postAlloc(VarData* vdata, uint32_t vflags) ASMJIT_NOTHROW
{
  if (vflags & VARIABLE_ALLOC_WRITE) vdata->changed = true;
}

void CompilerContext::_markMemoryUsed(VarData* vdata) ASMJIT_NOTHROW
{
  if (vdata->homeMemoryData != NULL) return;

  VarMemBlock* mem = _allocMemBlock(vdata->size);
  if (!mem) return;

  vdata->homeMemoryData = mem;
}

Mem CompilerContext::_getVarMem(VarData* vdata) ASMJIT_NOTHROW
{
  Mem m;
  m._mem.id = vdata->id;
  if (!vdata->isMemArgument) m._mem.displacement = _adjustESP;

  _markMemoryUsed(vdata);
  return m;
}

static int32_t getSpillScore(VarData* v, uint32_t currentOffset)
{
  int32_t score = 0;

  ASMJIT_ASSERT(v->lastEmittable != NULL);
  uint32_t lastOffset = v->lastEmittable->getOffset();

  if (lastOffset >= currentOffset)
    score += (int32_t)(lastOffset - currentOffset);

  // Each write access decreases probability of spill.
  score -= (int32_t)v->registerWriteCount + (int32_t)v->registerRWCount;
  // Each read-only access increases probability of spill.
  score += (int32_t)v->registerReadCount;

  // Each memory access increases probability of spill.
  score += (int32_t)v->memoryWriteCount + (int32_t)v->memoryRWCount;
  score += (int32_t)v->memoryReadCount;

  return score;
}

VarData* CompilerContext::_getSpillCandidateGP() ASMJIT_NOTHROW
{
  return _getSpillCandidateGeneric(_state.gp, REG_NUM_GP);
}

VarData* CompilerContext::_getSpillCandidateMM() ASMJIT_NOTHROW
{
  return _getSpillCandidateGeneric(_state.mm, REG_NUM_MM);
}

VarData* CompilerContext::_getSpillCandidateXMM() ASMJIT_NOTHROW
{
  return _getSpillCandidateGeneric(_state.xmm, REG_NUM_XMM);
}

VarData* CompilerContext::_getSpillCandidateGeneric(VarData** varArray, uint32_t count) ASMJIT_NOTHROW
{
  uint32_t i;

  VarData* candidate = NULL;
  uint32_t candidatePriority = 0;
  int32_t candidateScore = 0;

  uint32_t currentOffset = _compiler->getCurrentEmittable()->getOffset();

  for (i = 0; i < count; i++)
  {
    // Get variable.
    VarData* vdata = varArray[i];

    // Never spill variables needed for next instruction.
    if (vdata == NULL || vdata->workOffset == _currentOffset) continue;

    uint32_t variablePriority = vdata->priority;
    int32_t variableScore = getSpillScore(vdata, currentOffset);

    if ((candidate == NULL) ||
        (variablePriority > candidatePriority) ||
        (variablePriority == candidatePriority && variableScore > candidateScore))
    {
      candidate = vdata;
      candidatePriority = variablePriority;
      candidateScore = variableScore;
    }
  }

  return candidate;
}

void CompilerContext::_addActive(VarData* vdata) ASMJIT_NOTHROW
{
  // Never call with variable that is already in active list.
  ASMJIT_ASSERT(vdata->nextActive == NULL);
  ASMJIT_ASSERT(vdata->prevActive == NULL);

  if (_active == NULL)
  {
    vdata->nextActive = vdata;
    vdata->prevActive = vdata;

    _active = vdata;
  }
  else
  {
    VarData* vlast = _active->prevActive;

    vlast->nextActive = vdata;
    _active->prevActive = vdata;

    vdata->nextActive = _active;
    vdata->prevActive = vlast;
  }
}

void CompilerContext::_freeActive(VarData* vdata) ASMJIT_NOTHROW
{
  VarData* next = vdata->nextActive;
  VarData* prev = vdata->prevActive;

  if (prev == next)
  {
    _active = NULL;
  }
  else
  {
    if (_active == vdata) _active = next;
    prev->nextActive = next;
    next->prevActive = prev;
  }

  vdata->nextActive = NULL;
  vdata->prevActive = NULL;
}

void CompilerContext::_freeAllActive() ASMJIT_NOTHROW
{
  if (_active == NULL) return;

  VarData* cur = _active;
  for (;;)
  {
    VarData* next = cur->nextActive;
    cur->nextActive = NULL;
    cur->prevActive = NULL;
    if (next == _active) break;
  }

  _active = NULL;
}

void CompilerContext::_allocatedVariable(VarData* vdata) ASMJIT_NOTHROW
{
  uint32_t idx = vdata->registerIndex;

  switch (vdata->type)
  {
    case VARIABLE_TYPE_GPD:
    case VARIABLE_TYPE_GPQ:
      _state.gp[idx] = vdata;
      _allocatedGPRegister(idx);
      break;

    case VARIABLE_TYPE_MM:
      _state.mm[idx] = vdata;
      _allocatedMMRegister(idx);
      break;

    case VARIABLE_TYPE_XMM:
    case VARIABLE_TYPE_XMM_1F:
    case VARIABLE_TYPE_XMM_4F:
    case VARIABLE_TYPE_XMM_1D:
    case VARIABLE_TYPE_XMM_2D:
      _state.xmm[idx] = vdata;
      _allocatedXMMRegister(idx);
      break;

    default:
      ASMJIT_ASSERT(0);
      break;
  }
}

void CompilerContext::translateOperands(Operand* operands, uint32_t count) ASMJIT_NOTHROW
{
  uint32_t i;

  // Translate variables to registers.
  for (i = 0; i < count; i++)
  {
    Operand& o = operands[i];

    if (o.isVar())
    {
      VarData* vdata = _compiler->_getVarData(o.getId());
      ASMJIT_ASSERT(vdata != NULL);

      o._reg.op = OPERAND_REG;
      o._reg.code |= vdata->registerIndex;
    }
    else if (o.isMem())
    {
      if ((o.getId() & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        // Memory access. We just increment here actual displacement.
        VarData* vdata = _compiler->_getVarData(o.getId());
        ASMJIT_ASSERT(vdata != NULL);

        o._mem.displacement += vdata->isMemArgument
          ? _argumentsActualDisp
          : _variablesActualDisp;
        // NOTE: This is not enough, variable position will be patched later
        // by CompilerContext::_patchMemoryOperands().
      }
      else if ((o._mem.base & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.base);
        ASMJIT_ASSERT(vdata != NULL);

        o._mem.base = vdata->registerIndex;
      }

      if ((o._mem.index & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(o._mem.index);
        ASMJIT_ASSERT(vdata != NULL);

        o._mem.index = vdata->registerIndex;
      }
    }
  }
}

void CompilerContext::addBackwardCode(EJmp* from) ASMJIT_NOTHROW
{
  _backCode.append(from);
}

void CompilerContext::addForwardJump(EJmp* inst) ASMJIT_NOTHROW
{
  ForwardJumpData* j =
    reinterpret_cast<ForwardJumpData*>(_zone.zalloc(sizeof(ForwardJumpData)));
  if (j == NULL) { _compiler->setError(ERROR_NO_HEAP_MEMORY); return; }

  j->inst = inst;
  j->state = _saveState();
  j->next = _forwardJumps;
  _forwardJumps = j;
}

StateData* CompilerContext::_saveState() ASMJIT_NOTHROW
{
  // Get count of variables stored in memory.
  uint32_t memVarsCount = 0;
  VarData* cur = _active;
  if (cur)
  {
    do {
      if (cur->state == VARIABLE_STATE_MEMORY) memVarsCount++;
      cur = cur->nextActive;
    } while (cur != _active);
  }

  // Alloc StateData structure (using zone allocator) and copy current state into it.
  StateData* state = _compiler->_newStateData(memVarsCount);
  memcpy(state, &_state, sizeof(StateData));

  // Clear changed flags.
  state->changedGP = 0;
  state->changedMM = 0;
  state->changedXMM = 0;

  uint i;
  uint mask;

  // Save variables stored in REGISTERs and CHANGE flag.
  for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
  {
    if (state->gp[i] && state->gp[i]->changed) state->changedGP |= mask;
  }

  for (i = 0, mask = 1; i < REG_NUM_MM; i++, mask <<= 1)
  {
    if (state->mm[i] && state->mm[i]->changed) state->changedMM |= mask;
  }

  for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
  {
    if (state->xmm[i] && state->xmm[i]->changed) state->changedXMM |= mask;
  }

  // Save variables stored in MEMORY.
  state->memVarsCount = memVarsCount;
  memVarsCount = 0;

  cur = _active;
  if (cur)
  {
    do {
      if (cur->state == VARIABLE_STATE_MEMORY) state->memVarsData[memVarsCount++] = cur;
      cur = cur->nextActive;
    } while (cur != _active);
  }

  // Finished.
  return state;
}

void CompilerContext::_assignState(StateData* state) ASMJIT_NOTHROW
{
  Compiler* compiler = getCompiler();

  memcpy(&_state, state, sizeof(StateData));
  _state.memVarsCount = 0;

  uint i, mask;
  VarData* vdata;

  // Unuse all variables first.
  vdata = _active;
  if (vdata)
  {
    do {
      vdata->state = VARIABLE_STATE_UNUSED;
      vdata = vdata->nextActive;
    } while (vdata != _active);
  }

  // Assign variables stored in memory which are not unused.
  for (i = 0; i < state->memVarsCount; i++)
  {
    state->memVarsData[i]->state = VARIABLE_STATE_MEMORY;
  }

  // Assign allocated variables.
  for (i = 0, mask = 1; i < REG_NUM_GP; i++, mask <<= 1)
  {
    if ((vdata = _state.gp[i]) != NULL)
    {
      vdata->state = VARIABLE_STATE_REGISTER;
      vdata->registerIndex = i;
      vdata->changed = (_state.changedGP & mask) != 0;
    }
  }

  for (i = 0, mask = 1; i < REG_NUM_MM; i++, mask <<= 1)
  {
    if ((vdata = _state.mm[i]) != NULL)
    {
      vdata->state = VARIABLE_STATE_REGISTER;
      vdata->registerIndex = i;
      vdata->changed = (_state.changedMM & mask) != 0;
    }
  }

  for (i = 0, mask = 1; i < REG_NUM_XMM; i++, mask <<= 1)
  {
    if ((vdata = _state.xmm[i]) != NULL)
    {
      vdata->state = VARIABLE_STATE_REGISTER;
      vdata->registerIndex = i;
      vdata->changed = (_state.changedXMM & mask) != 0;
    }
  }
}

void CompilerContext::_restoreState(StateData* state, uint32_t targetOffset) ASMJIT_NOTHROW
{
  // 16 + 8 + 16 = GP + MMX + XMM registers.
  static const uint STATE_REGS_COUNT = 16 + 8 + 16;

  StateData* fromState = &_state;
  StateData* toState = state;

  // No change, rare...
  if (fromState == toState) return;

  uint base;
  uint i;

  // --------------------------------------------------------------------------
  // Set target state to all variables. vdata->tempInt is target state in this
  // function.
  // --------------------------------------------------------------------------

  {
    // UNUSED.
    VarData* vdata = _active;
    if (vdata)
    {
      do {
        vdata->tempInt = VARIABLE_STATE_UNUSED;
        vdata = vdata->nextActive;
      } while (vdata != _active);
    }

    // MEMORY.
    for (i = 0; i < toState->memVarsCount; i++)
    {
      toState->memVarsData[i]->tempInt = VARIABLE_STATE_MEMORY;
    }

    // REGISTER.
    for (i = 0; i < StateData::NUM_REGS; i++)
    {
      if ((vdata = toState->regs[i]) != NULL) vdata->tempInt = VARIABLE_STATE_REGISTER;
    }
  }

  // --------------------------------------------------------------------------
  // [GP-Registers Switch]
  // --------------------------------------------------------------------------

  // TODO.
#if 0
  for (i = 0; i < REG_NUM_GP; i++)
  {
    VarData* fromVar = fromState->gp[i];
    VarData* toVar = toState->gp[i];

    if (fromVar != toVar)
    {
      if (fromVar != NULL)
      {
        if (toVar != NULL)
        {
          if (fromState->gp[to
        }
        else
        {
          // It is possible that variable that was saved in state currently not
          // exists (tempInt is target scope!).
          if (fromVar->tempInt == VARIABLE_STATE_UNUSED)
          {
            unuseVar(fromVar, VARIABLE_STATE_UNUSED);
          }
          else
          {
            spillVar(fromVar);
          }
        }
      }
    }
    else if (fromVar != NULL)
    {
      uint32_t mask = Util::maskFromIndex(i);
      // Variables are the same, we just need to compare changed flags.
      if ((fromState->changedGP & mask) && !(toState->changedGP & mask)) saveVar(fromVar);
    }
  }
#endif

  // Spill.
  for (base = 0, i = 0; i < STATE_REGS_COUNT; i++)
  {
    // Change the base offset (from base offset the register index can be
    // calculated).
    if (i == 16 || i == 16 + 8) base = i;
    uint32_t regIndex = i - base;

    VarData* fromVar = fromState->regs[i];
    VarData* toVar = toState->regs[i];

    if (fromVar != toVar)
    {

      // Spill the register.
      if (fromVar != NULL)
      {
        // It is possible that variable that was saved in state currently not
        // exists (tempInt is target scope!).
        if (fromVar->tempInt == VARIABLE_STATE_UNUSED)
        {
          unuseVar(fromVar, VARIABLE_STATE_UNUSED);
        }
        else
        {
          spillVar(fromVar);
        }
      }
    }
    else if (fromVar != NULL)
    {
      uint32_t mask = Util::maskFromIndex(regIndex);
      // Variables are the same, we just need to compare changed flags.
      if ((fromState->changedGP & mask) && !(toState->changedGP & mask))
      {
        saveVar(fromVar);
      }
    }
  }

  // Alloc.
  for (base = 0, i = 0; i < STATE_REGS_COUNT; i++)
  {
    if (i == 16 || i == 24) base = i;

    VarData* fromVar = fromState->regs[i];
    VarData* toVar = toState->regs[i];

    if (fromVar != toVar)
    {
      uint32_t regIndex = i - base;

      // Alloc register
      if (toVar != NULL)
      {
        allocVar(toVar, Util::maskFromIndex(regIndex), VARIABLE_ALLOC_READ);
      }
    }

    // TODO:
    //if (toVar)
    //{
      // toVar->changed = to->changed;
    //}
  }

  // --------------------------------------------------------------------------
  // Update used masks.
  // --------------------------------------------------------------------------

  _state.usedGP = state->usedGP;
  _state.usedMM = state->usedMM;
  _state.usedXMM = state->usedXMM;

  // --------------------------------------------------------------------------
  // Update changed masks and cleanup.
  // --------------------------------------------------------------------------

  {
    VarData* vdata = _active;
    if (vdata)
    {
      do {
        if (vdata->tempInt != VARIABLE_STATE_REGISTER)
        {
          vdata->state = (int)vdata->tempInt;
          vdata->changed = false;
        }

        vdata->tempInt = 0;
        vdata = vdata->nextActive;
      } while (vdata != _active);
    }
  }
}

VarMemBlock* CompilerContext::_allocMemBlock(uint32_t size) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(size != 0);

  // First try to find mem blocks.
  VarMemBlock* mem = _memFree;
  VarMemBlock* prev = NULL;

  while (mem)
  {
    VarMemBlock* next = mem->nextFree;

    if (mem->size == size)
    {
      if (prev)
        prev->nextFree = next;
      else
        _memFree = next;

      mem->nextFree = NULL;
      return mem;
    }

    prev = mem;
    mem = next;
  }

  // Never mind, create new.
  mem = reinterpret_cast<VarMemBlock*>(_zone.zalloc(sizeof(VarMemBlock)));
  if (!mem)
  {
    _compiler->setError(ERROR_NO_HEAP_MEMORY);
    return NULL;
  }

  mem->offset = 0;
  mem->size = size;

  mem->nextUsed = _memUsed;
  mem->nextFree = NULL;

  _memUsed = mem;

  switch (size)
  {
    case 16: _mem16BlocksCount++; break;
    case 8: _mem8BlocksCount++; break;
    case 4: _mem4BlocksCount++; break;
  }

  return mem;
}

void CompilerContext::_freeMemBlock(VarMemBlock* mem) ASMJIT_NOTHROW
{
  // Add mem to free blocks.
  mem->nextFree = _memFree;
  _memFree = mem;
}

void CompilerContext::_allocMemoryOperands() ASMJIT_NOTHROW
{
  VarMemBlock* mem;

  // Variables are allocated in this order:
  // 1. 16-byte variables.
  // 2. 8-byte variables.
  // 3. 4-byte variables.
  // 4. All others.

  uint32_t start16 = 0;
  uint32_t start8 = start16 + _mem16BlocksCount * 16;
  uint32_t start4 = start8 + _mem8BlocksCount * 8;
  uint32_t startX = (start4 + _mem4BlocksCount * 4 + 15) & ~15;

  for (mem = _memUsed; mem; mem = mem->nextUsed)
  {
    uint32_t size = mem->size;
    uint32_t offset;

    switch (size)
    {
      case 16:
        offset = start16;
        start16 += 16;
        break;

      case 8:
        offset = start8;
        start8 += 8;
        break;

      case 4:
        offset = start4;
        start4 += 4;
        break;

      default:
        // Align to 16 bytes if size is 16 or more.
        if (size >= 16)
        {
          size = (size + 15) & ~15;
          startX = (startX + 15) & ~15;
        }
        offset = startX;
        startX += size;
        break;
    }

    mem->offset = (int32_t)offset;
    _memBytesTotal += size;
  }
}

void CompilerContext::_patchMemoryOperands(Emittable* start, Emittable* stop) ASMJIT_NOTHROW
{
  Emittable* cur;

  for (cur = start;; cur = cur->getNext())
  {
    if (cur->getType() == EMITTABLE_INSTRUCTION)
    {
      Mem* mem = reinterpret_cast<EInstruction*>(cur)->_memOp;

      if (mem && (mem->_mem.id & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_VAR)
      {
        VarData* vdata = _compiler->_getVarData(mem->_mem.id);
        ASMJIT_ASSERT(vdata != NULL);

        if (vdata->isMemArgument)
        {
          mem->_mem.base = _argumentsBaseReg;
          mem->_mem.displacement += vdata->homeMemoryOffset;
          mem->_mem.displacement += _argumentsBaseOffset;
        }
        else
        {
          VarMemBlock* mb = reinterpret_cast<VarMemBlock*>(vdata->homeMemoryData);
          ASMJIT_ASSERT(mb != NULL);

          mem->_mem.base = _variablesBaseReg;
          mem->_mem.displacement += mb->offset;
          mem->_mem.displacement += _variablesBaseOffset;
        }
      }
    }
    if (cur == stop) break;
  }
}

// ============================================================================
// [AsmJit::CompilerUtil]
// ============================================================================

bool CompilerUtil::isStack16ByteAligned()
{
  // Stack is always aligned to 16-bytes when using 64-bit OS.
  bool result = (sizeof(sysuint_t) == 8);

  // Modern Linux, APPLE and UNIX guarantees stack alignment to 16 bytes by
  // default. I'm really not sure about all UNIX operating systems, because
  // 16-byte alignment is an addition to the older specification.
#if (defined(__linux__)   || \
     defined(__linux)     || \
     defined(linux)       || \
     defined(__unix__)    || \
     defined(__FreeBSD__) || \
     defined(__NetBSD__)  || \
     defined(__OpenBSD__) || \
     defined(__DARWIN__)  || \
     defined(__APPLE__)   )
  result = true;
#endif // __linux__

  return result;
}

// ============================================================================
// [AsmJit::CompilerCore - Construction / Destruction]
// ============================================================================

CompilerCore::CompilerCore(CodeGenerator* codeGenerator) ASMJIT_NOTHROW :
  _zone(16384 - sizeof(Zone::Chunk) - 32),
  _codeGenerator(codeGenerator != NULL ? codeGenerator : CodeGenerator::getGlobal()),
  _logger(NULL),
  _error(0),
  _properties((1 << PROPERTY_OPTIMIZE_ALIGN)),
  _emitOptions(0),
  _finished(false),
  _first(NULL),
  _last(NULL),
  _current(NULL),
  _function(NULL),
  _varNameId(0),
  _cc(NULL)
{
}

CompilerCore::~CompilerCore() ASMJIT_NOTHROW
{
  free();
}

// ============================================================================
// [AsmJit::CompilerCore - Logging]
// ============================================================================

void CompilerCore::setLogger(Logger* logger) ASMJIT_NOTHROW
{
  _logger = logger;
}

// ============================================================================
// [AsmJit::CompilerCore - Error Handling]
// ============================================================================

void CompilerCore::setError(uint32_t error) ASMJIT_NOTHROW
{
  _error = error;
  if (_error == ERROR_NONE) return;

  if (_logger)
  {
    _logger->logFormat("*** COMPILER ERROR: %s (%u).\n",
      getErrorString(error),
      (unsigned int)error);
  }
}

// ============================================================================
// [AsmJit::CompilerCore - Properties]
// ============================================================================

uint32_t CompilerCore::getProperty(uint32_t propertyId)
{
  return (_properties & (1 << propertyId)) != 0;
}

void CompilerCore::setProperty(uint32_t propertyId, uint32_t value)
{
  if (value)
    _properties |= (1 << propertyId);
  else
    _properties &= ~(1 << propertyId);
}

// ============================================================================
// [AsmJit::CompilerCore - Buffer]
// ============================================================================

void CompilerCore::clear() ASMJIT_NOTHROW
{
  _finished = false;

  delAll(_first);
  _first = NULL;
  _last = NULL;
  _current = NULL;

  _zone.freeAll();
  _targetData.clear();
  _varData.clear();

  _cc = NULL;

  if (_error) setError(ERROR_NONE);
}

void CompilerCore::free() ASMJIT_NOTHROW
{
  clear();

  _targetData.free();
  _varData.free();
}

// ============================================================================
// [AsmJit::CompilerCore - Emittables]
// ============================================================================

void CompilerCore::addEmittable(Emittable* emittable) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(emittable != NULL);
  ASMJIT_ASSERT(emittable->_prev == NULL);
  ASMJIT_ASSERT(emittable->_next == NULL);

  if (_current == NULL)
  {
    if (!_first)
    {
      _first = emittable;
      _last = emittable;
    }
    else
    {
      emittable->_next = _first;
      _first->_prev = emittable;
      _first = emittable;
    }
  }
  else
  {
    Emittable* prev = _current;
    Emittable* next = _current->_next;

    emittable->_prev = prev;
    emittable->_next = next;

    prev->_next = emittable;
    if (next)
      next->_prev = emittable;
    else
      _last = emittable;
  }

  _current = emittable;
}

void CompilerCore::addEmittableAfter(Emittable* emittable, Emittable* ref) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(emittable != NULL);
  ASMJIT_ASSERT(emittable->_prev == NULL);
  ASMJIT_ASSERT(emittable->_next == NULL);
  ASMJIT_ASSERT(ref != NULL);

  Emittable* prev = ref;
  Emittable* next = ref->_next;

  emittable->_prev = prev;
  emittable->_next = next;

  prev->_next = emittable;
  if (next)
    next->_prev = emittable;
  else
    _last = emittable;
}

void CompilerCore::removeEmittable(Emittable* emittable) ASMJIT_NOTHROW
{
  Emittable* prev = emittable->_prev;
  Emittable* next = emittable->_next;

  if (_first == emittable) { _first = next; } else { prev->_next = next; }
  if (_last  == emittable) { _last  = prev; } else { next->_prev = prev; }

  emittable->_prev = NULL;
  emittable->_next = NULL;

  if (emittable == _current) _current = prev;
}

Emittable* CompilerCore::setCurrentEmittable(Emittable* current) ASMJIT_NOTHROW
{
  Emittable* old = _current;
  _current = current;
  return old;
}

// ============================================================================
// [AsmJit::CompilerCore - Logging]
// ============================================================================

void CompilerCore::comment(const char* fmt, ...) ASMJIT_NOTHROW
{
  char buf[128];
  char* p = buf;

  if (fmt)
  {
    *p++ = ';';
    *p++ = ' ';

    va_list ap;
    va_start(ap, fmt);
    p += vsnprintf(p, 100, fmt, ap);
    va_end(ap);
  }

  *p++ = '\n';
  *p   = '\0';

  addEmittable(Compiler_newObject<EComment>(this, buf));
}

// ============================================================================
// [AsmJit::CompilerCore - Function Builder]
// ============================================================================

EFunction* CompilerCore::newFunction_(
  uint32_t callingConvention,
  const uint32_t* arguments,
  uint32_t argumentsCount,
  uint32_t returnValue) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(_function == NULL);
  EFunction* f = _function = Compiler_newObject<EFunction>(this);

  f->setPrototype(callingConvention, arguments, argumentsCount, returnValue);
  addEmittable(f);

  bind(f->_entryLabel);
  addEmittable(f->_prolog);

  _varNameId = 0;

  f->_createVariables();
  return f;
}

EFunction* CompilerCore::endFunction() ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(_function != NULL);
  EFunction* f = _function;

  bind(f->_exitLabel);
  addEmittable(f->_epilog);
  addEmittable(f->_end);

  f->_finished = true;
  _function = NULL;

  return f;
}

// ============================================================================
// [AsmJit::CompilerCore - EmitInstruction]
// ============================================================================

void CompilerCore::_emitInstruction(uint32_t code) ASMJIT_NOTHROW
{
  EInstruction* e = newInstruction(code, NULL, 0);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitInstruction(uint32_t code, const Operand* o0) ASMJIT_NOTHROW
{
  Operand* operands = reinterpret_cast<Operand*>(_zone.zalloc(1 * sizeof(Operand)));
  if (!operands) return;

  operands[0] = *o0;

  EInstruction* e = newInstruction(code, operands, 1);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1) ASMJIT_NOTHROW
{
  Operand* operands = reinterpret_cast<Operand*>(_zone.zalloc(2 * sizeof(Operand)));
  if (!operands) return;

  operands[0] = *o0;
  operands[1] = *o1;

  EInstruction* e = newInstruction(code, operands, 2);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2) ASMJIT_NOTHROW
{
  Operand* operands = reinterpret_cast<Operand*>(_zone.zalloc(3 * sizeof(Operand)));
  if (!operands) return;

  operands[0] = *o0;
  operands[1] = *o1;
  operands[2] = *o2;

  EInstruction* e = newInstruction(code, operands, 3);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2, const Operand* o3) ASMJIT_NOTHROW
{
  Operand* operands = reinterpret_cast<Operand*>(_zone.zalloc(4 * sizeof(Operand)));
  if (!operands) return;

  operands[0] = *o0;
  operands[1] = *o1;
  operands[2] = *o2;
  operands[3] = *o3;

  EInstruction* e = newInstruction(code, operands, 4);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2, const Operand* o3, const Operand* o4) ASMJIT_NOTHROW
{
  Operand* operands = reinterpret_cast<Operand*>(_zone.zalloc(5 * sizeof(Operand)));
  if (!operands) return;

  operands[0] = *o0;
  operands[1] = *o1;
  operands[2] = *o2;
  operands[3] = *o3;
  operands[4] = *o4;

  EInstruction* e = newInstruction(code, operands, 5);
  if (!e) return;

  addEmittable(e);
  if (_cc) { e->_offset = _cc->_currentOffset; e->prepare(*_cc); }
}

void CompilerCore::_emitJcc(uint32_t code, const Label* label, uint32_t hint) ASMJIT_NOTHROW
{
  if (!hint)
  {
    _emitInstruction(code, label);
  }
  else
  {
    Imm imm(hint);
    _emitInstruction(code, label, &imm);
  }
}

ECall* CompilerCore::_emitCall(const Operand* o0) ASMJIT_NOTHROW
{
  EFunction* fn = getFunction();
  if (!fn) { setError(ERROR_NO_FUNCTION); return NULL; }

  ECall* eCall = Compiler_newObject<ECall>(this, fn, o0);
  if (!eCall) { setError(ERROR_NO_HEAP_MEMORY); return NULL; }

  addEmittable(eCall);
  return eCall;
}

void CompilerCore::_emitReturn(const Operand* first, const Operand* second) ASMJIT_NOTHROW
{
  EFunction* fn = getFunction();
  if (!fn) { setError(ERROR_NO_FUNCTION); return; }

  ERet* eRet = Compiler_newObject<ERet>(this, fn, first, second);
  if (!eRet) { setError(ERROR_NO_HEAP_MEMORY); return; }

  addEmittable(eRet);
}

// ============================================================================
// [AsmJit::CompilerCore - Embed]
// ============================================================================

void CompilerCore::embed(const void* data, sysuint_t size) ASMJIT_NOTHROW
{
  // Align length to 16 bytes.
  sysuint_t alignedSize = (size + 15) & ~15;

  EData* e =
    new(_zone.zalloc(sizeof(EData) - sizeof(void*) + alignedSize))
      EData(reinterpret_cast<Compiler*>(this), data, size);
  addEmittable(e);
}

// ============================================================================
// [AsmJit::CompilerCore - Align]
// ============================================================================

void CompilerCore::align(uint32_t m) ASMJIT_NOTHROW
{
  addEmittable(Compiler_newObject<EAlign>(this, m));
}

// ============================================================================
// [AsmJit::CompilerCore - Label]
// ============================================================================

Label CompilerCore::newLabel() ASMJIT_NOTHROW
{
  Label label;
  label._base.id = (uint32_t)_targetData.getLength() | OPERAND_ID_TYPE_LABEL;

  ETarget* target = Compiler_newObject<ETarget>(this, label);
  _targetData.append(target);

  return label;
}

void CompilerCore::bind(const Label& label) ASMJIT_NOTHROW
{
  uint32_t id = label.getId() & OPERAND_ID_VALUE_MASK;
  ASMJIT_ASSERT(id != INVALID_VALUE);
  ASMJIT_ASSERT(id < _targetData.getLength());

  addEmittable(_targetData[id]);
}

// ============================================================================
// [AsmJit::CompilerCore - Variables]
// ============================================================================

VarData* CompilerCore::_newVarData(const char* name, uint32_t type, uint32_t size) ASMJIT_NOTHROW
{
  VarData* vdata = reinterpret_cast<VarData*>(_zone.zalloc(sizeof(VarData)));
  if (vdata == NULL) return NULL;

  char nameBuffer[32];
  if (name == NULL)
  {
    sprintf(nameBuffer, "var_%d", _varNameId);
    name = nameBuffer;
    _varNameId++;
  }

  vdata->scope = getFunction();
  vdata->firstEmittable = NULL;
  vdata->firstCallable = NULL;
  vdata->lastEmittable = NULL;

  vdata->name = _zone.zstrdup(name);
  vdata->id = (uint32_t)_varData.getLength() | OPERAND_ID_TYPE_VAR;
  vdata->type = type;
  vdata->size = size;

  vdata->homeRegisterIndex = INVALID_VALUE;
  vdata->prefRegisterMask = 0;

  vdata->homeMemoryData = NULL;

  vdata->registerIndex = INVALID_VALUE;
  vdata->workOffset = INVALID_VALUE;

  vdata->nextActive = NULL;
  vdata->prevActive = NULL;

  vdata->priority = 10;
  vdata->calculated = false;
  vdata->isRegArgument = false;
  vdata->isMemArgument = false;

  vdata->state = VARIABLE_STATE_UNUSED;
  vdata->changed = false;
  vdata->saveOnUnuse = false;

  vdata->registerReadCount = 0;
  vdata->registerWriteCount = 0;
  vdata->registerRWCount = 0;

  vdata->registerGPBLoCount = 0;
  vdata->registerGPBHiCount = 0;

  vdata->memoryReadCount = 0;
  vdata->memoryWriteCount = 0;
  vdata->memoryRWCount = 0;

  vdata->tempPtr = NULL;

  _varData.append(vdata);
  return vdata;
}

GPVar CompilerCore::newGP(uint32_t variableType, const char* name) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT((variableType < _VARIABLE_TYPE_COUNT) &&
                (variableInfo[variableType].clazz & VariableInfo::CLASS_GP) != 0);

#if defined(ASMJIT_X86)
  if (variableInfo[variableType].size > 4)
  {
    variableType = VARIABLE_TYPE_GPD;
    if (_logger)
    {
      _logger->logString("*** COMPILER WARNING: Translated QWORD variable to DWORD, FIX YOUR CODE! ***\n");
    }
  }
#endif // ASMJIT_X86

  VarData* vdata = _newVarData(name, variableType, variableInfo[variableType].size);
  return GPVarFromData(vdata);
}

GPVar CompilerCore::argGP(uint32_t index) ASMJIT_NOTHROW
{
  GPVar var;
  EFunction* f = getFunction();

  if (f)
  {
    const FunctionPrototype& prototype = f->getPrototype();
    if (index < prototype.getArgumentsCount())
    {
      VarData* vdata = getFunction()->_argumentVariables[index];

      var._var.id = vdata->id;
      var._var.size = vdata->size;
      var._var.registerCode = variableInfo[vdata->type].code;
      var._var.variableType = vdata->type;
    }
  }

  return var;
}

MMVar CompilerCore::newMM(uint32_t variableType, const char* name) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT((variableType < _VARIABLE_TYPE_COUNT) &&
                (variableInfo[variableType].clazz & VariableInfo::CLASS_MM) != 0);

  VarData* vdata = _newVarData(name, variableType, 8);
  return MMVarFromData(vdata);
}

MMVar CompilerCore::argMM(uint32_t index) ASMJIT_NOTHROW
{
  MMVar var;
  EFunction* f = getFunction();

  if (f)
  {
    const FunctionPrototype& prototype = f->getPrototype();
    if (index < prototype.getArgumentsCount())
    {
      VarData* vdata = getFunction()->_argumentVariables[index];

      var._var.id = vdata->id;
      var._var.size = vdata->size;
      var._var.registerCode = variableInfo[vdata->type].code;
      var._var.variableType = vdata->type;
    }
  }

  return var;
}

XMMVar CompilerCore::newXMM(uint32_t variableType, const char* name) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT((variableType < _VARIABLE_TYPE_COUNT) &&
                (variableInfo[variableType].clazz & VariableInfo::CLASS_XMM) != 0);

  VarData* vdata = _newVarData(name, variableType, 16);
  return XMMVarFromData(vdata);
}

XMMVar CompilerCore::argXMM(uint32_t index) ASMJIT_NOTHROW
{
  XMMVar var;
  EFunction* f = getFunction();

  if (f)
  {
    const FunctionPrototype& prototype = f->getPrototype();
    if (index < prototype.getArgumentsCount())
    {
      VarData* vdata = getFunction()->_argumentVariables[index];

      var._var.id = vdata->id;
      var._var.size = vdata->size;
      var._var.registerCode = variableInfo[vdata->type].code;
      var._var.variableType = vdata->type;
    }
  }

  return var;
}

void CompilerCore::_vhint(BaseVar& var, uint32_t hintId, uint32_t hintValue) ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  EVariableHint* e = Compiler_newObject<EVariableHint>(this, vdata, hintId, hintValue);
  addEmittable(e);
}

void CompilerCore::alloc(BaseVar& var) ASMJIT_NOTHROW
{
  _vhint(var, VARIABLE_HINT_ALLOC, INVALID_VALUE);
}

void CompilerCore::alloc(BaseVar& var, uint32_t regIndex) ASMJIT_NOTHROW
{
  if (regIndex > 31)
    return;

  _vhint(var, VARIABLE_HINT_ALLOC, 1 << regIndex);
}

void CompilerCore::alloc(BaseVar& var, const BaseReg& reg) ASMJIT_NOTHROW
{
  _vhint(var, VARIABLE_HINT_ALLOC, 1 << reg.getRegIndex());
}

void CompilerCore::save(BaseVar& var) ASMJIT_NOTHROW
{
  _vhint(var, VARIABLE_HINT_SAVE, INVALID_VALUE);
}

void CompilerCore::spill(BaseVar& var) ASMJIT_NOTHROW
{
  _vhint(var, VARIABLE_HINT_SPILL, INVALID_VALUE);
}

void CompilerCore::unuse(BaseVar& var) ASMJIT_NOTHROW
{
  _vhint(var, VARIABLE_HINT_UNUSE, INVALID_VALUE);
}

uint32_t CompilerCore::getPriority(BaseVar& var) const ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return INVALID_VALUE;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  return vdata->priority;
}

void CompilerCore::setPriority(BaseVar& var, uint32_t priority) ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  if (priority > 100) priority = 100;
  vdata->priority = (uint8_t)priority;
}

bool CompilerCore::getSaveOnUnuse(BaseVar& var) const ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return false;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  return (bool)vdata->saveOnUnuse;
}

void CompilerCore::setSaveOnUnuse(BaseVar& var, bool value) ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  vdata->saveOnUnuse = value;
}

void CompilerCore::rename(BaseVar& var, const char* name) ASMJIT_NOTHROW
{
  if (var.getId() == INVALID_VALUE)
    return;

  VarData* vdata = _getVarData(var.getId());
  ASMJIT_ASSERT(vdata != NULL);

  vdata->name = _zone.zstrdup(name);
}

// ============================================================================
// [AsmJit::CompilerCore - State]
// ============================================================================

StateData* CompilerCore::_newStateData(uint32_t memVarsCount) ASMJIT_NOTHROW
{
  StateData* state = reinterpret_cast<StateData*>(_zone.zalloc(sizeof(StateData) + memVarsCount * sizeof(void*)));
  return state;
}

// ============================================================================
// [AsmJit::CompilerCore - Make]
// ============================================================================

void* CompilerCore::make() ASMJIT_NOTHROW
{
  Assembler a(_codeGenerator);

  a._properties = _properties;
  a.setLogger(_logger);

  serialize(a);

  if (this->getError())
  {
    return NULL;
  }

  if (a.getError())
  {
    setError(a.getError());
    return NULL;
  }

  void* result = a.make();

  if (_logger)
  {
    _logger->logFormat("*** COMPILER SUCCESS - Wrote %u bytes, code: %u, trampolines: %u.\n\n",
      (unsigned int)a.getCodeSize(),
      (unsigned int)a.getOffset(),
      (unsigned int)a.getTrampolineSize());
  }

  return result;
}

void CompilerCore::serialize(Assembler& a) ASMJIT_NOTHROW
{
  // Context.
  CompilerContext cc(reinterpret_cast<Compiler*>(this));

  Emittable* start = _first;
  Emittable* stop = NULL;

  // Register all labels.
  a.registerLabels(_targetData.getLength());

  // Make code.
  for (;;)
  {
    _cc = NULL;

    // ------------------------------------------------------------------------
    // Find a function.
    for (;;)
    {
      if (start == NULL) return;
      if (start->getType() == EMITTABLE_FUNCTION)
        break;
      else
        start->emit(a);

      start = start->getNext();
    }
    // ------------------------------------------------------------------------

    // ------------------------------------------------------------------------
    // Setup code generation context.
    Emittable* cur;

    cc._function = reinterpret_cast<EFunction*>(start);
    cc._start = start;
    cc._stop = stop = cc._function->getEnd();
    cc._extraBlock = stop->getPrev();

    // Detect whether the function generation was finished.
    if (!cc._function->_finished || cc._function->getEnd()->getPrev() == NULL)
    {
      setError(ERROR_INCOMPLETE_FUNCTION);
      return;
    }
    // ------------------------------------------------------------------------

    // ------------------------------------------------------------------------
    // Step 1:
    // - Assign/increment offset to each emittable.
    // - Extract variables from instructions.
    // - Prepare variables for register allocator:
    //   - Update read(r) / write(w) / overwrite(x) statistics.
    //   - Update register / memory usage statistics.
    //   - Find scope (first / last emittable) of variables.
    for (cur = start; ; cur = cur->getNext())
    {
      cur->prepare(cc);
      if (cur == stop) break;
    }
    // ------------------------------------------------------------------------

    // We set compiler context also to Compiler so new emitted instructions 
    // can call prepare() to itself.
    _cc = &cc;

    // ------------------------------------------------------------------------
    // Step 2:
    // - Translate special instructions (imul, cmpxchg8b, ...).
    // - Alloc registers.
    // - Translate forward jumps.
    // - Alloc memory operands (variables related).
    // - Emit function prolog.
    // - Emit function epilog.
    // - Patch memory operands (variables related).
    // - Dump function prototype and variable statistics (if enabled).

    // Translate special instructions and run alloc registers.
    cur = start;

    do {
      do {
        // Assign current offset for each emittable back to CompilerContext.
        cc._currentOffset = cur->_offset;
        // Assign previous emittable to compiler so each variable spill/alloc will
        // be emitted before.
        _current = cur->getPrev();

        cur = cur->translate(cc);
      } while (cur);

      cc._unreachable = true;

      sysuint_t len = cc._backCode.getLength();
      while (cc._backPos < len)
      {
        cur = cc._backCode[cc._backPos++]->getNext();
        if (!cur->isTranslated()) break;

        cur = NULL;
      }
    } while (cur);

    // Translate forward jumps.
    {
      ForwardJumpData* j = cc._forwardJumps;
      while (j)
      {
        cc._assignState(j->state);
        _current = j->inst->getPrev();
        j->inst->_doJump(cc);
        j = j->next;
      }
    }

    // Alloc memory operands (variables related).
    cc._allocMemoryOperands();

    // Emit function prolog / epilog.
    cc._function->_preparePrologEpilog(cc);

    _current = cc._function->_prolog;
    cc._function->_emitProlog(cc);

    _current = cc._function->_epilog;
    cc._function->_emitEpilog(cc);

    // Patch memory operands (variables related).
    _current = _last;
    cc._patchMemoryOperands(start, stop);

    // Dump function prototype and variable statistics (if enabled).
    if (_logger)
    {
      cc._function->_dumpFunction(cc);
    }
    // ------------------------------------------------------------------------

    // ------------------------------------------------------------------------
    // Hack: need to register labels that was created by the Step 2.
    if (a._labelData.getLength() < _targetData.getLength())
    {
      a.registerLabels(_targetData.getLength() - a._labelData.getLength());
    }

    Emittable* extraBlock = cc._extraBlock;

    // Step 3:
    // - Emit instructions to Assembler stream.
    for (cur = start; ; cur = cur->getNext())
    {
      cur->emit(a);
      if (cur == extraBlock) break;
    }
    // ------------------------------------------------------------------------

    // ------------------------------------------------------------------------
    // Step 4:
    // - Emit everything else (post action).
    for (cur = start; ; cur = cur->getNext())
    {
      cur->post(a);
      if (cur == extraBlock) break;
    }
    // ------------------------------------------------------------------------

    start = extraBlock->getNext();
    cc._clear();
  }
}

// ============================================================================
// [AsmJit::Compiler - Construction / Destruction]
// ============================================================================

Compiler::Compiler(CodeGenerator* codeGenerator) ASMJIT_NOTHROW : 
  CompilerIntrinsics(codeGenerator)
{
}

Compiler::~Compiler() ASMJIT_NOTHROW
{
}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/CompilerX86X64.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_COMPILERX86X64_H
#define _ASMJIT_COMPILERX86X64_H

#if !defined(_ASMJIT_COMPILER_H)
#warning "AsmJit/CompilerX86X64.h can be only included by AsmJit/Compiler.h"
#endif // _ASMJIT_COMPILER_H

// [Dependencies]
#include "Build.h"
#include "Assembler.h"
#include "Defs.h"
#include "Operand.h"
#include "Util.h"

#include <string.h>

// A little bit C++.
#include <new>

// [Api-Begin]
#include "ApiBegin.h"

//! @internal
//!
//! @brief Mark methods not supported by @ref Compiler. These methods are
//! usually used only in function prologs/epilogs or to manage stack.
#define ASMJIT_NOT_SUPPORTED_BY_COMPILER 0

namespace AsmJit {

//! @addtogroup AsmJit_Compiler
//! @{

// ============================================================================
// [AsmJit::TypeToId]
// ============================================================================

// Skip documenting this.
#if !defined(ASMJIT_NODOC)

ASMJIT_DECLARE_TYPE_AS_ID(int8_t, VARIABLE_TYPE_GPD);
ASMJIT_DECLARE_TYPE_AS_ID(uint8_t, VARIABLE_TYPE_GPD);

ASMJIT_DECLARE_TYPE_AS_ID(int16_t, VARIABLE_TYPE_GPD);
ASMJIT_DECLARE_TYPE_AS_ID(uint16_t, VARIABLE_TYPE_GPD);

ASMJIT_DECLARE_TYPE_AS_ID(int32_t, VARIABLE_TYPE_GPD);
ASMJIT_DECLARE_TYPE_AS_ID(uint32_t, VARIABLE_TYPE_GPD);

#if defined(ASMJIT_X64)
ASMJIT_DECLARE_TYPE_AS_ID(int64_t, VARIABLE_TYPE_GPQ);
ASMJIT_DECLARE_TYPE_AS_ID(uint64_t, VARIABLE_TYPE_GPQ);
#endif // ASMJIT_X64

ASMJIT_DECLARE_TYPE_AS_ID(float, VARIABLE_TYPE_FLOAT);
ASMJIT_DECLARE_TYPE_AS_ID(double, VARIABLE_TYPE_DOUBLE);

#endif // !ASMJIT_NODOC

// ============================================================================
// [AsmJit::FunctionPrototype]
// ============================================================================

//! @brief Calling convention and function argument handling.
struct ASMJIT_API FunctionPrototype
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref FunctionPrototype instance.
  FunctionPrototype() ASMJIT_NOTHROW;
  //! @brief Destroy the @ref FunctionPrototype instance.
  ~FunctionPrototype() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Argument]
  // --------------------------------------------------------------------------

  //! @brief Function argument location.
  struct Argument
  {
    //! @brief Variable type, see @c VARIABLE_TYPE.
    uint32_t variableType;
    //! @brief Register index if argument is passed through register, otherwise
    //! @c INVALID_VALUE.
    uint32_t registerIndex;
    //! @brief Stack offset if argument is passed through stack, otherwise
    //! @c INVALID_VALUE.
    int32_t stackOffset;

    //! @brief Get whether the argument is assigned, for private use only.
    inline bool isAssigned() const ASMJIT_NOTHROW
    { return registerIndex != INVALID_VALUE || stackOffset != (int32_t)INVALID_VALUE; }
  };

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Set function prototype.
  //!
  //! This will set function calling convention and setup arguments variables.
  //!
  //! @note This function will allocate variables, it can be called only once.
  void setPrototype(
    uint32_t callingConvention,
    const uint32_t* arguments, 
    uint32_t argumentsCount,
    uint32_t returnValue) ASMJIT_NOTHROW;

  //! @brief Get function calling convention, see @c CALL_CONV.
  inline uint32_t getCallingConvention() const ASMJIT_NOTHROW { return _callingConvention; }

  //! @brief Get whether the callee pops the stack.
  inline uint32_t getCalleePopsStack() const ASMJIT_NOTHROW { return _calleePopsStack; }

  //! @brief Get function arguments.
  inline Argument* getArguments() ASMJIT_NOTHROW { return _arguments; }
  //! @brief Get function arguments (const version).
  inline const Argument* getArguments() const ASMJIT_NOTHROW { return _arguments; }

  //! @brief Get count of arguments.
  inline uint32_t getArgumentsCount() const ASMJIT_NOTHROW { return _argumentsCount; }

  //! @brief Get function return value or @ref INVALID_VALUE if it's void.
  inline uint32_t getReturnValue() const ASMJIT_NOTHROW { return _returnValue; }

  //! @brief Get direction of arguments passed on the stack.
  //!
  //! Direction should be always @c ARGUMENT_DIR_RIGHT_TO_LEFT.
  //!
  //! @note This is related to used calling convention, it's not affected by
  //! number of function arguments or their types.
  inline uint32_t getArgumentsDirection() const ASMJIT_NOTHROW { return _argumentsDirection; }

  //! @brief Get stack size needed for function arguments passed on the stack.
  inline uint32_t getArgumentsStackSize() const ASMJIT_NOTHROW { return _argumentsStackSize; }

  //! @brief Get registers used to pass first integer parameters by current
  //! calling convention.
  //!
  //! @note This is related to used calling convention, it's not affected by
  //! number of function arguments or their types.
  inline const uint32_t* getArgumentsGPList() const ASMJIT_NOTHROW { return _argumentsGPList; }

  //! @brief Get registers used to pass first SP-FP or DP-FPparameters by
  //! current calling convention.
  //!
  //! @note This is related to used calling convention, it's not affected by
  //! number of function arguments or their types.
  inline const uint32_t* getArgumentsXMMList() const ASMJIT_NOTHROW { return _argumentsXMMList; }

  //! @brief Get bitmask of GP registers which might be used for arguments.
  inline uint32_t getArgumentsGP() const ASMJIT_NOTHROW { return _argumentsGP; }
  //! @brief Get bitmask of MM registers which might be used for arguments.
  inline uint32_t getArgumentsMM() const ASMJIT_NOTHROW { return _argumentsMM; }
  //! @brief Get bitmask of XMM registers which might be used for arguments.
  inline uint32_t getArgumentsXMM() const ASMJIT_NOTHROW { return _argumentsXMM; }

  //! @brief Get bitmask of general purpose registers that's preserved
  //! (non-volatile).
  //!
  //! @note This is related to used calling convention, it's not affected by
  //! number of function arguments or their types.
  inline uint32_t getPreservedGP() const ASMJIT_NOTHROW { return _preservedGP; }

  //! @brief Get bitmask of MM registers that's preserved (non-volatile).
  //!
  //! @note No standardized calling function is not preserving MM registers.
  //! This member is here for extension writers who need for some reason custom
  //! calling convention that can be called through code generated by AsmJit
  //! (or other runtime code generator).
  inline uint32_t getPreservedMM() const ASMJIT_NOTHROW { return _preservedMM; }

  //! @brief Return bitmask of XMM registers that's preserved (non-volatile).
  //!
  //! @note This is related to used calling convention, it's not affected by
  //! number of function arguments or their types.
  inline uint32_t getPreservedXMM() const ASMJIT_NOTHROW { return _preservedXMM; }

  //! @brief Get mask of all GP registers used to pass function arguments.
  inline uint32_t getPassedGP() const ASMJIT_NOTHROW { return _passedGP; }
  //! @brief Get mask of all MM registers used to pass function arguments.
  inline uint32_t getPassedMM() const ASMJIT_NOTHROW { return _passedMM; }
  //! @brief Get mask of all XMM registers used to pass function arguments.
  inline uint32_t getPassedXMM() const ASMJIT_NOTHROW { return _passedXMM; }

  //! @brief Find argument (id) by the register code. Used mainly by @ref ECall
  //! emittable.
  uint32_t findArgumentByRegisterCode(uint32_t regCode) const ASMJIT_NOTHROW;

protected:

  // --------------------------------------------------------------------------
  // [Private]
  // --------------------------------------------------------------------------

  void _clear() ASMJIT_NOTHROW;
  void _setCallingConvention(uint32_t callingConvention) ASMJIT_NOTHROW;
  void _setPrototype(
    const uint32_t* arguments,
    uint32_t argumentsCount,
    uint32_t returnValue) ASMJIT_NOTHROW;
  void _setReturnValue(uint32_t valueId) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Calling convention.
  uint32_t _callingConvention;
  //! @brief Whether callee pops stack.
  uint32_t _calleePopsStack;

  //! @brief List of arguments, their register codes or stack locations.
  Argument _arguments[FUNC_MAX_ARGS];

  //! @brief Function return value.
  uint32_t _returnValue;

  //! @brief Count of arguments (in @c _argumentsList).
  uint32_t _argumentsCount;
  //! @brief Direction for arguments passed on the stack, see @c ARGUMENT_DIR.
  uint32_t _argumentsDirection;
  //! @brief Count of bytes consumed by arguments on the stack.
  uint32_t _argumentsStackSize;

  //! @brief List of registers that's used for first GP arguments.
  uint32_t _argumentsGPList[16];
  //! @brief List of registers that's used for first XMM arguments.
  uint32_t _argumentsXMMList[16];

  //! @brief Bitmask for preserved GP registers.
  uint32_t _argumentsGP;
  //! @brief Bitmask for preserved MM registers.
  uint32_t _argumentsMM;
  //! @brief Bitmask for preserved XMM registers.
  uint32_t _argumentsXMM;

  //! @brief Bitmask for preserved GP registers.
  uint32_t _preservedGP;
  //! @brief Bitmask for preserved MM registers.
  uint32_t _preservedMM;
  //! @brief Bitmask for preserved XMM registers.
  uint32_t _preservedXMM;

  // Set by _setPrototype().

  //! @brief Bitmask for GP registers used as function arguments.
  uint32_t _passedGP;
  //! @brief Bitmask for GP registers used as function arguments.
  uint32_t _passedMM;
  //! @brief Bitmask for GP registers used as function arguments.
  uint32_t _passedXMM;
};

// ============================================================================
// [AsmJit::VarData]
// ============================================================================

//! @brief Variable data (used internally by @c Compiler).
struct VarData
{
  // --------------------------------------------------------------------------
  // [Scope]
  // --------------------------------------------------------------------------

  //! @brief Scope (NULL if variable is global).
  EFunction* scope;

  //! @brief The first emittable where the variable is accessed.
  //!
  //! @note If this member is @c NULL then variable is unused.
  Emittable* firstEmittable;
  //! @brief The first callable (ECall) which is after the @c firstEmittable.
  ECall* firstCallable;
  //! @brief The last emittable where the variable is accessed.
  Emittable* lastEmittable;

  // --------------------------------------------------------------------------
  // [Id / Name]
  // --------------------------------------------------------------------------

  //! @brief Variable name.
  const char* name;
  //! @brief Variable id.
  uint32_t id;
  //! @brief Variable type.
  uint32_t type;
  //! @brief Variable size.
  uint32_t size;

  // --------------------------------------------------------------------------
  // [Home]
  // --------------------------------------------------------------------------

  //! @brief Home register index or @c INVALID_VALUE (used by register allocator).
  uint32_t homeRegisterIndex;
  //! @brief Preferred register index.
  uint32_t prefRegisterMask;

  //! @brief Home memory address offset.
  int32_t homeMemoryOffset;
  //! @brief Used by @c CompilerContext, do not touch (NULL when created).
  void* homeMemoryData;

  // --------------------------------------------------------------------------
  // [Actual]
  // --------------------------------------------------------------------------

  //! @brief Actual register index (connected with actual @c StateData).
  uint32_t registerIndex;
  //! @brief Actual working offset. This member is set before register allocator
  //! is called. If workOffset is same as CompilerContext::_currentOffset then
  //! this variable is probably used in next instruction and can't be spilled.
  uint32_t workOffset;

  //! @brief Next active variable in circular double-linked list.
  VarData* nextActive;
  //! @brief Previous active variable in circular double-linked list.
  VarData* prevActive;

  // --------------------------------------------------------------------------
  // [Flags]
  // --------------------------------------------------------------------------

  //! @brief Variable priority.
  uint8_t priority;
  //! @brief Whether variable content can be calculated by simple instruction
  //!
  //! This is used mainly by mmx or sse2 code and variable allocator will
  //! never reserve space for this variable. Calculated variables are for
  //! example all zeros, all ones, etc.
  uint8_t calculated;
  //! @brief Whether variable is argument passed through register.
  uint8_t isRegArgument;
  //! @brief Whether variable is argument passed through memory.
  uint8_t isMemArgument;

  //! @brief Variable state (connected with actual @c StateData).
  uint8_t state;
  //! @brief Whether variable was changed (connected with actual @c StateData).
  uint8_t changed;
  //! @brief Save on unuse (at end of the variable scope).
  uint8_t saveOnUnuse;

  // --------------------------------------------------------------------------
  // [Statistics]
  // --------------------------------------------------------------------------

  //! @brief Register read statistics (used by instructions where this variable needs
  //! to be read only).
  uint32_t registerReadCount;
  //! @brief Register write statistics (used by instructions where this variable needs
  //! to be write only).
  uint32_t registerWriteCount;
  //! @brief Register read+write statistics (used by instructions where this variable
  //! needs to be read and write).
  uint32_t registerRWCount;

  //! @brief Register GPB.LO statistics (for code generator).
  uint32_t registerGPBLoCount;
  //! @brief Register GPB.HI statistics (for code generator).
  uint32_t registerGPBHiCount;

  //! @brief Memory read statistics.
  uint32_t memoryReadCount;
  //! @brief Memory write statistics.
  uint32_t memoryWriteCount;
  //! @brief Memory read+write statistics.
  uint32_t memoryRWCount;

  // --------------------------------------------------------------------------
  // [Temporary]
  // --------------------------------------------------------------------------

  //! @brief Temporary data that can be used in prepare/translate stage.
  //!
  //! Initial value is NULL and each emittable/code that will use it must also
  //! clear it.
  //!
  //! This temporary data is designed to be used by algorithms that need to
  //! set some state into the variables, do something and then cleanup. See
  //! state-switch and function call.
  union
  {
    void* tempPtr;
    sysint_t tempInt;
  };
};

// ============================================================================
// [AsmJit::VarMemBlock]
// ============================================================================

struct VarMemBlock
{
  int32_t offset;
  uint32_t size;

  VarMemBlock* nextUsed;
  VarMemBlock* nextFree;
};

// ============================================================================
// [AsmJit::VarAllocRecord]
// ============================================================================

//! @brief Variable alloc record (for each instruction that uses variables).
//!
//! Variable record contains pointer to variable data and register allocation
//! flags. These flags are important to determine the best alloc instruction.
struct VarAllocRecord
{
  //! @brief Variable data (the structure owned by @c Compiler).
  VarData* vdata;
  //! @brief Variable alloc flags, see @c VARIABLE_ALLOC.
  uint32_t vflags;
  //! @brief Register mask (default is 0).
  uint32_t regMask;
};

// ============================================================================
// [AsmJit::VarCallRecord]
// ============================================================================

//! @brief Variable call-fn record (for each callable that uses variables).
//!
//! This record contains variables that are used to call a function (using 
//! @c ECall emittable). Each variable contains the registers where it must
//! be and registers where the value will be returned.
struct VarCallRecord
{
  //! @brief Variable data (the structure owned by @c Compiler).
  VarData* vdata;
  uint32_t flags;

  uint8_t inCount;
  uint8_t inDone;

  uint8_t outCount;
  uint8_t outDone;

  enum FLAGS
  {
    FLAG_IN_GP = 0x0001,
    FLAG_IN_MM = 0x0002,
    FLAG_IN_XMM = 0x0004,
    FLAG_IN_STACK = 0x0008,

    FLAG_OUT_EAX = 0x0010,
    FLAG_OUT_EDX = 0x0020,
    FLAG_OUT_ST0 = 0x0040,
    FLAG_OUT_ST1 = 0x0080,
    FLAG_OUT_MM0 = 0x0100,
    FLAG_OUT_XMM0 = 0x0400,
    FLAG_OUT_XMM1 = 0x0800,

    FLAG_IN_MEM_PTR = 0x1000,
    FLAG_CALL_OPERAND_REG = 0x2000,
    FLAG_CALL_OPERAND_MEM = 0x4000,

    FLAG_UNUSE_AFTER_USE = 0x8000
  };
};

// ============================================================================
// [AsmJit::VarHintRecord]
// ============================================================================

struct VarHintRecord
{
  VarData* vdata;
  uint32_t hint;
};

// ============================================================================
// [AsmJit::StateData]
// ============================================================================

//! @brief State data.
struct StateData
{
  enum { NUM_REGS = 16 + 8 + 16 };

  inline void clear() ASMJIT_NOTHROW
  {
    memset(this, 0, sizeof(*this));
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union
  {
    //! @brief All allocated variables in one array.
    VarData* regs[NUM_REGS];

    struct
    {
      //! @brief Allocated GP registers.
      VarData* gp[16];
      //! @brief Allocated MM registers.
      VarData* mm[8];
      //! @brief Allocated XMM registers.
      VarData* xmm[16];
    };
  };

  //! @brief Used GP registers bitmask.
  uint32_t usedGP;
  //! @brief Used MM registers bitmask.
  uint32_t usedMM;
  //! @brief Used XMM registers bitmask.
  uint32_t usedXMM;

  //! @brief Changed GP registers bitmask.
  uint32_t changedGP;
  //! @brief Changed MM registers bitmask.
  uint32_t changedMM;
  //! @brief Changed XMM registers bitmask.
  uint32_t changedXMM;

  //! @brief Count of variables in @c memVarsData.
  uint32_t memVarsCount;
  //! @brief Variables stored in memory (@c VARIABLE_STATE_MEMORY).
  //!
  //! When saving / restoring state it's important to keep registers which are
  //! still in memory. Register is always unused when it is going out-of-scope.
  //! All variables which are not here are unused (@c VARIABLE_STATE_UNUSED).
  VarData* memVarsData[1];
};

// ============================================================================
// [AsmJit::ForwardJumpData]
// ============================================================================

struct ForwardJumpData
{
  EJmp* inst;
  StateData* state;
  ForwardJumpData* next;
};

// ============================================================================
// [AsmJit::EVariableHint]
// ============================================================================

//! @brief Variable hint.
struct ASMJIT_API EVariableHint : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EVariableHint instance.
  EVariableHint(Compiler* c, VarData* vdata, uint32_t hintId, uint32_t hintValue) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EVariableHInt instance.
  virtual ~EVariableHint() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Hint]
  // --------------------------------------------------------------------------

  //! @brief Get assigned variable (data).
  inline VarData* getVar() const ASMJIT_NOTHROW { return _vdata; }

  //! @brief Get hint it (see @ref VARIABLE_HINT).
  inline uint32_t getHintId() const ASMJIT_NOTHROW { return _hintId; }
  //! @brief Get hint value.
  inline uint32_t getHintValue() const ASMJIT_NOTHROW { return _hintValue; }

  //! @brief Set hint it (see @ref VARIABLE_HINT).
  inline void setHintId(uint32_t hintId) ASMJIT_NOTHROW { _hintId = hintId; }
  //! @brief Set hint value.
  inline void setHintValue(uint32_t hintValue) ASMJIT_NOTHROW { _hintValue = hintValue; }

  VarData* _vdata;
  uint32_t _hintId;
  uint32_t _hintValue;
};

// ============================================================================
// [AsmJit::EInstruction]
// ============================================================================

//! @brief Emittable that represents single instruction and its operands.
struct ASMJIT_API EInstruction : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EInstruction instance.
  EInstruction(Compiler* c, uint32_t code, Operand* operandsData, uint32_t operandsCount) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EInstruction instance.
  virtual ~EInstruction() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;
  virtual bool _tryUnuseVar(VarData* v) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Instruction Code]
  // --------------------------------------------------------------------------

  //! @brief Get whether the instruction is special.
  inline bool isSpecial() const ASMJIT_NOTHROW { return _isSpecial; }

  //! @brief Get whether the instruction is FPU.
  inline bool isFPU() const ASMJIT_NOTHROW { return _isFPU; }

  //! @brief Get instruction code, see @c INST_CODE.
  inline uint32_t getCode() const ASMJIT_NOTHROW { return _code; }

  //! @brief Set instruction code to @a code.
  //!
  //! Please do not modify instruction code if you are not know what you are
  //! doing. Incorrect instruction code or operands can raise assertion() at
  //! runtime.
  inline void setCode(uint32_t code) ASMJIT_NOTHROW { _code = code; }

  // --------------------------------------------------------------------------
  // [Operands]
  // --------------------------------------------------------------------------

  //! @brief Get count of operands in operands array (number between 0 to 2 inclusive).
  inline uint32_t getOperandsCount() const ASMJIT_NOTHROW { return _operandsCount; }

  //! @brief Get operands array (3 operands total).
  inline Operand* getOperands() ASMJIT_NOTHROW { return _operands; }
  //! @brief Get operands array (3 operands total).
  inline const Operand* getOperands() const ASMJIT_NOTHROW { return _operands; }

  //! @brief Get memory operand.
  inline Mem* getMemOp() ASMJIT_NOTHROW { return _memOp; }
  //! @brief Set memory operand.
  inline void setMemOp(Mem* op) ASMJIT_NOTHROW { _memOp = op; }

  // --------------------------------------------------------------------------
  // [Variables]
  // --------------------------------------------------------------------------

  //! @brief Get count of variables in instruction operands (and in variables array).
  inline uint32_t getVariablesCount() const ASMJIT_NOTHROW { return _variablesCount; }

  //! @brief Get operands array (3 operands total).
  inline VarAllocRecord* getVariables() ASMJIT_NOTHROW { return _variables; }
  //! @brief Get operands array (3 operands total).
  inline const VarAllocRecord* getVariables() const ASMJIT_NOTHROW { return _variables; }

  // --------------------------------------------------------------------------
  // [Jump]
  // --------------------------------------------------------------------------

  //! @brief Get possible jump target.
  //!
  //! If this instruction is conditional or normal jump then return value is
  //! label location (ETarget instance), otherwise return value is @c NULL.
  virtual ETarget* getJumpTarget() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Instruction code, see @c INST_CODE.
  uint32_t _code;

  //! @brief Emit options, see @c EMIT_OPTIONS.
  uint32_t _emitOptions;

  //! @brief Operands count.
  uint32_t _operandsCount;

  //! @brief Variables count.
  uint32_t _variablesCount;

  //! @brief Operands.
  Operand* _operands;
  //! @brief Memory operand (if instruction contains any).
  Mem* _memOp;

  //! @brief Variables (extracted from operands).
  VarAllocRecord* _variables;

  //! @brief Whether the instruction is special.
  bool _isSpecial;
  //! @brief Whether the instruction is FPU.
  bool _isFPU;

  //! @brief Whether the one of the operands is GPB.Lo register.
  bool _isGPBLoUsed;
  //! @brief Whether the one of the operands is GPB.Hi register.
  bool _isGPBHiUsed;

  friend struct EFunction;
  friend struct CompilerContext;
  friend struct CompilerCore;

private:
  ASMJIT_DISABLE_COPY(EInstruction)
};

// ============================================================================
// [AsmJit::EJmp]
// ============================================================================

//! @brief Emittable that represents single instruction that can jump somewhere.
struct ASMJIT_API EJmp : public EInstruction
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  EJmp(Compiler* c, uint32_t code, Operand* operandsData, uint32_t operandsCount) ASMJIT_NOTHROW;
  virtual ~EJmp() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  void _doJump(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Jump]
  // --------------------------------------------------------------------------

  virtual ETarget* getJumpTarget() const ASMJIT_NOTHROW;

  inline EJmp* getJumpNext() const ASMJIT_NOTHROW { return _jumpNext; }
  inline bool isTaken() const ASMJIT_NOTHROW { return _isTaken; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  ETarget* _jumpTarget;
  EJmp *_jumpNext;
  StateData* _state;
  bool _isTaken;

  friend struct EFunction;
  friend struct CompilerContext;
  friend struct CompilerCore;

private:
  ASMJIT_DISABLE_COPY(EJmp)
};

// ============================================================================
// [AsmJit::EFunction]
// ============================================================================

//! @brief Function emittable used to generate C/C++ functions.
//!
//! Functions are base blocks for generating assembler output. Each generated
//! assembler stream needs standard entry and leave sequences thats compatible
//! to the operating system conventions - Application Binary Interface (ABI).
//!
//! Function class can be used to generate entry (prolog) and leave (epilog)
//! sequences that is compatible to a given calling convention and to allocate
//! and manage variables that can be allocated to registers or spilled.
//!
//! @note To create function use @c AsmJit::Compiler::newFunction() method, do
//! not create @c EFunction instances using other ways.
//!
//! @sa @c State, @c Var.
struct ASMJIT_API EFunction : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new @c Function instance.
  //!
  //! @note Always use @c AsmJit::Compiler::newFunction() to create @c Function
  //! instance.
  EFunction(Compiler* c) ASMJIT_NOTHROW;
  //! @brief Destroy @c Function instance.
  virtual ~EFunction() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Function Prototype (Calling Convention + Arguments) / Return Value]
  // --------------------------------------------------------------------------

  inline const FunctionPrototype& getPrototype() const ASMJIT_NOTHROW { return _functionPrototype; }
  inline uint32_t getHint(uint32_t hint) ASMJIT_NOTHROW { return _hints[hint]; }

  void setPrototype(
    uint32_t callingConvention, 
    const uint32_t* arguments, 
    uint32_t argumentsCount,
    uint32_t returnValue) ASMJIT_NOTHROW;
  void setHint(uint32_t hint, uint32_t value) ASMJIT_NOTHROW;

  inline EProlog* getProlog() const ASMJIT_NOTHROW { return _prolog; }
  inline EEpilog* getEpilog() const ASMJIT_NOTHROW { return _epilog; }

  inline EFunctionEnd* getEnd() const ASMJIT_NOTHROW { return _end; }

  //! @brief Create variables from FunctionPrototype declaration. This is just
  //! parsing what FunctionPrototype generated for current function calling
  //! convention and arguments.
  void _createVariables() ASMJIT_NOTHROW;

  //! @brief Prepare variables (ids, names, scope, registers).
  void _prepareVariables(Emittable* first) ASMJIT_NOTHROW;

  //! @brief Allocate variables (setting correct state, changing masks, etc).
  void _allocVariables(CompilerContext& cc) ASMJIT_NOTHROW;

  void _preparePrologEpilog(CompilerContext& cc) ASMJIT_NOTHROW;
  void _dumpFunction(CompilerContext& cc) ASMJIT_NOTHROW;
  void _emitProlog(CompilerContext& cc) ASMJIT_NOTHROW;
  void _emitEpilog(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Function-Call]
  // --------------------------------------------------------------------------

  //! @brief Reserve stack for calling other function and mark function as
  //! callee.
  void reserveStackForFunctionCall(int32_t size);

  // --------------------------------------------------------------------------
  // [Labels]
  // --------------------------------------------------------------------------

  //! @brief Get function entry label.
  //!
  //! Entry label can be used to call this function from another code that's
  //! being generated.
  inline const Label& getEntryLabel() const ASMJIT_NOTHROW { return _entryLabel; }

  //! @brief Get function exit label.
  //!
  //! Use exit label to jump to function epilog.
  inline const Label& getExitLabel() const ASMJIT_NOTHROW { return _exitLabel; }

  // --------------------------------------------------------------------------
  // [Misc]
  // --------------------------------------------------------------------------

  //! @brief Set the _isEspAdjusted member to true.
  //!
  //! This method is used to tell compiler that the ESP/RSP must be adjusted in
  //! function prolog/epilog, because the stack is manipulated (usually caused
  //! by the function call, see @c ECall).
  inline void mustAdjustEsp() { _isEspAdjusted = true; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Function prototype.
  FunctionPrototype _functionPrototype;
  //! @brief Function arguments (variable IDs).
  VarData** _argumentVariables;
  //! @brief Function hints.
  uint32_t _hints[16];

  //! @brief Whether the function stack is aligned by 16-bytes by OS.
  //!
  //! This is always true for 64-bit mode and for linux.
  bool _isStackAlignedByOsTo16Bytes;

  //! @brief Whether the function stack (for variables) is aligned manually
  //! by function to 16-bytes.
  //!
  //! This makes sense only if _isStackAlignedByOsTo16Bytes is false and MOVDQA
  //! instruction or other SSE/SSE2 instructions are used to work with variable
  //! stored on the stack.
  //!
  //! Value is determined automatically by these factors, expectations are:
  //!
  //!   1. There is 16-byte wide variable which address was used (alloc, spill,
  //!      op).
  //!   2. Function can't be naked.
  bool _isStackAlignedByFnTo16Bytes;

  //! @brief Whether the function is using naked prolog / epilog
  //!
  //! Naked prolog / epilog means to omit saving and restoring EBP.
  bool _isNaked;

  //! @brief Whether the ESP register is adjusted by the stack size needed
  //! to save registers and function variables.
  //!
  //! Esp is adjusted by 'sub' instruction in prolog and by add function in
  //! epilog (only if function is not naked).
  bool _isEspAdjusted;

  //! @brief Whether another function is called from this function.
  //!
  //! If another function is called from this function, it's needed to prepare
  //! stack for it. If this member is true then it's likely that true will be
  //! also @c _isEspAdjusted one.
  bool _isCaller;

  //! @brief Whether to emit prolog / epilog sequence using push & pop
  //! instructions (the default).
  bool _pePushPop;

  //! @brief Whether to emit EMMS instruction in epilog (auto-detected).
  bool _emitEMMS;

  //! @brief Whether to emit SFence instruction in epilog (auto-detected).
  //!
  //! @note Combination of @c _emitSFence and @c _emitLFence will result in
  //! emitting mfence.
  bool _emitSFence;

  //! @brief Whether to emit LFence instruction in epilog (auto-detected).
  //!
  //! @note Combination of @c _emitSFence and @c _emitLFence will result in
  //! emitting mfence.
  bool _emitLFence;

  //! @brief Whether the function is finished using @c Compiler::endFunction().
  bool _finished;

  //! @brief Bitfield containing modified and preserved GP registers.
  uint32_t _modifiedAndPreservedGP;

  //! @brief Bitfield containing modified and preserved MM registers.
  uint32_t _modifiedAndPreservedMM;

  //! @brief Bitfield containing modified and preserved XMM registers.
  uint32_t _modifiedAndPreservedXMM;

  //! @brief ID mov movdqa instruction (@c INST_MOVDQA or @c INST_MOVDQU).
  //!
  //! The value is based on stack alignment. If it's guaranteed that stack
  //! is aligned to 16-bytes then @c INST_MOVDQA instruction is used, otherwise
  //! the @c INST_MOVDQU instruction is used for 16-byte mov.
  uint32_t _movDqaInstruction;

  //! @brief Prolog / epilog stack size for PUSH/POP sequences.
  int32_t _pePushPopStackSize;
  //! @brief Prolog / epilog stack size for MOV sequences.
  int32_t _peMovStackSize;
  //! @brief Prolog / epilog stack adjust size (to make it 16-byte aligned).
  int32_t _peAdjustStackSize;

  //! @brief Memory stack size (for all variables and temporary memory).
  int32_t _memStackSize;
  //! @brief Like @c _memStackSize, but aligned to 16-bytes.
  int32_t _memStackSize16;

  //! @brief Stack size needed to call other functions.
  int32_t _functionCallStackSize;

  //! @brief Function entry label.
  Label _entryLabel;
  //! @brief Function exit label.
  Label _exitLabel;

  //! @brief Function prolog emittable.
  EProlog* _prolog;
  //! @brief Function epilog emittable.
  EEpilog* _epilog;
  //! @brief Dummy emittable, signalizes end of function.
  EFunctionEnd* _end;

private:
  friend struct CompilerContext;
  friend struct CompilerCore;
  friend struct EProlog;
  friend struct EEpilog;
};

// ============================================================================
// [AsmJit::EProlog]
// ============================================================================

//! @brief Prolog emittable.
struct ASMJIT_API EProlog : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EProlog instance.
  EProlog(Compiler* c, EFunction* f) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EProlog instance.
  virtual ~EProlog() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Get function associated with this prolog.
  inline EFunction* getFunction() const ASMJIT_NOTHROW { return _function; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Prolog owner function.
  EFunction* _function;

private:
  friend struct CompilerCore;
  friend struct EFunction;
};

// ============================================================================
// [AsmJit::EEpilog]
// ============================================================================

//! @brief Epilog emittable.
struct ASMJIT_API EEpilog : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref EEpilog instance.
  EEpilog(Compiler* c, EFunction* f) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref EProlog instance.
  virtual ~EEpilog() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Get function associated with this epilog.
  inline EFunction* getFunction() const ASMJIT_NOTHROW { return _function; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Epilog owner function.
  EFunction* _function;

private:
  friend struct CompilerCore;
  friend struct EFunction;
};

// ============================================================================
// [AsmJit::ECall]
// ============================================================================

//! @brief Function call.
struct ASMJIT_API ECall : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref ECall instance.
  ECall(Compiler* c, EFunction* caller, const Operand* target) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref ECall instance.
  virtual ~ECall() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;
  virtual bool _tryUnuseVar(VarData* v) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Internal]
  // --------------------------------------------------------------------------

protected:

  uint32_t _findTemporaryGpRegister(CompilerContext& cc) ASMJIT_NOTHROW;
  uint32_t _findTemporaryXmmRegister(CompilerContext& cc) ASMJIT_NOTHROW;

  VarData* _getOverlappingVariable(CompilerContext& cc,
    const FunctionPrototype::Argument& argType) const ASMJIT_NOTHROW;

  void _moveAllocatedVariableToStack(CompilerContext& cc,
    VarData* vdata, const FunctionPrototype::Argument& argType) ASMJIT_NOTHROW;

  void _moveSpilledVariableToStack(CompilerContext& cc,
    VarData* vdata, const FunctionPrototype::Argument& argType,
    uint32_t temporaryGpReg,
    uint32_t temporaryXmmReg) ASMJIT_NOTHROW;

  void _moveSrcVariableToRegister(CompilerContext& cc,
    VarData* vdata, const FunctionPrototype::Argument& argType) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Function Prototype (Calling Convention + Arguments) / Return Value]
  // --------------------------------------------------------------------------

public:

  //! @brief Get function prototype.
  inline const FunctionPrototype& getPrototype() const ASMJIT_NOTHROW { return _functionPrototype; }

  //! @brief Set function prototype.
  inline void setPrototype(uint32_t cconv, const FunctionDefinition& def) ASMJIT_NOTHROW
  {
    _setPrototype(
      cconv,
      def.getArguments(), 
      def.getArgumentsCount(), 
      def.getReturnValue());
  }

  //! @brief Set function prototype (internal).
  void _setPrototype(
    uint32_t callingConvention,
    const uint32_t* arguments,
    uint32_t argumentsCount,
    uint32_t returnValue) ASMJIT_NOTHROW;

  //! @brief Set function argument @a i to @a var.
  bool setArgument(uint32_t i, const BaseVar& var) ASMJIT_NOTHROW;
  //! @brief Set function argument @a i to @a imm.
  bool setArgument(uint32_t i, const Imm& imm) ASMJIT_NOTHROW;

  //! @brief Set return value to 
  bool setReturn(const Operand& first, const Operand& second = Operand()) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Get caller.
  inline EFunction* getCaller() const ASMJIT_NOTHROW { return _caller; }

  //! @brief Get operand (function address).
  inline Operand& getTarget() ASMJIT_NOTHROW { return _target; }
  //! @overload
  inline const Operand& getTarget() const ASMJIT_NOTHROW { return _target; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Function prototype.
  FunctionPrototype _functionPrototype;

  //! @brief Callee (the function that calls me).
  EFunction* _caller;

  //! @brief Arguments (operands).
  Operand* _args;

  //! @brief Operand (address of function, register, label, ...)
  Operand _target;

  //! @brief Return value (operands)
  Operand _ret[2];

  //! @brief Mask of GP registers used as function arguments.
  uint32_t _gpParams;
  //! @brief Mask of MM registers used as function arguments.
  uint32_t _mmParams;
  //! @brief Mask of XMM registers used as function arguments.
  uint32_t _xmmParams;

  //! @brief Variables count.
  uint32_t _variablesCount;

  //! @brief Variables (extracted from operands).
  VarCallRecord* _variables;
  //! @brief Argument index to @c VarCallRecord.
  VarCallRecord* _argumentToVarRecord[FUNC_MAX_ARGS];

private:
  friend struct CompilerCore;
};

// ============================================================================
// [AsmJit::ERet]
// ============================================================================

//! @brief Function return.
struct ASMJIT_API ERet : public Emittable
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref ERet instance.
  ERet(Compiler* c, EFunction* function, const Operand* first, const Operand* second) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref ERet instance.
  virtual ~ERet() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  virtual void prepare(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual Emittable* translate(CompilerContext& cc) ASMJIT_NOTHROW;
  virtual void emit(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Utilities]
  // --------------------------------------------------------------------------

  virtual int getMaxSize() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @Brief Get function.
  inline EFunction* getFunction() ASMJIT_NOTHROW { return _function; }

  //! @brief Get operand (function address).
  inline Operand& getFirst() ASMJIT_NOTHROW { return _ret[0]; }
  //! @brief Get operand (function address).
  inline Operand& getSecond() ASMJIT_NOTHROW { return _ret[1]; }
  //! @overload
  inline const Operand& getFirst() const ASMJIT_NOTHROW { return _ret[0]; }
  //! @overload
  inline const Operand& getSecond() const ASMJIT_NOTHROW { return _ret[1]; }

  //! @brief Get whether jump to epilog have to be emitted.
  bool shouldEmitJumpToEpilog() const ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Function.
  EFunction* _function;
  //! @brief Return value (operands)
  Operand _ret[2];

private:
  friend struct CompilerCore;
};

// ============================================================================
// [AsmJit::CompilerContext]
// ============================================================================

//! @internal
//!
//! @brief Compiler context is used by @ref Compiler.
//!
//! Compiler context is used during compilation and normally developer doesn't
//! need access to it. The context is user per function (it's reset after each
//! function is generated).
struct ASMJIT_API CompilerContext
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new @ref CompilerContext instance.
  CompilerContext(Compiler* compiler) ASMJIT_NOTHROW;
  //! @brief Destroy the @ref CompilerContext instance.
  ~CompilerContext() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Clear]
  // --------------------------------------------------------------------------

  //! @brief Clear context, preparing it for next function generation.
  void _clear() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Register Allocator]
  // --------------------------------------------------------------------------

  //! @brief Allocate variable
  //!
  //! Calls @c allocGPVar, @c allocMMVar or @c allocXMMVar methods.
  void allocVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Save variable.
  //!
  //! Calls @c saveGPVar, @c saveMMVar or @c saveXMMVar methods.
  void saveVar(VarData* vdata) ASMJIT_NOTHROW;
  //! @brief Spill variable.
  //!
  //! Calls @c spillGPVar, @c spillMMVar or @c spillXMMVar methods.
  void spillVar(VarData* vdata) ASMJIT_NOTHROW;
  //! @brief Unuse variable (didn't spill, just forget about it).
  void unuseVar(VarData* vdata, uint32_t toState) ASMJIT_NOTHROW;

  //! @brief Helper method that is called for each variable per emittable.
  inline void _unuseVarOnEndOfScope(Emittable* e, VarData* v)
  {
    if (v->lastEmittable == e)
      unuseVar(v, VARIABLE_STATE_UNUSED);
  }
  //! @overload
  inline void _unuseVarOnEndOfScope(Emittable* e, VarAllocRecord* rec)
  {
    VarData* v = rec->vdata;
    if (v->lastEmittable == e || (rec->vflags & VARIABLE_ALLOC_UNUSE_AFTER_USE))
      unuseVar(v, VARIABLE_STATE_UNUSED);
  }
  //! @overload
  inline void _unuseVarOnEndOfScope(Emittable* e, VarCallRecord* rec)
  {
    VarData* v = rec->vdata;
    if (v->lastEmittable == e || (rec->flags & VarCallRecord::FLAG_UNUSE_AFTER_USE))
      unuseVar(v, VARIABLE_STATE_UNUSED);
  }

  //! @brief Allocate variable (GP).
  void allocGPVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Save variable (GP).
  void saveGPVar(VarData* vdata) ASMJIT_NOTHROW;
  //! @brief Spill variable (GP).
  void spillGPVar(VarData* vdata) ASMJIT_NOTHROW;

  //! @brief Allocate variable (MM).
  void allocMMVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Save variable (MM).
  void saveMMVar(VarData* vdata) ASMJIT_NOTHROW;
  //! @brief Spill variable (MM).
  void spillMMVar(VarData* vdata) ASMJIT_NOTHROW;

  //! @brief Allocate variable (XMM).
  void allocXMMVar(VarData* vdata, uint32_t regMask, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Save variable (XMM).
  void saveXMMVar(VarData* vdata) ASMJIT_NOTHROW;
  //! @brief Spill variable (XMM).
  void spillXMMVar(VarData* vdata) ASMJIT_NOTHROW;

  //! @brief Emit load variable instruction(s).
  void emitLoadVar(VarData* vdata, uint32_t regIndex) ASMJIT_NOTHROW;
  //! @brief Emit save variable instruction(s).
  void emitSaveVar(VarData* vdata, uint32_t regIndex) ASMJIT_NOTHROW;

  //! @brief Emit move variable instruction(s).
  void emitMoveVar(VarData* vdata, uint32_t regIndex, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Emit exchange variable instruction(s).
  void emitExchangeVar(VarData* vdata, uint32_t regIndex, uint32_t vflags, VarData* other) ASMJIT_NOTHROW;

  //! @brief Called each time a variable is alloceted.
  void _postAlloc(VarData* vdata, uint32_t vflags) ASMJIT_NOTHROW;
  //! @brief Marks variable home memory as used (must be called at least once
  //! for each variable that uses function local memory - stack).
  void _markMemoryUsed(VarData* vdata) ASMJIT_NOTHROW;

  Mem _getVarMem(VarData* vdata) ASMJIT_NOTHROW;

  VarData* _getSpillCandidateGP() ASMJIT_NOTHROW;
  VarData* _getSpillCandidateMM() ASMJIT_NOTHROW;
  VarData* _getSpillCandidateXMM() ASMJIT_NOTHROW;
  VarData* _getSpillCandidateGeneric(VarData** varArray, uint32_t count) ASMJIT_NOTHROW;

  inline bool _isActive(VarData* vdata) ASMJIT_NOTHROW { return vdata->nextActive != NULL; }
  void _addActive(VarData* vdata) ASMJIT_NOTHROW;
  void _freeActive(VarData* vdata) ASMJIT_NOTHROW;
  void _freeAllActive() ASMJIT_NOTHROW;

  void _allocatedVariable(VarData* vdata) ASMJIT_NOTHROW;

  inline void _allocatedGPRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedGP |= Util::maskFromIndex(index); _modifiedGPRegisters |= Util::maskFromIndex(index); }
  inline void _allocatedMMRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedMM |= Util::maskFromIndex(index); _modifiedMMRegisters |= Util::maskFromIndex(index); }
  inline void _allocatedXMMRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedXMM |= Util::maskFromIndex(index); _modifiedXMMRegisters |= Util::maskFromIndex(index); }

  inline void _freedGPRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedGP &= ~Util::maskFromIndex(index); }
  inline void _freedMMRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedMM &= ~Util::maskFromIndex(index); }
  inline void _freedXMMRegister(uint32_t index) ASMJIT_NOTHROW { _state.usedXMM &= ~Util::maskFromIndex(index); }

  inline void _markGPRegisterModified(uint32_t index) ASMJIT_NOTHROW { _modifiedGPRegisters |= Util::maskFromIndex(index); }
  inline void _markMMRegisterModified(uint32_t index) ASMJIT_NOTHROW { _modifiedMMRegisters |= Util::maskFromIndex(index); }
  inline void _markXMMRegisterModified(uint32_t index) ASMJIT_NOTHROW { _modifiedXMMRegisters |= Util::maskFromIndex(index); }

  // TODO: Find code which uses this and improve.
  inline void _newRegisterHomeIndex(VarData* vdata, uint32_t idx)
  {
    if (vdata->homeRegisterIndex == INVALID_VALUE) vdata->homeRegisterIndex = idx;
    vdata->prefRegisterMask |= (1U << idx);
  }

  // TODO: Find code which uses this and improve.
  inline void _newRegisterHomeMask(VarData* vdata, uint32_t mask)
  {
    vdata->prefRegisterMask |= mask;
  }

  // --------------------------------------------------------------------------
  // [Operand Patcher]
  // --------------------------------------------------------------------------

  void translateOperands(Operand* operands, uint32_t count) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  inline Compiler* getCompiler() const ASMJIT_NOTHROW { return _compiler; }
  inline EFunction* getFunction() const ASMJIT_NOTHROW { return _function; }

  inline Emittable* getExtraBlock() const ASMJIT_NOTHROW { return _extraBlock; }
  inline void setExtraBlock(Emittable* e) ASMJIT_NOTHROW { _extraBlock = e; }

  // --------------------------------------------------------------------------
  // [Backward Code]
  // --------------------------------------------------------------------------

  void addBackwardCode(EJmp* from) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Forward Jump]
  // --------------------------------------------------------------------------

  void addForwardJump(EJmp* inst) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [State]
  // --------------------------------------------------------------------------

  StateData* _saveState() ASMJIT_NOTHROW;
  void _assignState(StateData* state) ASMJIT_NOTHROW;
  void _restoreState(StateData* state, uint32_t targetOffset = INVALID_VALUE) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Memory Allocator]
  // --------------------------------------------------------------------------

  VarMemBlock* _allocMemBlock(uint32_t size) ASMJIT_NOTHROW;
  void _freeMemBlock(VarMemBlock* mem) ASMJIT_NOTHROW;

  void _allocMemoryOperands() ASMJIT_NOTHROW;
  void _patchMemoryOperands(Emittable* start, Emittable* stop) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Zone memory manager.
  Zone _zone;

  //! @brief Compiler instance.
  Compiler* _compiler;
  //! @brief Function emittable.
  EFunction* _function;

  //! @brief Current active scope start emittable.
  Emittable* _start;
  //! @brief Current active scope end emittable.
  Emittable* _stop;
  //! @brief Emittable that is used to insert some code after the function body.
  Emittable* _extraBlock;

  //! @brief Current state (register allocator).
  StateData _state;
  //! @brief Link to circular double-linked list containing all active variables
  //! (for current state).
  VarData* _active;

  //! @brief Forward jumps (single linked list).
  ForwardJumpData* _forwardJumps;

  //! @brief Current offset, used in prepare() stage. Each emittable should increment it.
  uint32_t _currentOffset;

  //! @brief Whether current code is unreachable.
  uint32_t _unreachable;

  //! @brief Global modified GP registers mask (per function).
  uint32_t _modifiedGPRegisters;
  //! @brief Global modified MM registers mask (per function).
  uint32_t _modifiedMMRegisters;
  //! @brief Global modified XMM registers mask (per function).
  uint32_t _modifiedXMMRegisters;

  //! @brief Whether the EBP/RBP register can be used by register allocator.
  uint32_t _allocableEBP;

  //! @brief ESP adjust constant (changed during PUSH/POP or when using
  //! stack.
  int _adjustESP;

  //! @brief Function arguments base pointer (register).
  uint32_t _argumentsBaseReg;
  //! @brief Function arguments base offset.
  int32_t _argumentsBaseOffset;
  //! @brief Function arguments displacement.
  int32_t _argumentsActualDisp;

  //! @brief Function variables base pointer (register).
  uint32_t _variablesBaseReg;
  //! @brief Function variables base offset.
  int32_t _variablesBaseOffset;
  //! @brief Function variables displacement.
  int32_t _variablesActualDisp;

  //! @brief Used memory blocks (for variables, here is each created mem block
  //! that can be also in _memFree list).
  VarMemBlock* _memUsed;
  //! @brief Free memory blocks (freed, prepared for another allocation).
  VarMemBlock* _memFree;
  //! @brief Count of 4-byte memory blocks used by the function.
  uint32_t _mem4BlocksCount;
  //! @brief Count of 8-byte memory blocks used by the function.
  uint32_t _mem8BlocksCount;
  //! @brief Count of 16-byte memory blocks used by the function.
  uint32_t _mem16BlocksCount;
  //! @brief Count of total bytes of stack memory used by the function.
  uint32_t _memBytesTotal;

  //! @brief Whether to emit comments.
  bool _emitComments;

  //! @brief List of emittables which need to be translated. These emittables
  //! are filled by @c addBackwardCode().
  PodVector<EJmp*> _backCode;
  //! @brief Backward code position (starts at 0).
  sysuint_t _backPos;
};

// ============================================================================
// [AsmJit::CompilerUtil]
// ============================================================================

//! @brief Static class that contains utility methods.
struct ASMJIT_API CompilerUtil
{
  static bool isStack16ByteAligned();
};

// ============================================================================
// [AsmJit::CompilerCore]
// ============================================================================

//! @brief Compiler core.
//!
//! @sa @c AsmJit::Compiler.
struct ASMJIT_API CompilerCore
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new (empty) instance of @c Compiler.
  CompilerCore(CodeGenerator* codeGenerator) ASMJIT_NOTHROW;
  //! @brief Destroy @c Compiler instance.
  virtual ~CompilerCore() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Code Generator]
  // --------------------------------------------------------------------------

  //! @brief Get code generator.
  inline CodeGenerator* getCodeGenerator() const { return _codeGenerator; }

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

  //! @brief Get zone memory manager.
  inline Zone& getZone() { return _zone; }

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  //! @brief Get logger.
  inline Logger* getLogger() const ASMJIT_NOTHROW { return _logger; }

  //! @brief Set logger to @a logger.
  virtual void setLogger(Logger* logger) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Error Handling]
  // --------------------------------------------------------------------------

  //! @brief Get error code.
  inline uint32_t getError() const ASMJIT_NOTHROW { return _error; }

  //! @brief Set error code.
  //!
  //! This method is virtual, because higher classes can use it to catch all
  //! errors.
  virtual void setError(uint32_t error) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Properties]
  // --------------------------------------------------------------------------

  //! @brief Get compiler property.
  uint32_t getProperty(uint32_t propertyId);
  //! @brief Set compiler property.
  void setProperty(uint32_t propertyId, uint32_t value);

  // --------------------------------------------------------------------------
  // [Buffer]
  // --------------------------------------------------------------------------

  //! @brief Clear everything, but not deallocate buffers.
  //!
  //! @note This method will destroy your code.
  void clear() ASMJIT_NOTHROW;

  //! @brief Free internal buffer, all emitters and NULL all pointers.
  //!
  //! @note This method will destroy your code.
  void free() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emittables]
  // --------------------------------------------------------------------------

  //! @brief Get first emittable.
  inline Emittable* getFirstEmittable() const ASMJIT_NOTHROW { return _first; }

  //! @brief Get last emittable.
  inline Emittable* getLastEmittable() const ASMJIT_NOTHROW { return _last; }

  //! @brief Get current emittable.
  //!
  //! @note If this method return @c NULL, it means that nothing emitted yet.
  inline Emittable* getCurrentEmittable() const ASMJIT_NOTHROW { return _current; }

  //! @brief Set new current emittable and return previous one.
  Emittable* setCurrentEmittable(Emittable* current) ASMJIT_NOTHROW;

  //! @brief Add emittable after current and set current to @a emittable.
  void addEmittable(Emittable* emittable) ASMJIT_NOTHROW;

  //! @brief Add emittable after @a ref.
  void addEmittableAfter(Emittable* emittable, Emittable* ref) ASMJIT_NOTHROW;

  //! @brief Remove emittable (and if needed set current to previous).
  void removeEmittable(Emittable* emittable) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Comment]
  // --------------------------------------------------------------------------

  //! @brief Emit a single comment line that will be logged.
  //!
  //! Emitting comments are useful to log something. Because assembler can be
  //! generated from AST or other data structures, you may sometimes need to
  //! log data characteristics or statistics.
  //!
  //! @note Emitting comment is not directly sent to logger, but instead it's
  //! stored in @c AsmJit::Compiler and emitted when @c serialize() method is
  //! called. Each comment keeps correct order.
  void comment(const char* fmt, ...) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Function Builder]
  // --------------------------------------------------------------------------

  //! @brief Create a new function.
  //!
  //! @param cconv Calling convention to use (see @c CALL_CONV enum)
  //! @param params Function arguments prototype.
  //!
  //! This method is usually used as a first step when generating functions
  //! by @c Compiler. First parameter @a cconv specifies function calling
  //! convention to use. Second parameter @a params specifies function
  //! arguments. To create function arguments are used templates
  //! @c BuildFunction0<>, @c BuildFunction1<...>, @c BuildFunction2<...>,
  //! etc...
  //!
  //! Templates with BuildFunction prefix are used to generate argument IDs
  //! based on real C++ types. See next example how to generate function with
  //! two 32-bit integer arguments.
  //!
  //! @code
  //! // Building function using AsmJit::Compiler example.
  //!
  //! // Compiler instance
  //! Compiler c;
  //!
  //! // Begin of function (also emits function @c Prolog)
  //! c.newFunction(
  //!   // Default calling convention (32-bit cdecl or 64-bit for host OS)
  //!   CALL_CONV_DEFAULT,
  //!   // Using function builder to generate arguments list
  //!   BuildFunction2<int, int>());
  //!
  //! // End of function (also emits function @c Epilog)
  //! c.endFunction();
  //! @endcode
  //!
  //! You can see that building functions is really easy. Previous code snipped
  //! will generate code for function with two 32-bit integer arguments. You
  //! can access arguments by @c AsmJit::Function::argument() method. Arguments
  //! are indexed from 0 (like everything in C).
  //!
  //! @code
  //! // Accessing function arguments through AsmJit::Function example.
  //!
  //! // Compiler instance
  //! Compiler c;
  //!
  //! // Begin of function (also emits function @c Prolog)
  //! c.newFunction(
  //!   // Default calling convention (32-bit cdecl or 64-bit for host OS)
  //!   CALL_CONV_DEFAULT,
  //!   // Using function builder to generate arguments list
  //!   BuildFunction2<int, int>());
  //!
  //! // Arguments are like other variables, you need to reference them by
  //! // variable operands:
  //! GPVar a0 = c.argGP(0);
  //! GPVar a1 = c.argGP(1);
  //!
  //! // Use them.
  //! c.add(a0, a1);
  //!
  //! // End of function (emits function epilog and return)
  //! c.endFunction();
  //! @endcode
  //!
  //! Arguments are like variables. How to manipulate with variables is
  //! documented in @c AsmJit::Compiler, variables section.
  //!
  //! @note To get current function use @c currentFunction() method or save
  //! pointer to @c AsmJit::Function returned by @c AsmJit::Compiler::newFunction<>
  //! method. Recommended is to save the pointer.
  //!
  //! @sa @c BuildFunction0, @c BuildFunction1, @c BuildFunction2, ...
  inline EFunction* newFunction(uint32_t cconv, const FunctionDefinition& def) ASMJIT_NOTHROW
  {
    return newFunction_(
      cconv,
      def.getArguments(),
      def.getArgumentsCount(),
      def.getReturnValue());
  }

  //! @brief Create a new function (low level version).
  //!
  //! @param cconv Function calling convention (see @c AsmJit::CALL_CONV).
  //! @param args Function arguments (see @c AsmJit::VARIABLE_TYPE).
  //! @param count Arguments count.
  //!
  //! This method is internally called from @c newFunction() method and
  //! contains arguments thats used internally by @c AsmJit::Compiler.
  //!
  //! @note To get current function use @c currentFunction() method.
  EFunction* newFunction_(
    uint32_t cconv,
    const uint32_t* arguments,
    uint32_t argumentsCount,
    uint32_t returnValue) ASMJIT_NOTHROW;

  //! @brief Get current function.
  //!
  //! This method can be called within @c newFunction() and @c endFunction()
  //! block to get current function you are working with. It's recommended
  //! to store @c AsmJit::Function pointer returned by @c newFunction<> method,
  //! because this allows you in future implement function sections outside of
  //! function itself (yeah, this is possible!).
  inline EFunction* getFunction() const ASMJIT_NOTHROW { return _function; }

  //! @brief End of current function scope and all variables.
  EFunction* endFunction() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Memory Management]
  // --------------------------------------------------------------------------

  inline EInstruction* newInstruction(uint32_t code, Operand* operandsData, uint32_t operandsCount) ASMJIT_NOTHROW
  {
    if (code >= _INST_J_BEGIN && code <= _INST_J_END)
    {
      void* addr = _zone.zalloc(sizeof(EJmp));

      return new(addr) EJmp(
        reinterpret_cast<Compiler*>(this), code, operandsData, operandsCount);
    }
    else
    {
      void* addr = _zone.zalloc(sizeof(EInstruction) + operandsCount * sizeof(Operand));

      return new(addr) EInstruction(
        reinterpret_cast<Compiler*>(this), code, operandsData, operandsCount);
    }
  }

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  //! @brief Emit instruction with no operand.
  void _emitInstruction(uint32_t code) ASMJIT_NOTHROW;

  //! @brief Emit instruction with one operand.
  void _emitInstruction(uint32_t code, const Operand* o0) ASMJIT_NOTHROW;

  //! @brief Emit instruction with two operands.
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1) ASMJIT_NOTHROW;

  //! @brief Emit instruction with three operands.
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2) ASMJIT_NOTHROW;

  //! @brief Emit instruction with four operands (Special instructions).
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2, const Operand* o3) ASMJIT_NOTHROW;

  //! @brief Emit instruction with five operands (Special instructions).
  void _emitInstruction(uint32_t code, const Operand* o0, const Operand* o1, const Operand* o2, const Operand* o3, const Operand* o4) ASMJIT_NOTHROW;

  //! @brief Private method for emitting jcc.
  void _emitJcc(uint32_t code, const Label* label, uint32_t hint) ASMJIT_NOTHROW;

  //! @brief Private method for emitting function call.
  ECall* _emitCall(const Operand* o0) ASMJIT_NOTHROW;

  //! @brief Private method for returning a value from the function.
  void _emitReturn(const Operand* first, const Operand* second) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  //! @brief Embed data into instruction stream.
  void embed(const void* data, sysuint_t len) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Align]
  // --------------------------------------------------------------------------

  //! @brief Align target buffer to @a m bytes.
  //!
  //! Typical usage of this is to align labels at start of the inner loops.
  //!
  //! Inserts @c nop() instructions or CPU optimized NOPs.
  void align(uint32_t m) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Label]
  // --------------------------------------------------------------------------

  //! @brief Create and return new label.
  Label newLabel() ASMJIT_NOTHROW;

  //! @brief Bind label to the current offset.
  //!
  //! @note Label can be bound only once!
  void bind(const Label& label) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Variables]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief Create a new variable data.
  VarData* _newVarData(const char* name, uint32_t type, uint32_t size) ASMJIT_NOTHROW;

  //! @internal
  //!
  //! @brief Get variable data.
  inline VarData* _getVarData(uint32_t id) const ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(id != INVALID_VALUE);
    return _varData[id & OPERAND_ID_VALUE_MASK];
  }

  //! @brief Create a new general-purpose variable.
  GPVar newGP(uint32_t variableType = VARIABLE_TYPE_GPN, const char* name = NULL) ASMJIT_NOTHROW;
  //! @brief Get argument as general-purpose variable.
  GPVar argGP(uint32_t index) ASMJIT_NOTHROW;

  //! @brief Create a new MM variable.
  MMVar newMM(uint32_t variableType = VARIABLE_TYPE_MM, const char* name = NULL) ASMJIT_NOTHROW;
  //! @brief Get argument as MM variable.
  MMVar argMM(uint32_t index) ASMJIT_NOTHROW;

  //! @brief Create a new XMM variable.
  XMMVar newXMM(uint32_t variableType = VARIABLE_TYPE_XMM, const char* name = NULL) ASMJIT_NOTHROW;
  //! @brief Get argument as XMM variable.
  XMMVar argXMM(uint32_t index) ASMJIT_NOTHROW;

  //! @internal
  //!
  //! @brief Serialize variable hint.
  void _vhint(BaseVar& var, uint32_t hintId, uint32_t hintValue) ASMJIT_NOTHROW;

  //! @brief Alloc variable @a var.
  void alloc(BaseVar& var) ASMJIT_NOTHROW;
  //! @brief Alloc variable @a var using @a regIndex as a register index.
  void alloc(BaseVar& var, uint32_t regIndex) ASMJIT_NOTHROW;
  //! @brief Alloc variable @a var using @a reg as a demanded register.
  void alloc(BaseVar& var, const BaseReg& reg) ASMJIT_NOTHROW;
  //! @brief Spill variable @a var.
  void spill(BaseVar& var) ASMJIT_NOTHROW;
  //! @brief Save variable @a var if modified.
  void save(BaseVar& var) ASMJIT_NOTHROW;
  //! @brief Unuse variable @a var.
  void unuse(BaseVar& var) ASMJIT_NOTHROW;

  //! @brief Get memory home of variable @a var.
  void getMemoryHome(BaseVar& var, GPVar* home, int* displacement = NULL);

  //! @brief Set memory home of variable @a var.
  //!
  //! Default memory home location is on stack (ESP/RSP), but when needed the
  //! bebahior can be changed by this method.
  //!
  //! It is an error to chaining memory home locations. For example the given 
  //! code is invalid:
  //!
  //! @code
  //! Compiler c;
  //!
  //! ...
  //! GPVar v0 = c.newGP();
  //! GPVar v1 = c.newGP();
  //! GPVar v2 = c.newGP();
  //! GPVar v3 = c.newGP();
  //!
  //! c.setMemoryHome(v1, v0, 0); // Allowed, [v0] is memory home for v1.
  //! c.setMemoryHome(v2, v0, 4); // Allowed, [v0+4] is memory home for v2.
  //! c.setMemoryHome(v3, v2);    // CHAINING, NOT ALLOWED!
  //! @endcode
  void setMemoryHome(BaseVar& var, const GPVar& home, int displacement = 0);

  //! @brief Get priority of variable @a var.
  uint32_t getPriority(BaseVar& var) const ASMJIT_NOTHROW;
  //! @brief Set priority of variable @a var to @a priority.
  void setPriority(BaseVar& var, uint32_t priority) ASMJIT_NOTHROW;

  //! @brief Get save-on-unuse @a var property.
  bool getSaveOnUnuse(BaseVar& var) const ASMJIT_NOTHROW;
  //! @brief Set save-on-unuse @a var property to @a value.
  void setSaveOnUnuse(BaseVar& var, bool value) ASMJIT_NOTHROW;

  //! @brief Rename variable @a var to @a name.
  //!
  //! @note Only new name will appear in the logger.
  void rename(BaseVar& var, const char* name) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [State]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief Create a new @ref StateData instance.
  StateData* _newStateData(uint32_t memVarsCount) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Make]
  // --------------------------------------------------------------------------

  //! @brief Make is convenience method to make currently serialized code and
  //! return pointer to generated function.
  //!
  //! What you need is only to cast this pointer to your function type and call
  //! it. Note that if there was an error and calling @c getError() method not
  //! returns @c ERROR_NONE (zero) then this function always return @c NULL and
  //! error value remains the same.
  virtual void* make() ASMJIT_NOTHROW;

  //! @brief Method that will emit everything to @c Assembler instance @a a.
  virtual void serialize(Assembler& a) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Data]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief Get target (emittable) from operand @a id (label id).
  inline ETarget* _getTarget(uint32_t id)
  {
    ASMJIT_ASSERT((id & OPERAND_ID_TYPE_MASK) == OPERAND_ID_TYPE_LABEL);
    return _targetData[id & OPERAND_ID_VALUE_MASK];
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:

  //! @brief Zone memory management.
  Zone _zone;

  //! @brief Code generator.
  CodeGenerator* _codeGenerator;

  //! @brief Logger.
  Logger* _logger;

  //! @brief Last error code.
  uint32_t _error;

  //! @brief Properties.
  uint32_t _properties;

  //! @brief Contains options for next emitted instruction, clear after each emit.
  uint32_t _emitOptions;

  //! @brief Whether compiler was finished the job (register allocator, etc...).
  uint32_t _finished;

  //! @brief First emittable.
  Emittable* _first;
  //! @brief Last emittable.
  Emittable* _last;
  //! @brief Current emittable.
  Emittable* _current;

  //! @brief Current function.
  EFunction* _function;

  //! @brief Label data.
  PodVector<ETarget*> _targetData;

  //! @brief Variable data.
  PodVector<VarData*> _varData;

  //! @brief Variable name id (used to generate unique names per function).
  int _varNameId;

  //! @brief Compiler context instance, only available after prepare().
  CompilerContext* _cc;

  friend struct BaseVar;
  friend struct CompilerContext;
  friend struct EFunction;
  friend struct EInstruction;
};

// ============================================================================
// [AsmJit::CompilerIntrinsics]
// ============================================================================

//! @brief Implementation of @c Compiler intrinsics.
//!
//! Methods in this class are implemented here, because we wan't to hide them
//! in shared libraries. These methods should be never exported by C++ compiler.
//!
//! @sa @c AsmJit::Compiler.
struct ASMJIT_HIDDEN CompilerIntrinsics : public CompilerCore
{
  // Special X86 instructions:
  // - cpuid,
  // - cbw, cwde, cdqe,
  // - cmpxchg
  // - cmpxchg8b, cmpxchg16b,
  // - daa, das,
  // - imul, mul, idiv, div,
  // - mov_ptr
  // - lahf, sahf
  // - maskmovq, maskmovdqu
  // - enter, leave
  // - ret
  // - monitor, mwait
  // - pop, popad, popfd, popfq,
  // - push, pushad, pushfd, pushfq
  // - rcl, rcr, rol, ror, sal, sar, shl, shr
  // - shld, shrd
  // - rdtsc. rdtscp
  // - lodsb, lodsd, lodsq, lodsw
  // - movsb, movsd, movsq, movsw
  // - stosb, stosd, stosq, stosw
  // - cmpsb, cmpsd, cmpsq, cmpsw
  // - scasb, scasd, scasq, scasw
  //
  // Special X87 instructions:
  // - fisttp

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create @c CompilerIntrinsics instance. Always use @c AsmJit::Compiler.
  inline CompilerIntrinsics(CodeGenerator* codeGenerator) ASMJIT_NOTHROW : 
    CompilerCore(codeGenerator)
  {
  }

  // --------------------------------------------------------------------------
  // [Embed]
  // --------------------------------------------------------------------------

  //! @brief Add 8-bit integer data to the instuction stream.
  inline void db(uint8_t  x) ASMJIT_NOTHROW { embed(&x, 1); }
  //! @brief Add 16-bit integer data to the instuction stream.
  inline void dw(uint16_t x) ASMJIT_NOTHROW { embed(&x, 2); }
  //! @brief Add 32-bit integer data to the instuction stream.
  inline void dd(uint32_t x) ASMJIT_NOTHROW { embed(&x, 4); }
  //! @brief Add 64-bit integer data to the instuction stream.
  inline void dq(uint64_t x) ASMJIT_NOTHROW { embed(&x, 8); }

  //! @brief Add 8-bit integer data to the instuction stream.
  inline void dint8(int8_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int8_t)); }
  //! @brief Add 8-bit integer data to the instuction stream.
  inline void duint8(uint8_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint8_t)); }

  //! @brief Add 16-bit integer data to the instuction stream.
  inline void dint16(int16_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int16_t)); }
  //! @brief Add 16-bit integer data to the instuction stream.
  inline void duint16(uint16_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint16_t)); }

  //! @brief Add 32-bit integer data to the instuction stream.
  inline void dint32(int32_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int32_t)); }
  //! @brief Add 32-bit integer data to the instuction stream.
  inline void duint32(uint32_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint32_t)); }

  //! @brief Add 64-bit integer data to the instuction stream.
  inline void dint64(int64_t x) ASMJIT_NOTHROW { embed(&x, sizeof(int64_t)); }
  //! @brief Add 64-bit integer data to the instuction stream.
  inline void duint64(uint64_t x) ASMJIT_NOTHROW { embed(&x, sizeof(uint64_t)); }

  //! @brief Add system-integer data to the instuction stream.
  inline void dsysint(sysint_t x) ASMJIT_NOTHROW { embed(&x, sizeof(sysint_t)); }
  //! @brief Add system-integer data to the instuction stream.
  inline void dsysuint(sysuint_t x) ASMJIT_NOTHROW { embed(&x, sizeof(sysuint_t)); }

  //! @brief Add float data to the instuction stream.
  inline void dfloat(float x) ASMJIT_NOTHROW { embed(&x, sizeof(float)); }
  //! @brief Add double data to the instuction stream.
  inline void ddouble(double x) ASMJIT_NOTHROW { embed(&x, sizeof(double)); }

  //! @brief Add pointer data to the instuction stream.
  inline void dptr(void* x) ASMJIT_NOTHROW { embed(&x, sizeof(void*)); }

  //! @brief Add MM data to the instuction stream.
  inline void dmm(const MMData& x) ASMJIT_NOTHROW { embed(&x, sizeof(MMData)); }
  //! @brief Add XMM data to the instuction stream.
  inline void dxmm(const XMMData& x) ASMJIT_NOTHROW { embed(&x, sizeof(XMMData)); }

  //! @brief Add data to the instuction stream.
  inline void data(const void* data, sysuint_t size) ASMJIT_NOTHROW { embed(data, size); }

  //! @brief Add data in a given structure instance to the instuction stream.
  template<typename T>
  inline void dstruct(const T& x) ASMJIT_NOTHROW { embed(&x, sizeof(T)); }

  // --------------------------------------------------------------------------
  // [Custom Instructions]
  // --------------------------------------------------------------------------

  // These emitters are used by custom compiler code (register alloc / spill,
  // prolog / epilog generator, ...).

  inline void emit(uint32_t code) ASMJIT_NOTHROW
  {
    _emitInstruction(code);
  }

  inline void emit(uint32_t code, const Operand& o0) ASMJIT_NOTHROW
  {
    _emitInstruction(code, &o0);
  }

  inline void emit(uint32_t code, const Operand& o0, const Operand& o1) ASMJIT_NOTHROW
  {
    _emitInstruction(code, &o0, &o1);
  }

  inline void emit(uint32_t code, const Operand& o0, const Operand& o1, const Operand& o2) ASMJIT_NOTHROW
  {
    _emitInstruction(code, &o0, &o1, &o2);
  }

  // --------------------------------------------------------------------------
  // [X86 Instructions]
  // --------------------------------------------------------------------------

  //! @brief Add with Carry.
  inline void adc(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }
  //! @brief Add with Carry.
  inline void adc(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ADC, &dst, &src);
  }

  //! @brief Add.
  inline void add(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }
  //! @brief Add.
  inline void add(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ADD, &dst, &src);
  }

  //! @brief Logical And.
  inline void and_(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }
  //! @brief Logical And.
  inline void and_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_AND, &dst, &src);
  }

  //! @brief Bit Scan Forward.
  inline void bsf(const GPVar& dst, const GPVar& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSF, &dst, &src);
  }
  //! @brief Bit Scan Forward.
  inline void bsf(const GPVar& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSF, &dst, &src);
  }

  //! @brief Bit Scan Reverse.
  inline void bsr(const GPVar& dst, const GPVar& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSR, &dst, &src);
  }
  //! @brief Bit Scan Reverse.
  inline void bsr(const GPVar& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_BSR, &dst, &src);
  }

  //! @brief Byte swap (32-bit or 64-bit registers only) (i486).
  inline void bswap(const GPVar& dst)
  {
    // ASMJIT_ASSERT(dst.getRegType() == REG_GPD || dst.getRegType() == REG_GPQ);
    _emitInstruction(INST_BSWAP, &dst);
  }

  //! @brief Bit test.
  inline void bt(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }
  //! @brief Bit test.
  inline void bt(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BT, &dst, &src);
  }

  //! @brief Bit test and complement.
  inline void btc(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }
  //! @brief Bit test and complement.
  inline void btc(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTC, &dst, &src);
  }

  //! @brief Bit test and reset.
  inline void btr(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }
  //! @brief Bit test and reset.
  inline void btr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTR, &dst, &src);
  }

  //! @brief Bit test and set.
  inline void bts(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }
  //! @brief Bit test and set.
  inline void bts(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_BTS, &dst, &src);
  }

  //! @brief Call Procedure.
  inline ECall* call(const GPVar& dst)
  {
    return _emitCall(&dst);
  }
  //! @brief Call Procedure.
  inline ECall* call(const Mem& dst)
  {
    return _emitCall(&dst);
  }
  //! @brief Call Procedure.
  inline ECall* call(const Imm& dst)
  {
    return _emitCall(&dst);
  }
  //! @brief Call Procedure.
  //! @overload
  inline ECall* call(void* dst)
  {
    Imm imm((sysint_t)dst);
    return _emitCall(&imm);
  }

  //! @brief Call Procedure.
  inline ECall* call(const Label& label)
  {
    return _emitCall(&label);
  }

  //! @brief Convert Byte to Word (Sign Extend).
  inline void cbw(const GPVar& dst)
  {
    _emitInstruction(INST_CBW, &dst);
  }

  //! @brief Convert Word to DWord (Sign Extend).
  inline void cwde(const GPVar& dst)
  {
    _emitInstruction(INST_CWDE, &dst);
  }

#if defined(ASMJIT_X64)
  //! @brief Convert DWord to QWord (Sign Extend).
  inline void cdqe(const GPVar& dst)
  {
    _emitInstruction(INST_CDQE, &dst);
  }
#endif // ASMJIT_X64

  //! @brief Clear Carry flag
  //!
  //! This instruction clears the CF flag in the EFLAGS register.
  inline void clc()
  {
    _emitInstruction(INST_CLC);
  }

  //! @brief Clear Direction flag
  //!
  //! This instruction clears the DF flag in the EFLAGS register.
  inline void cld()
  {
    _emitInstruction(INST_CLD);
  }

  //! @brief Complement Carry Flag.
  //!
  //! This instruction complements the CF flag in the EFLAGS register.
  //! (CF = NOT CF)
  inline void cmc()
  {
    _emitInstruction(INST_CMC);
  }

  //! @brief Conditional Move.
  inline void cmov(CONDITION cc, const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(ConditionToInstruction::toCMovCC(cc), &dst, &src);
  }

  //! @brief Conditional Move.
  inline void cmov(CONDITION cc, const GPVar& dst, const Mem& src)
  {
    _emitInstruction(ConditionToInstruction::toCMovCC(cc), &dst, &src);
  }

  //! @brief Conditional Move.
  inline void cmova  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVA  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmova  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVA  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovae (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVAE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovae (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVAE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovb  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVB  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovb  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVB  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovbe (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVBE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovbe (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVBE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovc  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVC  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovc  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVC  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmove  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVE  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmove  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVE  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovg  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVG  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovg  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVG  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovge (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVGE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovge (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVGE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovl  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVL  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovl  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVL  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovle (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVLE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovle (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVLE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovna (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNA , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovna (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNA , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnae(const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNAE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnae(const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNAE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnb (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNB , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnb (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNB , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnbe(const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNBE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnbe(const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNBE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnc (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNC , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnc (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNC , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovne (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovne (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovng (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNG , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovng (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNG , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnge(const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNGE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnge(const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNGE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnl (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNL , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnl (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNL , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnle(const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNLE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnle(const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNLE, &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovno (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovno (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnp (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNP , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnp (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNP , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovns (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNS , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovns (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNS , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnz (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVNZ , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovnz (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVNZ , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovo  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVO  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovo  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVO  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovp  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVP  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovp  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVP  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpe (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVPE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpe (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVPE , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpo (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVPO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovpo (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVPO , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovs  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVS  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovs  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVS  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovz  (const GPVar& dst, const GPVar& src) { _emitInstruction(INST_CMOVZ  , &dst, &src); }
  //! @brief Conditional Move.
  inline void cmovz  (const GPVar& dst, const Mem& src)   { _emitInstruction(INST_CMOVZ  , &dst, &src); }

  //! @brief Compare Two Operands.
  inline void cmp(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }
  //! @brief Compare Two Operands.
  inline void cmp(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_CMP, &dst, &src);
  }

  //! @brief Compare and Exchange (i486).
  inline void cmpxchg(const GPVar cmp_1_eax, const GPVar& cmp_2, const GPVar& src)
  {
    ASMJIT_ASSERT(cmp_1_eax.getId() != src.getId());
    _emitInstruction(INST_CMPXCHG, &cmp_1_eax, &cmp_2, &src);
  }
  //! @brief Compare and Exchange (i486).
  inline void cmpxchg(const GPVar cmp_1_eax, const Mem& cmp_2, const GPVar& src)
  {
    ASMJIT_ASSERT(cmp_1_eax.getId() != src.getId());
    _emitInstruction(INST_CMPXCHG, &cmp_1_eax, &cmp_2, &src);
  }

  //! @brief Compares the 64-bit value in EDX:EAX with the memory operand (Pentium).
  //!
  //! If the values are equal, then this instruction stores the 64-bit value
  //! in ECX:EBX into the memory operand and sets the zero flag. Otherwise,
  //! this instruction copies the 64-bit memory operand into the EDX:EAX
  //! registers and clears the zero flag.
  inline void cmpxchg8b(
    const GPVar& cmp_edx, const GPVar& cmp_eax,
    const GPVar& cmp_ecx, const GPVar& cmp_ebx,
    const Mem& dst)
  {
    ASMJIT_ASSERT(cmp_edx.getId() != cmp_eax.getId() &&
                  cmp_eax.getId() != cmp_ecx.getId() &&
                  cmp_ecx.getId() != cmp_ebx.getId());

    _emitInstruction(INST_CMPXCHG8B, &cmp_edx, &cmp_eax, &cmp_ecx, &cmp_ebx, &dst);
  }

#if defined(ASMJIT_X64)
  //! @brief Compares the 128-bit value in RDX:RAX with the memory operand (X64).
  //!
  //! If the values are equal, then this instruction stores the 128-bit value
  //! in RCX:RBX into the memory operand and sets the zero flag. Otherwise,
  //! this instruction copies the 128-bit memory operand into the RDX:RAX
  //! registers and clears the zero flag.
  inline void cmpxchg16b(
    const GPVar& cmp_edx, const GPVar& cmp_eax,
    const GPVar& cmp_ecx, const GPVar& cmp_ebx,
    const Mem& dst)
  {
    ASMJIT_ASSERT(cmp_edx.getId() != cmp_eax.getId() &&
                  cmp_eax.getId() != cmp_ecx.getId() &&
                  cmp_ecx.getId() != cmp_ebx.getId());

    _emitInstruction(INST_CMPXCHG16B, &cmp_edx, &cmp_eax, &cmp_ecx, &cmp_ebx, &dst);
  }
#endif // ASMJIT_X64

  //! @brief CPU Identification (i486).
  inline void cpuid(
    const GPVar& inout_eax,
    const GPVar& out_ebx,
    const GPVar& out_ecx,
    const GPVar& out_edx)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(inout_eax.getId() != out_ebx.getId() &&
                  out_ebx.getId() != out_ecx.getId() &&
                  out_ecx.getId() != out_edx.getId());

    _emitInstruction(INST_CPUID, &inout_eax, &out_ebx, &out_ecx, &out_edx);
  }

#if defined(ASMJIT_X86)
  inline void daa(const GPVar& dst)
  {
    _emitInstruction(INST_DAA, &dst);
  }
#endif // ASMJIT_X86

#if defined(ASMJIT_X86)
  inline void das(const GPVar& dst)
  {
    _emitInstruction(INST_DAS, &dst);
  }
#endif // ASMJIT_X86

  //! @brief Decrement by 1.
  //! @note This instruction can be slower than sub(dst, 1)
  inline void dec(const GPVar& dst)
  {
    _emitInstruction(INST_DEC, &dst);
  }
  //! @brief Decrement by 1.
  //! @note This instruction can be slower than sub(dst, 1)
  inline void dec(const Mem& dst)
  {
    _emitInstruction(INST_DEC, &dst);
  }

  //! @brief Unsigned divide.
  //!
  //! This instruction divides (unsigned) the value in the AL, AX, or EAX
  //! register by the source operand and stores the result in the AX,
  //! DX:AX, or EDX:EAX registers.
  inline void div(const GPVar& dst_rem, const GPVar& dst_quot, const GPVar& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_rem.getId() != dst_quot.getId());

    _emitInstruction(INST_DIV, &dst_rem, &dst_quot, &src);
  }
  //! @brief Unsigned divide.
  //! @overload
  inline void div(const GPVar& dst_rem, const GPVar& dst_quot, const Mem& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_rem.getId() != dst_quot.getId());

    _emitInstruction(INST_DIV, &dst_rem, &dst_quot, &src);
  }

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
  //! @brief Make Stack Frame for Procedure Parameters.
  inline void enter(const Imm& imm16, const Imm& imm8)
  {
    _emitInstruction(INST_ENTER, &imm16, &imm8);
  }
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

  //! @brief Signed divide.
  //!
  //! This instruction divides (signed) the value in the AL, AX, or EAX
  //! register by the source operand and stores the result in the AX,
  //! DX:AX, or EDX:EAX registers.
  inline void idiv(const GPVar& dst_rem, const GPVar& dst_quot, const GPVar& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_rem.getId() != dst_quot.getId());

    _emitInstruction(INST_IDIV, &dst_rem, &dst_quot, &src);
  }
  //! @brief Signed divide.
  //! @overload
  inline void idiv(const GPVar& dst_rem, const GPVar& dst_quot, const Mem& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_rem.getId() != dst_quot.getId());

    _emitInstruction(INST_IDIV, &dst_rem, &dst_quot, &src);
  }

  //! @brief Signed multiply.
  //!
  //! [dst_lo:dst_hi] = dst_hi * src.
  inline void imul(const GPVar& dst_hi, const GPVar& dst_lo, const GPVar& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_hi.getId() != dst_lo.getId());

    _emitInstruction(INST_IMUL, &dst_hi, &dst_lo, &src);
  }
  //! @overload
  inline void imul(const GPVar& dst_hi, const GPVar& dst_lo, const Mem& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_hi.getId() != dst_lo.getId());

    _emitInstruction(INST_IMUL, &dst_hi, &dst_lo, &src);
  }

  //! @brief Signed multiply.
  //!
  //! Destination operand (the first operand) is multiplied by the source
  //! operand (second operand). The destination operand is a general-purpose
  //! register and the source operand is an immediate value, a general-purpose
  //! register, or a memory location. The product is then stored in the
  //! destination operand location.
  inline void imul(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }
  //! @brief Signed multiply.
  //! @overload
  inline void imul(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }
  //! @brief Signed multiply.
  //! @overload
  inline void imul(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_IMUL, &dst, &src);
  }

  //! @brief Signed multiply.
  //!
  //! source operand (which can be a general-purpose register or a memory
  //! location) is multiplied by the second source operand (an immediate
  //! value). The product is then stored in the destination operand
  //! (a general-purpose register).
  inline void imul(const GPVar& dst, const GPVar& src, const Imm& imm)
  {
    _emitInstruction(INST_IMUL, &dst, &src, &imm);
  }
  //! @overload
  inline void imul(const GPVar& dst, const Mem& src, const Imm& imm)
  {
    _emitInstruction(INST_IMUL, &dst, &src, &imm);
  }

  //! @brief Increment by 1.
  //! @note This instruction can be slower than add(dst, 1)
  inline void inc(const GPVar& dst)
  {
    _emitInstruction(INST_INC, &dst);
  }
  //! @brief Increment by 1.
  //! @note This instruction can be slower than add(dst, 1)
  inline void inc(const Mem& dst)
  {
    _emitInstruction(INST_INC, &dst);
  }

  //! @brief Interrupt 3 - trap to debugger.
  inline void int3()
  {
    _emitInstruction(INST_INT3);
  }

  //! @brief Jump to label @a label if condition @a cc is met.
  //!
  //! This instruction checks the state of one or more of the status flags in
  //! the EFLAGS register (CF, OF, PF, SF, and ZF) and, if the flags are in the
  //! specified state (condition), performs a jump to the target instruction
  //! specified by the destination operand. A condition code (cc) is associated
  //! with each instruction to indicate the condition being tested for. If the
  //! condition is not satisfied, the jump is not performed and execution
  //! continues with the instruction following the Jcc instruction.
  inline void j(CONDITION cc, const Label& label, uint32_t hint = HINT_NONE)
  {
    _emitJcc(ConditionToInstruction::toJCC(cc), &label, hint);
  }

  //! @brief Jump to label @a label if condition is met.
  inline void ja  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JA  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jae (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JAE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jb  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JB  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jbe (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JBE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jc  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JC  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void je  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JE  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jg  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JG  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jge (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JGE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jl  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JL  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jle (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JLE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jna (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNA , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnae(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNAE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnb (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNB , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnbe(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNBE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnc (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNC , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jne (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jng (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNG , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnge(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNGE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnl (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNL , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnle(const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNLE, &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jno (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNO , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnp (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNP , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jns (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNS , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jnz (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JNZ , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jo  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JO  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jp  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JP  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jpe (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JPE , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jpo (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JPO , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void js  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JS  , &label, hint); }
  //! @brief Jump to label @a label if condition is met.
  inline void jz  (const Label& label, uint32_t hint = HINT_NONE) { _emitJcc(INST_JZ  , &label, hint); }

  //! @brief Jump.
  //! @overload
  inline void jmp(const GPVar& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }
  //! @brief Jump.
  //! @overload
  inline void jmp(const Mem& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }
  //! @brief Jump.
  //! @overload
  inline void jmp(const Imm& dst)
  {
    _emitInstruction(INST_JMP, &dst);
  }

  //! @brief Jump.
  //! @overload
  inline void jmp(void* dst)
  {
    Imm imm((sysint_t)dst);
    _emitInstruction(INST_JMP, &imm);
  }

  //! @brief Jump.
  //!
  //! This instruction transfers program control to a different point
  //! in the instruction stream without recording return information.
  //! The destination (target) operand specifies the label of the
  //! instruction being jumped to.
  inline void jmp(const Label& label)
  {
    _emitInstruction(INST_JMP, &label);
  }
  //! @brief Load Effective Address
  //!
  //! This instruction computes the effective address of the second
  //! operand (the source operand) and stores it in the first operand
  //! (destination operand). The source operand is a memory address
  //! (offset part) specified with one of the processors addressing modes.
  //! The destination operand is a general-purpose register.
  inline void lea(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_LEA, &dst, &src);
  }

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
  //! @brief High Level Procedure Exit.
  inline void leave()
  {
    _emitInstruction(INST_LEAVE);
  }
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

  //! @brief Move.
  //!
  //! This instruction copies the second operand (source operand) to the first
  //! operand (destination operand). The source operand can be an immediate
  //! value, general-purpose register, segment register, or memory location.
  //! The destination register can be a general-purpose register, segment
  //! register, or memory location. Both operands must be the same size, which
  //! can be a byte, a word, or a DWORD.
  //!
  //! @note To move MMX or SSE registers to/from GP registers or memory, use
  //! corresponding functions: @c movd(), @c movq(), etc. Passing MMX or SSE
  //! registers to @c mov() is illegal.
  inline void mov(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  //! @brief Move.
  //! @overload
  inline void mov(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move from segment register.
  //! @overload.
  inline void mov(const GPVar& dst, const SegmentReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }
  
  //! @brief Move from segment register.
  //! @overload.
  inline void mov(const Mem& dst, const SegmentReg& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move to segment register.
  //! @overload.
  inline void mov(const SegmentReg& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move to segment register.
  //! @overload.
  inline void mov(const SegmentReg& dst, const Mem& src)
  {
    _emitInstruction(INST_MOV, &dst, &src);
  }

  //! @brief Move byte, word, dword or qword from absolute address @a src to
  //! AL, AX, EAX or RAX register.
  inline void mov_ptr(const GPVar& dst, void* src)
  {
    Imm imm((sysint_t)src);
    _emitInstruction(INST_MOV_PTR, &dst, &imm);
  }

  //! @brief Move byte, word, dword or qword from AL, AX, EAX or RAX register
  //! to absolute address @a dst.
  inline void mov_ptr(void* dst, const GPVar& src)
  {
    Imm imm((sysint_t)dst);
    _emitInstruction(INST_MOV_PTR, &imm, &src);
  }

  //! @brief Move with Sign-Extension.
  //!
  //! This instruction copies the contents of the source operand (register
  //! or memory location) to the destination operand (register) and sign
  //! extends the value to 16, 32 or 64-bits.
  //!
  //! @sa movsxd().
  void movsx(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVSX, &dst, &src);
  }
  //! @brief Move with Sign-Extension.
  //! @overload
  void movsx(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSX, &dst, &src);
  }

#if defined(ASMJIT_X64)
  //! @brief Move DWord to QWord with sign-extension.
  inline void movsxd(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVSXD, &dst, &src);
  }
  //! @brief Move DWord to QWord with sign-extension.
  //! @overload
  inline void movsxd(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSXD, &dst, &src);
  }
#endif // ASMJIT_X64

  //! @brief Move with Zero-Extend.
  //!
  //! This instruction copies the contents of the source operand (register
  //! or memory location) to the destination operand (register) and zero
  //! extends the value to 16 or 32-bits. The size of the converted value
  //! depends on the operand-size attribute.
  inline void movzx(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVZX, &dst, &src);
  }
  //! @brief Move with Zero-Extend.
  //! @brief Overload
  inline void movzx(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVZX, &dst, &src);
  }

  //! @brief Unsigned multiply.
  //!
  //! Source operand (in a general-purpose register or memory location)
  //! is multiplied by the value in the AL, AX, or EAX register (depending
  //! on the operand size) and the product is stored in the AX, DX:AX, or
  //! EDX:EAX registers, respectively.
  inline void mul(const GPVar& dst_hi, const GPVar& dst_lo, const GPVar& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_hi.getId() != dst_lo.getId());

    _emitInstruction(INST_MUL, &dst_hi, &dst_lo, &src);
  }
  //! @brief Unsigned multiply.
  //! @overload
  inline void mul(const GPVar& dst_hi, const GPVar& dst_lo, const Mem& src)
  {
    // Destination variables must be different.
    ASMJIT_ASSERT(dst_hi.getId() != dst_lo.getId());

    _emitInstruction(INST_MUL, &dst_hi, &dst_lo, &src);
  }

  //! @brief Two's Complement Negation.
  inline void neg(const GPVar& dst)
  {
    _emitInstruction(INST_NEG, &dst);
  }
  //! @brief Two's Complement Negation.
  inline void neg(const Mem& dst)
  {
    _emitInstruction(INST_NEG, &dst);
  }

  //! @brief No Operation.
  //!
  //! This instruction performs no operation. This instruction is a one-byte
  //! instruction that takes up space in the instruction stream but does not
  //! affect the machine context, except the EIP register. The NOP instruction
  //! is an alias mnemonic for the XCHG (E)AX, (E)AX instruction.
  inline void nop()
  {
    _emitInstruction(INST_NOP);
  }

  //! @brief One's Complement Negation.
  inline void not_(const GPVar& dst)
  {
    _emitInstruction(INST_NOT, &dst);
  }
  //! @brief One's Complement Negation.
  inline void not_(const Mem& dst)
  {
    _emitInstruction(INST_NOT, &dst);
  }

  //! @brief Logical Inclusive OR.
  inline void or_(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }
  //! @brief Logical Inclusive OR.
  inline void or_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_OR, &dst, &src);
  }

  //! @brief Pop a Value from the Stack.
  //!
  //! This instruction loads the value from the top of the stack to the location
  //! specified with the destination operand and then increments the stack pointer.
  //! The destination operand can be a general purpose register, memory location,
  //! or segment register.
  inline void pop(const GPVar& dst)
  {
    _emitInstruction(INST_POP, &dst);
  }

  inline void pop(const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 2 || dst.getSize() == sizeof(sysint_t));
    _emitInstruction(INST_POP, &dst);
  }

#if defined(ASMJIT_X86)
  //! @brief Pop All General-Purpose Registers.
  //!
  //! Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX.
  inline void popad()
  {
    _emitInstruction(INST_POPAD);
  }
#endif // ASMJIT_X86

  //! @brief Pop Stack into EFLAGS Register (32-bit or 64-bit).
  inline void popf()
  {
#if defined(ASMJIT_X86)
    popfd();
#else
    popfq();
#endif
  }

#if defined(ASMJIT_X86)
  //! @brief Pop Stack into EFLAGS Register (32-bit).
  inline void popfd() { _emitInstruction(INST_POPFD); }
#else
  //! @brief Pop Stack into EFLAGS Register (64-bit).
  inline void popfq() { _emitInstruction(INST_POPFQ); }
#endif

  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  //!
  //! @note 32-bit architecture pushed DWORD while 64-bit
  //! pushes QWORD. 64-bit mode not provides instruction to
  //! push 32-bit register/memory.
  inline void push(const GPVar& src)
  {
    _emitInstruction(INST_PUSH, &src);
  }
  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  inline void push(const Mem& src)
  {
    ASMJIT_ASSERT(src.getSize() == 2 || src.getSize() == sizeof(sysint_t));
    _emitInstruction(INST_PUSH, &src);
  }
  //! @brief Push WORD/DWORD/QWORD Onto the Stack.
  inline void push(const Imm& src)
  {
    _emitInstruction(INST_PUSH, &src);
  }

#if defined(ASMJIT_X86)
  //! @brief Push All General-Purpose Registers.
  //!
  //! Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI.
  inline void pushad()
  {
    _emitInstruction(INST_PUSHAD);
  }
#endif // ASMJIT_X86

  //! @brief Push EFLAGS Register (32-bit or 64-bit) onto the Stack.
  inline void pushf()
  {
#if defined(ASMJIT_X86)
    pushfd();
#else
    pushfq();
#endif
  }

#if defined(ASMJIT_X86)
  //! @brief Push EFLAGS Register (32-bit) onto the Stack.
  inline void pushfd() { _emitInstruction(INST_PUSHFD); }
#else
  //! @brief Push EFLAGS Register (64-bit) onto the Stack.
  inline void pushfq() { _emitInstruction(INST_PUSHFQ); }
#endif // ASMJIT_X86

  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rcl(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rcl(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rcl(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rcl(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_RCL, &dst, &src);
  }

  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void rcr(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void rcr(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void rcr(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void rcr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_RCR, &dst, &src);
  }

  //! @brief Read Time-Stamp Counter (Pentium).
  inline void rdtsc(const GPVar& dst_edx, const GPVar& dst_eax)
  {
    // Destination registers must be different.
    ASMJIT_ASSERT(dst_edx.getId() != dst_eax.getId());

    _emitInstruction(INST_RDTSC, &dst_edx, &dst_eax);
  }

  //! @brief Read Time-Stamp Counter and Processor ID (New).
  inline void rdtscp(const GPVar& dst_edx, const GPVar& dst_eax, const GPVar& dst_ecx)
  {
    // Destination registers must be different.
    ASMJIT_ASSERT(dst_edx.getId() != dst_eax.getId() &&
                  dst_eax.getId() != dst_ecx.getId());

    _emitInstruction(INST_RDTSCP, &dst_edx, &dst_eax, &dst_ecx);
  }

  //! @brief Load ECX/RCX BYTEs from DS:[ESI/RSI] to AL.
  inline void rep_lodsb(const GPVar& dst_val, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_LODSB, &dst_val, &src_addr, &cnt_ecx);
  }

  //! @brief Load ECX/RCX DWORDs from DS:[ESI/RSI] to EAX.
  inline void rep_lodsd(const GPVar& dst_val, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_LODSD, &dst_val, &src_addr, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Load ECX/RCX QWORDs from DS:[ESI/RSI] to RAX.
  inline void rep_lodsq(const GPVar& dst_val, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_LODSQ, &dst_val, &src_addr, &cnt_ecx);
  }
#endif // ASMJIT_X64
  //! @brief Load ECX/RCX WORDs from DS:[ESI/RSI] to AX.
  inline void rep_lodsw(const GPVar& dst_val, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=EAX,RAX, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_val.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_LODSW, &dst_val, &src_addr, &cnt_ecx);
  }

  //! @brief Move ECX/RCX BYTEs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsb(const GPVar& dst_addr, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_MOVSB, &dst_addr, &src_addr, &cnt_ecx);
  }

  //! @brief Move ECX/RCX DWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsd(const GPVar& dst_addr, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_MOVSD, &dst_addr, &src_addr, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Move ECX/RCX QWORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsq(const GPVar& dst_addr, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_MOVSQ, &dst_addr, &src_addr, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Move ECX/RCX WORDs from DS:[ESI/RSI] to ES:[EDI/RDI].
  inline void rep_movsw(const GPVar& dst_addr, const GPVar& src_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=DS:ESI/RSI, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_addr.getId() && src_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_MOVSW, &dst_addr, &src_addr, &cnt_ecx);
  }

  //! @brief Fill ECX/RCX BYTEs at ES:[EDI/RDI] with AL.
  inline void rep_stosb(const GPVar& dst_addr, const GPVar& src_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_STOSB, &dst_addr, &src_val, &cnt_ecx);
  }

  //! @brief Fill ECX/RCX DWORDs at ES:[EDI/RDI] with EAX.
  inline void rep_stosd(const GPVar& dst_addr, const GPVar& src_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_STOSD, &dst_addr, &src_val, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Fill ECX/RCX QWORDs at ES:[EDI/RDI] with RAX.
  inline void rep_stosq(const GPVar& dst_addr, const GPVar& src_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_STOSQ, &dst_addr, &src_val, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Fill ECX/RCX WORDs at ES:[EDI/RDI] with AX.
  inline void rep_stosw(const GPVar& dst_addr, const GPVar& src_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to dst=ES:EDI,RDI, src=EAX/RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(dst_addr.getId() != src_val.getId() && src_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REP_STOSW, &dst_addr, &src_val, &cnt_ecx);
  }

  //! @brief Repeated find nonmatching BYTEs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsb(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_CMPSB, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

  //! @brief Repeated find nonmatching DWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsd(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_CMPSD, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Repeated find nonmatching QWORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsq(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_CMPSQ, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Repeated find nonmatching WORDs in ES:[EDI/RDI] and DS:[ESI/RDI].
  inline void repe_cmpsw(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_CMPSW, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

  //! @brief Find non-AL BYTE starting at ES:[EDI/RDI].
  inline void repe_scasb(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AL, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_SCASB, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

  //! @brief Find non-EAX DWORD starting at ES:[EDI/RDI].
  inline void repe_scasd(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=EAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_SCASD, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Find non-RAX QWORD starting at ES:[EDI/RDI].
  inline void repe_scasq(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_SCASQ, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Find non-AX WORD starting at ES:[EDI/RDI].
  inline void repe_scasw(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPE_SCASW, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

  //! @brief Find matching BYTEs in [RDI] and [RSI].
  inline void repne_cmpsb(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_CMPSB, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

  //! @brief Find matching DWORDs in [RDI] and [RSI].
  inline void repne_cmpsd(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_CMPSD, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Find matching QWORDs in [RDI] and [RSI].
  inline void repne_cmpsq(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_CMPSQ, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Find matching WORDs in [RDI] and [RSI].
  inline void repne_cmpsw(const GPVar& cmp1_addr, const GPVar& cmp2_addr, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, cmp2=ES:[EDI/RDI], cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_addr.getId() && cmp2_addr.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_CMPSW, &cmp1_addr, &cmp2_addr, &cnt_ecx);
  }

  //! @brief Find AL, starting at ES:[EDI/RDI].
  inline void repne_scasb(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AL, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_SCASB, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

  //! @brief Find EAX, starting at ES:[EDI/RDI].
  inline void repne_scasd(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=EAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_SCASD, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

#if defined(ASMJIT_X64)
  //! @brief Find RAX, starting at ES:[EDI/RDI].
  inline void repne_scasq(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=RAX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_SCASQ, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }
#endif // ASMJIT_X64

  //! @brief Find AX, starting at ES:[EDI/RDI].
  inline void repne_scasw(const GPVar& cmp1_addr, const GPVar& cmp2_val, const GPVar& cnt_ecx)
  {
    // All registers must be unique, they will be reallocated to cmp1=ES:EDI,RDI, src=AX, cnt=ECX/RCX.
    ASMJIT_ASSERT(cmp1_addr.getId() != cmp2_val.getId() && cmp2_val.getId() != cnt_ecx.getId());

    _emitInstruction(INST_REPNE_SCASW, &cmp1_addr, &cmp2_val, &cnt_ecx);
  }

  //! @brief Return from Procedure.
  inline void ret()
  {
    _emitReturn(NULL, NULL);
  }

  //! @brief Return from Procedure.
  inline void ret(const GPVar& first)
  {
    _emitReturn(&first, NULL);
  }

  //! @brief Return from Procedure.
  inline void ret(const GPVar& first, const GPVar& second)
  {
    _emitReturn(&first, &second);
  }

  //! @brief Return from Procedure.
  inline void ret(const XMMVar& first)
  {
    _emitReturn(&first, NULL);
  }

  //! @brief Return from Procedure.
  inline void ret(const XMMVar& first, const XMMVar& second)
  {
    _emitReturn(&first, &second);
  }

  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rol(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rol(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  //! @note @a src register can be only @c cl.
  inline void rol(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }
  //! @brief Rotate Bits Left.
  inline void rol(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ROL, &dst, &src);
  }

  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void ror(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void ror(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  //! @note @a src register can be only @c cl.
  inline void ror(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }
  //! @brief Rotate Bits Right.
  inline void ror(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_ROR, &dst, &src);
  }

#if defined(ASMJIT_X86)
  //! @brief Store @a var (allocated to AH/AX/EAX/RAX) into Flags.
  inline void sahf(const GPVar& var)
  {
    _emitInstruction(INST_SAHF, &var);
  }
#endif // ASMJIT_X86

  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }
  //! @brief Integer subtraction with borrow.
  inline void sbb(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SBB, &dst, &src);
  }

  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void sal(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void sal(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void sal(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void sal(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SAL, &dst, &src);
  }

  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void sar(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void sar(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void sar(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void sar(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SAR, &dst, &src);
  }

  //! @brief Set Byte on Condition.
  inline void set(CONDITION cc, const GPVar& dst)
  {
    ASMJIT_ASSERT(dst.getSize() == 1);
    _emitInstruction(ConditionToInstruction::toSetCC(cc), &dst);
  }

  //! @brief Set Byte on Condition.
  inline void set(CONDITION cc, const Mem& dst)
  {
    ASMJIT_ASSERT(dst.getSize() <= 1);
    _emitInstruction(ConditionToInstruction::toSetCC(cc), &dst);
  }

  //! @brief Set Byte on Condition.
  inline void seta  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETA  , &dst); }
  //! @brief Set Byte on Condition.
  inline void seta  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETA  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setae (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETAE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setae (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETAE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setb  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETB  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setb  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETB  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setbe (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETBE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setbe (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETBE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setc  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETC  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setc  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETC  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sete  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETE  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sete  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETE  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setg  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETG  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setg  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETG  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setge (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETGE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setge (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETGE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setl  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETL  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setl  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETL  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setle (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETLE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setle (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETLE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setna (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNA , &dst); }
  //! @brief Set Byte on Condition.
  inline void setna (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNA , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnae(const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNAE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnae(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNAE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnb (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNB , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnb (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNB , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnbe(const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNBE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnbe(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNBE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnc (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNC , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnc (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNC , &dst); }
  //! @brief Set Byte on Condition.
  inline void setne (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setne (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setng (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNG , &dst); }
  //! @brief Set Byte on Condition.
  inline void setng (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNG , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnge(const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNGE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnge(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNGE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnl (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNL , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnl (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNL , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnle(const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNLE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setnle(const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNLE, &dst); }
  //! @brief Set Byte on Condition.
  inline void setno (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setno (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnp (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNP , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnp (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNP , &dst); }
  //! @brief Set Byte on Condition.
  inline void setns (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNS , &dst); }
  //! @brief Set Byte on Condition.
  inline void setns (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNS , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnz (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETNZ , &dst); }
  //! @brief Set Byte on Condition.
  inline void setnz (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETNZ , &dst); }
  //! @brief Set Byte on Condition.
  inline void seto  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETO  , &dst); }
  //! @brief Set Byte on Condition.
  inline void seto  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETO  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setp  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETP  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setp  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETP  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpe (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETPE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpe (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETPE , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpo (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETPO , &dst); }
  //! @brief Set Byte on Condition.
  inline void setpo (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETPO , &dst); }
  //! @brief Set Byte on Condition.
  inline void sets  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETS  , &dst); }
  //! @brief Set Byte on Condition.
  inline void sets  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETS  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setz  (const GPVar& dst) { ASMJIT_ASSERT(dst.getSize() == 1); _emitInstruction(INST_SETZ  , &dst); }
  //! @brief Set Byte on Condition.
  inline void setz  (const Mem& dst)   { ASMJIT_ASSERT(dst.getSize() <= 1); _emitInstruction(INST_SETZ  , &dst); }

  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void shl(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void shl(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  //! @note @a src register can be only @c cl.
  inline void shl(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }
  //! @brief Shift Bits Left.
  inline void shl(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SHL, &dst, &src);
  }

  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void shr(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void shr(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  //! @note @a src register can be only @c cl.
  inline void shr(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }
  //! @brief Shift Bits Right.
  inline void shr(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SHR, &dst, &src);
  }

  //! @brief Double Precision Shift Left.
  //! @note src2 register can be only @c cl register.
  inline void shld(const GPVar& dst, const GPVar& src1, const GPVar& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  inline void shld(const GPVar& dst, const GPVar& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  //! @note src2 register can be only @c cl register.
  inline void shld(const Mem& dst, const GPVar& src1, const GPVar& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Left.
  inline void shld(const Mem& dst, const GPVar& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHLD, &dst, &src1, &src2);
  }

  //! @brief Double Precision Shift Right.
  //! @note src2 register can be only @c cl register.
  inline void shrd(const GPVar& dst, const GPVar& src1, const GPVar& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  inline void shrd(const GPVar& dst, const GPVar& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  //! @note src2 register can be only @c cl register.
  inline void shrd(const Mem& dst, const GPVar& src1, const GPVar& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }
  //! @brief Double Precision Shift Right.
  inline void shrd(const Mem& dst, const GPVar& src1, const Imm& src2)
  {
    _emitInstruction(INST_SHRD, &dst, &src1, &src2);
  }

  //! @brief Set Carry Flag to 1.
  inline void stc()
  {
    _emitInstruction(INST_STC);
  }

  //! @brief Set Direction Flag to 1.
  inline void std()
  {
    _emitInstruction(INST_STD);
  }

  //! @brief Subtract.
  inline void sub(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }
  //! @brief Subtract.
  inline void sub(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_SUB, &dst, &src);
  }

  //! @brief Logical Compare.
  inline void test(const GPVar& op1, const GPVar& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const GPVar& op1, const Imm& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const Mem& op1, const GPVar& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }
  //! @brief Logical Compare.
  inline void test(const Mem& op1, const Imm& op2)
  {
    _emitInstruction(INST_TEST, &op1, &op2);
  }

  //! @brief Undefined instruction - Raise invalid opcode exception.
  inline void ud2()
  {
    _emitInstruction(INST_UD2);
  }

  //! @brief Exchange and Add.
  inline void xadd(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_XADD, &dst, &src);
  }
  //! @brief Exchange and Add.
  inline void xadd(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_XADD, &dst, &src);
  }

  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_XCHG, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_XCHG, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xchg(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_XCHG, &src, &dst);
  }

  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const GPVar& dst, const Imm& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }
  //! @brief Exchange Register/Memory with Register.
  inline void xor_(const Mem& dst, const Imm& src)
  {
    _emitInstruction(INST_XOR, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [MMX]
  // --------------------------------------------------------------------------

  //! @brief Empty MMX state.
  inline void emms()
  {
    _emitInstruction(INST_EMMS);
  }

  //! @brief Move DWord (MMX).
  inline void movd(const Mem& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const GPVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord (MMX).
  inline void movd(const MMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }

  //! @brief Move QWord (MMX).
  inline void movq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
  //! @brief Move QWord (MMX).
  inline void movq(const Mem& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (MMX).
  inline void movq(const GPVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif
  //! @brief Move QWord (MMX).
  inline void movq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (MMX).
  inline void movq(const MMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif

  //! @brief Pack with Signed Saturation (MMX).
  inline void packsswb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (MMX).
  inline void packsswb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (MMX).
  inline void packssdw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (MMX).
  inline void packssdw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }

  //! @brief Pack with Unsigned Saturation (MMX).
  inline void packuswb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (MMX).
  inline void packuswb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }

  //! @brief Packed BYTE Add (MMX).
  inline void paddb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }
  //! @brief Packed BYTE Add (MMX).
  inline void paddb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }

  //! @brief Packed WORD Add (MMX).
  inline void paddw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }
  //! @brief Packed WORD Add (MMX).
  inline void paddw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }

  //! @brief Packed DWORD Add (MMX).
  inline void paddd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }
  //! @brief Packed DWORD Add (MMX).
  inline void paddd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }

  //! @brief Packed Add with Saturation (MMX).
  inline void paddsb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }
  //! @brief Packed Add with Saturation (MMX).
  inline void paddsb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }

  //! @brief Packed Add with Saturation (MMX).
  inline void paddsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }
  //! @brief Packed Add with Saturation (MMX).
  inline void paddsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (MMX).
  inline void paddusw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }

  //! @brief Logical AND (MMX).
  inline void pand(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }
  //! @brief Logical AND (MMX).
  inline void pand(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }

  //! @brief Logical AND Not (MMX).
  inline void pandn(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }
  //! @brief Logical AND Not (MMX).
  inline void pandn(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }

  //! @brief Packed Compare for Equal (BYTES) (MMX).
  inline void pcmpeqb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }
  //! @brief Packed Compare for Equal (BYTES) (MMX).
  inline void pcmpeqb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }

  //! @brief Packed Compare for Equal (WORDS) (MMX).
  inline void pcmpeqw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }
  //! @brief Packed Compare for Equal (WORDS) (MMX).
  inline void pcmpeqw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (DWORDS) (MMX).
  inline void pcmpeqd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }
  //! @brief Packed Compare for Equal (DWORDS) (MMX).
  inline void pcmpeqd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (BYTES) (MMX).
  inline void pcmpgtb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (BYTES) (MMX).
  inline void pcmpgtb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (WORDS) (MMX).
  inline void pcmpgtw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (WORDS) (MMX).
  inline void pcmpgtw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (DWORDS) (MMX).
  inline void pcmpgtd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (DWORDS) (MMX).
  inline void pcmpgtd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }

  //! @brief Packed Multiply High (MMX).
  inline void pmulhw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }
  //! @brief Packed Multiply High (MMX).
  inline void pmulhw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }

  //! @brief Packed Multiply Low (MMX).
  inline void pmullw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }
  //! @brief Packed Multiply Low (MMX).
  inline void pmullw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }

  //! @brief Bitwise Logical OR (MMX).
  inline void por(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }
  //! @brief Bitwise Logical OR (MMX).
  inline void por(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }

  //! @brief Packed Multiply and Add (MMX).
  inline void pmaddwd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }
  //! @brief Packed Multiply and Add (MMX).
  inline void pmaddwd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void pslld(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllq(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (MMX).
  inline void psllw(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psrad(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (MMX).
  inline void psraw(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrld(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlq(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (MMX).
  inline void psrlw(const MMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }

  //! @brief Packed Subtract (MMX).
  inline void psubd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }
  //! @brief Packed Subtract (MMX).
  inline void psubd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (MMX).
  inline void psubsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (MMX).
  inline void psubusw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhbw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhbw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhwd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhwd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhdq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckhdq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklbw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklbw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklwd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpcklwd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }

  //! @brief Unpack High Packed Data (MMX).
  inline void punpckldq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }
  //! @brief Unpack High Packed Data (MMX).
  inline void punpckldq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }

  //! @brief Bitwise Exclusive OR (MMX).
  inline void pxor(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }
  //! @brief Bitwise Exclusive OR (MMX).
  inline void pxor(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [3dNow]
  // --------------------------------------------------------------------------

  //! @brief Faster EMMS (3dNow!).
  //!
  //! @note Use only for early AMD processors where is only 3dNow! or SSE. If
  //! CPU contains SSE2, it's better to use @c emms() ( @c femms() is mapped
  //! to @c emms() ).
  inline void femms()
  {
    _emitInstruction(INST_FEMMS);
  }

  //! @brief Packed SP-FP to Integer Convert (3dNow!).
  inline void pf2id(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PF2ID, &dst, &src);
  }
  //! @brief Packed SP-FP to Integer Convert (3dNow!).
  inline void pf2id(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PF2ID, &dst, &src);
  }

  //! @brief  Packed SP-FP to Integer Word Convert (3dNow!).
  inline void pf2iw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PF2IW, &dst, &src);
  }
  //! @brief  Packed SP-FP to Integer Word Convert (3dNow!).
  inline void pf2iw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PF2IW, &dst, &src);
  }

  //! @brief Packed SP-FP Accumulate (3dNow!).
  inline void pfacc(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFACC, &dst, &src);
  }
  //! @brief Packed SP-FP Accumulate (3dNow!).
  inline void pfacc(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFACC, &dst, &src);
  }

  //! @brief Packed SP-FP Addition (3dNow!).
  inline void pfadd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFADD, &dst, &src);
  }
  //! @brief Packed SP-FP Addition (3dNow!).
  inline void pfadd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFADD, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst == src (3dNow!).
  inline void pfcmpeq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFCMPEQ, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst == src (3dNow!).
  inline void pfcmpeq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPEQ, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst >= src (3dNow!).
  inline void pfcmpge(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFCMPGE, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst >= src (3dNow!).
  inline void pfcmpge(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPGE, &dst, &src);
  }

  //! @brief Packed SP-FP Compare - dst > src (3dNow!).
  inline void pfcmpgt(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFCMPGT, &dst, &src);
  }
  //! @brief Packed SP-FP Compare - dst > src (3dNow!).
  inline void pfcmpgt(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFCMPGT, &dst, &src);
  }

  //! @brief Packed SP-FP Maximum (3dNow!).
  inline void pfmax(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFMAX, &dst, &src);
  }
  //! @brief Packed SP-FP Maximum (3dNow!).
  inline void pfmax(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMAX, &dst, &src);
  }

  //! @brief Packed SP-FP Minimum (3dNow!).
  inline void pfmin(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFMIN, &dst, &src);
  }
  //! @brief Packed SP-FP Minimum (3dNow!).
  inline void pfmin(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMIN, &dst, &src);
  }

  //! @brief Packed SP-FP Multiply (3dNow!).
  inline void pfmul(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFMUL, &dst, &src);
  }
  //! @brief Packed SP-FP Multiply (3dNow!).
  inline void pfmul(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFMUL, &dst, &src);
  }

  //! @brief Packed SP-FP Negative Accumulate (3dNow!).
  inline void pfnacc(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFNACC, &dst, &src);
  }
  //! @brief Packed SP-FP Negative Accumulate (3dNow!).
  inline void pfnacc(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFNACC, &dst, &src);
  }

  //! @brief Packed SP-FP Mixed Accumulate (3dNow!).
  inline void pfpnaxx(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFPNACC, &dst, &src);
  }
  //! @brief Packed SP-FP Mixed Accumulate (3dNow!).
  inline void pfpnacc(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFPNACC, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Approximation (3dNow!).
  inline void pfrcp(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFRCP, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Approximation (3dNow!).
  inline void pfrcp(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCP, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
  inline void pfrcpit1(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFRCPIT1, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal, First Iteration Step (3dNow!).
  inline void pfrcpit1(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCPIT1, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
  inline void pfrcpit2(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFRCPIT2, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal, Second Iteration Step (3dNow!).
  inline void pfrcpit2(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRCPIT2, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
  inline void pfrsqit1(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFRSQIT1, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Square Root, First Iteration Step (3dNow!).
  inline void pfrsqit1(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRSQIT1, &dst, &src);
  }

  //! @brief Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
  inline void pfrsqrt(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFRSQRT, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal Square Root Approximation (3dNow!).
  inline void pfrsqrt(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFRSQRT, &dst, &src);
  }

  //! @brief Packed SP-FP Subtract (3dNow!).
  inline void pfsub(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFSUB, &dst, &src);
  }
  //! @brief Packed SP-FP Subtract (3dNow!).
  inline void pfsub(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFSUB, &dst, &src);
  }

  //! @brief Packed SP-FP Reverse Subtract (3dNow!).
  inline void pfsubr(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PFSUBR, &dst, &src);
  }
  //! @brief Packed SP-FP Reverse Subtract (3dNow!).
  inline void pfsubr(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PFSUBR, &dst, &src);
  }

  //! @brief Packed DWords to SP-FP (3dNow!).
  inline void pi2fd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PI2FD, &dst, &src);
  }
  //! @brief Packed DWords to SP-FP (3dNow!).
  inline void pi2fd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PI2FD, &dst, &src);
  }

  //! @brief Packed Words to SP-FP (3dNow!).
  inline void pi2fw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PI2FW, &dst, &src);
  }
  //! @brief Packed Words to SP-FP (3dNow!).
  inline void pi2fw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PI2FW, &dst, &src);
  }

  //! @brief Packed swap DWord (3dNow!)
  inline void pswapd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSWAPD, &dst, &src);
  }
  //! @brief Packed swap DWord (3dNow!)
  inline void pswapd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSWAPD, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE]
  // --------------------------------------------------------------------------

  //! @brief Packed SP-FP Add (SSE).
  inline void addps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDPS, &dst, &src);
  }
  //! @brief Packed SP-FP Add (SSE).
  inline void addps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Add (SSE).
  inline void addss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Add (SSE).
  inline void addss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSS, &dst, &src);
  }

  //! @brief Bit-wise Logical And Not For SP-FP (SSE).
  inline void andnps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ANDNPS, &dst, &src);
  }
  //! @brief Bit-wise Logical And Not For SP-FP (SSE).
  inline void andnps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDNPS, &dst, &src);
  }

  //! @brief Bit-wise Logical And For SP-FP (SSE).
  inline void andps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ANDPS, &dst, &src);
  }
  //! @brief Bit-wise Logical And For SP-FP (SSE).
  inline void andps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDPS, &dst, &src);
  }

  //! @brief Packed SP-FP Compare (SSE).
  inline void cmpps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPS, &dst, &src, &imm8);
  }
  //! @brief Packed SP-FP Compare (SSE).
  inline void cmpps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPS, &dst, &src, &imm8);
  }

  //! @brief Compare Scalar SP-FP Values (SSE).
  inline void cmpss(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSS, &dst, &src, &imm8);
  }
  //! @brief Compare Scalar SP-FP Values (SSE).
  inline void cmpss(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSS, &dst, &src, &imm8);
  }

  //! @brief Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
  inline void comiss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_COMISS, &dst, &src);
  }
  //! @brief Scalar Ordered SP-FP Compare and Set EFLAGS (SSE).
  inline void comiss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_COMISS, &dst, &src);
  }

  //! @brief Packed Signed INT32 to Packed SP-FP Conversion (SSE).
  inline void cvtpi2ps(const XMMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_CVTPI2PS, &dst, &src);
  }
  //! @brief Packed Signed INT32 to Packed SP-FP Conversion (SSE).
  inline void cvtpi2ps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPI2PS, &dst, &src);
  }

  //! @brief Packed SP-FP to Packed INT32 Conversion (SSE).
  inline void cvtps2pi(const MMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPS2PI, &dst, &src);
  }
  //! @brief Packed SP-FP to Packed INT32 Conversion (SSE).
  inline void cvtps2pi(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2PI, &dst, &src);
  }

  //! @brief Scalar Signed INT32 to SP-FP Conversion (SSE).
  inline void cvtsi2ss(const XMMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_CVTSI2SS, &dst, &src);
  }
  //! @brief Scalar Signed INT32 to SP-FP Conversion (SSE).
  inline void cvtsi2ss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSI2SS, &dst, &src);
  }

  //! @brief Scalar SP-FP to Signed INT32 Conversion (SSE).
  inline void cvtss2si(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTSS2SI, &dst, &src);
  }
  //! @brief Scalar SP-FP to Signed INT32 Conversion (SSE).
  inline void cvtss2si(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSS2SI, &dst, &src);
  }

  //! @brief Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
  inline void cvttps2pi(const MMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTPS2PI, &dst, &src);
  }
  //! @brief Packed SP-FP to Packed INT32 Conversion (truncate) (SSE).
  inline void cvttps2pi(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPS2PI, &dst, &src);
  }

  //! @brief Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
  inline void cvttss2si(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTSS2SI, &dst, &src);
  }
  //! @brief Scalar SP-FP to Signed INT32 Conversion (truncate) (SSE).
  inline void cvttss2si(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTSS2SI, &dst, &src);
  }

  //! @brief Packed SP-FP Divide (SSE).
  inline void divps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_DIVPS, &dst, &src);
  }
  //! @brief Packed SP-FP Divide (SSE).
  inline void divps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Divide (SSE).
  inline void divss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_DIVSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Divide (SSE).
  inline void divss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVSS, &dst, &src);
  }

  //! @brief Load Streaming SIMD Extension Control/Status (SSE).
  inline void ldmxcsr(const Mem& src)
  {
    _emitInstruction(INST_LDMXCSR, &src);
  }

  //! @brief Byte Mask Write (SSE).
  //!
  //! @note The default memory location is specified by DS:EDI.
  inline void maskmovq(const GPVar& dst_ptr, const MMVar& data, const MMVar& mask)
  {
    _emitInstruction(INST_MASKMOVQ, &dst_ptr, &data, &mask);
  }

  //! @brief Packed SP-FP Maximum (SSE).
  inline void maxps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MAXPS, &dst, &src);
  }
  //! @brief Packed SP-FP Maximum (SSE).
  inline void maxps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Maximum (SSE).
  inline void maxss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MAXSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Maximum (SSE).
  inline void maxss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXSS, &dst, &src);
  }

  //! @brief Packed SP-FP Minimum (SSE).
  inline void minps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MINPS, &dst, &src);
  }
  //! @brief Packed SP-FP Minimum (SSE).
  inline void minps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MINPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Minimum (SSE).
  inline void minss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MINSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Minimum (SSE).
  inline void minss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MINSS, &dst, &src);
  }

  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }
  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }

  //! @brief Move Aligned Packed SP-FP Values (SSE).
  inline void movaps(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVAPS, &dst, &src);
  }

  //! @brief Move DWord.
  inline void movd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }
  //! @brief Move DWord.
  inline void movd(const XMMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVD, &dst, &src);
  }

  //! @brief Move QWord (SSE).
  inline void movq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
  //! @brief Move QWord (SSE).
  inline void movq(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (SSE).
  inline void movq(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif // ASMJIT_X64
  //! @brief Move QWord (SSE).
  inline void movq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#if defined(ASMJIT_X64)
  //! @brief Move QWord (SSE).
  inline void movq(const XMMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVQ, &dst, &src);
  }
#endif // ASMJIT_X64

  //! @brief Move 64 Bits Non Temporal (SSE).
  inline void movntq(const Mem& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVNTQ, &dst, &src);
  }

  //! @brief High to Low Packed SP-FP (SSE).
  inline void movhlps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVHLPS, &dst, &src);
  }

  //! @brief Move High Packed SP-FP (SSE).
  inline void movhps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVHPS, &dst, &src);
  }

  //! @brief Move High Packed SP-FP (SSE).
  inline void movhps(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVHPS, &dst, &src);
  }

  //! @brief Move Low to High Packed SP-FP (SSE).
  inline void movlhps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVLHPS, &dst, &src);
  }

  //! @brief Move Low Packed SP-FP (SSE).
  inline void movlps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVLPS, &dst, &src);
  }

  //! @brief Move Low Packed SP-FP (SSE).
  inline void movlps(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVLPS, &dst, &src);
  }

  //! @brief Move Aligned Four Packed SP-FP Non Temporal (SSE).
  inline void movntps(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVNTPS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Scalar SP-FP (SSE).
  inline void movss(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSS, &dst, &src);
  }

  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }
  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }

  //! @brief Move Unaligned Packed SP-FP Values (SSE).
  inline void movups(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVUPS, &dst, &src);
  }

  //! @brief Packed SP-FP Multiply (SSE).
  inline void mulps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MULPS, &dst, &src);
  }
  //! @brief Packed SP-FP Multiply (SSE).
  inline void mulps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MULPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Multiply (SSE).
  inline void mulss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MULSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Multiply (SSE).
  inline void mulss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MULSS, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for SP-FP Data (SSE).
  inline void orps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ORPS, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for SP-FP Data (SSE).
  inline void orps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ORPS, &dst, &src);
  }

  //! @brief Packed Average (SSE).
  inline void pavgb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }
  //! @brief Packed Average (SSE).
  inline void pavgb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }

  //! @brief Packed Average (SSE).
  inline void pavgw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }
  //! @brief Packed Average (SSE).
  inline void pavgw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }

  //! @brief Extract Word (SSE).
  inline void pextrw(const GPVar& dst, const MMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }

  //! @brief Insert Word (SSE).
  inline void pinsrw(const MMVar& dst, const GPVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }
  //! @brief Insert Word (SSE).
  inline void pinsrw(const MMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }

  //! @brief Packed Signed Integer Word Maximum (SSE).
  inline void pmaxsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Maximum (SSE).
  inline void pmaxsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Maximum (SSE).
  inline void pmaxub(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Maximum (SSE).
  inline void pmaxub(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }

  //! @brief Packed Signed Integer Word Minimum (SSE).
  inline void pminsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Minimum (SSE).
  inline void pminsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Minimum (SSE).
  inline void pminub(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Minimum (SSE).
  inline void pminub(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }

  //! @brief Move Byte Mask To Integer (SSE).
  inline void pmovmskb(const GPVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMOVMSKB, &dst, &src);
  }

  //! @brief Packed Multiply High Unsigned (SSE).
  inline void pmulhuw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }
  //! @brief Packed Multiply High Unsigned (SSE).
  inline void pmulhuw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }

  //! @brief Packed Sum of Absolute Differences (SSE).
  inline void psadbw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }
  //! @brief Packed Sum of Absolute Differences (SSE).
  inline void psadbw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }

  //! @brief Packed Shuffle word (SSE).
  inline void pshufw(const MMVar& dst, const MMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFW, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle word (SSE).
  inline void pshufw(const MMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFW, &dst, &src, &imm8);
  }

  //! @brief Packed SP-FP Reciprocal (SSE).
  inline void rcpps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_RCPPS, &dst, &src);
  }
  //! @brief Packed SP-FP Reciprocal (SSE).
  inline void rcpps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_RCPPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Reciprocal (SSE).
  inline void rcpss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_RCPSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Reciprocal (SSE).
  inline void rcpss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_RCPSS, &dst, &src);
  }

  //! @brief Prefetch (SSE).
  inline void prefetch(const Mem& mem, const Imm& hint)
  {
    _emitInstruction(INST_PREFETCH, &mem, &hint);
  }

  //! @brief Compute Sum of Absolute Differences (SSE).
  inline void psadbw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }
  //! @brief Compute Sum of Absolute Differences (SSE).
  inline void psadbw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSADBW, &dst, &src);
  }

  //! @brief Packed SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_RSQRTPS, &dst, &src);
  }
  //! @brief Packed SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_RSQRTPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_RSQRTSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Square Root Reciprocal (SSE).
  inline void rsqrtss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_RSQRTSS, &dst, &src);
  }

  //! @brief Store fence (SSE).
  inline void sfence()
  {
    _emitInstruction(INST_SFENCE);
  }

  //! @brief Shuffle SP-FP (SSE).
  inline void shufps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPS, &dst, &src, &imm8);
  }
  //! @brief Shuffle SP-FP (SSE).
  inline void shufps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPS, &dst, &src, &imm8);
  }

  //! @brief Packed SP-FP Square Root (SSE).
  inline void sqrtps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SQRTPS, &dst, &src);
  }
  //! @brief Packed SP-FP Square Root (SSE).
  inline void sqrtps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Square Root (SSE).
  inline void sqrtss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SQRTSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Square Root (SSE).
  inline void sqrtss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTSS, &dst, &src);
  }

  //! @brief Store Streaming SIMD Extension Control/Status (SSE).
  inline void stmxcsr(const Mem& dst)
  {
    _emitInstruction(INST_STMXCSR, &dst);
  }

  //! @brief Packed SP-FP Subtract (SSE).
  inline void subps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Subtract (SSE).
  inline void subps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBPS, &dst, &src);
  }

  //! @brief Scalar SP-FP Subtract (SSE).
  inline void subss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SUBSS, &dst, &src);
  }
  //! @brief Scalar SP-FP Subtract (SSE).
  inline void subss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBSS, &dst, &src);
  }

  //! @brief Unordered Scalar SP-FP compare and set EFLAGS (SSE).
  inline void ucomiss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UCOMISS, &dst, &src);
  }
  //! @brief Unordered Scalar SP-FP compare and set EFLAGS (SSE).
  inline void ucomiss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UCOMISS, &dst, &src);
  }

  //! @brief Unpack High Packed SP-FP Data (SSE).
  inline void unpckhps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UNPCKHPS, &dst, &src);
  }
  //! @brief Unpack High Packed SP-FP Data (SSE).
  inline void unpckhps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKHPS, &dst, &src);
  }

  //! @brief Unpack Low Packed SP-FP Data (SSE).
  inline void unpcklps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UNPCKLPS, &dst, &src);
  }
  //! @brief Unpack Low Packed SP-FP Data (SSE).
  inline void unpcklps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKLPS, &dst, &src);
  }

  //! @brief Bit-wise Logical Xor for SP-FP Data (SSE).
  inline void xorps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_XORPS, &dst, &src);
  }
  //! @brief Bit-wise Logical Xor for SP-FP Data (SSE).
  inline void xorps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_XORPS, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE2]
  // --------------------------------------------------------------------------

  //! @brief Packed DP-FP Add (SSE2).
  inline void addpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDPD, &dst, &src);
  }
  //! @brief Packed DP-FP Add (SSE2).
  inline void addpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Add (SSE2).
  inline void addsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Add (SSE2).
  inline void addsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSD, &dst, &src);
  }

  //! @brief Bit-wise Logical And Not For DP-FP (SSE2).
  inline void andnpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ANDNPD, &dst, &src);
  }
  //! @brief Bit-wise Logical And Not For DP-FP (SSE2).
  inline void andnpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDNPD, &dst, &src);
  }

  //! @brief Bit-wise Logical And For DP-FP (SSE2).
  inline void andpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ANDPD, &dst, &src);
  }
  //! @brief Bit-wise Logical And For DP-FP (SSE2).
  inline void andpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ANDPD, &dst, &src);
  }

  //! @brief Flush Cache Line (SSE2).
  inline void clflush(const Mem& mem)
  {
    _emitInstruction(INST_CLFLUSH, &mem);
  }

  //! @brief Packed DP-FP Compare (SSE2).
  inline void cmppd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPD, &dst, &src, &imm8);
  }
  //! @brief Packed DP-FP Compare (SSE2).
  inline void cmppd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPPD, &dst, &src, &imm8);
  }

  //! @brief Compare Scalar SP-FP Values (SSE2).
  inline void cmpsd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSD, &dst, &src, &imm8);
  }
  //! @brief Compare Scalar SP-FP Values (SSE2).
  inline void cmpsd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_CMPSD, &dst, &src, &imm8);
  }

  //! @brief Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void comisd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_COMISD, &dst, &src);
  }
  //! @brief Scalar Ordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void comisd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_COMISD, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtdq2pd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTDQ2PD, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtdq2pd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTDQ2PD, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
  inline void cvtdq2ps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTDQ2PS, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed SP-FP Values (SSE2).
  inline void cvtdq2ps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTDQ2PS, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2dq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPD2DQ, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2dq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2DQ, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2pi(const MMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPD2PI, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtpd2pi(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2PI, &dst, &src);
  }

  //! @brief Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
  inline void cvtpd2ps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPD2PS, &dst, &src);
  }
  //! @brief Convert Packed DP-FP Values to Packed SP-FP Values (SSE2).
  inline void cvtpd2ps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPD2PS, &dst, &src);
  }

  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtpi2pd(const XMMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_CVTPI2PD, &dst, &src);
  }
  //! @brief Convert Packed Dword Integers to Packed DP-FP Values (SSE2).
  inline void cvtpi2pd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPI2PD, &dst, &src);
  }

  //! @brief Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtps2dq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPS2DQ, &dst, &src);
  }
  //! @brief Convert Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvtps2dq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2DQ, &dst, &src);
  }

  //! @brief Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
  inline void cvtps2pd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTPS2PD, &dst, &src);
  }
  //! @brief Convert Packed SP-FP Values to Packed DP-FP Values (SSE2).
  inline void cvtps2pd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTPS2PD, &dst, &src);
  }

  //! @brief Convert Scalar DP-FP Value to Dword Integer (SSE2).
  inline void cvtsd2si(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTSD2SI, &dst, &src);
  }
  //! @brief Convert Scalar DP-FP Value to Dword Integer (SSE2).
  inline void cvtsd2si(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSD2SI, &dst, &src);
  }

  //! @brief Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
  inline void cvtsd2ss(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTSD2SS, &dst, &src);
  }
  //! @brief Convert Scalar DP-FP Value to Scalar SP-FP Value (SSE2).
  inline void cvtsd2ss(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSD2SS, &dst, &src);
  }

  //! @brief Convert Dword Integer to Scalar DP-FP Value (SSE2).
  inline void cvtsi2sd(const XMMVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_CVTSI2SD, &dst, &src);
  }
  //! @brief Convert Dword Integer to Scalar DP-FP Value (SSE2).
  inline void cvtsi2sd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSI2SD, &dst, &src);
  }

  //! @brief Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
  inline void cvtss2sd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTSS2SD, &dst, &src);
  }
  //! @brief Convert Scalar SP-FP Value to Scalar DP-FP Value (SSE2).
  inline void cvtss2sd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTSS2SD, &dst, &src);
  }

  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2pi(const MMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTPD2PI, &dst, &src);
  }
  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2pi(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPD2PI, &dst, &src);
  }

  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2dq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTPD2DQ, &dst, &src);
  }
  //! @brief Convert with Truncation Packed DP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttpd2dq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPD2DQ, &dst, &src);
  }

  //! @brief Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttps2dq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTPS2DQ, &dst, &src);
  }
  //! @brief Convert with Truncation Packed SP-FP Values to Packed Dword Integers (SSE2).
  inline void cvttps2dq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTPS2DQ, &dst, &src);
  }

  //! @brief Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
  inline void cvttsd2si(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_CVTTSD2SI, &dst, &src);
  }
  //! @brief Convert with Truncation Scalar DP-FP Value to Signed Dword Integer (SSE2).
  inline void cvttsd2si(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CVTTSD2SI, &dst, &src);
  }

  //! @brief Packed DP-FP Divide (SSE2).
  inline void divpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_DIVPD, &dst, &src);
  }
  //! @brief Packed DP-FP Divide (SSE2).
  inline void divpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Divide (SSE2).
  inline void divsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_DIVSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Divide (SSE2).
  inline void divsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_DIVSD, &dst, &src);
  }

  //! @brief Load Fence (SSE2).
  inline void lfence()
  {
    _emitInstruction(INST_LFENCE);
  }

  //! @brief Store Selected Bytes of Double Quadword (SSE2).
  //!
  //! @note Target is DS:EDI.
  inline void maskmovdqu(const GPVar& dst_ptr, const XMMVar& src, const XMMVar& mask)
  {
    _emitInstruction(INST_MASKMOVDQU, &dst_ptr, &src, &mask);
  }

  //! @brief Return Maximum Packed Double-Precision FP Values (SSE2).
  inline void maxpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MAXPD, &dst, &src);
  }
  //! @brief Return Maximum Packed Double-Precision FP Values (SSE2).
  inline void maxpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXPD, &dst, &src);
  }

  //! @brief Return Maximum Scalar Double-Precision FP Value (SSE2).
  inline void maxsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MAXSD, &dst, &src);
  }
  //! @brief Return Maximum Scalar Double-Precision FP Value (SSE2).
  inline void maxsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MAXSD, &dst, &src);
  }

  //! @brief Memory Fence (SSE2).
  inline void mfence()
  {
    _emitInstruction(INST_MFENCE);
  }

  //! @brief Return Minimum Packed DP-FP Values (SSE2).
  inline void minpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MINPD, &dst, &src);
  }
  //! @brief Return Minimum Packed DP-FP Values (SSE2).
  inline void minpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MINPD, &dst, &src);
  }

  //! @brief Return Minimum Scalar DP-FP Value (SSE2).
  inline void minsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MINSD, &dst, &src);
  }
  //! @brief Return Minimum Scalar DP-FP Value (SSE2).
  inline void minsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MINSD, &dst, &src);
  }

  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }
  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }

  //! @brief Move Aligned DQWord (SSE2).
  inline void movdqa(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDQA, &dst, &src);
  }

  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }
  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }

  //! @brief Move Unaligned Double Quadword (SSE2).
  inline void movdqu(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDQU, &dst, &src);
  }

  //! @brief Extract Packed SP-FP Sign Mask (SSE2).
  inline void movmskps(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVMSKPS, &dst, &src);
  }

  //! @brief Extract Packed DP-FP Sign Mask (SSE2).
  inline void movmskpd(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVMSKPD, &dst, &src);
  }

  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }
  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }

  //! @brief Move Scalar Double-Precision FP Value (SSE2).
  inline void movsd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Aligned Packed Double-Precision FP Values (SSE2).
  inline void movapd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVAPD, &dst, &src);
  }

  //! @brief Move Quadword from XMM to MMX Technology Register (SSE2).
  inline void movdq2q(const MMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDQ2Q, &dst, &src);
  }

  //! @brief Move Quadword from MMX Technology to XMM Register (SSE2).
  inline void movq2dq(const XMMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_MOVQ2DQ, &dst, &src);
  }

  //! @brief Move High Packed Double-Precision FP Value (SSE2).
  inline void movhpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVHPD, &dst, &src);
  }

  //! @brief Move High Packed Double-Precision FP Value (SSE2).
  inline void movhpd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVHPD, &dst, &src);
  }

  //! @brief Move Low Packed Double-Precision FP Value (SSE2).
  inline void movlpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVLPD, &dst, &src);
  }

  //! @brief Move Low Packed Double-Precision FP Value (SSE2).
  inline void movlpd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVLPD, &dst, &src);
  }

  //! @brief Store Double Quadword Using Non-Temporal Hint (SSE2).
  inline void movntdq(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVNTDQ, &dst, &src);
  }

  //! @brief Store Store DWORD Using Non-Temporal Hint (SSE2).
  inline void movnti(const Mem& dst, const GPVar& src)
  {
    _emitInstruction(INST_MOVNTI, &dst, &src);
  }

  //! @brief Store Packed Double-Precision FP Values Using Non-Temporal Hint (SSE2).
  inline void movntpd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVNTPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Move Unaligned Packed Double-Precision FP Values (SSE2).
  inline void movupd(const Mem& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVUPD, &dst, &src);
  }

  //! @brief Packed DP-FP Multiply (SSE2).
  inline void mulpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MULPD, &dst, &src);
  }
  //! @brief Packed DP-FP Multiply (SSE2).
  inline void mulpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MULPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Multiply (SSE2).
  inline void mulsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MULSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Multiply (SSE2).
  inline void mulsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MULSD, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void orpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ORPD, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void orpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ORPD, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (SSE2).
  inline void packsswb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (SSE2).
  inline void packsswb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSWB, &dst, &src);
  }

  //! @brief Pack with Signed Saturation (SSE2).
  inline void packssdw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }
  //! @brief Pack with Signed Saturation (SSE2).
  inline void packssdw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKSSDW, &dst, &src);
  }

  //! @brief Pack with Unsigned Saturation (SSE2).
  inline void packuswb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (SSE2).
  inline void packuswb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSWB, &dst, &src);
  }

  //! @brief Packed BYTE Add (SSE2).
  inline void paddb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }
  //! @brief Packed BYTE Add (SSE2).
  inline void paddb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDB, &dst, &src);
  }

  //! @brief Packed WORD Add (SSE2).
  inline void paddw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }
  //! @brief Packed WORD Add (SSE2).
  inline void paddw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDW, &dst, &src);
  }

  //! @brief Packed DWORD Add (SSE2).
  inline void paddd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }
  //! @brief Packed DWORD Add (SSE2).
  inline void paddd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDD, &dst, &src);
  }

  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }
  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }

  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }
  //! @brief Packed QWORD Add (SSE2).
  inline void paddq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDQ, &dst, &src);
  }

  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }
  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSB, &dst, &src);
  }

  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }
  //! @brief Packed Add with Saturation (SSE2).
  inline void paddsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDSW, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSB, &dst, &src);
  }

  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }
  //! @brief Packed Add Unsigned with Saturation (SSE2).
  inline void paddusw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PADDUSW, &dst, &src);
  }

  //! @brief Logical AND (SSE2).
  inline void pand(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }
  //! @brief Logical AND (SSE2).
  inline void pand(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAND, &dst, &src);
  }

  //! @brief Logical AND Not (SSE2).
  inline void pandn(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }
  //! @brief Logical AND Not (SSE2).
  inline void pandn(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PANDN, &dst, &src);
  }

  //! @brief Spin Loop Hint (SSE2).
  inline void pause()
  {
    _emitInstruction(INST_PAUSE);
  }

  //! @brief Packed Average (SSE2).
  inline void pavgb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }
  //! @brief Packed Average (SSE2).
  inline void pavgb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGB, &dst, &src);
  }

  //! @brief Packed Average (SSE2).
  inline void pavgw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }
  //! @brief Packed Average (SSE2).
  inline void pavgw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PAVGW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (BYTES) (SSE2).
  inline void pcmpeqb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }
  //! @brief Packed Compare for Equal (BYTES) (SSE2).
  inline void pcmpeqb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQB, &dst, &src);
  }

  //! @brief Packed Compare for Equal (WORDS) (SSE2).
  inline void pcmpeqw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }
  //! @brief Packed Compare for Equal (WORDS) (SSE2).
  inline void pcmpeqw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQW, &dst, &src);
  }

  //! @brief Packed Compare for Equal (DWORDS) (SSE2).
  inline void pcmpeqd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }
  //! @brief Packed Compare for Equal (DWORDS) (SSE2).
  inline void pcmpeqd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQD, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (BYTES) (SSE2).
  inline void pcmpgtb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (BYTES) (SSE2).
  inline void pcmpgtb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTB, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (WORDS) (SSE2).
  inline void pcmpgtw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (WORDS) (SSE2).
  inline void pcmpgtw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTW, &dst, &src);
  }

  //! @brief Packed Compare for Greater Than (DWORDS) (SSE2).
  inline void pcmpgtd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }
  //! @brief Packed Compare for Greater Than (DWORDS) (SSE2).
  inline void pcmpgtd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTD, &dst, &src);
  }

  //! @brief Extract Word (SSE2).
  inline void pextrw(const GPVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }
  //! @brief Extract Word (SSE2).
  inline void pextrw(const Mem& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRW, &dst, &src, &imm8);
  }

  //! @brief Packed Signed Integer Word Maximum (SSE2).
  inline void pmaxsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Maximum (SSE2).
  inline void pmaxsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Maximum (SSE2).
  inline void pmaxub(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Maximum (SSE2).
  inline void pmaxub(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUB, &dst, &src);
  }

  //! @brief Packed Signed Integer Word Minimum (SSE2).
  inline void pminsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }
  //! @brief Packed Signed Integer Word Minimum (SSE2).
  inline void pminsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSW, &dst, &src);
  }

  //! @brief Packed Unsigned Integer Byte Minimum (SSE2).
  inline void pminub(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }
  //! @brief Packed Unsigned Integer Byte Minimum (SSE2).
  inline void pminub(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUB, &dst, &src);
  }

  //! @brief Move Byte Mask (SSE2).
  inline void pmovmskb(const GPVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVMSKB, &dst, &src);
  }

  //! @brief Packed Multiply High (SSE2).
  inline void pmulhw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }
  //! @brief Packed Multiply High (SSE2).
  inline void pmulhw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHW, &dst, &src);
  }

  //! @brief Packed Multiply High Unsigned (SSE2).
  inline void pmulhuw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }
  //! @brief Packed Multiply High Unsigned (SSE2).
  inline void pmulhuw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHUW, &dst, &src);
  }

  //! @brief Packed Multiply Low (SSE2).
  inline void pmullw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }
  //! @brief Packed Multiply Low (SSE2).
  inline void pmullw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLW, &dst, &src);
  }

  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }
  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }

  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }
  //! @brief Packed Multiply to QWORD (SSE2).
  inline void pmuludq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULUDQ, &dst, &src);
  }

  //! @brief Bitwise Logical OR (SSE2).
  inline void por(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }
  //! @brief Bitwise Logical OR (SSE2).
  inline void por(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_POR, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslld(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLD, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllq(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLQ, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }
  //! @brief Packed Shift Left Logical (SSE2).
  inline void psllw(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLW, &dst, &src);
  }

  //! @brief Packed Shift Left Logical (SSE2).
  inline void pslldq(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSLLDQ, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psrad(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAD, &dst, &src);
  }

  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }
  //! @brief Packed Shift Right Arithmetic (SSE2).
  inline void psraw(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRAW, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBB, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBW, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBD, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubq(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubq(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }

  //! @brief Packed Subtract (SSE2).
  inline void psubq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }
  //! @brief Packed Subtract (SSE2).
  inline void psubq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBQ, &dst, &src);
  }

  //! @brief Packed Multiply and Add (SSE2).
  inline void pmaddwd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }
  //! @brief Packed Multiply and Add (SSE2).
  inline void pmaddwd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDWD, &dst, &src);
  }

  //! @brief Shuffle Packed DWORDs (SSE2).
  inline void pshufd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFD, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed DWORDs (SSE2).
  inline void pshufd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFD, &dst, &src, &imm8);
  }

  //! @brief Shuffle Packed High Words (SSE2).
  inline void pshufhw(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFHW, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed High Words (SSE2).
  inline void pshufhw(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFHW, &dst, &src, &imm8);
  }

  //! @brief Shuffle Packed Low Words (SSE2).
  inline void pshuflw(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFLW, &dst, &src, &imm8);
  }
  //! @brief Shuffle Packed Low Words (SSE2).
  inline void pshuflw(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PSHUFLW, &dst, &src, &imm8);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrld(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLD, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlq(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLQ, &dst, &src);
  }

  //! @brief DQWord Shift Right Logical (MMX).
  inline void psrldq(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLDQ, &dst, &src);
  }

  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }
  //! @brief Packed Shift Right Logical (SSE2).
  inline void psrlw(const XMMVar& dst, const Imm& src)
  {
    _emitInstruction(INST_PSRLW, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSB, &dst, &src);
  }

  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }
  //! @brief Packed Subtract with Saturation (SSE2).
  inline void psubsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBSW, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSB, &dst, &src);
  }

  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }
  //! @brief Packed Subtract with Unsigned Saturation (SSE2).
  inline void psubusw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSUBUSW, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhbw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhbw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHBW, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhwd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhwd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHWD, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhdq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhdq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHDQ, &dst, &src);
  }

  //! @brief Unpack High Data (SSE2).
  inline void punpckhqdq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKHQDQ, &dst, &src);
  }
  //! @brief Unpack High Data (SSE2).
  inline void punpckhqdq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKHQDQ, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklbw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklbw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLBW, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklwd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklwd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLWD, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpckldq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpckldq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLDQ, &dst, &src);
  }

  //! @brief Unpack Low Data (SSE2).
  inline void punpcklqdq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PUNPCKLQDQ, &dst, &src);
  }
  //! @brief Unpack Low Data (SSE2).
  inline void punpcklqdq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PUNPCKLQDQ, &dst, &src);
  }

  //! @brief Bitwise Exclusive OR (SSE2).
  inline void pxor(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }
  //! @brief Bitwise Exclusive OR (SSE2).
  inline void pxor(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PXOR, &dst, &src);
  }

  //! @brief Shuffle DP-FP (SSE2).
  inline void shufpd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPD, &dst, &src, &imm8);
  }
  //! @brief Shuffle DP-FP (SSE2).
  inline void shufpd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_SHUFPD, &dst, &src, &imm8);
  }

  //! @brief Compute Square Roots of Packed DP-FP Values (SSE2).
  inline void sqrtpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SQRTPD, &dst, &src);
  }
  //! @brief Compute Square Roots of Packed DP-FP Values (SSE2).
  inline void sqrtpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTPD, &dst, &src);
  }

  //! @brief Compute Square Root of Scalar DP-FP Value (SSE2).
  inline void sqrtsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SQRTSD, &dst, &src);
  }
  //! @brief Compute Square Root of Scalar DP-FP Value (SSE2).
  inline void sqrtsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SQRTSD, &dst, &src);
  }

  //! @brief Packed DP-FP Subtract (SSE2).
  inline void subpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Subtract (SSE2).
  inline void subpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBPD, &dst, &src);
  }

  //! @brief Scalar DP-FP Subtract (SSE2).
  inline void subsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_SUBSD, &dst, &src);
  }
  //! @brief Scalar DP-FP Subtract (SSE2).
  inline void subsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_SUBSD, &dst, &src);
  }

  //! @brief Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void ucomisd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UCOMISD, &dst, &src);
  }
  //! @brief Scalar Unordered DP-FP Compare and Set EFLAGS (SSE2).
  inline void ucomisd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UCOMISD, &dst, &src);
  }

  //! @brief Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
  inline void unpckhpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UNPCKHPD, &dst, &src);
  }
  //! @brief Unpack and Interleave High Packed Double-Precision FP Values (SSE2).
  inline void unpckhpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKHPD, &dst, &src);
  }

  //! @brief Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
  inline void unpcklpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_UNPCKLPD, &dst, &src);
  }
  //! @brief Unpack and Interleave Low Packed Double-Precision FP Values (SSE2).
  inline void unpcklpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_UNPCKLPD, &dst, &src);
  }

  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void xorpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_XORPD, &dst, &src);
  }
  //! @brief Bit-wise Logical OR for DP-FP Data (SSE2).
  inline void xorpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_XORPD, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [SSE3]
  // --------------------------------------------------------------------------

  //! @brief Packed DP-FP Add/Subtract (SSE3).
  inline void addsubpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDSUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Add/Subtract (SSE3).
  inline void addsubpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSUBPD, &dst, &src);
  }

  //! @brief Packed SP-FP Add/Subtract (SSE3).
  inline void addsubps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_ADDSUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Add/Subtract (SSE3).
  inline void addsubps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_ADDSUBPS, &dst, &src);
  }

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
  // TODO: NOT IMPLEMENTED BY THE COMPILER.
  //! @brief Store Integer with Truncation (SSE3).
  inline void fisttp(const Mem& dst)
  {
    _emitInstruction(INST_FISTTP, &dst);
  }
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

  //! @brief Packed DP-FP Horizontal Add (SSE3).
  inline void haddpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_HADDPD, &dst, &src);
  }
  //! @brief Packed DP-FP Horizontal Add (SSE3).
  inline void haddpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_HADDPD, &dst, &src);
  }

  //! @brief Packed SP-FP Horizontal Add (SSE3).
  inline void haddps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_HADDPS, &dst, &src);
  }
  //! @brief Packed SP-FP Horizontal Add (SSE3).
  inline void haddps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_HADDPS, &dst, &src);
  }

  //! @brief Packed DP-FP Horizontal Subtract (SSE3).
  inline void hsubpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_HSUBPD, &dst, &src);
  }
  //! @brief Packed DP-FP Horizontal Subtract (SSE3).
  inline void hsubpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_HSUBPD, &dst, &src);
  }

  //! @brief Packed SP-FP Horizontal Subtract (SSE3).
  inline void hsubps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_HSUBPS, &dst, &src);
  }
  //! @brief Packed SP-FP Horizontal Subtract (SSE3).
  inline void hsubps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_HSUBPS, &dst, &src);
  }

  //! @brief Load Unaligned Integer 128 Bits (SSE3).
  inline void lddqu(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_LDDQU, &dst, &src);
  }

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
  //! @brief Set Up Monitor Address (SSE3).
  inline void monitor()
  {
    _emitInstruction(INST_MONITOR);
  }
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

  //! @brief Move One DP-FP and Duplicate (SSE3).
  inline void movddup(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVDDUP, &dst, &src);
  }
  //! @brief Move One DP-FP and Duplicate (SSE3).
  inline void movddup(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVDDUP, &dst, &src);
  }

  //! @brief Move Packed SP-FP High and Duplicate (SSE3).
  inline void movshdup(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSHDUP, &dst, &src);
  }
  //! @brief Move Packed SP-FP High and Duplicate (SSE3).
  inline void movshdup(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSHDUP, &dst, &src);
  }

  //! @brief Move Packed SP-FP Low and Duplicate (SSE3).
  inline void movsldup(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_MOVSLDUP, &dst, &src);
  }
  //! @brief Move Packed SP-FP Low and Duplicate (SSE3).
  inline void movsldup(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVSLDUP, &dst, &src);
  }

#if ASMJIT_NOT_SUPPORTED_BY_COMPILER
  //! @brief Monitor Wait (SSE3).
  inline void mwait()
  {
    _emitInstruction(INST_MWAIT);
  }
#endif // ASMJIT_NOT_SUPPORTED_BY_COMPILER

  // --------------------------------------------------------------------------
  // [SSSE3]
  // --------------------------------------------------------------------------

  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNB, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGNW, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }

  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }
  //! @brief Packed SIGN (SSSE3).
  inline void psignd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSIGND, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDW, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }

  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }
  //! @brief Packed Horizontal Add (SSSE3).
  inline void phaddd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDD, &dst, &src);
  }

  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }
  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }

  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }
  //! @brief Packed Horizontal Add and Saturate (SSSE3).
  inline void phaddsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHADDSW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract (SSSE3).
  inline void phsubd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBD, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }

  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }
  //! @brief Packed Horizontal Subtract and Saturate (SSSE3).
  inline void phsubsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHSUBSW, &dst, &src);
  }

  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }
  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }

  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }
  //! @brief Multiply and Add Packed Signed and Unsigned Bytes (SSSE3).
  inline void pmaddubsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMADDUBSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSB, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSW, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }

  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }
  //! @brief Packed Absolute Value (SSSE3).
  inline void pabsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PABSD, &dst, &src);
  }

  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }
  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }

  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }
  //! @brief Packed Multiply High with Round and Scale (SSSE3).
  inline void pmulhrsw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULHRSW, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const MMVar& dst, const MMVar& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const MMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void pshufb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PSHUFB, &dst, &src);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const MMVar& dst, const MMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const MMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }

  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }
  //! @brief Packed Shuffle Bytes (SSSE3).
  inline void palignr(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PALIGNR, &dst, &src, &imm8);
  }

  // --------------------------------------------------------------------------
  // [SSE4.1]
  // --------------------------------------------------------------------------

  //! @brief Blend Packed DP-FP Values (SSE4.1).
  inline void blendpd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPD, &dst, &src, &imm8);
  }
  //! @brief Blend Packed DP-FP Values (SSE4.1).
  inline void blendpd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPD, &dst, &src, &imm8);
  }

  //! @brief Blend Packed SP-FP Values (SSE4.1).
  inline void blendps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPS, &dst, &src, &imm8);
  }
  //! @brief Blend Packed SP-FP Values (SSE4.1).
  inline void blendps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_BLENDPS, &dst, &src, &imm8);
  }

  //! @brief Variable Blend Packed DP-FP Values (SSE4.1).
  inline void blendvpd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_BLENDVPD, &dst, &src);
  }
  //! @brief Variable Blend Packed DP-FP Values (SSE4.1).
  inline void blendvpd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_BLENDVPD, &dst, &src);
  }

  //! @brief Variable Blend Packed SP-FP Values (SSE4.1).
  inline void blendvps(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_BLENDVPS, &dst, &src);
  }
  //! @brief Variable Blend Packed SP-FP Values (SSE4.1).
  inline void blendvps(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_BLENDVPS, &dst, &src);
  }

  //! @brief Dot Product of Packed DP-FP Values (SSE4.1).
  inline void dppd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPD, &dst, &src, &imm8);
  }
  //! @brief Dot Product of Packed DP-FP Values (SSE4.1).
  inline void dppd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPD, &dst, &src, &imm8);
  }

  //! @brief Dot Product of Packed SP-FP Values (SSE4.1).
  inline void dpps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPS, &dst, &src, &imm8);
  }
  //! @brief Dot Product of Packed SP-FP Values (SSE4.1).
  inline void dpps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_DPPS, &dst, &src, &imm8);
  }

  //! @brief Extract Packed SP-FP Value (SSE4.1).
  inline void extractps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_EXTRACTPS, &dst, &src, &imm8);
  }
  //! @brief Extract Packed SP-FP Value (SSE4.1).
  inline void extractps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_EXTRACTPS, &dst, &src, &imm8);
  }

  //! @brief Load Double Quadword Non-Temporal Aligned Hint (SSE4.1).
  inline void movntdqa(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_MOVNTDQA, &dst, &src);
  }

  //! @brief Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
  inline void mpsadbw(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_MPSADBW, &dst, &src, &imm8);
  }
  //! @brief Compute Multiple Packed Sums of Absolute Difference (SSE4.1).
  inline void mpsadbw(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_MPSADBW, &dst, &src, &imm8);
  }

  //! @brief Pack with Unsigned Saturation (SSE4.1).
  inline void packusdw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PACKUSDW, &dst, &src);
  }
  //! @brief Pack with Unsigned Saturation (SSE4.1).
  inline void packusdw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PACKUSDW, &dst, &src);
  }

  //! @brief Variable Blend Packed Bytes (SSE4.1).
  inline void pblendvb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PBLENDVB, &dst, &src);
  }
  //! @brief Variable Blend Packed Bytes (SSE4.1).
  inline void pblendvb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PBLENDVB, &dst, &src);
  }

  //! @brief Blend Packed Words (SSE4.1).
  inline void pblendw(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PBLENDW, &dst, &src, &imm8);
  }
  //! @brief Blend Packed Words (SSE4.1).
  inline void pblendw(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PBLENDW, &dst, &src, &imm8);
  }

  //! @brief Compare Packed Qword Data for Equal (SSE4.1).
  inline void pcmpeqq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPEQQ, &dst, &src);
  }
  //! @brief Compare Packed Qword Data for Equal (SSE4.1).
  inline void pcmpeqq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPEQQ, &dst, &src);
  }

  //! @brief Extract Byte (SSE4.1).
  inline void pextrb(const GPVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRB, &dst, &src, &imm8);
  }
  //! @brief Extract Byte (SSE4.1).
  inline void pextrb(const Mem& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRB, &dst, &src, &imm8);
  }

  //! @brief Extract Dword (SSE4.1).
  inline void pextrd(const GPVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRD, &dst, &src, &imm8);
  }
  //! @brief Extract Dword (SSE4.1).
  inline void pextrd(const Mem& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRD, &dst, &src, &imm8);
  }

  //! @brief Extract Dword (SSE4.1).
  inline void pextrq(const GPVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRQ, &dst, &src, &imm8);
  }
  //! @brief Extract Dword (SSE4.1).
  inline void pextrq(const Mem& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PEXTRQ, &dst, &src, &imm8);
  }

  //! @brief Packed Horizontal Word Minimum (SSE4.1).
  inline void phminposuw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PHMINPOSUW, &dst, &src);
  }
  //! @brief Packed Horizontal Word Minimum (SSE4.1).
  inline void phminposuw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PHMINPOSUW, &dst, &src);
  }

  //! @brief Insert Byte (SSE4.1).
  inline void pinsrb(const XMMVar& dst, const GPVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRB, &dst, &src, &imm8);
  }
  //! @brief Insert Byte (SSE4.1).
  inline void pinsrb(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRB, &dst, &src, &imm8);
  }

  //! @brief Insert Dword (SSE4.1).
  inline void pinsrd(const XMMVar& dst, const GPVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRD, &dst, &src, &imm8);
  }
  //! @brief Insert Dword (SSE4.1).
  inline void pinsrd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRD, &dst, &src, &imm8);
  }

  //! @brief Insert Dword (SSE4.1).
  inline void pinsrq(const XMMVar& dst, const GPVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRQ, &dst, &src, &imm8);
  }
  //! @brief Insert Dword (SSE4.1).
  inline void pinsrq(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRQ, &dst, &src, &imm8);
  }

  //! @brief Insert Word (SSE2).
  inline void pinsrw(const XMMVar& dst, const GPVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }
  //! @brief Insert Word (SSE2).
  inline void pinsrw(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PINSRW, &dst, &src, &imm8);
  }

  //! @brief Maximum of Packed Word Integers (SSE4.1).
  inline void pmaxuw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXUW, &dst, &src);
  }
  //! @brief Maximum of Packed Word Integers (SSE4.1).
  inline void pmaxuw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUW, &dst, &src);
  }

  //! @brief Maximum of Packed Signed Byte Integers (SSE4.1).
  inline void pmaxsb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXSB, &dst, &src);
  }
  //! @brief Maximum of Packed Signed Byte Integers (SSE4.1).
  inline void pmaxsb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSB, &dst, &src);
  }

  //! @brief Maximum of Packed Signed Dword Integers (SSE4.1).
  inline void pmaxsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXSD, &dst, &src);
  }
  //! @brief Maximum of Packed Signed Dword Integers (SSE4.1).
  inline void pmaxsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXSD, &dst, &src);
  }

  //! @brief Maximum of Packed Unsigned Dword Integers (SSE4.1).
  inline void pmaxud(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMAXUD, &dst, &src);
  }
  //! @brief Maximum of Packed Unsigned Dword Integers (SSE4.1).
  inline void pmaxud(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMAXUD, &dst, &src);
  }

  //! @brief Minimum of Packed Signed Byte Integers (SSE4.1).
  inline void pminsb(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINSB, &dst, &src);
  }
  //! @brief Minimum of Packed Signed Byte Integers (SSE4.1).
  inline void pminsb(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSB, &dst, &src);
  }

  //! @brief Minimum of Packed Word Integers (SSE4.1).
  inline void pminuw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINUW, &dst, &src);
  }
  //! @brief Minimum of Packed Word Integers (SSE4.1).
  inline void pminuw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUW, &dst, &src);
  }

  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminud(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINUD, &dst, &src);
  }
  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminud(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINUD, &dst, &src);
  }

  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminsd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMINSD, &dst, &src);
  }
  //! @brief Minimum of Packed Dword Integers (SSE4.1).
  inline void pminsd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMINSD, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXBW, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBW, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXBD, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBD, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXBQ, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxbq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXBQ, &dst, &src);
  }

  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxwd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXWD, &dst, &src);
  }
  //! @brief Packed Move with Sign Extend (SSE4.1).
  inline void pmovsxwd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXWD, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovsxwq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXWQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovsxwq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXWQ, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovsxdq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVSXDQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovsxdq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVSXDQ, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbw(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXBW, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbw(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBW, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXBD, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBD, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXBQ, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxbq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXBQ, &dst, &src);
  }

  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxwd(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXWD, &dst, &src);
  }
  //! @brief Packed Move with Zero Extend (SSE4.1).
  inline void pmovzxwd(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXWD, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovzxwq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXWQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovzxwq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXWQ, &dst, &src);
  }

  //! @brief (SSE4.1).
  inline void pmovzxdq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMOVZXDQ, &dst, &src);
  }
  //! @brief (SSE4.1).
  inline void pmovzxdq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMOVZXDQ, &dst, &src);
  }

  //! @brief Multiply Packed Signed Dword Integers (SSE4.1).
  inline void pmuldq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULDQ, &dst, &src);
  }
  //! @brief Multiply Packed Signed Dword Integers (SSE4.1).
  inline void pmuldq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULDQ, &dst, &src);
  }

  //! @brief Multiply Packed Signed Integers and Store Low Result (SSE4.1).
  inline void pmulld(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PMULLD, &dst, &src);
  }
  //! @brief Multiply Packed Signed Integers and Store Low Result (SSE4.1).
  inline void pmulld(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PMULLD, &dst, &src);
  }

  //! @brief Logical Compare (SSE4.1).
  inline void ptest(const XMMVar& op1, const XMMVar& op2)
  {
    _emitInstruction(INST_PTEST, &op1, &op2);
  }
  //! @brief Logical Compare (SSE4.1).
  inline void ptest(const XMMVar& op1, const Mem& op2)
  {
    _emitInstruction(INST_PTEST, &op1, &op2);
  }

  //! Round Packed SP-FP Values @brief (SSE4.1).
  inline void roundps(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPS, &dst, &src, &imm8);
  }
  //! Round Packed SP-FP Values @brief (SSE4.1).
  inline void roundps(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPS, &dst, &src, &imm8);
  }

  //! @brief Round Scalar SP-FP Values (SSE4.1).
  inline void roundss(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSS, &dst, &src, &imm8);
  }
  //! @brief Round Scalar SP-FP Values (SSE4.1).
  inline void roundss(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSS, &dst, &src, &imm8);
  }

  //! @brief Round Packed DP-FP Values (SSE4.1).
  inline void roundpd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPD, &dst, &src, &imm8);
  }
  //! @brief Round Packed DP-FP Values (SSE4.1).
  inline void roundpd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDPD, &dst, &src, &imm8);
  }

  //! @brief Round Scalar DP-FP Values (SSE4.1).
  inline void roundsd(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSD, &dst, &src, &imm8);
  }
  //! @brief Round Scalar DP-FP Values (SSE4.1).
  inline void roundsd(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_ROUNDSD, &dst, &src, &imm8);
  }

  // --------------------------------------------------------------------------
  // [SSE4.2]
  // --------------------------------------------------------------------------

  //! @brief Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
  inline void crc32(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_CRC32, &dst, &src);
  }
  //! @brief Accumulate CRC32 Value (polynomial 0x11EDC6F41) (SSE4.2).
  inline void crc32(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_CRC32, &dst, &src);
  }

  //! @brief Packed Compare Explicit Length Strings, Return Index (SSE4.2).
  inline void pcmpestri(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRI, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Explicit Length Strings, Return Index (SSE4.2).
  inline void pcmpestri(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRI, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpestrm(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRM, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Explicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpestrm(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPESTRM, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Implicit Length Strings, Return Index (SSE4.2).
  inline void pcmpistri(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRI, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Implicit Length Strings, Return Index (SSE4.2).
  inline void pcmpistri(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRI, &dst, &src, &imm8);
  }

  //! @brief Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpistrm(const XMMVar& dst, const XMMVar& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRM, &dst, &src, &imm8);
  }
  //! @brief Packed Compare Implicit Length Strings, Return Mask (SSE4.2).
  inline void pcmpistrm(const XMMVar& dst, const Mem& src, const Imm& imm8)
  {
    _emitInstruction(INST_PCMPISTRM, &dst, &src, &imm8);
  }

  //! @brief Compare Packed Data for Greater Than (SSE4.2).
  inline void pcmpgtq(const XMMVar& dst, const XMMVar& src)
  {
    _emitInstruction(INST_PCMPGTQ, &dst, &src);
  }
  //! @brief Compare Packed Data for Greater Than (SSE4.2).
  inline void pcmpgtq(const XMMVar& dst, const Mem& src)
  {
    _emitInstruction(INST_PCMPGTQ, &dst, &src);
  }

  //! @brief Return the Count of Number of Bits Set to 1 (SSE4.2).
  inline void popcnt(const GPVar& dst, const GPVar& src)
  {
    _emitInstruction(INST_POPCNT, &dst, &src);
  }
  //! @brief Return the Count of Number of Bits Set to 1 (SSE4.2).
  inline void popcnt(const GPVar& dst, const Mem& src)
  {
    _emitInstruction(INST_POPCNT, &dst, &src);
  }

  // --------------------------------------------------------------------------
  // [AMD only]
  // --------------------------------------------------------------------------

  //! @brief Prefetch (3dNow - Amd).
  //!
  //! Loads the entire 64-byte aligned memory sequence containing the
  //! specified memory address into the L1 data cache. The position of
  //! the specified memory address within the 64-byte cache line is
  //! irrelevant. If a cache hit occurs, or if a memory fault is detected,
  //! no bus cycle is initiated and the instruction is treated as a NOP.
  inline void amd_prefetch(const Mem& mem)
  {
    _emitInstruction(INST_AMD_PREFETCH, &mem);
  }

  //! @brief Prefetch and set cache to modified (3dNow - Amd).
  //!
  //! The PREFETCHW instruction loads the prefetched line and sets the
  //! cache-line state to Modified, in anticipation of subsequent data
  //! writes to the line. The PREFETCH instruction, by contrast, typically
  //! sets the cache-line state to Exclusive (depending on the hardware
  //! implementation).
  inline void amd_prefetchw(const Mem& mem)
  {
    _emitInstruction(INST_AMD_PREFETCHW, &mem);
  }

  // --------------------------------------------------------------------------
  // [Intel only]
  // --------------------------------------------------------------------------

  //! @brief Move Data After Swapping Bytes (SSE3 - Intel Atom).
  inline void movbe(const GPVar& dst, const Mem& src)
  {
    ASMJIT_ASSERT(!dst.isGPB());
    _emitInstruction(INST_MOVBE, &dst, &src);
  }

  //! @brief Move Data After Swapping Bytes (SSE3 - Intel Atom).
  inline void movbe(const Mem& dst, const GPVar& src)
  {
    ASMJIT_ASSERT(!src.isGPB());
    _emitInstruction(INST_MOVBE, &dst, &src);
  }

  // -------------------------------------------------------------------------
  // [Emit Options]
  // -------------------------------------------------------------------------

  //! @brief Assert LOCK# Signal Prefix.
  //!
  //! This instruction causes the processor's LOCK# signal to be asserted
  //! during execution of the accompanying instruction (turns the
  //! instruction into an atomic instruction). In a multiprocessor environment,
  //! the LOCK# signal insures that the processor has exclusive use of any shared
  //! memory while the signal is asserted.
  //!
  //! The LOCK prefix can be prepended only to the following instructions and
  //! to those forms of the instructions that use a memory operand: ADD, ADC,
  //! AND, BTC, BTR, BTS, CMPXCHG, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD,
  //! and XCHG. An undefined opcode exception will be generated if the LOCK
  //! prefix is used with any other instruction. The XCHG instruction always
  //! asserts the LOCK# signal regardless of the presence or absence of the LOCK
  //! prefix.
  inline void lock()
  {
    _emitOptions |= EMIT_OPTION_LOCK_PREFIX;
  }

  //! @brief Force REX prefix to be emitted.
  //!
  //! This option should be used carefully, because there are unencodable
  //! combinations. If you want to access ah, bh, ch or dh registers then you
  //! can't emit REX prefix and it will cause an illegal instruction error.
  //!
  //! @note REX prefix is only valid for X64/AMD64 platform.
  //!
  //! @sa @c EMIT_OPTION_REX_PREFIX.
  inline void rex()
  {
    _emitOptions |= EMIT_OPTION_REX_PREFIX;
  }
};

// ============================================================================
// [AsmJit::Compiler]
// ============================================================================

//! @brief Compiler - high level code generation.
//!
//! This class is used to store instruction stream and allows to modify
//! it on the fly. It uses different concept than @c AsmJit::Assembler class
//! and in fact @c AsmJit::Assembler is only used as a backend. Compiler never
//! emits machine code and each instruction you use is stored to instruction
//! array instead. This allows to modify instruction stream later and for
//! example to reorder instructions to make better performance.
//!
//! Using @c AsmJit::Compiler moves code generation to higher level. Higher
//! level constructs allows to write more abstract and extensible code that
//! is not possible with pure @c AsmJit::Assembler class. Because
//! @c AsmJit::Compiler needs to create many objects and lifetime of these
//! objects is small (same as @c AsmJit::Compiler lifetime itself) it uses
//! very fast memory management model. This model allows to create object
//! instances in nearly zero time (compared to @c malloc() or @c new()
//! operators) so overhead by creating machine code by @c AsmJit::Compiler
//! is minimized.
//!
//! @section AsmJit_Compiler_TheStory The Story
//!
//! Before telling you how Compiler works I'd like to write a story. I'd like
//! to cover reasons why this class was created and why I'm recommending to use 
//! it. When I released the first version of AsmJit (0.1) it was a toy. The
//! first function I wrote was function which is still available as testjit and
//! which simply returns 1024. The reason why function works for both 32-bit/
//! 64-bit mode and for Windows/Unix specific calling conventions is luck, no
//! arguments usage and no registers usage except returning value in EAX/RAX.
//!
//! Then I started a project called BlitJit which was targetted to generating
//! JIT code for computer graphics. After writing some lines I decided that I
//! can't join pieces of code together without abstraction, should be
//! pixels source pointer in ESI/RSI or EDI/RDI or it's completelly 
//! irrellevant? What about destination pointer and SSE2 register for reading
//! input pixels? The simple answer might be "just pick some one and use it".
//!
//! Another reason for abstraction is function calling-conventions. It's really
//! not easy to write assembler code for 32-bit and 64-bit platform supporting
//! three calling conventions (32-bit is similar between Windows and Unix, but
//! 64-bit calling conventions are different).
//!
//! At this time I realized that I can't write code which uses named registers,
//! I need to abstract it. In most cases you don't need specific register, you
//! need to emit instruction that does something with 'virtual' register(s),
//! memory, immediate or label.
//!
//! The first version of AsmJit with Compiler was 0.5 (or 0.6?, can't remember).
//! There was support for 32-bit and 64-bit mode, function calling conventions,
//! but when emitting instructions the developer needed to decide which 
//! registers are changed, which are only read or completely overwritten. This
//! model helped a lot when generating code, especially when joining more
//! code-sections together, but there was also small possibility for mistakes.
//! Simply the first version of Compiler was great improvement over low-level 
//! Assembler class, but the API design wasn't perfect.
//!
//! The second version of Compiler, completelly rewritten and based on 
//! different goals, is part of AsmJit starting at version 1.0. This version
//! was designed after the first one and it contains serious improvements over
//! the old one. The first improvement is that you just use instructions with 
//! virtual registers - called variables. When using compiler there is no way
//! to use native registers, there are variables instead. AsmJit is smarter 
//! than before and it knows which register is needed only for read (r), 
//! read/write (w) or overwrite (x). Supported are also instructions which 
//! are using some registers in implicit way (these registers are not part of
//! instruction definition in string form). For example to use CPUID instruction 
//! you must give it four variables which will be automatically allocated to
//! input/output registers (EAX, EBX, ECX, EDX).
//! 
//! Another improvement is algorithm used by a register allocator. In first
//! version the registers were allocated when creating instruction stream. In
//! new version registers are allocated after calling @c Compiler::make(). This
//! means that register allocator has information about scope of all variables
//! and their usage statistics. The algorithm to allocate registers is very
//! simple and it's always called as a 'linear scan register allocator'. When
//! you get out of registers the all possible variables are scored and the worst
//! is spilled. Of course algorithm ignores the variables used for current
//! instruction.
//!
//! In addition, because registers are allocated after the code stream is
//! generated, the state switches between jumps are handled by Compiler too.
//! You don't need to worry about jumps, compiler always do this dirty work 
//! for you.
//!
//! The nearly last thing I'd like to present is calling other functions from 
//! the generated code. AsmJit uses a @c FunctionPrototype class to hold
//! the function parameters, their position in stack (or register index) and
//! function return value. This class is used internally, but it can be
//! used to create your own function calling-convention. All standard function
//! calling conventions are implemented.
//!
//! Please enjoy the new version of Compiler, it was created for writing a
//! low-level code using high-level API, leaving developer to concentrate to
//! real problems and not to solving a register puzzle.
//!
//! @section AsmJit_Compiler_CodeGeneration Code Generation
//!
//! First that is needed to know about compiler is that compiler never emits
//! machine code. It's used as a middleware between @c AsmJit::Assembler and
//! your code. There is also convenience method @c make() that allows to
//! generate machine code directly without creating @c AsmJit::Assembler
//! instance.
//!
//! Comparison of generating machine code through @c Assembler and directly
//! by @c Compiler:
//!
//! @code
//! // Assembler instance is low level code generation class that emits
//! // machine code.
//! Assembler a;
//!
//! // Compiler instance is high level code generation class that stores all
//! // instructions in internal representation.
//! Compiler c;
//!
//! // ... put your code here ...
//!
//! // Final step - generate code. AsmJit::Compiler::serialize() will serialize
//! // all instructions into Assembler and this ensures generating real machine
//! // code.
//! c.serialize(a);
//!
//! // Your function
//! void* fn = a.make();
//! @endcode
//!
//! Example how to generate machine code using only @c Compiler (preferred):
//!
//! @code
//! // Compiler instance is enough.
//! Compiler c;
//!
//! // ... put your code here ...
//!
//! // Your function
//! void* fn = c.make();
//! @endcode
//!
//! You can see that there is @c AsmJit::Compiler::serialize() function that
//! emits instructions into @c AsmJit::Assembler(). This layered architecture
//! means that each class is used for something different and there is no code
//! duplication. For convenience there is also @c AsmJit::Compiler::make()
//! method that can create your function using @c AsmJit::Assembler, but
//! internally (this is preffered bahavior when using @c AsmJit::Compiler).
//!
//! The @c make() method allocates memory using @c CodeGenerator instance passed
//! into the @c Compiler constructor. If code generator is used to create JIT
//! function then virtual memory allocated by @c MemoryManager is used. To get
//! global memory manager use @c MemoryManager::getGlobal().
//!
//! @code
//! // Compiler instance is enough.
//! Compiler c;
//!
//! // ... put your code using Compiler instance ...
//!
//! // Your function
//! void* fn = c.make();
//!
//! // Free it if you don't want it anymore
//! // (using global memory manager instance)
//! MemoryManager::getGlobal()->free(fn);
//! @endcode
//!
//! @section AsmJit_Compiler_Functions Functions
//!
//! To build functions with @c Compiler, see @c AsmJit::Compiler::newFunction()
//! method.
//!
//! @section AsmJit_Compiler_Variables Variables
//!
//! Compiler is able to manage variables and function arguments. Internally
//! there is no difference between function argument and variable declared
//! inside. To get function argument you use @c argGP() method and to declare
//! variable use @c newGP(), @c newMM() and @c newXMM() methods. The @c newXXX()
//! methods accept also parameter describing the variable type. For example
//! the @c newGP() method always creates variable which size matches the target
//! architecture size (for 32-bit target the 32-bit variable is created, for
//! 64-bit target the variable size is 64-bit). To override this behavior the
//! variable type must be specified.
//!
//! @code
//! // Compiler and function declaration - void f(int*);
//! Compiler c;
//! c.newFunction(CALL_CONV_DEFAULT, BuildFunction1<int*>());
//!
//! // Get argument variable (it's pointer).
//! GPVar a1(c.argGP(0));
//!
//! // Create your variables.
//! GPVar x1(c.newGP(VARIABLE_TYPE_GPD));
//! GPVar x2(c.newGP(VARIABLE_TYPE_GPD));
//!
//! // Init your variables.
//! c.mov(x1, 1);
//! c.mov(x2, 2);
//!
//! // ... your code ...
//! c.add(x1, x2);
//! // ... your code ...
//!
//! // Store result to a given pointer in first argument
//! c.mov(dword_ptr(a1), x1);
//!
//! // End of function body.
//! c.endFunction();
//!
//! // Make the function.
//! typedef void (*MyFn)(int*);
//! MyFn fn = function_cast<MyFn>(c.make());
//! @endcode
//!
//! This code snipped needs to be explained. You can see that there are more 
//! variable types that can be used by @c Compiler. Most useful variables can
//! be allocated using general purpose registers (@c GPVar), MMX registers 
//! (@c MMVar) or SSE registers (@c XMMVar).
//!
//! X86/X64 variable types:
//! 
//! - @c VARIABLE_TYPE_GPD - 32-bit general purpose register (EAX, EBX, ...).
//! - @c VARIABLE_TYPE_GPQ - 64-bit general purpose register (RAX, RBX, ...).
//! - @c VARIABLE_TYPE_GPN - 32-bit or 64-bit general purpose register, depends
//!   to target architecture. Mapped to @c VARIABLE_TYPE_GPD or @c VARIABLE_TYPE_GPQ.
//!
//! - @c VARIABLE_TYPE_X87 - 80-bit floating point stack register st(0 to 7).
//! - @c VARIABLE_TYPE_X87_1F - 32-bit floating point stack register st(0 to 7).
//! - @c VARIABLE_TYPE_X87_1D - 64-bit floating point stack register st(0 to 7).
//!
//! - @c VARIALBE_TYPE_MM - 64-bit MMX register.
//!
//! - @c VARIABLE_TYPE_XMM - 128-bit SSE register.
//! - @c VARIABLE_TYPE_XMM_1F - 128-bit SSE register which contains 
//!   scalar 32-bit single precision floating point.
//! - @c VARIABLE_TYPE_XMM_1D - 128-bit SSE register which contains
//!   scalar 64-bit double precision floating point.
//! - @c VARIABLE_TYPE_XMM_4F - 128-bit SSE register which contains
//!   4 packed 32-bit single precision floating points.
//! - @c VARIABLE_TYPE_XMM_2D - 128-bit SSE register which contains
//!   2 packed 64-bit double precision floating points.
//!
//! Unified variable types:
//!
//! - @c VARIABLE_TYPE_INT32 - 32-bit general purpose register.
//! - @c VARIABLE_TYPE_INT64 - 64-bit general purpose register.
//! - @c VARIABLE_TYPE_INTPTR - 32-bit or 64-bit general purpose register / pointer.
//!
//! - @c VARIABLE_TYPE_FLOAT - 32-bit single precision floating point.
//! - @c VARIABLE_TYPE_DOUBLE - 64-bit double precision floating point.
//!
//! Variable states:
//!
//! - @c VARIABLE_STATE_UNUSED - State that is assigned to newly created
//!   variables or to not used variables (dereferenced to zero).
//! - @c VARIABLE_STATE_REGISTER - State that means that variable is currently
//!   allocated in register.
//! - @c VARIABLE_STATE_MEMORY - State that means that variable is currently
//!   only in memory location.
//!
//! When you create new variable, initial state is always @c VARIABLE_STATE_UNUSED,
//! allocating it to register or spilling to memory changes this state to
//! @c VARIABLE_STATE_REGISTER or @c VARIABLE_STATE_MEMORY, respectively.
//! During variable lifetime it's usual that its state is changed multiple
//! times. To generate better code, you can control allocating and spilling
//! by using up to four types of methods that allows it (see next list).
//!
//! Explicit variable allocating / spilling methods:
//!
//! - @c Compiler::alloc() - Explicit method to alloc variable into
//!      register. You can use this before loops or code blocks.
//!
//! - @c Compiler::spill() - Explicit method to spill variable. If variable
//!      is in register and you call this method, it's moved to its home memory
//!      location. If variable is not in register no operation is performed.
//!
//! - @c Compiler::unuse() - Unuse variable (you can use this to end the
//!      variable scope or sub-scope).
//!
//! Please see AsmJit tutorials (testcompiler.cpp and testvariables.cpp) for
//! more complete examples.
//!
//! @section AsmJit_Compiler_MemoryManagement Memory Management
//!
//! @c Compiler Memory management follows these rules:
//! - Everything created by @c Compiler is always freed by @c Compiler.
//! - To get decent performance, compiler always uses larger memory buffer
//!   for objects to allocate and when compiler instance is destroyed, this
//!   buffer is freed. Destructors of active objects are called when
//!   destroying compiler instance. Destructors of abadonded compiler
//!   objects are called immediately after abadonding them.
//! - This type of memory management is called 'zone memory management'.
//!
//! This means that you can't use any @c Compiler object after destructing it,
//! it also means that each object like @c Label, @c Var and others are created
//! and managed by @c Compiler itself. These objects contain ID which is used
//! internally by Compiler to store additional information about these objects.
//!
//! @section AsmJit_Compiler_StateManagement Control-Flow and State Management.
//!
//! The @c Compiler automatically manages state of the variables when using
//! control flow instructions like jumps, conditional jumps and calls. There
//! is minimal heuristics for choosing the method how state is saved or restored.
//!
//! Generally the state can be changed only when using jump or conditional jump
//! instruction. When using non-conditional jump then state change is embedded
//! into the instruction stream before the jump. When using conditional jump
//! the @c Compiler decides whether to restore state before the jump or whether
//! to use another block where state is restored. The last case is that no-code
//! have to be emitted and there is no state change (this is of course ideal).
//!
//! Choosing whether to embed 'restore-state' section before conditional jump
//! is quite simple. If jump is likely to be 'taken' then code is embedded, if
//! jump is unlikely to be taken then the small code section for state-switch
//! will be generated instead.
//!
//! Next example is the situation where the extended code block is used to
//! do state-change:
//!
//! @code
//! Compiler c;
//!
//! c.newFunction(CALL_CONV_DEFAULT, FunctionBuilder0<Void>());
//! c.getFunction()->setHint(FUNCTION_HINT_NAKED, true);
//!
//! // Labels.
//! Label L0 = c.newLabel();
//!
//! // Variables.
//! GPVar var0 = c.newGP();
//! GPVar var1 = c.newGP();
//!
//! // Cleanup. After these two lines, the var0 and var1 will be always stored
//! // in registers. Our example is very small, but in larger code the var0 can
//! // be spilled by xor(var1, var1).
//! c.xor_(var0, var0);
//! c.xor_(var1, var1);
//! c.cmp(var0, var1);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//!
//! // We manually spill these variables.
//! c.spill(var0);
//! c.spill(var1);
//! // State:
//! //   var0 - memory.
//! //   var1 - memory.
//!
//! // Conditional jump to L0. It will be always taken, but compiler thinks that
//! // it is unlikely taken so it will embed state change code somewhere.
//! c.je(L0);
//!
//! // Do something. The variables var0 and var1 will be allocated again.
//! c.add(var0, 1);
//! c.add(var1, 2);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//!
//! // Bind label here, the state is not changed.
//! c.bind(L0);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//!
//! // We need to use var0 and var1, because if compiler detects that variables
//! // are out of scope then it optimizes the state-change.
//! c.sub(var0, var1);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//!
//! c.endFunction();
//! @endcode
//!
//! The output:
//!
//! @verbatim
//! xor eax, eax                    ; xor var_0, var_0
//! xor ecx, ecx                    ; xor var_1, var_1
//! cmp eax, ecx                    ; cmp var_0, var_1
//! mov [esp - 24], eax             ; spill var_0
//! mov [esp - 28], ecx             ; spill var_1
//! je L0_Switch
//! mov eax, [esp - 24]             ; alloc var_0
//! add eax, 1                      ; add var_0, 1
//! mov ecx, [esp - 28]             ; alloc var_1
//! add ecx, 2                      ; add var_1, 2
//! L0:
//! sub eax, ecx                    ; sub var_0, var_1
//! ret
//!
//! ; state-switch begin
//! L0_Switch0:
//! mov eax, [esp - 24]             ; alloc var_0
//! mov ecx, [esp - 28]             ; alloc var_1
//! jmp short L0
//! ; state-switch end
//! @endverbatim
//!
//! You can see that the state-switch section was generated (see L0_Switch0).
//! The compiler is unable to restore state immediately when emitting the
//! forward jump (the code is generated from first to last instruction and
//! the target state is simply not known at this time).
//!
//! To tell @c Compiler that you want to embed state-switch code before jump
//! it's needed to create backward jump (where also processor expects that it
//! will be taken). To demonstrate the possibility to embed state-switch before
//! jump we use slightly modified code:
//!
//! @code
//! Compiler c;
//! 
//! c.newFunction(CALL_CONV_DEFAULT, FunctionBuilder0<Void>());
//! c.getFunction()->setHint(FUNCTION_HINT_NAKED, true);
//! 
//! // Labels.
//! Label L0 = c.newLabel();
//! 
//! // Variables.
//! GPVar var0 = c.newGP();
//! GPVar var1 = c.newGP();
//! 
//! // Cleanup. After these two lines, the var0 and var1 will be always stored
//! // in registers. Our example is very small, but in larger code the var0 can
//! // be spilled by xor(var1, var1).
//! c.xor_(var0, var0);
//! c.xor_(var1, var1);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//! 
//! // We manually spill these variables.
//! c.spill(var0);
//! c.spill(var1);
//! // State:
//! //   var0 - memory.
//! //   var1 - memory.
//! 
//! // Bind our label here.
//! c.bind(L0);
//! 
//! // Do something, the variables will be allocated again.
//! c.add(var0, 1);
//! c.add(var1, 2);
//! // State:
//! //   var0 - register.
//! //   var1 - register.
//! 
//! // Backward conditional jump to L0. The default behavior is that it is taken
//! // so state-change code will be embedded here.
//! c.je(L0);
//! 
//! c.endFunction();
//! @endcode
//!
//! The output:
//!
//! @verbatim
//! xor ecx, ecx                    ; xor var_0, var_0
//! xor edx, edx                    ; xor var_1, var_1
//! mov [esp - 24], ecx             ; spill var_0
//! mov [esp - 28], edx             ; spill var_1
//! L.2:
//! mov ecx, [esp - 24]             ; alloc var_0
//! add ecx, 1                      ; add var_0, 1
//! mov edx, [esp - 28]             ; alloc var_1
//! add edx, 2                      ; add var_1, 2
//!
//! ; state-switch begin
//! mov [esp - 24], ecx             ; spill var_0
//! mov [esp - 28], edx             ; spill var_1
//! ; state-switch end
//!
//! je short L.2
//! ret
//! @endverbatim
//!
//! Please notice where the state-switch section is located. The @c Compiler 
//! decided that jump is likely to be taken so the state change is embedded
//! before the conditional jump. To change this behavior into the previous
//! case it's needed to add a hint (@c HINT_TAKEN or @c HINT_NOT_TAKEN).
//!
//! Replacing the <code>c.je(L0)</code> by <code>c.je(L0, HINT_NOT_TAKEN)
//! will generate code like this:
//!
//! @verbatim
//! xor ecx, ecx                    ; xor var_0, var_0
//! xor edx, edx                    ; xor var_1, var_1
//! mov [esp - 24], ecx             ; spill var_0
//! mov [esp - 28], edx             ; spill var_1
//! L0:
//! mov ecx, [esp - 24]             ; alloc var_0
//! add ecx, 1                      ; add var_0, a
//! mov edx, [esp - 28]             ; alloc var_1
//! add edx, 2                      ; add var_1, 2
//! je L0_Switch, 2
//! ret
//!
//! ; state-switch begin
//! L0_Switch:
//! mov [esp - 24], ecx             ; spill var_0
//! mov [esp - 28], edx             ; spill var_1
//! jmp short L0
//! ; state-switch end
//! @endverbatim
//!
//! This section provided information about how state-change works. The 
//! behavior is deterministic and it can be overridden.
//!
//! @section AsmJit_Compiler_AdvancedCodeGeneration Advanced Code Generation
//!
//! This section describes advanced method of code generation available to
//! @c Compiler (but also to @c Assembler). When emitting code to instruction
//! stream the methods like @c mov(), @c add(), @c sub() can be called directly
//! (advantage is static-type control performed also by C++ compiler) or 
//! indirectly using @c emit() method. The @c emit() method needs only 
//! instruction code and operands.
//!
//! Example of code generating by standard type-safe API:
//!
//! @code
//! Compiler c;
//! GPVar var0 = c.newGP();
//! GPVar var1 = c.newGP();
//!
//! ...
//!
//! c.mov(var0, imm(0));
//! c.add(var0, var1);
//! c.sub(var0, var1);
//! @endcode
//!
//! The code above can be rewritten as:
//!
//! @code
//! Compiler c;
//! GPVar var0 = c.newGP();
//! GPVar var1 = c.newGP();
//!
//! ...
//!
//! c.emit(INST_MOV, var0, imm(0));
//! c.emit(INST_ADD, var0, var1);
//! c.emit(INST_SUB, var0, var1);
//! @endcode
//!
//! The advantage of first snippet is very friendly API and type-safe control
//! that is controlled by the C++ compiler. The advantage of second snippet is
//! availability to replace or generate instruction code in different places.
//! See the next example how the @c emit() method can be used to generate
//! abstract code.
//!
//! Use case:
//!
//! @code
//! bool emitArithmetic(Compiler& c, XMMVar& var0, XMMVar& var1, const char* op)
//! {
//!   uint code = INVALID_VALUE;
//!
//!   if (strcmp(op, "ADD") == 0)
//!     code = INST_ADDSS;
//!   else if (strcmp(op, "SUBTRACT") == 0)
//!     code = INST_SUBSS;
//!   else if (strcmp(op, "MULTIPLY") == 0)
//!     code = INST_MULSS;
//!   else if (strcmp(op, "DIVIDE") == 0)
//!     code = INST_DIVSS;
//!   else
//!     // Invalid parameter?
//!     return false;
//!
//!   c.emit(code, var0, var1);
//! }
//! @endcode
//!
//! Other use cases are waiting for you! Be sure that instruction you are 
//! emitting is correct and encodable, because if not, Assembler will set
//! error code to @c ERROR_UNKNOWN_INSTRUCTION.
//!
//! @section AsmJit_Compiler_CompilerDetails Compiler Details
//!
//! This section is here for people interested in the compiling process. There
//! are few steps that must be done for each compiled function (or your code).
//!
//! When your @c Compiler instance is ready, you can create function and add
//! emittables using intrinsics or higher level methods implemented by the
//! @c AsmJit::Compiler. When you are done (all instructions serialized) you
//! should call @c AsmJit::Compiler::make() method which will analyze your code,
//! allocate registers and memory for local variables and serialize all emittables
//! to @c AsmJit::Assembler instance. Next steps shows what's done internally
//! before code is serialized into @c AsmJit::Assembler
//!   (implemented in @c AsmJit::Compiler::serialize() method).
//!
//! 1. Compiler try to match function and end-function emittables (these
//!    emittables define the function-body or function block).
//!
//! 2. For all emittables inside the function-body the virtual functions
//!    are called in this order:
//!    - Emittable::prepare()
//!    - Emittable::translate()
//!    - Emittable::emit()
//!    - Emittable::post()
//!
//!    There is some extra work when emitting function prolog / epilog and
//!    register allocator.
//!
//! 3. Emit jump tables data.
//!
//! When everything here ends, @c AsmJit::Assembler contains binary stream
//! that needs only relocation to be callable by C/C++ code.
//!
//! @section AsmJit_Compiler_Differences Summary of Differences between @c Assembler and @c Compiler
//!
//! - Instructions are not translated to machine code immediately, they are
//!   stored as emmitables (see @c AsmJit::Emittable, @c AsmJit::EInstruction).
//! - Contains function builder and ability to call other functions.
//! - Contains register allocator and variable management.
//! - Contains a lot of helper methods to simplify the code generation not
//!   available/possible in @c AsmJit::Assembler.
//! - Ability to pre-process or post-process the code which is being generated.
struct ASMJIT_API Compiler : public CompilerIntrinsics
{
  //! @brief Create the @c Compiler instance.
  Compiler(CodeGenerator* codeGenerator = NULL) ASMJIT_NOTHROW;
  //! @brief Destroy the @c Compiler instance.
  virtual ~Compiler() ASMJIT_NOTHROW;
};

//! @}

} // AsmJit namespace

#undef ASMJIT_NOT_SUPPORTED_BY_COMPILER

// [Api-End]
#include "ApiEnd.h"

// [Guard]
#endif // _ASMJIT_COMPILERX86X64_H

```

`AsmJit/Config.h`:

```h
// This file is designed to be modifyable.

#ifndef _ASMJIT_CONFIG_H
#define _ASMJIT_CONFIG_H

// ============================================================================
// [AsmJit - OS]
// ============================================================================

// #define ASMJIT_WINDOWS 1
// #define ASMJIT_POSIX 2

// ============================================================================
// [AsmJit - Architecture]
// ============================================================================

// #define ASMJIT_X86
// #define ASMJIT_X64

#ifdef PROTECT_X64
#define ASMJIT_X64
#else
#define ASMJIT_X86
#endif

// ============================================================================
// [AsmJit - API]
// ============================================================================

// If you are embedding AsmJit library into your project (statically), undef ASMJIT_API macro.
// ASMJIT_HIDDEN macro can contain visibility (used by GCC)
//   to hide some AsmJit symbols that shouldn't be never exported.

// #define ASMJIT_HIDDEN
#define ASMJIT_API         // 注释后windows编译会错误
// #define ASMJIT_NOTHROW  // ASMJIT_NOTHROW marks functions that never throws

// ============================================================================
// [AsmJit - Memory Management]
// ============================================================================

// #define ASMJIT_MALLOC ::malloc
// #define ASMJIT_REALLOC ::realloc
// #define ASMJIT_FREE ::free

// ============================================================================
// [AsmJit - Debug]
// ============================================================================

// #define ASMJIT_DEBUG
// #define ASMJIT_NO_DEBUG
// #define ASMJIT_ASSERT(exp) do { if (!(exp)) ::AsmJit::assertionFailure(__FILE__, __LINE__, #exp); } while(0)

#endif // _ASMJIT_CONFIG_H

```

`AsmJit/CpuInfo.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "CpuInfo.h"

#if defined(ASMJIT_WINDOWS)
# include <windows.h>
#endif // ASMJIT_WINDOWS

// 2009-02-05: Thanks to Mike Tajmajer for supporting VC7.1 compiler. This
// shouldn't affect x64 compilation, because x64 compiler starts with
// VS2005 (VC8.0).
#if defined(_MSC_VER)

// VC2005 Bug : error C2733
#if _MSC_VER <= 1400
#define _interlockedbittestandreset _interlockedbittestandreset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
#define _interlockedbittestandset _interlockedbittestandset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
#endif

# if _MSC_VER >= 1400 // (>= VS2005)
#  include <intrin.h>
# endif // _MSC_VER >= 1400

#endif // _MSC_VER

#if defined(ASMJIT_POSIX)
#include <errno.h>
#include <string.h>
#include <sys/statvfs.h>
#include <sys/utsname.h>
#include <unistd.h>
#endif // ASMJIT_POSIX

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// helpers
static uint32_t detectNumberOfProcessors(void)
{
#if defined(ASMJIT_WINDOWS)
  SYSTEM_INFO info;
  GetSystemInfo(&info);
  return info.dwNumberOfProcessors;
#elif defined(ASMJIT_POSIX) && defined(_SC_NPROCESSORS_ONLN)
  // It seems that sysconf returns the number of "logical" processors on both
  // mac and linux.  So we get the number of "online logical" processors.
  long res = sysconf(_SC_NPROCESSORS_ONLN);
  if (res == -1) return 1;

  return static_cast<uint32_t>(res);
#else
  return 1;
#endif
}

// This is messy, I know. cpuid is implemented as intrinsic in VS2005, but
// we should support other compilers as well. Main problem is that MS compilers
// in 64-bit mode not allows to use inline assembler, so we need intrinsic and
// we need also asm version.

// cpuid() and detectCpuInfo() for x86 and x64 platforms begins here.
#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
void cpuid(uint32_t in, CpuId* out) ASMJIT_NOTHROW
{
#if defined(_MSC_VER)

// 2009-02-05: Thanks to Mike Tajmajer for supporting VC7.1 compiler.
// ASMJIT_X64 is here only for readibility, only VS2005 can compile 64-bit code.
# if _MSC_VER >= 1400 || defined(ASMJIT_X64)
  // done by intrinsics
  __cpuid(reinterpret_cast<int*>(out->i), in);
# else // _MSC_VER < 1400
  uint32_t cpuid_in = in;
  uint32_t* cpuid_out = out->i;

  __asm
  {
    mov     eax, cpuid_in
    mov     edi, cpuid_out
    cpuid
    mov     dword ptr[edi +  0], eax
    mov     dword ptr[edi +  4], ebx
    mov     dword ptr[edi +  8], ecx
    mov     dword ptr[edi + 12], edx
  }
# endif // _MSC_VER < 1400

#elif defined(__GNUC__)

// Note, need to preserve ebx/rbx register!
# if defined(ASMJIT_X86)
#  define __mycpuid(a, b, c, d, inp) \
  asm ("mov %%ebx, %%edi\n"    \
       "cpuid\n"               \
       "xchg %%edi, %%ebx\n"   \
       : "=a" (a), "=D" (b), "=c" (c), "=d" (d) : "a" (inp))
# else
#  define __mycpuid(a, b, c, d, inp) \
  asm ("mov %%rbx, %%rdi\n"    \
       "cpuid\n"               \
       "xchg %%rdi, %%rbx\n"   \
       : "=a" (a), "=D" (b), "=c" (c), "=d" (d) : "a" (inp))
# endif
  __mycpuid(out->eax, out->ebx, out->ecx, out->edx, in);

#endif // compiler
}

struct CpuVendorInfo
{
  uint32_t id;
  char text[12];
};

static const CpuVendorInfo cpuVendorInfo[] = 
{
  { CPU_VENDOR_INTEL    , { 'G', 'e', 'n', 'u', 'i', 'n', 'e', 'I', 'n', 't', 'e', 'l' } },

  { CPU_VENDOR_AMD      , { 'A', 'u', 't', 'h', 'e', 'n', 't', 'i', 'c', 'A', 'M', 'D' } },
  { CPU_VENDOR_AMD      , { 'A', 'M', 'D', 'i', 's', 'b', 'e', 't', 't', 'e', 'r', '!' } },

  { CPU_VENDOR_NSM      , { 'G', 'e', 'o', 'd', 'e', ' ', 'b', 'y', ' ', 'N', 'S', 'C' } },
  { CPU_VENDOR_NSM      , { 'C', 'y', 'r', 'i', 'x', 'I', 'n', 's', 't', 'e', 'a', 'd' } },

  { CPU_VENDOR_TRANSMETA, { 'G', 'e', 'n', 'u', 'i', 'n', 'e', 'T', 'M', 'x', '8', '6' } },
  { CPU_VENDOR_TRANSMETA, { 'T', 'r', 'a', 'n', 's', 'm', 'e', 't', 'a', 'C', 'P', 'U' } },

  { CPU_VENDOR_VIA      , { 'V', 'I', 'A',  0 , 'V', 'I', 'A',  0 , 'V', 'I', 'A',  0  } },
  { CPU_VENDOR_VIA      , { 'C', 'e', 'n', 't', 'a', 'u', 'r', 'H', 'a', 'u', 'l', 's' } }
};

static inline bool cpuVencorEq(const CpuVendorInfo& info, const char* vendorString)
{
  const uint32_t* a = reinterpret_cast<const uint32_t*>(info.text);
  const uint32_t* b = reinterpret_cast<const uint32_t*>(vendorString);

  return (a[0] == b[0]) &
         (a[1] == b[1]) &
         (a[2] == b[2]) ;
}

static inline void simplifyBrandString(char* s)
{
  // Always clear the current character in the buffer. This ensures that there
  // is no garbage after the string NULL terminator.
  char* d = s;

  char prev = 0;
  char curr = s[0];
  s[0] = '\0';

  for (;;)
  {
    if (curr == 0) break;

    if (curr == ' ')
    {
      if (prev == '@') goto _Skip;
      if (s[1] == ' ' || s[1] == '@') goto _Skip;
    }

    d[0] = curr;
    d++;
    prev = curr;

_Skip:
    curr = *++s;
    s[0] = '\0';
  }

  d[0] = '\0';
}

void detectCpuInfo(CpuInfo* i) ASMJIT_NOTHROW
{
  uint32_t a;

  // First clear our struct
  memset(i, 0, sizeof(CpuInfo));
  memcpy(i->vendor, "Unknown", 8);

  i->numberOfProcessors = detectNumberOfProcessors();

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
  CpuId out;

  // Get vendor string
  cpuid(0, &out);

  memcpy(i->vendor, &out.ebx, 4);
  memcpy(i->vendor + 4, &out.edx, 4);
  memcpy(i->vendor + 8, &out.ecx, 4);

  for (a = 0; a < 3; a++)
  {
    if (cpuVencorEq(cpuVendorInfo[a], i->vendor))
    {
      i->vendorId = cpuVendorInfo[a].id;
      break;
    }
  }

  // get feature flags in ecx/edx, and family/model in eax
  cpuid(1, &out);

  // family and model fields
  i->family   = (out.eax >> 8) & 0x0F;
  i->model    = (out.eax >> 4) & 0x0F;
  i->stepping = (out.eax     ) & 0x0F;

  // use extended family and model fields
  if (i->family == 0x0F)
  {
    i->family += ((out.eax >> 20) & 0xFF);
    i->model  += ((out.eax >> 16) & 0x0F) << 4;
  }

  i->x86ExtendedInfo.processorType        = ((out.eax >> 12) & 0x03);
  i->x86ExtendedInfo.brandIndex           = ((out.ebx      ) & 0xFF);
  i->x86ExtendedInfo.flushCacheLineSize   = ((out.ebx >>  8) & 0xFF) * 8;
  i->x86ExtendedInfo.maxLogicalProcessors = ((out.ebx >> 16) & 0xFF);
  i->x86ExtendedInfo.apicPhysicalId       = ((out.ebx >> 24) & 0xFF);

  if (out.ecx & 0x00000001U) i->features |= CPU_FEATURE_SSE3;
  if (out.ecx & 0x00000002U) i->features |= CPU_FEATURE_PCLMULDQ;
  if (out.ecx & 0x00000008U) i->features |= CPU_FEATURE_MONITOR_MWAIT;
  if (out.ecx & 0x00000200U) i->features |= CPU_FEATURE_SSSE3;
  if (out.ecx & 0x00002000U) i->features |= CPU_FEATURE_CMPXCHG16B;
  if (out.ecx & 0x00080000U) i->features |= CPU_FEATURE_SSE4_1;
  if (out.ecx & 0x00100000U) i->features |= CPU_FEATURE_SSE4_2;
  if (out.ecx & 0x00400000U) i->features |= CPU_FEATURE_MOVBE;
  if (out.ecx & 0x00800000U) i->features |= CPU_FEATURE_POPCNT;
  if (out.ecx & 0x10000000U) i->features |= CPU_FEATURE_AVX;

  if (out.edx & 0x00000010U) i->features |= CPU_FEATURE_RDTSC;
  if (out.edx & 0x00000100U) i->features |= CPU_FEATURE_CMPXCHG8B;
  if (out.edx & 0x00008000U) i->features |= CPU_FEATURE_CMOV;
  if (out.edx & 0x00800000U) i->features |= CPU_FEATURE_MMX;
  if (out.edx & 0x01000000U) i->features |= CPU_FEATURE_FXSR;
  if (out.edx & 0x02000000U) i->features |= CPU_FEATURE_SSE | CPU_FEATURE_MMX_EXT;
  if (out.edx & 0x04000000U) i->features |= CPU_FEATURE_SSE | CPU_FEATURE_SSE2;
  if (out.edx & 0x10000000U) i->features |= CPU_FEATURE_MULTI_THREADING;

  if (i->vendorId == CPU_VENDOR_AMD && (out.edx & 0x10000000U))
  {
    // AMD sets Multithreading to ON if it has more cores.
    if (i->numberOfProcessors == 1) i->numberOfProcessors = 2;
  }

  // This comment comes from V8 and I think that its important:
  //
  // Opteron Rev E has a bug in which on very rare occasions a locked
  // instruction doesn't act as a read-acquire barrier if followed by a
  // non-locked read-modify-write instruction.  Rev F has this bug in 
  // pre-release versions, but not in versions released to customers,
  // so we test only for Rev E, which is family 15, model 32..63 inclusive.

  if (i->vendorId == CPU_VENDOR_AMD && i->family == 15 && i->model >= 32 && i->model <= 63) 
  {
    i->bugs |= CPU_BUG_AMD_LOCK_MB;
  }

  // Calling cpuid with 0x80000000 as the in argument
  // gets the number of valid extended IDs.

  cpuid(0x80000000, &out);

  uint32_t exIds = out.eax;
  if (exIds > 0x80000004) exIds = 0x80000004;

  uint32_t* brand = reinterpret_cast<uint32_t*>(i->brand);

  for (a = 0x80000001; a <= exIds; a++)
  {
    cpuid(a, &out);

    switch (a)
    {
      case 0x80000001:
        if (out.ecx & 0x00000001U) i->features |= CPU_FEATURE_LAHF_SAHF;
        if (out.ecx & 0x00000020U) i->features |= CPU_FEATURE_LZCNT;
        if (out.ecx & 0x00000040U) i->features |= CPU_FEATURE_SSE4_A;
        if (out.ecx & 0x00000080U) i->features |= CPU_FEATURE_MSSE;
        if (out.ecx & 0x00000100U) i->features |= CPU_FEATURE_PREFETCH;

        if (out.edx & 0x00100000U) i->features |= CPU_FEATURE_EXECUTE_DISABLE_BIT;
        if (out.edx & 0x00200000U) i->features |= CPU_FEATURE_FFXSR;
        if (out.edx & 0x00400000U) i->features |= CPU_FEATURE_MMX_EXT;
        if (out.edx & 0x08000000U) i->features |= CPU_FEATURE_RDTSCP;
        if (out.edx & 0x20000000U) i->features |= CPU_FEATURE_64_BIT;
        if (out.edx & 0x40000000U) i->features |= CPU_FEATURE_3DNOW_EXT | CPU_FEATURE_MMX_EXT;
        if (out.edx & 0x80000000U) i->features |= CPU_FEATURE_3DNOW;
        break;

      case 0x80000002:
      case 0x80000003:
      case 0x80000004:
        *brand++ = out.eax;
        *brand++ = out.ebx;
        *brand++ = out.ecx;
        *brand++ = out.edx;
        break;

      default:
        // Additional features can be detected in the future.
        break;
    }
  }

  // Simplify the brand string (remove unnecessary spaces to make it printable).
  simplifyBrandString(i->brand);

#endif // ASMJIT_X86 || ASMJIT_X64
}
#else
void detectCpuInfo(CpuInfo* i) ASMJIT_NOTHROW
{
  memset(i, 0, sizeof(CpuInfo));
}
#endif

struct ASMJIT_HIDDEN CpuInfoStatic
{
  CpuInfoStatic() ASMJIT_NOTHROW { detectCpuInfo(&i); }

  CpuInfo i;
};

CpuInfo* getCpuInfo() ASMJIT_NOTHROW
{
  static CpuInfoStatic i;
  return &i.i;
}

} // AsmJit

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/CpuInfo.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_CPUINFO_H
#define _ASMJIT_CPUINFO_H

// [Dependencies]
#include "Build.h"

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

//! @addtogroup AsmJit_CpuInfo
//! @{

// ============================================================================
// [AsmJit::CpuId]
// ============================================================================

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
//! @brief Structure (union) used by cpuid() function.
union CpuId
{
  //! @brief cpuid results array(eax, ebx, ecx and edx registers).
  uint32_t i[4];

  struct
  {
    //! @brief cpuid result in eax register.
    uint32_t eax;
    //! @brief cpuid result in ebx register.
    uint32_t ebx;
    //! @brief cpuid result in ecx register.
    uint32_t ecx;
    //! @brief cpuid result in edx register.
    uint32_t edx;
  };
};

//! @brief Calls CPUID instruction with eax == @a in and returns result to @a out.
//!
//! @c cpuid() function has one input parameter that is passed to cpuid through 
//! eax register and results in four output values representing result of cpuid 
//! instruction (eax, ebx, ecx and edx registers).
ASMJIT_API void cpuid(uint32_t in, CpuId* out) ASMJIT_NOTHROW;
#endif // ASMJIT_X86 || ASMJIT_X64

// ============================================================================
// [AsmJit::CPU_VENDOR]
// ============================================================================

//! @brief Cpu vendor IDs.
//!
//! Cpu vendor IDs are specific for AsmJit library. Vendor ID is not directly
//! read from cpuid result, instead it's based on CPU vendor string.
enum CPU_VENDOR
{
  //! @brief Unknown CPU vendor.
  CPU_VENDOR_UNKNOWN = 0,

  //! @brief Intel CPU vendor.
  CPU_VENDOR_INTEL = 1,
  //! @brief AMD CPU vendor.
  CPU_VENDOR_AMD = 2,
  //! @brief National Semiconductor CPU vendor (applies also to Cyrix processors).
  CPU_VENDOR_NSM = 3,
  //! @brief Transmeta CPU vendor.
  CPU_VENDOR_TRANSMETA = 4,
  //! @brief VIA CPU vendor.
  CPU_VENDOR_VIA = 5
};

// ============================================================================
// [AsmJit::CPU_FEATURE]
// ============================================================================

//! @brief X86/X64 CPU features.
enum CPU_FEATURE
{
  //! @brief Cpu has RDTSC instruction.
  CPU_FEATURE_RDTSC = 1U << 0,
  //! @brief Cpu has RDTSCP instruction.
  CPU_FEATURE_RDTSCP = 1U << 1,
  //! @brief Cpu has CMOV instruction (conditional move)
  CPU_FEATURE_CMOV = 1U << 2,
  //! @brief Cpu has CMPXCHG8B instruction
  CPU_FEATURE_CMPXCHG8B = 1U << 3,
  //! @brief Cpu has CMPXCHG16B instruction (64-bit processors)
  CPU_FEATURE_CMPXCHG16B = 1U << 4,
  //! @brief Cpu has CLFUSH instruction
  CPU_FEATURE_CLFLUSH = 1U << 5,
  //! @brief Cpu has PREFETCH instruction
  CPU_FEATURE_PREFETCH = 1U << 6,
  //! @brief Cpu supports LAHF and SAHF instrictions.
  CPU_FEATURE_LAHF_SAHF = 1U << 7,
  //! @brief Cpu supports FXSAVE and FXRSTOR instructions.
  CPU_FEATURE_FXSR = 1U << 8,
  //! @brief Cpu supports FXSAVE and FXRSTOR instruction optimizations (FFXSR).
  CPU_FEATURE_FFXSR = 1U << 9,
  //! @brief Cpu has MMX.
  CPU_FEATURE_MMX = 1U << 10,
  //! @brief Cpu has extended MMX.
  CPU_FEATURE_MMX_EXT = 1U << 11,
  //! @brief Cpu has 3dNow!
  CPU_FEATURE_3DNOW = 1U << 12,
  //! @brief Cpu has enchanced 3dNow!
  CPU_FEATURE_3DNOW_EXT = 1U << 13,
  //! @brief Cpu has SSE.
  CPU_FEATURE_SSE = 1U << 14,
  //! @brief Cpu has SSE2.
  CPU_FEATURE_SSE2 = 1U << 15,
  //! @brief Cpu has SSE3.
  CPU_FEATURE_SSE3 = 1U << 16,
  //! @brief Cpu has Supplemental SSE3 (SSSE3).
  CPU_FEATURE_SSSE3 = 1U << 17,
  //! @brief Cpu has SSE4.A.
  CPU_FEATURE_SSE4_A = 1U << 18,
  //! @brief Cpu has SSE4.1.
  CPU_FEATURE_SSE4_1 = 1U << 19,
  //! @brief Cpu has SSE4.2.
  CPU_FEATURE_SSE4_2 = 1U << 20,
  //! @brief Cpu has AVX.
  CPU_FEATURE_AVX = 1U << 22,
  //! @brief Cpu has Misaligned SSE (MSSE).
  CPU_FEATURE_MSSE = 1U << 23,
  //! @brief Cpu supports MONITOR and MWAIT instructions.
  CPU_FEATURE_MONITOR_MWAIT = 1U << 24,
  //! @brief Cpu supports MOVBE instruction.
  CPU_FEATURE_MOVBE = 1U << 25,
  //! @brief Cpu supports POPCNT instruction.
  CPU_FEATURE_POPCNT = 1U << 26,
  //! @brief Cpu supports LZCNT instruction.
  CPU_FEATURE_LZCNT = 1U << 27,
  //! @brief Cpu supports PCLMULDQ set of instructions.
  CPU_FEATURE_PCLMULDQ  = 1U << 28,
  //! @brief Cpu supports multithreading.
  CPU_FEATURE_MULTI_THREADING = 1U << 29,
  //! @brief Cpu supports execute disable bit (execute protection).
  CPU_FEATURE_EXECUTE_DISABLE_BIT = 1U << 30,
  //! @brief 64-bit CPU.
  CPU_FEATURE_64_BIT = 1U << 31
};

// ============================================================================
// [AsmJit::CPU_BUG]
// ============================================================================

//! @brief X86/X64 CPU bugs.
enum CPU_BUG
{
  //! @brief Whether the processor contains bug seen in some 
  //! AMD-Opteron processors.
  CPU_BUG_AMD_LOCK_MB = 1U << 0
};

// ============================================================================
// [AsmJit::CpuInfo]
// ============================================================================

//! @brief Informations about host cpu.
struct ASMJIT_HIDDEN CpuInfo
{
  //! @brief Cpu short vendor string.
  char vendor[16];
  //! @brief Cpu long vendor string (brand).
  char brand[64];
  //! @brief Cpu vendor id (see @c AsmJit::CpuInfo::VendorId enum).
  uint32_t vendorId;
  //! @brief Cpu family ID.
  uint32_t family;
  //! @brief Cpu model ID.
  uint32_t model;
  //! @brief Cpu stepping.
  uint32_t stepping;
  //! @brief Number of processors or cores.
  uint32_t numberOfProcessors;
  //! @brief Cpu features bitfield, see @c AsmJit::CpuInfo::Feature enum).
  uint32_t features;
  //! @brief Cpu bugs bitfield, see @c AsmJit::CpuInfo::Bug enum).
  uint32_t bugs;

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
  //! @brief Extended information for x86/x64 compatible processors.
  struct X86ExtendedInfo
  {
    //! @brief Processor type.
    uint32_t processorType;
    //! @brief Brand index.
    uint32_t brandIndex;
    //! @brief Flush cache line size in bytes.
    uint32_t flushCacheLineSize;
    //! @brief Maximum number of addressable IDs for logical processors.
    uint32_t maxLogicalProcessors;
    //! @brief Initial APIC ID.
    uint32_t apicPhysicalId;
  };
  //! @brief Extended information for x86/x64 compatible processors.
  X86ExtendedInfo x86ExtendedInfo;
#endif // ASMJIT_X86 || ASMJIT_X64
};

//! @brief Detect CPU features to CpuInfo structure @a i.
//!
//! @sa @c CpuInfo.
ASMJIT_API void detectCpuInfo(CpuInfo* i) ASMJIT_NOTHROW;

//! @brief Return CpuInfo (detection is done only once).
//!
//! @sa @c CpuInfo.
ASMJIT_API CpuInfo* getCpuInfo() ASMJIT_NOTHROW;

//! @}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

// [Guard]
#endif // _ASMJIT_CPUINFO_H

```

`AsmJit/Defs.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "Defs.h"

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

const char* getErrorString(uint32_t error) ASMJIT_NOTHROW
{
  static const char* errorMessage[] = {
    "No error",

    "No heap memory",
    "No virtual memory",

    "Unknown instruction",
    "Illegal instruction",
    "Illegal addressing",
    "Illegal short jump",

    "No function defined",
    "Incomplete function",

    "Not enough registers",
    "Registers overlap",

    "Incompatible argument",
    "Incompatible return value",

    "Unknown error"
  };

  // Saturate error code to be able to use errorMessage[].
  if (error > _ERROR_COUNT) error = _ERROR_COUNT;

  return errorMessage[error];
}

} // AsmJit

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/Defs.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_DEFS_H
#define _ASMJIT_DEFS_H

// [Dependencies]
#include "Build.h"

namespace AsmJit {

//! @addtogroup AsmJit_Core
//! @{

// ============================================================================
// [AsmJit::ENUM]
// ============================================================================

//! @brief Uncategorized constants.
enum
{
  //! @brief Invalid operand identifier.
  INVALID_VALUE = 0xFFFFFFFF,

  //! @brief Maximum allowed arguments per function declaration / call.
  FUNC_MAX_ARGS = 32
};

// ============================================================================
// [AsmJit::MEMORY_ALLOC_TYPE]
// ============================================================================

//! @brief Types of allocation used by @c AsmJit::MemoryManager::alloc() method.
enum MEMORY_ALLOC_TYPE
{
  //! @brief Allocate memory that can be freed by @c AsmJit::MemoryManager::free()
  //! method.
  MEMORY_ALLOC_FREEABLE = 0,
  //! @brief Allocate permanent memory that will be never freed.
  MEMORY_ALLOC_PERMANENT = 1
};

// ============================================================================
// [AsmJit::ERROR_CODE]
// ============================================================================

//! @brief AsmJit error codes.
enum ERROR_CODE
{
  //! @brief No error (success).
  //!
  //! This is default state and state you want.
  ERROR_NONE = 0,

  //! @brief Memory allocation error (@c ASMJIT_MALLOC returned @c NULL).
  ERROR_NO_HEAP_MEMORY = 1,
  //! @brief Virtual memory allocation error (@c VirtualMemory returned @c NULL).
  ERROR_NO_VIRTUAL_MEMORY = 2,

  //! @brief Unknown instruction. This happens only if instruction code is
  //! out of bounds. Shouldn't happen.
  ERROR_UNKNOWN_INSTRUCTION = 3,
  //! @brief Illegal instruction, usually generated by AsmJit::AssemblerCore
  //! class when emitting instruction opcode. If this error is generated the
  //! target buffer is not affected by this invalid instruction.
  //!
  //! You can also get this error code if you are under x64 (64-bit x86) and
  //! you tried to decode instruction using AH, BH, CH or DH register with REX
  //! prefix. These registers can't be accessed if REX prefix is used and AsmJit
  //! didn't check for this situation in intrinsics (@c Compiler takes care of
  //! this and rearrange registers if needed).
  //!
  //! Examples that will raise @c ERROR_ILLEGAL_INSTRUCTION error (a is
  //! @c Assembler instance):
  //!
  //! @code
  //! a.mov(dword_ptr(eax), al); // Invalid address size.
  //! a.mov(byte_ptr(r10), ah);  // Undecodable instruction (AH used with r10
  //!                            // which can be encoded only using REX prefix)
  //! @endcode
  //!
  //! @note In debug mode you get assertion failure instead of setting error
  //! code.
  ERROR_ILLEGAL_INSTRUCTION = 4,
  //! @brief Illegal addressing used (unencodable).
  ERROR_ILLEGAL_ADDRESING = 5,
  //! @brief Short jump instruction used, but displacement is out of bounds.
  ERROR_ILLEGAL_SHORT_JUMP = 6,

  //! @brief No function defined.
  ERROR_NO_FUNCTION = 7,
  //! @brief Function generation is not finished by using @c Compiler::endFunction()
  //! or something bad happened during generation related to function. This can
  //! be missing emittable, etc...
  ERROR_INCOMPLETE_FUNCTION = 8,

  //! @brief Compiler can't allocate registers, because all of them are used.
  //!
  //! @note AsmJit is able to spill registers so this error really shouldn't
  //! happen unless all registers have priority 0 (which means never spill).
  ERROR_NOT_ENOUGH_REGISTERS = 9,
  //! @brief Compiler can't allocate one register to multiple destinations.
  //!
  //! This error can only happen using special instructions like cmpxchg8b and
  //! others where there are more destination operands (implicit).
  ERROR_REGISTERS_OVERLAP = 10,

  //! @brief Tried to call function using incompatible argument.
  ERROR_INCOMPATIBLE_ARGUMENT = 11,
  //! @brief Incompatible return value.
  ERROR_INCOMPATIBLE_RETURN_VALUE = 12,

  //! @brief Count of error codes by AsmJit. Can grow in future.
  _ERROR_COUNT
};

// ============================================================================
// [AsmJit::OPERAND_TYPE]
// ============================================================================

//! @brief Operand types that can be encoded in @c Op operand.
enum OPERAND_TYPE
{
  //! @brief Operand is none, used only internally (not initialized Operand).
  //!
  //! This operand is not valid.
  OPERAND_NONE = 0x00,

  //! @brief Operand is register.
  OPERAND_REG = 0x01,
  //! @brief Operand is memory.
  OPERAND_MEM = 0x02,
  //! @brief Operand is immediate.
  OPERAND_IMM = 0x04,
  //! @brief Operand is label.
  OPERAND_LABEL = 0x08,
  //! @brief Operand is variable.
  OPERAND_VAR = 0x10
};

// ============================================================================
// [AsmJit::OPERAND_MEM_TYPE]
// ============================================================================

//! @brief Type of memory operand.
enum OPERAND_MEM_TYPE
{
  //! @brief Operand is combination of register(s) and displacement (native).
  OPERAND_MEM_NATIVE = 0,
  //! @brief Operand is label.
  OPERAND_MEM_LABEL = 1,
  //! @brief Operand is absolute memory location (supported mainly in 32-bit 
  //! mode)
  OPERAND_MEM_ABSOLUTE = 2,
};

// ============================================================================
// [AsmJit::OPERAND_ID]
// ============================================================================

//! @brief Operand ID masks used to determine the operand type.
enum OPERAND_ID
{
  //! @brief Operand id value mask (part used for IDs).
  OPERAND_ID_VALUE_MASK = 0x3FFFFFFF,
  //! @brief Operand id type mask (part used for operand type).
  OPERAND_ID_TYPE_MASK  = 0xC0000000,
  //! @brief Label operand mark id.
  OPERAND_ID_TYPE_LABEL = 0x40000000,
  //! @brief Variable operand mark id.
  OPERAND_ID_TYPE_VAR   = 0x80000000
};

// ============================================================================
// [AsmJit::PROPERTY]
// ============================================================================

//! @brief @c Assembler/Compiler properties.
enum PROPERTY
{
  //! @brief Optimize align for current processor.
  //!
  //! Default: @c true.
  PROPERTY_OPTIMIZE_ALIGN = 0,

  //! @brief Emit hints added to jcc() instructions.
  //!
  //! Default: @c true.
  //!
  //! @note This is X86/X64 property only.
  PROPERTY_JUMP_HINTS = 1
};

// ============================================================================
// [AsmJit::SIZE]
// ============================================================================

//! @brief Size of registers and pointers.
enum SIZE
{
  //! @brief 1 byte size.
  SIZE_BYTE   = 1,
  //! @brief 2 bytes size.
  SIZE_WORD   = 2,
  //! @brief 4 bytes size.
  SIZE_DWORD  = 4,
  //! @brief 8 bytes size.
  SIZE_QWORD  = 8,
  //! @brief 10 bytes size.
  SIZE_TWORD  = 10,
  //! @brief 16 bytes size.
  SIZE_DQWORD = 16
};

// ============================================================================
// [EMITTABLE_TYPE]
// ============================================================================

//! @brief Emmitable type.
//!
//! For each emittable that is used by @c Compiler must be defined it's type.
//! Compiler can optimize instruction stream by analyzing emittables and each
//! type is hint for it. The most used emittables are instructions
//! (@c EMITTABLE_INSTRUCTION).
enum EMITTABLE_TYPE
{
  //! @brief Emittable is invalid (can't be used).
  EMITTABLE_NONE = 0,
  //! @brief Emittable is dummy (used as a mark) (@ref EDummy).
  EMITTABLE_DUMMY,
  //! @brief Emittable is comment (no code) (@ref EComment).
  EMITTABLE_COMMENT,
  //! @brief Emittable is embedded data (@ref EData).
  EMITTABLE_EMBEDDED_DATA,
  //! @brief Emittable is .align directive (@ref EAlign).
  EMITTABLE_ALIGN,
  //! @brief Emittable is variable hint (alloc, spill, use, unuse, ...) (@ref EVariableHint).
  EMITTABLE_VARIABLE_HINT,
  //! @brief Emittable is single instruction (@ref EInstruction).
  EMITTABLE_INSTRUCTION,
  //! @brief Emittable is block of instructions.
  EMITTABLE_BLOCK,
  //! @brief Emittable is function declaration (@ref EFunction).
  EMITTABLE_FUNCTION,
  //! @brief Emittable is function prolog (@ref EProlog).
  EMITTABLE_PROLOG,
  //! @brief Emittable is function epilog (@ref EEpilog).
  EMITTABLE_EPILOG,
  //! @brief Emittable is end of function (@ref EFunctionEnd).
  EMITTABLE_FUNCTION_END,
  //! @brief Emittable is target (bound label).
  EMITTABLE_TARGET,
  //! @brief Emittable is jump table (@ref EJmp).
  EMITTABLE_JUMP_TABLE,
  //! @brief Emittable is function call (@ref ECall).
  EMITTABLE_CALL,
  //! @brief Emittable is return (@ref ERet).
  EMITTABLE_RET
};

// ============================================================================
// [AsmJit::VARIABLE_STATE]
// ============================================================================

//! @brief State of variable.
//!
//! @note State of variable is used only during make process and it's not
//! visible to the developer.
enum VARIABLE_STATE
{
  //! @brief Variable is currently not used.
  VARIABLE_STATE_UNUSED = 0,

  //! @brief Variable is in register.
  //!
  //! Variable is currently allocated in register.
  VARIABLE_STATE_REGISTER = 1,

  //! @brief Variable is in memory location or spilled.
  //!
  //! Variable was spilled from register to memory or variable is used for
  //! memory only storage.
  VARIABLE_STATE_MEMORY = 2
};

// ============================================================================
// [AsmJit::VARIABLE_ALLOC_FLAGS]
// ============================================================================

//! @brief Variable alloc mode.
enum VARIABLE_ALLOC
{
  //! @brief Allocating variable to read only.
  //!
  //! Read only variables are used to optimize variable spilling. If variable
  //! is some time ago deallocated and it's not marked as changed (so it was
  //! all the life time read only) then spill is simply NOP (no mov instruction
  //! is generated to move it to it's home memory location).
  VARIABLE_ALLOC_READ = 0x01,

  //! @brief Allocating variable to write only (overwrite).
  //!
  //! Overwriting means that if variable is in memory, there is no generated
  //! instruction to move variable from memory to register, because that
  //! register will be overwritten by next instruction. This is used as a
  //! simple optimization to improve generated code by @c Compiler.
  VARIABLE_ALLOC_WRITE = 0x02,

  //! @brief Allocating variable to read / write.
  //!
  //! Variable allocated for read / write is marked as changed. This means that
  //! if variable must be later spilled into memory, mov (or similar)
  //! instruction will be generated.
  VARIABLE_ALLOC_READWRITE = 0x03,

  //! @brief Variable can be allocated in register.
  VARIABLE_ALLOC_REGISTER = 0x04,

  //! @brief Variable can be allocated in memory.
  VARIABLE_ALLOC_MEMORY = 0x08,

  //! @brief Unuse the variable after use.
  VARIABLE_ALLOC_UNUSE_AFTER_USE = 0x10,

  //! @brief Variable can be allocated only to one register (special allocation).
  VARIABLE_ALLOC_SPECIAL = 0x20
};

// ============================================================================
// [AsmJit::VARIABLE_ALLOC_POLICY]
// ============================================================================

//! @brief Variable allocation method.
//!
//! Variable allocation method is used by compiler and it means if compiler
//! should first allocate preserved registers or not. Preserved registers are
//! registers that must be saved / restored by generated function.
//!
//! This option is for people who are calling C/C++ functions from JIT code so
//! Compiler can recude generating push/pop sequences before and after call,
//! respectively.
enum VARIABLE_ALLOC_POLICY
{
  //! @brief Allocate preserved registers first.
  VARIABLE_ALLOC_PRESERVED_FIRST = 0,
  //! @brief Allocate preserved registers last (default).
  VARIABLE_ALLOC_PRESERVED_LAST = 1
};

// ============================================================================
// [AsmJit::FUNCTION_HINT]
// ============================================================================

//! @brief Function hints.
enum FUNCTION_HINT
{
  //! @brief Use push/pop sequences instead of mov sequences in function prolog
  //! and epilog.
  FUNCTION_HINT_PUSH_POP_SEQUENCE = 0,
  //! @brief Make naked function (without using ebp/erp in prolog / epilog).
  FUNCTION_HINT_NAKED = 1,
  //! @brief Add emms instruction to the function epilog.
  FUNCTION_HINT_EMMS = 2,
  //! @brief Add sfence instruction to the function epilog.
  FUNCTION_HINT_SFENCE = 3,
  //! @brief Add lfence instruction to the function epilog.
  FUNCTION_HINT_LFENCE = 4
};

// ============================================================================
// [AsmJit::ARGUMENT_DIR]
// ============================================================================

//! @brief Arguments direction used by @c Function.
enum ARGUMENT_DIR
{
  //! @brief Arguments are passed left to right.
  //!
  //! This arguments direction is unusual to C programming, it's used by pascal
  //! compilers and in some calling conventions by Borland compiler).
  ARGUMENT_DIR_LEFT_TO_RIGHT = 0,
  //! @brief Arguments are passer right ro left
  //!
  //! This is default argument direction in C programming.
  ARGUMENT_DIR_RIGHT_TO_LEFT = 1
};

// ============================================================================
// [AsmJit::API]
// ============================================================================

//! @brief Translates error code (see @c ERROR_CODE) into text representation.
ASMJIT_API const char* getErrorString(uint32_t error) ASMJIT_NOTHROW;

//! @}

} // AsmJit namespace

// ============================================================================
// [Platform Specific]
//
// Following enums must be declared by platform specific header:
// - CALL_CONV - Calling convention.
// - VARIABLE_TYPE - Variable type.
// ============================================================================

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
#include "DefsX86X64.h"
#endif // ASMJIT_X86 || ASMJIT_X64

// [Guard]
#endif // _ASMJIT_DEFS_H

```

`AsmJit/DefsX86X64.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "Defs.h"

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::ConditionToInstruction]
// ============================================================================

const uint32_t ConditionToInstruction::_jcctable[16] =
{
  INST_JO,
  INST_JNO,
  INST_JB,
  INST_JAE,
  INST_JE,
  INST_JNE,
  INST_JBE,
  INST_JA,
  INST_JS,
  INST_JNS,
  INST_JPE,
  INST_JPO,
  INST_JL,
  INST_JGE,
  INST_JLE,
  INST_JG
};

const uint32_t ConditionToInstruction::_cmovcctable[16] =
{
  INST_CMOVO,
  INST_CMOVNO,
  INST_CMOVB,
  INST_CMOVAE,
  INST_CMOVE,
  INST_CMOVNE,
  INST_CMOVBE,
  INST_CMOVA,
  INST_CMOVS,
  INST_CMOVNS,
  INST_CMOVPE,
  INST_CMOVPO,
  INST_CMOVL,
  INST_CMOVGE,
  INST_CMOVLE,
  INST_CMOVG
};

const uint32_t ConditionToInstruction::_setcctable[16] =
{
  INST_SETO,
  INST_SETNO,
  INST_SETB,
  INST_SETAE,
  INST_SETE,
  INST_SETNE,
  INST_SETBE,
  INST_SETA,
  INST_SETS,
  INST_SETNS,
  INST_SETPE,
  INST_SETPO,
  INST_SETL,
  INST_SETGE,
  INST_SETLE,
  INST_SETG
};

// ============================================================================
// [AsmJit::Instruction Name]
// ============================================================================

// Following {DATA SECTION} is auto-generated using InstructionDescription data.
//
// ${INSTRUCTION_DATA_BEGIN}
const char instructionName[] =
  "adc\0"
  "add\0"
  "addpd\0"
  "addps\0"
  "addsd\0"
  "addss\0"
  "addsubpd\0"
  "addsubps\0"
  "amd_prefetch\0"
  "amd_prefetchw\0"
  "and\0"
  "andnpd\0"
  "andnps\0"
  "andpd\0"
  "andps\0"
  "blendpd\0"
  "blendps\0"
  "blendvpd\0"
  "blendvps\0"
  "bsf\0"
  "bsr\0"
  "bswap\0"
  "bt\0"
  "btc\0"
  "btr\0"
  "bts\0"
  "call\0"
  "cbw\0"
  "cdqe\0"
  "clc\0"
  "cld\0"
  "clflush\0"
  "cmc\0"
  "cmova\0"
  "cmovae\0"
  "cmovb\0"
  "cmovbe\0"
  "cmovc\0"
  "cmove\0"
  "cmovg\0"
  "cmovge\0"
  "cmovl\0"
  "cmovle\0"
  "cmovna\0"
  "cmovnae\0"
  "cmovnb\0"
  "cmovnbe\0"
  "cmovnc\0"
  "cmovne\0"
  "cmovng\0"
  "cmovnge\0"
  "cmovnl\0"
  "cmovnle\0"
  "cmovno\0"
  "cmovnp\0"
  "cmovns\0"
  "cmovnz\0"
  "cmovo\0"
  "cmovp\0"
  "cmovpe\0"
  "cmovpo\0"
  "cmovs\0"
  "cmovz\0"
  "cmp\0"
  "cmppd\0"
  "cmpps\0"
  "cmpsd\0"
  "cmpss\0"
  "cmpxchg\0"
  "cmpxchg16b\0"
  "cmpxchg8b\0"
  "comisd\0"
  "comiss\0"
  "cpuid\0"
  "crc32\0"
  "cvtdq2pd\0"
  "cvtdq2ps\0"
  "cvtpd2dq\0"
  "cvtpd2pi\0"
  "cvtpd2ps\0"
  "cvtpi2pd\0"
  "cvtpi2ps\0"
  "cvtps2dq\0"
  "cvtps2pd\0"
  "cvtps2pi\0"
  "cvtsd2si\0"
  "cvtsd2ss\0"
  "cvtsi2sd\0"
  "cvtsi2ss\0"
  "cvtss2sd\0"
  "cvtss2si\0"
  "cvttpd2dq\0"
  "cvttpd2pi\0"
  "cvttps2dq\0"
  "cvttps2pi\0"
  "cvttsd2si\0"
  "cvttss2si\0"
  "cwde\0"
  "daa\0"
  "das\0"
  "dec\0"
  "div\0"
  "divpd\0"
  "divps\0"
  "divsd\0"
  "divss\0"
  "dppd\0"
  "dpps\0"
  "emms\0"
  "enter\0"
  "extractps\0"
  "f2xm1\0"
  "fabs\0"
  "fadd\0"
  "faddp\0"
  "fbld\0"
  "fbstp\0"
  "fchs\0"
  "fclex\0"
  "fcmovb\0"
  "fcmovbe\0"
  "fcmove\0"
  "fcmovnb\0"
  "fcmovnbe\0"
  "fcmovne\0"
  "fcmovnu\0"
  "fcmovu\0"
  "fcom\0"
  "fcomi\0"
  "fcomip\0"
  "fcomp\0"
  "fcompp\0"
  "fcos\0"
  "fdecstp\0"
  "fdiv\0"
  "fdivp\0"
  "fdivr\0"
  "fdivrp\0"
  "femms\0"
  "ffree\0"
  "fiadd\0"
  "ficom\0"
  "ficomp\0"
  "fidiv\0"
  "fidivr\0"
  "fild\0"
  "fimul\0"
  "fincstp\0"
  "finit\0"
  "fist\0"
  "fistp\0"
  "fisttp\0"
  "fisub\0"
  "fisubr\0"
  "fld\0"
  "fld1\0"
  "fldcw\0"
  "fldenv\0"
  "fldl2e\0"
  "fldl2t\0"
  "fldlg2\0"
  "fldln2\0"
  "fldpi\0"
  "fldz\0"
  "fmul\0"
  "fmulp\0"
  "fnclex\0"
  "fninit\0"
  "fnop\0"
  "fnsave\0"
  "fnstcw\0"
  "fnstenv\0"
  "fnstsw\0"
  "fpatan\0"
  "fprem\0"
  "fprem1\0"
  "fptan\0"
  "frndint\0"
  "frstor\0"
  "fsave\0"
  "fscale\0"
  "fsin\0"
  "fsincos\0"
  "fsqrt\0"
  "fst\0"
  "fstcw\0"
  "fstenv\0"
  "fstp\0"
  "fstsw\0"
  "fsub\0"
  "fsubp\0"
  "fsubr\0"
  "fsubrp\0"
  "ftst\0"
  "fucom\0"
  "fucomi\0"
  "fucomip\0"
  "fucomp\0"
  "fucompp\0"
  "fwait\0"
  "fxam\0"
  "fxch\0"
  "fxrstor\0"
  "fxsave\0"
  "fxtract\0"
  "fyl2x\0"
  "fyl2xp1\0"
  "haddpd\0"
  "haddps\0"
  "hsubpd\0"
  "hsubps\0"
  "idiv\0"
  "imul\0"
  "inc\0"
  "int3\0"
  "ja\0"
  "jae\0"
  "jb\0"
  "jbe\0"
  "jc\0"
  "je\0"
  "jg\0"
  "jge\0"
  "jl\0"
  "jle\0"
  "jna\0"
  "jnae\0"
  "jnb\0"
  "jnbe\0"
  "jnc\0"
  "jne\0"
  "jng\0"
  "jnge\0"
  "jnl\0"
  "jnle\0"
  "jno\0"
  "jnp\0"
  "jns\0"
  "jnz\0"
  "jo\0"
  "jp\0"
  "jpe\0"
  "jpo\0"
  "js\0"
  "jz\0"
  "jmp\0"
  "lddqu\0"
  "ldmxcsr\0"
  "lahf\0"
  "lea\0"
  "leave\0"
  "lfence\0"
  "maskmovdqu\0"
  "maskmovq\0"
  "maxpd\0"
  "maxps\0"
  "maxsd\0"
  "maxss\0"
  "mfence\0"
  "minpd\0"
  "minps\0"
  "minsd\0"
  "minss\0"
  "monitor\0"
  "mov\0"
  "movapd\0"
  "movaps\0"
  "movbe\0"
  "movd\0"
  "movddup\0"
  "movdq2q\0"
  "movdqa\0"
  "movdqu\0"
  "movhlps\0"
  "movhpd\0"
  "movhps\0"
  "movlhps\0"
  "movlpd\0"
  "movlps\0"
  "movmskpd\0"
  "movmskps\0"
  "movntdq\0"
  "movntdqa\0"
  "movnti\0"
  "movntpd\0"
  "movntps\0"
  "movntq\0"
  "movq\0"
  "movq2dq\0"
  "movsd\0"
  "movshdup\0"
  "movsldup\0"
  "movss\0"
  "movsx\0"
  "movsxd\0"
  "movupd\0"
  "movups\0"
  "movzx\0"
  "mov_ptr\0"
  "mpsadbw\0"
  "mul\0"
  "mulpd\0"
  "mulps\0"
  "mulsd\0"
  "mulss\0"
  "mwait\0"
  "neg\0"
  "nop\0"
  "not\0"
  "or\0"
  "orpd\0"
  "orps\0"
  "pabsb\0"
  "pabsd\0"
  "pabsw\0"
  "packssdw\0"
  "packsswb\0"
  "packusdw\0"
  "packuswb\0"
  "paddb\0"
  "paddd\0"
  "paddq\0"
  "paddsb\0"
  "paddsw\0"
  "paddusb\0"
  "paddusw\0"
  "paddw\0"
  "palignr\0"
  "pand\0"
  "pandn\0"
  "pause\0"
  "pavgb\0"
  "pavgw\0"
  "pblendvb\0"
  "pblendw\0"
  "pcmpeqb\0"
  "pcmpeqd\0"
  "pcmpeqq\0"
  "pcmpeqw\0"
  "pcmpestri\0"
  "pcmpestrm\0"
  "pcmpgtb\0"
  "pcmpgtd\0"
  "pcmpgtq\0"
  "pcmpgtw\0"
  "pcmpistri\0"
  "pcmpistrm\0"
  "pextrb\0"
  "pextrd\0"
  "pextrq\0"
  "pextrw\0"
  "pf2id\0"
  "pf2iw\0"
  "pfacc\0"
  "pfadd\0"
  "pfcmpeq\0"
  "pfcmpge\0"
  "pfcmpgt\0"
  "pfmax\0"
  "pfmin\0"
  "pfmul\0"
  "pfnacc\0"
  "pfpnacc\0"
  "pfrcp\0"
  "pfrcpit1\0"
  "pfrcpit2\0"
  "pfrsqit1\0"
  "pfrsqrt\0"
  "pfsub\0"
  "pfsubr\0"
  "phaddd\0"
  "phaddsw\0"
  "phaddw\0"
  "phminposuw\0"
  "phsubd\0"
  "phsubsw\0"
  "phsubw\0"
  "pi2fd\0"
  "pi2fw\0"
  "pinsrb\0"
  "pinsrd\0"
  "pinsrq\0"
  "pinsrw\0"
  "pmaddubsw\0"
  "pmaddwd\0"
  "pmaxsb\0"
  "pmaxsd\0"
  "pmaxsw\0"
  "pmaxub\0"
  "pmaxud\0"
  "pmaxuw\0"
  "pminsb\0"
  "pminsd\0"
  "pminsw\0"
  "pminub\0"
  "pminud\0"
  "pminuw\0"
  "pmovmskb\0"
  "pmovsxbd\0"
  "pmovsxbq\0"
  "pmovsxbw\0"
  "pmovsxdq\0"
  "pmovsxwd\0"
  "pmovsxwq\0"
  "pmovzxbd\0"
  "pmovzxbq\0"
  "pmovzxbw\0"
  "pmovzxdq\0"
  "pmovzxwd\0"
  "pmovzxwq\0"
  "pmuldq\0"
  "pmulhrsw\0"
  "pmulhuw\0"
  "pmulhw\0"
  "pmulld\0"
  "pmullw\0"
  "pmuludq\0"
  "pop\0"
  "popad\0"
  "popcnt\0"
  "popfd\0"
  "popfq\0"
  "por\0"
  "prefetch\0"
  "psadbw\0"
  "pshufb\0"
  "pshufd\0"
  "pshufw\0"
  "pshufhw\0"
  "pshuflw\0"
  "psignb\0"
  "psignd\0"
  "psignw\0"
  "pslld\0"
  "pslldq\0"
  "psllq\0"
  "psllw\0"
  "psrad\0"
  "psraw\0"
  "psrld\0"
  "psrldq\0"
  "psrlq\0"
  "psrlw\0"
  "psubb\0"
  "psubd\0"
  "psubq\0"
  "psubsb\0"
  "psubsw\0"
  "psubusb\0"
  "psubusw\0"
  "psubw\0"
  "pswapd\0"
  "ptest\0"
  "punpckhbw\0"
  "punpckhdq\0"
  "punpckhqdq\0"
  "punpckhwd\0"
  "punpcklbw\0"
  "punpckldq\0"
  "punpcklqdq\0"
  "punpcklwd\0"
  "push\0"
  "pushad\0"
  "pushfd\0"
  "pushfq\0"
  "pxor\0"
  "rcl\0"
  "rcpps\0"
  "rcpss\0"
  "rcr\0"
  "rdtsc\0"
  "rdtscp\0"
  "rep lodsb\0"
  "rep lodsd\0"
  "rep lodsq\0"
  "rep lodsw\0"
  "rep movsb\0"
  "rep movsd\0"
  "rep movsq\0"
  "rep movsw\0"
  "rep stosb\0"
  "rep stosd\0"
  "rep stosq\0"
  "rep stosw\0"
  "repe cmpsb\0"
  "repe cmpsd\0"
  "repe cmpsq\0"
  "repe cmpsw\0"
  "repe scasb\0"
  "repe scasd\0"
  "repe scasq\0"
  "repe scasw\0"
  "repne cmpsb\0"
  "repne cmpsd\0"
  "repne cmpsq\0"
  "repne cmpsw\0"
  "repne scasb\0"
  "repne scasd\0"
  "repne scasq\0"
  "repne scasw\0"
  "ret\0"
  "rol\0"
  "ror\0"
  "roundpd\0"
  "roundps\0"
  "roundsd\0"
  "roundss\0"
  "rsqrtps\0"
  "rsqrtss\0"
  "sahf\0"
  "sal\0"
  "sar\0"
  "sbb\0"
  "seta\0"
  "setae\0"
  "setb\0"
  "setbe\0"
  "setc\0"
  "sete\0"
  "setg\0"
  "setge\0"
  "setl\0"
  "setle\0"
  "setna\0"
  "setnae\0"
  "setnb\0"
  "setnbe\0"
  "setnc\0"
  "setne\0"
  "setng\0"
  "setnge\0"
  "setnl\0"
  "setnle\0"
  "setno\0"
  "setnp\0"
  "setns\0"
  "setnz\0"
  "seto\0"
  "setp\0"
  "setpe\0"
  "setpo\0"
  "sets\0"
  "setz\0"
  "sfence\0"
  "shl\0"
  "shld\0"
  "shr\0"
  "shrd\0"
  "shufpd\0"
  "shufps\0"
  "sqrtpd\0"
  "sqrtps\0"
  "sqrtsd\0"
  "sqrtss\0"
  "stc\0"
  "std\0"
  "stmxcsr\0"
  "sub\0"
  "subpd\0"
  "subps\0"
  "subsd\0"
  "subss\0"
  "test\0"
  "ucomisd\0"
  "ucomiss\0"
  "ud2\0"
  "unpckhpd\0"
  "unpckhps\0"
  "unpcklpd\0"
  "unpcklps\0"
  "xadd\0"
  "xchg\0"
  "xor\0"
  "xorpd\0"
  "xorps\0"
  ;

#define INST_ADC_INDEX 0
#define INST_ADD_INDEX 4
#define INST_ADDPD_INDEX 8
#define INST_ADDPS_INDEX 14
#define INST_ADDSD_INDEX 20
#define INST_ADDSS_INDEX 26
#define INST_ADDSUBPD_INDEX 32
#define INST_ADDSUBPS_INDEX 41
#define INST_AMD_PREFETCH_INDEX 50
#define INST_AMD_PREFETCHW_INDEX 63
#define INST_AND_INDEX 77
#define INST_ANDNPD_INDEX 81
#define INST_ANDNPS_INDEX 88
#define INST_ANDPD_INDEX 95
#define INST_ANDPS_INDEX 101
#define INST_BLENDPD_INDEX 107
#define INST_BLENDPS_INDEX 115
#define INST_BLENDVPD_INDEX 123
#define INST_BLENDVPS_INDEX 132
#define INST_BSF_INDEX 141
#define INST_BSR_INDEX 145
#define INST_BSWAP_INDEX 149
#define INST_BT_INDEX 155
#define INST_BTC_INDEX 158
#define INST_BTR_INDEX 162
#define INST_BTS_INDEX 166
#define INST_CALL_INDEX 170
#define INST_CBW_INDEX 175
#define INST_CDQE_INDEX 179
#define INST_CLC_INDEX 184
#define INST_CLD_INDEX 188
#define INST_CLFLUSH_INDEX 192
#define INST_CMC_INDEX 200
#define INST_CMOVA_INDEX 204
#define INST_CMOVAE_INDEX 210
#define INST_CMOVB_INDEX 217
#define INST_CMOVBE_INDEX 223
#define INST_CMOVC_INDEX 230
#define INST_CMOVE_INDEX 236
#define INST_CMOVG_INDEX 242
#define INST_CMOVGE_INDEX 248
#define INST_CMOVL_INDEX 255
#define INST_CMOVLE_INDEX 261
#define INST_CMOVNA_INDEX 268
#define INST_CMOVNAE_INDEX 275
#define INST_CMOVNB_INDEX 283
#define INST_CMOVNBE_INDEX 290
#define INST_CMOVNC_INDEX 298
#define INST_CMOVNE_INDEX 305
#define INST_CMOVNG_INDEX 312
#define INST_CMOVNGE_INDEX 319
#define INST_CMOVNL_INDEX 327
#define INST_CMOVNLE_INDEX 334
#define INST_CMOVNO_INDEX 342
#define INST_CMOVNP_INDEX 349
#define INST_CMOVNS_INDEX 356
#define INST_CMOVNZ_INDEX 363
#define INST_CMOVO_INDEX 370
#define INST_CMOVP_INDEX 376
#define INST_CMOVPE_INDEX 382
#define INST_CMOVPO_INDEX 389
#define INST_CMOVS_INDEX 396
#define INST_CMOVZ_INDEX 402
#define INST_CMP_INDEX 408
#define INST_CMPPD_INDEX 412
#define INST_CMPPS_INDEX 418
#define INST_CMPSD_INDEX 424
#define INST_CMPSS_INDEX 430
#define INST_CMPXCHG_INDEX 436
#define INST_CMPXCHG16B_INDEX 444
#define INST_CMPXCHG8B_INDEX 455
#define INST_COMISD_INDEX 465
#define INST_COMISS_INDEX 472
#define INST_CPUID_INDEX 479
#define INST_CRC32_INDEX 485
#define INST_CVTDQ2PD_INDEX 491
#define INST_CVTDQ2PS_INDEX 500
#define INST_CVTPD2DQ_INDEX 509
#define INST_CVTPD2PI_INDEX 518
#define INST_CVTPD2PS_INDEX 527
#define INST_CVTPI2PD_INDEX 536
#define INST_CVTPI2PS_INDEX 545
#define INST_CVTPS2DQ_INDEX 554
#define INST_CVTPS2PD_INDEX 563
#define INST_CVTPS2PI_INDEX 572
#define INST_CVTSD2SI_INDEX 581
#define INST_CVTSD2SS_INDEX 590
#define INST_CVTSI2SD_INDEX 599
#define INST_CVTSI2SS_INDEX 608
#define INST_CVTSS2SD_INDEX 617
#define INST_CVTSS2SI_INDEX 626
#define INST_CVTTPD2DQ_INDEX 635
#define INST_CVTTPD2PI_INDEX 645
#define INST_CVTTPS2DQ_INDEX 655
#define INST_CVTTPS2PI_INDEX 665
#define INST_CVTTSD2SI_INDEX 675
#define INST_CVTTSS2SI_INDEX 685
#define INST_CWDE_INDEX 695
#define INST_DAA_INDEX 700
#define INST_DAS_INDEX 704
#define INST_DEC_INDEX 708
#define INST_DIV_INDEX 712
#define INST_DIVPD_INDEX 716
#define INST_DIVPS_INDEX 722
#define INST_DIVSD_INDEX 728
#define INST_DIVSS_INDEX 734
#define INST_DPPD_INDEX 740
#define INST_DPPS_INDEX 745
#define INST_EMMS_INDEX 750
#define INST_ENTER_INDEX 755
#define INST_EXTRACTPS_INDEX 761
#define INST_F2XM1_INDEX 771
#define INST_FABS_INDEX 777
#define INST_FADD_INDEX 782
#define INST_FADDP_INDEX 787
#define INST_FBLD_INDEX 793
#define INST_FBSTP_INDEX 798
#define INST_FCHS_INDEX 804
#define INST_FCLEX_INDEX 809
#define INST_FCMOVB_INDEX 815
#define INST_FCMOVBE_INDEX 822
#define INST_FCMOVE_INDEX 830
#define INST_FCMOVNB_INDEX 837
#define INST_FCMOVNBE_INDEX 845
#define INST_FCMOVNE_INDEX 854
#define INST_FCMOVNU_INDEX 862
#define INST_FCMOVU_INDEX 870
#define INST_FCOM_INDEX 877
#define INST_FCOMI_INDEX 882
#define INST_FCOMIP_INDEX 888
#define INST_FCOMP_INDEX 895
#define INST_FCOMPP_INDEX 901
#define INST_FCOS_INDEX 908
#define INST_FDECSTP_INDEX 913
#define INST_FDIV_INDEX 921
#define INST_FDIVP_INDEX 926
#define INST_FDIVR_INDEX 932
#define INST_FDIVRP_INDEX 938
#define INST_FEMMS_INDEX 945
#define INST_FFREE_INDEX 951
#define INST_FIADD_INDEX 957
#define INST_FICOM_INDEX 963
#define INST_FICOMP_INDEX 969
#define INST_FIDIV_INDEX 976
#define INST_FIDIVR_INDEX 982
#define INST_FILD_INDEX 989
#define INST_FIMUL_INDEX 994
#define INST_FINCSTP_INDEX 1000
#define INST_FINIT_INDEX 1008
#define INST_FIST_INDEX 1014
#define INST_FISTP_INDEX 1019
#define INST_FISTTP_INDEX 1025
#define INST_FISUB_INDEX 1032
#define INST_FISUBR_INDEX 1038
#define INST_FLD_INDEX 1045
#define INST_FLD1_INDEX 1049
#define INST_FLDCW_INDEX 1054
#define INST_FLDENV_INDEX 1060
#define INST_FLDL2E_INDEX 1067
#define INST_FLDL2T_INDEX 1074
#define INST_FLDLG2_INDEX 1081
#define INST_FLDLN2_INDEX 1088
#define INST_FLDPI_INDEX 1095
#define INST_FLDZ_INDEX 1101
#define INST_FMUL_INDEX 1106
#define INST_FMULP_INDEX 1111
#define INST_FNCLEX_INDEX 1117
#define INST_FNINIT_INDEX 1124
#define INST_FNOP_INDEX 1131
#define INST_FNSAVE_INDEX 1136
#define INST_FNSTCW_INDEX 1143
#define INST_FNSTENV_INDEX 1150
#define INST_FNSTSW_INDEX 1158
#define INST_FPATAN_INDEX 1165
#define INST_FPREM_INDEX 1172
#define INST_FPREM1_INDEX 1178
#define INST_FPTAN_INDEX 1185
#define INST_FRNDINT_INDEX 1191
#define INST_FRSTOR_INDEX 1199
#define INST_FSAVE_INDEX 1206
#define INST_FSCALE_INDEX 1212
#define INST_FSIN_INDEX 1219
#define INST_FSINCOS_INDEX 1224
#define INST_FSQRT_INDEX 1232
#define INST_FST_INDEX 1238
#define INST_FSTCW_INDEX 1242
#define INST_FSTENV_INDEX 1248
#define INST_FSTP_INDEX 1255
#define INST_FSTSW_INDEX 1260
#define INST_FSUB_INDEX 1266
#define INST_FSUBP_INDEX 1271
#define INST_FSUBR_INDEX 1277
#define INST_FSUBRP_INDEX 1283
#define INST_FTST_INDEX 1290
#define INST_FUCOM_INDEX 1295
#define INST_FUCOMI_INDEX 1301
#define INST_FUCOMIP_INDEX 1308
#define INST_FUCOMP_INDEX 1316
#define INST_FUCOMPP_INDEX 1323
#define INST_FWAIT_INDEX 1331
#define INST_FXAM_INDEX 1337
#define INST_FXCH_INDEX 1342
#define INST_FXRSTOR_INDEX 1347
#define INST_FXSAVE_INDEX 1355
#define INST_FXTRACT_INDEX 1362
#define INST_FYL2X_INDEX 1370
#define INST_FYL2XP1_INDEX 1376
#define INST_HADDPD_INDEX 1384
#define INST_HADDPS_INDEX 1391
#define INST_HSUBPD_INDEX 1398
#define INST_HSUBPS_INDEX 1405
#define INST_IDIV_INDEX 1412
#define INST_IMUL_INDEX 1417
#define INST_INC_INDEX 1422
#define INST_INT3_INDEX 1426
#define INST_JA_INDEX 1431
#define INST_JAE_INDEX 1434
#define INST_JB_INDEX 1438
#define INST_JBE_INDEX 1441
#define INST_JC_INDEX 1445
#define INST_JE_INDEX 1448
#define INST_JG_INDEX 1451
#define INST_JGE_INDEX 1454
#define INST_JL_INDEX 1458
#define INST_JLE_INDEX 1461
#define INST_JNA_INDEX 1465
#define INST_JNAE_INDEX 1469
#define INST_JNB_INDEX 1474
#define INST_JNBE_INDEX 1478
#define INST_JNC_INDEX 1483
#define INST_JNE_INDEX 1487
#define INST_JNG_INDEX 1491
#define INST_JNGE_INDEX 1495
#define INST_JNL_INDEX 1500
#define INST_JNLE_INDEX 1504
#define INST_JNO_INDEX 1509
#define INST_JNP_INDEX 1513
#define INST_JNS_INDEX 1517
#define INST_JNZ_INDEX 1521
#define INST_JO_INDEX 1525
#define INST_JP_INDEX 1528
#define INST_JPE_INDEX 1531
#define INST_JPO_INDEX 1535
#define INST_JS_INDEX 1539
#define INST_JZ_INDEX 1542
#define INST_JMP_INDEX 1545
#define INST_LDDQU_INDEX 1549
#define INST_LDMXCSR_INDEX 1555
#define INST_LAHF_INDEX 1563
#define INST_LEA_INDEX 1568
#define INST_LEAVE_INDEX 1572
#define INST_LFENCE_INDEX 1578
#define INST_MASKMOVDQU_INDEX 1585
#define INST_MASKMOVQ_INDEX 1596
#define INST_MAXPD_INDEX 1605
#define INST_MAXPS_INDEX 1611
#define INST_MAXSD_INDEX 1617
#define INST_MAXSS_INDEX 1623
#define INST_MFENCE_INDEX 1629
#define INST_MINPD_INDEX 1636
#define INST_MINPS_INDEX 1642
#define INST_MINSD_INDEX 1648
#define INST_MINSS_INDEX 1654
#define INST_MONITOR_INDEX 1660
#define INST_MOV_INDEX 1668
#define INST_MOVAPD_INDEX 1672
#define INST_MOVAPS_INDEX 1679
#define INST_MOVBE_INDEX 1686
#define INST_MOVD_INDEX 1692
#define INST_MOVDDUP_INDEX 1697
#define INST_MOVDQ2Q_INDEX 1705
#define INST_MOVDQA_INDEX 1713
#define INST_MOVDQU_INDEX 1720
#define INST_MOVHLPS_INDEX 1727
#define INST_MOVHPD_INDEX 1735
#define INST_MOVHPS_INDEX 1742
#define INST_MOVLHPS_INDEX 1749
#define INST_MOVLPD_INDEX 1757
#define INST_MOVLPS_INDEX 1764
#define INST_MOVMSKPD_INDEX 1771
#define INST_MOVMSKPS_INDEX 1780
#define INST_MOVNTDQ_INDEX 1789
#define INST_MOVNTDQA_INDEX 1797
#define INST_MOVNTI_INDEX 1806
#define INST_MOVNTPD_INDEX 1813
#define INST_MOVNTPS_INDEX 1821
#define INST_MOVNTQ_INDEX 1829
#define INST_MOVQ_INDEX 1836
#define INST_MOVQ2DQ_INDEX 1841
#define INST_MOVSD_INDEX 1849
#define INST_MOVSHDUP_INDEX 1855
#define INST_MOVSLDUP_INDEX 1864
#define INST_MOVSS_INDEX 1873
#define INST_MOVSX_INDEX 1879
#define INST_MOVSXD_INDEX 1885
#define INST_MOVUPD_INDEX 1892
#define INST_MOVUPS_INDEX 1899
#define INST_MOVZX_INDEX 1906
#define INST_MOV_PTR_INDEX 1912
#define INST_MPSADBW_INDEX 1920
#define INST_MUL_INDEX 1928
#define INST_MULPD_INDEX 1932
#define INST_MULPS_INDEX 1938
#define INST_MULSD_INDEX 1944
#define INST_MULSS_INDEX 1950
#define INST_MWAIT_INDEX 1956
#define INST_NEG_INDEX 1962
#define INST_NOP_INDEX 1966
#define INST_NOT_INDEX 1970
#define INST_OR_INDEX 1974
#define INST_ORPD_INDEX 1977
#define INST_ORPS_INDEX 1982
#define INST_PABSB_INDEX 1987
#define INST_PABSD_INDEX 1993
#define INST_PABSW_INDEX 1999
#define INST_PACKSSDW_INDEX 2005
#define INST_PACKSSWB_INDEX 2014
#define INST_PACKUSDW_INDEX 2023
#define INST_PACKUSWB_INDEX 2032
#define INST_PADDB_INDEX 2041
#define INST_PADDD_INDEX 2047
#define INST_PADDQ_INDEX 2053
#define INST_PADDSB_INDEX 2059
#define INST_PADDSW_INDEX 2066
#define INST_PADDUSB_INDEX 2073
#define INST_PADDUSW_INDEX 2081
#define INST_PADDW_INDEX 2089
#define INST_PALIGNR_INDEX 2095
#define INST_PAND_INDEX 2103
#define INST_PANDN_INDEX 2108
#define INST_PAUSE_INDEX 2114
#define INST_PAVGB_INDEX 2120
#define INST_PAVGW_INDEX 2126
#define INST_PBLENDVB_INDEX 2132
#define INST_PBLENDW_INDEX 2141
#define INST_PCMPEQB_INDEX 2149
#define INST_PCMPEQD_INDEX 2157
#define INST_PCMPEQQ_INDEX 2165
#define INST_PCMPEQW_INDEX 2173
#define INST_PCMPESTRI_INDEX 2181
#define INST_PCMPESTRM_INDEX 2191
#define INST_PCMPGTB_INDEX 2201
#define INST_PCMPGTD_INDEX 2209
#define INST_PCMPGTQ_INDEX 2217
#define INST_PCMPGTW_INDEX 2225
#define INST_PCMPISTRI_INDEX 2233
#define INST_PCMPISTRM_INDEX 2243
#define INST_PEXTRB_INDEX 2253
#define INST_PEXTRD_INDEX 2260
#define INST_PEXTRQ_INDEX 2267
#define INST_PEXTRW_INDEX 2274
#define INST_PF2ID_INDEX 2281
#define INST_PF2IW_INDEX 2287
#define INST_PFACC_INDEX 2293
#define INST_PFADD_INDEX 2299
#define INST_PFCMPEQ_INDEX 2305
#define INST_PFCMPGE_INDEX 2313
#define INST_PFCMPGT_INDEX 2321
#define INST_PFMAX_INDEX 2329
#define INST_PFMIN_INDEX 2335
#define INST_PFMUL_INDEX 2341
#define INST_PFNACC_INDEX 2347
#define INST_PFPNACC_INDEX 2354
#define INST_PFRCP_INDEX 2362
#define INST_PFRCPIT1_INDEX 2368
#define INST_PFRCPIT2_INDEX 2377
#define INST_PFRSQIT1_INDEX 2386
#define INST_PFRSQRT_INDEX 2395
#define INST_PFSUB_INDEX 2403
#define INST_PFSUBR_INDEX 2409
#define INST_PHADDD_INDEX 2416
#define INST_PHADDSW_INDEX 2423
#define INST_PHADDW_INDEX 2431
#define INST_PHMINPOSUW_INDEX 2438
#define INST_PHSUBD_INDEX 2449
#define INST_PHSUBSW_INDEX 2456
#define INST_PHSUBW_INDEX 2464
#define INST_PI2FD_INDEX 2471
#define INST_PI2FW_INDEX 2477
#define INST_PINSRB_INDEX 2483
#define INST_PINSRD_INDEX 2490
#define INST_PINSRQ_INDEX 2497
#define INST_PINSRW_INDEX 2504
#define INST_PMADDUBSW_INDEX 2511
#define INST_PMADDWD_INDEX 2521
#define INST_PMAXSB_INDEX 2529
#define INST_PMAXSD_INDEX 2536
#define INST_PMAXSW_INDEX 2543
#define INST_PMAXUB_INDEX 2550
#define INST_PMAXUD_INDEX 2557
#define INST_PMAXUW_INDEX 2564
#define INST_PMINSB_INDEX 2571
#define INST_PMINSD_INDEX 2578
#define INST_PMINSW_INDEX 2585
#define INST_PMINUB_INDEX 2592
#define INST_PMINUD_INDEX 2599
#define INST_PMINUW_INDEX 2606
#define INST_PMOVMSKB_INDEX 2613
#define INST_PMOVSXBD_INDEX 2622
#define INST_PMOVSXBQ_INDEX 2631
#define INST_PMOVSXBW_INDEX 2640
#define INST_PMOVSXDQ_INDEX 2649
#define INST_PMOVSXWD_INDEX 2658
#define INST_PMOVSXWQ_INDEX 2667
#define INST_PMOVZXBD_INDEX 2676
#define INST_PMOVZXBQ_INDEX 2685
#define INST_PMOVZXBW_INDEX 2694
#define INST_PMOVZXDQ_INDEX 2703
#define INST_PMOVZXWD_INDEX 2712
#define INST_PMOVZXWQ_INDEX 2721
#define INST_PMULDQ_INDEX 2730
#define INST_PMULHRSW_INDEX 2737
#define INST_PMULHUW_INDEX 2746
#define INST_PMULHW_INDEX 2754
#define INST_PMULLD_INDEX 2761
#define INST_PMULLW_INDEX 2768
#define INST_PMULUDQ_INDEX 2775
#define INST_POP_INDEX 2783
#define INST_POPAD_INDEX 2787
#define INST_POPCNT_INDEX 2793
#define INST_POPFD_INDEX 2800
#define INST_POPFQ_INDEX 2806
#define INST_POR_INDEX 2812
#define INST_PREFETCH_INDEX 2816
#define INST_PSADBW_INDEX 2825
#define INST_PSHUFB_INDEX 2832
#define INST_PSHUFD_INDEX 2839
#define INST_PSHUFW_INDEX 2846
#define INST_PSHUFHW_INDEX 2853
#define INST_PSHUFLW_INDEX 2861
#define INST_PSIGNB_INDEX 2869
#define INST_PSIGND_INDEX 2876
#define INST_PSIGNW_INDEX 2883
#define INST_PSLLD_INDEX 2890
#define INST_PSLLDQ_INDEX 2896
#define INST_PSLLQ_INDEX 2903
#define INST_PSLLW_INDEX 2909
#define INST_PSRAD_INDEX 2915
#define INST_PSRAW_INDEX 2921
#define INST_PSRLD_INDEX 2927
#define INST_PSRLDQ_INDEX 2933
#define INST_PSRLQ_INDEX 2940
#define INST_PSRLW_INDEX 2946
#define INST_PSUBB_INDEX 2952
#define INST_PSUBD_INDEX 2958
#define INST_PSUBQ_INDEX 2964
#define INST_PSUBSB_INDEX 2970
#define INST_PSUBSW_INDEX 2977
#define INST_PSUBUSB_INDEX 2984
#define INST_PSUBUSW_INDEX 2992
#define INST_PSUBW_INDEX 3000
#define INST_PSWAPD_INDEX 3006
#define INST_PTEST_INDEX 3013
#define INST_PUNPCKHBW_INDEX 3019
#define INST_PUNPCKHDQ_INDEX 3029
#define INST_PUNPCKHQDQ_INDEX 3039
#define INST_PUNPCKHWD_INDEX 3050
#define INST_PUNPCKLBW_INDEX 3060
#define INST_PUNPCKLDQ_INDEX 3070
#define INST_PUNPCKLQDQ_INDEX 3080
#define INST_PUNPCKLWD_INDEX 3091
#define INST_PUSH_INDEX 3101
#define INST_PUSHAD_INDEX 3106
#define INST_PUSHFD_INDEX 3113
#define INST_PUSHFQ_INDEX 3120
#define INST_PXOR_INDEX 3127
#define INST_RCL_INDEX 3132
#define INST_RCPPS_INDEX 3136
#define INST_RCPSS_INDEX 3142
#define INST_RCR_INDEX 3148
#define INST_RDTSC_INDEX 3152
#define INST_RDTSCP_INDEX 3158
#define INST_REP_LODSB_INDEX 3165
#define INST_REP_LODSD_INDEX 3175
#define INST_REP_LODSQ_INDEX 3185
#define INST_REP_LODSW_INDEX 3195
#define INST_REP_MOVSB_INDEX 3205
#define INST_REP_MOVSD_INDEX 3215
#define INST_REP_MOVSQ_INDEX 3225
#define INST_REP_MOVSW_INDEX 3235
#define INST_REP_STOSB_INDEX 3245
#define INST_REP_STOSD_INDEX 3255
#define INST_REP_STOSQ_INDEX 3265
#define INST_REP_STOSW_INDEX 3275
#define INST_REPE_CMPSB_INDEX 3285
#define INST_REPE_CMPSD_INDEX 3296
#define INST_REPE_CMPSQ_INDEX 3307
#define INST_REPE_CMPSW_INDEX 3318
#define INST_REPE_SCASB_INDEX 3329
#define INST_REPE_SCASD_INDEX 3340
#define INST_REPE_SCASQ_INDEX 3351
#define INST_REPE_SCASW_INDEX 3362
#define INST_REPNE_CMPSB_INDEX 3373
#define INST_REPNE_CMPSD_INDEX 3385
#define INST_REPNE_CMPSQ_INDEX 3397
#define INST_REPNE_CMPSW_INDEX 3409
#define INST_REPNE_SCASB_INDEX 3421
#define INST_REPNE_SCASD_INDEX 3433
#define INST_REPNE_SCASQ_INDEX 3445
#define INST_REPNE_SCASW_INDEX 3457
#define INST_RET_INDEX 3469
#define INST_ROL_INDEX 3473
#define INST_ROR_INDEX 3477
#define INST_ROUNDPD_INDEX 3481
#define INST_ROUNDPS_INDEX 3489
#define INST_ROUNDSD_INDEX 3497
#define INST_ROUNDSS_INDEX 3505
#define INST_RSQRTPS_INDEX 3513
#define INST_RSQRTSS_INDEX 3521
#define INST_SAHF_INDEX 3529
#define INST_SAL_INDEX 3534
#define INST_SAR_INDEX 3538
#define INST_SBB_INDEX 3542
#define INST_SETA_INDEX 3546
#define INST_SETAE_INDEX 3551
#define INST_SETB_INDEX 3557
#define INST_SETBE_INDEX 3562
#define INST_SETC_INDEX 3568
#define INST_SETE_INDEX 3573
#define INST_SETG_INDEX 3578
#define INST_SETGE_INDEX 3583
#define INST_SETL_INDEX 3589
#define INST_SETLE_INDEX 3594
#define INST_SETNA_INDEX 3600
#define INST_SETNAE_INDEX 3606
#define INST_SETNB_INDEX 3613
#define INST_SETNBE_INDEX 3619
#define INST_SETNC_INDEX 3626
#define INST_SETNE_INDEX 3632
#define INST_SETNG_INDEX 3638
#define INST_SETNGE_INDEX 3644
#define INST_SETNL_INDEX 3651
#define INST_SETNLE_INDEX 3657
#define INST_SETNO_INDEX 3664
#define INST_SETNP_INDEX 3670
#define INST_SETNS_INDEX 3676
#define INST_SETNZ_INDEX 3682
#define INST_SETO_INDEX 3688
#define INST_SETP_INDEX 3693
#define INST_SETPE_INDEX 3698
#define INST_SETPO_INDEX 3704
#define INST_SETS_INDEX 3710
#define INST_SETZ_INDEX 3715
#define INST_SFENCE_INDEX 3720
#define INST_SHL_INDEX 3727
#define INST_SHLD_INDEX 3731
#define INST_SHR_INDEX 3736
#define INST_SHRD_INDEX 3740
#define INST_SHUFPD_INDEX 3745
#define INST_SHUFPS_INDEX 3752
#define INST_SQRTPD_INDEX 3759
#define INST_SQRTPS_INDEX 3766
#define INST_SQRTSD_INDEX 3773
#define INST_SQRTSS_INDEX 3780
#define INST_STC_INDEX 3787
#define INST_STD_INDEX 3791
#define INST_STMXCSR_INDEX 3795
#define INST_SUB_INDEX 3803
#define INST_SUBPD_INDEX 3807
#define INST_SUBPS_INDEX 3813
#define INST_SUBSD_INDEX 3819
#define INST_SUBSS_INDEX 3825
#define INST_TEST_INDEX 3831
#define INST_UCOMISD_INDEX 3836
#define INST_UCOMISS_INDEX 3844
#define INST_UD2_INDEX 3852
#define INST_UNPCKHPD_INDEX 3856
#define INST_UNPCKHPS_INDEX 3865
#define INST_UNPCKLPD_INDEX 3874
#define INST_UNPCKLPS_INDEX 3883
#define INST_XADD_INDEX 3892
#define INST_XCHG_INDEX 3897
#define INST_XOR_INDEX 3902
#define INST_XORPD_INDEX 3906
#define INST_XORPS_INDEX 3912
// ${INSTRUCTION_DATA_END}

// ============================================================================
// [AsmJit::Instruction Description]
// ============================================================================

#define MAKE_INST(code, name, group, flags, oflags0, oflags1, opReg, opCode0, opCode1) \
  { code, code##_INDEX, group, flags, { oflags0, oflags1 }, opReg, { opCode0, opCode1 } }

#define G(g) InstructionDescription::G_##g
#define F(f) InstructionDescription::F_##f
#define O(o) InstructionDescription::O_##o

const InstructionDescription instructionDescription[] =
{
  // Instruction code (enum)      | instruction name   | instruction group| instruction flags| oflags[0]           | oflags[1]           | r| opCode[0] | opcode[1]
  MAKE_INST(INST_ADC              , "adc"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 2, 0x00000010, 0x00000080),
  MAKE_INST(INST_ADD              , "add"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 0, 0x00000000, 0x00000080),
  MAKE_INST(INST_ADDPD            , "addpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F58, 0),
  MAKE_INST(INST_ADDPS            , "addps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F58, 0),
  MAKE_INST(INST_ADDSD            , "addsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F58, 0),
  MAKE_INST(INST_ADDSS            , "addss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F58, 0),
  MAKE_INST(INST_ADDSUBPD         , "addsubpd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000FD0, 0),
  MAKE_INST(INST_ADDSUBPS         , "addsubps"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000FD0, 0),
  MAKE_INST(INST_AMD_PREFETCH     , "amd_prefetch"     , G(M)             , F(NONE)          , O(MEM)              , 0                   , 0, 0x00000F0D, 0),
  MAKE_INST(INST_AMD_PREFETCHW    , "amd_prefetchw"    , G(M)             , F(NONE)          , O(MEM)              , 0                   , 1, 0x00000F0D, 0),
  MAKE_INST(INST_AND              , "and"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 4, 0x00000020, 0x00000080),
  MAKE_INST(INST_ANDNPD           , "andnpd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F55, 0),
  MAKE_INST(INST_ANDNPS           , "andnps"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F55, 0),
  MAKE_INST(INST_ANDPD            , "andpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F54, 0),
  MAKE_INST(INST_ANDPS            , "andps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F54, 0),
  MAKE_INST(INST_BLENDPD          , "blendpd"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A0D, 0),
  MAKE_INST(INST_BLENDPS          , "blendps"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A0C, 0),
  MAKE_INST(INST_BLENDVPD         , "blendvpd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3815, 0),
  MAKE_INST(INST_BLENDVPS         , "blendvps"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3814, 0),
  MAKE_INST(INST_BSF              , "bsf"              , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000FBC, 0),
  MAKE_INST(INST_BSR              , "bsr"              , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000FBD, 0),
  MAKE_INST(INST_BSWAP            , "bswap"            , G(BSWAP)         , F(NONE)          , O(GQD)              , 0                   , 0, 0         , 0),
  MAKE_INST(INST_BT               , "bt"               , G(BT)            , F(NONE)          , O(GQDW)|O(MEM)      , O(GQDW)|O(IMM)      , 4, 0x00000FA3, 0x00000FBA),
  MAKE_INST(INST_BTC              , "btc"              , G(BT)            , F(LOCKABLE)      , O(GQDW)|O(MEM)      , O(GQDW)|O(IMM)      , 7, 0x00000FBB, 0x00000FBA),
  MAKE_INST(INST_BTR              , "btr"              , G(BT)            , F(LOCKABLE)      , O(GQDW)|O(MEM)      , O(GQDW)|O(IMM)      , 6, 0x00000FB3, 0x00000FBA),
  MAKE_INST(INST_BTS              , "bts"              , G(BT)            , F(LOCKABLE)      , O(GQDW)|O(MEM)      , O(GQDW)|O(IMM)      , 5, 0x00000FAB, 0x00000FBA),
  MAKE_INST(INST_CALL             , "call"             , G(CALL)          , F(JUMP)          , O(GQD)|O(MEM)       , 0                   , 0, 0         , 0),
  MAKE_INST(INST_CBW              , "cbw"              , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x66000099, 0),
  MAKE_INST(INST_CDQE             , "cdqe"             , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x48000099, 0),
  MAKE_INST(INST_CLC              , "clc"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000F8, 0),
  MAKE_INST(INST_CLD              , "cld"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000FC, 0),
  MAKE_INST(INST_CLFLUSH          , "clflush"          , G(M)             , F(NONE)          , O(MEM)              , 0                   , 7, 0x00000FAE, 0),
  MAKE_INST(INST_CMC              , "cmc"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000F5, 0),
  MAKE_INST(INST_CMOVA            , "cmova"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F47, 0),
  MAKE_INST(INST_CMOVAE           , "cmovae"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F43, 0),
  MAKE_INST(INST_CMOVB            , "cmovb"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F42, 0),
  MAKE_INST(INST_CMOVBE           , "cmovbe"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F46, 0),
  MAKE_INST(INST_CMOVC            , "cmovc"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F42, 0),
  MAKE_INST(INST_CMOVE            , "cmove"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F44, 0),
  MAKE_INST(INST_CMOVG            , "cmovg"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4F, 0),
  MAKE_INST(INST_CMOVGE           , "cmovge"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4D, 0),
  MAKE_INST(INST_CMOVL            , "cmovl"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4C, 0),
  MAKE_INST(INST_CMOVLE           , "cmovle"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4E, 0),
  MAKE_INST(INST_CMOVNA           , "cmovna"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F46, 0),
  MAKE_INST(INST_CMOVNAE          , "cmovnae"          , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F42, 0),
  MAKE_INST(INST_CMOVNB           , "cmovnb"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F43, 0),
  MAKE_INST(INST_CMOVNBE          , "cmovnbe"          , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F47, 0),
  MAKE_INST(INST_CMOVNC           , "cmovnc"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F43, 0),
  MAKE_INST(INST_CMOVNE           , "cmovne"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F45, 0),
  MAKE_INST(INST_CMOVNG           , "cmovng"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4E, 0),
  MAKE_INST(INST_CMOVNGE          , "cmovnge"          , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4C, 0),
  MAKE_INST(INST_CMOVNL           , "cmovnl"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4D, 0),
  MAKE_INST(INST_CMOVNLE          , "cmovnle"          , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4F, 0),
  MAKE_INST(INST_CMOVNO           , "cmovno"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F41, 0),
  MAKE_INST(INST_CMOVNP           , "cmovnp"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4B, 0),
  MAKE_INST(INST_CMOVNS           , "cmovns"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F49, 0),
  MAKE_INST(INST_CMOVNZ           , "cmovnz"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F45, 0),
  MAKE_INST(INST_CMOVO            , "cmovo"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F40, 0),
  MAKE_INST(INST_CMOVP            , "cmovp"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4A, 0),
  MAKE_INST(INST_CMOVPE           , "cmovpe"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4A, 0),
  MAKE_INST(INST_CMOVPO           , "cmovpo"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F4B, 0),
  MAKE_INST(INST_CMOVS            , "cmovs"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F48, 0),
  MAKE_INST(INST_CMOVZ            , "cmovz"            , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0x00000F44, 0),
  MAKE_INST(INST_CMP              , "cmp"              , G(ALU)           , F(NONE)          , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 7, 0x00000038, 0x00000080),
  MAKE_INST(INST_CMPPD            , "cmppd"            , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000FC2, 0),
  MAKE_INST(INST_CMPPS            , "cmpps"            , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000FC2, 0),
  MAKE_INST(INST_CMPSD            , "cmpsd"            , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000FC2, 0),
  MAKE_INST(INST_CMPSS            , "cmpss"            , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000FC2, 0),
  MAKE_INST(INST_CMPXCHG          , "cmpxchg"          , G(RM_R)          , F(SPECIAL)|F(LOCKABLE), 0              , 0                   , 0, 0x00000FB0, 0),
  MAKE_INST(INST_CMPXCHG16B       , "cmpxchg16b"       , G(M)             , F(SPECIAL)       , O(MEM)              , 0                   , 1, 0x00000FC7, 1 /* RexW */),
  MAKE_INST(INST_CMPXCHG8B        , "cmpxchg8b"        , G(M)             , F(SPECIAL)       , O(MEM)              , 0                   , 1, 0x00000FC7, 0),
  MAKE_INST(INST_COMISD           , "comisd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F2F, 0),
  MAKE_INST(INST_COMISS           , "comiss"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F2F, 0),
  MAKE_INST(INST_CPUID            , "cpuid"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000FA2, 0),
  MAKE_INST(INST_CRC32            , "crc32"            , G(CRC32)         , F(NONE)          , O(GQD)              , O(GQDWB_MEM)        , 0, 0xF20F38F0, 0),
  MAKE_INST(INST_CVTDQ2PD         , "cvtdq2pd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000FE6, 0),
  MAKE_INST(INST_CVTDQ2PS         , "cvtdq2ps"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5B, 0),
  MAKE_INST(INST_CVTPD2DQ         , "cvtpd2dq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000FE6, 0),
  MAKE_INST(INST_CVTPD2PI         , "cvtpd2pi"         , G(MMU_RMI)       , F(MOV)           , O(MM)               , O(XMM_MEM)          , 0, 0x66000F2D, 0),
  MAKE_INST(INST_CVTPD2PS         , "cvtpd2ps"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5A, 0),
  MAKE_INST(INST_CVTPI2PD         , "cvtpi2pd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(MM_MEM)           , 0, 0x66000F2A, 0),
  MAKE_INST(INST_CVTPI2PS         , "cvtpi2ps"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(MM_MEM)           , 0, 0x00000F2A, 0),
  MAKE_INST(INST_CVTPS2DQ         , "cvtps2dq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5B, 0),
  MAKE_INST(INST_CVTPS2PD         , "cvtps2pd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5A, 0),
  MAKE_INST(INST_CVTPS2PI         , "cvtps2pi"         , G(MMU_RMI)       , F(MOV)           , O(MM)               , O(XMM_MEM)          , 0, 0x00000F2D, 0),
  MAKE_INST(INST_CVTSD2SI         , "cvtsd2si"         , G(MMU_RMI)       , F(MOV)           , O(GQD)              , O(XMM_MEM)          , 0, 0xF2000F2D, 0),
  MAKE_INST(INST_CVTSD2SS         , "cvtsd2ss"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F5A, 0),
  MAKE_INST(INST_CVTSI2SD         , "cvtsi2sd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(GQD)|O(MEM)       , 0, 0xF2000F2A, 0),
  MAKE_INST(INST_CVTSI2SS         , "cvtsi2ss"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(GQD)|O(MEM)       , 0, 0xF3000F2A, 0),
  MAKE_INST(INST_CVTSS2SD         , "cvtss2sd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5A, 0),
  MAKE_INST(INST_CVTSS2SI         , "cvtss2si"         , G(MMU_RMI)       , F(NONE)          , O(GQD)              , O(XMM_MEM)          , 0, 0xF3000F2D, 0),
  MAKE_INST(INST_CVTTPD2DQ        , "cvttpd2dq"        , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x66000FE6, 0),
  MAKE_INST(INST_CVTTPD2PI        , "cvttpd2pi"        , G(MMU_RMI)       , F(MOV)           , O(MM)               , O(XMM_MEM)          , 0, 0x66000F2C, 0),
  MAKE_INST(INST_CVTTPS2DQ        , "cvttps2dq"        , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5B, 0),
  MAKE_INST(INST_CVTTPS2PI        , "cvttps2pi"        , G(MMU_RMI)       , F(MOV)           , O(MM)               , O(XMM_MEM)          , 0, 0x00000F2C, 0),
  MAKE_INST(INST_CVTTSD2SI        , "cvttsd2si"        , G(MMU_RMI)       , F(NONE)          , O(GQD)              , O(XMM_MEM)          , 0, 0xF2000F2C, 0),
  MAKE_INST(INST_CVTTSS2SI        , "cvttss2si"        , G(MMU_RMI)       , F(NONE)          , O(GQD)              , O(XMM_MEM)          , 0, 0xF3000F2C, 0),
  MAKE_INST(INST_CWDE             , "cwde"             , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000099, 0),
  MAKE_INST(INST_DAA              , "daa"              , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000027, 0),
  MAKE_INST(INST_DAS              , "das"              , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000002F, 0),
  MAKE_INST(INST_DEC              , "dec"              , G(INC_DEC)       , F(LOCKABLE)      , O(GQDWB_MEM)        , 0                   , 1, 0x00000048, 0x000000FE),
  MAKE_INST(INST_DIV              , "div"              , G(RM)            , F(SPECIAL)       , 0                   , 0                   , 6, 0x000000F6, 0),
  MAKE_INST(INST_DIVPD            , "divpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5E, 0),
  MAKE_INST(INST_DIVPS            , "divps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5E, 0),
  MAKE_INST(INST_DIVSD            , "divsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F5E, 0),
  MAKE_INST(INST_DIVSS            , "divss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5E, 0),
  MAKE_INST(INST_DPPD             , "dppd"             , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A41, 0),
  MAKE_INST(INST_DPPS             , "dpps"             , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A40, 0),
  MAKE_INST(INST_EMMS             , "emms"             , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x00000F77, 0),
  MAKE_INST(INST_ENTER            , "enter"            , G(ENTER)         , F(SPECIAL)       , 0                   , 0                   , 0, 0x000000C8, 0),
  MAKE_INST(INST_EXTRACTPS        , "extractps"        , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A17, 0),
  MAKE_INST(INST_F2XM1            , "f2xm1"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F0, 0),
  MAKE_INST(INST_FABS             , "fabs"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E1, 0),
  MAKE_INST(INST_FADD             , "fadd"             , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 0, 0xD8DCC0C0, 0),
  MAKE_INST(INST_FADDP            , "faddp"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEC0, 0),
  MAKE_INST(INST_FBLD             , "fbld"             , G(M)             , F(FPU)           , O(MEM)              , 0                   , 4, 0x000000DF, 0),
  MAKE_INST(INST_FBSTP            , "fbstp"            , G(M)             , F(FPU)           , O(MEM)              , 0                   , 6, 0x000000DF, 0),
  MAKE_INST(INST_FCHS             , "fchs"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E0, 0),
  MAKE_INST(INST_FCLEX            , "fclex"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x9B00DBE2, 0),
  MAKE_INST(INST_FCMOVB           , "fcmovb"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DAC0, 0),
  MAKE_INST(INST_FCMOVBE          , "fcmovbe"          , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DAD0, 0),
  MAKE_INST(INST_FCMOVE           , "fcmove"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DAC8, 0),
  MAKE_INST(INST_FCMOVNB          , "fcmovnb"          , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBC0, 0),
  MAKE_INST(INST_FCMOVNBE         , "fcmovnbe"         , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBD0, 0),
  MAKE_INST(INST_FCMOVNE          , "fcmovne"          , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBC8, 0),
  MAKE_INST(INST_FCMOVNU          , "fcmovnu"          , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBD8, 0),
  MAKE_INST(INST_FCMOVU           , "fcmovu"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DAD8, 0),
  MAKE_INST(INST_FCOM             , "fcom"             , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 2, 0xD8DCD0D0, 0),
  MAKE_INST(INST_FCOMI            , "fcomi"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBF0, 0),
  MAKE_INST(INST_FCOMIP           , "fcomip"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DFF0, 0),
  MAKE_INST(INST_FCOMP            , "fcomp"            , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 3, 0xD8DCD8D8, 0),
  MAKE_INST(INST_FCOMPP           , "fcompp"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000DED9, 0),
  MAKE_INST(INST_FCOS             , "fcos"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FF, 0),
  MAKE_INST(INST_FDECSTP          , "fdecstp"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F6, 0),
  MAKE_INST(INST_FDIV             , "fdiv"             , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 6, 0xD8DCF0F8, 0),
  MAKE_INST(INST_FDIVP            , "fdivp"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEF8, 0),
  MAKE_INST(INST_FDIVR            , "fdivr"            , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 7, 0xD8DCF8F0, 0),
  MAKE_INST(INST_FDIVRP           , "fdivrp"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEF0, 0),
  MAKE_INST(INST_FEMMS            , "femms"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x00000F0E, 0),
  MAKE_INST(INST_FFREE            , "ffree"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DDC0, 0),
  MAKE_INST(INST_FIADD            , "fiadd"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 0, 0xDEDA0000, 0),
  MAKE_INST(INST_FICOM            , "ficom"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 2, 0xDEDA0000, 0),
  MAKE_INST(INST_FICOMP           , "ficomp"           , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 3, 0xDEDA0000, 0),
  MAKE_INST(INST_FIDIV            , "fidiv"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 6, 0xDEDA0000, 0),
  MAKE_INST(INST_FIDIVR           , "fidivr"           , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 7, 0xDEDA0000, 0),
  MAKE_INST(INST_FILD             , "fild"             , G(X87_MEM)       , F(FPU)           , O(FM_2_4_8)         , 0                   , 0, 0xDFDBDF05, 0),
  MAKE_INST(INST_FIMUL            , "fimul"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 1, 0xDEDA0000, 0),
  MAKE_INST(INST_FINCSTP          , "fincstp"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F7, 0),
  MAKE_INST(INST_FINIT            , "finit"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x9B00DBE3, 0),
  MAKE_INST(INST_FIST             , "fist"             , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 2, 0xDFDB0000, 0),
  MAKE_INST(INST_FISTP            , "fistp"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4_8)         , 0                   , 3, 0xDFDBDF07, 0),
  MAKE_INST(INST_FISTTP           , "fisttp"           , G(X87_MEM)       , F(FPU)           , O(FM_2_4_8)         , 0                   , 1, 0xDFDBDD01, 0),
  MAKE_INST(INST_FISUB            , "fisub"            , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 4, 0xDEDA0000, 0),
  MAKE_INST(INST_FISUBR           , "fisubr"           , G(X87_MEM)       , F(FPU)           , O(FM_2_4)           , 0                   , 5, 0xDEDA0000, 0),
  MAKE_INST(INST_FLD              , "fld"              , G(X87_MEM_STI)   , F(FPU)           , O(FM_4_8_10)        , 0                   , 0, 0x00D9DD00, 0xD9C0DB05),
  MAKE_INST(INST_FLD1             , "fld1"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E8, 0),
  MAKE_INST(INST_FLDCW            , "fldcw"            , G(M)             , F(FPU)           , O(MEM)              , 0                   , 5, 0x000000D9, 0),
  MAKE_INST(INST_FLDENV           , "fldenv"           , G(M)             , F(FPU)           , O(MEM)              , 0                   , 4, 0x000000D9, 0),
  MAKE_INST(INST_FLDL2E           , "fldl2e"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9EA, 0),
  MAKE_INST(INST_FLDL2T           , "fldl2t"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E9, 0),
  MAKE_INST(INST_FLDLG2           , "fldlg2"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9EC, 0),
  MAKE_INST(INST_FLDLN2           , "fldln2"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9ED, 0),
  MAKE_INST(INST_FLDPI            , "fldpi"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9EB, 0),
  MAKE_INST(INST_FLDZ             , "fldz"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9EE, 0),
  MAKE_INST(INST_FMUL             , "fmul"             , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 1, 0xD8DCC8C8, 0),
  MAKE_INST(INST_FMULP            , "fmulp"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEC8, 0),
  MAKE_INST(INST_FNCLEX           , "fnclex"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000DBE2, 0),
  MAKE_INST(INST_FNINIT           , "fninit"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000DBE3, 0),
  MAKE_INST(INST_FNOP             , "fnop"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9D0, 0),
  MAKE_INST(INST_FNSAVE           , "fnsave"           , G(M)             , F(FPU)           , O(MEM)              , 0                   , 6, 0x000000DD, 0),
  MAKE_INST(INST_FNSTCW           , "fnstcw"           , G(M)             , F(FPU)           , O(MEM)              , 0                   , 7, 0x000000D9, 0),
  MAKE_INST(INST_FNSTENV          , "fnstenv"          , G(M)             , F(FPU)           , O(MEM)              , 0                   , 6, 0x000000D9, 0),
  MAKE_INST(INST_FNSTSW           , "fnstsw"           , G(X87_FSTSW)     , F(FPU)           , O(MEM)              , 0                   , 7, 0x000000DD, 0x0000DFE0),
  MAKE_INST(INST_FPATAN           , "fpatan"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F3, 0),
  MAKE_INST(INST_FPREM            , "fprem"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F8, 0),
  MAKE_INST(INST_FPREM1           , "fprem1"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F5, 0),
  MAKE_INST(INST_FPTAN            , "fptan"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F2, 0),
  MAKE_INST(INST_FRNDINT          , "frndint"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FC, 0),
  MAKE_INST(INST_FRSTOR           , "frstor"           , G(M)             , F(FPU)           , O(MEM)              , 0                   , 4, 0x000000DD, 0),
  MAKE_INST(INST_FSAVE            , "fsave"            , G(M)             , F(FPU)           , O(MEM)              , 0                   , 6, 0x9B0000DD, 0),
  MAKE_INST(INST_FSCALE           , "fscale"           , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FD, 0),
  MAKE_INST(INST_FSIN             , "fsin"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FE, 0),
  MAKE_INST(INST_FSINCOS          , "fsincos"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FB, 0),
  MAKE_INST(INST_FSQRT            , "fsqrt"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9FA, 0),
  MAKE_INST(INST_FST              , "fst"              , G(X87_MEM_STI)   , F(FPU)           , O(FM_4_8)           , 0                   , 2, 0x00D9DD02, 0xDDD00000),
  MAKE_INST(INST_FSTCW            , "fstcw"            , G(M)             , F(FPU)           , O(MEM)              , 0                   , 7, 0x9B0000D9, 0),
  MAKE_INST(INST_FSTENV           , "fstenv"           , G(M)             , F(FPU)           , O(MEM)              , 0                   , 6, 0x9B0000D9, 0),
  MAKE_INST(INST_FSTP             , "fstp"             , G(X87_MEM_STI)   , F(FPU)           , O(FM_4_8_10)        , 0                   , 3, 0x00D9DD03, 0xDDD8DB07),
  MAKE_INST(INST_FSTSW            , "fstsw"            , G(X87_FSTSW)     , F(FPU)           , O(MEM)              , 0                   , 7, 0x9B0000DD, 0x9B00DFE0),
  MAKE_INST(INST_FSUB             , "fsub"             , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 4, 0xD8DCE0E8, 0),
  MAKE_INST(INST_FSUBP            , "fsubp"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEE8, 0),
  MAKE_INST(INST_FSUBR            , "fsubr"            , G(X87_FPU)       , F(FPU)           , 0                   , 0                   , 5, 0xD8DCE8E0, 0),
  MAKE_INST(INST_FSUBRP           , "fsubrp"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DEE0, 0),
  MAKE_INST(INST_FTST             , "ftst"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E4, 0),
  MAKE_INST(INST_FUCOM            , "fucom"            , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DDE0, 0),
  MAKE_INST(INST_FUCOMI           , "fucomi"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DBE8, 0),
  MAKE_INST(INST_FUCOMIP          , "fucomip"          , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DFE8, 0),
  MAKE_INST(INST_FUCOMP           , "fucomp"           , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000DDE8, 0),
  MAKE_INST(INST_FUCOMPP          , "fucompp"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000DAE9, 0),
  MAKE_INST(INST_FWAIT            , "fwait"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x000000DB, 0),
  MAKE_INST(INST_FXAM             , "fxam"             , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9E5, 0),
  MAKE_INST(INST_FXCH             , "fxch"             , G(X87_STI)       , F(FPU)           , 0                   , 0                   , 0, 0x0000D9C8, 0),
  MAKE_INST(INST_FXRSTOR          , "fxrstor"          , G(M)             , F(FPU)           , 0                   , 0                   , 1, 0x00000FAE, 0),
  MAKE_INST(INST_FXSAVE           , "fxsave"           , G(M)             , F(FPU)           , 0                   , 0                   , 0, 0x00000FAE, 0),
  MAKE_INST(INST_FXTRACT          , "fxtract"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F4, 0),
  MAKE_INST(INST_FYL2X            , "fyl2x"            , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F1, 0),
  MAKE_INST(INST_FYL2XP1          , "fyl2xp1"          , G(EMIT)          , F(FPU)           , 0                   , 0                   , 0, 0x0000D9F9, 0),
  MAKE_INST(INST_HADDPD           , "haddpd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F7C, 0),
  MAKE_INST(INST_HADDPS           , "haddps"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F7C, 0),
  MAKE_INST(INST_HSUBPD           , "hsubpd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F7D, 0),
  MAKE_INST(INST_HSUBPS           , "hsubps"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F7D, 0),
  MAKE_INST(INST_IDIV             , "idiv"             , G(RM)            , F(SPECIAL)       , 0                   , 0                   , 7, 0x000000F6, 0),
  MAKE_INST(INST_IMUL             , "imul"             , G(IMUL)          , F(SPECIAL)       , 0                   , 0                   , 0, 0         , 0),
  MAKE_INST(INST_INC              , "inc"              , G(INC_DEC)       , F(LOCKABLE)      , O(GQDWB_MEM)        , 0                   , 0, 0x00000040, 0x000000FE),
  MAKE_INST(INST_INT3             , "int3"             , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000CC, 0),
  MAKE_INST(INST_JA               , "ja"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x7       , 0),
  MAKE_INST(INST_JAE              , "jae"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x3       , 0),
  MAKE_INST(INST_JB               , "jb"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x2       , 0),
  MAKE_INST(INST_JBE              , "jbe"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x6       , 0),
  MAKE_INST(INST_JC               , "jc"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x2       , 0),
  MAKE_INST(INST_JE               , "je"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x4       , 0),
  MAKE_INST(INST_JG               , "jg"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xF       , 0),
  MAKE_INST(INST_JGE              , "jge"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xD       , 0),
  MAKE_INST(INST_JL               , "jl"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xC       , 0),
  MAKE_INST(INST_JLE              , "jle"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xE       , 0),
  MAKE_INST(INST_JNA              , "jna"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x6       , 0),
  MAKE_INST(INST_JNAE             , "jnae"             , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x2       , 0),
  MAKE_INST(INST_JNB              , "jnb"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x3       , 0),
  MAKE_INST(INST_JNBE             , "jnbe"             , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x7       , 0),
  MAKE_INST(INST_JNC              , "jnc"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x3       , 0),
  MAKE_INST(INST_JNE              , "jne"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x5       , 0),
  MAKE_INST(INST_JNG              , "jng"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xE       , 0),
  MAKE_INST(INST_JNGE             , "jnge"             , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xC       , 0),
  MAKE_INST(INST_JNL              , "jnl"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xD       , 0),
  MAKE_INST(INST_JNLE             , "jnle"             , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xF       , 0),
  MAKE_INST(INST_JNO              , "jno"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x1       , 0),
  MAKE_INST(INST_JNP              , "jnp"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xB       , 0),
  MAKE_INST(INST_JNS              , "jns"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x9       , 0),
  MAKE_INST(INST_JNZ              , "jnz"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x5       , 0),
  MAKE_INST(INST_JO               , "jo"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x0       , 0),
  MAKE_INST(INST_JP               , "jp"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xA       , 0),
  MAKE_INST(INST_JPE              , "jpe"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xA       , 0),
  MAKE_INST(INST_JPO              , "jpo"              , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0xB       , 0),
  MAKE_INST(INST_JS               , "js"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x8       , 0),
  MAKE_INST(INST_JZ               , "jz"               , G(J)             , F(JUMP)          , 0                   , 0                   , 0, 0x4       , 0),
  MAKE_INST(INST_JMP              , "jmp"              , G(JMP)           , F(JUMP)          , 0                   , 0                   , 0, 0         , 0),
  MAKE_INST(INST_LDDQU            , "lddqu"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(MEM)              , 0, 0xF2000FF0, 0),
  MAKE_INST(INST_LDMXCSR          , "ldmxcsr"          , G(M)             , F(NONE)          , O(MEM)              , 0                   , 2, 0x00000FAE, 0),
  MAKE_INST(INST_LAHF             , "lahf"             , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009F, 0),
  MAKE_INST(INST_LEA              , "lea"              , G(LEA)           , F(NONE)          , O(GQD)              , O(MEM)              , 0, 0         , 0),
  MAKE_INST(INST_LEAVE            , "leave"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x000000C9, 0),
  MAKE_INST(INST_LFENCE           , "lfence"           , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000FAEE8, 0),
  MAKE_INST(INST_MASKMOVDQU       , "maskmovdqu"       , G(MMU_RMI)       , F(SPECIAL)       , O(XMM)              , O(XMM)              , 0, 0x66000F57, 0),
  MAKE_INST(INST_MASKMOVQ         , "maskmovq"         , G(MMU_RMI)       , F(SPECIAL)       , O(MM)               , O(MM)               , 0, 0x00000FF7, 0),
  MAKE_INST(INST_MAXPD            , "maxpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5F, 0),
  MAKE_INST(INST_MAXPS            , "maxps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5F, 0),
  MAKE_INST(INST_MAXSD            , "maxsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F5F, 0),
  MAKE_INST(INST_MAXSS            , "maxss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5F, 0),
  MAKE_INST(INST_MFENCE           , "mfence"           , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000FAEF0, 0),
  MAKE_INST(INST_MINPD            , "minpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5D, 0),
  MAKE_INST(INST_MINPS            , "minps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5D, 0),
  MAKE_INST(INST_MINSD            , "minsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F5D, 0),
  MAKE_INST(INST_MINSS            , "minss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5D, 0),
  MAKE_INST(INST_MONITOR          , "monitor"          , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x000F01C8, 0),
  MAKE_INST(INST_MOV              , "mov"              , G(MOV)           , F(MOV)           , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 0, 0         , 0),
  MAKE_INST(INST_MOVAPD           , "movapd"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x66000F28, 0x66000F29),
  MAKE_INST(INST_MOVAPS           , "movaps"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x00000F28, 0x00000F29),
  MAKE_INST(INST_MOVBE            , "movbe"            , G(MOVBE)         , F(MOV)           , O(GQDW)|O(MEM)      , O(GQDW)|O(MEM)      , 0, 0x000F38F0, 0x000F38F1),
  MAKE_INST(INST_MOVD             , "movd"             , G(MMU_MOVD)      , F(MOV)           , O(GD)|O(MM_XMM_MEM) , O(GD)|O(MM_XMM_MEM) , 0, 0         , 0),
  MAKE_INST(INST_MOVDDUP          , "movddup"          , G(MMU_MOV)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F12, 0),
  MAKE_INST(INST_MOVDQ2Q          , "movdq2q"          , G(MMU_MOV)       , F(MOV)           , O(MM)               , O(XMM)              , 0, 0xF2000FD6, 0),
  MAKE_INST(INST_MOVDQA           , "movdqa"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x66000F6F, 0x66000F7F),
  MAKE_INST(INST_MOVDQU           , "movdqu"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0xF3000F6F, 0xF3000F7F),
  MAKE_INST(INST_MOVHLPS          , "movhlps"          , G(MMU_MOV)       , F(NONE)          , O(XMM)              , O(XMM)              , 0, 0x00000F12, 0),
  MAKE_INST(INST_MOVHPD           , "movhpd"           , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x66000F16, 0x66000F17),
  MAKE_INST(INST_MOVHPS           , "movhps"           , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x00000F16, 0x00000F17),
  MAKE_INST(INST_MOVLHPS          , "movlhps"          , G(MMU_MOV)       , F(NONE)          , O(XMM)              , O(XMM)              , 0, 0x00000F16, 0),
  MAKE_INST(INST_MOVLPD           , "movlpd"           , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x66000F12, 0x66000F13),
  MAKE_INST(INST_MOVLPS           , "movlps"           , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x00000F12, 0x00000F13),
  MAKE_INST(INST_MOVMSKPD         , "movmskpd"         , G(MMU_MOV)       , F(MOV)           , O(GQD)|O(NOREX)     , O(XMM)              , 0, 0x66000F50, 0),
  MAKE_INST(INST_MOVMSKPS         , "movmskps"         , G(MMU_MOV)       , F(MOV)           , O(GQD)|O(NOREX)     , O(XMM)              , 0, 0x00000F50, 0),
  MAKE_INST(INST_MOVNTDQ          , "movntdq"          , G(MMU_MOV)       , F(NONE)          , O(MEM)              , O(XMM)              , 0, 0         , 0x66000FE7),
  MAKE_INST(INST_MOVNTDQA         , "movntdqa"         , G(MMU_MOV)       , F(MOV)           , O(XMM)              , O(MEM)              , 0, 0x660F382A, 0),
  MAKE_INST(INST_MOVNTI           , "movnti"           , G(MMU_MOV)       , F(MOV)           , O(MEM)              , O(GQD)              , 0, 0         , 0x00000FC3),
  MAKE_INST(INST_MOVNTPD          , "movntpd"          , G(MMU_MOV)       , F(NONE)          , O(MEM)              , O(XMM)              , 0, 0         , 0x66000F2B),
  MAKE_INST(INST_MOVNTPS          , "movntps"          , G(MMU_MOV)       , F(NONE)          , O(MEM)              , O(XMM)              , 0, 0         , 0x00000F2B),
  MAKE_INST(INST_MOVNTQ           , "movntq"           , G(MMU_MOV)       , F(NONE)          , O(MEM)              , O(MM)               , 0, 0         , 0x00000FE7),
  MAKE_INST(INST_MOVQ             , "movq"             , G(MMU_MOVQ)      , F(MOV)           , O(GQ)|O(MM_XMM_MEM) , O(GQ)|O(MM_XMM_MEM) , 0, 0         , 0),
  MAKE_INST(INST_MOVQ2DQ          , "movq2dq"          , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(MM)               , 0, 0xF3000FD6, 0),
  MAKE_INST(INST_MOVSD            , "movsd"            , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0xF2000F10, 0xF2000F11),
  MAKE_INST(INST_MOVSHDUP         , "movshdup"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F16, 0),
  MAKE_INST(INST_MOVSLDUP         , "movsldup"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F12, 0),
  MAKE_INST(INST_MOVSS            , "movss"            , G(MMU_MOV)       , F(NONE)          , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0xF3000F10, 0xF3000F11),
  MAKE_INST(INST_MOVSX            , "movsx"            , G(MOVSX_MOVZX)   , F(NONE)          , O(GQDW)             , O(GWB_MEM)          , 0, 0x00000FBE, 0),
  MAKE_INST(INST_MOVSXD           , "movsxd"           , G(MOVSXD)        , F(NONE)          , O(GQ)               , O(GD_MEM)           , 0, 0         , 0),
  MAKE_INST(INST_MOVUPD           , "movupd"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x66000F10, 0x66000F11),
  MAKE_INST(INST_MOVUPS           , "movups"           , G(MMU_MOV)       , F(MOV)           , O(XMM_MEM)          , O(XMM_MEM)          , 0, 0x00000F10, 0x00000F11),
  MAKE_INST(INST_MOVZX            , "movzx"            , G(MOVSX_MOVZX)   , F(MOV)           , O(GQDW)             , O(GWB_MEM)          , 0, 0x00000FB6, 0),
  MAKE_INST(INST_MOV_PTR          , "mov_ptr"          , G(MOV_PTR)       , F(MOV)|F(SPECIAL), O(GQDWB)            , O(IMM)              , 0, 0         , 0),
  MAKE_INST(INST_MPSADBW          , "mpsadbw"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A42, 0),
  MAKE_INST(INST_MUL              , "mul"              , G(RM)            , F(SPECIAL)       , 0                   , 0                   , 4, 0x000000F6, 0),
  MAKE_INST(INST_MULPD            , "mulpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F59, 0),
  MAKE_INST(INST_MULPS            , "mulps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F59, 0),
  MAKE_INST(INST_MULSD            , "mulsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F59, 0),
  MAKE_INST(INST_MULSS            , "mulss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F59, 0),
  MAKE_INST(INST_MWAIT            , "mwait"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x000F01C9, 0),
  MAKE_INST(INST_NEG              , "neg"              , G(RM)            , F(LOCKABLE)      , O(GQDWB_MEM)        , 0                   , 3, 0x000000F6, 0),
  MAKE_INST(INST_NOP              , "nop"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x00000090, 0),
  MAKE_INST(INST_NOT              , "not"              , G(RM)            , F(LOCKABLE)      , O(GQDWB_MEM)        , 0                   , 2, 0x000000F6, 0),
  MAKE_INST(INST_OR               , "or"               , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 1, 0x00000008, 0x00000080),
  MAKE_INST(INST_ORPD             , "orpd"             , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F56, 0),
  MAKE_INST(INST_ORPS             , "orps"             , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F56, 0),
  MAKE_INST(INST_PABSB            , "pabsb"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F381C, 0),
  MAKE_INST(INST_PABSD            , "pabsd"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F381E, 0),
  MAKE_INST(INST_PABSW            , "pabsw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F381D, 0),
  MAKE_INST(INST_PACKSSDW         , "packssdw"         , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F6B, 0),
  MAKE_INST(INST_PACKSSWB         , "packsswb"         , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F63, 0),
  MAKE_INST(INST_PACKUSDW         , "packusdw"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F382B, 0),
  MAKE_INST(INST_PACKUSWB         , "packuswb"         , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F67, 0),
  MAKE_INST(INST_PADDB            , "paddb"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FFC, 0),
  MAKE_INST(INST_PADDD            , "paddd"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FFE, 0),
  MAKE_INST(INST_PADDQ            , "paddq"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FD4, 0),
  MAKE_INST(INST_PADDSB           , "paddsb"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FEC, 0),
  MAKE_INST(INST_PADDSW           , "paddsw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FED, 0),
  MAKE_INST(INST_PADDUSB          , "paddusb"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDC, 0),
  MAKE_INST(INST_PADDUSW          , "paddusw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDD, 0),
  MAKE_INST(INST_PADDW            , "paddw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FFD, 0),
  MAKE_INST(INST_PALIGNR          , "palignr"          , G(MMU_RM_IMM8)   , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3A0F, 0),
  MAKE_INST(INST_PAND             , "pand"             , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDB, 0),
  MAKE_INST(INST_PANDN            , "pandn"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDF, 0),
  MAKE_INST(INST_PAUSE            , "pause"            , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0xF3000090, 0),
  MAKE_INST(INST_PAVGB            , "pavgb"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE0, 0),
  MAKE_INST(INST_PAVGW            , "pavgw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE3, 0),
  MAKE_INST(INST_PBLENDVB         , "pblendvb"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3810, 0),
  MAKE_INST(INST_PBLENDW          , "pblendw"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A0E, 0),
  MAKE_INST(INST_PCMPEQB          , "pcmpeqb"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F74, 0),
  MAKE_INST(INST_PCMPEQD          , "pcmpeqd"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F76, 0),
  MAKE_INST(INST_PCMPEQQ          , "pcmpeqq"          , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3829, 0),
  MAKE_INST(INST_PCMPEQW          , "pcmpeqw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F75, 0),
  MAKE_INST(INST_PCMPESTRI        , "pcmpestri"        , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A61, 0),
  MAKE_INST(INST_PCMPESTRM        , "pcmpestrm"        , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A60, 0),
  MAKE_INST(INST_PCMPGTB          , "pcmpgtb"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F64, 0),
  MAKE_INST(INST_PCMPGTD          , "pcmpgtd"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F66, 0),
  MAKE_INST(INST_PCMPGTQ          , "pcmpgtq"          , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3837, 0),
  MAKE_INST(INST_PCMPGTW          , "pcmpgtw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F65, 0),
  MAKE_INST(INST_PCMPISTRI        , "pcmpistri"        , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A63, 0),
  MAKE_INST(INST_PCMPISTRM        , "pcmpistrm"        , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A62, 0),
  MAKE_INST(INST_PEXTRB           , "pextrb"           , G(MMU_PEXTR)     , F(NONE)          , O(GD)|O(GB)|O(MEM)  , O(XMM)              , 0, 0x000F3A14, 0),
  MAKE_INST(INST_PEXTRD           , "pextrd"           , G(MMU_PEXTR)     , F(NONE)          , O(GD)      |O(MEM)  , O(XMM)              , 0, 0x000F3A16, 0),
  MAKE_INST(INST_PEXTRQ           , "pextrq"           , G(MMU_PEXTR)     , F(NONE)          , O(GQD)     |O(MEM)  , O(XMM)              , 1, 0x000F3A16, 0),
  MAKE_INST(INST_PEXTRW           , "pextrw"           , G(MMU_PEXTR)     , F(NONE)          , O(GD)      |O(MEM)  , O(XMM) | O(MM)      , 0, 0x000F3A15, 0),
  MAKE_INST(INST_PF2ID            , "pf2id"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x1D),
  MAKE_INST(INST_PF2IW            , "pf2iw"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x1C),
  MAKE_INST(INST_PFACC            , "pfacc"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xAE),
  MAKE_INST(INST_PFADD            , "pfadd"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x9E),
  MAKE_INST(INST_PFCMPEQ          , "pfcmpeq"          , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xB0),
  MAKE_INST(INST_PFCMPGE          , "pfcmpge"          , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x90),
  MAKE_INST(INST_PFCMPGT          , "pfcmpgt"          , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xA0),
  MAKE_INST(INST_PFMAX            , "pfmax"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xA4),
  MAKE_INST(INST_PFMIN            , "pfmin"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x94),
  MAKE_INST(INST_PFMUL            , "pfmul"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xB4),
  MAKE_INST(INST_PFNACC           , "pfnacc"           , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x8A),
  MAKE_INST(INST_PFPNACC          , "pfpnacc"          , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x8E),
  MAKE_INST(INST_PFRCP            , "pfrcp"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x96),
  MAKE_INST(INST_PFRCPIT1         , "pfrcpit1"         , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xA6),
  MAKE_INST(INST_PFRCPIT2         , "pfrcpit2"         , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xB6),
  MAKE_INST(INST_PFRSQIT1         , "pfrsqit1"         , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xA7),
  MAKE_INST(INST_PFRSQRT          , "pfrsqrt"          , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x97),
  MAKE_INST(INST_PFSUB            , "pfsub"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x9A),
  MAKE_INST(INST_PFSUBR           , "pfsubr"           , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xAA),
  MAKE_INST(INST_PHADDD           , "phaddd"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3802, 0),
  MAKE_INST(INST_PHADDSW          , "phaddsw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3803, 0),
  MAKE_INST(INST_PHADDW           , "phaddw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3801, 0),
  MAKE_INST(INST_PHMINPOSUW       , "phminposuw"       , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3841, 0),
  MAKE_INST(INST_PHSUBD           , "phsubd"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3806, 0),
  MAKE_INST(INST_PHSUBSW          , "phsubsw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3807, 0),
  MAKE_INST(INST_PHSUBW           , "phsubw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3805, 0),
  MAKE_INST(INST_PI2FD            , "pi2fd"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x0D),
  MAKE_INST(INST_PI2FW            , "pi2fw"            , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0x0C),
  MAKE_INST(INST_PINSRB           , "pinsrb"           , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(GD) | O(MEM)      , 0, 0x660F3A20, 0),
  MAKE_INST(INST_PINSRD           , "pinsrd"           , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(GD) | O(MEM)      , 0, 0x660F3A22, 0),
  MAKE_INST(INST_PINSRQ           , "pinsrq"           , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(GQ) | O(MEM)      , 0, 0x660F3A22, 0),
  MAKE_INST(INST_PINSRW           , "pinsrw"           , G(MMU_RM_IMM8)   , F(NONE)          , O(MM_XMM)           , O(GD) | O(MEM)      , 0, 0x00000FC4, 0),
  MAKE_INST(INST_PMADDUBSW        , "pmaddubsw"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3804, 0),
  MAKE_INST(INST_PMADDWD          , "pmaddwd"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FF5, 0),
  MAKE_INST(INST_PMAXSB           , "pmaxsb"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383C, 0),
  MAKE_INST(INST_PMAXSD           , "pmaxsd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383D, 0),
  MAKE_INST(INST_PMAXSW           , "pmaxsw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FEE, 0),
  MAKE_INST(INST_PMAXUB           , "pmaxub"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDE, 0),
  MAKE_INST(INST_PMAXUD           , "pmaxud"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383F, 0),
  MAKE_INST(INST_PMAXUW           , "pmaxuw"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383E, 0),
  MAKE_INST(INST_PMINSB           , "pminsb"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3838, 0),
  MAKE_INST(INST_PMINSD           , "pminsd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3839, 0),
  MAKE_INST(INST_PMINSW           , "pminsw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FEA, 0),
  MAKE_INST(INST_PMINUB           , "pminub"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FDA, 0),
  MAKE_INST(INST_PMINUD           , "pminud"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383B, 0),
  MAKE_INST(INST_PMINUW           , "pminuw"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F383A, 0),
  MAKE_INST(INST_PMOVMSKB         , "pmovmskb"         , G(MMU_RMI)       , F(MOV)           , O(GQD)              , O(MM_XMM)           , 0, 0x00000FD7, 0),
  MAKE_INST(INST_PMOVSXBD         , "pmovsxbd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3821, 0),
  MAKE_INST(INST_PMOVSXBQ         , "pmovsxbq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3822, 0),
  MAKE_INST(INST_PMOVSXBW         , "pmovsxbw"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3820, 0),
  MAKE_INST(INST_PMOVSXDQ         , "pmovsxdq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3825, 0),
  MAKE_INST(INST_PMOVSXWD         , "pmovsxwd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3823, 0),
  MAKE_INST(INST_PMOVSXWQ         , "pmovsxwq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3824, 0),
  MAKE_INST(INST_PMOVZXBD         , "pmovzxbd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3831, 0),
  MAKE_INST(INST_PMOVZXBQ         , "pmovzxbq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3832, 0),
  MAKE_INST(INST_PMOVZXBW         , "pmovzxbw"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3830, 0),
  MAKE_INST(INST_PMOVZXDQ         , "pmovzxdq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3835, 0),
  MAKE_INST(INST_PMOVZXWD         , "pmovzxwd"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3833, 0),
  MAKE_INST(INST_PMOVZXWQ         , "pmovzxwq"         , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3834, 0),
  MAKE_INST(INST_PMULDQ           , "pmuldq"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3828, 0),
  MAKE_INST(INST_PMULHRSW         , "pmulhrsw"         , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F380B, 0),
  MAKE_INST(INST_PMULHUW          , "pmulhuw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE4, 0),
  MAKE_INST(INST_PMULHW           , "pmulhw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE5, 0),
  MAKE_INST(INST_PMULLD           , "pmulld"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3840, 0),
  MAKE_INST(INST_PMULLW           , "pmullw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FD5, 0),
  MAKE_INST(INST_PMULUDQ          , "pmuludq"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FF4, 0),
  MAKE_INST(INST_POP              , "pop"              , G(POP)           , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000058, 0x0000008F),
  MAKE_INST(INST_POPAD            , "popad"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000061, 0),
  MAKE_INST(INST_POPCNT           , "popcnt"           , G(R_RM)          , F(NONE)          , O(GQDW)             , O(GQDW_MEM)         , 0, 0xF3000FB8, 0),
  MAKE_INST(INST_POPFD            , "popfd"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009D, 0),
  MAKE_INST(INST_POPFQ            , "popfq"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009D, 0),
  MAKE_INST(INST_POR              , "por"              , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FEB, 0),
  MAKE_INST(INST_PREFETCH         , "prefetch"         , G(MMU_PREFETCH)  , F(NONE)          , O(MEM)              , O(IMM)              , 0, 0         , 0),
  MAKE_INST(INST_PSADBW           , "psadbw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FF6, 0),
  MAKE_INST(INST_PSHUFB           , "pshufb"           , G(MMU_RMI)       , F(MOV)           , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3800, 0),
  MAKE_INST(INST_PSHUFD           , "pshufd"           , G(MMU_RM_IMM8)   , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F70, 0),
  MAKE_INST(INST_PSHUFW           , "pshufw"           , G(MMU_RM_IMM8)   , F(MOV)           , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F70, 0),
  MAKE_INST(INST_PSHUFHW          , "pshufhw"          , G(MMU_RM_IMM8)   , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F70, 0),
  MAKE_INST(INST_PSHUFLW          , "pshuflw"          , G(MMU_RM_IMM8)   , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F70, 0),
  MAKE_INST(INST_PSIGNB           , "psignb"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3808, 0),
  MAKE_INST(INST_PSIGND           , "psignd"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F380A, 0),
  MAKE_INST(INST_PSIGNW           , "psignw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x000F3809, 0),
  MAKE_INST(INST_PSLLD            , "pslld"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 6, 0x00000FF2, 0x00000F72),
  MAKE_INST(INST_PSLLDQ           , "pslldq"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(IMM)              , 7, 0         , 0x66000F73),
  MAKE_INST(INST_PSLLQ            , "psllq"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 6, 0x00000FF3, 0x00000F73),
  MAKE_INST(INST_PSLLW            , "psllw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 6, 0x00000FF1, 0x00000F71),
  MAKE_INST(INST_PSRAD            , "psrad"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 4, 0x00000FE2, 0x00000F72),
  MAKE_INST(INST_PSRAW            , "psraw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 4, 0x00000FE1, 0x00000F71),
  MAKE_INST(INST_PSRLD            , "psrld"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 2, 0x00000FD2, 0x00000F72),
  MAKE_INST(INST_PSRLDQ           , "psrldq"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(IMM)              , 3, 0         , 0x66000F73),
  MAKE_INST(INST_PSRLQ            , "psrlq"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 2, 0x00000FD3, 0x00000F73),
  MAKE_INST(INST_PSRLW            , "psrlw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)|O(IMM), 2, 0x00000FD1, 0x00000F71),
  MAKE_INST(INST_PSUBB            , "psubb"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FF8, 0),
  MAKE_INST(INST_PSUBD            , "psubd"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FFA, 0),
  MAKE_INST(INST_PSUBQ            , "psubq"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FFB, 0),
  MAKE_INST(INST_PSUBSB           , "psubsb"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE8, 0),
  MAKE_INST(INST_PSUBSW           , "psubsw"           , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FE9, 0),
  MAKE_INST(INST_PSUBUSB          , "psubusb"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FD8, 0),
  MAKE_INST(INST_PSUBUSW          , "psubusw"          , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FD9, 0),
  MAKE_INST(INST_PSUBW            , "psubw"            , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FF9, 0),
  MAKE_INST(INST_PSWAPD           , "pswapd"           , G(MMU_RM_3DNOW)  , F(NONE)          , O(MM)               , O(MM_MEM)           , 0, 0x00000F0F, 0xBB),
  MAKE_INST(INST_PTEST            , "ptest"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3817, 0),
  MAKE_INST(INST_PUNPCKHBW        , "punpckhbw"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F68, 0),
  MAKE_INST(INST_PUNPCKHDQ        , "punpckhdq"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F6A, 0),
  MAKE_INST(INST_PUNPCKHQDQ       , "punpckhqdq"       , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F6D, 0),
  MAKE_INST(INST_PUNPCKHWD        , "punpckhwd"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F69, 0),
  MAKE_INST(INST_PUNPCKLBW        , "punpcklbw"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F60, 0),
  MAKE_INST(INST_PUNPCKLDQ        , "punpckldq"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F62, 0),
  MAKE_INST(INST_PUNPCKLQDQ       , "punpcklqdq"       , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F6C, 0),
  MAKE_INST(INST_PUNPCKLWD        , "punpcklwd"        , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000F61, 0),
  MAKE_INST(INST_PUSH             , "push"             , G(PUSH)          , F(SPECIAL)       , 0                   , 0                   , 6, 0x00000050, 0x000000FF),
  MAKE_INST(INST_PUSHAD           , "pushad"           , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000060, 0),
  MAKE_INST(INST_PUSHFD           , "pushfd"           , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009C, 0),
  MAKE_INST(INST_PUSHFQ           , "pushfq"           , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009C, 0),
  MAKE_INST(INST_PXOR             , "pxor"             , G(MMU_RMI)       , F(NONE)          , O(MM_XMM)           , O(MM_XMM_MEM)       , 0, 0x00000FEF, 0),
  MAKE_INST(INST_RCL              , "rcl"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 2, 0         , 0),
  MAKE_INST(INST_RCPPS            , "rcpps"            , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F53, 0),
  MAKE_INST(INST_RCPSS            , "rcpss"            , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F53, 0),
  MAKE_INST(INST_RCR              , "rcr"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 3, 0         , 0),
  MAKE_INST(INST_RDTSC            , "rdtsc"            , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x00000F31, 0),
  MAKE_INST(INST_RDTSCP           , "rdtscp"           , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x000F01F9, 0),
  MAKE_INST(INST_REP_LODSB        , "rep lodsb"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AC, 1 /* Size of mem */),
  MAKE_INST(INST_REP_LODSD        , "rep lodsd"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AC, 4 /* Size of mem */),
  MAKE_INST(INST_REP_LODSQ        , "rep lodsq"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AC, 8 /* Size of mem */),
  MAKE_INST(INST_REP_LODSW        , "rep lodsw"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AC, 2 /* Size of mem */),
  MAKE_INST(INST_REP_MOVSB        , "rep movsb"        , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A4, 1 /* Size of mem */),
  MAKE_INST(INST_REP_MOVSD        , "rep movsd"        , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A4, 4 /* Size of mem */),
  MAKE_INST(INST_REP_MOVSQ        , "rep movsq"        , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A4, 8 /* Size of mem */),
  MAKE_INST(INST_REP_MOVSW        , "rep movsw"        , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A4, 2 /* Size of mem */),
  MAKE_INST(INST_REP_STOSB        , "rep stosb"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AA, 1 /* Size of mem */),
  MAKE_INST(INST_REP_STOSD        , "rep stosd"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AA, 4 /* Size of mem */),
  MAKE_INST(INST_REP_STOSQ        , "rep stosq"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AA, 8 /* Size of mem */),
  MAKE_INST(INST_REP_STOSW        , "rep stosw"        , G(REP)           , F(SPECIAL)       , O(MEM)              , 0                   , 0, 0xF30000AA, 2 /* Size of mem */),
  MAKE_INST(INST_REPE_CMPSB       , "repe cmpsb"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A6, 1 /* Size of mem */),
  MAKE_INST(INST_REPE_CMPSD       , "repe cmpsd"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A6, 4 /* Size of mem */),
  MAKE_INST(INST_REPE_CMPSQ       , "repe cmpsq"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A6, 8 /* Size of mem */),
  MAKE_INST(INST_REPE_CMPSW       , "repe cmpsw"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000A6, 2 /* Size of mem */),
  MAKE_INST(INST_REPE_SCASB       , "repe scasb"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000AE, 1 /* Size of mem */),
  MAKE_INST(INST_REPE_SCASD       , "repe scasd"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000AE, 4 /* Size of mem */),
  MAKE_INST(INST_REPE_SCASQ       , "repe scasq"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000AE, 8 /* Size of mem */),
  MAKE_INST(INST_REPE_SCASW       , "repe scasw"       , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF30000AE, 2 /* Size of mem */),
  MAKE_INST(INST_REPNE_CMPSB      , "repne cmpsb"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000A6, 1 /* Size of mem */),
  MAKE_INST(INST_REPNE_CMPSD      , "repne cmpsd"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000A6, 4 /* Size of mem */),
  MAKE_INST(INST_REPNE_CMPSQ      , "repne cmpsq"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000A6, 8 /* Size of mem */),
  MAKE_INST(INST_REPNE_CMPSW      , "repne cmpsw"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000A6, 2 /* Size of mem */),
  MAKE_INST(INST_REPNE_SCASB      , "repne scasb"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000AE, 1 /* Size of mem */),
  MAKE_INST(INST_REPNE_SCASD      , "repne scasd"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000AE, 4 /* Size of mem */),
  MAKE_INST(INST_REPNE_SCASQ      , "repne scasq"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000AE, 8 /* Size of mem */),
  MAKE_INST(INST_REPNE_SCASW      , "repne scasw"      , G(REP)           , F(SPECIAL)       , O(MEM)              , O(MEM)              , 0, 0xF20000AE, 2 /* Size of mem */),
  MAKE_INST(INST_RET              , "ret"              , G(RET)           , F(SPECIAL)       , 0                   , 0                   , 0, 0         , 0),
  MAKE_INST(INST_ROL              , "rol"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 0, 0         , 0),
  MAKE_INST(INST_ROR              , "ror"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 1, 0         , 0),
  MAKE_INST(INST_ROUNDPD          , "roundpd"          , G(MMU_RM_IMM8)   , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A09, 0),
  MAKE_INST(INST_ROUNDPS          , "roundps"          , G(MMU_RM_IMM8)   , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A08, 0),
  MAKE_INST(INST_ROUNDSD          , "roundsd"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A0B, 0),
  MAKE_INST(INST_ROUNDSS          , "roundss"          , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x660F3A0A, 0),
  MAKE_INST(INST_RSQRTPS          , "rsqrtps"          , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F52, 0),
  MAKE_INST(INST_RSQRTSS          , "rsqrtss"          , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F52, 0),
  MAKE_INST(INST_SAHF             , "sahf"             , G(EMIT)          , F(SPECIAL)       , 0                   , 0                   , 0, 0x0000009E, 0),
  MAKE_INST(INST_SAL              , "sal"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 4, 0         , 0),
  MAKE_INST(INST_SAR              , "sar"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 7, 0         , 0),
  MAKE_INST(INST_SBB              , "sbb"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 3, 0x00000018, 0x00000080),
  MAKE_INST(INST_SETA             , "seta"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F97, 0),
  MAKE_INST(INST_SETAE            , "setae"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F93, 0),
  MAKE_INST(INST_SETB             , "setb"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F92, 0),
  MAKE_INST(INST_SETBE            , "setbe"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F96, 0),
  MAKE_INST(INST_SETC             , "setc"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F92, 0),
  MAKE_INST(INST_SETE             , "sete"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F94, 0),
  MAKE_INST(INST_SETG             , "setg"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9F, 0),
  MAKE_INST(INST_SETGE            , "setge"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9D, 0),
  MAKE_INST(INST_SETL             , "setl"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9C, 0),
  MAKE_INST(INST_SETLE            , "setle"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9E, 0),
  MAKE_INST(INST_SETNA            , "setna"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F96, 0),
  MAKE_INST(INST_SETNAE           , "setnae"           , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F92, 0),
  MAKE_INST(INST_SETNB            , "setnb"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F93, 0),
  MAKE_INST(INST_SETNBE           , "setnbe"           , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F97, 0),
  MAKE_INST(INST_SETNC            , "setnc"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F93, 0),
  MAKE_INST(INST_SETNE            , "setne"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F95, 0),
  MAKE_INST(INST_SETNG            , "setng"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9E, 0),
  MAKE_INST(INST_SETNGE           , "setnge"           , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9C, 0),
  MAKE_INST(INST_SETNL            , "setnl"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9D, 0),
  MAKE_INST(INST_SETNLE           , "setnle"           , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9F, 0),
  MAKE_INST(INST_SETNO            , "setno"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F91, 0),
  MAKE_INST(INST_SETNP            , "setnp"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9B, 0),
  MAKE_INST(INST_SETNS            , "setns"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F99, 0),
  MAKE_INST(INST_SETNZ            , "setnz"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F95, 0),
  MAKE_INST(INST_SETO             , "seto"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F90, 0),
  MAKE_INST(INST_SETP             , "setp"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9A, 0),
  MAKE_INST(INST_SETPE            , "setpe"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9A, 0),
  MAKE_INST(INST_SETPO            , "setpo"            , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F9B, 0),
  MAKE_INST(INST_SETS             , "sets"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F98, 0),
  MAKE_INST(INST_SETZ             , "setz"             , G(RM_B)          , F(NONE)          , O(GB_MEM)           , 0                   , 0, 0x00000F94, 0),
  MAKE_INST(INST_SFENCE           , "sfence"           , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000FAEF8, 0),
  MAKE_INST(INST_SHL              , "shl"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 4, 0         , 0),
  MAKE_INST(INST_SHLD             , "shld"             , G(SHLD_SHRD)     , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)               , 0, 0x00000FA4, 0),
  MAKE_INST(INST_SHR              , "shr"              , G(ROT)           , F(SPECIAL)       , O(GQDWB_MEM)        , O(GB)|O(IMM)        , 5, 0         , 0),
  MAKE_INST(INST_SHRD             , "shrd"             , G(SHLD_SHRD)     , F(SPECIAL)       , O(GQDWB_MEM)        , O(GQDWB)            , 0, 0x00000FAC, 0),
  MAKE_INST(INST_SHUFPD           , "shufpd"           , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000FC6, 0),
  MAKE_INST(INST_SHUFPS           , "shufps"           , G(MMU_RM_IMM8)   , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000FC6, 0),
  MAKE_INST(INST_SQRTPD           , "sqrtpd"           , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F51, 0),
  MAKE_INST(INST_SQRTPS           , "sqrtps"           , G(MMU_RMI)       , F(MOV)           , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F51, 0),
  MAKE_INST(INST_SQRTSD           , "sqrtsd"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F51, 0),
  MAKE_INST(INST_SQRTSS           , "sqrtss"           , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F51, 0),
  MAKE_INST(INST_STC              , "stc"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000F9, 0),
  MAKE_INST(INST_STD              , "std"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x000000FD, 0),
  MAKE_INST(INST_STMXCSR          , "stmxcsr"          , G(M)             , F(NONE)          , O(MEM)              , 0                   , 3, 0x00000FAE, 0),
  MAKE_INST(INST_SUB              , "sub"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 5, 0x00000028, 0x00000080),
  MAKE_INST(INST_SUBPD            , "subpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F5C, 0),
  MAKE_INST(INST_SUBPS            , "subps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F5C, 0),
  MAKE_INST(INST_SUBSD            , "subsd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF2000F5C, 0),
  MAKE_INST(INST_SUBSS            , "subss"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0xF3000F5C, 0),
  MAKE_INST(INST_TEST             , "test"             , G(TEST)          , F(NONE)          , O(GQDWB_MEM)        , O(GQDWB)|O(IMM)     , 0, 0         , 0),
  MAKE_INST(INST_UCOMISD          , "ucomisd"          , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F2E, 0),
  MAKE_INST(INST_UCOMISS          , "ucomiss"          , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F2E, 0),
  MAKE_INST(INST_UD2              , "ud2"              , G(EMIT)          , F(NONE)          , 0                   , 0                   , 0, 0x00000F0B, 0),
  MAKE_INST(INST_UNPCKHPD         , "unpckhpd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F15, 0),
  MAKE_INST(INST_UNPCKHPS         , "unpckhps"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F15, 0),
  MAKE_INST(INST_UNPCKLPD         , "unpcklpd"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F14, 0),
  MAKE_INST(INST_UNPCKLPS         , "unpcklps"         , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F14, 0),
  MAKE_INST(INST_XADD             , "xadd"             , G(RM_R)          , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB)            , 0, 0x00000FC0, 0),
  MAKE_INST(INST_XCHG             , "xchg"             , G(XCHG)          , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB)            , 0, 0         , 0),
  MAKE_INST(INST_XOR              , "xor"              , G(ALU)           , F(LOCKABLE)      , O(GQDWB_MEM)        , O(GQDWB_MEM)|O(IMM) , 6, 0x00000030, 0x00000080),
  MAKE_INST(INST_XORPD            , "xorpd"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x66000F57, 0),
  MAKE_INST(INST_XORPS            , "xorps"            , G(MMU_RMI)       , F(NONE)          , O(XMM)              , O(XMM_MEM)          , 0, 0x00000F57, 0)
};

#undef G
#undef F
#undef O

#undef MAKE_INST

} // AsmJit namespace

#include "ApiEnd.h"

```

`AsmJit/DefsX86X64.h`:

```h

#ifndef _ASMJIT_DEFSX86X64_H
#define _ASMJIT_DEFSX86X64_H

#if !defined(_ASMJIT_DEFS_H)
#warning "AsmJit/DefsX86X64.h can be only included by AsmJit/Defs.h"
#endif

#include "Build.h"
#include "Util.h"

#include <stdlib.h>
#include <string.h>

#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

// ============================================================================
// [AsmJit::REG_NUM]
// ============================================================================

//! @var REG_NUM
//! @brief Count of General purpose registers and XMM registers.
//!
//! Count of general purpose registers and XMM registers depends on current
//! bit-mode. If application is compiled for 32-bit platform then this number
//! is 8, 64-bit platforms have 8 extra general purpose and xmm registers (16
//! total).

//! @brief Count of registers.
enum REG_NUM
{
  //! @var REG_NUM_BASE
  //!
  //! Count of general purpose registers and XMM registers depends on current
  //! bit-mode. If application is compiled for 32-bit platform then this number
  //! is 8, 64-bit platforms have 8 extra general purpose and XMM registers (16
  //! total).
#if defined(ASMJIT_X86)
  REG_NUM_BASE = 8,
#else
  REG_NUM_BASE = 16,
#endif

  //! @brief Count of general purpose registers.
  //!
  //! 8 in 32-bit mode and 16 in 64-bit mode.
  REG_NUM_GP = REG_NUM_BASE,

  //! @brief Count of MM registers (always 8).
  REG_NUM_MM = 8,

  //! @brief Count of FPU stack registers (always 8).
  REG_NUM_FPU = 8,
  
  //! @brief Count of XMM registers.
  //!
  //! 8 in 32-bit mode and 16 in 64-bit mode.
  REG_NUM_XMM = REG_NUM_BASE,

  //! @brief Count of segment registers, including no segment (AsmJit specific).
  //!
  //! @note There are 6 segment registers, but AsmJit uses 0 as no segment, and
  //! 1...6 as segment registers, this means that there are 7 segment registers
  //! in AsmJit API, but only 6 can be used through @c Assembler or @c Compiler
  //! API.
  REG_NUM_SEGMENT = 7
};

// ============================================================================
// [AsmJit::REG_INDEX]
// ============================================================================

//! @brief Valid X86 register indexes.
//!
//! These codes are real, don't miss with @c REG enum! and don't use these
//! values if you are not writing AsmJit code.
enum REG_INDEX
{
  //! @brief Mask for register code (index).
  REG_INDEX_MASK = 0x00FF,

  //! @brief ID for AX/EAX/RAX registers.
  REG_INDEX_EAX = 0,
  //! @brief ID for CX/ECX/RCX registers.
  REG_INDEX_ECX = 1,
  //! @brief ID for DX/EDX/RDX registers.
  REG_INDEX_EDX = 2,
  //! @brief ID for BX/EBX/RBX registers.
  REG_INDEX_EBX = 3,
  //! @brief ID for SP/ESP/RSP registers.
  REG_INDEX_ESP = 4,
  //! @brief ID for BP/EBP/RBP registers.
  REG_INDEX_EBP = 5,
  //! @brief ID for SI/ESI/RSI registers.
  REG_INDEX_ESI = 6,
  //! @brief ID for DI/EDI/RDI registers.
  REG_INDEX_EDI = 7,

#if defined(ASMJIT_X64)
  //! @brief ID for AX/EAX/RAX registers.
  REG_INDEX_RAX = 0,
  //! @brief ID for CX/ECX/RCX registers.
  REG_INDEX_RCX = 1,
  //! @brief ID for DX/EDX/RDX registers.
  REG_INDEX_RDX = 2,
  //! @brief ID for BX/EBX/RBX registers.
  REG_INDEX_RBX = 3,
  //! @brief ID for SP/ESP/RSP registers.
  REG_INDEX_RSP = 4,
  //! @brief ID for BP/EBP/RBP registers.
  REG_INDEX_RBP = 5,
  //! @brief ID for SI/ESI/RSI registers.
  REG_INDEX_RSI = 6,
  //! @brief ID for DI/EDI/RDI registers.
  REG_INDEX_RDI = 7,

  //! @brief ID for r8 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R8 = 8,
  //! @brief ID for R9 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R9 = 9,
  //! @brief ID for R10 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R10 = 10,
  //! @brief ID for R11 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R11 = 11,
  //! @brief ID for R12 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R12 = 12,
  //! @brief ID for R13 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R13 = 13,
  //! @brief ID for R14 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R14 = 14,
  //! @brief ID for R15 register (additional register introduced by 64-bit architecture).
  REG_INDEX_R15 = 15,
#endif // ASMJIT_X64

  //! @brief ID for mm0 register.
  REG_INDEX_MM0 = 0,
  //! @brief ID for mm1 register.
  REG_INDEX_MM1 = 1,
  //! @brief ID for mm2 register.
  REG_INDEX_MM2 = 2,
  //! @brief ID for mm3 register.
  REG_INDEX_MM3 = 3,
  //! @brief ID for mm4 register.
  REG_INDEX_MM4 = 4,
  //! @brief ID for mm5 register.
  REG_INDEX_MM5 = 5,
  //! @brief ID for mm6 register.
  REG_INDEX_MM6 = 6,
  //! @brief ID for mm7 register.
  REG_INDEX_MM7 = 7,

  //! @brief ID for xmm0 register.
  REG_INDEX_XMM0 = 0,
  //! @brief ID for xmm1 register.
  REG_INDEX_XMM1 = 1,
  //! @brief ID for xmm2 register.
  REG_INDEX_XMM2 = 2,
  //! @brief ID for xmm3 register.
  REG_INDEX_XMM3 = 3,
  //! @brief ID for xmm4 register.
  REG_INDEX_XMM4 = 4,
  //! @brief ID for xmm5 register.
  REG_INDEX_XMM5 = 5,
  //! @brief ID for xmm6 register.
  REG_INDEX_XMM6 = 6,
  //! @brief ID for xmm7 register.
  REG_INDEX_XMM7 = 7,

#if defined(ASMJIT_X64)
  //! @brief ID for xmm8 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM8 = 8,
  //! @brief ID for xmm9 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM9 = 9,
  //! @brief ID for xmm10 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM10 = 10,
  //! @brief ID for xmm11 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM11 = 11,
  //! @brief ID for xmm12 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM12 = 12,
  //! @brief ID for xmm13 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM13 = 13,
  //! @brief ID for xmm14 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM14 = 14,
  //! @brief ID for xmm15 register (additional register introduced by 64-bit architecture).
  REG_INDEX_XMM15 = 15,
#endif // ASMJIT_X64

  //! @brief ID for ES segment register.
  REG_INDEX_ES = 0,
  //! @brief ID for CS segment register.
  REG_INDEX_CS = 1,
  //! @brief ID for SS segment register.
  REG_INDEX_SS = 2,
  //! @brief ID for DS segment register.
  REG_INDEX_DS = 3,
  //! @brief ID for FS segment register.
  REG_INDEX_FS = 4,
  //! @brief ID for GS segment register.
  REG_INDEX_GS = 5
};

// ============================================================================
// [AsmJit::REG_TYPE]
// ============================================================================

//! @brief Pseudo (not real X86) register types.
enum REG_TYPE
{
  //! @brief Mask for register type.
  REG_TYPE_MASK = 0xFF00,

  // First byte contains register type (mask 0xFF00), Second byte contains
  // register index code.

  // --------------------------------------------------------------------------
  // [GP Register Types]
  // --------------------------------------------------------------------------

  //! @brief 8-bit general purpose register type (LO).
  REG_TYPE_GPB_LO = 0x0100,
  //! @brief 8-bit general purpose register type (HI, only AH, BH, CH, DH).
  REG_TYPE_GPB_HI = 0x0200,
  //! @brief 16-bit general purpose register type.
  REG_TYPE_GPW = 0x1000,
  //! @brief 32-bit general purpose register type.
  REG_TYPE_GPD = 0x2000,
  //! @brief 64-bit general purpose register type.
  REG_TYPE_GPQ = 0x3000,

  //! @var REG_GPN
  //! @brief 32-bit or 64-bit general purpose register type.

  // native 32-bit or 64-bit register type (depends on x86 or x64 mode).
#if defined(ASMJIT_X86)
  REG_TYPE_GPN = REG_TYPE_GPD,
#else
  REG_TYPE_GPN = REG_TYPE_GPQ,
#endif

  // --------------------------------------------------------------------------
  // [X87 (FPU) Register Type]
  // --------------------------------------------------------------------------

  //! @brief X87 (FPU) register type.
  REG_TYPE_X87 = 0x5000,

  // --------------------------------------------------------------------------
  // [MM Register Type]
  // --------------------------------------------------------------------------

  //! @brief 64-bit MM register type.
  REG_TYPE_MM = 0x6000,

  // --------------------------------------------------------------------------
  // [XMM Register Type]
  // --------------------------------------------------------------------------

  //! @brief 128-bit XMM register type.
  REG_TYPE_XMM = 0x7000,

  // --------------------------------------------------------------------------
  // [YMM Register Type]
  // --------------------------------------------------------------------------

  //! @brief 256-bit YMM register type.
  REG_TYPE_YMM = 0x8000,

  // --------------------------------------------------------------------------
  // [Other]
  // --------------------------------------------------------------------------

  //! @brief 16-bit segment register type.
  REG_TYPE_SEGMENT = 0xD000
};

// ============================================================================
// [AsmJit::REG_CODE]
// ============================================================================

//! @brief Pseudo (not real X86) register codes used for generating opcodes.
//!
//! From this register code can be generated real x86 register ID, type of
//! register and size of register.
enum REG_CODE
{
  // --------------------------------------------------------------------------
  // [8-bit Registers]
  // --------------------------------------------------------------------------

  REG_AL = REG_TYPE_GPB_LO,
  REG_CL,
  REG_DL,
  REG_BL,
#if defined(ASMJIT_X64)
  REG_SPL,
  REG_BPL,
  REG_SIL,
  REG_DIL,
#endif // ASMJIT_X64

#if defined(ASMJIT_X64)
  REG_R8B,
  REG_R9B,
  REG_R10B,
  REG_R11B,
  REG_R12B,
  REG_R13B,
  REG_R14B,
  REG_R15B,
#endif // ASMJIT_X64

  REG_AH = REG_TYPE_GPB_HI,
  REG_CH,
  REG_DH,
  REG_BH,

  // --------------------------------------------------------------------------
  // [16-bit Registers]
  // --------------------------------------------------------------------------

  REG_AX = REG_TYPE_GPW,
  REG_CX,
  REG_DX,
  REG_BX,
  REG_SP,
  REG_BP,
  REG_SI,
  REG_DI,
#if defined(ASMJIT_X64)
  REG_R8W,
  REG_R9W,
  REG_R10W,
  REG_R11W,
  REG_R12W,
  REG_R13W,
  REG_R14W,
  REG_R15W,
#endif // ASMJIT_X64

  // --------------------------------------------------------------------------
  // [32-bit Registers]
  // --------------------------------------------------------------------------

  REG_EAX = REG_TYPE_GPD,
  REG_ECX,
  REG_EDX,
  REG_EBX,
  REG_ESP,
  REG_EBP,
  REG_ESI,
  REG_EDI,
#if defined(ASMJIT_X64)
  REG_R8D,
  REG_R9D,
  REG_R10D,
  REG_R11D,
  REG_R12D,
  REG_R13D,
  REG_R14D,
  REG_R15D,
#endif // ASMJIT_X64

  // --------------------------------------------------------------------------
  // [64-bit Registers]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_X64)
  REG_RAX = REG_TYPE_GPQ,
  REG_RCX,
  REG_RDX,
  REG_RBX,
  REG_RSP,
  REG_RBP,
  REG_RSI,
  REG_RDI,
  REG_R8,
  REG_R9,
  REG_R10,
  REG_R11,
  REG_R12,
  REG_R13,
  REG_R14,
  REG_R15,
#endif // ASMJIT_X64

  // --------------------------------------------------------------------------
  // [MM Registers]
  // --------------------------------------------------------------------------

  REG_MM0 = REG_TYPE_MM,
  REG_MM1,
  REG_MM2,
  REG_MM3,
  REG_MM4,
  REG_MM5,
  REG_MM6,
  REG_MM7,

  // --------------------------------------------------------------------------
  // [XMM Registers]
  // --------------------------------------------------------------------------

  REG_XMM0 = REG_TYPE_XMM,
  REG_XMM1,
  REG_XMM2,
  REG_XMM3,
  REG_XMM4,
  REG_XMM5,
  REG_XMM6,
  REG_XMM7,
#if defined(ASMJIT_X64)
  REG_XMM8,
  REG_XMM9,
  REG_XMM10,
  REG_XMM11,
  REG_XMM12,
  REG_XMM13,
  REG_XMM14,
  REG_XMM15,
#endif // ASMJIT_X64

  // --------------------------------------------------------------------------
  // [Native registers (depends on 32-bit or 64-bit mode)]
  // --------------------------------------------------------------------------

  REG_NAX = REG_TYPE_GPN,
  REG_NCX,
  REG_NDX,
  REG_NBX,
  REG_NSP,
  REG_NBP,
  REG_NSI,
  REG_NDI,

  // --------------------------------------------------------------------------
  // [Segment registers]
  // --------------------------------------------------------------------------

  //! @brief ES segment register.
  REG_ES = REG_TYPE_SEGMENT,
  //! @brief CS segment register.
  REG_CS,
  //! @brief SS segment register.
  REG_SS,
  //! @brief DS segment register.
  REG_DS,
  //! @brief FS segment register.
  REG_FS,
  //! @brief GS segment register.
  REG_GS
};

// ============================================================================
// [AsmJit::SEGMENT_PREFIX]
// ============================================================================

//! @brief Segment override prefixes.
enum SEGMENT_PREFIX
{
  // DO NOT MODIFY INDEX CODES - They are used by _emitSegmentPrefix() and
  // by logger in the following order:

  //! @brief Use 'es' segment override prefix.
  SEGMENT_ES = 0,
  //! @brief Use 'cs' segment override prefix.
  SEGMENT_CS = 1,
  //! @brief Use 'ss' segment override prefix.
  SEGMENT_SS = 2,
  //! @brief Use 'ds' segment override prefix.
  SEGMENT_DS = 3,
  //! @brief Use 'fs' segment override prefix.
  SEGMENT_FS = 4,
  //! @brief Use 'gs' segment override prefix.
  SEGMENT_GS = 5,

  //! @brief No segment override prefix.
  SEGMENT_NONE = 0xF,

  //! @brief End of prefix codes
  _SEGMENT_COUNT = 6
};

// ============================================================================
// [AsmJit::PREFETCH_HINT]
// ============================================================================

//! @brief Prefetch hints.
enum PREFETCH_HINT
{
  //! @brief Prefetch to L0 cache.
  PREFETCH_T0  = 1,
  //! @brief Prefetch to L1 cache.
  PREFETCH_T1  = 2,
  //! @brief Prefetch to L2 cache.
  PREFETCH_T2  = 3,
  //! @brief Prefetch using NT hint.
  PREFETCH_NTA = 0
};

// ============================================================================
// [AsmJit::CONDITION]
// ============================================================================

//! @brief Condition codes.
enum CONDITION
{
  //! @brief No condition code.
  C_NO_CONDITION  = -1,

  // Condition codes from processor manuals.
  C_A             = 0x7,
  C_AE            = 0x3,
  C_B             = 0x2,
  C_BE            = 0x6,
  C_C             = 0x2,
  C_E             = 0x4,
  C_G             = 0xF,
  C_GE            = 0xD,
  C_L             = 0xC,
  C_LE            = 0xE,
  C_NA            = 0x6,
  C_NAE           = 0x2,
  C_NB            = 0x3,
  C_NBE           = 0x7,
  C_NC            = 0x3,
  C_NE            = 0x5,
  C_NG            = 0xE,
  C_NGE           = 0xC,
  C_NL            = 0xD,
  C_NLE           = 0xF,
  C_NO            = 0x1,
  C_NP            = 0xB,
  C_NS            = 0x9,
  C_NZ            = 0x5,
  C_O             = 0x0,
  C_P             = 0xA,
  C_PE            = 0xA,
  C_PO            = 0xB,
  C_S             = 0x8,
  C_Z             = 0x4,

  // Simplified condition codes
  C_OVERFLOW      = 0x0,
  C_NO_OVERFLOW   = 0x1,
  C_BELOW         = 0x2,
  C_ABOVE_EQUAL   = 0x3,
  C_EQUAL         = 0x4,
  C_NOT_EQUAL     = 0x5,
  C_BELOW_EQUAL   = 0x6,
  C_ABOVE         = 0x7,
  C_SIGN          = 0x8,
  C_NOT_SIGN      = 0x9,
  C_PARITY_EVEN   = 0xA,
  C_PARITY_ODD    = 0xB,
  C_LESS          = 0xC,
  C_GREATER_EQUAL = 0xD,
  C_LESS_EQUAL    = 0xE,
  C_GREATER       = 0xF,

  // aliases
  C_ZERO          = 0x4,
  C_NOT_ZERO      = 0x5,
  C_NEGATIVE      = 0x8,
  C_POSITIVE      = 0x9,

  // x87 floating point only
  C_FP_UNORDERED  = 16,
  C_FP_NOT_UNORDERED = 17
};

//! @brief  Returns the equivalent of !cc.
//!
//! Negation of the default no_condition (-1) results in a non-default
//! no_condition value (-2). As long as tests for no_condition check
//! for condition < 0, this will work as expected.
static inline CONDITION negateCondition(CONDITION cc)
{
  return static_cast<CONDITION>(cc ^ 1);
}

//! @brief Corresponds to transposing the operands of a comparison.
static inline CONDITION reverseCondition(CONDITION cc)
{
  switch (cc) {
    case C_BELOW:
      return C_ABOVE;
    case C_ABOVE:
      return C_BELOW;
    case C_ABOVE_EQUAL:
      return C_BELOW_EQUAL;
    case C_BELOW_EQUAL:
      return C_ABOVE_EQUAL;
    case C_LESS:
      return C_GREATER;
    case C_GREATER:
      return C_LESS;
    case C_GREATER_EQUAL:
      return C_LESS_EQUAL;
    case C_LESS_EQUAL:
      return C_GREATER_EQUAL;
    default:
      return cc;
  };
}

struct ASMJIT_API ConditionToInstruction
{
  //! @brief Used to map condition code to jcc instructions.
  static const uint32_t _jcctable[16];
  //! @brief Used to map condition code to cmovcc instructions.
  static const uint32_t _cmovcctable[16];
  //! @brief Used to map condition code to setcc instructions.
  static const uint32_t _setcctable[16];

  //! @brief Translate condition code @a cc to jcc instruction code.
  //! @sa @c INST_CODE, @c INST_J.
  static inline uint32_t toJCC(CONDITION cc) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(static_cast<uint32_t>(cc) <= 0xF);
    return _jcctable[cc];
  }

  //! @brief Translate condition code @a cc to cmovcc instruction code.
  //! @sa @c INST_CODE, @c INST_CMOV.
  static inline uint32_t toCMovCC(CONDITION cc) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(static_cast<uint32_t>(cc) <= 0xF);
    return _cmovcctable[cc];
  }

  //! @brief Translate condition code @a cc to setcc instruction code.
  //! @sa @c INST_CODE, @c INST_SET.
  static inline uint32_t toSetCC(CONDITION cc) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(static_cast<uint32_t>(cc) <= 0xF);
    return _setcctable[cc];
  }
};

// ============================================================================
// [AsmJit::SCALE]
// ============================================================================

//! @brief Scale, can be used for addressing.
//!
//! See @c Op and addressing methods like @c byte_ptr(), @c word_ptr(),
//! @c dword_ptr(), etc...
enum SCALE
{
  //! @brief Scale 1 times (no scale).
  TIMES_1 = 0,
  //! @brief Scale 2 times (same as shifting to left by 1).
  TIMES_2 = 1,
  //! @brief Scale 4 times (same as shifting to left by 2).
  TIMES_4 = 2,
  //! @brief Scale 8 times (same as shifting to left by 3).
  TIMES_8 = 3
};

// ============================================================================
// [AsmJit::HINT]
// ============================================================================

//! @brief Condition hint, see @c AsmJit::Assembler::jz(), @c AsmJit::Compiler::jz()
//! and friends.
enum HINT
{
  //! @brief No hint.
  HINT_NONE = 0x00,
  //! @brief Condition will be taken (likely).
  HINT_TAKEN = 0x01,
  //! @brief Condition will be not taken (unlikely).
  HINT_NOT_TAKEN = 0x02
};

//! @brief Hint byte value is the byte that will be emitted if hint flag
//! is specified by @c HINT.
enum HINT_BYTE_VALUE
{
  //! @brief Condition will be taken (likely).
  HINT_BYTE_VALUE_TAKEN = 0x3E,
  //! @brief Condition will be not taken (unlikely).
  HINT_BYTE_VALUE_NOT_TAKEN = 0x2E
};

// ============================================================================
// [AsmJit::FP_STATUS]
// ============================================================================

//! @brief Floating point status.
enum FP_STATUS
{
  FP_C0 = 0x100,
  FP_C1 = 0x200,
  FP_C2 = 0x400,
  FP_C3 = 0x4000,
  FP_CC_MASK = 0x4500
};

// ============================================================================
// [AsmJit::FP_CW]
// ============================================================================

//! @brief Floating point control word.
enum FP_CW
{
  FP_CW_INVOPEX_MASK  = 0x001,
  FP_CW_DENOPEX_MASK  = 0x002,
  FP_CW_ZERODIV_MASK  = 0x004,
  FP_CW_OVFEX_MASK    = 0x008,
  FP_CW_UNDFEX_MASK   = 0x010,
  FP_CW_PRECEX_MASK   = 0x020,
  FP_CW_PRECC_MASK    = 0x300,
  FP_CW_ROUNDC_MASK   = 0xC00,

  // Values for precision control.
  FP_CW_PREC_SINGLE   = 0x000,
  FP_CW_PREC_DOUBLE   = 0x200,
  FP_CW_PREC_EXTENDED = 0x300,

  // Values for rounding control.
  FP_CW_ROUND_NEAREST = 0x000,
  FP_CW_ROUND_DOWN    = 0x400,
  FP_CW_ROUND_UP      = 0x800,
  FP_CW_ROUND_TOZERO  = 0xC00
};

// ============================================================================
// [AsmJit::INST_CODE]
// ============================================================================

//! @brief Instruction codes.
//!
//! Note that these instruction codes are AsmJit specific. Each instruction is
//! unique ID into AsmJit instruction table. Instruction codes are used together
//! with AsmJit::Assembler and you can also use instruction codes to serialize
//! instructions by @ref AssemblerCore::_emitInstruction() or
//! @ref CompilerCore::_emitInstruction()
enum INST_CODE
{
  INST_ADC,           // X86/X64
  INST_ADD,           // X86/X64
  INST_ADDPD,         // SSE2
  INST_ADDPS,         // SSE
  INST_ADDSD,         // SSE2
  INST_ADDSS,         // SSE
  INST_ADDSUBPD,      // SSE3
  INST_ADDSUBPS,      // SSE3
  INST_AMD_PREFETCH,
  INST_AMD_PREFETCHW,
  INST_AND,           // X86/X64
  INST_ANDNPD,        // SSE2
  INST_ANDNPS,        // SSE
  INST_ANDPD,         // SSE2
  INST_ANDPS,         // SSE
  INST_BLENDPD,       // SSE4.1
  INST_BLENDPS,       // SSE4.1
  INST_BLENDVPD,      // SSE4.1
  INST_BLENDVPS,      // SSE4.1
  INST_BSF,           // X86/X64
  INST_BSR,           // X86/X64
  INST_BSWAP,         // X86/X64 (i486)
  INST_BT,            // X86/X64
  INST_BTC,           // X86/X64
  INST_BTR,           // X86/X64
  INST_BTS,           // X86/X64
  INST_CALL,          // X86/X64
  INST_CBW,           // X86/X64
  INST_CDQE,          // X64 only
  INST_CLC,           // X86/X64
  INST_CLD,           // X86/X64
  INST_CLFLUSH,       // SSE2
  INST_CMC,           // X86/X64

  INST_CMOV,          // Begin (cmovcc) (i586)
  INST_CMOVA = INST_CMOV, //X86/X64 (cmovcc) (i586)
  INST_CMOVAE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVB,         // X86/X64 (cmovcc) (i586)
  INST_CMOVBE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVC,         // X86/X64 (cmovcc) (i586)
  INST_CMOVE,         // X86/X64 (cmovcc) (i586)
  INST_CMOVG,         // X86/X64 (cmovcc) (i586)
  INST_CMOVGE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVL,         // X86/X64 (cmovcc) (i586)
  INST_CMOVLE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNA,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNAE,       // X86/X64 (cmovcc) (i586)
  INST_CMOVNB,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNBE,       // X86/X64 (cmovcc) (i586)
  INST_CMOVNC,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNG,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNGE,       // X86/X64 (cmovcc) (i586)
  INST_CMOVNL,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNLE,       // X86/X64 (cmovcc) (i586)
  INST_CMOVNO,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNP,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNS,        // X86/X64 (cmovcc) (i586)
  INST_CMOVNZ,        // X86/X64 (cmovcc) (i586)
  INST_CMOVO,         // X86/X64 (cmovcc) (i586)
  INST_CMOVP,         // X86/X64 (cmovcc) (i586)
  INST_CMOVPE,        // X86/X64 (cmovcc) (i586)
  INST_CMOVPO,        // X86/X64 (cmovcc) (i586)
  INST_CMOVS,         // X86/X64 (cmovcc) (i586)
  INST_CMOVZ,         // X86/X64 (cmovcc) (i586)

  INST_CMP,           // X86/X64
  INST_CMPPD,         // SSE2
  INST_CMPPS,         // SSE
  INST_CMPSD,         // SSE2
  INST_CMPSS,         // SSE
  INST_CMPXCHG,       // X86/X64 (i486)
  INST_CMPXCHG16B,    // X64 only
  INST_CMPXCHG8B,     // X86/X64 (i586)
  INST_COMISD,        // SSE2
  INST_COMISS,        // SSE
  INST_CPUID,         // X86/X64 (i486)
  INST_CRC32,         // SSE4.2
  INST_CVTDQ2PD,      // SSE2
  INST_CVTDQ2PS,      // SSE2
  INST_CVTPD2DQ,      // SSE2
  INST_CVTPD2PI,      // SSE2
  INST_CVTPD2PS,      // SSE2
  INST_CVTPI2PD,      // SSE2
  INST_CVTPI2PS,      // SSE
  INST_CVTPS2DQ,      // SSE2
  INST_CVTPS2PD,      // SSE2
  INST_CVTPS2PI,      // SSE
  INST_CVTSD2SI,      // SSE2
  INST_CVTSD2SS,      // SSE2
  INST_CVTSI2SD,      // SSE2
  INST_CVTSI2SS,      // SSE
  INST_CVTSS2SD,      // SSE2
  INST_CVTSS2SI,      // SSE
  INST_CVTTPD2DQ,     // SSE2
  INST_CVTTPD2PI,     // SSE2
  INST_CVTTPS2DQ,     // SSE2
  INST_CVTTPS2PI,     // SSE
  INST_CVTTSD2SI,     // SSE2
  INST_CVTTSS2SI,     // SSE
  INST_CWDE,          // X86/X64
  INST_DAA,           // X86 only
  INST_DAS,           // X86 only
  INST_DEC,           // X86/X64
  INST_DIV,           // X86/X64
  INST_DIVPD,         // SSE2
  INST_DIVPS,         // SSE
  INST_DIVSD,         // SSE2
  INST_DIVSS,         // SSE
  INST_DPPD,          // SSE4.1
  INST_DPPS,          // SSE4.1
  INST_EMMS,          // MMX
  INST_ENTER,         // X86/X64
  INST_EXTRACTPS,     // SSE4.1
  INST_F2XM1,         // X87
  INST_FABS,          // X87
  INST_FADD,          // X87
  INST_FADDP,         // X87
  INST_FBLD,          // X87
  INST_FBSTP,         // X87
  INST_FCHS,          // X87
  INST_FCLEX,         // X87
  INST_FCMOVB,        // X87
  INST_FCMOVBE,       // X87
  INST_FCMOVE,        // X87
  INST_FCMOVNB,       // X87
  INST_FCMOVNBE,      // X87
  INST_FCMOVNE,       // X87
  INST_FCMOVNU,       // X87
  INST_FCMOVU,        // X87
  INST_FCOM,          // X87
  INST_FCOMI,         // X87
  INST_FCOMIP,        // X87
  INST_FCOMP,         // X87
  INST_FCOMPP,        // X87
  INST_FCOS,          // X87
  INST_FDECSTP,       // X87
  INST_FDIV,          // X87
  INST_FDIVP,         // X87
  INST_FDIVR,         // X87
  INST_FDIVRP,        // X87
  INST_FEMMS,         // 3dNow!
  INST_FFREE,         // X87
  INST_FIADD,         // X87
  INST_FICOM,         // X87
  INST_FICOMP,        // X87
  INST_FIDIV,         // X87
  INST_FIDIVR,        // X87
  INST_FILD,          // X87
  INST_FIMUL,         // X87
  INST_FINCSTP,       // X87
  INST_FINIT,         // X87
  INST_FIST,          // X87
  INST_FISTP,         // X87
  INST_FISTTP,        // SSE3
  INST_FISUB,         // X87
  INST_FISUBR,        // X87
  INST_FLD,           // X87
  INST_FLD1,          // X87
  INST_FLDCW,         // X87
  INST_FLDENV,        // X87
  INST_FLDL2E,        // X87
  INST_FLDL2T,        // X87
  INST_FLDLG2,        // X87
  INST_FLDLN2,        // X87
  INST_FLDPI,         // X87
  INST_FLDZ,          // X87
  INST_FMUL,          // X87
  INST_FMULP,         // X87
  INST_FNCLEX,        // X87
  INST_FNINIT,        // X87
  INST_FNOP,          // X87
  INST_FNSAVE,        // X87
  INST_FNSTCW,        // X87
  INST_FNSTENV,       // X87
  INST_FNSTSW,        // X87
  INST_FPATAN,        // X87
  INST_FPREM,         // X87
  INST_FPREM1,        // X87
  INST_FPTAN,         // X87
  INST_FRNDINT,       // X87
  INST_FRSTOR,        // X87
  INST_FSAVE,         // X87
  INST_FSCALE,        // X87
  INST_FSIN,          // X87
  INST_FSINCOS,       // X87
  INST_FSQRT,         // X87
  INST_FST,           // X87
  INST_FSTCW,         // X87
  INST_FSTENV,        // X87
  INST_FSTP,          // X87
  INST_FSTSW,         // X87
  INST_FSUB,          // X87
  INST_FSUBP,         // X87
  INST_FSUBR,         // X87
  INST_FSUBRP,        // X87
  INST_FTST,          // X87
  INST_FUCOM,         // X87
  INST_FUCOMI,        // X87
  INST_FUCOMIP,       // X87
  INST_FUCOMP,        // X87
  INST_FUCOMPP,       // X87
  INST_FWAIT,         // X87
  INST_FXAM,          // X87
  INST_FXCH,          // X87
  INST_FXRSTOR,       // X87
  INST_FXSAVE,        // X87
  INST_FXTRACT,       // X87
  INST_FYL2X,         // X87
  INST_FYL2XP1,       // X87
  INST_HADDPD,        // SSE3
  INST_HADDPS,        // SSE3
  INST_HSUBPD,        // SSE3
  INST_HSUBPS,        // SSE3
  INST_IDIV,          // X86/X64
  INST_IMUL,          // X86/X64
  INST_INC,           // X86/X64
  INST_INT3,          // X86/X64
  INST_J,             // Begin (jcc)
  INST_JA = 
    INST_J,           // X86/X64 (jcc)
  INST_JAE,           // X86/X64 (jcc)
  INST_JB,            // X86/X64 (jcc)
  INST_JBE,           // X86/X64 (jcc)
  INST_JC,            // X86/X64 (jcc)
  INST_JE,            // X86/X64 (jcc)
  INST_JG,            // X86/X64 (jcc)
  INST_JGE,           // X86/X64 (jcc)
  INST_JL,            // X86/X64 (jcc)
  INST_JLE,           // X86/X64 (jcc)
  INST_JNA,           // X86/X64 (jcc)
  INST_JNAE,          // X86/X64 (jcc)
  INST_JNB,           // X86/X64 (jcc)
  INST_JNBE,          // X86/X64 (jcc)
  INST_JNC,           // X86/X64 (jcc)
  INST_JNE,           // X86/X64 (jcc)
  INST_JNG,           // X86/X64 (jcc)
  INST_JNGE,          // X86/X64 (jcc)
  INST_JNL,           // X86/X64 (jcc)
  INST_JNLE,          // X86/X64 (jcc)
  INST_JNO,           // X86/X64 (jcc)
  INST_JNP,           // X86/X64 (jcc)
  INST_JNS,           // X86/X64 (jcc)
  INST_JNZ,           // X86/X64 (jcc)
  INST_JO,            // X86/X64 (jcc)
  INST_JP,            // X86/X64 (jcc)
  INST_JPE,           // X86/X64 (jcc)
  INST_JPO,           // X86/X64 (jcc)
  INST_JS,            // X86/X64 (jcc)
  INST_JZ,            // X86/X64 (jcc)
  INST_JMP,           // X86/X64 (jmp)
  INST_LDDQU,         // SSE3
  INST_LDMXCSR,       // SSE
  INST_LAHF,          // X86/X64 (CPUID NEEDED)
  INST_LEA,           // X86/X64
  INST_LEAVE,         // X86/X64
  INST_LFENCE,        // SSE2
  INST_MASKMOVDQU,    // SSE2
  INST_MASKMOVQ,      // MMX-Ext
  INST_MAXPD,         // SSE2
  INST_MAXPS,         // SSE
  INST_MAXSD,         // SSE2
  INST_MAXSS,         // SSE
  INST_MFENCE,        // SSE2
  INST_MINPD,         // SSE2
  INST_MINPS,         // SSE
  INST_MINSD,         // SSE2
  INST_MINSS,         // SSE
  INST_MONITOR,       // SSE3
  INST_MOV,           // X86/X64
  INST_MOVAPD,        // SSE2
  INST_MOVAPS,        // SSE
  INST_MOVBE,         // SSE3 - Intel-Atom
  INST_MOVD,          // MMX/SSE2
  INST_MOVDDUP,       // SSE3
  INST_MOVDQ2Q,       // SSE2
  INST_MOVDQA,        // SSE2
  INST_MOVDQU,        // SSE2
  INST_MOVHLPS,       // SSE
  INST_MOVHPD,        // SSE2
  INST_MOVHPS,        // SSE
  INST_MOVLHPS,       // SSE
  INST_MOVLPD,        // SSE2
  INST_MOVLPS,        // SSE
  INST_MOVMSKPD,      // SSE2
  INST_MOVMSKPS,      // SSE2
  INST_MOVNTDQ,       // SSE2
  INST_MOVNTDQA,      // SSE4.1
  INST_MOVNTI,        // SSE2
  INST_MOVNTPD,       // SSE2
  INST_MOVNTPS,       // SSE
  INST_MOVNTQ,        // MMX-Ext
  INST_MOVQ,          // MMX/SSE/SSE2
  INST_MOVQ2DQ,       // SSE2
  INST_MOVSD,         // SSE2
  INST_MOVSHDUP,      // SSE3
  INST_MOVSLDUP,      // SSE3
  INST_MOVSS,         // SSE
  INST_MOVSX,         // X86/X64
  INST_MOVSXD,        // X86/X64
  INST_MOVUPD,        // SSE2
  INST_MOVUPS,        // SSE
  INST_MOVZX,         // X86/X64
  INST_MOV_PTR,       // X86/X64
  INST_MPSADBW,       // SSE4.1
  INST_MUL,           // X86/X64
  INST_MULPD,         // SSE2
  INST_MULPS,         // SSE
  INST_MULSD,         // SSE2
  INST_MULSS,         // SSE
  INST_MWAIT,         // SSE3
  INST_NEG,           // X86/X64
  INST_NOP,           // X86/X64
  INST_NOT,           // X86/X64
  INST_OR,            // X86/X64
  INST_ORPD,          // SSE2
  INST_ORPS,          // SSE
  INST_PABSB,         // SSSE3
  INST_PABSD,         // SSSE3
  INST_PABSW,         // SSSE3
  INST_PACKSSDW,      // MMX/SSE2
  INST_PACKSSWB,      // MMX/SSE2
  INST_PACKUSDW,      // SSE4.1
  INST_PACKUSWB,      // MMX/SSE2
  INST_PADDB,         // MMX/SSE2
  INST_PADDD,         // MMX/SSE2
  INST_PADDQ,         // SSE2
  INST_PADDSB,        // MMX/SSE2
  INST_PADDSW,        // MMX/SSE2
  INST_PADDUSB,       // MMX/SSE2
  INST_PADDUSW,       // MMX/SSE2
  INST_PADDW,         // MMX/SSE2
  INST_PALIGNR,       // SSSE3
  INST_PAND,          // MMX/SSE2
  INST_PANDN,         // MMX/SSE2
  INST_PAUSE,         // SSE2.
  INST_PAVGB,         // MMX-Ext
  INST_PAVGW,         // MMX-Ext
  INST_PBLENDVB,      // SSE4.1
  INST_PBLENDW,       // SSE4.1
  INST_PCMPEQB,       // MMX/SSE2
  INST_PCMPEQD,       // MMX/SSE2
  INST_PCMPEQQ,       // SSE4.1
  INST_PCMPEQW,       // MMX/SSE2    
  INST_PCMPESTRI,     // SSE4.2
  INST_PCMPESTRM,     // SSE4.2
  INST_PCMPGTB,       // MMX/SSE2
  INST_PCMPGTD,       // MMX/SSE2
  INST_PCMPGTQ,       // SSE4.2
  INST_PCMPGTW,       // MMX/SSE2
  INST_PCMPISTRI,     // SSE4.2
  INST_PCMPISTRM,     // SSE4.2
  INST_PEXTRB,        // SSE4.1
  INST_PEXTRD,        // SSE4.1        
  INST_PEXTRQ,        // SSE4.1
  INST_PEXTRW,        // MMX-Ext/SSE2
  INST_PF2ID,         // 3dNow!
  INST_PF2IW,         // Enhanced 3dNow!
  INST_PFACC,         // 3dNow!
  INST_PFADD,         // 3dNow!
  INST_PFCMPEQ,       // 3dNow!
  INST_PFCMPGE,       // 3dNow!
  INST_PFCMPGT,       // 3dNow!
  INST_PFMAX,         // 3dNow!
  INST_PFMIN,         // 3dNow!
  INST_PFMUL,         // 3dNow!
  INST_PFNACC,        // Enhanced 3dNow!
  INST_PFPNACC,       // Enhanced 3dNow!
  INST_PFRCP,         // 3dNow!
  INST_PFRCPIT1,      // 3dNow!
  INST_PFRCPIT2,      // 3dNow!
  INST_PFRSQIT1,      // 3dNow!
  INST_PFRSQRT,       // 3dNow!
  INST_PFSUB,         // 3dNow!
  INST_PFSUBR,        // 3dNow!
  INST_PHADDD,        // SSSE3
  INST_PHADDSW,       // SSSE3
  INST_PHADDW,        // SSSE3
  INST_PHMINPOSUW,    // SSE4.1
  INST_PHSUBD,        // SSSE3
  INST_PHSUBSW,       // SSSE3
  INST_PHSUBW,        // SSSE3
  INST_PI2FD,         // 3dNow!
  INST_PI2FW,         // Enhanced 3dNow!
  INST_PINSRB,        // SSE4.1
  INST_PINSRD,        // SSE4.1
  INST_PINSRQ,        // SSE4.1
  INST_PINSRW,        // MMX-Ext
  INST_PMADDUBSW,     // SSSE3
  INST_PMADDWD,       // MMX/SSE2
  INST_PMAXSB,        // SSE4.1
  INST_PMAXSD,        // SSE4.1
  INST_PMAXSW,        // MMX-Ext
  INST_PMAXUB,        // MMX-Ext
  INST_PMAXUD,        // SSE4.1
  INST_PMAXUW,        // SSE4.1
  INST_PMINSB,        // SSE4.1
  INST_PMINSD,        // SSE4.1
  INST_PMINSW,        // MMX-Ext
  INST_PMINUB,        // MMX-Ext
  INST_PMINUD,        // SSE4.1
  INST_PMINUW,        // SSE4.1
  INST_PMOVMSKB,      // MMX-Ext
  INST_PMOVSXBD,      // SSE4.1
  INST_PMOVSXBQ,      // SSE4.1
  INST_PMOVSXBW,      // SSE4.1
  INST_PMOVSXDQ,      // SSE4.1
  INST_PMOVSXWD,      // SSE4.1
  INST_PMOVSXWQ,      // SSE4.1
  INST_PMOVZXBD,      // SSE4.1
  INST_PMOVZXBQ,      // SSE4.1
  INST_PMOVZXBW,      // SSE4.1
  INST_PMOVZXDQ,      // SSE4.1
  INST_PMOVZXWD,      // SSE4.1
  INST_PMOVZXWQ,      // SSE4.1
  INST_PMULDQ,        // SSE4.1
  INST_PMULHRSW,      // SSSE3
  INST_PMULHUW,       // MMX-Ext
  INST_PMULHW,        // MMX/SSE2
  INST_PMULLD,        // SSE4.1
  INST_PMULLW,        // MMX/SSE2
  INST_PMULUDQ,       // SSE2
  INST_POP,           // X86/X64
  INST_POPAD,         // X86 only
  INST_POPCNT,        // SSE4.2
  INST_POPFD,         // X86 only
  INST_POPFQ,         // X64 only
  INST_POR,           // MMX/SSE2
  INST_PREFETCH,      // MMX-Ext
  INST_PSADBW,        // MMX-Ext
  INST_PSHUFB,        // SSSE3
  INST_PSHUFD,        // SSE2
  INST_PSHUFW,        // MMX-Ext
  INST_PSHUFHW,       // SSE2
  INST_PSHUFLW,       // SSE2
  INST_PSIGNB,        // SSSE3
  INST_PSIGND,        // SSSE3
  INST_PSIGNW,        // SSSE3
  INST_PSLLD,         // MMX/SSE2
  INST_PSLLDQ,        // SSE2
  INST_PSLLQ,         // MMX/SSE2
  INST_PSLLW,         // MMX/SSE2
  INST_PSRAD,         // MMX/SSE2
  INST_PSRAW,         // MMX/SSE2
  INST_PSRLD,         // MMX/SSE2
  INST_PSRLDQ,        // SSE2
  INST_PSRLQ,         // MMX/SSE2
  INST_PSRLW,         // MMX/SSE2
  INST_PSUBB,         // MMX/SSE2
  INST_PSUBD,         // MMX/SSE2
  INST_PSUBQ,         // SSE2
  INST_PSUBSB,        // MMX/SSE2
  INST_PSUBSW,        // MMX/SSE2
  INST_PSUBUSB,       // MMX/SSE2
  INST_PSUBUSW,       // MMX/SSE2
  INST_PSUBW,         // MMX/SSE2
  INST_PSWAPD,        // Enhanced 3dNow!
  INST_PTEST,         // SSE4.1
  INST_PUNPCKHBW,     // MMX/SSE2
  INST_PUNPCKHDQ,     // MMX/SSE2
  INST_PUNPCKHQDQ,    // SSE2
  INST_PUNPCKHWD,     // MMX/SSE2
  INST_PUNPCKLBW,     // MMX/SSE2
  INST_PUNPCKLDQ,     // MMX/SSE2
  INST_PUNPCKLQDQ,    // SSE2
  INST_PUNPCKLWD,     // MMX/SSE2
  INST_PUSH,          // X86/X64
  INST_PUSHAD,        // X86 only
  INST_PUSHFD,        // X86 only
  INST_PUSHFQ,        // X64 only
  INST_PXOR,          // MMX/SSE2
  INST_RCL,           // X86/X64
  INST_RCPPS,         // SSE
  INST_RCPSS,         // SSE
  INST_RCR,           // X86/X64
  INST_RDTSC,         // X86/X64
  INST_RDTSCP,        // X86/X64
  INST_REP_LODSB,     // X86/X64 (REP)
  INST_REP_LODSD,     // X86/X64 (REP)
  INST_REP_LODSQ,     // X64 only (REP)
  INST_REP_LODSW,     // X86/X64 (REP)
  INST_REP_MOVSB,     // X86/X64 (REP)
  INST_REP_MOVSD,     // X86/X64 (REP)
  INST_REP_MOVSQ,     // X64 only (REP)
  INST_REP_MOVSW,     // X86/X64 (REP)
  INST_REP_STOSB,     // X86/X64 (REP)
  INST_REP_STOSD,     // X86/X64 (REP)
  INST_REP_STOSQ,     // X64 only (REP)
  INST_REP_STOSW,     // X86/X64 (REP)
  INST_REPE_CMPSB,    // X86/X64 (REP)
  INST_REPE_CMPSD,    // X86/X64 (REP)
  INST_REPE_CMPSQ,    // X64 only (REP)
  INST_REPE_CMPSW,    // X86/X64 (REP)
  INST_REPE_SCASB,    // X86/X64 (REP)
  INST_REPE_SCASD,    // X86/X64 (REP)
  INST_REPE_SCASQ,    // X64 only (REP)
  INST_REPE_SCASW,    // X86/X64 (REP)
  INST_REPNE_CMPSB,   // X86/X64 (REP)
  INST_REPNE_CMPSD,   // X86/X64 (REP)
  INST_REPNE_CMPSQ,   // X64 only (REP)
  INST_REPNE_CMPSW,   // X86/X64 (REP)
  INST_REPNE_SCASB,   // X86/X64 (REP)
  INST_REPNE_SCASD,   // X86/X64 (REP)
  INST_REPNE_SCASQ,   // X64 only (REP)
  INST_REPNE_SCASW,   // X86/X64 (REP)
  INST_RET,           // X86/X64
  INST_ROL,           // X86/X64
  INST_ROR,           // X86/X64
  INST_ROUNDPD,       // SSE4.1
  INST_ROUNDPS,       // SSE4.1
  INST_ROUNDSD,       // SSE4.1
  INST_ROUNDSS,       // SSE4.1
  INST_RSQRTPS,       // SSE
  INST_RSQRTSS,       // SSE
  INST_SAHF,          // X86/X64 (CPUID NEEDED)
  INST_SAL,           // X86/X64
  INST_SAR,           // X86/X64
  INST_SBB,           // X86/X64
  INST_SET,           // Begin (setcc)
  INST_SETA=INST_SET, // X86/X64 (setcc)
  INST_SETAE,         // X86/X64 (setcc)
  INST_SETB,          // X86/X64 (setcc)
  INST_SETBE,         // X86/X64 (setcc)
  INST_SETC,          // X86/X64 (setcc)
  INST_SETE,          // X86/X64 (setcc)
  INST_SETG,          // X86/X64 (setcc)
  INST_SETGE,         // X86/X64 (setcc)
  INST_SETL,          // X86/X64 (setcc)
  INST_SETLE,         // X86/X64 (setcc)
  INST_SETNA,         // X86/X64 (setcc)
  INST_SETNAE,        // X86/X64 (setcc)
  INST_SETNB,         // X86/X64 (setcc)
  INST_SETNBE,        // X86/X64 (setcc)
  INST_SETNC,         // X86/X64 (setcc)
  INST_SETNE,         // X86/X64 (setcc)
  INST_SETNG,         // X86/X64 (setcc)
  INST_SETNGE,        // X86/X64 (setcc)
  INST_SETNL,         // X86/X64 (setcc)
  INST_SETNLE,        // X86/X64 (setcc)
  INST_SETNO,         // X86/X64 (setcc)
  INST_SETNP,         // X86/X64 (setcc)
  INST_SETNS,         // X86/X64 (setcc)
  INST_SETNZ,         // X86/X64 (setcc)
  INST_SETO,          // X86/X64 (setcc)
  INST_SETP,          // X86/X64 (setcc)
  INST_SETPE,         // X86/X64 (setcc)
  INST_SETPO,         // X86/X64 (setcc)
  INST_SETS,          // X86/X64 (setcc)
  INST_SETZ,          // X86/X64 (setcc)
  INST_SFENCE,        // MMX-Ext/SSE
  INST_SHL,           // X86/X64
  INST_SHLD,          // X86/X64
  INST_SHR,           // X86/X64
  INST_SHRD,          // X86/X64
  INST_SHUFPD,        // SSE2
  INST_SHUFPS,        // SSE
  INST_SQRTPD,        // SSE2
  INST_SQRTPS,        // SSE
  INST_SQRTSD,        // SSE2
  INST_SQRTSS,        // SSE
  INST_STC,           // X86/X64
  INST_STD,           // X86/X64
  INST_STMXCSR,       // SSE
  INST_SUB,           // X86/X64
  INST_SUBPD,         // SSE2
  INST_SUBPS,         // SSE
  INST_SUBSD,         // SSE2
  INST_SUBSS,         // SSE
  INST_TEST,          // X86/X64
  INST_UCOMISD,       // SSE2
  INST_UCOMISS,       // SSE
  INST_UD2,           // X86/X64
  INST_UNPCKHPD,      // SSE2
  INST_UNPCKHPS,      // SSE
  INST_UNPCKLPD,      // SSE2
  INST_UNPCKLPS,      // SSE
  INST_XADD,          // X86/X64 (i486)
  INST_XCHG,          // X86/X64 (i386)
  INST_XOR,           // X86/X64
  INST_XORPD,         // SSE2
  INST_XORPS,         // SSE

  _INST_COUNT,

  _INST_J_BEGIN = INST_J,
  _INST_J_END = INST_JMP
};

// ============================================================================
// [AsmJit::Instruction Name]
// ============================================================================

//! @internal
//! 
//! @brief Instruction names.
ASMJIT_API extern const char instructionName[];

// ============================================================================
// [AsmJit::Instruction Description]
// ============================================================================

struct InstructionDescription
{
  // --------------------------------------------------------------------------
  // [Instruction Groups]
  // --------------------------------------------------------------------------

  //! @brief Instruction groups.
  //!
  //! This should be only used by assembler, because it's @c AsmJit::Assembler
  //! specific grouping. Each group represents one 'case' in the Assembler's 
  //! main emit method.
  enum G
  {
    // Gloup categories.
    G_EMIT,

    G_ALU,
    G_BSWAP,
    G_BT,
    G_CALL,
    G_CRC32,
    G_ENTER,
    G_IMUL,
    G_INC_DEC,
    G_J,
    G_JMP,
    G_LEA,
    G_M,
    G_MOV,
    G_MOV_PTR,
    G_MOVSX_MOVZX,
    G_MOVSXD,
    G_PUSH, // I_PUSH is implemented before I_POP
    G_POP,
    G_R_RM,
    G_RM_B,
    G_RM,
    G_RM_R,
    G_REP,
    G_RET,
    G_ROT,
    G_SHLD_SHRD,
    G_TEST,
    G_XCHG,

    // Group for x87 FP instructions in format mem or st(i), st(i) (fadd, fsub, fdiv, ...)
    G_X87_FPU,
    // Group for x87 FP instructions in format st(i), st(i)
    G_X87_STI,
    // Group for fld/fst/fstp instruction, internally uses I_X87_MEM group.
    G_X87_MEM_STI,
    // Group for x87 FP instructions that uses Word, DWord, QWord or TWord memory pointer.
    G_X87_MEM,
    // Group for x87 FSTSW/FNSTSW instructions
    G_X87_FSTSW,

    // Group for movbe instruction
    G_MOVBE,

    // Group for MMX/SSE instructions in format (X)MM|Reg|Mem <- (X)MM|Reg|Mem,
    // 0x66 prefix must be set manually in opcodes.
    // - Primary opcode is used for instructions in (X)MM <- (X)MM/Mem format,
    // - Secondary opcode is used for instructions in (X)MM/Mem <- (X)MM format.
    G_MMU_MOV,

    // Group for movd and movq instructions.
    G_MMU_MOVD,
    G_MMU_MOVQ,

    // Group for pextrd, pextrq and pextrw instructions (it's special instruction
    // not similar to others)
    G_MMU_PEXTR,

    // Group for prefetch instruction
    G_MMU_PREFETCH,

    // Group for MMX/SSE instructions in format (X)MM|Reg <- (X)MM|Reg|Mem|Imm,
    // 0x66 prefix is added for MMX instructions that used by SSE2 registers.
    // - Primary opcode is used for instructions in (X)MM|Reg <- (X)MM|Reg|Mem format,
    // - Secondary opcode is iused for instructions in (X)MM|Reg <- Imm format.
    G_MMU_RMI,
    G_MMU_RM_IMM8,

    // Group for 3dNow instructions
    G_MMU_RM_3DNOW
  };

  // --------------------------------------------------------------------------
  // [Instruction Core Flags]
  // --------------------------------------------------------------------------

  //! @brief Instruction core flags.
  enum F
  {
    //! @brief No flags.
    F_NONE = 0x00,
    //! @brief Instruction is jump, conditional jump, call or ret.
    F_JUMP = 0x01,
    //! @brief Instruction will overwrite first operand - o[0].
    F_MOV = 0x02,
    //! @brief Instruction is X87 FPU.
    F_FPU = 0x04,
    //! @brief Instruction can be prepended using LOCK prefix
    //! (usable for multithreaded applications).
    F_LOCKABLE = 0x08,

    //! @brief Instruction is special, this is for @c Compiler.
    F_SPECIAL = 0x10,
    //! @brief Instruction always performs memory access.
    //!
    //! This flag is always combined with @c F_SPECIAL and signalizes that
    //! there is implicit address which is accessed (usually EDI/RDI or ESI/EDI).
    F_SPECIAL_MEM = 0x20
  };

  // --------------------------------------------------------------------------
  // [Instruction Operand Flags]
  // --------------------------------------------------------------------------

  //! @brief Instruction operand flags.
  enum O
  {
    // X86, MM, XMM
    O_GB          = 0x0001,
    O_GW          = 0x0002,
    O_GD          = 0x0004,
    O_GQ          = 0x0008,
    O_MM          = 0x0010,
    O_XMM         = 0x0020,
    O_MEM         = 0x0040,
    O_IMM         = 0x0080,


    O_GB_MEM      = O_GB    | O_MEM,
    O_GW_MEM      = O_GW    | O_MEM,
    O_GD_MEM      = O_GD    | O_MEM,
    O_GQ_MEM      = O_GQ    | O_MEM,

    O_GQDWB       = O_GQ    | O_GD    | O_GW    | O_GB,
    O_GQDW        = O_GQ    | O_GD    | O_GW,
    O_GQD         = O_GQ    | O_GD,
    O_GWB         = O_GW    | O_GB,

    O_GQDWB_MEM   = O_GQDWB | O_MEM,
    O_GQDW_MEM    = O_GQDW  | O_MEM,
    O_GQD_MEM     = O_GQD   | O_MEM,
    O_GWB_MEM     = O_GWB   | O_MEM,

    O_MM_MEM      = O_MM    | O_MEM,
    O_XMM_MEM     = O_XMM   | O_MEM,
    O_MM_XMM      = O_MM    | O_XMM,
    O_MM_XMM_MEM  = O_MM    | O_XMM   | O_MEM,

    // X87
    O_FM_2        = O_MEM   | 0x0100,
    O_FM_4        = O_MEM   | 0x0200,
    O_FM_8        = O_MEM   | 0x0400,
    O_FM_10       = O_MEM   | 0x0800,

    O_FM_2_4      = O_FM_2  | O_FM_4,
    O_FM_2_4_8    = O_FM_2  | O_FM_4  | O_FM_8,
    O_FM_4_8      = O_FM_4  | O_FM_8,
    O_FM_4_8_10   = O_FM_4  | O_FM_8  | O_FM_10,

    // Don't emit REX prefix.
    O_NOREX       = 0x2000
  };

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Instruction code.
  uint16_t code;
  //! @brief Instruction name index in instructionName[] array.
  uint16_t nameIndex;
  //! @brief Instruction group, used also by @c Compiler.
  uint8_t group;
  //! @brief Instruction type flags.
  uint8_t flags;
  //! @brief First and second operand flags (some groups depends on these settings, used also by @c Compiler).
  uint16_t oflags[2];
  //! @brief If instruction has only memory operand, this is register opcode.
  uint16_t opCodeR;
  //! @brief Primary and secondary opcodes.
  uint32_t opCode[2];

  //! @brief Get the instruction name (null terminated string).
  inline const char* getName() const { return instructionName + nameIndex; }

  //! @brief Get whether the instruction is conditional or standard jump.
  inline bool isJump() const { return (flags & F_JUMP) != 0; }
  //! @brief Get whether the instruction is MOV type.
  inline bool isMov() const { return (flags & F_MOV) != 0; }
  //! @brief Get whether the instruction is X87 FPU type.
  inline bool isFPU() const { return (flags & F_FPU) != 0; }
  //! @brief Get whether the instruction can be prefixed by LOCK prefix.
  inline bool isLockable() const { return (flags & F_LOCKABLE) != 0; }

  //! @brief Get whether the instruction is special type (this is used by
  //! @c Compiler to manage additional variables or functionality).
  inline bool isSpecial() const { return (flags & F_SPECIAL) != 0; }
  //! @brief Get whether the instruction is special type and it performs
  //! memory access.
  inline bool isSpecialMem() const { return (flags & F_SPECIAL_MEM) != 0; }
};

ASMJIT_API extern const InstructionDescription instructionDescription[];

// ============================================================================
// [AsmJit::EMIT_OPTIONS]
// ============================================================================

//! @brief Emit options, mainly for internal purposes.
enum EMIT_OPTIONS
{
  //! @brief Force REX prefix to be emitted.
  //!
  //! This option should be used carefully, because there are unencodable
  //! combinations. If you want to access ah, bh, ch or dh registers then you
  //! can't emit REX prefix and it will cause an illegal instruction error.
  EMIT_OPTION_REX_PREFIX = (1 << 0),

  //! @brief Tell @c Assembler or @c Compiler to emit and validate lock prefix.
  //!
  //! If this option is used and instruction doesn't support LOCK prefix then
  //! invalid instruction error is generated.
  EMIT_OPTION_LOCK_PREFIX = (1 << 1),

  //! @brief Emit short/near jump or conditional jump instead of far one, 
  //! saving some bytes.
  EMIT_OPTION_SHORT_JUMP = (1 << 2)
};

// ============================================================================
// [AsmJit::CALL_CONV]
// ============================================================================

//! @brief Calling convention type.
//!
//! Calling convention is scheme how function arguments are passed into 
//! function and how functions returns values. In assembler programming
//! it's needed to always comply with function calling conventions, because
//! even small inconsistency can cause undefined behavior or crash.
//!
//! List of calling conventions for 32-bit x86 mode:
//! - @c CALL_CONV_CDECL - Calling convention for C runtime.
//! - @c CALL_CONV_STDCALL - Calling convention for WinAPI functions.
//! - @c CALL_CONV_MSTHISCALL - Calling convention for C++ members under 
//!      Windows (produced by MSVC and all MSVC compatible compilers).
//! - @c CALL_CONV_MSFASTCALL - Fastest calling convention that can be used
//!      by MSVC compiler.
//! - @c CALL_CONV_BORNANDFASTCALL - Borland fastcall convention.
//! - @c CALL_CONV_GCCFASTCALL - GCC fastcall convention (2 register arguments).
//! - @c CALL_CONV_GCCREGPARM_1 - GCC regparm(1) convention.
//! - @c CALL_CONV_GCCREGPARM_2 - GCC regparm(2) convention.
//! - @c CALL_CONV_GCCREGPARM_3 - GCC regparm(3) convention.
//!
//! List of calling conventions for 64-bit x86 mode (x64):
//! - @c CALL_CONV_X64W - Windows 64-bit calling convention (WIN64 ABI).
//! - @c CALL_CONV_X64U - Unix 64-bit calling convention (AMD64 ABI).
//!
//! There is also @c CALL_CONV_DEFAULT that is defined to fit best to your 
//! compiler.
//!
//! These types are used together with @c AsmJit::Compiler::newFunction() 
//! method.
enum CALL_CONV
{
  //! @brief Calling convention is invalid (can't be used).
  CALL_CONV_NONE = 0,

  // [X64 Calling Conventions]

  //! @brief X64 calling convention for Windows platform (WIN64 ABI).
  //!
  //! For first four arguments are used these registers:
  //! - 1. 32/64-bit integer or floating point argument - rcx/xmm0
  //! - 2. 32/64-bit integer or floating point argument - rdx/xmm1
  //! - 3. 32/64-bit integer or floating point argument - r8/xmm2
  //! - 4. 32/64-bit integer or floating point argument - r9/xmm3
  //!
  //! Note first four arguments here means arguments at positions from 1 to 4
  //! (included). For example if second argument is not passed by register then
  //! rdx/xmm1 register is unused.
  //!
  //! All other arguments are pushed on the stack in right-to-left direction.
  //! Stack is aligned by 16 bytes. There is 32-byte shadow space on the stack
  //! that can be used to save up to four 64-bit registers (probably designed to
  //! be used to save first four arguments passed in registers).
  //!
  //! Arguments direction:
  //! - Right to Left (except for first 4 parameters that's in registers)
  //!
  //! Stack is cleaned by:
  //! - Caller.
  //!
  //! Return value:
  //! - Integer types - RAX register.
  //! - Floating points - XMM0 register.
  //!
  //! Stack is always aligned by 16 bytes.
  //!
  //! More information about this calling convention can be found on MSDN:
  //! http://msdn.microsoft.com/en-us/library/9b372w95.aspx .
  CALL_CONV_X64W = 1,

  //! @brief X64 calling convention for Unix platforms (AMD64 ABI).
  //!
  //! First six 32 or 64-bit integer arguments are passed in rdi, rsi, rdx, 
  //! rcx, r8, r9 registers. First eight floating point or XMM arguments 
  //! are passed in xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7 registers.
  //! This means that in registers can be transferred up to 14 arguments total.
  //!
  //! There is also RED ZONE below the stack pointer that can be used for 
  //! temporary storage. The red zone is the space from [rsp-128] to [rsp-8].
  //! 
  //! Arguments direction:
  //! - Right to Left (Except for arguments passed in registers).
  //!
  //! Stack is cleaned by:
  //! - Caller.
  //!
  //! Return value:
  //! - Integer types - RAX register.
  //! - Floating points - XMM0 register.
  //!
  //! Stack is always aligned by 16 bytes.
  CALL_CONV_X64U = 2,

  // [X86 Calling Conventions]

  //! @brief Cdecl calling convention (used by C runtime).
  //!
  //! Compatible across MSVC and GCC.
  //!
  //! Arguments direction:
  //! - Right to Left
  //!
  //! Stack is cleaned by:
  //! - Caller.
  CALL_CONV_CDECL = 3,

  //! @brief Stdcall calling convention (used by WinAPI).
  //!
  //! Compatible across MSVC and GCC.
  //!
  //! Arguments direction:
  //! - Right to Left
  //!
  //! Stack is cleaned by:
  //! - Callee.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  CALL_CONV_STDCALL = 4,

  //! @brief MSVC specific calling convention used by MSVC/Intel compilers
  //! for struct/class methods.
  //!
  //! This is MSVC (and Intel) only calling convention used in Windows
  //! world for C++ class methods. Implicit 'this' pointer is stored in
  //! ECX register instead of storing it on the stack.
  //!
  //! Arguments direction:
  //! - Right to Left (except this pointer in ECX)
  //!
  //! Stack is cleaned by:
  //! - Callee.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  //!
  //! C++ class methods that have variable count of arguments uses different
  //! calling convention called cdecl.
  //!
  //! @note This calling convention is always used by MSVC for class methods,
  //! it's implicit and there is no way how to override it.
  CALL_CONV_MSTHISCALL = 5,

  //! @brief MSVC specific fastcall.
  //!
  //! Two first parameters (evaluated from left-to-right) are in ECX:EDX 
  //! registers, all others on the stack in right-to-left order.
  //!
  //! Arguments direction:
  //! - Right to Left (except to first two integer arguments in ECX:EDX)
  //!
  //! Stack is cleaned by:
  //! - Callee.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  //!
  //! @note This calling convention differs to GCC one in stack cleaning
  //! mechanism.
  CALL_CONV_MSFASTCALL = 6,

  //! @brief Borland specific fastcall with 2 parameters in registers.
  //!
  //! Two first parameters (evaluated from left-to-right) are in ECX:EDX 
  //! registers, all others on the stack in left-to-right order.
  //!
  //! Arguments direction:
  //! - Left to Right (except to first two integer arguments in ECX:EDX)
  //!
  //! Stack is cleaned by:
  //! - Callee.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  //!
  //! @note Arguments on the stack are in left-to-right order that differs
  //! to other fastcall conventions used in different compilers.
  CALL_CONV_BORLANDFASTCALL = 7,

  //! @brief GCC specific fastcall convention.
  //!
  //! Two first parameters (evaluated from left-to-right) are in ECX:EDX 
  //! registers, all others on the stack in right-to-left order.
  //!
  //! Arguments direction:
  //! - Right to Left (except to first two integer arguments in ECX:EDX)
  //!
  //! Stack is cleaned by:
  //! - Callee.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  //!
  //! @note This calling convention should be compatible to
  //! @c CALL_CONV_MSFASTCALL.
  CALL_CONV_GCCFASTCALL = 8,

  //! @brief GCC specific regparm(1) convention.
  //!
  //! The first parameter (evaluated from left-to-right) is in EAX register,
  //! all others on the stack in right-to-left order.
  //!
  //! Arguments direction:
  //! - Right to Left (except to first one integer argument in EAX)
  //!
  //! Stack is cleaned by:
  //! - Caller.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  CALL_CONV_GCCREGPARM_1 = 9,

  //! @brief GCC specific regparm(2) convention.
  //!
  //! Two first parameters (evaluated from left-to-right) are in EAX:EDX 
  //! registers, all others on the stack in right-to-left order.
  //!
  //! Arguments direction:
  //! - Right to Left (except to first two integer arguments in EAX:EDX)
  //!
  //! Stack is cleaned by:
  //! - Caller.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  CALL_CONV_GCCREGPARM_2 = 10,

  //! @brief GCC specific fastcall with 3 parameters in registers.
  //!
  //! Three first parameters (evaluated from left-to-right) are in 
  //! EAX:EDX:ECX registers, all others on the stack in right-to-left order.
  //!
  //! Arguments direction:
  //! - Right to Left (except to first three integer arguments in EAX:EDX:ECX)
  //!
  //! Stack is cleaned by:
  //! - Caller.
  //!
  //! Return value:
  //! - Integer types - EAX:EDX registers.
  //! - Floating points - st(0) register.
  CALL_CONV_GCCREGPARM_3 = 11,

  // [Preferred Calling Convention]

  //! @def CALL_CONV_DEFAULT
  //! @brief Default calling convention for current platform / operating system.

#if defined(ASMJIT_X86)

  CALL_CONV_DEFAULT = CALL_CONV_CDECL,

# if defined(_MSC_VER)
  CALL_CONV_COMPAT_FASTCALL = CALL_CONV_MSFASTCALL,
# elif defined(__GNUC__)
  CALL_CONV_COMPAT_FASTCALL = CALL_CONV_GCCFASTCALL,
# elif defined(__BORLANDC__)
  CALL_CONV_COMPAT_FASTCALL = CALL_CONV_BORLANDFASTCALL,
# else
#  error "AsmJit::CALL_CONV_COMPATIBLE_FASTCALL_2 - Unsupported."
# endif

  CALL_CONV_COMPAT_STDCALL = CALL_CONV_STDCALL,
  CALL_CONV_COMPAT_CDECL   = CALL_CONV_CDECL

#else  // ASMJIT_X86

# if defined(ASMJIT_WINDOWS)
  CALL_CONV_DEFAULT = CALL_CONV_X64W,
# else
  CALL_CONV_DEFAULT = CALL_CONV_X64U,
# endif

  CALL_CONV_COMPAT_FASTCALL = CALL_CONV_DEFAULT,
  CALL_CONV_COMPAT_STDCALL = CALL_CONV_DEFAULT,
  CALL_CONV_COMPAT_CDECL = CALL_CONV_DEFAULT

#endif // ASMJIT_X86
};

// ============================================================================
// [AsmJit::VARIABLE_TYPE]
// ============================================================================

enum VARIABLE_TYPE
{
  VARIABLE_TYPE_GPD = 0,  // Variable is 32-bit general purpose register.
  VARIABLE_TYPE_GPQ = 1,  // Variable is 64-bit general purpose register.

  // VARIABLE_TYPE_GPN - Variable is system wide general purpose register (32-bit or 64-bit).
#if defined(ASMJIT_X86)
  VARIABLE_TYPE_GPN = VARIABLE_TYPE_GPD,
#else
  VARIABLE_TYPE_GPN = VARIABLE_TYPE_GPQ,
#endif

  //! @brief Variable is X87 (FPU).
  VARIABLE_TYPE_X87    = 2,

  //! @brief Variable is X87 (FPU) SP-FP number (float).
  VARIABLE_TYPE_X87_1F = 3,

  //! @brief Variable is X87 (FPU) DP-FP number (double).
  VARIABLE_TYPE_X87_1D = 4,

  //! @brief Variable is MM register / memory location.
  VARIABLE_TYPE_MM     = 5,

  //! @brief Variable is XMM register / memory location.
  VARIABLE_TYPE_XMM    = 6,

  //! @brief Variable is SSE scalar SP-FP number.
  VARIABLE_TYPE_XMM_1F = 7,
  //! @brief Variable is SSE packed SP-FP number (4 floats).
  VARIABLE_TYPE_XMM_4F = 8,

  //! @brief Variable is SSE2 scalar DP-FP number.
  VARIABLE_TYPE_XMM_1D = 9,
  //! @brief Variable is SSE2 packed DP-FP number (2 doubles).
  VARIABLE_TYPE_XMM_2D = 10,

  //! @brief Count of variable types.
  _VARIABLE_TYPE_COUNT = 11,

  // --------------------------------------------------------------------------
  // [Platform Independent]
  // --------------------------------------------------------------------------

  //! @brief Variable is 32-bit integer.
  VARIABLE_TYPE_INT32 = VARIABLE_TYPE_GPD,
  //! @brief Variable is 64-bit integer.
  VARIABLE_TYPE_INT64 = VARIABLE_TYPE_GPQ,
  //! @brief Variable is system dependent integer / pointer.
  VARIABLE_TYPE_INTPTR = VARIABLE_TYPE_GPN,

#if !defined(ASMJIT_NODOC)
#if defined(ASMJIT_X86)
  VARIABLE_TYPE_FLOAT  = VARIABLE_TYPE_X87_1F,
  VARIABLE_TYPE_DOUBLE = VARIABLE_TYPE_X87_1D
#else
  VARIABLE_TYPE_FLOAT  = VARIABLE_TYPE_XMM_1F,
  VARIABLE_TYPE_DOUBLE = VARIABLE_TYPE_XMM_1D
#endif
#else  // ASMJIT_NODOC
  VARIABLE_TYPE_FLOAT  = XXX,  // Variable is SP-FP (x87 or xmm).
  VARIABLE_TYPE_DOUBLE = XXX   // Variable is DP-FP (x87 or xmm).
#endif
};

// ============================================================================
// [AsmJit::VARIABLE_HINT]
// ============================================================================

//! @brief Variable hint (used by @ref Compiler).
//!
//! @sa @ref Compiler.
enum VARIABLE_HINT
{
  //! @brief Alloc variable.
  VARIABLE_HINT_ALLOC = 0,
  //! @brief Spill variable.
  VARIABLE_HINT_SPILL = 1,
  //! @brief Save variable if modified.
  VARIABLE_HINT_SAVE  = 2,
  //! @brief Save variable if modified and mark it as unused.
  VARIABLE_HINT_SAVE_AND_UNUSE = 3,
  //! @brief Mark variable as unused.
  VARIABLE_HINT_UNUSE = 4
};

} // AsmJit namespace

#include "ApiEnd.h"    // [Api-End]

#endif // _ASMJIT_DEFSX86X64_H

```

`AsmJit/Logger.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// We are using sprintf() here.
#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif // _MSC_VER

// [Dependencies]
#include "Logger.h"

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::Logger]
// ============================================================================

Logger::Logger() ASMJIT_NOTHROW :
  _enabled(true),
  _used(true),
  _logBinary(false)
{
}

Logger::~Logger() ASMJIT_NOTHROW
{
}

void Logger::logFormat(const char* fmt, ...) ASMJIT_NOTHROW
{
  char buf[1024];
  sysuint_t len;

  va_list ap;
  va_start(ap, fmt);
  len = vsnprintf(buf, 1023, fmt, ap);
  va_end(ap);

  logString(buf, len);
}

void Logger::setEnabled(bool enabled) ASMJIT_NOTHROW
{
  _enabled = enabled;
  _used = enabled;
}

// ============================================================================
// [AsmJit::FileLogger]
// ============================================================================

FileLogger::FileLogger(FILE* stream) ASMJIT_NOTHROW
  : _stream(NULL)
{
  setStream(stream);
}

void FileLogger::logString(const char* buf, sysuint_t len) ASMJIT_NOTHROW
{
  if (!_used) return;

  if (len == (sysuint_t)-1)
      len = (sysuint_t)strlen(buf);
  fwrite(buf, 1, len, _stream);
}

void FileLogger::setEnabled(bool enabled) ASMJIT_NOTHROW
{
  _enabled = enabled;
  _used = (_enabled == true) & (_stream != NULL);
}

//! @brief Set file stream.
void FileLogger::setStream(FILE* stream) ASMJIT_NOTHROW
{
  _stream = stream;
  _used = (_enabled == true) & (_stream != NULL);
}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/Logger.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_LOGGER_H
#define _ASMJIT_LOGGER_H

// [Dependencies]
#include "Defs.h"

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

//! @addtogroup AsmJit_Logging
//! @{

//! @brief Abstract logging class.
//!
//! This class can be inherited and reimplemented to fit into your logging
//! subsystem. When reimplementing use @c AsmJit::Logger::log() method to
//! log into your stream.
//!
//! This class also contain @c _enabled member that can be used to enable
//! or disable logging.
struct ASMJIT_API Logger
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create logger.
  Logger() ASMJIT_NOTHROW;
  //! @brief Destroy logger.
  virtual ~Logger() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  //! @brief Abstract method to log output.
  //!
  //! Default implementation that is in @c AsmJit::Logger is to do nothing.
  //! It's virtual to fit to your logging system.
  virtual void logString(const char* buf, sysuint_t len = (sysuint_t)-1) ASMJIT_NOTHROW = 0;

  //! @brief Log formatter message (like sprintf) sending output to @c logString() method.
  virtual void logFormat(const char* fmt, ...) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Enabled]
  // --------------------------------------------------------------------------

  //! @brief Return @c true if logging is enabled.
  inline bool isEnabled() const ASMJIT_NOTHROW { return _enabled; }

  //! @brief Set logging to enabled or disabled.
  virtual void setEnabled(bool enabled) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Used]
  // --------------------------------------------------------------------------

  //! @brief Get whether the logger should be used.
  inline bool isUsed() const ASMJIT_NOTHROW { return _used; }

  // --------------------------------------------------------------------------
  // [LogBinary]
  // --------------------------------------------------------------------------

  //! @brief Get whether logging binary output.
  inline bool getLogBinary() const { return _logBinary; }
  //! @brief Get whether to log binary output.
  inline void setLogBinary(bool val) { _logBinary = val; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:

  //! @brief Whether logger is enabled or disabled.
  //!
  //! Default @c true.
  bool _enabled;

  //! @brief Whether logger is enabled and can be used.
  //!
  //! This value can be set by inherited classes to inform @c Logger that
  //! assigned stream (or something that can log output) is invalid. If
  //! @c _used is false it means that there is no logging output and AsmJit
  //! shouldn't use this logger (because all messages will be lost).
  //!
  //! This is designed only to optimize cases that logger exists, but its
  //! configured not to output messages. The API inside Logging and AsmJit
  //! should only check this value when needed. The API outside AsmJit should
  //! check only whether logging is @c _enabled.
  //!
  //! Default @c true.
  bool _used;

  //! @brief Whether to log instruction in binary form.
  bool _logBinary;

private:
  ASMJIT_DISABLE_COPY(Logger)
};

//! @brief Logger that can log to standard C @c FILE* stream.
struct ASMJIT_API FileLogger : public Logger
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new @c FileLogger.
  //! @param stream FILE stream where logging will be sent (can be @c NULL
  //! to disable logging).
  FileLogger(FILE* stream = NULL) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Logging]
  // --------------------------------------------------------------------------

  virtual void logString(const char* buf, sysuint_t len = (sysuint_t)-1) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Enabled]
  // --------------------------------------------------------------------------

  virtual void setEnabled(bool enabled) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Stream]
  // --------------------------------------------------------------------------

  //! @brief Get @c FILE* stream.
  //!
  //! @note Return value can be @c NULL.
  inline FILE* getStream() const ASMJIT_NOTHROW { return _stream; }

  //! @brief Set @c FILE* stream.
  //!
  //! @param stream @c FILE stream where to log output (can be @c NULL to
  //! disable logging).
  void setStream(FILE* stream) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief C file stream.
  FILE* _stream;

  ASMJIT_DISABLE_COPY(FileLogger)
};

//! @}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

// [Guard]
#endif // _ASMJIT_LOGGER_H

```

`AsmJit/MemoryManager.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "Build.h"
#include "MemoryManager.h"
#include "Platform.h"

#include <stdio.h>
#include <string.h>

#include <new>

// [Api-Begin]
#include "ApiBegin.h"

// This file contains implementation of virtual memory management for AsmJit
// library. The initial concept is to keep this implementation simple but 
// efficient. There are several goals I decided to write implementation myself.
//
// Goals:
// - We need usually to allocate blocks of 64 bytes long and more.
// - Alignment of allocated blocks is large - 32 bytes or 64 bytes.
// - Keep memory manager information outside allocated virtual memory pages
//   (these pages allows execution of code).
// - Keep implementation small.
//
// I think that implementation is not small and probably not too much readable,
// so there is small know how.
//
// - Implementation is based on bit arrays and binary trees. Bit arrays 
//   contains information about allocated and unused blocks of memory. Each
//   block size describes MemNode::density member. Count of blocks are
//   stored in MemNode::blocks member. For example if density is 64 and 
//   count of blocks is 20, memory node contains 64*20 bytes of memory and
//   smallest possible allocation (and also alignment) is 64 bytes. So density
//   describes also memory alignment. Binary trees are used to enable fast
//   lookup into all addresses allocated by memory manager instance. This is
//   used mainly in MemoryManagerPrivate::free().
//
//   Bit array looks like this (empty = unused, X = used) - Size of block 64
//   -------------------------------------------------------------------------
//   | |X|X| | | | | |X|X|X|X|X|X| | | | | | | | | | | | |X| | | | |X|X|X| | |
//   -------------------------------------------------------------------------
//   Bits array shows that there are 12 allocated blocks of 64 bytes, so total 
//   allocated size is 768 bytes. Maximum count of continuous blocks is 12
//   (see largest gap).

namespace AsmJit {

// ============================================================================
// [Bits Manipulation]
// ============================================================================

#define BITS_PER_ENTITY (sizeof(sysuint_t) * 8)

static void _SetBit(sysuint_t* buf, sysuint_t index) ASMJIT_NOTHROW
{
  sysuint_t i = index / BITS_PER_ENTITY; // sysuint_t[]
  sysuint_t j = index % BITS_PER_ENTITY; // sysuint_t[][] bit index

  buf += i;
  *buf |= (sysuint_t)1 << j;
}

static void _ClearBit(sysuint_t* buf, sysuint_t index) ASMJIT_NOTHROW
{
  sysuint_t i = index / BITS_PER_ENTITY; // sysuint_t[]
  sysuint_t j = index % BITS_PER_ENTITY; // sysuint_t[][] bit index

  buf += i;
  *buf &= ~((sysuint_t)1 << j);
}

static void _SetBits(sysuint_t* buf, sysuint_t index, sysuint_t len) ASMJIT_NOTHROW
{
  if (len == 0) return;

  sysuint_t i = index / BITS_PER_ENTITY; // sysuint_t[]
  sysuint_t j = index % BITS_PER_ENTITY; // sysuint_t[][] bit index

  // How many bytes process in the first group.
  sysuint_t c = BITS_PER_ENTITY - j;
  if (c > len) c = len;

  // Offset.
  buf += i;

  *buf++ |= (((sysuint_t)-1) >> (BITS_PER_ENTITY - c)) << j;
  len -= c;

  while (len >= BITS_PER_ENTITY)
  {
    *buf++ = (sysuint_t)-1;
    len -= BITS_PER_ENTITY;
  }

  if (len)
  {
    *buf |= (((sysuint_t)-1) >> (BITS_PER_ENTITY - len));
  }
}

static void _ClearBits(sysuint_t* buf, sysuint_t index, sysuint_t len) ASMJIT_NOTHROW
{
  if (len == 0) return;

  sysuint_t i = index / BITS_PER_ENTITY; // sysuint_t[]
  sysuint_t j = index % BITS_PER_ENTITY; // sysuint_t[][] bit index

  // How many bytes process in the first group.
  sysuint_t c = BITS_PER_ENTITY - j;
  if (c > len) c = len;

  // Offset.
  buf += i;

  *buf++ &= ~((((sysuint_t)-1) >> (BITS_PER_ENTITY - c)) << j);
  len -= c;

  while (len >= BITS_PER_ENTITY)
  {
    *buf++ = 0;
    len -= BITS_PER_ENTITY;
  }

  if (len)
  {
    *buf &= ((sysuint_t)-1) << len;
  }
}

// ============================================================================
// [AsmJit::MemNode]
// ============================================================================

#define M_DIV(x, y) ((x) / (y))
#define M_MOD(x, y) ((x) % (y))

template<typename T>
struct ASMJIT_HIDDEN RbNode
{
  // --------------------------------------------------------------------------
  // [Node red-black tree tree, key is mem pointer].
  // --------------------------------------------------------------------------

  // Implementation is based on article by Julienne Walker (Public Domain),
  // including C code and original comments. Thanks for the excellent article.

  // Left[0] and right[1] nodes.
  T* node[2];
  // Whether the node is RED.
  uint32_t red;

  // --------------------------------------------------------------------------
  // [Chunk Memory]
  // --------------------------------------------------------------------------

  // Virtual memory address.
  uint8_t* mem;
};

// Get whether the node is red (NULL or node with red flag).
template<typename T>
inline bool isRed(RbNode<T>* node)
{
  return node != NULL && node->red;
}

struct ASMJIT_HIDDEN MemNode : public RbNode<MemNode>
{
  // --------------------------------------------------------------------------
  // [Node double-linked list]
  // --------------------------------------------------------------------------

  MemNode* prev;           // Prev node in list.
  MemNode* next;           // Next node in list.

  // --------------------------------------------------------------------------
  // [Chunk Data]
  // --------------------------------------------------------------------------

  sysuint_t size;          // How many bytes contain this node.
  sysuint_t blocks;        // How many blocks are here.
  sysuint_t density;       // Minimum count of allocated bytes in this node (also alignment).
  sysuint_t used;          // How many bytes are used in this node.
  sysuint_t largestBlock;  // Contains largest block that can be allocated.

  sysuint_t* baUsed;       // Contains bits about used blocks.
                           // (0 = unused, 1 = used).
  sysuint_t* baCont;       // Contains bits about continuous blocks.
                           // (0 = stop, 1 = continue).

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  // Get available space.
  inline sysuint_t getAvailable() const ASMJIT_NOTHROW { return size - used; }

  inline void fillData(MemNode* other)
  {
    mem = other->mem;

    size = other->size;
    blocks = other->blocks;
    density = other->density;
    used = other->used;
    largestBlock = other->largestBlock;
    baUsed = other->baUsed;
    baCont = other->baCont;
  }
};

// ============================================================================
// [AsmJit::M_Permanent]
// ============================================================================

//! @brief Permanent node.
struct ASMJIT_HIDDEN PermanentNode
{
  uint8_t* mem;            // Base pointer (virtual memory address).
  sysuint_t size;          // Count of bytes allocated.
  sysuint_t used;          // Count of bytes used.
  PermanentNode* prev;     // Pointer to prev chunk or NULL.

  // Get available space.
  inline sysuint_t getAvailable() const ASMJIT_NOTHROW { return size - used; }
};

// ============================================================================
// [AsmJit::MemoryManagerPrivate]
// ============================================================================

struct ASMJIT_HIDDEN MemoryManagerPrivate
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_WINDOWS)
  MemoryManagerPrivate() ASMJIT_NOTHROW;
#else
  MemoryManagerPrivate(HANDLE hProcess) ASMJIT_NOTHROW;
#endif // ASMJIT_WINDOWS
  ~MemoryManagerPrivate() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Allocation]
  // --------------------------------------------------------------------------

  MemNode* createNode(sysuint_t size, sysuint_t density) ASMJIT_NOTHROW;

  void* allocPermanent(sysuint_t vsize) ASMJIT_NOTHROW;
  void* allocFreeable(sysuint_t vsize) ASMJIT_NOTHROW;

  bool free(void* address) ASMJIT_NOTHROW;
  bool shrink(void* address, sysuint_t used) ASMJIT_NOTHROW;
  void freeAll(bool keepVirtualMemory) ASMJIT_NOTHROW;

  // Helpers to avoid ifdefs in the code.
  inline uint8_t* allocVirtualMemory(sysuint_t size, sysuint_t* vsize) ASMJIT_NOTHROW
  {
#if !defined(ASMJIT_WINDOWS)
    return (uint8_t*)VirtualMemory::alloc(size, vsize, true);
#else
    return (uint8_t*)VirtualMemory::allocProcessMemory(_hProcess, size, vsize, true);
#endif
  }

  inline void freeVirtualMemory(void* vmem, sysuint_t vsize) ASMJIT_NOTHROW
  {
#if !defined(ASMJIT_WINDOWS)
    VirtualMemory::free(vmem, vsize);
#else
    VirtualMemory::freeProcessMemory(_hProcess, vmem, vsize);
#endif
  }

  // --------------------------------------------------------------------------
  // [NodeList RB-Tree]
  // --------------------------------------------------------------------------

  bool checkTree() ASMJIT_NOTHROW;

  void insertNode(MemNode* node) ASMJIT_NOTHROW;
  MemNode* removeNode(MemNode* node) ASMJIT_NOTHROW;
  MemNode* findPtr(uint8_t* mem) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_WINDOWS)
  HANDLE _hProcess;            // Process where to allocate memory.
#endif // ASMJIT_WINDOWS
  Lock _lock;                  // Lock for thread safety.

  sysuint_t _newChunkSize;     // Default node size.
  sysuint_t _newChunkDensity;  // Default node density.
  sysuint_t _allocated;        // How many bytes are allocated.
  sysuint_t _used;             // How many bytes are used.

  // Memory nodes list.
  MemNode* _first;
  MemNode* _last;
  MemNode* _optimal;

  // Memory nodes tree.
  MemNode* _root;

  // Permanent memory.
  PermanentNode* _permanent;

  // Whether to keep virtual memory after destroy.
  bool _keepVirtualMemory;
};

// ============================================================================
// [AsmJit::MemoryManagerPrivate - Construction / Destruction]
// ============================================================================

#if !defined(ASMJIT_WINDOWS)
MemoryManagerPrivate::MemoryManagerPrivate() ASMJIT_NOTHROW :
#else
MemoryManagerPrivate::MemoryManagerPrivate(HANDLE hProcess) ASMJIT_NOTHROW :
  _hProcess(hProcess),
#endif
  _newChunkSize(65536),
  _newChunkDensity(64),
  _allocated(0),
  _used(0),
  _root(NULL),
  _first(NULL),
  _last(NULL),
  _optimal(NULL),
  _permanent(NULL),
  _keepVirtualMemory(false)
{
}

MemoryManagerPrivate::~MemoryManagerPrivate() ASMJIT_NOTHROW
{
  // Freeable memory cleanup - Also frees the virtual memory if configured to.
  freeAll(_keepVirtualMemory);

  // Permanent memory cleanup - Never frees the virtual memory.
  PermanentNode* node = _permanent;
  while (node)
  {
    PermanentNode* prev = node->prev;
    ASMJIT_FREE(node);
    node = prev;
  }
}

// ============================================================================
// [AsmJit::MemoryManagerPrivate - Allocation]
// ============================================================================

// Allocates virtual memory node and MemNode structure.
//
// Returns MemNode* on success, otherwise NULL.
MemNode* MemoryManagerPrivate::createNode(sysuint_t size, sysuint_t density) ASMJIT_NOTHROW
{
  sysuint_t vsize;
  uint8_t* vmem = allocVirtualMemory(size, &vsize);

  // Out of memory.
  if (vmem == NULL) return NULL;

  sysuint_t blocks = (vsize / density);
  sysuint_t bsize = (((blocks + 7) >> 3) + sizeof(sysuint_t) - 1) & ~(sysuint_t)(sizeof(sysuint_t)-1);

  MemNode* node = reinterpret_cast<MemNode*>(ASMJIT_MALLOC(sizeof(MemNode)));
  uint8_t* data = reinterpret_cast<uint8_t*>(ASMJIT_MALLOC(bsize * 2));

  // Out of memory.
  if (node == NULL || data == NULL)
  {
    freeVirtualMemory(vmem, vsize);
    if (node) ASMJIT_FREE(node);
    if (data) ASMJIT_FREE(data);
    return NULL;
  }

  // Initialize RbNode data.
  node->node[0] = NULL;
  node->node[1] = NULL;
  node->red = 1;
  node->mem = vmem;

  // Initialize MemNode data.
  node->prev = NULL;
  node->next = NULL;

  node->size = vsize;
  node->blocks = blocks;
  node->density = density;
  node->used = 0;
  node->largestBlock = vsize;

  memset(data, 0, bsize * 2);
  node->baUsed = reinterpret_cast<sysuint_t*>(data);
  node->baCont = reinterpret_cast<sysuint_t*>(data + bsize);

  return node;
}

void* MemoryManagerPrivate::allocPermanent(sysuint_t vsize) ASMJIT_NOTHROW
{
  static const sysuint_t permanentAlignment = 32;
  static const sysuint_t permanentNodeSize  = 32768;

  sysuint_t over = vsize % permanentAlignment;
  if (over) over = permanentAlignment - over;
  sysuint_t alignedSize = vsize + over;

  AutoLock locked(_lock);

  PermanentNode* node = _permanent;

  // Try to find space in allocated chunks.
  while (node && alignedSize > node->getAvailable()) node = node->prev;

  // Or allocate new node.
  if (!node)
  {
    sysuint_t nodeSize = permanentNodeSize;
    if (vsize > nodeSize) nodeSize = vsize;

    node = (PermanentNode*)ASMJIT_MALLOC(sizeof(PermanentNode));
    // Out of memory.
    if (node == NULL) return NULL;

    node->mem = allocVirtualMemory(nodeSize, &node->size);
    // Out of memory.
    if (node->mem == NULL) 
    {
      ASMJIT_FREE(node);
      return NULL;
    }

    node->used = 0;
    node->prev = _permanent;
    _permanent = node;
  }

  // Finally, copy function code to our space we reserved for.
  uint8_t* result = node->mem + node->used;

  // Update Statistics.
  node->used += alignedSize;
  _used += alignedSize;

  // Code can be null to only reserve space for code.
  return (void*)result;
}

void* MemoryManagerPrivate::allocFreeable(sysuint_t vsize) ASMJIT_NOTHROW
{
  sysuint_t i;               // Current index.
  sysuint_t need;            // How many we need to be freed.
  sysuint_t minVSize;

  // Align to 32 bytes (our default alignment).
  vsize = (vsize + 31) & ~(sysuint_t)31;
  if (vsize == 0) return NULL;

  AutoLock locked(_lock);
  MemNode* node = _optimal;

  minVSize = _newChunkSize;

  // Try to find memory block in existing nodes.
  while (node)
  {
    // Skip this node?
    if ((node->getAvailable() < vsize) || 
        (node->largestBlock < vsize && node->largestBlock != 0))
    {
      MemNode* next = node->next;
      if (node->getAvailable() < minVSize && node == _optimal && next) _optimal = next;
      node = next;
      continue;
    }

    sysuint_t* up = node->baUsed;    // Current ubits address.
    sysuint_t ubits;                 // Current ubits[0] value.
    sysuint_t bit;                   // Current bit mask.
    sysuint_t blocks = node->blocks; // Count of blocks in node.
    sysuint_t cont = 0;              // How many bits are currently freed in find loop.
    sysuint_t maxCont = 0;           // Largest continuous block (bits count).
    sysuint_t j;

    need = M_DIV((vsize + node->density - 1), node->density);
    i = 0;

    // Try to find node that is large enough.
    while (i < blocks)
    {
      ubits = *up++;

      // Fast skip used blocks.
      if (ubits == (sysuint_t)-1)
      { 
        if (cont > maxCont) maxCont = cont;
        cont = 0;

        i += BITS_PER_ENTITY;
        continue;
      }

      sysuint_t max = BITS_PER_ENTITY;
      if (i + max > blocks) max = blocks - i;

      for (j = 0, bit = 1; j < max; bit <<= 1)
      {
        j++;
        if ((ubits & bit) == 0)
        {
          if (++cont == need) { i += j; i -= cont; goto found; }
          continue;
        }

        if (cont > maxCont) maxCont = cont;
        cont = 0;
      }

      i += BITS_PER_ENTITY;
    }

    // Because we traversed entire node, we can set largest node size that
    // will be used to cache next traversing..
    node->largestBlock = maxCont * node->density;

    node = node->next;
  }

  // If we are here, we failed to find existing memory block and we must
  // allocate new.
  {
    sysuint_t chunkSize = _newChunkSize;
    if (chunkSize < vsize) chunkSize = vsize;

    node = createNode(chunkSize, _newChunkDensity);
    if (node == NULL) return NULL;

    // Update binary tree.
    insertNode(node);
    ASMJIT_ASSERT(checkTree());

    // Alloc first node at start.
    i = 0;
    need = (vsize + node->density - 1) / node->density;

    // Update statistics.
    _allocated += node->size;
  }

found:
  // Update bits.
  _SetBits(node->baUsed, i, need);
  _SetBits(node->baCont, i, need - 1);

  // Update statistics.
  {
    sysuint_t u = need * node->density;
    node->used += u;
    node->largestBlock = 0;
    _used += u;
  }

  // And return pointer to allocated memory.
  uint8_t* result = node->mem + i * node->density;
  ASMJIT_ASSERT(result >= node->mem && result <= node->mem + node->size - vsize);
  return result;
}

bool MemoryManagerPrivate::free(void* address) ASMJIT_NOTHROW
{
  if (address == NULL) return true;

  AutoLock locked(_lock);

  MemNode* node = findPtr((uint8_t*)address);
  if (node == NULL)
    return false;

  sysuint_t offset = (sysuint_t)((uint8_t*)address - (uint8_t*)node->mem);
  sysuint_t bitpos = M_DIV(offset, node->density);
  sysuint_t i = (bitpos / BITS_PER_ENTITY);

  sysuint_t* up = node->baUsed + i;  // Current ubits address.
  sysuint_t* cp = node->baCont + i;  // Current cbits address.
  sysuint_t ubits = *up;             // Current ubits[0] value.
  sysuint_t cbits = *cp;             // Current cbits[0] value.
  sysuint_t bit = (sysuint_t)1 << (bitpos % BITS_PER_ENTITY);

  sysuint_t cont = 0;
  bool stop;

  for (;;)
  {
    stop = (cbits & bit) == 0;
    ubits &= ~bit;
    cbits &= ~bit;

    bit <<= 1;
    cont++;

    if (stop || bit == 0)
    {
      *up = ubits;
      *cp = cbits;
      if (stop) break;

      ubits = *++up;
      cbits = *++cp;
      bit = 1;
    }
  }

  // If the freed block is fully allocated node then it's needed to 
  // update 'optimal' pointer in memory manager.
  if (node->used == node->size)
  {
    MemNode* cur = _optimal;

    do {
      cur = cur->prev;
      if (cur == node) { _optimal = node; break; }
    } while (cur);
  }

  // Statistics.
  cont *= node->density;
  if (node->largestBlock < cont) node->largestBlock = cont;
  node->used -= cont;
  _used -= cont;

  // If page is empty, we can free it.
  if (node->used == 0)
  {
    // Free memory associated with node (this memory is not accessed
    // anymore so it's safe).
    freeVirtualMemory(node->mem, node->size);
    ASMJIT_FREE(node->baUsed);

    node->baUsed = NULL;
    node->baCont = NULL;

    // Statistics.
    _allocated -= node->size;

    // Remove node. This function can return different node than
    // passed into, but data is copied into previous node if needed.
    ASMJIT_FREE(removeNode(node));
    ASMJIT_ASSERT(checkTree());
  }

  return true;
}

bool MemoryManagerPrivate::shrink(void* address, sysuint_t used) ASMJIT_NOTHROW
{
  if (address == NULL) return false;
  if (used == 0) return free(address);

  AutoLock locked(_lock);

  MemNode* node = findPtr((uint8_t*)address);
  if (node == NULL)
    return false;

  sysuint_t offset = (sysuint_t)((uint8_t*)address - (uint8_t*)node->mem);
  sysuint_t bitpos = M_DIV(offset, node->density);
  sysuint_t i = (bitpos / BITS_PER_ENTITY);

  sysuint_t* up = node->baUsed + i;  // Current ubits address.
  sysuint_t* cp = node->baCont + i;  // Current cbits address.
  sysuint_t ubits = *up;             // Current ubits[0] value.
  sysuint_t cbits = *cp;             // Current cbits[0] value.
  sysuint_t bit = (sysuint_t)1 << (bitpos % BITS_PER_ENTITY);

  sysuint_t cont = 0;
  sysuint_t usedBlocks = (used + node->density - 1) / node->density;

  bool stop;

  // Find the first block we can mark as free.
  for (;;)
  {
    stop = (cbits & bit) == 0;
    if (stop) return true;

    if (++cont == usedBlocks) break;

    bit <<= 1;
    if (bit == 0)
    {
      ubits = *++up;
      cbits = *++cp;
      bit = 1;
    }
  }

  // Free the tail blocks.
  cont = (sysuint_t)-1;
  goto enterFreeLoop;

  for (;;)
  {
    stop = (cbits & bit) == 0;
    ubits &= ~bit;
enterFreeLoop:
    cbits &= ~bit;

    bit <<= 1;
    cont++;

    if (stop || bit == 0)
    {
      *up = ubits;
      *cp = cbits;
      if (stop) break;

      ubits = *++up;
      cbits = *++cp;
      bit = 1;
    }
  }

  // Statistics.
  cont *= node->density;
  if (node->largestBlock < cont) node->largestBlock = cont;
  node->used -= cont;
  _used -= cont;

  return true;
}

void MemoryManagerPrivate::freeAll(bool keepVirtualMemory) ASMJIT_NOTHROW
{
  MemNode* node = _first;

  while (node)
  {
    MemNode* next = node->next;
  
    if (!keepVirtualMemory) freeVirtualMemory(node->mem, node->size);
    ASMJIT_FREE(node->baUsed);
    ASMJIT_FREE(node);

    node = next;
  }

  _allocated = 0;
  _used = 0;

  _root = NULL;
  _first = NULL;
  _last = NULL;
  _optimal = NULL;
}

// ============================================================================
// [AsmJit::MemoryManagerPrivate - NodeList RB-Tree]
// ============================================================================

static int rbAssert(MemNode* root)
{
  if (root == NULL) return 1;

  MemNode* ln = root->node[0];
  MemNode* rn = root->node[1];

  // Red violation.
  ASMJIT_ASSERT( !(isRed(root) && (isRed(ln) || isRed(rn))) );

  int lh = rbAssert(ln);
  int rh = rbAssert(rn);

  // Invalid btree.
  ASMJIT_ASSERT(ln == NULL || ln->mem < root->mem);
  ASMJIT_ASSERT(rn == NULL || rn->mem > root->mem);

  // Black violation.
  ASMJIT_ASSERT( !(lh != 0 && rh != 0 && lh != rh) );

  // Only count black links.
  if (lh != 0 && rh != 0)
    return isRed(root) ? lh : lh + 1;
  else
    return 0;
}

static inline MemNode* rbRotateSingle(MemNode* root, int dir)
{
  MemNode* save = root->node[!dir];

  root->node[!dir] = save->node[dir];
  save->node[dir] = root;

  root->red = 1;
  save->red = 0;

  return save;
}

static inline MemNode* rbRotateDouble(MemNode* root, int dir)
{
  root->node[!dir] = rbRotateSingle(root->node[!dir], !dir);
  return rbRotateSingle(root, dir);
}

bool MemoryManagerPrivate::checkTree() ASMJIT_NOTHROW
{
  return rbAssert(_root) > 0;
}

void MemoryManagerPrivate::insertNode(MemNode* node) ASMJIT_NOTHROW
{
  if (_root == NULL)
  {
    // Empty tree case.
    _root = node;
  }
  else
  {
    // False tree root.
    RbNode<MemNode> head = {0};

    // Grandparent & parent.
    MemNode* g = NULL;
    MemNode* t = reinterpret_cast<MemNode*>(&head);

    // Iterator & parent.
    MemNode* p = NULL;
    MemNode* q = t->node[1] = _root;

    int dir = 0, last;

    // Search down the tree.
    for (;;)
    {
      if (q == NULL)
      {
        // Insert new node at the bottom.
        q = node;
        p->node[dir] = node;
      }
      else if (isRed(q->node[0]) && isRed(q->node[1]))
      {
        // Color flip.
        q->red = 1;
        q->node[0]->red = 0;
        q->node[1]->red = 0;
      }

      // Fix red violation.
      if (isRed(q) && isRed(p))
      {
        int dir2 = t->node[1] == g;
        t->node[dir2] = (q == p->node[last]) ? rbRotateSingle(g, !last) : rbRotateDouble(g, !last);
      }

      // Stop if found.
      if (q == node) break;

      last = dir;
      dir = q->mem < node->mem;

      // Update helpers.
      if (g != NULL) t = g;
      g = p;
      p = q;
      q = q->node[dir];
    }

    // Update root.
    _root = head.node[1];
  }

  // Make root black.
  _root->red = 0;

  // Link with others.
  node->prev = _last;

  if (_first == NULL)
  {
    _first = node;
    _last = node;
    _optimal = node;
  }
  else
  {
    node->prev = _last;
    _last->next = node;
    _last = node;
  }
}

MemNode* MemoryManagerPrivate::removeNode(MemNode* node) ASMJIT_NOTHROW
{
  // False tree root.
  RbNode<MemNode> head = {0}; 

  // Helpers.
  MemNode* q = reinterpret_cast<MemNode*>(&head);
  MemNode* p = NULL;
  MemNode* g = NULL;
  // Found item.
  MemNode* f = NULL;
  int dir = 1;

  // Set up.
  q->node[1] = _root;

  // Search and push a red down.
  while (q->node[dir] != NULL)
  {
    int last = dir;

    // Update helpers.
    g = p;
    p = q;
    q = q->node[dir];
    dir = q->mem < node->mem;

    // Save found node.
    if (q == node) f = q;

    // Push the red node down.
    if (!isRed(q) && !isRed(q->node[dir]))
    {
      if (isRed(q->node[!dir]))
      {
        p = p->node[last] = rbRotateSingle(q, dir);
      }
      else if (!isRed(q->node[!dir]))
      {
        MemNode* s = p->node[!last];

        if (s != NULL)
        {
          if (!isRed(s->node[!last]) && !isRed(s->node[last]))
          {
            // Color flip.
            p->red = 0;
            s->red = 1;
            q->red = 1;
          }
          else
          {
            int dir2 = g->node[1] == p;

            if (isRed(s->node[last]))
              g->node[dir2] = rbRotateDouble(p, last);
            else if (isRed(s->node[!last]))
              g->node[dir2] = rbRotateSingle(p, last);

            // Ensure correct coloring.
            q->red = g->node[dir2]->red = 1;
            g->node[dir2]->node[0]->red = 0;
            g->node[dir2]->node[1]->red = 0;
          }
        }
      }
    }
  }

  // Replace and remove.
  ASMJIT_ASSERT(f != NULL);
  ASMJIT_ASSERT(f != reinterpret_cast<MemNode*>(&head));
  ASMJIT_ASSERT(q != reinterpret_cast<MemNode*>(&head));

  if (f != q) f->fillData(q);
  p->node[p->node[1] == q] = q->node[q->node[0] == NULL];

  // Update root and make it black.
  if ((_root = head.node[1]) != NULL) _root->red = 0;

  // Unlink.
  MemNode* next = q->next;
  MemNode* prev = q->prev;

  if (prev) { prev->next = next; } else { _first = next; }
  if (next) { next->prev = prev; } else { _last  = prev; }
  if (_optimal == q) { _optimal = prev ? prev : next; }

  return q;
}

MemNode* MemoryManagerPrivate::findPtr(uint8_t* mem) ASMJIT_NOTHROW
{
  MemNode* cur = _root;
  while (cur)
  {
    uint8_t* curMem = cur->mem;
    if (mem < curMem)
    {
      // Go left.
      cur = cur->node[0];
      continue;
    }
    else
    {
      uint8_t* curEnd = curMem + cur->size;
      if (mem >= curEnd)
      {
        // Go right.
        cur = cur->node[1];
        continue;
      }
      else
      {
        // Match.
        break;
      }
    }
  }
  return cur;
}

// ============================================================================
// [AsmJit::MemoryManager]
// ============================================================================

MemoryManager::MemoryManager() ASMJIT_NOTHROW
{
}

MemoryManager::~MemoryManager() ASMJIT_NOTHROW
{
}

MemoryManager* MemoryManager::getGlobal() ASMJIT_NOTHROW
{
  static VirtualMemoryManager memmgr;
  return &memmgr;
}

// ============================================================================
// [AsmJit::VirtualMemoryManager]
// ============================================================================

#if !defined(ASMJIT_WINDOWS)
VirtualMemoryManager::VirtualMemoryManager() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = new(std::nothrow) MemoryManagerPrivate();
  _d = (void*)d;
}
#else
VirtualMemoryManager::VirtualMemoryManager() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = new(std::nothrow) MemoryManagerPrivate(GetCurrentProcess());
  _d = (void*)d;
}

VirtualMemoryManager::VirtualMemoryManager(HANDLE hProcess) ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = new(std::nothrow) MemoryManagerPrivate(hProcess);
  _d = (void*)d;
}
#endif // ASMJIT_WINDOWS

VirtualMemoryManager::~VirtualMemoryManager() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  delete d;
}

void* VirtualMemoryManager::alloc(sysuint_t size, uint32_t type) ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);

  if (type == MEMORY_ALLOC_PERMANENT) 
    return d->allocPermanent(size);
  else
    return d->allocFreeable(size);
}

bool VirtualMemoryManager::free(void* address) ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  return d->free(address);
}

bool VirtualMemoryManager::shrink(void* address, sysuint_t used) ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  return d->shrink(address, used);
}

void VirtualMemoryManager::freeAll() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);

  // Calling MemoryManager::freeAll() will never keep allocated memory.
  return d->freeAll(false);
}

sysuint_t VirtualMemoryManager::getUsedBytes() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  return d->_used;
}

sysuint_t VirtualMemoryManager::getAllocatedBytes() ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  return d->_allocated;
}

bool VirtualMemoryManager::getKeepVirtualMemory() const ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  return d->_keepVirtualMemory;
}

void VirtualMemoryManager::setKeepVirtualMemory(bool keepVirtualMemory) ASMJIT_NOTHROW
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  d->_keepVirtualMemory = keepVirtualMemory;
}

// ============================================================================
// [AsmJit::VirtualMemoryManager - Debug]
// ============================================================================

#if defined(ASMJIT_MEMORY_MANAGER_DUMP)

struct ASMJIT_HIDDEN GraphVizContext
{
  GraphVizContext();
  ~GraphVizContext();

  bool openFile(const char* fileName);
  void closeFile();

  void dumpNode(MemNode* node);
  void connect(MemNode* node, MemNode* other, const char* dst);

  FILE* file;
};

GraphVizContext::GraphVizContext() :
  file(NULL)
{
}

GraphVizContext::~GraphVizContext()
{
  closeFile();
}

bool GraphVizContext::openFile(const char* fileName)
{
  file = fopen(fileName, "w");
  return file != NULL;
}

void GraphVizContext::closeFile()
{
  if (file) { fclose(file); file = NULL; }
}

void GraphVizContext::dumpNode(MemNode* node)
{
  fprintf(file, "  NODE_%p [shape=record, style=filled, color=%s, label=\"<L>|<C>Mem: %p, Used: %d/%d|<R>\"];\n",
    node,
    node->red ? "red" : "gray",
    node->mem, node->used, node->size);

  if (node->node[0]) connect(node, node->node[0], "L");
  if (node->node[1]) connect(node, node->node[1], "R");
}

void GraphVizContext::connect(MemNode* node, MemNode* other, const char* dst)
{
  dumpNode(other);

  fprintf(file, "  NODE_%p:%s -> NODE_%p:C", node, dst, other);
  if (other->red) fprintf(file, " [style=bold, color=red]");
  fprintf(file, ";\n");
}

void VirtualMemoryManager::dump(const char* fileName)
{
  MemoryManagerPrivate* d = reinterpret_cast<MemoryManagerPrivate*>(_d);
  GraphVizContext ctx;
  if (!ctx.openFile(fileName)) return;

  fprintf(ctx.file, "digraph {\n");
  if (d->_root) ctx.dumpNode(d->_root);
  fprintf(ctx.file, "}\n");
}
#endif // ASMJIT_MEMORY_MANAGER_DUMP

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/MemoryManager.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_MEMORYMANAGER_H
#define _ASMJIT_MEMORYMANAGER_H

// [Dependencies]
#include "Build.h"
#include "Defs.h"

// [Api-Begin]
#include "ApiBegin.h"

// [Debug]
// #define ASMJIT_MEMORY_MANAGER_DUMP

namespace AsmJit {

//! @addtogroup AsmJit_MemoryManagement
//! @{

// ============================================================================
// [AsmJit::MemoryManager]
// ============================================================================

//! @brief Virtual memory manager interface.
//!
//! This class is pure virtual. You can get default virtual memory manager using
//! @c getGlobal() method. If you want to create more memory managers with same
//! functionality as global memory manager use @c VirtualMemoryManager class.
struct ASMJIT_API MemoryManager
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create memory manager instance.
  MemoryManager() ASMJIT_NOTHROW;
  //! @brief Destroy memory manager instance, this means also to free all memory
  //! blocks.
  virtual ~MemoryManager() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  //! @brief Allocate a @a size bytes of virtual memory.
  //!
  //! Note that if you are implementing your own virtual memory manager then you
  //! can quitly ignore type of allocation. This is mainly for AsmJit to memory
  //! manager that allocated memory will be never freed.
  virtual void* alloc(sysuint_t size, uint32_t type = MEMORY_ALLOC_FREEABLE) ASMJIT_NOTHROW = 0;
  //! @brief Free previously allocated memory at a given @a address.
  virtual bool free(void* address) ASMJIT_NOTHROW = 0;
  //! @brief Free some tail memory.
  virtual bool shrink(void* address, sysuint_t used) ASMJIT_NOTHROW = 0;
  //! @brief Free all allocated memory.
  virtual void freeAll() ASMJIT_NOTHROW = 0;

  //! @brief Get how many bytes are currently used.
  virtual sysuint_t getUsedBytes() ASMJIT_NOTHROW = 0;
  //! @brief Get how many bytes are currently allocated.
  virtual sysuint_t getAllocatedBytes() ASMJIT_NOTHROW = 0;

  //! @brief Get global memory manager instance.
  //!
  //! Global instance is instance of @c VirtualMemoryManager class. Global memory
  //! manager is used by default by @ref Assembler::make() and @ref Compiler::make()
  //! methods.
  static MemoryManager* getGlobal() ASMJIT_NOTHROW;
};

//! @brief Reference implementation of memory manager that uses
//! @ref AsmJit::VirtualMemory class to allocate chunks of virtual memory
//! and bit arrays to manage it.
struct ASMJIT_API VirtualMemoryManager : public MemoryManager
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a @c VirtualMemoryManager instance.
  VirtualMemoryManager() ASMJIT_NOTHROW;

#if defined(ASMJIT_WINDOWS)
  //! @brief Create a @c VirtualMemoryManager instance for process @a hProcess.
  //!
  //! This is specialized version of constructor available only for windows and
  //! usable to alloc/free memory of different process.
  VirtualMemoryManager(HANDLE hProcess) ASMJIT_NOTHROW;
#endif // ASMJIT_WINDOWS

  //! @brief Destroy the @c VirtualMemoryManager instance, this means also to
  //! free all blocks.
  virtual ~VirtualMemoryManager() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Interface]
  // --------------------------------------------------------------------------

  virtual void* alloc(sysuint_t size, uint32_t type = MEMORY_ALLOC_FREEABLE) ASMJIT_NOTHROW;
  virtual bool free(void* address) ASMJIT_NOTHROW;
  virtual bool shrink(void* address, sysuint_t used) ASMJIT_NOTHROW;
  virtual void freeAll() ASMJIT_NOTHROW;

  virtual sysuint_t getUsedBytes() ASMJIT_NOTHROW;
  virtual sysuint_t getAllocatedBytes() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Virtual Memory Manager Specific]
  // --------------------------------------------------------------------------

  //! @brief Get whether to keep allocated memory after memory manager is
  //! destroyed.
  //!
  //! @sa @c setKeepVirtualMemory().
  bool getKeepVirtualMemory() const ASMJIT_NOTHROW;

  //! @brief Set whether to keep allocated memory after memory manager is
  //! destroyed.
  //!
  //! This method is usable when patching code of remote process. You need to
  //! allocate process memory, store generated assembler into it and patch the
  //! method you want to redirect (into your code). This method affects only
  //! VirtualMemoryManager destructor. After destruction all internal 
  //! structures are freed, only the process virtual memory remains.
  //! 
  //! @note Memory allocated with MEMORY_ALLOC_PERMANENT is always kept.
  //!
  //! @sa @c getKeepVirtualMemory().
  void setKeepVirtualMemory(bool keepVirtualMemory) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Debug]
  // --------------------------------------------------------------------------

#if defined(ASMJIT_MEMORY_MANAGER_DUMP)
  //! @brief Dump memory manager tree into file.
  //!
  //! Generated output is using DOT language (from graphviz package).
  void dump(const char* fileName);
#endif // ASMJIT_MEMORY_MANAGER_DUMP

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

protected:
  //! @brief Pointer to private data hidden from the public API.
  void* _d;
};

//! @}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

// [Guard]
#endif // _ASMJIT_MEMORYMANAGER_H

```

`AsmJit/MemoryMarker.cpp`:

```cpp

#include "Build.h"
#include "MemoryMarker.h"

#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

MemoryMarker::MemoryMarker()  ASMJIT_NOTHROW {}
MemoryMarker::~MemoryMarker() ASMJIT_NOTHROW {}

} // AsmJit namespace

#include "ApiEnd.h"    // [Api-End]

```

`AsmJit/MemoryMarker.h`:

```h

#ifndef _ASMJIT_MEMORYMARKER_H
#define _ASMJIT_MEMORYMARKER_H

#include "Build.h"
#include "Defs.h"

#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

struct ASMJIT_API MemoryMarker
{
  MemoryMarker() ASMJIT_NOTHROW;
  virtual ~MemoryMarker() ASMJIT_NOTHROW;
  //
  virtual void mark(const void* ptr, sysuint_t size) ASMJIT_NOTHROW = 0;

private:
  ASMJIT_DISABLE_COPY(MemoryMarker)
};

} // AsmJit namespace

#include "ApiEnd.h"    // [Api-End]

#endif // _ASMJIT_MEMORYMARKER_H

```

`AsmJit/Operand.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_OPERAND_H
#define _ASMJIT_OPERAND_H

// [Dependencies]
#include "Build.h"

namespace AsmJit {

//! @addtogroup AsmJit_Core
//! @{

// There is currently no platform independent code.

//! @}

} // AsmJit namespace

// ============================================================================
// [Platform Specific]
// ============================================================================

#if defined(ASMJIT_X86) || defined(ASMJIT_X64)
#include "OperandX86X64.h"
#endif // ASMJIT_X86 || ASMJIT_X64

// [Guard]
#endif // _ASMJIT_OPERAND_H

```

`AsmJit/OperandX86X64.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include "Defs.h"
#include "Operand.h"

// [Api-Begin]
#include "ApiBegin.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::Registers - no_reg]
// ============================================================================

const GPReg no_reg(_Initialize(), INVALID_VALUE);

// ============================================================================
// [AsmJit::Registers - 8-bit]
// ============================================================================

const GPReg al(_Initialize(), REG_AL);
const GPReg cl(_Initialize(), REG_CL);
const GPReg dl(_Initialize(), REG_DL);
const GPReg bl(_Initialize(), REG_BL);

#if defined(ASMJIT_X64)
const GPReg spl(_Initialize(), REG_SPL);
const GPReg bpl(_Initialize(), REG_BPL);
const GPReg sil(_Initialize(), REG_SIL);
const GPReg dil(_Initialize(), REG_DIL);

const GPReg r8b(_Initialize(), REG_R8B);
const GPReg r9b(_Initialize(), REG_R9B);
const GPReg r10b(_Initialize(), REG_R10B);
const GPReg r11b(_Initialize(), REG_R11B);
const GPReg r12b(_Initialize(), REG_R12B);
const GPReg r13b(_Initialize(), REG_R13B);
const GPReg r14b(_Initialize(), REG_R14B);
const GPReg r15b(_Initialize(), REG_R15B);
#endif // ASMJIT_X64

const GPReg ah(_Initialize(), REG_AH);
const GPReg ch(_Initialize(), REG_CH);
const GPReg dh(_Initialize(), REG_DH);
const GPReg bh(_Initialize(), REG_BH);

// ============================================================================
// [AsmJit::Registers - 16-bit]
// ============================================================================

const GPReg ax(_Initialize(), REG_AX);
const GPReg cx(_Initialize(), REG_CX);
const GPReg dx(_Initialize(), REG_DX);
const GPReg bx(_Initialize(), REG_BX);
const GPReg sp(_Initialize(), REG_SP);
const GPReg bp(_Initialize(), REG_BP);
const GPReg si(_Initialize(), REG_SI);
const GPReg di(_Initialize(), REG_DI);

#if defined(ASMJIT_X64)
const GPReg r8w(_Initialize(), REG_R8W);
const GPReg r9w(_Initialize(), REG_R9W);
const GPReg r10w(_Initialize(), REG_R10W);
const GPReg r11w(_Initialize(), REG_R11W);
const GPReg r12w(_Initialize(), REG_R12W);
const GPReg r13w(_Initialize(), REG_R13W);
const GPReg r14w(_Initialize(), REG_R14W);
const GPReg r15w(_Initialize(), REG_R15W);
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - 32-bit]
// ============================================================================

const GPReg eax(_Initialize(), REG_EAX);
const GPReg ecx(_Initialize(), REG_ECX);
const GPReg edx(_Initialize(), REG_EDX);
const GPReg ebx(_Initialize(), REG_EBX);
const GPReg esp(_Initialize(), REG_ESP);
const GPReg ebp(_Initialize(), REG_EBP);
const GPReg esi(_Initialize(), REG_ESI);
const GPReg edi(_Initialize(), REG_EDI);

#if defined(ASMJIT_X64)
const GPReg r8d(_Initialize(), REG_R8D);
const GPReg r9d(_Initialize(), REG_R9D);
const GPReg r10d(_Initialize(), REG_R10D);
const GPReg r11d(_Initialize(), REG_R11D);
const GPReg r12d(_Initialize(), REG_R12D);
const GPReg r13d(_Initialize(), REG_R13D);
const GPReg r14d(_Initialize(), REG_R14D);
const GPReg r15d(_Initialize(), REG_R15D);
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - 64-bit]
// ============================================================================

#if defined(ASMJIT_X64)
const GPReg rax(_Initialize(), REG_RAX);
const GPReg rcx(_Initialize(), REG_RCX);
const GPReg rdx(_Initialize(), REG_RDX);
const GPReg rbx(_Initialize(), REG_RBX);
const GPReg rsp(_Initialize(), REG_RSP);
const GPReg rbp(_Initialize(), REG_RBP);
const GPReg rsi(_Initialize(), REG_RSI);
const GPReg rdi(_Initialize(), REG_RDI);

const GPReg r8(_Initialize(), REG_R8);
const GPReg r9(_Initialize(), REG_R9);
const GPReg r10(_Initialize(), REG_R10);
const GPReg r11(_Initialize(), REG_R11);
const GPReg r12(_Initialize(), REG_R12);
const GPReg r13(_Initialize(), REG_R13);
const GPReg r14(_Initialize(), REG_R14);
const GPReg r15(_Initialize(), REG_R15);
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - Native (AsmJit extension)]
// ============================================================================

const GPReg nax(_Initialize(), REG_NAX);
const GPReg ncx(_Initialize(), REG_NCX);
const GPReg ndx(_Initialize(), REG_NDX);
const GPReg nbx(_Initialize(), REG_NBX);
const GPReg nsp(_Initialize(), REG_NSP);
const GPReg nbp(_Initialize(), REG_NBP);
const GPReg nsi(_Initialize(), REG_NSI);
const GPReg ndi(_Initialize(), REG_NDI);

// ============================================================================
// [AsmJit::Registers - MM]
// ============================================================================

const MMReg mm0(_Initialize(), REG_MM0);
const MMReg mm1(_Initialize(), REG_MM1);
const MMReg mm2(_Initialize(), REG_MM2);
const MMReg mm3(_Initialize(), REG_MM3);
const MMReg mm4(_Initialize(), REG_MM4);
const MMReg mm5(_Initialize(), REG_MM5);
const MMReg mm6(_Initialize(), REG_MM6);
const MMReg mm7(_Initialize(), REG_MM7);

// ============================================================================
// [AsmJit::Registers - XMM]
// ============================================================================

const XMMReg xmm0(_Initialize(), REG_XMM0);
const XMMReg xmm1(_Initialize(), REG_XMM1);
const XMMReg xmm2(_Initialize(), REG_XMM2);
const XMMReg xmm3(_Initialize(), REG_XMM3);
const XMMReg xmm4(_Initialize(), REG_XMM4);
const XMMReg xmm5(_Initialize(), REG_XMM5);
const XMMReg xmm6(_Initialize(), REG_XMM6);
const XMMReg xmm7(_Initialize(), REG_XMM7);

#if defined(ASMJIT_X64)
const XMMReg xmm8(_Initialize(), REG_XMM8);
const XMMReg xmm9(_Initialize(), REG_XMM9);
const XMMReg xmm10(_Initialize(), REG_XMM10);
const XMMReg xmm11(_Initialize(), REG_XMM11);
const XMMReg xmm12(_Initialize(), REG_XMM12);
const XMMReg xmm13(_Initialize(), REG_XMM13);
const XMMReg xmm14(_Initialize(), REG_XMM14);
const XMMReg xmm15(_Initialize(), REG_XMM15);
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - Segment]
// ============================================================================

const SegmentReg cs(_Initialize(), REG_CS);
const SegmentReg ss(_Initialize(), REG_SS);
const SegmentReg ds(_Initialize(), REG_DS);
const SegmentReg es(_Initialize(), REG_ES);
const SegmentReg fs(_Initialize(), REG_FS);
const SegmentReg gs(_Initialize(), REG_GS);

// ============================================================================
// [AsmJit::Immediate]
// ============================================================================

//! @brief Create signed immediate value operand.
Imm imm(sysint_t i) ASMJIT_NOTHROW
{ 
  return Imm(i, false);
}

//! @brief Create unsigned immediate value operand.
Imm uimm(sysuint_t i) ASMJIT_NOTHROW
{
  return Imm((sysint_t)i, true);
}

// ============================================================================
// [AsmJit::BaseVar]
// ============================================================================

Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize) ASMJIT_NOTHROW
{
  Mem m; //(_DontInitialize());

  m._mem.op = OPERAND_MEM;
  m._mem.size = (ptrSize == INVALID_VALUE) ? var.getSize() : (uint8_t)ptrSize;
  m._mem.type = OPERAND_MEM_NATIVE;
  m._mem.segmentPrefix = SEGMENT_NONE;
  m._mem.sizePrefix = 0;
  m._mem.shift = 0;

  m._mem.id = var.getId();
  m._mem.base = INVALID_VALUE;
  m._mem.index = INVALID_VALUE;

  m._mem.target = NULL;
  m._mem.displacement = 0;

  return m;
}


Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize, sysint_t disp) ASMJIT_NOTHROW
{
  Mem m; //(_DontInitialize());

  m._mem.op = OPERAND_MEM;
  m._mem.size = (ptrSize == INVALID_VALUE) ? var.getSize() : (uint8_t)ptrSize;
  m._mem.type = OPERAND_MEM_NATIVE;
  m._mem.segmentPrefix = SEGMENT_NONE;
  m._mem.sizePrefix = 0;
  m._mem.shift = 0;

  m._mem.id = var.getId();

  m._mem.base = INVALID_VALUE;
  m._mem.index = INVALID_VALUE;

  m._mem.target = NULL;
  m._mem.displacement = disp;

  return m;
}

Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize, const GPVar& index, uint32_t shift, sysint_t disp) ASMJIT_NOTHROW
{
  Mem m; //(_DontInitialize());

  m._mem.op = OPERAND_MEM;
  m._mem.size = (ptrSize == INVALID_VALUE) ? var.getSize() : (uint8_t)ptrSize;
  m._mem.type = OPERAND_MEM_NATIVE;
  m._mem.segmentPrefix = SEGMENT_NONE;
  m._mem.sizePrefix = 0;
  m._mem.shift = shift;

  m._mem.id = var.getId();

  m._mem.base = INVALID_VALUE;
  m._mem.index = index.getId();

  m._mem.target = NULL;
  m._mem.displacement = disp;

  return m;
}

// ============================================================================
// [AsmJit::Mem - ptr[]]
// ============================================================================

Mem _MemPtrBuild(
  const Label& label, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  return Mem(label, disp, ptrSize);
}

Mem _MemPtrBuild(
  const Label& label,
  const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  Mem m(label, disp, ptrSize);

  m._mem.index = index.getRegIndex();
  m._mem.shift = shift;

  return m;
}

Mem _MemPtrBuild(
  const Label& label,
  const GPVar& index, uint32_t shift, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  Mem m(label, disp, ptrSize);

  m._mem.index = index.getId();
  m._mem.shift = shift;

  return m;
}


// ============================================================================
// [AsmJit::Mem - ptr[] - Absolute Addressing]
// ============================================================================

ASMJIT_API Mem _MemPtrAbs(
  void* target, sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  Mem m;

  m._mem.size = ptrSize;
  m._mem.type = OPERAND_MEM_ABSOLUTE;
  m._mem.segmentPrefix = segmentPrefix;

  m._mem.target = target;
  m._mem.displacement = disp;

  return m;
}

ASMJIT_API Mem _MemPtrAbs(
  void* target,
  const GPReg& index, uint32_t shift, sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  Mem m;// (_DontInitialize());

  m._mem.op = OPERAND_MEM;
  m._mem.size = ptrSize;
  m._mem.type = OPERAND_MEM_ABSOLUTE;
  m._mem.segmentPrefix = (uint8_t)segmentPrefix;

#if defined(ASMJIT_X86)
  m._mem.sizePrefix = index.getSize() != 4;
#else
  m._mem.sizePrefix = index.getSize() != 8;
#endif

  m._mem.shift = shift;

  m._mem.id = INVALID_VALUE;
  m._mem.base = INVALID_VALUE;
  m._mem.index = index.getRegIndex();

  m._mem.target = target;
  m._mem.displacement = disp;

  return m;
}

ASMJIT_API Mem _MemPtrAbs(
  void* target,
  const GPVar& index, uint32_t shift, sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  Mem m;// (_DontInitialize());

  m._mem.op = OPERAND_MEM;
  m._mem.size = ptrSize;
  m._mem.type = OPERAND_MEM_ABSOLUTE;
  m._mem.segmentPrefix = (uint8_t)segmentPrefix;

#if defined(ASMJIT_X86)
  m._mem.sizePrefix = index.getSize() != 4;
#else
  m._mem.sizePrefix = index.getSize() != 8;
#endif

  m._mem.shift = shift;

  m._mem.id = INVALID_VALUE;
  m._mem.base = INVALID_VALUE;
  m._mem.index = index.getId();

  m._mem.target = target;
  m._mem.displacement = disp;

  return m;
}

// ============================================================================
// [AsmJit::Mem - ptr[base + displacement]]
// ============================================================================

Mem _MemPtrBuild(
  const GPReg& base, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix)
  ASMJIT_NOTHROW
{
  return Mem(base, disp, ptrSize, segmentPrefix);
}

Mem _MemPtrBuild(
	const GPReg& base, sysint_t disp, uint32_t ptrSize)
	ASMJIT_NOTHROW
{
	return Mem(base, disp, ptrSize);
}

Mem _MemPtrBuild(
  const GPReg& base,
  const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  return Mem(base, index, shift, disp, ptrSize);
}

Mem _MemPtrBuild(
const GPReg& base,
	const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix)
	ASMJIT_NOTHROW
{
	return Mem(base, index, shift, disp, ptrSize, segmentPrefix);
}

Mem _MemPtrBuild(
  const GPVar& base, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  return Mem(base, disp, ptrSize);
}

Mem _MemPtrBuild(
  const GPVar& base,
  const GPVar& index, uint32_t shift, sysint_t disp, uint32_t ptrSize)
  ASMJIT_NOTHROW
{
  return Mem(base, index, shift, disp, ptrSize);
}


} // AsmJit namespace

```

`AsmJit/OperandX86X64.h`:

```h
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Guard]
#ifndef _ASMJIT_OPERANDX86X64_H
#define _ASMJIT_OPERANDX86X64_H

#if !defined(_ASMJIT_OPERAND_H)
#warning "AsmJit/OperandX86X64.h can be only included by AsmJit/Operand.h"
#endif // _ASMJIT_OPERAND_H

// [Dependencies]
#include "Build.h"
#include "Defs.h"

namespace AsmJit {

// ============================================================================
// [AsmJit::Forward Declarations]
// ============================================================================

struct BaseReg;
struct BaseVar;
struct Compiler;
struct GPReg;
struct GPVar;
struct Imm;
struct Label;
struct Mem;
struct MMReg;
struct MMVar;
struct Operand;
struct X87Reg;
struct X87Var;
struct XMMReg;
struct XMMVar;

//! @addtogroup AsmJit_Core
//! @{

// ============================================================================
// [AsmJit::Operand]
// ============================================================================

//! @brief Operand, abstract class for register, memory location and immediate
//! value operands.
struct ASMJIT_HIDDEN Operand
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create an uninitialized operand.
  inline Operand() ASMJIT_NOTHROW
  {
    memset(this, 0, sizeof(Operand));
    _base.id = INVALID_VALUE;
  }

  //! @brief Create a reference to @a other operand.
  inline Operand(const Operand& other) ASMJIT_NOTHROW
  {
    _init(other);
  }

#if !defined(ASMJIT_NODOC)
  inline Operand(const _DontInitialize&) ASMJIT_NOTHROW
  {
  }
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Init & Copy]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief Initialize operand to @a other (used by constructors).
  inline void _init(const Operand& other) ASMJIT_NOTHROW
  {
    memcpy(this, &other, sizeof(Operand));
  }

  //! @internal
  //!
  //! @brief Initialize operand to @a other (used by assign operators).
  inline void _copy(const Operand& other) ASMJIT_NOTHROW
  {
    memcpy(this, &other, sizeof(Operand));
  }

  // --------------------------------------------------------------------------
  // [Identification]
  // --------------------------------------------------------------------------

  //! @brief Get type of operand, see @c OPERAND_TYPE.
  inline uint32_t getType() const ASMJIT_NOTHROW
  { return _base.op; }

  //! @brief Get whether operand is none (@c OPERAND_NONE).
  inline bool isNone() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_NONE); }

  //! @brief Get whether operand is any (general purpose, mmx or sse) register (@c OPERAND_REG).
  inline bool isReg() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_REG); }

  //! @brief Get whether operand is memory address (@c OPERAND_MEM).
  inline bool isMem() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_MEM); }

  //! @brief Get whether operand is immediate (@c OPERAND_IMM).
  inline bool isImm() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_IMM); }

  //! @brief Get whether operand is label (@c OPERAND_LABEL).
  inline bool isLabel() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_LABEL); }

  //! @brief Get whether operand is variable (@c OPERAND_VAR).
  inline bool isVar() const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_VAR); }

  //! @brief Get whether operand is variable or memory.
  inline bool isVarMem() const ASMJIT_NOTHROW
  { return ((_base.op & (OPERAND_VAR | OPERAND_MEM)) != 0); }

  //! @brief Get whether operand is register and type of register is @a regType.
  inline bool isRegType(uint32_t regType) const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_REG) & ((_reg.code & REG_TYPE_MASK) == regType); }

  //! @brief Get whether operand is register and code of register is @a regCode.
  inline bool isRegCode(uint32_t regCode) const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_REG) & (_reg.code == regCode); }

  //! @brief Get whether operand is register and index of register is @a regIndex.
  inline bool isRegIndex(uint32_t regIndex) const ASMJIT_NOTHROW
  { return (_base.op == OPERAND_REG) & ((_reg.code & REG_INDEX_MASK) == (regIndex & REG_INDEX_MASK)); }

  //! @brief Get whether operand is any register or memory.
  inline bool isRegMem() const ASMJIT_NOTHROW
  { return ((_base.op & (OPERAND_REG | OPERAND_MEM)) != 0); }

  //! @brief Get whether operand is register of @a regType type or memory.
  inline bool isRegTypeMem(uint32_t regType) const ASMJIT_NOTHROW
  { return ((_base.op == OPERAND_REG) & ((_reg.code & REG_TYPE_MASK) == regType)) | (_base.op == OPERAND_MEM); }

  // --------------------------------------------------------------------------
  // [Operand Size]
  // --------------------------------------------------------------------------

  //! @brief Return size of operand in bytes.
  inline uint32_t getSize() const ASMJIT_NOTHROW
  { return _base.size; }

  // --------------------------------------------------------------------------
  // [Operand Id]
  // --------------------------------------------------------------------------

  //! @brief Return operand Id (Operand Id's are used internally by 
  //! @c Assembler and @c Compiler classes).
  //!
  //! @note There is no way how to change or remove operand id. If you don't
  //! need the operand just assign different operand to this one.
  inline uint32_t getId() const ASMJIT_NOTHROW
  { return _base.id; }

  // --------------------------------------------------------------------------
  // [Extensions]
  // --------------------------------------------------------------------------

  //! @brief Get whether the extended register (additional eight registers
  //! introduced by 64-bit mode) is used.
  inline bool isExtendedRegisterUsed() const ASMJIT_NOTHROW
  {
    // Hacky, but correct.
    // - If operand type is register then extended register is register with
    //   index 8 and greater (8 to 15 inclusive).
    // - If operand type is memory operand then we need to take care about
    //   label (in _mem.base) and INVALID_VALUE, we just decrement the value
    //   by 8 and check if it's at interval 0 to 7 inclusive (if it's there
    //   then it's extended register.
    return (isReg() && (_reg.code & REG_INDEX_MASK)  >= 8) ||
           (isMem() && ((((uint32_t)_mem.base  - 8U) < 8U) ||
                        (((uint32_t)_mem.index - 8U) < 8U) ));
  }

  // --------------------------------------------------------------------------
  // [Data Structures]
  // --------------------------------------------------------------------------

  //! @internal
  //! 
  //! @brief Base operand data shared between all operands.
  struct BaseData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE.
    uint8_t op;
    //! @brief Size of operand (register, address, immediate or variable).
    uint8_t size;

    //! @brief Not used.
    uint8_t reserved[2];

    //! @brief Operand id (private variable for @c Assembler and @c Compiler classes).
    //!
    //! @note Uninitialized operands has id equal to zero.
    uint32_t id;
  };

  //! @internal
  //! 
  //! @brief Register data.
  struct RegData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE (in this case @c OPERAND_REG).
    uint8_t op;
    //! @brief Size of register.
    uint8_t size;

    //! @brief Not used.
    uint8_t reserved[2];

    //! @brief Operand id.
    uint32_t id;

    //! @brief Register code or variable, see @c REG and @c INVALID_VALUE.
    uint32_t code;
  };

  //! @internal
  //! 
  //! @brief Memory address data.
  struct MemData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE (in this case @c OPERAND_MEM).
    uint8_t op;
    //! @brief Size of pointer.
    uint8_t size;

    //! @brief Memory operand type, see @c OPERAND_MEM_TYPE.
    uint8_t type;
    //! @brief Segment override prefix, see @c SEGMENT_PREFIX.
    uint8_t segmentPrefix : 4;
    //! @brief Emit MOV/LEA instruction using 16-bit form of base/index registers.
    uint8_t sizePrefix : 1;
    //! @brief Index register shift/scale (0 to 3 inclusive, see @c SCALE).
    uint8_t shift : 3;

    //! @brief Operand ID.
    uint32_t id;

    //! @brief Base register index, variable or label id.
    uint32_t base;
    //! @brief Index register index or variable id.
    uint32_t index;

    //! @brief Target (for 32-bit, absolute address).
    void* target;

    //! @brief Displacement.
    sysint_t displacement;
  };

  //! @internal
  //! 
  //! @brief Immediate value data.
  struct ImmData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE (in this case @c OPERAND_IMM)..
    uint8_t op;
    //! @brief Size of immediate (or 0 to autodetect).
    uint8_t size;

    //! @brief @c true if immediate is unsigned.
    uint8_t isUnsigned;
    //! @brief Not used.
    uint8_t reserved;

    //! @brief Operand ID.
    uint32_t id;

    //! @brief Immediate value.
    sysint_t value;
  };

  //! @internal
  //! 
  //! @brief Label data.
  struct LblData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE (in this case @c OPERAND_LABEL).
    uint8_t op;
    //! @brief Size of label, currently not used.
    uint8_t size;

    //! @brief Not used.
    uint8_t reserved[2];

    //! @brief Operand ID.
    uint32_t id;
  };

  //! @internal
  //! 
  //! @brief Variable data.
  struct VarData
  {
    //! @brief Type of operand, see @c OPERAND_TYPE (in this case @c OPERAND_VAR).
    uint8_t op;
    //! @brief Size of variable (0 if don't known).
    uint8_t size;

    //! @brief Not used.
    uint8_t reserved[2];

    //! @brief Operand ID.
    uint32_t id;

    //! @brief Type (and later also code) of register, see @c REG_TYPE, @c REG_CODE.
    //!
    //! @note Register code and variable code are two different things. In most
    //! cases registerCode is very related to variableType, but general purpose
    //! registers are divided to 64-bit, 32-bit, 16-bit and 8-bit entities so
    //! the registerCode can be used to access these, variableType remains
    //! unchanged from the initialization state. Variable type describes mainly
    //! variable type and home memory size.
    uint32_t registerCode;

    //! @brief Type of variable. See @c VARIABLE_TYPE enum.
    uint32_t variableType;
  };
  
  //! @brief Binary data.
  struct BinData
  {
    //! @brief First four 32-bit integers.
    uint32_t u32[4];
    //! @brief Second two 32 or 64-bit integers.
    sysuint_t s[2];
  };

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union
  {
    //! @brief Generic operand data.
    BaseData _base;
    //! @brief Register operand data.
    RegData _reg;
    //! @brief Memory operand data.
    MemData _mem;
    //! @brief Immediate operand data.
    ImmData _imm;
    //! @brief Label data.
    LblData _lbl;
    //! @brief Variable data.
    VarData _var;
    //! @brief 
    BinData _bin;
  };
};

// ============================================================================
// [AsmJit::BaseReg]
// ============================================================================

//! @brief Base class for all registers.
struct ASMJIT_HIDDEN BaseReg : public Operand
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new base register.
  inline BaseReg(uint32_t code, uint32_t size) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _reg.op = OPERAND_REG;
    _reg.size = (uint8_t)size;
    _reg.id = INVALID_VALUE;
    _reg.code = code;
  }

  //! @brief Create a new reference to @a other.
  inline BaseReg(const BaseReg& other) ASMJIT_NOTHROW :
    Operand(other)
  {}

#if !defined(ASMJIT_NODOC)
  inline BaseReg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    Operand(dontInitialize)
  {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [BaseReg Specific]
  // --------------------------------------------------------------------------

  //! @brief Get register code, see @c REG.
  inline uint32_t getRegCode() const ASMJIT_NOTHROW
  { return (uint32_t)(_reg.code); }

  //! @brief Get register type, see @c REG.
  inline uint32_t getRegType() const ASMJIT_NOTHROW
  { return (uint32_t)(_reg.code & REG_TYPE_MASK); }

  //! @brief Get register index (value from 0 to 7/15).
  inline uint32_t getRegIndex() const ASMJIT_NOTHROW
  { return (uint32_t)(_reg.code & REG_INDEX_MASK); }

  //! @brief Get whether register code is equal to @a code.
  inline bool isRegCode(uint32_t code) const ASMJIT_NOTHROW
  { return _reg.code == code; }

  //! @brief Get whether register code is equal to @a type.
  inline bool isRegType(uint32_t type) const ASMJIT_NOTHROW
  { return (uint32_t)(_reg.code & REG_TYPE_MASK) == type; }

  //! @brief Get whether register index is equal to @a index.
  inline bool isRegIndex(uint32_t index) const ASMJIT_NOTHROW
  { return (uint32_t)(_reg.code & REG_INDEX_MASK) == index; }

  //! @brief Set register code to @a code.
  inline void setCode(uint32_t code) ASMJIT_NOTHROW
  { _reg.code = code; }

  //! @brief Set register size to @a size.
  inline void setSize(uint32_t size) ASMJIT_NOTHROW
  { _reg.size = (uint8_t)size; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  inline BaseReg& operator=(const BaseReg& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const BaseReg& other) const ASMJIT_NOTHROW
  { return getRegCode() == other.getRegCode(); }

  inline bool operator!=(const BaseReg& other) const ASMJIT_NOTHROW
  { return getRegCode() != other.getRegCode(); }
};

// ============================================================================
// [AsmJit::Reg]
// ============================================================================

//! @brief General purpose register.
//!
//! This class is for all general purpose registers (64, 32, 16 and 8-bit).
struct ASMJIT_HIDDEN GPReg : public BaseReg
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create non-initialized general purpose register.
  inline GPReg() ASMJIT_NOTHROW :
    BaseReg(INVALID_VALUE, 0) {}

  //! @brief Create a reference to @a other general purpose register.
  inline GPReg(const GPReg& other) ASMJIT_NOTHROW :
    BaseReg(other) {}

#if !defined(ASMJIT_NODOC)
  inline GPReg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseReg(dontInitialize) {}

  inline GPReg(const _Initialize&, uint32_t code) ASMJIT_NOTHROW :
    BaseReg(code, static_cast<uint32_t>(1U << ((code & REG_TYPE_MASK) >> 12))) {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [GPReg Specific]
  // --------------------------------------------------------------------------

  //! @brief Get whether the general purpose register is BYTE (8-bit) type.
  inline bool isGPB() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) <= REG_TYPE_GPB_HI; }
  //! @brief Get whether the general purpose register is LO-BYTE (8-bit) type.
  inline bool isGPBLo() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) == REG_TYPE_GPB_LO; }
  //! @brief Get whether the general purpose register is HI-BYTE (8-bit) type.
  inline bool isGPBHi() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) == REG_TYPE_GPB_HI; }

  //! @brief Get whether the general purpose register is WORD (16-bit) type.
  inline bool isGPW() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) == REG_TYPE_GPW; }
  //! @brief Get whether the general purpose register is DWORD (32-bit) type.
  //!
  //! This is default type for 32-bit platforms.
  inline bool isGPD() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) == REG_TYPE_GPD; }
  //! @brief Get whether the general purpose register is QWORD (64-bit) type.
  //!
  //! This is default type for 64-bit platforms.
  inline bool isGPQ() const ASMJIT_NOTHROW { return (_reg.code & REG_TYPE_MASK) == REG_TYPE_GPQ; }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline GPReg& operator=(const GPReg& other) ASMJIT_NOTHROW { _copy(other); return *this; }
  inline bool operator==(const GPReg& other) const ASMJIT_NOTHROW { return getRegCode() == other.getRegCode(); }
  inline bool operator!=(const GPReg& other) const ASMJIT_NOTHROW { return getRegCode() != other.getRegCode(); }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::X87Register]
// ============================================================================

//! @brief 80-bit x87 floating point register.
//!
//! To create instance of x87 register, use @c st() function.
struct ASMJIT_HIDDEN X87Reg : public BaseReg
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create non-initialized x87 register.
  inline X87Reg() ASMJIT_NOTHROW :
    BaseReg(INVALID_VALUE, 10) {}

  //! @brief Create a reference to @a other x87 register.
  inline X87Reg(const X87Reg& other) ASMJIT_NOTHROW :
    BaseReg(other) {}

#if !defined(ASMJIT_NODOC)
  inline X87Reg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseReg(dontInitialize) {}

  inline X87Reg(const _Initialize&, uint32_t code) ASMJIT_NOTHROW :
    BaseReg(code | REG_TYPE_X87, 10) {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline X87Reg& operator=(const X87Reg& other) ASMJIT_NOTHROW { _copy(other); return *this; }
  inline bool operator==(const X87Reg& other) const ASMJIT_NOTHROW { return getRegCode() == other.getRegCode(); }
  inline bool operator!=(const X87Reg& other) const ASMJIT_NOTHROW { return getRegCode() != other.getRegCode(); }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::MMReg]
// ============================================================================

//! @brief 64-bit MMX register.
struct ASMJIT_HIDDEN MMReg : public BaseReg
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create non-initialized MM register.
  inline MMReg() ASMJIT_NOTHROW :
    BaseReg(INVALID_VALUE, 8) {}

  //! @brief Create a reference to @a other MM register.
  inline MMReg(const MMReg& other) ASMJIT_NOTHROW :
    BaseReg(other) {}

#if !defined(ASMJIT_NODOC)
  inline MMReg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseReg(dontInitialize) {}

  inline MMReg(const _Initialize&, uint32_t code) ASMJIT_NOTHROW :
    BaseReg(code, 8) {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline MMReg& operator=(const MMReg& other) ASMJIT_NOTHROW { _copy(other); return *this; }
  inline bool operator==(const MMReg& other) const ASMJIT_NOTHROW { return getRegCode() == other.getRegCode(); }
  inline bool operator!=(const MMReg& other) const ASMJIT_NOTHROW { return getRegCode() != other.getRegCode(); }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::XMMReg]
// ============================================================================

//! @brief 128-bit SSE register.
struct ASMJIT_HIDDEN XMMReg : public BaseReg
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create non-initialized XMM register.
  inline XMMReg() ASMJIT_NOTHROW :
    BaseReg(INVALID_VALUE, 16) {}

  //! @brief Create a reference to @a other XMM register.
  inline XMMReg(const _Initialize&, uint32_t code) ASMJIT_NOTHROW :
    BaseReg(code, 16) {}

#if !defined(ASMJIT_NODOC)
  inline XMMReg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseReg(dontInitialize) {}

  inline XMMReg(const XMMReg& other) ASMJIT_NOTHROW :
    BaseReg(other) {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline XMMReg& operator=(const XMMReg& other) ASMJIT_NOTHROW { _copy(other); return *this; }
  inline bool operator==(const XMMReg& other) const ASMJIT_NOTHROW { return getRegCode() == other.getRegCode(); }
  inline bool operator!=(const XMMReg& other) const ASMJIT_NOTHROW { return getRegCode() != other.getRegCode(); }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::SegmentReg]
// ============================================================================

//! @brief Segment register.
struct ASMJIT_HIDDEN SegmentReg : public BaseReg
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create non-initialized segment register.
  inline SegmentReg() ASMJIT_NOTHROW :
    BaseReg(INVALID_VALUE, 2) {}

  //! @brief Create a reference to @a other segment register.
  inline SegmentReg(const _Initialize&, uint32_t code) ASMJIT_NOTHROW :
    BaseReg(code, 2) {}

#if !defined(ASMJIT_NODOC)
  inline SegmentReg(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseReg(dontInitialize) {}

  inline SegmentReg(const SegmentReg& other) ASMJIT_NOTHROW :
    BaseReg(other) {}
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline SegmentReg& operator=(const SegmentReg& other) ASMJIT_NOTHROW { _copy(other); return *this; }
  inline bool operator==(const SegmentReg& other) const ASMJIT_NOTHROW { return getRegCode() == other.getRegCode(); }
  inline bool operator!=(const SegmentReg& other) const ASMJIT_NOTHROW { return getRegCode() != other.getRegCode(); }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::Registers - no_reg]
// ============================================================================

//! @brief No register, can be used only in @c Mem operand.
ASMJIT_VAR const GPReg no_reg;

// ============================================================================
// [AsmJit::Registers - 8-bit]
// ============================================================================

//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg al;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg cl;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg dl;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg bl;

#if defined(ASMJIT_X64)
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg spl;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg bpl;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg sil;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg dil;

//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r8b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r9b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r10b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r11b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r12b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r13b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r14b;
//! @brief 8-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r15b;
#endif // ASMJIT_X64

//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg ah;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg ch;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg dh;
//! @brief 8-bit General purpose register.
ASMJIT_VAR const GPReg bh;

// ============================================================================
// [AsmJit::Registers - 16-bit]
// ============================================================================

//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg ax;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg cx;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg dx;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg bx;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg sp;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg bp;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg si;
//! @brief 16-bit General purpose register.
ASMJIT_VAR const GPReg di;

#if defined(ASMJIT_X64)
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r8w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r9w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r10w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r11w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r12w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r13w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r14w;
//! @brief 16-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r15w;
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - 32-bit]
// ============================================================================

//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg eax;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ecx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg edx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ebx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg esp;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ebp;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg esi;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg edi;

#if defined(ASMJIT_X64)
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r8d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r9d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r10d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r11d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r12d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r13d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r14d;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg r15d;
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - 64-bit]
// ============================================================================

#if defined(ASMJIT_X64)
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rax;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rcx;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rdx;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rbx;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rsp;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rbp;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rsi;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg rdi;

//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r8;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r9;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r10;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r11;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r12;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r13;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r14;
//! @brief 64-bit General purpose register (64-bit mode only).
ASMJIT_VAR const GPReg r15;
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - Native (AsmJit extension)]
// ============================================================================

//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg nax;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ncx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ndx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg nbx;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg nsp;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg nbp;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg nsi;
//! @brief 32-bit General purpose register.
ASMJIT_VAR const GPReg ndi;

// ============================================================================
// [AsmJit::Registers - MM]
// ============================================================================

//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm0;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm1;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm2;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm3;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm4;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm5;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm6;
//! @brief 64-bit MM register.
ASMJIT_VAR const MMReg mm7;

// ============================================================================
// [AsmJit::Registers - XMM]
// ============================================================================

//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm0;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm1;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm2;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm3;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm4;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm5;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm6;
//! @brief 128-bit XMM register.
ASMJIT_VAR const XMMReg xmm7;

#if defined(ASMJIT_X64)
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm8;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm9;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm10;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm11;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm12;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm13;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm14;
//! @brief 128-bit XMM register (64-bit mode only).
ASMJIT_VAR const XMMReg xmm15;
#endif // ASMJIT_X64

// ============================================================================
// [AsmJit::Registers - Segment]
// ============================================================================

ASMJIT_VAR const SegmentReg cs;
ASMJIT_VAR const SegmentReg ss;
ASMJIT_VAR const SegmentReg ds;
ASMJIT_VAR const SegmentReg es;
ASMJIT_VAR const SegmentReg fs;
ASMJIT_VAR const SegmentReg gs;

// ============================================================================
// [AsmJit::Registers - Register From Index]
// ============================================================================

//! @brief Get general purpose register of byte size.
static inline GPReg gpb_lo(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPB_LO)); }

//! @brief Get general purpose register of byte size.
static inline GPReg gpb_hi(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPB_HI)); }

//! @brief Get general purpose register of word size.
static inline GPReg gpw(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPW)); }

//! @brief Get general purpose register of dword size.
static inline GPReg gpd(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPD)); }

#if defined(ASMJIT_X64)
//! @brief Get general purpose register of qword size (64-bit only).
static inline GPReg gpq(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPQ)); }
#endif

//! @brief Get general purpose dword/qword register (depending to architecture).
static inline GPReg gpn(uint32_t index) ASMJIT_NOTHROW
{ return GPReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_GPN)); }

//! @brief Get MMX (MM) register .
static inline MMReg mm(uint32_t index) ASMJIT_NOTHROW
{ return MMReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_MM)); }

//! @brief Get SSE (XMM) register.
static inline XMMReg xmm(uint32_t index) ASMJIT_NOTHROW
{ return XMMReg(_Initialize(), static_cast<uint32_t>(index | REG_TYPE_XMM)); }

//! @brief Get x87 register with index @a i.
static inline X87Reg st(uint32_t i) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(i < 8);
  return X87Reg(_Initialize(), static_cast<uint32_t>(i));
}

// ============================================================================
// [AsmJit::Imm]
// ============================================================================

//! @brief Immediate operand.
//!
//! Immediate operand is part of instruction (it's inlined after it).
//!
//! To create immediate operand, use @c imm() and @c uimm() constructors
//! or constructors provided by @c Immediate class itself.
struct ASMJIT_HIDDEN Imm : public Operand
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create a new immediate value (initial value is 0).
  Imm() ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _imm.op = OPERAND_IMM;
    _imm.size = 0;
    _imm.isUnsigned = false;
    _imm.reserved = 0;

    _imm.id = INVALID_VALUE;
    _imm.value = 0;
  }

  //! @brief Create a new signed immediate value, assigning the value to @a i.
  Imm(sysint_t i) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _imm.op = OPERAND_IMM;
    _imm.size = 0;
    _imm.isUnsigned = false;
    _imm.reserved = 0;

    _imm.id = INVALID_VALUE;
    _imm.value = i;
  }

  //! @brief Create a new signed or unsigned immediate value, assigning the value to @a i.
  Imm(sysint_t i, bool isUnsigned) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _imm.op = OPERAND_IMM;
    _imm.size = 0;
    _imm.isUnsigned = isUnsigned;
    _imm.reserved = 0;

    _imm.id = INVALID_VALUE;
    _imm.value = i;
  }

  //! @brief Create a new immediate value from @a other.
  inline Imm(const Imm& other) ASMJIT_NOTHROW :
    Operand(other) {}

  // --------------------------------------------------------------------------
  // [Immediate Specific]
  // --------------------------------------------------------------------------

  //! @brief Get whether an immediate is unsigned value.
  inline bool isUnsigned() const ASMJIT_NOTHROW { return _imm.isUnsigned != 0; }

  //! @brief Get signed immediate value.
  inline sysint_t getValue() const ASMJIT_NOTHROW { return _imm.value; }

  //! @brief Get unsigned immediate value.
  inline sysuint_t getUValue() const ASMJIT_NOTHROW { return (sysuint_t)_imm.value; }

  //! @brief Set immediate value as signed type to @a val.
  inline void setValue(sysint_t val, bool isUnsigned = false) ASMJIT_NOTHROW
  {
    _imm.value = val;
    _imm.isUnsigned = isUnsigned;
  }

  //! @brief Set immediate value as unsigned type to @a val.
  inline void setUValue(sysuint_t val) ASMJIT_NOTHROW
  {
    _imm.value = (sysint_t)val;
    _imm.isUnsigned = true;
  }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

  //! @brief Assign a signed value @a val to the immediate operand.
  inline Imm& operator=(sysint_t val) ASMJIT_NOTHROW
  { setValue(val); return *this; }

  //! @brief Assign @a other to the immediate operand.
  inline Imm& operator=(const Imm& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }
};

//! @brief Create signed immediate value operand.
ASMJIT_API Imm imm(sysint_t i) ASMJIT_NOTHROW;

//! @brief Create unsigned immediate value operand.
ASMJIT_API Imm uimm(sysuint_t i) ASMJIT_NOTHROW;

// ============================================================================
// [AsmJit::Label]
// ============================================================================

//! @brief Label (jump target or data location).
//!
//! Label represents locations typically used as jump targets, but may be also
//! used as position where are stored constants or static variables. If you 
//! want to use @c Label you need first to associate it with @c Assembler or
//! @c Compiler instance. To create new label use @c Assembler::newLabel() or
//! @c Compiler::newLabel().
//!
//! Example of using labels:
//!
//! @code
//! // Create Assembler or Compiler instance.
//! Assembler a;
//! 
//! // Create Label instance.
//! Label L_1(a);
//!
//! // ... your code ...
//!
//! // Using label, see @c AsmJit::Assembler or @c AsmJit::Compiler.
//! a.jump(L_1);
//!
//! // ... your code ...
//!
//! // Bind label to current position, see @c AsmJit::Assembler::bind() or
//! // @c AsmJit::Compiler::bind().
//! a.bind(L_1);
//! @endcode
struct ASMJIT_HIDDEN Label : public Operand
{
  inline Label() : Operand(_DontInitialize())  // Create new, unassociated label.
  {
    _lbl.op = OPERAND_LABEL;
    _lbl.size = 0;
    _lbl.id = INVALID_VALUE;
  }

  inline Label(const Label& other) : Operand(other)  // Create reference to another label.
  {
  }

  inline ~Label()
  {
  }

  inline Label& operator=(const Label& other) { _copy(other); return *this; }

  inline bool operator==(const Label& other)  { return _base.id == other._base.id; }
  inline bool operator!=(const Label& other)  { return _base.id != other._base.id; }
};

// ============================================================================
// [AsmJit::Mem]
// ============================================================================

//! @brief Memory operand.
struct ASMJIT_HIDDEN Mem : public Operand
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline Mem() ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _mem.op = OPERAND_MEM;
    _mem.size = 0;
    _mem.type = OPERAND_MEM_NATIVE;
    _mem.segmentPrefix = SEGMENT_NONE;
    _mem.sizePrefix = 0;
    _mem.shift = 0;

    _mem.id    = INVALID_VALUE;
    _mem.base  = INVALID_VALUE;
    _mem.index = INVALID_VALUE;

    _mem.target = NULL;
    _mem.displacement = 0;
  }

  inline Mem(const Label& label, sysint_t displacement, uint32_t size = 0) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _mem.op = OPERAND_MEM;
    _mem.size = (uint8_t)size;
    _mem.type = OPERAND_MEM_LABEL;
    _mem.segmentPrefix = SEGMENT_NONE;
    _mem.sizePrefix = 0;
    _mem.shift = 0;

    _mem.id = INVALID_VALUE;
    _mem.base = reinterpret_cast<const Operand&>(label)._base.id;
    _mem.index = INVALID_VALUE;

    _mem.target = NULL;
    _mem.displacement = displacement;
  }

  inline Mem(const GPReg& base, sysint_t displacement, uint32_t size = 0) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _mem.op = OPERAND_MEM;
    _mem.size = (uint8_t)size;
    _mem.type = OPERAND_MEM_NATIVE;
    _mem.segmentPrefix = SEGMENT_NONE;

#if defined(ASMJIT_X86)
    _mem.sizePrefix = base.getSize() != 4;
#else
    _mem.sizePrefix = base.getSize() != 8;
#endif

    _mem.shift = 0;

    _mem.id = INVALID_VALUE;
    _mem.base = base.getRegCode() & REG_INDEX_MASK;
    _mem.index = INVALID_VALUE;

    _mem.target = NULL;
    _mem.displacement = displacement;
  }

	inline Mem(const GPReg& base, sysint_t displacement, uint32_t size, uint32_t segmentPrefix) ASMJIT_NOTHROW :   //自己添加的
	Operand(_DontInitialize())
	{
		_mem.op = OPERAND_MEM;
		_mem.size = (uint8_t)size;
		_mem.type = OPERAND_MEM_NATIVE;
		_mem.segmentPrefix = segmentPrefix;

#if defined(ASMJIT_X86)
		_mem.sizePrefix = base.getSize() != 4;
#else
		_mem.sizePrefix = base.getSize() != 8;
#endif

		_mem.shift = 0;

		_mem.id = INVALID_VALUE;
		_mem.base = base.getRegCode() & REG_INDEX_MASK;
		_mem.index = INVALID_VALUE;

		_mem.target = NULL;
		_mem.displacement = displacement;
	}

  inline Mem(const GPVar& base, sysint_t displacement, uint32_t size = 0) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _mem.op = OPERAND_MEM;
    _mem.size = (uint8_t)size;
    _mem.type = OPERAND_MEM_NATIVE;
    _mem.segmentPrefix = SEGMENT_NONE;

#if defined(ASMJIT_X86)
    _mem.sizePrefix = (reinterpret_cast<const Operand&>(base)._var.size) != 4;
#else
    _mem.sizePrefix = (reinterpret_cast<const Operand&>(base)._var.size) != 8;
#endif

    _mem.shift = 0;

    _mem.id = INVALID_VALUE;
    _mem.base = reinterpret_cast<const Operand&>(base).getId();
    _mem.index = INVALID_VALUE;

    _mem.target = NULL;
    _mem.displacement = displacement;
  }

  inline Mem(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t displacement, uint32_t size = 0) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    ASMJIT_ASSERT(shift <= 3);

    _mem.op = OPERAND_MEM;
    _mem.size = (uint8_t)size;
    _mem.type = OPERAND_MEM_NATIVE;
    _mem.segmentPrefix = SEGMENT_NONE;

#if defined(ASMJIT_X86)
    _mem.sizePrefix = (base.getSize() | index.getSize()) != 4;
#else
    _mem.sizePrefix = (base.getSize() | index.getSize()) != 8;
#endif

    _mem.shift = (uint8_t)shift;

    _mem.id = INVALID_VALUE;
    _mem.base = base.getRegIndex();
    _mem.index = index.getRegIndex();

    _mem.target = NULL;
    _mem.displacement = displacement;
  }

	inline Mem(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t displacement, uint32_t size, uint32_t segmentPrefix ) ASMJIT_NOTHROW :  //自己添加的
	Operand(_DontInitialize())
	{
		ASMJIT_ASSERT(shift <= 3);

		_mem.op = OPERAND_MEM;
		_mem.size = (uint8_t)size;
		_mem.type = OPERAND_MEM_NATIVE;
		//_mem.segmentPrefix = SEGMENT_NONE;.
		_mem.segmentPrefix = segmentPrefix;

	#if defined(ASMJIT_X86)
		_mem.sizePrefix = (base.getSize() | index.getSize()) != 4;
	#else
		_mem.sizePrefix = (base.getSize() | index.getSize()) != 8;
	#endif

		_mem.shift = (uint8_t)shift;

		_mem.id = INVALID_VALUE;
		_mem.base = base.getRegIndex();
		_mem.index = index.getRegIndex();

		_mem.target = NULL;
		_mem.displacement = displacement;
	}

  inline Mem(const GPVar& base, const GPVar& index, uint32_t shift, sysint_t displacement, uint32_t size = 0) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    ASMJIT_ASSERT(shift <= 3);

    _mem.op = OPERAND_MEM;
    _mem.size = (uint8_t)size;
    _mem.type = OPERAND_MEM_NATIVE;
    _mem.segmentPrefix = SEGMENT_NONE;

#if defined(ASMJIT_X86)
    _mem.sizePrefix = (reinterpret_cast<const Operand&>(base )._var.size | 
                       reinterpret_cast<const Operand&>(index)._var.size ) != 4;
#else
    _mem.sizePrefix = (reinterpret_cast<const Operand&>(base )._var.size | 
                       reinterpret_cast<const Operand&>(index)._var.size ) != 8;
#endif

    _mem.shift = (uint8_t)shift;

    _mem.id = INVALID_VALUE;
    _mem.base = reinterpret_cast<const Operand&>(base).getId();
    _mem.index = reinterpret_cast<const Operand&>(index).getId();

    _mem.target = NULL;
    _mem.displacement = displacement;
  }

  inline Mem(const Mem& other) ASMJIT_NOTHROW :
    Operand(other)
  {
  }

  inline Mem(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    Operand(dontInitialize)
  {
  }

  // --------------------------------------------------------------------------
  // [Mem Specific]
  // --------------------------------------------------------------------------

  //! @brief Get type of memory operand, see @c OPERAND_MEM_TYPE enum.
  inline uint32_t getMemType() const ASMJIT_NOTHROW
  { return _mem.type; }

  //! @brief Get memory operand segment prefix, see @c SEGMENT_PREFIX enum.
  inline uint32_t getSegmentPrefix() const ASMJIT_NOTHROW
  { return _mem.segmentPrefix; }

  //! @brief Get whether the memory operand has base register.
  inline bool hasBase() const ASMJIT_NOTHROW
  { return _mem.base != INVALID_VALUE; }

  //! @brief Get whether the memory operand has index.
  inline bool hasIndex() const ASMJIT_NOTHROW
  { return _mem.index != INVALID_VALUE; }

  //! @brief Get whether the memory operand has shift used.
  inline bool hasShift() const ASMJIT_NOTHROW
  { return _mem.shift != 0; }

  //! @brief Get memory operand base register or @c INVALID_VALUE.
  inline uint32_t getBase() const ASMJIT_NOTHROW
  { return _mem.base; }

  //! @brief Get memory operand index register or @c INVALID_VALUE.
  inline uint32_t getIndex() const ASMJIT_NOTHROW
  { return _mem.index; }

  //! @brief Get memory operand index scale (0, 1, 2 or 3).
  inline uint32_t getShift() const ASMJIT_NOTHROW
  { return _mem.shift; }

  //! @brief Get whether to use size-override prefix.
  //!
  //! @note This is useful only for MOV and LEA type of instructions.
  inline bool getSizePrefix() const ASMJIT_NOTHROW
  { return _mem.sizePrefix; }
  
  //! @brief Set whether to use size-override prefix.
  inline void setSizePrefix(bool b) ASMJIT_NOTHROW
  { _mem.sizePrefix = b; }

  //! @brief Get absolute target address.
  //!
  //! @note You should always check if operand contains address by @c getMemType().
  inline void* getTarget() const ASMJIT_NOTHROW
  { return _mem.target; }

  //! @brief Set memory operand size.
  inline void setSize(uint32_t size) ASMJIT_NOTHROW
  { _mem.size = size; }

  //! @brief Set absolute target address.
  inline void setTarget(void* target) ASMJIT_NOTHROW
  { _mem.target = target; }

  //! @brief Get memory operand relative displacement.
  inline sysint_t getDisplacement() const ASMJIT_NOTHROW
  { return _mem.displacement; }

  //! @brief Set memory operand relative displacement.
  inline void setDisplacement(sysint_t displacement) ASMJIT_NOTHROW
  { _mem.displacement = displacement; }

  //! @brief Adjust memory operand relative displacement by @a displacement.
  inline void adjust(sysint_t displacement) ASMJIT_NOTHROW
  {
    _mem.displacement += displacement;
  }

  //! @brief Get new memory operand adjusted by @a displacement.
  inline Mem adjusted(sysint_t displacement) const ASMJIT_NOTHROW
  {
    Mem result(*this);
    result.adjust(displacement);
    return result;
  }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline Mem& operator=(const Mem& other) ASMJIT_NOTHROW
  {
    _copy(other);
    return *this;
  }

  inline bool operator==(const Mem& other) const ASMJIT_NOTHROW
  {
    return _bin.u32[0] == other._bin.u32[0] &&
           _bin.u32[1] == other._bin.u32[1] &&
           _bin.u32[2] == other._bin.u32[2] &&
           _bin.u32[3] == other._bin.u32[3] &&
           _bin.s[0] == other._bin.s[0] &&
           _bin.s[1] == other._bin.s[1];
  }

  inline bool operator!=(const Mem& other) const ASMJIT_NOTHROW
  {
    return !(*this == other);
  }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::BaseVar]
// ============================================================================

ASMJIT_API Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize) ASMJIT_NOTHROW;
ASMJIT_API Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize, sysint_t disp) ASMJIT_NOTHROW;
ASMJIT_API Mem _BaseVarMem(const BaseVar& var, uint32_t ptrSize, const GPVar& index, uint32_t shift, sysint_t disp) ASMJIT_NOTHROW;

//! @brief Base class for all variables.
struct ASMJIT_HIDDEN BaseVar : public Operand
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline BaseVar(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    Operand(dontInitialize)
  {
  }
#endif // ASMJIT_NODOC

  inline BaseVar() ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = 0;
    _var.registerCode = INVALID_VALUE;
    _var.variableType = INVALID_VALUE;
    _var.id = INVALID_VALUE;
  }

  inline BaseVar(const BaseVar& other) ASMJIT_NOTHROW :
    Operand(other)
  {
  }

  // --------------------------------------------------------------------------
  // [Type]
  // --------------------------------------------------------------------------

  inline uint32_t getVariableType() const ASMJIT_NOTHROW
  { return _var.variableType; }

  inline bool isGPVar() const ASMJIT_NOTHROW
  { return _var.variableType <= VARIABLE_TYPE_GPQ; }

  inline bool isX87Var() const ASMJIT_NOTHROW
  { return _var.variableType >= VARIABLE_TYPE_X87 && _var.variableType <= VARIABLE_TYPE_X87_1D; }

  inline bool isMMVar() const ASMJIT_NOTHROW
  { return _var.variableType == VARIABLE_TYPE_MM; }

  inline bool isXMMVar() const ASMJIT_NOTHROW
  { return _var.variableType >= VARIABLE_TYPE_XMM && _var.variableType <= VARIABLE_TYPE_XMM_2D; }

  // --------------------------------------------------------------------------
  // [Memory Cast]
  // --------------------------------------------------------------------------

  //! @brief Cast this variable to memory operand.
  //!
  //! @note Size of operand depends on native variable type, you can use other
  //! variants if you want specific one.
  inline Mem m() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, INVALID_VALUE); }

  //! @overload.
  inline Mem m(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, INVALID_VALUE, disp); }

  //! @overload.
  inline Mem m(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, INVALID_VALUE, index, shift, disp); }

  //! @brief Cast this variable to 8-bit memory operand.
  inline Mem m8() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 1); }

  //! @overload.
  inline Mem m8(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 1, disp); }

  //! @overload.
  inline Mem m8(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 1, index, shift, disp); }

  //! @brief Cast this variable to 16-bit memory operand.
  inline Mem m16() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 2); }

  //! @overload.
  inline Mem m16(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 2, disp); }

  //! @overload.
  inline Mem m16(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 2, index, shift, disp); }

  //! @brief Cast this variable to 32-bit memory operand.
  inline Mem m32() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 4); }

  //! @overload.
  inline Mem m32(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 4, disp); }

  //! @overload.
  inline Mem m32(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 4, index, shift, disp); }

  //! @brief Cast this variable to 64-bit memory operand.
  inline Mem m64() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 8); }

  //! @overload.
  inline Mem m64(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 8, disp); }

  //! @overload.
  inline Mem m64(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 8, index, shift, disp); }

  //! @brief Cast this variable to 80-bit memory operand (long double).
  inline Mem m80() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 10); }

  //! @overload.
  inline Mem m80(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 10, disp); }

  //! @overload.
  inline Mem m80(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 10, index, shift, disp); }

  //! @brief Cast this variable to 128-bit memory operand.
  inline Mem m128() const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 16); }

  //! @overload.
  inline Mem m128(sysint_t disp) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 16, disp); }

  //! @overload.
  inline Mem m128(const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) const ASMJIT_NOTHROW
  { return _BaseVarMem(*this, 16, index, shift, disp); }

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline BaseVar& operator=(const BaseVar& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const BaseVar& other) const ASMJIT_NOTHROW { return _base.id == other._base.id && _var.registerCode == other._var.registerCode; }
  inline bool operator!=(const BaseVar& other) const ASMJIT_NOTHROW { return _base.id != other._base.id || _var.registerCode != other._var.registerCode; }
#endif // ASMJIT_NODOC

  // --------------------------------------------------------------------------
  // [Private]
  // --------------------------------------------------------------------------

protected:
  inline BaseVar(const BaseVar& other, uint32_t registerCode, uint32_t size) ASMJIT_NOTHROW :
    Operand(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = (uint8_t)size;
    _var.id = other._base.id;
    _var.registerCode = registerCode;
    _var.variableType = other._var.variableType;
  }
};

// ============================================================================
// [AsmJit::X87Var]
// ============================================================================

//! @brief X87 Variable operand.
struct ASMJIT_HIDDEN X87Var : public BaseVar
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline X87Var(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseVar(dontInitialize)
  {
  }

  inline X87Var() ASMJIT_NOTHROW :
    BaseVar(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = 12;
    _var.id = INVALID_VALUE;

    _var.registerCode = REG_TYPE_X87;
    _var.variableType = VARIABLE_TYPE_X87;
  }

  inline X87Var(const X87Var& other) ASMJIT_NOTHROW :
    BaseVar(other) {}

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline X87Var& operator=(const X87Var& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const X87Var& other) const ASMJIT_NOTHROW { return _base.id == other._base.id; }
  inline bool operator!=(const X87Var& other) const ASMJIT_NOTHROW { return _base.id != other._base.id; }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::GPVar]
// ============================================================================

//! @brief GP variable operand.
struct ASMJIT_HIDDEN GPVar : public BaseVar
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new uninitialized @c GPVar instance (internal constructor).
  inline GPVar(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseVar(dontInitialize)
  {
  }

  //! @brief Create new uninitialized @c GPVar instance.
  inline GPVar() ASMJIT_NOTHROW :
    BaseVar(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = sizeof(sysint_t);
    _var.id = INVALID_VALUE;

    _var.registerCode = REG_TYPE_GPN;
    _var.variableType = VARIABLE_TYPE_GPN;
  }

  //! @brief Create new @c GPVar instance using @a other.
  //!
  //! Note this will not create a different variable, use @c Compiler::newGP()
  //! if you want to do so. This is only copy-constructor that allows to store
  //! the same variable in different places.
  inline GPVar(const GPVar& other) : BaseVar(other)
  {}

  // --------------------------------------------------------------------------
  // [GPVar Specific]
  // --------------------------------------------------------------------------

  //! @brief Get whether this variable is general purpose BYTE register.
  inline bool isGPB()   const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) <= REG_TYPE_GPB_HI; }
  //! @brief Get whether this variable is general purpose BYTE.LO register.
  inline bool isGPBLo() const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) == REG_TYPE_GPB_LO; }
  //! @brief Get whether this variable is general purpose BYTE.HI register.
  inline bool isGPBHi() const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) == REG_TYPE_GPB_HI; }

  //! @brief Get whether this variable is general purpose WORD register.
  inline bool isGPW() const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) == REG_TYPE_GPW; }
  //! @brief Get whether this variable is general purpose DWORD register.
  inline bool isGPD() const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) == REG_TYPE_GPD; }
  //! @brief Get whether this variable is general purpose QWORD (only 64-bit) register.
  inline bool isGPQ() const ASMJIT_NOTHROW { return (_var.registerCode & REG_TYPE_MASK) == REG_TYPE_GPQ; }

  // --------------------------------------------------------------------------
  // [GPVar Cast]
  // --------------------------------------------------------------------------

  //! @brief Cast this variable to 8-bit (LO) part of variable
  inline GPVar r8()   const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPB_LO, 1); }
  //! @brief Cast this variable to 8-bit (LO) part of variable
  inline GPVar r8Lo() const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPB_LO, 1); }
  //! @brief Cast this variable to 8-bit (HI) part of variable
  inline GPVar r8Hi() const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPB_HI, 1); }

  //! @brief Cast this variable to 16-bit part of variable
  inline GPVar r16() const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPW, 2); }
  //! @brief Cast this variable to 32-bit part of variable
  inline GPVar r32() const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPD, 4); }

#if defined(ASMJIT_X64)
  //! @brief Cast this variable to 64-bit part of variable
  inline GPVar r64() const ASMJIT_NOTHROW { return GPVar(*this, REG_TYPE_GPQ, 8); }
#endif // ASMJIT_X64

#if !defined(ASMJIT_NODOC)
  inline GPVar& operator=(const GPVar& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const GPVar& other) const ASMJIT_NOTHROW { return _base.id == other._base.id && _var.registerCode == other._var.registerCode; }
  inline bool operator!=(const GPVar& other) const ASMJIT_NOTHROW { return _base.id != other._base.id || _var.registerCode != other._var.registerCode; }
#endif

protected:
  inline GPVar(const GPVar& other, uint32_t registerCode, uint32_t size) :
    BaseVar(other, registerCode, size)
  {
  }
};

// ============================================================================
// [AsmJit::MMVar]
// ============================================================================

//! @brief MM variable operand.
struct ASMJIT_HIDDEN MMVar : public BaseVar
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new uninitialized @c MMVar instance (internal constructor).
  inline MMVar(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseVar(dontInitialize)
  {
  }

  //! @brief Create new uninitialized @c MMVar instance.
  inline MMVar() ASMJIT_NOTHROW :
    BaseVar(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = 8;
    _var.id = INVALID_VALUE;

    _var.registerCode = REG_TYPE_MM;
    _var.variableType = VARIABLE_TYPE_MM;
  }

  //! @brief Create new @c MMVar instance using @a other.
  //!
  //! Note this will not create a different variable, use @c Compiler::newMM()
  //! if you want to do so. This is only copy-constructor that allows to store
  //! the same variable in different places.
  inline MMVar(const MMVar& other) ASMJIT_NOTHROW :
    BaseVar(other) {}

  // --------------------------------------------------------------------------
  // [MMVar Cast]
  // --------------------------------------------------------------------------

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline MMVar& operator=(const MMVar& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const MMVar& other) const ASMJIT_NOTHROW { return _base.id == other._base.id; }
  inline bool operator!=(const MMVar& other) const ASMJIT_NOTHROW { return _base.id != other._base.id; }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::XMMVar]
// ============================================================================

//! @brief XMM Variable operand.
struct ASMJIT_HIDDEN XMMVar : public BaseVar
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline XMMVar(const _DontInitialize& dontInitialize) ASMJIT_NOTHROW :
    BaseVar(dontInitialize)
  {
  }

  inline XMMVar() ASMJIT_NOTHROW :
    BaseVar(_DontInitialize())
  {
    _var.op = OPERAND_VAR;
    _var.size = 16;
    _var.id = INVALID_VALUE;

    _var.registerCode = REG_TYPE_XMM;
    _var.variableType = VARIABLE_TYPE_XMM;
  }

  inline XMMVar(const XMMVar& other) ASMJIT_NOTHROW :
    BaseVar(other) {}

  // --------------------------------------------------------------------------
  // [XMMVar Access]
  // --------------------------------------------------------------------------

  // --------------------------------------------------------------------------
  // [Operator Overload]
  // --------------------------------------------------------------------------

#if !defined(ASMJIT_NODOC)
  inline XMMVar& operator=(const XMMVar& other) ASMJIT_NOTHROW
  { _copy(other); return *this; }

  inline bool operator==(const XMMVar& other) const ASMJIT_NOTHROW { return _base.id == other._base.id; }
  inline bool operator!=(const XMMVar& other) const ASMJIT_NOTHROW { return _base.id != other._base.id; }
#endif // ASMJIT_NODOC
};

// ============================================================================
// [AsmJit::Mem - ptr[displacement]]
// ============================================================================

//! @internal
ASMJIT_API Mem _MemPtrBuild(const Label& label, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrBuild(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrBuild(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

ASMJIT_API Mem _MemPtrBuild(
	const GPReg& base, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix)
	ASMJIT_NOTHROW;

ASMJIT_API Mem _MemPtrBuild(
	const GPReg& base,
	const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix)
	ASMJIT_NOTHROW;

//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const Label& label, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, disp, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const Label& label, const GPReg& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const Label& label, const GPVar& index, uint32_t shift, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(label, index, shift, disp, sizeof(sysint_t)); }

// ============================================================================
// [AsmJit::Mem - Absolute Addressing]
// ============================================================================

//! @internal
ASMJIT_API Mem _MemPtrAbs(
  void* target,
  sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrAbs(
  void* target,
  const GPReg& index, uint32_t shift, sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrAbs(
  void* target,
  const GPVar& index, uint32_t shift, sysint_t disp,
  uint32_t segmentPrefix, uint32_t ptrSize) ASMJIT_NOTHROW;



//! @brief Create pointer operand with not specified size.
static inline Mem ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr_abs(void* target, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, disp, segmentPrefix, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr_abs(void* target, const GPReg& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr_abs(void* target, const GPVar& index, uint32_t shift, sysint_t disp = 0, uint32_t segmentPrefix = SEGMENT_NONE) ASMJIT_NOTHROW
{ return _MemPtrAbs(target, index, shift, disp, segmentPrefix, sizeof(sysint_t)); }

// ============================================================================
// [AsmJit::Mem - ptr[base + displacement]]
// ============================================================================

//! @internal
ASMJIT_API Mem _MemPtrBuild(const GPReg& base, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrBuild(const GPVar& base, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;



//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const GPReg& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 bytes) pointer operand
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const GPVar& base, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, sizeof(sysint_t)); }

// ============================================================================
// [AsmJit::Mem - ptr[base + (index << shift) + displacement]]
// ============================================================================

//! @internal
ASMJIT_API Mem _MemPtrBuild(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

//! @internal
ASMJIT_API Mem _MemPtrBuild(const GPVar& base, const GPVar& index, uint32_t shift, sysint_t disp, uint32_t ptrSize) ASMJIT_NOTHROW;

ASMJIT_API Mem _MemPtrBuild(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix) ASMJIT_NOTHROW; //自己添加的

ASMJIT_API Mem _MemPtrBuild(const GPReg& base, sysint_t disp, uint32_t ptrSize, uint32_t segmentPrefix) ASMJIT_NOTHROW;


//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 Bytes) pointer operand).
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 Bytes) pointer operand.
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const GPReg& base, const GPReg& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, sizeof(sysint_t)); }



//! @brief Create pointer operand with not specified size.
static inline Mem ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, 0); }

//! @brief Create byte pointer operand.
static inline Mem byte_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_BYTE); }

//! @brief Create word (2 Bytes) pointer operand.
static inline Mem word_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_WORD); }

//! @brief Create dword (4 Bytes) pointer operand.
static inline Mem dword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DWORD); }

//! @brief Create qword (8 Bytes) pointer operand.
static inline Mem qword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_QWORD); }

//! @brief Create tword (10 Bytes) pointer operand (used for 80-bit floating points).
static inline Mem tword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_TWORD); }

//! @brief Create dqword (16 Bytes) pointer operand.
static inline Mem dqword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DQWORD); }

//! @brief Create mmword (8 Bytes) pointer operand).
//!
//! @note This constructor is provided only for convenience for mmx programming.
static inline Mem mmword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_QWORD); }

//! @brief Create xmmword (16 Bytes) pointer operand.
//!
//! @note This constructor is provided only for convenience for sse programming.
static inline Mem xmmword_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DQWORD); }

//! @brief Create system dependent pointer operand (32-bit or 64-bit).
static inline Mem sysint_ptr(const GPVar& base, const GPVar& index, uint32_t shift = 0, sysint_t disp = 0) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, sizeof(sysint_t)); }

static inline Mem byte_ptr(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW        //自己添加的
{ return _MemPtrBuild(base, index, shift, disp, SIZE_BYTE, segmentPrefix); }

static inline Mem word_ptr(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_WORD, segmentPrefix); }

static inline Mem dword_ptr(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_DWORD, segmentPrefix); }

static inline Mem qword_ptr(const GPReg& base, const GPReg& index, uint32_t shift, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, index, shift, disp, SIZE_QWORD, segmentPrefix); }

static inline Mem byte_ptr(const GPReg& base, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_BYTE, segmentPrefix); }

static inline Mem word_ptr(const GPReg& base, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_WORD, segmentPrefix); }

static inline Mem dword_ptr(const GPReg& base, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_DWORD, segmentPrefix); }

static inline Mem qword_ptr(const GPReg& base, sysint_t disp ,uint32_t segmentPrefix) ASMJIT_NOTHROW
{ return _MemPtrBuild(base, disp, SIZE_QWORD, segmentPrefix); }
// ============================================================================
// [AsmJit::Macros]
// ============================================================================

//! @brief Create Shuffle Constant for MMX/SSE shuffle instrutions.
//! @param z First component position, number at interval [0, 3] inclusive.
//! @param x Second component position, number at interval [0, 3] inclusive.
//! @param y Third component position, number at interval [0, 3] inclusive.
//! @param w Fourth component position, number at interval [0, 3] inclusive.
//!
//! Shuffle constants can be used to make immediate value for these intrinsics:
//! - @c AsmJit::AssemblerIntrinsics::pshufw()
//! - @c AsmJit::AssemblerIntrinsics::pshufd()
//! - @c AsmJit::AssemblerIntrinsics::pshufhw()
//! - @c AsmJit::AssemblerIntrinsics::pshuflw()
//! - @c AsmJit::AssemblerIntrinsics::shufps()
static inline uint8_t mm_shuffle(uint8_t z, uint8_t y, uint8_t x, uint8_t w) ASMJIT_NOTHROW
{ return (z << 6) | (y << 4) | (x << 2) | w; }

//! @}

} // AsmJit namespace

// [Guard]
#endif // _ASMJIT_OPERANDX86X64_H

```

`AsmJit/Platform.cpp`:

```cpp
// [AsmJit]
// Complete JIT Assembler for C++ Language.
//
// [License]
// Zlib - See COPYING file in this package.

// [Dependencies]
#include <stdio.h>

#include "Platform.h"

// [Api-Begin]
#include "ApiBegin.h"

#if defined(_MSC_VER)
#pragma warning(disable:4311)
#endif

// helpers
namespace AsmJit {

// ============================================================================
// [AsmJit::Assert]
// ============================================================================

void assertionFailure(const char* file, int line, const char* exp)
{
  fprintf(stderr,
    "*** ASSERTION FAILURE at %s (line %d)\n"
    "*** %s\n", file, line, exp);

  exit(1);
}

// ============================================================================
// [AsmJit::Helpers]
// ============================================================================

static bool isAligned(sysuint_t base, sysuint_t alignment)
{
  return base % alignment == 0;
}

static sysuint_t roundUp(sysuint_t base, sysuint_t pageSize)
{
  sysuint_t over = base % pageSize;
  return base + (over > 0 ? pageSize - over : 0);
}

// Implementation is from "Hacker's Delight" by Henry S. Warren, Jr.,
// figure 3-3, page 48, where the function is called clp2.
static sysuint_t roundUpToPowerOf2(sysuint_t base)
{
  base -= 1;

  base = base | (base >> 1);
  base = base | (base >> 2);
  base = base | (base >> 4);
  base = base | (base >> 8);
  base = base | (base >> 16);

  // I'm trying to make this portable and MSVC strikes me the warning C4293:
  //   "Shift count negative or too big, undefined behavior"
  // Fixing...
#if _MSC_VER
# pragma warning(disable: 4293)
#endif // _MSC_VER

  if (sizeof(sysuint_t) >= 8)
    base = base | (base >> 32);

  return base + 1;
}

} // AsmJit namespace

// ============================================================================
// [AsmJit::VirtualMemory::Windows]
// ============================================================================

#if defined(ASMJIT_WINDOWS)

#include <windows.h>

namespace AsmJit {

struct ASMJIT_HIDDEN VirtualMemoryLocal
{
  VirtualMemoryLocal() ASMJIT_NOTHROW
  {
    SYSTEM_INFO info;
    GetSystemInfo(&info);

    alignment = info.dwAllocationGranularity;
    pageSize = roundUpToPowerOf2(info.dwPageSize);
  }

  sysuint_t alignment;
  sysuint_t pageSize;
};

static VirtualMemoryLocal& vm() ASMJIT_NOTHROW
{
  static VirtualMemoryLocal vm;
  return vm;
};

void* VirtualMemory::alloc(sysuint_t length, sysuint_t* allocated, bool canExecute)
  ASMJIT_NOTHROW
{
  return allocProcessMemory(GetCurrentProcess(), length, allocated, canExecute);
}

void VirtualMemory::free(void* addr, sysuint_t length)
  ASMJIT_NOTHROW
{
  return freeProcessMemory(GetCurrentProcess(), addr, length);
}

void* VirtualMemory::allocProcessMemory(HANDLE hProcess, sysuint_t length, sysuint_t* allocated, bool canExecute) ASMJIT_NOTHROW
{
  // VirtualAlloc rounds allocated size to page size automatically.
  sysuint_t msize = roundUp(length, vm().pageSize);

  // Windows XP SP2 / Vista allow Data Excution Prevention (DEP).
  WORD protect = canExecute ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
  LPVOID mbase = VirtualAllocEx(hProcess, NULL, msize, MEM_COMMIT | MEM_RESERVE, protect);
  if (mbase == NULL) return NULL;

  ASMJIT_ASSERT(isAligned(reinterpret_cast<sysuint_t>(mbase), vm().alignment));

  if (allocated) *allocated = msize;
  return mbase;
}

void VirtualMemory::freeProcessMemory(HANDLE hProcess, void* addr, sysuint_t /* length */) ASMJIT_NOTHROW
{
  VirtualFreeEx(hProcess, addr, 0, MEM_RELEASE);
}

sysuint_t VirtualMemory::getAlignment()
  ASMJIT_NOTHROW
{
  return vm().alignment;
}

sysuint_t VirtualMemory::getPageSize()
  ASMJIT_NOTHROW
{
  return vm().pageSize;
}

} // AsmJit

#endif // ASMJIT_WINDOWS

// ============================================================================
// [AsmJit::VirtualMemory::Posix]
// ============================================================================

#if defined(ASMJIT_POSIX)

#include <sys/types.h>
#include <sys/mman.h>
#include <unistd.h>

// MacOS uses MAP_ANON instead of MAP_ANONYMOUS
#ifndef MAP_ANONYMOUS
# define MAP_ANONYMOUS MAP_ANON
#endif

namespace AsmJit {

struct ASMJIT_HIDDEN VirtualMemoryLocal
{
  VirtualMemoryLocal() ASMJIT_NOTHROW
  {
    alignment = pageSize = getpagesize();
  }

  sysuint_t alignment;
  sysuint_t pageSize;
};

static VirtualMemoryLocal& vm()
  ASMJIT_NOTHROW
{
  static VirtualMemoryLocal vm;
  return vm;
}

void* VirtualMemory::alloc(sysuint_t length, sysuint_t* allocated, bool canExecute)
  ASMJIT_NOTHROW
{
  sysuint_t msize = roundUp(length, vm().pageSize);
  int protection = PROT_READ | PROT_WRITE | (canExecute ? PROT_EXEC : 0);
  void* mbase = mmap(NULL, msize, protection, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (mbase == MAP_FAILED) return NULL;
  if (allocated) *allocated = msize;
  return mbase;
}

void VirtualMemory::free(void* addr, sysuint_t length)
  ASMJIT_NOTHROW
{
  munmap(addr, length);
}

sysuint_t VirtualMemory::getAlignment()
  ASMJIT_NOTHROW
{
  return vm().alignment;
}

sysuint_t VirtualMemory::getPageSize()
  ASMJIT_NOTHROW
{
  return vm().pageSize;
}

} // AsmJit

#endif // ASMJIT_POSIX

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/Platform.h`:

```h

#ifndef _ASMJIT_PLATFORM_H
#define _ASMJIT_PLATFORM_H

#include "Build.h"

#if defined(ASMJIT_WINDOWS)
#include <windows.h>
#elif defined(ASMJIT_POSIX)
#include <pthread.h>
#endif


#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

//! @addtogroup AsmJit_Util
//! @{

// ============================================================================
// [AsmJit::Assert]
// ============================================================================

//! @brief Called in debug build on assertion failure.
//! @param file Source file name where it happened.
//! @param line Line in the source file.
//! @param exp Expression what failed.
//!
//! If you have problems with assertions simply put a breakpoint into
//! AsmJit::assertionFailure() method (see AsmJit/Platform.cpp file) and see
//! call stack.
ASMJIT_API void assertionFailure(const char* file, int line, const char* exp);

// ============================================================================
// [AsmJit::Lock]
// ============================================================================

//! @brief Lock - used in thread-safe code for locking.
struct ASMJIT_HIDDEN Lock
{
#if defined(ASMJIT_WINDOWS)
  typedef CRITICAL_SECTION Handle;
#endif // ASMJIT_WINDOWS
#if defined(ASMJIT_POSIX)
  typedef pthread_mutex_t Handle;
#endif // ASMJIT_POSIX

  //! @brief Create a new @ref Lock instance.
  inline Lock() ASMJIT_NOTHROW
  {
#if defined(ASMJIT_WINDOWS)
    InitializeCriticalSection(&_handle);
    // InitializeLockAndSpinCount(&_handle, 2000);
#endif // ASMJIT_WINDOWS
#if defined(ASMJIT_POSIX)
    pthread_mutex_init(&_handle, NULL);
#endif // ASMJIT_POSIX
  }

  //! @brief Destroy the @ref Lock instance.
  inline ~Lock() ASMJIT_NOTHROW
  {
#if defined(ASMJIT_WINDOWS)
    DeleteCriticalSection(&_handle);
#endif // ASMJIT_WINDOWS
#if defined(ASMJIT_POSIX)
    pthread_mutex_destroy(&_handle);
#endif // ASMJIT_POSIX
  }

  //! @brief Get handle.
  inline Handle& getHandle() ASMJIT_NOTHROW
  {
    return _handle;
  }

  //! @overload
  inline const Handle& getHandle() const ASMJIT_NOTHROW
  {
    return _handle;
  }

  //! @brief Lock.
  inline void lock() ASMJIT_NOTHROW
  {
#if defined(ASMJIT_WINDOWS)
    EnterCriticalSection(&_handle);
#endif // ASMJIT_WINDOWS
#if defined(ASMJIT_POSIX)
    pthread_mutex_lock(&_handle);
#endif // ASMJIT_POSIX
  }

  //! @brief Unlock.
  inline void unlock() ASMJIT_NOTHROW
  {
#if defined(ASMJIT_WINDOWS)
    LeaveCriticalSection(&_handle);
#endif // ASMJIT_WINDOWS
#if defined(ASMJIT_POSIX)
    pthread_mutex_unlock(&_handle);
#endif // ASMJIT_POSIX
  }

private:
  //! @brief Handle.
  Handle _handle;

  // Disable copy.
  ASMJIT_DISABLE_COPY(Lock)
};

// ============================================================================
// [AsmJit::AutoLock]
// ============================================================================

//! @brief Scope auto locker.
struct ASMJIT_HIDDEN AutoLock
{
  //! @brief Locks @a target.
  inline AutoLock(Lock& target) ASMJIT_NOTHROW : _target(target)
  {
    _target.lock();
  }

  //! @brief Unlocks target.
  inline ~AutoLock() ASMJIT_NOTHROW
  {
    _target.unlock();
  }

private:
  //! @brief Pointer to target (lock).
  Lock& _target;

  // Disable copy.
  ASMJIT_DISABLE_COPY(AutoLock)
};

// ============================================================================
// [AsmJit::VirtualMemory]
// ============================================================================

//! @brief Class that helps with allocating memory for executing code
//! generated by JIT compiler.
//!
//! There are defined functions that provides facility to allocate and free
//! memory where can be executed code. If processor and operating system
//! supports execution protection then you can't run code from normally
//! malloc()'ed memory.
//!
//! Functions are internally implemented by operating system dependent way.
//! VirtualAlloc() function is used for Windows operating system and mmap()
//! for posix ones. If you want to study or create your own functions, look
//! at VirtualAlloc() or mmap() documentation (depends on you target OS).
//!
//! Under posix operating systems is also useable mprotect() function, that
//! can enable execution protection to malloc()'ed memory block.
struct ASMJIT_API VirtualMemory
{
  //! @brief Allocate virtual memory.
  //!
  //! Pages are readable/writeable, but they are not guaranteed to be
  //! executable unless 'canExecute' is true. Returns the address of
  //! allocated memory, or NULL if failed.
  static void* alloc(sysuint_t length, sysuint_t* allocated, bool canExecute) ASMJIT_NOTHROW;

  //! @brief Free memory allocated by @c alloc()
  static void free(void* addr, sysuint_t length) ASMJIT_NOTHROW;

#if defined(ASMJIT_WINDOWS)
  //! @brief Allocate virtual memory of @a hProcess.
  //!
  //! @note This function is windows specific and unportable.
  static void* allocProcessMemory(HANDLE hProcess, sysuint_t length, sysuint_t* allocated, bool canExecute) ASMJIT_NOTHROW;

  //! @brief Free virtual memory of @a hProcess.
  //!
  //! @note This function is windows specific and unportable.
  static void freeProcessMemory(HANDLE hProcess, void* addr, sysuint_t length) ASMJIT_NOTHROW;
#endif // ASMJIT_WINDOWS

  //! @brief Get the alignment guaranteed by alloc().
  static sysuint_t getAlignment() ASMJIT_NOTHROW;

  //! @brief Get size of single page.
  static sysuint_t getPageSize() ASMJIT_NOTHROW;
};

//! @}

} // AsmJit namespace


#include "ApiEnd.h"    // [Api-End]

#endif // _ASMJIT_PLATFORM_H

```

`AsmJit/Util.cpp`:

```cpp

#include "Build.h"
#include "Util_p.h"

#include "ApiBegin.h"  // [Api-Begin]

namespace AsmJit {

// ============================================================================
// [AsmJit::Util]
// ============================================================================

static const char letters[] = "0123456789ABCDEF";

char* Util::mycpy(char* dst, const char* src, sysuint_t len) ASMJIT_NOTHROW
{
  if (src == NULL) return dst;

  if (len == (sysuint_t)-1)
  {
    while (*src) *dst++ = *src++;
  }
  else
  {
    memcpy(dst, src, len);
    dst += len;
  }

  return dst;
}

char* Util::myfill(char* dst, const int c, sysuint_t len) ASMJIT_NOTHROW
{
  memset(dst, c, len);
  return dst + len;
}

char* Util::myhex(char* dst, const uint8_t* src, sysuint_t len) ASMJIT_NOTHROW
{
  for (sysuint_t i = len; i; i--, dst += 2, src += 1)
  {
    dst[0] = letters[(src[0] >> 4) & 0xF];
    dst[1] = letters[(src[0]     ) & 0xF];
  }

  return dst;
}

// Not too efficient, but this is mainly for debugging:)
char* Util::myutoa(char* dst, sysuint_t i, sysuint_t base) ASMJIT_NOTHROW
{
  ASMJIT_ASSERT(base <= 16);

  char buf[128];
  char* p = buf + 128;

  do {
    sysint_t b = i % base;
    *--p = letters[b];
    i /= base;
  } while (i);

  return Util::mycpy(dst, p, (sysuint_t)(buf + 128 - p));
}

char* Util::myitoa(char* dst, sysint_t i, sysuint_t base) ASMJIT_NOTHROW
{
  if (i < 0)
  {
    *dst++ = '-';
    i = -i;
  }

  return Util::myutoa(dst, (sysuint_t)i, base);
}

// ============================================================================
// [AsmJit::Buffer]
// ============================================================================

void Buffer::emitData(const void* dataPtr, sysuint_t dataLen) ASMJIT_NOTHROW
{
  sysint_t max = getCapacity() - getOffset();
  if ((sysuint_t)max < dataLen)
  {
    if (!realloc(getOffset() + dataLen)) return;
  }

  memcpy(_cur, dataPtr, dataLen);
  _cur += dataLen;
}

bool Buffer::realloc(sysint_t to) ASMJIT_NOTHROW
{
  if (getCapacity() < to)
  {
    sysint_t len = getOffset();

    uint8_t *newdata;
    if (_data)
      newdata = (uint8_t*)ASMJIT_REALLOC(_data, to);
    else
      newdata = (uint8_t*)ASMJIT_MALLOC(to);
    if (!newdata) return false;

    _data = newdata;
    _cur = newdata + len;
    _max = newdata + to;
    _max -= (to >= _growThreshold) ? _growThreshold : to;

    _capacity = to;
  }

  return true;
}

bool Buffer::grow() ASMJIT_NOTHROW
{
  sysint_t to = _capacity;

  if (to < 512)
    to = 1024;
  else if (to > 65536)
    to += 65536;
  else
    to <<= 1;

  return realloc(to);
}

void Buffer::clear() ASMJIT_NOTHROW
{
  _cur = _data;
}

void Buffer::free() ASMJIT_NOTHROW
{
  if (!_data) return;
  ASMJIT_FREE(_data);

  _data = NULL;
  _cur = NULL;
  _max = NULL;
  _capacity = 0;
}

uint8_t* Buffer::take() ASMJIT_NOTHROW
{
  uint8_t* data = _data;

  _data = NULL;
  _cur = NULL;
  _max = NULL;
  _capacity = 0;

  return data;
}

// ============================================================================
// [AsmJit::Zone]
// ============================================================================

Zone::Zone(sysuint_t chunkSize) ASMJIT_NOTHROW
{
  _chunks = NULL;
  _total = 0;
  _chunkSize = chunkSize;
}

Zone::~Zone() ASMJIT_NOTHROW
{
  freeAll();
}

void* Zone::zalloc(sysuint_t size) ASMJIT_NOTHROW
{
  // Align to 4 or 8 bytes.
  size = (size + sizeof(sysint_t)-1) & ~(sizeof(sysint_t)-1);

  Chunk* cur = _chunks;

  if (!cur || cur->getRemainingBytes() < size)
  {
    sysuint_t chSize = _chunkSize;
    if (chSize < size) chSize = size;

    cur = (Chunk*)ASMJIT_MALLOC(sizeof(Chunk) - sizeof(void*) + chSize);
    if (!cur) return NULL;

    cur->prev = _chunks;
    cur->pos = 0;
    cur->size = _chunkSize;
    _chunks = cur;
  }

  uint8_t* p = cur->data + cur->pos;
  cur->pos += size;
  _total += size;
  return (void*)p;
}

char* Zone::zstrdup(const char* str) ASMJIT_NOTHROW
{
  if (str == NULL) return NULL;

  sysuint_t len = (sysuint_t)strlen(str);
  if (len == 0) return NULL;

  // Include NULL terminator.
  len++;

  // Limit string length.
  if (len > 256) len = 256;

  char* m = reinterpret_cast<char*>(zalloc((len + 15) & ~15));
  if (!m) return NULL;

  memcpy(m, str, len);
  m[len-1] = '\0';
  return m;
}

void Zone::clear() ASMJIT_NOTHROW
{
  Chunk* cur = _chunks;
  if (!cur) return;

  _chunks->pos = 0;
  _chunks->prev = NULL;
  _total = 0;

  cur = cur->prev;
  while (cur)
  {
    Chunk* prev = cur->prev;
    ASMJIT_FREE(cur);
    cur = prev;
  }
}

void Zone::freeAll() ASMJIT_NOTHROW
{
  Chunk* cur = _chunks;

  _chunks = NULL;
  _total = 0;

  while (cur)
  {
    Chunk* prev = cur->prev;
    ASMJIT_FREE(cur);
    cur = prev;
  }
}

} // AsmJit namespace

// [Api-End]
#include "ApiEnd.h"

```

`AsmJit/Util.h`:

```h

#ifndef _ASMJIT_UTIL_H
#define _ASMJIT_UTIL_H

#include "Build.h"

#include <stdlib.h>
#include <string.h>

namespace AsmJit {

//! @addtogroup AsmJit_Util
//! @{

// ============================================================================
// [AsmJit::Macros]
// ============================================================================

// Skip documenting this.
#if !defined(ASMJIT_NODOC)
struct ASMJIT_HIDDEN _DontInitialize {};
struct ASMJIT_HIDDEN _Initialize {};
#endif // !ASMJIT_NODOC

// ============================================================================
// [AsmJit::Util]
// ============================================================================

namespace Util {

// ============================================================================
// [AsmJit::Util::isInt?]
// ============================================================================

//! @brief Returns @c true if a given integer @a x is signed 8-bit integer
static inline bool isInt8(sysint_t x) ASMJIT_NOTHROW { return x >= -128 && x <= 127; }
//! @brief Returns @c true if a given integer @a x is unsigned 8-bit integer
static inline bool isUInt8(sysint_t x) ASMJIT_NOTHROW { return x >= 0 && x <= 255; }

//! @brief Returns @c true if a given integer @a x is signed 16-bit integer
static inline bool isInt16(sysint_t x) ASMJIT_NOTHROW { return x >= -32768 && x <= 32767; }
//! @brief Returns @c true if a given integer @a x is unsigned 16-bit integer
static inline bool isUInt16(sysint_t x) ASMJIT_NOTHROW { return x >= 0 && x <= 65535; }

//! @brief Returns @c true if a given integer @a x is signed 16-bit integer
static inline bool isInt32(sysint_t x) ASMJIT_NOTHROW
{
#if defined(ASMJIT_X86)
  return true;
#else
  return x >= ASMJIT_INT64_C(-2147483648) && x <= ASMJIT_INT64_C(2147483647);
#endif
}
//! @brief Returns @c true if a given integer @a x is unsigned 16-bit integer
static inline bool isUInt32(sysint_t x) ASMJIT_NOTHROW
{
#if defined(ASMJIT_X86)
  return x >= 0;
#else
  return x >= 0 && x <= ASMJIT_INT64_C(4294967295);
#endif
}

// ============================================================================
// [Bit Utils]
// ============================================================================

static inline uint32_t maskFromIndex(uint32_t x)
{
  return (1U << x);
}

static inline uint32_t maskUpToIndex(uint32_t x)
{
  if (x >= 32)
    return 0xFFFFFFFF;
  else
    return (1U << x) - 1;
}

// From http://graphics.stanford.edu/~seander/bithacks.html .
static inline uint32_t bitCount(uint32_t x)
{
  x = x - ((x >> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  return ((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
}

static inline uint32_t findFirstBit(uint32_t mask) ASMJIT_NOTHROW
{
  for (uint32_t i = 0, bit = 1; i < sizeof(uint32_t) * 8; i++, bit <<= 1)
  {
    if (mask & bit) return i;
  }

  // INVALID_VALUE.
  return 0xFFFFFFFF;
}

// ============================================================================
// [Alignment]
// ============================================================================

// Align variable @a x to 16-bytes.
template<typename T>
static inline T alignTo16(const T& x)
{
  return (x + (T)15) & (T)~15;
}

// Return the size needed to align variable @a x to 16-bytes.
template<typename T>
static inline T deltaTo16(const T& x)
{
  T aligned = alignTo16(x);
  return aligned - x;
}

} // Util namespace

// ============================================================================
// [AsmJit::function_cast<>]
// ============================================================================

//! @brief Cast used to cast pointer to function. It's like reinterpret_cast<>, 
//! but uses internally C style cast to work with MinGW.
//!
//! If you are using single compiler and @c reinterpret_cast<> works for you,
//! there is no reason to use @c AsmJit::function_cast<>. If you are writing
//! cross-platform software with various compiler support, consider using
//! @c AsmJit::function_cast<> instead of @c reinterpret_cast<>.
template<typename T, typename Z>
static inline T function_cast(Z* p) ASMJIT_NOTHROW { return (T)p; }

// ============================================================================
// [AsmJit::(X)MMData]
// ============================================================================

//! @brief Structure used for MMX specific data (64-bit).
//!
//! This structure can be used to load / store data from / to MMX register.
union ASMJIT_HIDDEN MMData
{
  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Set all eight signed 8-bit integers.
  inline void setSB(
    int8_t x0, int8_t x1, int8_t x2, int8_t x3, int8_t x4, int8_t x5, int8_t x6, int8_t x7) ASMJIT_NOTHROW
  {
    sb[0] = x0; sb[1] = x1; sb[2] = x2; sb[3] = x3; sb[4] = x4; sb[5] = x5; sb[6] = x6; sb[7] = x7;
  }

  //! @brief Set all eight unsigned 8-bit integers.
  inline void setUB(
    uint8_t x0, uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4, uint8_t x5, uint8_t x6, uint8_t x7) ASMJIT_NOTHROW
  {
    ub[0] = x0; ub[1] = x1; ub[2] = x2; ub[3] = x3; ub[4] = x4; ub[5] = x5; ub[6] = x6; ub[7] = x7;
  }

  //! @brief Set all four signed 16-bit integers.
  inline void setSW(
    int16_t x0, int16_t x1, int16_t x2, int16_t x3) ASMJIT_NOTHROW
  {
    sw[0] = x0; sw[1] = x1; sw[2] = x2; sw[3] = x3;
  }

  //! @brief Set all four unsigned 16-bit integers.
  inline void setUW(
    uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3) ASMJIT_NOTHROW
  {
    uw[0] = x0; uw[1] = x1; uw[2] = x2; uw[3] = x3;
  }

  //! @brief Set all two signed 32-bit integers.
  inline void setSD(
    int32_t x0, int32_t x1) ASMJIT_NOTHROW
  {
    sd[0] = x0; sd[1] = x1;
  }

  //! @brief Set all two unsigned 32-bit integers.
  inline void setUD(
    uint32_t x0, uint32_t x1) ASMJIT_NOTHROW
  {
    ud[0] = x0; ud[1] = x1;
  }

  //! @brief Set signed 64-bit integer.
  inline void setSQ(
    int64_t x0) ASMJIT_NOTHROW
  {
    sq[0] = x0;
  }

  //! @brief Set unsigned 64-bit integer.
  inline void setUQ(
    uint64_t x0) ASMJIT_NOTHROW
  {
    uq[0] = x0;
  }

  //! @brief Set all two SP-FP values.
  inline void setSF(
    float x0, float x1) ASMJIT_NOTHROW
  {
    sf[0] = x0; sf[1] = x1;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Array of eight signed 8-bit integers.
  int8_t sb[8];
  //! @brief Array of eight unsigned 8-bit integers.
  uint8_t ub[8];
  //! @brief Array of four signed 16-bit integers.
  int16_t sw[4];
  //! @brief Array of four unsigned 16-bit integers.
  uint16_t uw[4];
  //! @brief Array of two signed 32-bit integers.
  int32_t sd[2];
  //! @brief Array of two unsigned 32-bit integers.
  uint32_t ud[2];
  //! @brief Array of one signed 64-bit integer.
  int64_t sq[1];
  //! @brief Array of one unsigned 64-bit integer.
  uint64_t uq[1];

  //! @brief Array of two SP-FP values.
  float sf[2];
};

//! @brief Structure used for SSE specific data (128-bit).
//!
//! This structure can be used to load / store data from / to SSE register.
//!
//! @note Always align SSE data to 16-bytes.
union ASMJIT_HIDDEN XMMData
{
  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Set all sixteen signed 8-bit integers.
  inline void setSB(
    int8_t x0, int8_t x1, int8_t x2 , int8_t x3 , int8_t x4 , int8_t x5 , int8_t x6 , int8_t x7 ,
    int8_t x8, int8_t x9, int8_t x10, int8_t x11, int8_t x12, int8_t x13, int8_t x14, int8_t x15) ASMJIT_NOTHROW
  {
    sb[0] = x0; sb[1] = x1; sb[ 2] = x2 ; sb[3 ] = x3 ; sb[4 ] = x4 ; sb[5 ] = x5 ; sb[6 ] = x6 ; sb[7 ] = x7 ;
    sb[8] = x8; sb[9] = x9; sb[10] = x10; sb[11] = x11; sb[12] = x12; sb[13] = x13; sb[14] = x14; sb[15] = x15; 
  }

  //! @brief Set all sixteen unsigned 8-bit integers.
  inline void setUB(
    uint8_t x0, uint8_t x1, uint8_t x2 , uint8_t x3 , uint8_t x4 , uint8_t x5 , uint8_t x6 , uint8_t x7 ,
    uint8_t x8, uint8_t x9, uint8_t x10, uint8_t x11, uint8_t x12, uint8_t x13, uint8_t x14, uint8_t x15) ASMJIT_NOTHROW
  {
    ub[0] = x0; ub[1] = x1; ub[ 2] = x2 ; ub[3 ] = x3 ; ub[4 ] = x4 ; ub[5 ] = x5 ; ub[6 ] = x6 ; ub[7 ] = x7 ;
    ub[8] = x8; ub[9] = x9; ub[10] = x10; ub[11] = x11; ub[12] = x12; ub[13] = x13; ub[14] = x14; ub[15] = x15; 
  }

  //! @brief Set all eight signed 16-bit integers.
  inline void setSW(
    int16_t x0, int16_t x1, int16_t x2, int16_t x3, int16_t x4, int16_t x5, int16_t x6, int16_t x7) ASMJIT_NOTHROW
  {
    sw[0] = x0; sw[1] = x1; sw[2] = x2; sw[3] = x3; sw[4] = x4; sw[5] = x5; sw[6] = x6; sw[7] = x7;
  }

  //! @brief Set all eight unsigned 16-bit integers.
  inline void setUW(
    uint16_t x0, uint16_t x1, uint16_t x2, uint16_t x3, uint16_t x4, uint16_t x5, uint16_t x6, uint16_t x7) ASMJIT_NOTHROW
  {
    uw[0] = x0; uw[1] = x1; uw[2] = x2; uw[3] = x3; uw[4] = x4; uw[5] = x5; uw[6] = x6; uw[7] = x7;
  }

  //! @brief Set all four signed 32-bit integers.
  inline void setSD(
    int32_t x0, int32_t x1, int32_t x2, int32_t x3) ASMJIT_NOTHROW
  {
    sd[0] = x0; sd[1] = x1; sd[2] = x2; sd[3] = x3;
  }

  //! @brief Set all four unsigned 32-bit integers.
  inline void setUD(
    uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3) ASMJIT_NOTHROW
  {
    ud[0] = x0; ud[1] = x1; ud[2] = x2; ud[3] = x3;
  }

  //! @brief Set all two signed 64-bit integers.
  inline void setSQ(
    int64_t x0, int64_t x1) ASMJIT_NOTHROW
  {
    sq[0] = x0; sq[1] = x1;
  }

  //! @brief Set all two unsigned 64-bit integers.
  inline void setUQ(
    uint64_t x0, uint64_t x1) ASMJIT_NOTHROW
  {
    uq[0] = x0; uq[1] = x1;
  }

  //! @brief Set all four SP-FP floats.
  inline void setSF(
    float x0, float x1, float x2, float x3) ASMJIT_NOTHROW
  {
    sf[0] = x0; sf[1] = x1; sf[2] = x2; sf[3] = x3;
  }

  //! @brief Set all two DP-FP floats.
  inline void setDF(
    double x0, double x1) ASMJIT_NOTHROW
  {
    df[0] = x0; df[1] = x1;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Array of sixteen signed 8-bit integers.
  int8_t sb[16];
  //! @brief Array of sixteen unsigned 8-bit integers.
  uint8_t ub[16];
  //! @brief Array of eight signed 16-bit integers.
  int16_t sw[8];
  //! @brief Array of eight unsigned 16-bit integers.
  uint16_t uw[8];
  //! @brief Array of four signed 32-bit integers.
  int32_t sd[4];
  //! @brief Array of four unsigned 32-bit integers.
  uint32_t ud[4];
  //! @brief Array of two signed 64-bit integers.
  int64_t sq[2];
  //! @brief Array of two unsigned 64-bit integers.
  uint64_t uq[2];

  //! @brief Array of four 32-bit single precision floating points.
  float sf[4];
  //! @brief Array of two 64-bit double precision floating points.
  double df[2];
};

// ============================================================================
// [AsmJit::Buffer]
// ============================================================================

//! @brief Buffer used to store instruction stream in AsmJit.
//! 
//! This class can be dangerous, if you don't know how it works. Assembler
//! instruction stream is usually constructed by multiple calls of emit
//! functions that emits bytes, words, dwords or qwords. But to decrease
//! AsmJit library size and improve performance, we are not checking for
//! buffer overflow for each emit operation, but only once in highler level
//! emit instruction.
//!
//! So, if you want to use this class, you need to do buffer checking yourself
//! by using @c ensureSpace() method. It's designed to grow buffer if needed.
//! Threshold for growing is named @c growThreshold() and it means count of
//! bytes for emitting single operation. Default size is set to 16 bytes,
//! because x86 and x64 instruction can't be larger (so it's space to hold 1
//! instruction).
//!
//! Example using Buffer:
//!
//! @code
//! // Buffer instance, growThreshold == 16
//! // (no memory allocated in constructor).
//! AsmJit::Buffer buf(16);
//!
//! // Begin of emit stream, ensure space can fail on out of memory error.
//! if (buf.ensureSpace()) 
//! {
//!   // here, you can emit up to 16 (growThreshold) bytes
//!   buf.emitByte(0x00);
//!   buf.emitByte(0x01);
//!   buf.emitByte(0x02);
//!   buf.emitByte(0x03);
//!   ...
//! }
//! @endcode
struct ASMJIT_API Buffer
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  inline Buffer(sysint_t growThreshold = 16) ASMJIT_NOTHROW :
    _data(NULL),
    _cur(NULL),
    _max(NULL),
    _capacity(0),
    _growThreshold(growThreshold)
  {
  }

  inline ~Buffer() ASMJIT_NOTHROW
  {
    if (_data) ASMJIT_FREE(_data);
  }

  //! @brief Get start of buffer.
  inline uint8_t* getData() const ASMJIT_NOTHROW { return _data; }

  //! @brief Get current pointer in code buffer.
  inline uint8_t* getCur() const ASMJIT_NOTHROW { return _cur; }

  //! @brief Get maximum pointer in code buffer for growing.
  inline uint8_t* getMax() const ASMJIT_NOTHROW { return _max; }

  //! @brief Get current offset in buffer.
  inline sysint_t getOffset() const ASMJIT_NOTHROW { return (sysint_t)(_cur - _data); }

  //! @brief Get capacity of buffer.
  inline sysint_t getCapacity() const ASMJIT_NOTHROW { return _capacity; }

  //! @brief Get grow threshold.
  inline sysint_t getGrowThreshold() const ASMJIT_NOTHROW { return _growThreshold; }

  //! @brief Ensure space for next instruction
  inline bool ensureSpace() ASMJIT_NOTHROW { return (_cur >= _max) ? grow() : true; }

  //! @brief Sets offset to @a o and returns previous offset.
  //!
  //! This method can be used to truncate buffer or it's used to
  //! overwrite specific position in buffer by Assembler.
  inline sysint_t toOffset(sysint_t o) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(o < _capacity);

    sysint_t prev = (sysint_t)(_cur - _data);
    _cur = _data + o;
    return prev;
  }

  //! @brief Reallocate buffer.
  //!
  //! It's only used for growing, buffer is never reallocated to smaller 
  //! number than current capacity() is.
  bool realloc(sysint_t to) ASMJIT_NOTHROW;

  //! @brief Used to grow the buffer.
  //!
  //! It will typically realloc to twice size of capacity(), but if capacity()
  //! is large, it will use smaller steps.
  bool grow() ASMJIT_NOTHROW;

  //! @brief Clear everything, but not deallocate buffer.
  void clear() ASMJIT_NOTHROW;

  //! @brief Free buffer and NULL all pointers.
  void free() ASMJIT_NOTHROW;

  //! @brief Take ownership of the buffer data and purge @c Buffer instance.
  uint8_t* take() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Emit]
  // --------------------------------------------------------------------------

  //! @brief Emit Byte.
  inline void emitByte(uint8_t x) ASMJIT_NOTHROW
  {
    *_cur++ = x;
  }

  //! @brief Emit Word (2 bytes).
  inline void emitWord(uint16_t x) ASMJIT_NOTHROW
  {
    *(uint16_t *)_cur = x;
    _cur += 2;
  }

  //! @brief Emit DWord (4 bytes).
  inline void emitDWord(uint32_t x) ASMJIT_NOTHROW
  {
    *(uint32_t *)_cur = x;
    _cur += 4;
  }

  //! @brief Emit QWord (8 bytes).
  inline void emitQWord(uint64_t x) ASMJIT_NOTHROW
  {
    *(uint64_t *)_cur = x;
    _cur += 8;
  }

  //! @brief Emit system signed integer (4 or 8 bytes).
  inline void emitSysInt(sysint_t x) ASMJIT_NOTHROW
  {
    *(sysint_t *)_cur = x;
    _cur += sizeof(sysint_t);
  }

  //! @brief Emit system unsigned integer (4 or 8 bytes).
  inline void emitSysUInt(sysuint_t x) ASMJIT_NOTHROW
  {
    *(sysuint_t *)_cur = x;
    _cur += sizeof(sysuint_t);
  }

  //! @brief Emit custom data. 
  void emitData(const void* ptr, sysuint_t len) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Get / Set]
  // --------------------------------------------------------------------------

  //! @brief Set byte at position @a pos.
  inline uint8_t getByteAt(sysint_t pos) const ASMJIT_NOTHROW
  {
    return *reinterpret_cast<const uint8_t*>(_data + pos);
  }

  //! @brief Set word at position @a pos.
  inline uint16_t getWordAt(sysint_t pos) const ASMJIT_NOTHROW
  {
    return *reinterpret_cast<const uint16_t*>(_data + pos);
  }

  //! @brief Set word at position @a pos.
  inline uint32_t getDWordAt(sysint_t pos) const ASMJIT_NOTHROW
  {
    return *reinterpret_cast<const uint32_t*>(_data + pos);
  }

  //! @brief Set word at position @a pos.
  inline uint64_t getQWordAt(sysint_t pos) const ASMJIT_NOTHROW
  {
    return *reinterpret_cast<const uint64_t*>(_data + pos);
  }

  //! @brief Set byte at position @a pos.
  inline void setByteAt(sysint_t pos, uint8_t x) ASMJIT_NOTHROW
  {
    *reinterpret_cast<uint8_t*>(_data + pos) = x;
  }

  //! @brief Set word at position @a pos.
  inline void setWordAt(sysint_t pos, uint16_t x) ASMJIT_NOTHROW
  {
    *reinterpret_cast<uint16_t*>(_data + pos) = x;
  }

  //! @brief Set word at position @a pos.
  inline void setDWordAt(sysint_t pos, uint32_t x) ASMJIT_NOTHROW
  {
    *reinterpret_cast<uint32_t*>(_data + pos) = x;
  }

  //! @brief Set word at position @a pos.
  inline void setQWordAt(sysint_t pos, uint64_t x) ASMJIT_NOTHROW
  {
    *reinterpret_cast<uint64_t*>(_data + pos) = x;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  // All members are public, because they can be accessed and modified by 
  // Assembler/Compiler directly.

  //! @brief Beginning position of buffer.
  uint8_t* _data;
  //! @brief Current position in buffer.
  uint8_t* _cur;
  //! @brief Maximum position in buffer for realloc.
  uint8_t* _max;

  //! @brief Buffer capacity (in bytes).
  sysint_t _capacity;

  //! @brief Grow threshold
  sysint_t _growThreshold;
};

// ============================================================================
// [AsmJit::PodVector<>]
// ============================================================================

//! @brief Template used to store and manage array of POD data.
//!
//! This template has these adventages over other vector<> templates:
//! - Non-copyable (designed to be non-copyable, we want it)
//! - No copy-on-write (some implementations of stl can use it)
//! - Optimized for working only with POD types
//! - Uses ASMJIT_... memory management macros
template <typename T>
struct PodVector
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new instance of PodVector template. Data will not
  //! be allocated (will be NULL).
  inline PodVector() ASMJIT_NOTHROW : _data(NULL), _length(0), _capacity(0)
  {
  }
  
  //! @brief Destroy PodVector and free all data.
  inline ~PodVector() ASMJIT_NOTHROW
  {
    if (_data) ASMJIT_FREE(_data);
  }

  // --------------------------------------------------------------------------
  // [Data]
  // --------------------------------------------------------------------------

  //! @brief Get vector data.
  inline T* getData() ASMJIT_NOTHROW { return _data; }
  //! @overload
  inline const T* getData() const ASMJIT_NOTHROW { return _data; }
  //! @brief Get vector length.
  inline sysuint_t getLength() const ASMJIT_NOTHROW { return _length; }
  //! @brief get vector capacity (allocation capacity).
  inline sysuint_t getCapacity() const ASMJIT_NOTHROW { return _capacity; }

  // --------------------------------------------------------------------------
  // [Manipulation]
  // --------------------------------------------------------------------------

  //! @brief Clear vector data, but not free internal buffer.
  void clear() ASMJIT_NOTHROW
  {
    _length = 0;
  }

  //! @brief Clear vector data and free internal buffer.
  void free() ASMJIT_NOTHROW
  {
    if (_data) 
    {
      ASMJIT_FREE(_data);
      _data = 0;
      _length = 0;
      _capacity = 0;
    }
  }

  //! @brief Prepend @a item to vector.
  bool prepend(const T& item) ASMJIT_NOTHROW
  {
    if (_length == _capacity && !_grow()) return false;

    memmove(_data + 1, _data, sizeof(T) * _length);
    memcpy(_data, &item, sizeof(T));

    _length++;
    return true;
  }

  //! @brief Insert an @a item at the @a index.
  bool insert(sysuint_t index, const T& item) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(index <= _length);
    if (_length == _capacity && !_grow()) return false;

    T* dst = _data + index;
    memmove(dst + 1, dst, _length - index);
    memcpy(dst, &item, sizeof(T));

    _length++;
    return true;
  }

  //! @brief Append @a item to vector.
  bool append(const T& item) ASMJIT_NOTHROW
  {
    if (_length == _capacity && !_grow())
        return false;

    memcpy(_data + _length, &item, sizeof(T));
    _length++;

    return true;
  }

  //! @brief Get index of @a val or (sysuint_t)-1 if not found.
  sysuint_t indexOf(const T& val) const ASMJIT_NOTHROW
  {
    sysuint_t i = 0, len = _length;
    for (i = 0; i < len; i++) { if (_data[i] == val) return i; }
    return (sysuint_t)-1;
  }

  //! @brief Remove element at index @a i.
  void removeAt(sysuint_t i) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(i < _length);

    T* dst = _data + i;
    _length--;
    memmove(dst, dst + 1, _length - i);
  }

  //! @brief Swap this pod-vector with @a other.
  void swap(PodVector<T>& other) ASMJIT_NOTHROW
  {
    T* _tmp_data = _data;
    sysuint_t _tmp_length = _length;
    sysuint_t _tmp_capacity = _capacity;

    _data = other._data;
    _length = other._length;
    _capacity = other._capacity;

    other._data = _tmp_data;
    other._length = _tmp_length;
    other._capacity = _tmp_capacity;
  }

  //! @brief Get item at position @a i.
  inline T& operator[](sysuint_t i) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(i < _length);
    return _data[i];
  }
  //! @brief Get item at position @a i.
  inline const T& operator[](sysuint_t i) const ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(i < _length);
    return _data[i];
  }

  //! @brief Append the item and return address so it can be initialized.
  T* newItem() ASMJIT_NOTHROW
  {
    if (_length == _capacity && !_grow()) return NULL;
    return _data + (_length++);
  }

  // --------------------------------------------------------------------------
  // [Private]
  // --------------------------------------------------------------------------

private:
  //! @brief Called to grow internal array.
  bool _grow() ASMJIT_NOTHROW
  {
    return _realloc(_capacity < 16 ? 16 : _capacity * 2);
  }

  //! @brief Realloc internal array to fit @a to items.
  bool _realloc(sysuint_t to) ASMJIT_NOTHROW
  {
    ASMJIT_ASSERT(to >= _length);

    T* p = reinterpret_cast<T*>(_data 
      ? ASMJIT_REALLOC(_data, to * sizeof(T)) 
      : ASMJIT_MALLOC(to * sizeof(T)));
    if (!p) return false;

    _data = p;
    _capacity = to;
    return true;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! @brief Items data.
  T* _data;
  //! @brief Length of buffer (count of items in array).
  sysuint_t _length;
  //! @brief Capacity of buffer (maximum items that can fit to current array).
  sysuint_t _capacity;

private:
  ASMJIT_DISABLE_COPY(PodVector<T>)
};

// ============================================================================
// [AsmJit::Zone]
// ============================================================================

//! @brief Memory allocator designed to fast alloc memory that will be freed
//! in one step.
//!
//! @note This is hackery for performance. Concept is that objects created
//! by @c Zone are freed all at once. This means that lifetime of 
//! these objects are same as zone object itselt.
//!
//! All emittables, variables, labels and states allocated by @c Compiler are
//! allocated through @c Zone object.
struct ASMJIT_API Zone
{
  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! @brief Create new instance of @c Zone.
  //! @param chunkSize Default size for one zone chunk.
  Zone(sysuint_t chunkSize) ASMJIT_NOTHROW;

  //! @brief Destroy zone instance.
  ~Zone() ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Methods]
  // --------------------------------------------------------------------------

  //! @brief Allocate @c size bytes of memory and return pointer to it.
  //!
  //! Pointer allocated by this way will be valid until @c Zone object is
  //! destroyed. To create class by this way use placement @c new and 
  //! @c delete operators:
  //!
  //! @code
  //! // Example of allocating simple class
  //!
  //! // Your class
  //! class Object
  //! {
  //!   // members...
  //! };
  //!
  //! // Your function
  //! void f()
  //! {
  //!   // We are using AsmJit namespace
  //!   using namespace AsmJit
  //!
  //!   // Create zone object with chunk size of 65536 bytes.
  //!   Zone zone(65536);
  //!
  //!   // Create your objects using zone object allocating, for example:
  //!   Object* obj = new(zone.alloc(sizeof(YourClass))) Object();
  //! 
  //!   // ... lifetime of your objects ...
  //! 
  //!   // Destroy your objects:
  //!   obj->~Object();
  //!
  //!   // Zone destructor will free all memory allocated through it, 
  //!   // alternative is to call @c zone.freeAll().
  //! }
  //! @endcode
  void* zalloc(sysuint_t size) ASMJIT_NOTHROW;

  //! @brief Helper to duplicate string.
  char* zstrdup(const char* str) ASMJIT_NOTHROW;

  //! @brief Free all allocated memory except first block that remains for reuse.
  //!
  //! Note that this method will invalidate all instances using this memory
  //! allocated by this zone instance.
  void clear() ASMJIT_NOTHROW;

  //! @brief Free all allocated memory at once.
  //!
  //! Note that this method will invalidate all instances using this memory
  //! allocated by this zone instance.
  void freeAll() ASMJIT_NOTHROW;

  //! @brief Get total size of allocated objects - by @c alloc().
  inline sysuint_t getTotal() const ASMJIT_NOTHROW { return _total; }
  //! @brief Get (default) chunk size.
  inline sysuint_t getChunkSize() const ASMJIT_NOTHROW { return _chunkSize; }

  // --------------------------------------------------------------------------
  // [Chunk]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief One allocated chunk of memory.
  struct ASMJIT_HIDDEN Chunk
  {
    //! @brief Link to previous chunk.
    Chunk* prev;
    //! @brief Position in this chunk.
    sysuint_t pos;
    //! @brief Size of this chunk (in bytes).
    sysuint_t size;

    //! @brief Data.
    uint8_t data[sizeof(void*)];

    //! @brief Get count of remaining (unused) bytes in chunk.
    inline sysuint_t getRemainingBytes() const ASMJIT_NOTHROW { return size - pos; }
  };

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

private:
  //! @brief Last allocated chunk of memory.
  Chunk* _chunks;
  //! @brief Total size of allocated objects - by @c alloc() method.
  sysuint_t _total;
  //! @brief One chunk size.
  sysuint_t _chunkSize;
};

//! @}

} // AsmJit namespace

#endif // _ASMJIT_UTIL_H

```

`AsmJit/Util_p.h`:

```h

#ifndef _ASMJIT_UTIL_P_H
#define _ASMJIT_UTIL_P_H

// [Dependencies]
#include "Util.h"

#include <stdlib.h>
#include <string.h>

namespace AsmJit {

namespace Util
{
  // --------------------------------------------------------------------------
  // [AsmJit::floatAsInt32, int32AsFloat]
  // --------------------------------------------------------------------------

  //! @internal
  //!
  //! @brief used to cast from float to 32-bit integer and vica versa.
  union I32FPUnion
  {
    //! @brief 32-bit signed integer value.
    int32_t i;
    //! @brief 32-bit SP-FP value.
    float f;
  };

  //! @internal
  //!
  //! @brief used to cast from double to 64-bit integer and vica versa.
  union I64FPUnion
  {
    //! @brief 64-bit signed integer value.
    int64_t i;
    //! @brief 64-bit DP-FP value.
    double f;
  };

  //! @brief Binary cast from 32-bit integer to SP-FP value (@c float).
  static inline float int32AsFloat(int32_t i) ASMJIT_NOTHROW
  {
    I32FPUnion u;
    u.i = i;
    return u.f;
  }

  //! @brief Binary cast SP-FP value (@c float) to 32-bit integer.
  static inline int32_t floatAsInt32(float f) ASMJIT_NOTHROW
  {
    I32FPUnion u;
    u.f = f;
    return u.i;
  }

  //! @brief Binary cast from 64-bit integer to DP-FP value (@c double).
  static inline double int64AsDouble(int64_t i) ASMJIT_NOTHROW
  {
    I64FPUnion u;
    u.i = i;
    return u.f;
  }

  //! @brief Binary cast from DP-FP value (@c double) to 64-bit integer.
  static inline int64_t doubleAsInt64(double f) ASMJIT_NOTHROW
  {
    I64FPUnion u;
    u.f = f;
    return u.i;
  }

  // --------------------------------------------------------------------------
  // [Str Utils]
  // --------------------------------------------------------------------------

  ASMJIT_HIDDEN char* mycpy(char* dst, const char* src, sysuint_t len = (sysuint_t)-1) ASMJIT_NOTHROW;
  ASMJIT_HIDDEN char* myfill(char* dst, const int c, sysuint_t len) ASMJIT_NOTHROW;
  ASMJIT_HIDDEN char* myhex(char* dst, const uint8_t* src, sysuint_t len) ASMJIT_NOTHROW;
  ASMJIT_HIDDEN char* myutoa(char* dst, sysuint_t i, sysuint_t base = 10) ASMJIT_NOTHROW;
  ASMJIT_HIDDEN char* myitoa(char* dst, sysint_t i, sysuint_t base = 10) ASMJIT_NOTHROW;

  // --------------------------------------------------------------------------
  // [Mem Utils]
  // --------------------------------------------------------------------------

  static inline void memset32(uint32_t* p, uint32_t c, sysuint_t len) ASMJIT_NOTHROW
  {
    sysuint_t i;
    for (i = 0; i < len; i++) p[i] = c;
  }
} // Util namespace

} // AsmJit namespace

#endif // _ASMJIT_UTIL_P_H

```

`AsmJit/assembl.h`:

```h
#ifndef  ASSEMBL_H
#define  ASSEMBL_H

#include "AsmJit.h"
#include <iostream>
#include <list>

using namespace AsmJit;

typedef struct asmmodel {
    char code[256];
    char mask[256];
    int length;
} asmmodel;

#define TEXTLEN        256             // Maximal length of text string

typedef struct asmoperand {
	int            type;                 // Operand type, see beginning of file
	int            size;                 // Operand size or 0 if yet unknown
	int            index;                // Index or other register
	int            scale;                // Scale
	int            base;                 // Base register if present
	long           offset;               // Immediate value or offset
	int            anyoffset;            // Offset is present but undefined
	int            segment;              // Segment in address if present
	int            jmpmode;              // Specified jump size
	Label * label;
	int           mode;   //判断是否是什么类型  浮点还是什么  上面的类型是reg 这个是
} asmoperand;


struct label_list {
	char labelname[256];
	Label label;
};

class Assembl
{
public:
    Assembl();
    ~Assembl();
public:
     int Assemble(char *cmd,ulong ip,asmmodel *model,char *error);
	 int Assemble(char *cmd);

	void Parseasmoperand(asmoperand *op);
    Assembler a;
	void Scanasm(int mode);
	const GPReg * get_reg(int reg,int size);
	const Operand get_operand(asmoperand *op);
	void reloc(unsigned long relocaddr);
	unsigned char * get_code();
	int get_code_size();
	char      *asmcmd;              // Pointer to 0-terminated source line
	int       scan;                 // Type of last scanned element
	int       prio;                 // Priority of operation (0: highest)
	char      sdata[TEXTLEN];       // Last scanned name (depends on type)
	long      idata;                // Last scanned value
	long      double fdata;         // Floating-point number
	const char      *asmerror;      // Explanation of last error, or NULL
	Label * now_label;              // 指向label的指针
	std::list <label_list> l_label;
};
#endif

```

`AsmJit/opcode_table.cpp`:

```cpp
#include "opcode_table.h"

const unsigned int instruction_table_count = 575;
const char * instruction_table[575] =
{
  "ADC",           // X86/X64
  "ADD",           // X86/X64
  "ADDPD",         // SSE2
  "ADDPS",         // SSE
  "ADDSD",         // SSE2
  "ADDSS",         // SSE
  "ADDSUBPD",      // SSE3
  "ADDSUBPS",      // SSE3
  "AMD_PREFETCH",
  "AMD_PREFETCHW",
  "AND",           // X86/X64
  "ANDNPD",        // SSE2
  "ANDNPS",        // SSE
  "ANDPD",         // SSE2
  "ANDPS",         // SSE
  "BLENDPD",       // SSE4.1
  "BLENDPS",       // SSE4.1
  "BLENDVPD",      // SSE4.1
  "BLENDVPS",      // SSE4.1
  "BSF",           // X86/X64
  "BSR",           // X86/X64
  "BSWAP",         // X86/X64 (i486)
  "BT",            // X86/X64
  "BTC",           // X86/X64
  "BTR",           // X86/X64
  "BTS",           // X86/X64
  "CALL",          // X86/X64
  "CBW",           // X86/X64
  "CDQE",          // X64 only
  "CLC",           // X86/X64
  "CLD",           // X86/X64
  "CLFLUSH",       // SSE2
  "CMC",           // X86/X64
  "CMOVA",         //X86/X64 (cmovcc) (i586)
  "CMOVAE",        // X86/X64 (cmovcc) (i586)
  "CMOVB",         // X86/X64 (cmovcc) (i586)
  "CMOVBE",        // X86/X64 (cmovcc) (i586)
  "CMOVC",         // X86/X64 (cmovcc) (i586)
  "CMOVE",         // X86/X64 (cmovcc) (i586)
  "CMOVG",         // X86/X64 (cmovcc) (i586)
  "CMOVGE",        // X86/X64 (cmovcc) (i586)
  "CMOVL",         // X86/X64 (cmovcc) (i586)
  "CMOVLE",        // X86/X64 (cmovcc) (i586)
  "CMOVNA",        // X86/X64 (cmovcc) (i586)
  "CMOVNAE",       // X86/X64 (cmovcc) (i586)
  "CMOVNB",        // X86/X64 (cmovcc) (i586)
  "CMOVNBE",       // X86/X64 (cmovcc) (i586)
  "CMOVNC",        // X86/X64 (cmovcc) (i586)
  "CMOVNE",        // X86/X64 (cmovcc) (i586)
  "CMOVNG",        // X86/X64 (cmovcc) (i586)
  "CMOVNGE",       // X86/X64 (cmovcc) (i586)
  "CMOVNL",        // X86/X64 (cmovcc) (i586)
  "CMOVNLE",       // X86/X64 (cmovcc) (i586)
  "CMOVNO",        // X86/X64 (cmovcc) (i586)
  "CMOVNP",        // X86/X64 (cmovcc) (i586)
  "CMOVNS",        // X86/X64 (cmovcc) (i586)
  "CMOVNZ",        // X86/X64 (cmovcc) (i586)
  "CMOVO",         // X86/X64 (cmovcc) (i586)
  "CMOVP",         // X86/X64 (cmovcc) (i586)
  "CMOVPE",        // X86/X64 (cmovcc) (i586)
  "CMOVPO",        // X86/X64 (cmovcc) (i586)
  "CMOVS",         // X86/X64 (cmovcc) (i586)
  "CMOVZ",         // X86/X64 (cmovcc) (i586)

  "CMP",           // X86/X64
  "CMPPD",         // SSE2
  "CMPPS",         // SSE
  "CMPSD",         // SSE2
  "CMPSS",         // SSE
  "CMPXCHG",       // X86/X64 (i486)
  "CMPXCHG16B",    // X64 only
  "CMPXCHG8B",     // X86/X64 (i586)
  "COMISD",        // SSE2
  "COMISS",        // SSE
  "CPUID",         // X86/X64 (i486)
  "CRC32",         // SSE4.2
  "CVTDQ2PD",      // SSE2
  "CVTDQ2PS",      // SSE2
  "CVTPD2DQ",      // SSE2
  "CVTPD2PI",      // SSE2
  "CVTPD2PS",      // SSE2
  "CVTPI2PD",      // SSE2
  "CVTPI2PS",      // SSE
  "CVTPS2DQ",      // SSE2
  "CVTPS2PD",      // SSE2
  "CVTPS2PI",      // SSE
  "CVTSD2SI",      // SSE2
  "CVTSD2SS",      // SSE2
  "CVTSI2SD",      // SSE2
  "CVTSI2SS",      // SSE
  "CVTSS2SD",      // SSE2
  "CVTSS2SI",      // SSE
  "CVTTPD2DQ",     // SSE2
  "CVTTPD2PI",     // SSE2
  "CVTTPS2DQ",     // SSE2
  "CVTTPS2PI",     // SSE
  "CVTTSD2SI",     // SSE2
  "CVTTSS2SI",     // SSE
  "CWDE",          // X86/X64
  "DAA",           // X86 only
  "DAS",           // X86 only
  "DEC",           // X86/X64
  "DIV",           // X86/X64
  "DIVPD",         // SSE2
  "DIVPS",         // SSE
  "DIVSD",         // SSE2
  "DIVSS",         // SSE
  "DPPD",          // SSE4.1
  "DPPS",          // SSE4.1
  "EMMS",          // MMX
  "ENTER",         // X86/X64
  "EXTRACTPS",     // SSE4.1
  "F2XM1",         // X87
  "FABS",          // X87
  "FADD",          // X87
  "FADDP",         // X87
  "FBLD",          // X87
  "FBSTP",         // X87
  "FCHS",          // X87
  "FCLEX",         // X87
  "FCMOVB",        // X87
  "FCMOVBE",       // X87
  "FCMOVE",        // X87
  "FCMOVNB",       // X87
  "FCMOVNBE",      // X87
  "FCMOVNE",       // X87
  "FCMOVNU",       // X87
  "FCMOVU",        // X87
  "FCOM",          // X87
  "FCOMI",         // X87
  "FCOMIP",        // X87
  "FCOMP",         // X87
  "FCOMPP",        // X87
  "FCOS",          // X87
  "FDECSTP",       // X87
  "FDIV",          // X87
  "FDIVP",         // X87
  "FDIVR",         // X87
  "FDIVRP",        // X87
  "FEMMS",         // 3dNow!
  "FFREE",         // X87
  "FIADD",         // X87
  "FICOM",         // X87
  "FICOMP",        // X87
  "FIDIV",         // X87
  "FIDIVR",        // X87
  "FILD",          // X87
  "FIMUL",         // X87
  "FINCSTP",       // X87
  "FINIT",         // X87
  "FIST",          // X87
  "FISTP",         // X87
  "FISTTP",        // SSE3
  "FISUB",         // X87
  "FISUBR",        // X87
  "FLD",           // X87
  "FLD1",          // X87
  "FLDCW",         // X87
  "FLDENV",        // X87
  "FLDL2E",        // X87
  "FLDL2T",        // X87
  "FLDLG2",        // X87
  "FLDLN2",        // X87
  "FLDPI",         // X87
  "FLDZ",          // X87
  "FMUL",          // X87
  "FMULP",         // X87
  "FNCLEX",        // X87
  "FNINIT",        // X87
  "FNOP",          // X87
  "FNSAVE",        // X87
  "FNSTCW",        // X87
  "FNSTENV",       // X87
  "FNSTSW",        // X87
  "FPATAN",        // X87
  "FPREM",         // X87
  "FPREM1",        // X87
  "FPTAN",         // X87
  "FRNDINT",       // X87
  "FRSTOR",        // X87
  "FSAVE",         // X87
  "FSCALE",        // X87
  "FSIN",          // X87
  "FSINCOS",       // X87
  "FSQRT",         // X87
  "FST",           // X87
  "FSTCW",         // X87
  "FSTENV",        // X87
  "FSTP",          // X87
  "FSTSW",         // X87
  "FSUB",          // X87
  "FSUBP",         // X87
  "FSUBR",         // X87
  "FSUBRP",        // X87
  "FTST",          // X87
  "FUCOM",         // X87
  "FUCOMI",        // X87
  "FUCOMIP",       // X87
  "FUCOMP",        // X87
  "FUCOMPP",       // X87
  "FWAIT",         // X87
  "FXAM",          // X87
  "FXCH",          // X87
  "FXRSTOR",       // X87
  "FXSAVE",        // X87
  "FXTRACT",       // X87
  "FYL2X",         // X87
  "FYL2XP1",       // X87
  "HADDPD",        // SSE3
  "HADDPS",        // SSE3
  "HSUBPD",        // SSE3
  "HSUBPS",        // SSE3
  "IDIV",          // X86/X64
  "IMUL",          // X86/X64
  "INC",           // X86/X64
  "INT3",          // X86/X64
  "JA",             // Begin (jcc)
  "JAE",           // X86/X64 (jcc)
  "JB",            // X86/X64 (jcc)
  "JBE",           // X86/X64 (jcc)
  "JC",            // X86/X64 (jcc)
  "JE",            // X86/X64 (jcc)
  "JG",            // X86/X64 (jcc)
  "JGE",           // X86/X64 (jcc)
  "JL",            // X86/X64 (jcc)
  "JLE",           // X86/X64 (jcc)
  "JNA",           // X86/X64 (jcc)
  "JNAE",          // X86/X64 (jcc)
  "JNB",           // X86/X64 (jcc)
  "JNBE",          // X86/X64 (jcc)
  "JNC",           // X86/X64 (jcc)
  "JNE",           // X86/X64 (jcc)
  "JNG",           // X86/X64 (jcc)
  "JNGE",          // X86/X64 (jcc)
  "JNL",           // X86/X64 (jcc)
  "JNLE",          // X86/X64 (jcc)
  "JNO",           // X86/X64 (jcc)
  "JNP",           // X86/X64 (jcc)
  "JNS",           // X86/X64 (jcc)
  "JNZ",           // X86/X64 (jcc)
  "JO",            // X86/X64 (jcc)
  "JP",            // X86/X64 (jcc)
  "JPE",           // X86/X64 (jcc)
  "JPO",           // X86/X64 (jcc)
  "JS",            // X86/X64 (jcc)
  "JZ",            // X86/X64 (jcc)
  "JMP",           // X86/X64 (jmp)
  "LDDQU",         // SSE3
  "LDMXCSR",       // SSE
  "LAHF",          // X86/X64 (CPUID NEEDED)
  "LEA",           // X86/X64
  "LEAVE",         // X86/X64
  "LFENCE",        // SSE2
  "MASKMOVDQU",    // SSE2
  "MASKMOVQ",      // MMX-Ext
  "MAXPD",         // SSE2
  "MAXPS",         // SSE
  "MAXSD",         // SSE2
  "MAXSS",         // SSE
  "MFENCE",        // SSE2
  "MINPD",         // SSE2
  "MINPS",         // SSE
  "MINSD",         // SSE2
  "MINSS",         // SSE
  "MONITOR",       // SSE3
  "MOV",           // X86/X64
  "MOVAPD",        // SSE2
  "MOVAPS",        // SSE
  "MOVBE",         // SSE3 - Intel-Atom
  "MOVD",          // MMX/SSE2
  "MOVDDUP",       // SSE3
  "MOVDQ2Q",       // SSE2
  "MOVDQA",        // SSE2
  "MOVDQU",        // SSE2
  "MOVHLPS",       // SSE
  "MOVHPD",        // SSE2
  "MOVHPS",        // SSE
  "MOVLHPS",       // SSE
  "MOVLPD",        // SSE2
  "MOVLPS",        // SSE
  "MOVMSKPD",      // SSE2
  "MOVMSKPS",      // SSE2
  "MOVNTDQ",       // SSE2
  "MOVNTDQA",      // SSE4.1
  "MOVNTI",        // SSE2
  "MOVNTPD",       // SSE2
  "MOVNTPS",       // SSE
  "MOVNTQ",        // MMX-Ext
  "MOVQ",          // MMX/SSE/SSE2
  "MOVQ2DQ",       // SSE2
  "MOVSD",         // SSE2
  "MOVSHDUP",      // SSE3
  "MOVSLDUP",      // SSE3
  "MOVSS",         // SSE
  "MOVSX",         // X86/X64
  "MOVSXD",        // X86/X64
  "MOVUPD",        // SSE2
  "MOVUPS",        // SSE
  "MOVZX",         // X86/X64
  "MOV_PTR",       // X86/X64
  "MPSADBW",       // SSE4.1
  "MUL",           // X86/X64
  "MULPD",         // SSE2
  "MULPS",         // SSE
  "MULSD",         // SSE2
  "MULSS",         // SSE
  "MWAIT",         // SSE3
  "NEG",           // X86/X64
  "NOP",           // X86/X64
  "NOT",           // X86/X64
  "OR",            // X86/X64
  "ORPD",          // SSE2
  "ORPS",          // SSE
  "PABSB",         // SSSE3
  "PABSD",         // SSSE3
  "PABSW",         // SSSE3
  "PACKSSDW",      // MMX/SSE2
  "PACKSSWB",      // MMX/SSE2
  "PACKUSDW",      // SSE4.1
  "PACKUSWB",      // MMX/SSE2
  "PADDB",         // MMX/SSE2
  "PADDD",         // MMX/SSE2
  "PADDQ",         // SSE2
  "PADDSB",        // MMX/SSE2
  "PADDSW",        // MMX/SSE2
  "PADDUSB",       // MMX/SSE2
  "PADDUSW",       // MMX/SSE2
  "PADDW",         // MMX/SSE2
  "PALIGNR",       // SSSE3
  "PAND",          // MMX/SSE2
  "PANDN",         // MMX/SSE2
  "PAUSE",         // SSE2.
  "PAVGB",         // MMX-Ext
  "PAVGW",         // MMX-Ext
  "PBLENDVB",      // SSE4.1
  "PBLENDW",       // SSE4.1
  "PCMPEQB",       // MMX/SSE2
  "PCMPEQD",       // MMX/SSE2
  "PCMPEQQ",       // SSE4.1
  "PCMPEQW",       // MMX/SSE2    
  "PCMPESTRI",     // SSE4.2
  "PCMPESTRM",     // SSE4.2
  "PCMPGTB",       // MMX/SSE2
  "PCMPGTD",       // MMX/SSE2
  "PCMPGTQ",       // SSE4.2
  "PCMPGTW",       // MMX/SSE2
  "PCMPISTRI",     // SSE4.2
  "PCMPISTRM",     // SSE4.2
  "PEXTRB",        // SSE4.1
  "PEXTRD",        // SSE4.1        
  "PEXTRQ",        // SSE4.1
  "PEXTRW",        // MMX-Ext/SSE2
  "PF2ID",         // 3dNow!
  "PF2IW",         // Enhanced 3dNow!
  "PFACC",         // 3dNow!
  "PFADD",         // 3dNow!
  "PFCMPEQ",       // 3dNow!
  "PFCMPGE",       // 3dNow!
  "PFCMPGT",       // 3dNow!
  "PFMAX",         // 3dNow!
  "PFMIN",         // 3dNow!
  "PFMUL",         // 3dNow!
  "PFNACC",        // Enhanced 3dNow!
  "PFPNACC",       // Enhanced 3dNow!
  "PFRCP",         // 3dNow!
  "PFRCPIT1",      // 3dNow!
  "PFRCPIT2",      // 3dNow!
  "PFRSQIT1",      // 3dNow!
  "PFRSQRT",       // 3dNow!
  "PFSUB",         // 3dNow!
  "PFSUBR",        // 3dNow!
  "PHADDD",        // SSSE3
  "PHADDSW",       // SSSE3
  "PHADDW",        // SSSE3
  "PHMINPOSUW",    // SSE4.1
  "PHSUBD",        // SSSE3
  "PHSUBSW",       // SSSE3
  "PHSUBW",        // SSSE3
  "PI2FD",         // 3dNow!
  "PI2FW",         // Enhanced 3dNow!
  "PINSRB",        // SSE4.1
  "PINSRD",        // SSE4.1
  "PINSRQ",        // SSE4.1
  "PINSRW",        // MMX-Ext
  "PMADDUBSW",     // SSSE3
  "PMADDWD",       // MMX/SSE2
  "PMAXSB",        // SSE4.1
  "PMAXSD",        // SSE4.1
  "PMAXSW",        // MMX-Ext
  "PMAXUB",        // MMX-Ext
  "PMAXUD",        // SSE4.1
  "PMAXUW",        // SSE4.1
  "PMINSB",        // SSE4.1
  "PMINSD",        // SSE4.1
  "PMINSW",        // MMX-Ext
  "PMINUB",        // MMX-Ext
  "PMINUD",        // SSE4.1
  "PMINUW",        // SSE4.1
  "PMOVMSKB",      // MMX-Ext
  "PMOVSXBD",      // SSE4.1
  "PMOVSXBQ",      // SSE4.1
  "PMOVSXBW",      // SSE4.1
  "PMOVSXDQ",      // SSE4.1
  "PMOVSXWD",      // SSE4.1
  "PMOVSXWQ",      // SSE4.1
  "PMOVZXBD",      // SSE4.1
  "PMOVZXBQ",      // SSE4.1
  "PMOVZXBW",      // SSE4.1
  "PMOVZXDQ",      // SSE4.1
  "PMOVZXWD",      // SSE4.1
  "PMOVZXWQ",      // SSE4.1
  "PMULDQ",        // SSE4.1
  "PMULHRSW",      // SSSE3
  "PMULHUW",       // MMX-Ext
  "PMULHW",        // MMX/SSE2
  "PMULLD",        // SSE4.1
  "PMULLW",        // MMX/SSE2
  "PMULUDQ",       // SSE2
  "POP",           // X86/X64
  "POPAD",         // X86 only
  "POPCNT",        // SSE4.2
  "POPFD",         // X86 only
  "POPFQ",         // X64 only
  "POR",           // MMX/SSE2
  "PREFETCH",      // MMX-Ext
  "PSADBW",        // MMX-Ext
  "PSHUFB",        // SSSE3
  "PSHUFD",        // SSE2
  "PSHUFW",        // MMX-Ext
  "PSHUFHW",       // SSE2
  "PSHUFLW",       // SSE2
  "PSIGNB",        // SSSE3
  "PSIGND",        // SSSE3
  "PSIGNW",        // SSSE3
  "PSLLD",         // MMX/SSE2
  "PSLLDQ",        // SSE2
  "PSLLQ",         // MMX/SSE2
  "PSLLW",         // MMX/SSE2
  "PSRAD",         // MMX/SSE2
  "PSRAW",         // MMX/SSE2
  "PSRLD",         // MMX/SSE2
  "PSRLDQ",        // SSE2
  "PSRLQ",         // MMX/SSE2
  "PSRLW",         // MMX/SSE2
  "PSUBB",         // MMX/SSE2
  "PSUBD",         // MMX/SSE2
  "PSUBQ",         // SSE2
  "PSUBSB",        // MMX/SSE2
  "PSUBSW",        // MMX/SSE2
  "PSUBUSB",       // MMX/SSE2
  "PSUBUSW",       // MMX/SSE2
  "PSUBW",         // MMX/SSE2
  "PSWAPD",        // Enhanced 3dNow!
  "PTEST",         // SSE4.1
  "PUNPCKHBW",     // MMX/SSE2
  "PUNPCKHDQ",     // MMX/SSE2
  "PUNPCKHQDQ",    // SSE2
  "PUNPCKHWD",     // MMX/SSE2
  "PUNPCKLBW",     // MMX/SSE2
  "PUNPCKLDQ",     // MMX/SSE2
  "PUNPCKLQDQ",    // SSE2
  "PUNPCKLWD",     // MMX/SSE2
  "PUSH",          // X86/X64
  "PUSHAD",        // X86 only
  "PUSHFD",        // X86 only
  "PUSHFQ",        // X64 only
  "PXOR",          // MMX/SSE2
  "RCL",           // X86/X64
  "RCPPS",         // SSE
  "RCPSS",         // SSE
  "RCR",           // X86/X64
  "RDTSC",         // X86/X64
  "RDTSCP",        // X86/X64
  "REP_LODSB",     // X86/X64 (REP)
  "REP_LODSD",     // X86/X64 (REP)
  "REP_LODSQ",     // X64 only (REP)
  "REP_LODSW",     // X86/X64 (REP)
  "REP_MOVSB",     // X86/X64 (REP)
  "REP_MOVSD",     // X86/X64 (REP)
  "REP_MOVSQ",     // X64 only (REP)
  "REP_MOVSW",     // X86/X64 (REP)
  "REP_STOSB",     // X86/X64 (REP)
  "REP_STOSD",     // X86/X64 (REP)
  "REP_STOSQ",     // X64 only (REP)
  "REP_STOSW",     // X86/X64 (REP)
  "REPE_CMPSB",    // X86/X64 (REP)
  "REPE_CMPSD",    // X86/X64 (REP)
  "REPE_CMPSQ",    // X64 only (REP)
  "REPE_CMPSW",    // X86/X64 (REP)
  "REPE_SCASB",    // X86/X64 (REP)
  "REPE_SCASD",    // X86/X64 (REP)
  "REPE_SCASQ",    // X64 only (REP)
  "REPE_SCASW",    // X86/X64 (REP)
  "REPNE_CMPSB",   // X86/X64 (REP)
  "REPNE_CMPSD",   // X86/X64 (REP)
  "REPNE_CMPSQ",   // X64 only (REP)
  "REPNE_CMPSW",   // X86/X64 (REP)
  "REPNE_SCASB",   // X86/X64 (REP)
  "REPNE_SCASD",   // X86/X64 (REP)
  "REPNE_SCASQ",   // X64 only (REP)
  "REPNE_SCASW",   // X86/X64 (REP)
  "RET",           // X86/X64
  "ROL",           // X86/X64
  "ROR",           // X86/X64
  "ROUNDPD",       // SSE4.1
  "ROUNDPS",       // SSE4.1
  "ROUNDSD",       // SSE4.1
  "ROUNDSS",       // SSE4.1
  "RSQRTPS",       // SSE
  "RSQRTSS",       // SSE
  "SAHF",          // X86/X64 (CPUID NEEDED)
  "SAL",           // X86/X64
  "SAR",           // X86/X64
  "SBB",           // X86/X64
  "SETA",           // Begin (setcc)
                 // X86/X64 (setcc)
  "SETAE",         // X86/X64 (setcc)
  "SETB",          // X86/X64 (setcc)
  "SETBE",         // X86/X64 (setcc)
  "SETC",          // X86/X64 (setcc)
  "SETE",          // X86/X64 (setcc)
  "SETG",          // X86/X64 (setcc)
  "SETGE",         // X86/X64 (setcc)
  "SETL",          // X86/X64 (setcc)
  "SETLE",         // X86/X64 (setcc)
  "SETNA",         // X86/X64 (setcc)
  "SETNAE",        // X86/X64 (setcc)
  "SETNB",         // X86/X64 (setcc)
  "SETNBE",        // X86/X64 (setcc)
  "SETNC",         // X86/X64 (setcc)
  "SETNE",         // X86/X64 (setcc)
  "SETNG",         // X86/X64 (setcc)
  "SETNGE",        // X86/X64 (setcc)
  "SETNL",         // X86/X64 (setcc)
  "SETNLE",        // X86/X64 (setcc)
  "SETNO",         // X86/X64 (setcc)
  "SETNP",         // X86/X64 (setcc)
  "SETNS",         // X86/X64 (setcc)
  "SETNZ",         // X86/X64 (setcc)
  "SETO",          // X86/X64 (setcc)
  "SETP",          // X86/X64 (setcc)
  "SETPE",         // X86/X64 (setcc)
  "SETPO",         // X86/X64 (setcc)
  "SETS",          // X86/X64 (setcc)
  "SETZ",          // X86/X64 (setcc)
  "SFENCE",        // MMX-Ext/SSE
  "SHL",           // X86/X64
  "SHLD",          // X86/X64
  "SHR",           // X86/X64
  "SHRD",          // X86/X64
  "SHUFPD",        // SSE2
  "SHUFPS",        // SSE
  "SQRTPD",        // SSE2
  "SQRTPS",        // SSE
  "SQRTSD",        // SSE2
  "SQRTSS",        // SSE
  "STC",           // X86/X64
  "STD",           // X86/X64
  "STMXCSR",       // SSE
  "SUB",           // X86/X64
  "SUBPD",         // SSE2
  "SUBPS",         // SSE
  "SUBSD",         // SSE2
  "SUBSS",         // SSE
  "TEST",          // X86/X64
  "UCOMISD",       // SSE2
  "UCOMISS",       // SSE
  "UD2",           // X86/X64
  "UNPCKHPD",      // SSE2
  "UNPCKHPS",      // SSE
  "UNPCKLPD",      // SSE2
  "UNPCKLPS",      // SSE
  "XADD",          // X86/X64 (i486)
  "XCHG",          // X86/X64 (i386)
  "XOR",           // X86/X64
  "XORPD",         // SSE2
  "XORPS",         // SSE
};     

```

`AsmJit/opcode_table.h`:

```h
#ifndef OPCODE_TABLE_H
#define OPCODE_TABLE_H

extern const unsigned int instruction_table_count;
extern const char * instruction_table[575];    

#endif /* OPCODE_TABLE_H */ 

```

`BuildCode.hpp`:

```hpp
#ifndef BUILD_INFO_HPP
#define BUILD_INFO_HPP

#include <list>

struct Code_Piece
{
  long CodeStartAddr;
  long CodeSize;
}; 

class BuildExeInfo
{
    char *pchBuildExeName;
    std::list<Code_Piece> list_CodePiece;

  public:
    BuildExeInfo(char *pchFileName)
    {
        pchBuildExeName = pchFileName;
    }
    ~BuildExeInfo(){}

    typedef std::list<Code_Piece>::iterator iterator;

    iterator begin()
    {
        return list_CodePiece.begin();
    }

    iterator end()
    {
        return list_CodePiece.end();
    }

    void push_back(Code_Piece & _piece)
    {
      list_CodePiece.push_back(_piece);
    }

    void for_each(void (*fuc)(iterator _iter))
    {
        for (iterator i = begin(); i != end(); i++)
        {
            fuc(i);
        }
    }

    char *get_filename()
    {
      return pchBuildExeName;
    }
};

#endif /* BUILD_INFO_HPP */

```

`BuildVMByteCode.cpp`:

```cpp
/************************************************************
 *                                                         *
 *                                                        *
 *                2015年7月31日                          *
 *                             By:XiaoWei               *
 *                                                     *
 *                                                    *
 *****************************************************/

#include <list>
#include <map>
#include <vector>
#define _STDINT_H
#include "BuildVMByteCode.hpp"
#include "VirtualMachine.h"
#include "CombosVMCode.hpp"
#include "VMAddressTable.hpp"
#include "VMCodeBuffer.hpp"
#include "PCode.hpp"
#include "Analysis.hpp"
#include "OutDetailedInformation.hpp"
#include "AsmJit/opcode_table.h"
#include "VOperand.hpp"
#pragma warning(disable:4309)

long g_Handle_i_key = 0x12345678;

#define get_operand1(x)      x.operand[0]
#define get_operand2(x)      x.operand[1]
#define get_operand1_type(x) x.operand[0].type
#define get_operand2_type(x) x.operand[1].type

#define read_mem(x) if(x.type == UD_OP_MEM) { \
         switch (x.size) { \
         case 0:\
         printf("大小为0\n");\
         break;\
         case 8:\
         var_combos_vm_code.b_read_mem();\
         break;\
         case 16:\
         var_combos_vm_code.w_read_mem();\
         break;\
         case 32:\
         var_combos_vm_code.d_read_mem();\
         break;\
         case 64:\
         int low_tmp_addr = var_combos_vm_code.get_tmp_vmregister();\
         var_combos_vm_code.push_vsp();\
         var_combos_vm_code.d_read_mem();\
         var_combos_vm_code.pop(low_tmp_addr);\
         var_combos_vm_code.b_push_imm_zx(4);\
         var_combos_vm_code.d_add();\
         var_combos_vm_code.pop(T_INVALID);\
         var_combos_vm_code.d_read_mem();\
         var_combos_vm_code.push(low_tmp_addr | T_E32X);\
         var_combos_vm_code.d_read_mem();\
         var_combos_vm_code.unlock_tmp_vmregister(low_tmp_addr);\
         break;} \
     }    

#define write_mem(x) if(x.type == UD_OP_MEM){ \
              switch (x.size){ \
                 case 8:\
                    var_combos_vm_code.b_write_mem();\
                    break;\
                 case 16:\
                    var_combos_vm_code.w_write_mem();\
                    break;\
                 case 32:\
                    var_combos_vm_code.d_write_mem();\
                    break;\
                 case 64:\
                    int higt_tmp_addr = var_combos_vm_code.get_tmp_vmregister();\
                    var_combos_vm_code.push_vsp();\
                    var_combos_vm_code.d_read_mem();\
                    var_combos_vm_code.b_push_imm_zx(4);\
                    var_combos_vm_code.d_add();\
                    var_combos_vm_code.pop(T_INVALID);\
                    var_combos_vm_code.pop(higt_tmp_addr| T_E32X);\
                    var_combos_vm_code.d_write_mem();\
                    var_combos_vm_code.push(higt_tmp_addr | T_E32X);\
                    var_combos_vm_code.d_write_mem();\
                    var_combos_vm_code.unlock_tmp_vmregister(higt_tmp_addr);\
                    break;}}  

// 根据operand[0]的size，调整operand[1]中的立即数的值
#define set_imm_operand_size(dst,src) if (dst.type == UD_OP_IMM)\
        {\
            switch (src.size)\
            {\
            case 8:\
                break;\
            case 16:\
                if (dst.size == 8)\
                dst.lval.sword = (signed short)dst.lval.sbyte;\
                break;\
            case 32:\
                if (dst.size == 8)\
                {\
                    dst.lval.sdword = (signed int)dst.lval.sbyte;\
                }\
                else if (dst.size == 16)\
                {\
                    dst.lval.sdword = (signed int)dst.lval.sword;\
                }\
                break;\
            }\
            dst.size = src.size;\
        }

 
void printf_map_register_store(
        std::map<int,RegisterStore> & _p_map_in,
        std::map<int,RegisterStore> & _p_map_out)
{
    int i = 0;
    while (_p_map_in.find(i) != _p_map_in.end())
    {
        printf("标签:%x\n",i);
        printf("In  Key:%08x\n",_p_map_in[i].get_key());
        OutDI di;
        di.set_begin_text("");
        di.set_end_text(" ");

        di.print_vmregister_information(_p_map_in[i]);

        printf("\nOut Key:%08x\n",_p_map_out[i].get_key());
        di.set_begin_text("");
        di.set_end_text(" ");
        di.print_vmregister_information(_p_map_out[i]);
        i++;
        printf("\n");
    }
}

void printf_map_register_store(std::map<int,RegisterStore> & _p_map,
        char *sz)
{/*{{{*/
    std::map<int,RegisterStore>::iterator iter = _p_map.begin();
    for (iter; iter!=_p_map.end();iter++)
    {
        printf("标签:%x\n",iter->first);
        printf("%s Key:%08x\n\n",sz,iter->second.get_key());
        OutDI di;
        di.set_begin_text(sz);
        di.set_end_text("\n");
        di.print_vmregister_information(iter->second);
    }
}/*}}}*/

long BuildVMByteCode::get_vmcode_address(int _label_index)
{
    long result = 0;
    if (var_map_label_vmcode_addr.find(_label_index) !=
        var_map_label_vmcode_addr.end())
    {
       result = var_map_label_vmcode_addr[_label_index];
    }
    return result;
}

// DeDf : 1
long BuildVMByteCode::create_vm_entry(int _piece_label)
{
    long opcode_addr = get_vmcode_address(_piece_label);
    long init_de_key = 0x12345678;
    bool t_sign = ptr_addr_table->get_sign();
    ptr_addr_table->set_sign(true);
    long head_address = ptr_addr_table->assign_address(0x70);
    ptr_addr_table->set_sign(t_sign);

    VMCodeBufferManage * buffer_manage = var_map_label_vmbuffer_manage[_piece_label];

    ppcode_block_info info = pVM->create_function_head(
                            head_address,
                            opcode_addr,
                            &(buffer_manage->get_pcode()),
                            123456,
                            init_de_key); //pcode位置有问题

    ptr_addr_table->copy(head_address,info->buf,info->size);

    printf("VM入口点地址:%x\n",head_address);
    return head_address;
}

long BuildVMByteCode::build_vmcode(bool b_allocator)
{
    long vm_byte_code_head = 0;
    newlabel_count = 0;

    for (std::vector<CodePiece>::iterator iter = var_list_code_piece.begin();
         iter != var_list_code_piece.end();
         iter++)
    {
        int var_cur_label = iter->get_label();
        VMCodeBufferManage * cur_vmbuffer_manage = NULL;
        if (b_allocator)
        {
            cur_vmbuffer_manage = new VMCodeBufferManage(pVM);
            cur_vmbuffer_manage->set_vmcode_label(var_cur_label);
            var_vmcode_manager_list.push_back(cur_vmbuffer_manage);
            var_map_label_vmbuffer_manage.insert(
                                    std::make_pair<int,VMCodeBufferManage*>(
                                            var_cur_label,cur_vmbuffer_manage));
        }
        else
        {
            if (var_map_label_vmbuffer_manage.find(var_cur_label) !=
                var_map_label_vmbuffer_manage.end())
            {
                cur_vmbuffer_manage = var_map_label_vmbuffer_manage[var_cur_label];
            }
            else
            {
                __asm int 3;
            }
        }

        PCode & var_pcode = cur_vmbuffer_manage->get_pcode();
        VCombosVMCode & var_combos_vm_code = cur_vmbuffer_manage->get_generator();
        VTable var_vmcode_info;
        if (b_allocator)
        {
            var_vmcode_info.key = var_pcode.get_original_key();
            var_vmcode_info.v = &var_combos_vm_code;
            var_pcode.count_vmcode_begin();
            var_pcode.set_key(0x12345678);
        }
        else
        {
#ifdef _DEBUG
            char file_name[256];
            memset(&file_name,0,256);

            sprintf_s(file_name, 256, "virtual_machine_Label%d_%08x",
            //sprintf_s(file_name, 256, "virtual_machine_Label\n"
                iter->get_label(),
                var_map_label_vmcode_addr[iter->get_label()]);

            var_pcode.out_log_file(file_name);
#endif
        }

        var_pcode.register_store_in  = var_map_label_vmreg_store_in[iter->get_label()];
        var_pcode.register_store_out = var_map_label_vmreg_store_out[iter->get_label()];
        printf("save_vm_context->\n");
        var_combos_vm_code.save_vm_context();
        printf(" <-save_vm_context()\n");

        for (std::list<ud_t>::iterator uiter = iter->get_piece().begin();
             uiter != iter->get_piece().end();
             uiter++)
        {
            if (b_allocator == false)
                for (std::vector<long*>::iterator entry_iter = var_entry_address.begin();
                    entry_iter != var_entry_address.end();
                    entry_iter++)
                {
                    long * addr = *entry_iter;
                    if (uiter->insn_offset == *addr)
                    {
                        if (get_vmcode_address(var_cur_label))
                            *addr = create_vm_entry(var_cur_label);
                        else
                        {
                            printf("没有找到地址%x\n",*addr);
                            _asm int 3;
                        }
                    }
                }

            std::list<ud_t>::iterator uiter_check_end = uiter;
            if (++uiter_check_end == iter->get_piece().end()) //是否是最后一条指令
            {
                printf("最后一条指令\n");
                long next_addr = 0;
                long jmp_addr = 0;
                bool test_find_addr_next = var_map_label_vmreg_store_in.find(iter->get_label() + 1) !=
                                var_map_label_vmreg_store_in.end();
                bool test_find_addr_jmp = var_map_label_vmreg_store_in.find(iter->get_jmplabel()) !=
                                var_map_label_vmreg_store_in.end();
                if (test_find_addr_next)
                    next_addr = get_vmcode_address(iter->get_label() + 1);
                if (test_find_addr_jmp)
                    jmp_addr = get_vmcode_address(iter->get_jmplabel());

                 long ignore_build_code_addr = 0;
                 ignore_build_code_addr = iter->get_jmplabel();

                switch (iter->get_opcode_attribute())
                {
                case OPCODE_ATTRIBUTE_JCC: //虚拟机内部条件跳转
                {
                    var_combos_vm_code.d_push_imm(jmp_addr);
                    var_combos_vm_code.d_push_imm(next_addr);
                    var_combos_vm_code.pop(T_NEXTINSADDR);
                    var_combos_vm_code.pop(T_JMPINSADDR);
                    build(var_combos_vm_code,*uiter);
                    var_combos_vm_code.recover_vm_context();
                    var_combos_vm_code.push(T_NEXTINSADDR);
                    var_combos_vm_code.set_pc(0x12345678);
                }
                    break;
                case OPCODE_ATTRIBUTE_JMP: //虚拟机内部跳转
                {
                    var_combos_vm_code.recover_vm_context();
                    var_combos_vm_code.d_push_imm(jmp_addr);
                    var_combos_vm_code.set_pc(0x12345678);
                }
                    break;
                case OPCODE_ATTRIBUTE_CALL: //虚拟机内部call
                {
                    _asm int 3;
                }
                    break;
                case OPCODE_ATTRIBUTE_EXTERNAL_JMP: //跳转到虚拟机外部
                {
                    if (iter->get_jmplabel() != PC_NONE)
                    {
                       var_combos_vm_code.d_push_imm(ignore_build_code_addr);
                    }
                    else
                    {
                        read_vm_operand(var_combos_vm_code,uiter->operand[0]);
                    }
                    //var_combos_vm_code.recover_vm_context();
                    var_combos_vm_code.ret();
                }
                    break;
                case OPCODE_ATTRIBUTE_EXTERNAL_CALL:
                {
                    int next_pcode_addr = 0;
                    if (get_vmcode_address(iter->get_label() + 1))
                         next_pcode_addr = create_vm_entry(iter->get_label() + 1);
                    else
                         next_pcode_addr = (int)uiter->pc;
                    var_combos_vm_code.d_push_imm(next_pcode_addr);
                    if (iter->get_jmplabel() != PC_NONE)
                    {
                        var_combos_vm_code.d_push_imm(ignore_build_code_addr);
                    }
                    else
                    {
                        read_vm_operand(var_combos_vm_code,uiter->operand[0]);
                    }
                    //var_combos_vm_code.recover_vm_context();
                    var_combos_vm_code.ret();
//                    printf("处理OPCODE_ATTRIBUTE_EXTERNAL_CALL\n");
                }
                    break;
                case OPCODE_ATTRIBUTE_EXTERNAL_JCC:
                {
                    _asm int 3;
                }
                    break;
                case OPCODE_ATTRIBUTE_NORMAL:
                {
                    build(var_combos_vm_code,*uiter);
                    var_combos_vm_code.recover_vm_context();
                    //var_combos_vm_code.push(T_NEXTINSADDR);
                    var_combos_vm_code.d_push_imm(next_addr);
                    var_combos_vm_code.set_pc(0x12345678);
                }
                    break;
                case OPCODE_ATTRIBUTE_RET:
                {
                    build(var_combos_vm_code,*uiter);
                }
                    break;
                case OPCODE_ATTRIBUTE_EXIT:
                {
                    build(var_combos_vm_code,*uiter);
                    var_combos_vm_code.d_push_imm(ignore_build_code_addr);
                    //var_combos_vm_code.recover_vm_context();
                    var_combos_vm_code.ret();
                }
                    break;
                default:
                    break;
                }
            }
            else  // 不是最后一条指令
            {
                if (ud_insn_mnemonic(&*uiter) != UD_Inop)
                    printf("build %s\n",uiter->insn_buffer);

                build(var_combos_vm_code, *uiter);
            }

#ifdef _DEBUG
            if (b_allocator == false )
            {
                fprintf(var_pcode.get_log(),"\nbuild %-30s\n\n",uiter->insn_buffer);
                printf("build %-30s ...done\n",uiter->insn_buffer);
            }
#endif
        }

        if (b_allocator)
        {
            unsigned long vm_piece_size = (unsigned long)var_pcode.count_vmcode_end();

            unsigned long t_byte_code_addr = ptr_addr_table->assign_address(vm_piece_size,var_vmcode_info);

            printf("标签%d,大小:%d, addr:%08x\n", iter->get_label(), vm_piece_size, t_byte_code_addr);

            if(vm_byte_code_head == 0)
                vm_byte_code_head = t_byte_code_addr;

            if (ptr_addr_table->get_sign())
                printf("分配到的PCODE地址%08x - %08x,标志:%d\n",
                       t_byte_code_addr,
                       t_byte_code_addr + vm_piece_size,
                       ptr_addr_table->get_sign());
            else
                printf("分配到的PCODE地址%08x - %08x,标志:%d\n",
                       t_byte_code_addr - vm_piece_size,
                       t_byte_code_addr,
                       ptr_addr_table->get_sign());

            var_map_label_vmcode_addr.insert(std::make_pair<int,long>(iter->get_label(),t_byte_code_addr));
        }
    }
    return vm_byte_code_head;
}


void BuildVMByteCode::register_mapped_init()
{
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RAX,T_RAX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RBX,T_RBX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RCX,T_RCX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RDX,T_RDX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RSP,T_RSP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RBP,T_RBP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RSI,T_RSI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_RDI,T_RDI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_EAX,T_EAX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_EBX,T_EBX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_ECX,T_ECX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_EDX,T_EDX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_ESP,T_ESP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_EBP,T_EBP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_ESI,T_ESI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_EDI,T_EDI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_AX,T_AX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_BX,T_BX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_CX,T_CX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_DX,T_DX));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_SP,T_SP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_BP,T_BP));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_SI,T_SI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_DI,T_DI));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_AL,T_AL));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_AH,T_AH));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_BL,T_BL));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_CL,T_CL));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_DL,T_DL));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_BH,T_BH));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_CH,T_CH));
    mapped_vm_register.insert(make_pair<ud_type,long>(UD_R_DH,T_DH));
}

BuildVMByteCode::BuildVMByteCode(VirtualMachine *vm,
        pCodeBufferInfo ptr_info,
        VMAddressTable *ptr_address_table):newlabel_count(0)
{
   if (!ptr_info->size)  // 指令块长度
        return;

    register_mapped_init();

    Analysis var_analysis;
    var_analysis.disasm(ptr_info,var_list_code_piece);
    var_analysis.printf_piece(var_list_code_piece);

    pVM = vm;
    ptr_addr_table = ptr_address_table;

    full_register_store(var_list_code_piece,
                              var_map_label_vmreg_store_in,var_map_label_vmreg_store_out);
    printf_map_register_store(var_map_label_vmreg_store_in,var_map_label_vmreg_store_out);

    long vm_byte_code_head = build_vmcode(true);
    build_vmcode(false);
    ptr_address_table->copy();

    bool t_sign = ptr_address_table->get_sign();
    ptr_address_table->set_sign(true);
    long head_address = ptr_address_table->assign_address(0x70);
    ptr_address_table->set_sign(t_sign);

    ppcode_block_info info = pVM->create_function_head(
          head_address,
          vm_byte_code_head,
          &(var_vmcode_manager_list[0]->get_pcode()),
          123456,
          g_Handle_i_key);

    ptr_address_table->copy(head_address, info->buf, info->size);
    ptr_info->addr = head_address;
}

BuildVMByteCode::~BuildVMByteCode()
{
   for (std::vector<VMCodeBufferManage*>::iterator iter = var_vmcode_manager_list.begin();
         iter != var_vmcode_manager_list.end();
         iter++) 
   {
      delete *iter;
   }
}

void BuildVMByteCode::vm_operand(
      VCombosVMCode & var_combos_vm_code, ud_operand & var_operand)
{
   var_combos_vm_code.impact_vmregister(false);
   switch (var_operand.type)
   {
      case UD_OP_MEM:
         {
            int count = 0;
            if (mapped_vm_register.find(var_operand.base) == mapped_vm_register.end())
            {
                 //printf("没有base\n");
            }
            else
            {
               long base = mapped_vm_register[var_operand.base];
               var_combos_vm_code.push(base); 
               count++;
            }

            if (mapped_vm_register.find(var_operand.index) == mapped_vm_register.end())
            {
               //printf("没有index\n");
            }
            else
            {
               long index = mapped_vm_register[var_operand.index];
               var_combos_vm_code.push(index);
               switch (var_operand.scale)
               {
               case 1:
                   var_combos_vm_code.b_push_imm(0);
                   break;
               case 2:
                   var_combos_vm_code.b_push_imm(1);
                   break;
               case 4:
                   var_combos_vm_code.b_push_imm(2);
                   break;
               case 8:
                   var_combos_vm_code.b_push_imm(3);
                   break;
               }

               var_combos_vm_code.d_shl();
               var_combos_vm_code.pop(T_INVALID);
               count++;
            }

            if (var_operand.lval.sdword)
            {
               count++;
               if (var_operand.offset == 8)
               {
                  signed char lval = var_operand.lval.sbyte;
                  var_combos_vm_code.b_push_imm_sx(lval);
               }
               else
               {
                  long lval = var_operand.lval.sdword;
                  var_combos_vm_code.d_push_imm(lval);
               }
            }
            for (int i = 1; i < count ; i++)
            {
               var_combos_vm_code.d_add();
               var_combos_vm_code.pop(T_INVALID);
            } 
         }
         break;

      case UD_OP_IMM:
         {
            switch (var_operand.size)
            {
               case 8:
                  {
                     signed char lval = var_operand.lval.sbyte; 
                     var_combos_vm_code.b_push_imm(lval);
                  }
                  break;
               case 16:
                  {
                     signed short lval = var_operand.lval.sword;
                     var_combos_vm_code.w_push_imm(lval); 
                  }
                  break;
               case 32:
                  {
                     int lval = var_operand.lval.sdword;
                     var_combos_vm_code.d_push_imm(lval);  
                  }
                  break;
            }
         }
         break;

      case UD_OP_REG:
         {
            if (mapped_vm_register.find(var_operand.base) == mapped_vm_register.end())
            {
                 printf("没有寄存器\n");
                 __asm int 3;
            }
            else
            {
               long base = mapped_vm_register[var_operand.base];
               var_combos_vm_code.push(base); 
            } 
         }
         break;
   }  // switch (var_operand.type)

   var_combos_vm_code.impact_vmregister(true);
}

long BuildVMByteCode::get_vm_register(ud_type _register)
{
   long result = T_INVALID;
   if (mapped_vm_register.find(_register) == mapped_vm_register.end())
   {
      printf("无法识别的寄存器\n");
   }
   else
   {
      result = mapped_vm_register[_register];
   }
   return result;
}

void BuildVMByteCode::copy_exec_code_to_stack(VCombosVMCode & var_combos_vm_code,
                                              const uint8_t * var_code_buffer,
                                              size_t var_code_size)
{
    var_combos_vm_code.b_push_imm(0xc3);
    for (int i = (int)var_code_size - 1; i >= 0; i--)
    {
       //printf("%x ",code_addr[i]);
       var_combos_vm_code.b_push_imm(var_code_buffer[i]);
    }
    var_combos_vm_code.b_push_imm((char)var_code_size + 1);
    var_combos_vm_code.run_stack();
}

void BuildVMByteCode::build_fpu(VCombosVMCode & var_combos_vm_code,ud_t &var_ud)
{
   // printf ("instruction_table size %d\n",sizeof(instruction_table));
    switch (get_operand1_type(var_ud))
    {
    case UD_OP_IMM:
        copy_exec_code_to_stack(var_combos_vm_code,ud_insn_ptr(&var_ud),ud_insn_len(&var_ud));
        break;
    case UD_OP_MEM:
        if (get_operand1(var_ud).base == UD_NONE &&
                get_operand1(var_ud).index == UD_NONE &&
                get_operand1(var_ud).scale == 0) //like mnemonic [addr]
        {
            copy_exec_code_to_stack(var_combos_vm_code,ud_insn_ptr(&var_ud),ud_insn_len(&var_ud));
        }
        else{
            const char * mnemonic_name = ud_lookup_mnemonic(ud_insn_mnemonic(&var_ud));
            bool find = false;
            //printf ("mnemonic :%s\n",mnemonic_name);
            for (unsigned int index = 0; index < instruction_table_count; index++)
            {
                if (_stricmp(instruction_table[index],mnemonic_name) == 0)
                {
                    read_vm_operand(var_combos_vm_code,get_operand1(var_ud));

                    find = true;
                    //read_vm_operand(var_combos_vm_code,var_ud);
                    AsmJit::Assembler a;
                    AsmJit::Operand o1;
                    switch (get_operand1(var_ud).size) {
                    case 32:
                        o1 = AsmJit::dword_ptr(AsmJit::nbp);
                        break;
                    case 64:
                        o1 = AsmJit::qword_ptr(AsmJit::nbp);
                        break;
                    default:
#ifdef _DEBUG
                        printf("未知的FPU指令操作数大小%d\n",get_operand1(var_ud).size);
#endif
                        break;
                    }
                    a._emitInstruction(index,&o1);
                    copy_exec_code_to_stack(var_combos_vm_code,
                                            a.getCode(),
                                            a.getCodeSize());
                    break;
                }
            }
            if (find == false)
                printf("没有找到%s指令\n",mnemonic_name);
            else
                write_vm_operand(var_combos_vm_code,get_operand1(var_ud));
        }
        break;
    case UD_OP_REG:
        if (mapped_vm_register.find(get_operand1(var_ud).base) == mapped_vm_register.end()) //like mnemonic st1,st2
            copy_exec_code_to_stack(var_combos_vm_code,ud_insn_ptr(&var_ud),ud_insn_len(&var_ud));
        break;
    case UD_NONE:
        copy_exec_code_to_stack(var_combos_vm_code,ud_insn_ptr(&var_ud),ud_insn_len(&var_ud));
        break;
    }
}

 //编译前缀
void BuildVMByteCode::build_pfx(VCombosVMCode & var_combos_vm_code,ud_t &var_ud,CodePiece & var_cur_piece,bool b_allocator)
{
   VMCodeBufferManage * code_buf = NULL;

   if (b_allocator)
   {
      code_buf = create_newvm_piece();
   }
   else
   {
       code_buf = get_newvm_piece();
   }

   VCombosVMCode & new_combos_vm_code = code_buf->get_generator();
   PCode & new_pcode = code_buf->get_pcode();

   if (b_allocator)
   {
       new_pcode.count_vmcode_begin();
       //cur_vmcode -> new_combos or next
       //new_combos -> cur_vmcode

       RegisterStore t_store;
       new_combos_vm_code.upset_register_array(t_store);

       new_combos_vm_code.set_vmregister_store_in(t_store);
       new_combos_vm_code.set_vmregister_store_out(t_store);
       new_pcode.set_key(0x12345678);
   }
   else
   {
       new_combos_vm_code.set_vmregister_store_in(
                   var_map_label_vmreg_store_out[var_cur_piece.get_label()]);
       new_combos_vm_code.set_vmregister_store_out(
                   var_map_label_vmreg_store_in[var_cur_piece.get_label()]);
#ifdef _DEBUG
           char file_name[256];
           memset(&file_name,0,256);
           sprintf_s(file_name, 256,
               "virtual_machine_assembly/NewLabel%d,%08x\n",
               get_newvm_cur_label(),var_map_newlabel_vmcode_addr[get_newvm_cur_label()]);
           new_pcode.out_log_file(file_name);
#endif
   }

   new_combos_vm_code.save_vm_context();
   build(new_combos_vm_code,var_ud); 

   if (var_ud.pfx_rep)
   {
      if (b_allocator)
      {
       var_combos_vm_code.d_push_imm(0);
       var_combos_vm_code.d_push_imm(0);
      } else {
         long jmp_addr = var_map_label_vmcode_addr[var_cur_piece.get_jmplabel()];
         long next_addr = var_map_newlabel_vmcode_addr[get_newvm_cur_label()];
         //var_combos_vm_code.d_push_imm(next_addr);
         //var_combos_vm_code.d_push_imm(jmp_addr);
         var_combos_vm_code.d_push_imm(jmp_addr);
         var_combos_vm_code.d_push_imm(next_addr);
      }
      //var_combos_vm_code.ptr_pcode->out_info("cmp ecx,0 \njz store\n");
      var_combos_vm_code.impact_vmregister(false);
      var_combos_vm_code.push_vsp();

      var_combos_vm_code.push(T_ECX); //cmp ecx,0
      var_combos_vm_code.d_push_imm(0);
      var_combos_vm_code.d_cmp();
      var_combos_vm_code.get_zf();

      var_combos_vm_code.d_add();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.d_read_mem(); //读取地址
      var_combos_vm_code.pop(T_NEXTINSADDR);
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_INVALID);

      //用这个的话计算到最后ecx会少一个
      /*
      var_combos_vm_code.d_push_imm(1) ;
      var_combos_vm_code.push(T_ECX); //sub ecx,1
      var_combos_vm_code.d_sub();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_ECX);

      */
      new_combos_vm_code.d_push_imm(1);
      new_combos_vm_code.push(T_ECX); //sub ecx,1
      new_combos_vm_code.d_sub();
      new_combos_vm_code.pop(T_INVALID);
      new_combos_vm_code.pop(T_ECX);



      //var_combos_vm_code.set_pc(0x12345678);

      new_combos_vm_code.recover_vm_context();
      if (b_allocator)
      {
          new_combos_vm_code.d_push_imm(0);
          //new_combos_vm_code.d_push_imm(0);
      }
      else
      {
          int next_addr = get_vmcode_address(var_cur_piece.get_label());//var_map_label_vmcode_addr[var_cur_piece.get_label()];
          new_combos_vm_code.d_push_imm(next_addr);
      }
      new_combos_vm_code.set_pc(0x12345678);

   }
   else if (var_ud.pfx_repe)
   {
      //while (ecx != 0)
      //{
      //   oldcode();
      //}
      if (b_allocator)
      {
       var_combos_vm_code.d_push_imm(0);
       var_combos_vm_code.d_push_imm(0);
      } else {
         long jmp_addr = var_map_label_vmcode_addr[var_cur_piece.get_jmplabel()];
         long next_addr = var_map_newlabel_vmcode_addr[get_newvm_cur_label()];
         var_combos_vm_code.d_push_imm(next_addr);
         var_combos_vm_code.d_push_imm(jmp_addr);
         //var_combos_vm_code.d_push_imm(jmp_addr);
         //var_combos_vm_code.d_push_imm(next_addr);
      }
      //var_combos_vm_code.ptr_pcode->out_info("cmp ecx,0 \njz store\n");
      var_combos_vm_code.impact_vmregister(false);
      var_combos_vm_code.push_vsp();

      var_combos_vm_code.push(T_ECX); //cmp ecx,0
      var_combos_vm_code.d_push_imm(0);
      var_combos_vm_code.d_cmp();
      var_combos_vm_code.get_zf();

      var_combos_vm_code.pushf();
      var_combos_vm_code.impact_vmregister(true);
      var_combos_vm_code.get_zf();
      var_combos_vm_code.d_or();
      var_combos_vm_code.pop(T_INVALID);

      var_combos_vm_code.d_add();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.d_read_mem(); //读取地址
      //var_combos_vm_code.int3();
      var_combos_vm_code.pop(T_NEXTINSADDR);
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_INVALID);

      //用这个的话计算到最后ecx会少一个
      /*
      var_combos_vm_code.d_push_imm(1) ;
      var_combos_vm_code.push(T_ECX); //sub ecx,1
      var_combos_vm_code.d_sub();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_ECX);

      */
      new_combos_vm_code.d_push_imm(1);
      new_combos_vm_code.push(T_ECX); //sub ecx,1
      new_combos_vm_code.d_sub();
      new_combos_vm_code.pop(T_INVALID);
      new_combos_vm_code.pop(T_ECX);


      //var_combos_vm_code.set_pc(0x12345678);

      new_combos_vm_code.recover_vm_context();
      if (b_allocator)
      {
          new_combos_vm_code.d_push_imm(0);
          //new_combos_vm_code.d_push_imm(0);
      }
      else
      {
          int next_addr = get_vmcode_address(var_cur_piece.get_label());//var_map_label_vmcode_addr[var_cur_piece.get_label()];
          new_combos_vm_code.d_push_imm(next_addr);
      }
      new_combos_vm_code.set_pc(0x12345678);

   }
   else if (var_ud.pfx_repne)
   {
      
      //while (ecx != 0)
      //{
      //   oldcode();
      //}
      if (b_allocator)
      {
       var_combos_vm_code.d_push_imm(0);
       var_combos_vm_code.d_push_imm(0);
      } else {
         long jmp_addr = var_map_label_vmcode_addr[var_cur_piece.get_jmplabel()];
         long next_addr = var_map_newlabel_vmcode_addr[get_newvm_cur_label()];
         //var_combos_vm_code.d_push_imm(next_addr);
         //var_combos_vm_code.d_push_imm(jmp_addr);
         var_combos_vm_code.d_push_imm(jmp_addr);
         var_combos_vm_code.d_push_imm(next_addr);
      } 
      //var_combos_vm_code.ptr_pcode->out_info("cmp ecx,0 \njz store\n");
      var_combos_vm_code.impact_vmregister(false);
      var_combos_vm_code.push_vsp();

      var_combos_vm_code.push(T_ECX); //cmp ecx,0
      var_combos_vm_code.d_push_imm(0);
      var_combos_vm_code.d_cmp();
      var_combos_vm_code.get_zf();

      var_combos_vm_code.pushf();
      var_combos_vm_code.impact_vmregister(true);
      var_combos_vm_code.get_zf();
      var_combos_vm_code.d_or();
      var_combos_vm_code.pop(T_INVALID);

      var_combos_vm_code.d_add();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.d_read_mem(); //读取地址
      //var_combos_vm_code.int3();
      var_combos_vm_code.pop(T_NEXTINSADDR);
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_INVALID);

      //用这个的话计算到最后ecx会少一个
      /*
      var_combos_vm_code.d_push_imm(1) ;
      var_combos_vm_code.push(T_ECX); //sub ecx,1
      var_combos_vm_code.d_sub();
      var_combos_vm_code.pop(T_INVALID);
      var_combos_vm_code.pop(T_ECX);

      */
      new_combos_vm_code.d_push_imm(1);
      new_combos_vm_code.push(T_ECX); //sub ecx,1
      new_combos_vm_code.d_sub();
      new_combos_vm_code.pop(T_INVALID);
      new_combos_vm_code.pop(T_ECX);


      //var_combos_vm_code.set_pc(0x12345678);

      new_combos_vm_code.recover_vm_context();
      if (b_allocator)
      {
          new_combos_vm_code.d_push_imm(0);
          //new_combos_vm_code.d_push_imm(0);
      }
      else
      {
          int next_addr = get_vmcode_address(var_cur_piece.get_label());//var_map_label_vmcode_addr[var_cur_piece.get_label()];
          new_combos_vm_code.d_push_imm(next_addr);
      }
      new_combos_vm_code.set_pc(0x12345678);

      //var_combos_vm_code.push()
      //var_combos_vm_code
   }
   if (b_allocator)
   {
      int new_pcode_size = (int)new_pcode.count_vmcode_end();
      VTable table;
      table.v = &new_combos_vm_code;
      long new_pcode_addr = ptr_addr_table->assign_address(new_pcode_size,table);
      var_map_newlabel_vmcode_addr.insert(std::make_pair<int,long>(get_newvm_cur_label(),new_pcode_addr));
      //printf("NewLabel分配到PCODE地址:%x - %x\n",new_pcode_addr - new_pcode_size,new_pcode_addr);
           if (ptr_addr_table->get_sign())
               printf("分配到的NEWPCODE地址%08x - %08x,标志:%d\n",
                  new_pcode_addr,
                  new_pcode_addr + new_pcode_size,
                  ptr_addr_table->get_sign());
           else
               printf("分配到的NEWPCODE地址%08x - %08x,标志:%d\n",
                  new_pcode_addr - new_pcode_size,
                  new_pcode_addr,
                  ptr_addr_table->get_sign());

   }
   else
   {
       //ptr_addr_table->copy();
       //int a = new_combos_vm_code.get_code_size();
       //printf("代码大小%d\n",a);
   }
}

VMCodeBufferManage * BuildVMByteCode::create_newvm_piece()
{
   var_vmcode_manager_list.push_back(new VMCodeBufferManage(pVM));
   var_map_newlabel_vmbuffer_manage.insert(
         std::make_pair<int,VMCodeBufferManage *>(newlabel_count,var_vmcode_manager_list.back()));
   newlabel_count++;
   return var_vmcode_manager_list.back();
} 

VMCodeBufferManage * BuildVMByteCode::get_newvm_piece()
{
    VMCodeBufferManage * result = NULL;
   if (var_map_newlabel_vmbuffer_manage.find(newlabel_count) !=
           var_map_newlabel_vmbuffer_manage.end())
   {
       result = var_map_newlabel_vmbuffer_manage[newlabel_count];

   }
   newlabel_count++;
   return result;
}

long BuildVMByteCode::get_newvm_cur_label()
{
    return newlabel_count;
}

void BuildVMByteCode::write_vm_operand(VCombosVMCode & var_combos_vm_code,ud_operand & var_operand)
{
    switch (var_operand.type)
    {
    case UD_OP_MEM:
        vm_operand(var_combos_vm_code,var_operand);
        write_mem(var_operand);
        break;
    case UD_OP_REG:
        if (var_operand.base == UD_R_ESP)
        {
            var_combos_vm_code.pop_vsp();
        }
        else
            var_combos_vm_code.pop(get_vm_register(var_operand.base));
        break;
    }    
}

void BuildVMByteCode::read_vm_operand(VCombosVMCode & var_combos_vm_code,ud_operand & var_operand)
{
     vm_operand(var_combos_vm_code,var_operand);
     read_mem(var_operand);
}

void BuildVMByteCode::build(VCombosVMCode & var_combos_vm_code, ud_t &ud)
{
   if( get_operand1(ud).base  == UD_R_ESP ||
       get_operand1(ud).index == UD_R_ESP ||
       get_operand2(ud).base  == UD_R_ESP ||
       get_operand2(ud).index == UD_R_ESP )
   {
      var_combos_vm_code.push_vsp();
      var_combos_vm_code.pop(T_ESP);
   }

   switch(ud_insn_mnemonic(&ud))
   {
    case UD_Inop:
       break;
    case UD_Imov:
       {
          set_imm_operand_size(get_operand2(ud),get_operand1(ud));

           read_vm_operand(var_combos_vm_code,get_operand2(ud));
          write_vm_operand(var_combos_vm_code,get_operand1(ud));
       }
     break;
    case UD_Ixchg:
       {
         read_vm_operand(var_combos_vm_code,get_operand2(ud));
         read_vm_operand(var_combos_vm_code,get_operand1(ud));

         write_vm_operand(var_combos_vm_code,get_operand2(ud));
         write_vm_operand(var_combos_vm_code,get_operand1(ud));
       }
       break;
    case UD_Ilea:
     {/*{{{*/
        vm_operand(var_combos_vm_code,get_operand2(ud));
        
        //var_combos_vm_code.pop(mapped_vm_register[get_operand1(var_ud).base]);
        write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }/*}}}*/
     break;
    case UD_Ipush:
     {/*{{{*/
        ud_operand o;
        o.size = 32; //默认用32位
        set_imm_operand_size(get_operand1(ud),o);
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
     }/*}}}*/
     break;   
    case UD_Icmp:
     {/*{{{*/
/*操作
temp  SRC1 - SignExtend(SRC2); 
ModifyStatusFlags; (* Modify status flags in the same manner as the SUB instruction*)
影响的标志
CF、OF、SF、ZF、AF 及 PF 标志根据结果设置。
*/      set_imm_operand_size(get_operand2(ud),get_operand1(ud));

       read_vm_operand(var_combos_vm_code,get_operand2(ud));
       read_vm_operand(var_combos_vm_code,get_operand1(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_sub();
              var_combos_vm_code.popf();   
              var_combos_vm_code.pop(T_INVALID | T_E32X | T_16X | T_8L);
              break;
           case 16:
              var_combos_vm_code.w_sub();
              var_combos_vm_code.popf();
              var_combos_vm_code.pop(T_INVALID | T_E32X | T_16X);
              break;
           case 32:
              var_combos_vm_code.d_sub();
              var_combos_vm_code.popf();
              var_combos_vm_code.pop(T_INVALID | T_E32X);
              break;
        }
        
     }/*}}}*/
     break;     
    case UD_Iret:
     {
        var_combos_vm_code.ret();
     }
     break;
    case UD_Iadd:
     {
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));

        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));

        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));

        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_add();
              break;
           case 16:
              var_combos_vm_code.w_add();
              break;
           case 32:
              var_combos_vm_code.d_add();
              break;
        }
        var_combos_vm_code.popf();

        write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }
     break;
    case UD_Isub:
     {/*{{{*/
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));

        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_sub();
              break;
           case 16:
              var_combos_vm_code.w_sub();
              break;
           case 32:
              var_combos_vm_code.d_sub();
              break;
        }
        var_combos_vm_code.popf();

        write_vm_operand(var_combos_vm_code,get_operand1(ud));
        /*
        switch(get_operand1_type(var_ud))
        {
           case UD_OP_MEM:
              vm_operand(var_combos_vm_code,get_operand1(var_ud)); 
              write_mem(get_operand1(var_ud));    
              break;
           case UD_OP_REG:
              var_combos_vm_code.pop(get_vm_register(get_operand1(var_ud).base));
              break;
        }*/
        
     }/*}}}*/
     break;
    case UD_Inot:
     {/*{{{*/
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_not();
              break;
           case 16:
              var_combos_vm_code.w_not();
              break;
           case 32:
              var_combos_vm_code.d_not();
              break;
        }
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
        /*
        switch (get_operand1_type(var_ud))
        {
           case UD_OP_MEM:
              vm_operand(var_combos_vm_code,get_operand1(var_ud));
              write_mem(get_operand1(var_ud));
              break;
           case UD_OP_REG:
              var_combos_vm_code.pop(get_vm_register(get_operand1(var_ud)));
              break;
        } */
        write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }/*}}}*/
     break;
    case UD_Iand:
     {/*{{{*/
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));

        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_and();
              break;
           case 16:
              var_combos_vm_code.w_and();
              break;
           case 32:
              var_combos_vm_code.d_and();
              break;
        }
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
 
        write_vm_operand(var_combos_vm_code,get_operand1(ud)); 
     }/*}}}*/
     break;
    case UD_Ixor:
     {/*{{{*/
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_xor();
              break;
           case 16:
              var_combos_vm_code.w_xor();
              break;
           case 32:
              var_combos_vm_code.d_xor();
              break;
        }
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
 
        write_vm_operand(var_combos_vm_code,get_operand1(ud));  
     }/*}}}*/
     break;
    case UD_Ior:
     {/*{{{*/
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_or();
              break;
           case 16:
              var_combos_vm_code.w_or();
              break;
           case 32:
              var_combos_vm_code.d_or();
              break;
        }
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
 
        write_vm_operand(var_combos_vm_code,get_operand1(ud));   
     }/*}}}*/
     break;
    case UD_Itest:
     {/*{{{*/
        set_imm_operand_size(get_operand2(ud),get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        vm_operand(var_combos_vm_code,get_operand2(ud));
        read_mem(get_operand2(ud));
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.b_and();
              break;
           case 16:
              var_combos_vm_code.w_and();
              break;
           case 32:
              var_combos_vm_code.d_and();
              break;
        }
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
        switch (get_operand1(ud).size)
        {
           case 8:
              var_combos_vm_code.pop(T_INVALID|T_E32X|T_16X|T_8H);
              break;
           case 16:
              var_combos_vm_code.pop(T_INVALID|T_E32X|T_16X);
              break;
           case 32:
              var_combos_vm_code.pop(T_INVALID|T_E32X);
              break;
        }
     }/*}}}*/
     break;
    case UD_Ipop:
     {/*{{{*/
        //vm_operand(var_combos_vm_code,get_operand1(var_ud));
        ud_operand o;
        o.size = 32;
        set_imm_operand_size(get_operand1(ud),o);
        write_vm_operand(var_combos_vm_code,get_operand1(ud));
        //write_mem(get_operand1(var_ud));
        //if (get_operand1_type(var_ud) )
        //var_combos_vm_code.pop
     }/*}}}*/
     break;
    case UD_Iinc:
     {/*{{{*/


        vm_operand(var_combos_vm_code,get_operand1(ud));
        read_mem(get_operand1(ud));
        switch (get_operand1(ud).size)
        {
           case 8: 
              var_combos_vm_code.b_push_imm(1);
              var_combos_vm_code.b_add();
              break;
           case 16:
              var_combos_vm_code.w_push_imm(1);
              var_combos_vm_code.w_add();
              break;
           case 32:
              var_combos_vm_code.d_push_imm(1);
              var_combos_vm_code.d_add();
              break;
        }
        var_combos_vm_code.d_push_imm(~((1 << 0) | (1 << 10)));
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);
              
        var_combos_vm_code.pushf();
        var_combos_vm_code.d_push_imm((1 << 0) | (1 << 10));
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);     
        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);
        //var_combos_vm_code.popf();
        var_combos_vm_code.popf();
        write_vm_operand(var_combos_vm_code,get_operand1(ud));
        /*switch (get_operand1_type(var_ud))
        {
           case UD_OP_REG:
              var_combos_vm_code.pop(get_vm_register(get_operand1(var_ud).base));
              break;
           case UD_OP_MEM:
              vm_operand(var_combos_vm_code,get_operand1(var_ud));
              write_mem(get_operand1(var_ud));
              break;
        }*/
     }/*}}}*/
     break;
    case UD_Idec:
     {/*{{{*/
        //read_mem(get_operand1(var_ud));
        switch (get_operand1(ud).size)
        {
           case 8: 
              var_combos_vm_code.b_push_imm(1);
              read_vm_operand(var_combos_vm_code,get_operand1(ud));
              var_combos_vm_code.b_sub();
              break;
           case 16:
              var_combos_vm_code.w_push_imm(1);
              read_vm_operand(var_combos_vm_code,get_operand1(ud));
              var_combos_vm_code.w_sub();
              break;
           case 32:
              var_combos_vm_code.b_push_imm_zx(1);
              read_vm_operand(var_combos_vm_code,get_operand1(ud));
              var_combos_vm_code.d_sub();
              break;
        }
        var_combos_vm_code.d_push_imm(~((1 << 0) | (1 << 10)));
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);
              
        var_combos_vm_code.pushf();
        var_combos_vm_code.d_push_imm((1 << 0) | (1 << 10));
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);     
        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.popf(); 
        write_vm_operand(var_combos_vm_code,get_operand1(ud));
        /*
        switch (get_operand1_type(var_ud))
        {
           case UD_OP_REG:
              var_combos_vm_code.pop(get_vm_register(get_operand1(var_ud).base));
              break;
           case UD_OP_MEM:
              vm_operand(var_combos_vm_code,get_operand1(var_ud));
              write_mem(get_operand1(var_ud));
              break;
        }  */
     }/*}}}*/
     break;
    case UD_Ishl:
     {
         vm_operand(var_combos_vm_code, get_operand1(ud));
         read_mem(get_operand1(ud));
         vm_operand(var_combos_vm_code, get_operand2(ud));
         read_mem(get_operand2(ud));
         switch (get_operand1(ud).size) {
         case 8:
             var_combos_vm_code.b_shl();
             break;
         case 16:
             var_combos_vm_code.w_shl();
             break;
         case 32:
             var_combos_vm_code.d_shl();
             break;
         default:
             break;
         }
         //var_combos_vm_code.popf();
         var_combos_vm_code.popf();
         write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }
     break;
    case UD_Ishr:
     {
         vm_operand(var_combos_vm_code, get_operand1(ud));
         read_mem(get_operand1(ud));
         vm_operand(var_combos_vm_code, get_operand2(ud));
         read_mem(get_operand2(ud));
         switch (get_operand1(ud).size) {
         case 8:
             var_combos_vm_code.b_shr();
             break;
         case 16:
             var_combos_vm_code.w_shr();
             break;
         case 32:
             var_combos_vm_code.d_shr();
             break;
         default:
             break;
         }
         //var_combos_vm_code.popf();
         var_combos_vm_code.popf();
         write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }
     break;
    case UD_Isar:
     {
       /*
        * sar 10101110,2
        * 最高位 = 1
        * 11111111  sub 0,最高位 -> diff
        * 11111000  shl diff << 右移位数 + 1
        * 11111001  add diff,最高位
        * 00000111  neg diff
        * 11100000  shl diff,目标操作数位数(7) - 右移位数 + 1
        * shr 目标操作数,右移位数
        * add 目标操作数,diff
        */
         var_combos_vm_code.impact_vmregister(false);

         vm_operand(var_combos_vm_code, get_operand1(ud));
         read_mem(get_operand1(ud));
         int dest_reg = var_combos_vm_code.get_tmp_vmregister();
         int highest_bit = var_combos_vm_code.get_tmp_vmregister();
         int count_reg = var_combos_vm_code.get_tmp_vmregister();
         int tmp_cf_reg = var_combos_vm_code.get_tmp_vmregister();
         vm_operand(var_combos_vm_code, get_operand2(ud));
         read_mem(get_operand2(ud));
         switch (get_operand1(ud).size) {
         case 8:
             var_combos_vm_code.pop(count_reg|T_E32X|T_16X|T_8H);//save count
             //and o1,10000000b
             var_combos_vm_code.push_vsp();
             var_combos_vm_code.b_read_mem(); //copy dest
             var_combos_vm_code.pop(dest_reg|T_E32X|T_16X|T_8H); //save dest
             var_combos_vm_code.b_push_imm(1<<7);
             var_combos_vm_code.b_and();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.b_push_imm(7);
             var_combos_vm_code.b_shr();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.push_vsp();
             var_combos_vm_code.b_read_mem();
             var_combos_vm_code.pop(highest_bit|T_E32X|T_16X|T_8H);
             //neg diff
             var_combos_vm_code.b_neg();
             var_combos_vm_code.pop(T_INVALID);
             //add count,1
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(1);
             var_combos_vm_code.b_add();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,count+1
             var_combos_vm_code.b_shl();
             var_combos_vm_code.pop(T_INVALID);
             //add diff,最高位
             var_combos_vm_code.push(highest_bit|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_add();
             var_combos_vm_code.pop(T_INVALID);
             //neg diff
             var_combos_vm_code.b_neg();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,7 - count_reg
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(8-1);
             var_combos_vm_code.b_sub();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.b_shl();
             var_combos_vm_code.pop(T_INVALID);
             //shr dest_reg,count_reg
             var_combos_vm_code.push(dest_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_shr();

             //var_combos_vm_code.pop(T_INVALID);
             //get_cf();
             //var_combos_vm_code.d_push_imm(1);
             var_combos_vm_code.b_push_imm_zx(1);
             var_combos_vm_code.d_and();   //获取shr的cf标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.pop(tmp_cf_reg);

             //or dest_reg,diff
             var_combos_vm_code.b_or();

             var_combos_vm_code.push(tmp_cf_reg);
             var_combos_vm_code.d_or(); //合并shr的cf和or的其他标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.popf(); //设置标志位

             write_vm_operand(var_combos_vm_code,get_operand1(ud));
             break;
         case 16:
             var_combos_vm_code.pop(count_reg|T_E32X|T_16X|T_8H);//save count
             //and o1,10000000b
             var_combos_vm_code.push_vsp();
             var_combos_vm_code.w_read_mem(); //copy dest
             var_combos_vm_code.pop(dest_reg|T_E32X|T_16X); //save dest
             var_combos_vm_code.w_push_imm(1<<15);
             var_combos_vm_code.w_and();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.b_push_imm(15);
             var_combos_vm_code.w_shr();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.push_vsp();
             var_combos_vm_code.w_read_mem();
             var_combos_vm_code.pop(highest_bit|T_E32X|T_16X);
             //neg diff
             var_combos_vm_code.w_neg();
             var_combos_vm_code.pop(T_INVALID);
             //add count,1
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(1);
             var_combos_vm_code.b_add();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,count+1
             var_combos_vm_code.w_shl();
             var_combos_vm_code.pop(T_INVALID);
             //add diff,最高位
             var_combos_vm_code.push(highest_bit|T_E32X|T_16X);
             var_combos_vm_code.w_add();
             var_combos_vm_code.pop(T_INVALID);
             //neg diff
             var_combos_vm_code.w_neg();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,7 - count_reg
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(16-1);
             var_combos_vm_code.b_sub();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.w_shl();
             var_combos_vm_code.pop(T_INVALID);
             //shr dest_reg,count_reg
             var_combos_vm_code.push(dest_reg|T_E32X|T_16X);
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.w_shr();
             //var_combos_vm_code.pop(T_INVALID);
             //get_cf();
             //var_combos_vm_code.d_push_imm(1);
             var_combos_vm_code.b_push_imm_zx(1);
             var_combos_vm_code.d_and();   //获取shr的cf标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.pop(tmp_cf_reg);

             //or dest_reg,diff
             var_combos_vm_code.w_or();

             var_combos_vm_code.push(tmp_cf_reg);
             var_combos_vm_code.d_or(); //合并shr的cf和or的其他标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.popf(); //设置标志位
             write_vm_operand(var_combos_vm_code,get_operand1(ud));
             break;
         case 32:
             var_combos_vm_code.pop(count_reg|T_E32X|T_16X|T_8H);//save count
             //and o1,10000000b
             var_combos_vm_code.push_vsp();
             var_combos_vm_code.d_read_mem(); //copy dest
             var_combos_vm_code.pop(dest_reg|T_E32X); //save dest
             var_combos_vm_code.d_push_imm(1<<31);
             var_combos_vm_code.d_and();
             var_combos_vm_code.pop(T_INVALID);

             //shr o1,31
             var_combos_vm_code.b_push_imm(31);
             var_combos_vm_code.d_shr();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.push_vsp();
             var_combos_vm_code.d_read_mem();
             var_combos_vm_code.pop(highest_bit|T_E32X);
             //neg diff
             var_combos_vm_code.d_neg();
             var_combos_vm_code.pop(T_INVALID);
             //add count,1
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(1);
             var_combos_vm_code.b_add();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,count+1
             var_combos_vm_code.d_shl();
             var_combos_vm_code.pop(T_INVALID);
             //add diff,最高位
             var_combos_vm_code.push(highest_bit|T_E32X);
             var_combos_vm_code.d_add();
             var_combos_vm_code.pop(T_INVALID);
             //neg diff
             var_combos_vm_code.d_neg();
             var_combos_vm_code.pop(T_INVALID);
             //shl diff,7 - count_reg
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.b_push_imm(32-1);
             var_combos_vm_code.b_sub();
             var_combos_vm_code.pop(T_INVALID);

             var_combos_vm_code.d_shl();
             var_combos_vm_code.pop(T_INVALID);
             //shr dest_reg,count_reg
             var_combos_vm_code.push(dest_reg|T_E32X);
             var_combos_vm_code.push(count_reg|T_E32X|T_16X|T_8H);
             var_combos_vm_code.d_shr();
             //var_combos_vm_code.pop(T_INVALID);
             //get_cf();
             //var_combos_vm_code.d_push_imm(1);
             var_combos_vm_code.b_push_imm_zx(1);
             var_combos_vm_code.d_and();   //获取shr的cf标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.pop(tmp_cf_reg);

             //or dest_reg,diff
             var_combos_vm_code.d_or();

             var_combos_vm_code.push(tmp_cf_reg);
             var_combos_vm_code.d_or(); //合并shr的cf和or的其他标志位
             var_combos_vm_code.pop(T_INVALID);
             var_combos_vm_code.popf(); //设置标志位
             write_vm_operand(var_combos_vm_code,get_operand1(ud));

             break;
         default:
             break;
         }
         var_combos_vm_code.unlock_tmp_vmregister(count_reg);
         var_combos_vm_code.unlock_tmp_vmregister(dest_reg);
         var_combos_vm_code.unlock_tmp_vmregister(highest_bit);
         var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Iscasb: //edi - ~df + df
     {
       /*
        *
        * df = 1
        * neg df      ;0xffffffff
        * add edi,df
        * not df      ;0
        * sub edi,df
        *
        * df = 0
        * neg df      ;0
        * add edi,df
        * not df      ;0xffffffff
        * sub edi,df
        *
        */
       var_combos_vm_code.impact_vmregister(false);
       var_combos_vm_code.push(T_EDI);
       //var_combos_vm_code.pushf();
       var_combos_vm_code.b_read_mem();
       var_combos_vm_code.push(T_AL);
       var_combos_vm_code.b_cmp();
       var_combos_vm_code.popf();

       var_combos_vm_code.get_string_ins_diff();
       var_combos_vm_code.b_push_imm(0);
       var_combos_vm_code.d_shl();
       var_combos_vm_code.pop(T_INVALID);

       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);

       /*
       //sub 0,df
       int tmp_vmregister_df = var_combos_vm_code.get_tmp_vmregister();
       var_combos_vm_code.pushf(); //t_edi
       var_combos_vm_code.get_df();
       var_combos_vm_code.d_push_imm(0);
       var_combos_vm_code.d_sub();
       //var_combos_vm_code.int3();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.push_vsp();
       var_combos_vm_code.d_read_mem();
       var_combos_vm_code.pop(tmp_vmregister_df | T_E32X);

       //add edi,df
       int tmp_vmregister_edi = var_combos_vm_code.get_tmp_vmregister();
       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(tmp_vmregister_edi | T_E32X);

       //not df
       //var_combos_vm_code.pushf();
       var_combos_vm_code.push(tmp_vmregister_df | T_E32X);
       //var_combos_vm_code.get_df();
       var_combos_vm_code.d_not();
       var_combos_vm_code.pop(T_INVALID);

       //sub edi,df
       var_combos_vm_code.push(tmp_vmregister_edi | T_E32X);
       var_combos_vm_code.d_sub();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);
       //var_combos_vm_code.int3(); //

       var_combos_vm_code.unlock_tmp_vmregister(tmp_vmregister_edi);
       var_combos_vm_code.unlock_tmp_vmregister(tmp_vmregister_df);
       //var_combos_vm_code.int3(); //sub edi,~df
      */
       var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Iscasw: //edi - ~df + df
     {
       var_combos_vm_code.impact_vmregister(false);
       var_combos_vm_code.push(T_EDI);
       //var_combos_vm_code.pushf();
       var_combos_vm_code.w_read_mem();
       var_combos_vm_code.push(T_AX);
       var_combos_vm_code.w_cmp();
       var_combos_vm_code.popf();

       var_combos_vm_code.get_string_ins_diff();
       var_combos_vm_code.b_push_imm(1);
       var_combos_vm_code.d_shl();
       var_combos_vm_code.pop(T_INVALID);

       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);

       //var_combos_vm_code.int3(); //sub edi,~df
       var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Iscasd: //edi - ~df + df
     {
       var_combos_vm_code.impact_vmregister(false);
       var_combos_vm_code.push(T_EDI);
       //var_combos_vm_code.pushf();
       var_combos_vm_code.d_read_mem();
       var_combos_vm_code.push(T_EAX);
       var_combos_vm_code.d_cmp();
       var_combos_vm_code.popf();


       var_combos_vm_code.get_string_ins_diff();
       var_combos_vm_code.b_push_imm(2);
       var_combos_vm_code.d_shl();
       var_combos_vm_code.pop(T_INVALID);

       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);
       var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Imovsb:
     {
       var_combos_vm_code.impact_vmregister(false);
       var_combos_vm_code.push(T_ESI);
       var_combos_vm_code.b_read_mem();
       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.b_write_mem();

       var_combos_vm_code.get_string_ins_diff();
       var_combos_vm_code.push_vsp();
       var_combos_vm_code.d_read_mem();
       //var_combos_vm_code.b_push_imm(0);
       //var_combos_vm_code.d_shl();
       //var_combos_vm_code.pop(T_INVALID);

       var_combos_vm_code.push(T_ESI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_ESI);

       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);
       var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Imovsd:
     {
       var_combos_vm_code.impact_vmregister(false);
       var_combos_vm_code.push(T_ESI);
       var_combos_vm_code.d_read_mem();
       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_write_mem();

       var_combos_vm_code.get_string_ins_diff();
       var_combos_vm_code.b_push_imm(2);
       var_combos_vm_code.d_shl();
       var_combos_vm_code.pop(T_INVALID);
       //var_combos_vm_code.int3();
       var_combos_vm_code.push_vsp();
       var_combos_vm_code.d_read_mem();


       var_combos_vm_code.push(T_ESI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_ESI);

       var_combos_vm_code.push(T_EDI);
       var_combos_vm_code.d_add();
       var_combos_vm_code.pop(T_INVALID);
       var_combos_vm_code.pop(T_EDI);
       var_combos_vm_code.impact_vmregister(true);
     }
     break;
    case UD_Ijnz: //ZF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.d_push_imm(0x40);
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.b_push_imm(4);
        var_combos_vm_code.d_shr();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);
     }/*}}}*/
     break;
    case UD_Ijz:  //ZF != 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.d_push_imm(0x40);
        var_combos_vm_code.d_and();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.b_push_imm(4);
        var_combos_vm_code.d_shr();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);
     }/*}}}*/
     break;  
    case UD_Ija: //CF = 0 && ZF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_cf();
        var_combos_vm_code.pushf();
        var_combos_vm_code.get_zf();
        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijae:  // CF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_cf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true); 
     }/*}}}*/
     break;
    case UD_Ijb://CF = 1
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        //var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_cf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijbe: //CF = 1 || ZF = 1
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        //var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_cf();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_zf();

        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);   
     }/*}}}*/
     break;
    case UD_Ijcxz:  //CX = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push(T_NEXTINSADDR);

        var_combos_vm_code.push_vsp();
        var_combos_vm_code.w_push_imm(0);
        var_combos_vm_code.push(T_CX);
        var_combos_vm_code.w_cmp();
        var_combos_vm_code.get_zf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijg:  //ZF = 0 && SF = OF
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_zf();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();
        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();
        var_combos_vm_code.d_xor();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true); 
     }/*}}}*/
     break;
    case UD_Ijge: //SF = OF
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();
        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();
        var_combos_vm_code.d_xor();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijl:  // OF != SF
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR); 

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();
        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();
        var_combos_vm_code.d_xor();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);   
     }/*}}}*/
     break;
    case UD_Ijle:  // ZF = 1 || SF != OF
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR); 

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_zf();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();
        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();
        var_combos_vm_code.d_xor();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_or();
        var_combos_vm_code.pop(T_INVALID);

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);    
     }/*}}}*/
     break;
    case UD_Ijno: // OF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true); 
     }/*}}}*/
     break;
    case UD_Ijnp: // PF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_pf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijns: // SF = 0
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijo:  // OF = 1
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        //var_combos_vm_code.push(T_NEXTINSADDR);
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR);

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_of();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);  
     }/*}}}*/
     break;
    case UD_Ijp:  // PF = 1
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR); 

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_pf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);   
     }/*}}}*/
     break;
    case UD_Ijs:  // SF = 1
     {/*{{{*/
        var_combos_vm_code.impact_vmregister(false);
        
        var_combos_vm_code.push(T_JMPINSADDR);
        var_combos_vm_code.push(T_NEXTINSADDR); 

        var_combos_vm_code.push_vsp();

        var_combos_vm_code.pushf();
        var_combos_vm_code.get_sf();

        var_combos_vm_code.d_add();
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.d_read_mem();
        var_combos_vm_code.pop(T_NEXTINSADDR);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.pop(T_INVALID);
        var_combos_vm_code.impact_vmregister(true);   
     }/*}}}*/
     break;
    case UD_Ijmp:
     {

     }
     break;
    case UD_Imovzx:
        {
            for (int i = get_operand2(ud).size; i < get_operand1(ud).size;i+=8)
            {
                var_combos_vm_code.b_push_imm(0);
            }
            read_vm_operand(var_combos_vm_code,get_operand2(ud));
            write_vm_operand(var_combos_vm_code,get_operand1(ud));
        }
        break;
    case UD_If2xm1:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifabs:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifadd:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifaddp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifbld:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifbstp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifchs:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifclex:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovb:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmove:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovbe:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovu:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovnb:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovne:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovnbe:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcmovnu:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifucomi:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcom:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcom2:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcomp3:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcomi:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifucomip:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcomip:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcomp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcomp5:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcompp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifcos:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifdecstp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifdiv:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifdivp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifdivr:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifdivrp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifemms:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Iffree:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Iffreep:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ificom:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ificomp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifild:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifincstp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifninit:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifiadd:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifidivr:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifidiv:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifisub:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifisubr:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifist:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifistp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifisttp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifld:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifld1:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldl2t:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldl2e:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldpi:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldlg2:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldln2:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldz:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldcw:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifldenv:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifmul:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifmulp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifimul:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifnop:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifpatan:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifprem:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifprem1:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifptan:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifrndint:

     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifrstor:

     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifnsave:

     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifscale:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsin:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsincos:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsqrt:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifstp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifstp1:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifstp8:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifstp9:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifst:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifnstcw:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifnstenv:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifnstsw:
     {
       var_combos_vm_code.fstsw();
       write_vm_operand(var_combos_vm_code,get_operand1(ud));
     }
     break;
    case UD_Ifsub:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsubp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsubr:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifsubrp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Iftst:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifucom:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifucomp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifucompp:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxam:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxch:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxch4:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxch7:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxrstor:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxsave:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifxtract:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifyl2x:
     build_fpu(var_combos_vm_code,ud);
     break;
    case UD_Ifyl2xp1:
     build_fpu(var_combos_vm_code,ud);
     break;

   default:
       printf("没有处理%s\n",ud_lookup_mnemonic(ud.mnemonic));
       break;
   }
}


void BuildVMByteCode::full_vmregister_store(std::vector<CodePiece> & var_list_code_piece,
      std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
      std::map<int,RegisterStore> & var_map_label_vmreg_store_out)
{
   size_t var_list_size = var_list_code_piece.size();
   for (size_t i = 0; i < var_list_size; i++)
   {
      set_vmregister_store(var_list_code_piece,
          var_map_label_vmreg_store_in,
          var_map_label_vmreg_store_out,
          (int)i);
   }
}

void BuildVMByteCode::set_vmregister_store(std::vector<CodePiece> & var_list_code_piece,
      std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
      std::map<int,RegisterStore> & var_map_label_vmreg_store_out, 
      int var_cur_label)
{/*{{{*/
    std::vector<CodePiece>::iterator iter = var_list_code_piece.begin();
    bool find_out = false;
    bool find_in = false;
    std::vector<int> var_label_in;
    std::vector<int> var_label_out;
    RegisterStore var_store_in;    
    RegisterStore var_store_out;
    for (iter;iter != var_list_code_piece.end();iter++)
    {
       //查找是否有指令跳转到这里
       if (iter->get_jmplabel() == var_cur_label)
       {
          if (var_map_label_vmreg_store_out.find(iter->get_label()) != var_map_label_vmreg_store_out.end()) 
          {
             if (var_store_in.get_key() != var_map_label_vmreg_store_out[iter->get_label()].get_key())
             {
                _asm int 3;
             }
             var_store_in = var_map_label_vmreg_store_out[iter->get_label()];
             var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(var_cur_label,
                      var_map_label_vmreg_store_out[iter->get_label()]));
             find_in = true;
          }
          else
          {
             //if (iter->get_jmplabel_type() == TYPE_LABEL)
                var_label_out.push_back(iter->get_label());
          }
       }
       //查找上条指令
       if (iter->get_label() + 1 == var_cur_label && iter->get_opcode_attribute() == OPCODE_ATTRIBUTE_NORMAL)//iter->get_jmplabel_type() == TYPE_LABEL)
       {
              if (var_store_in.get_key() != var_map_label_vmreg_store_out[iter->get_label()].get_key())
             {
                _asm int 3;
             }                          
          if (var_map_label_vmreg_store_out.find(iter->get_label()) != var_map_label_vmreg_store_out.end())
          {
             var_store_in = var_map_label_vmreg_store_out[iter->get_label()]; 
             var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(var_cur_label,
                      var_map_label_vmreg_store_out[iter->get_label()]));
             find_in = true;
          } 
          else
          {
              //if (iter->get_jmplabel_type() == TYPE_LABEL) 
                 var_label_out.push_back(iter->get_label());
          }  
       }
       
       if (iter->get_label() == var_cur_label)
       {
               if (var_store_out.get_key() != var_map_label_vmreg_store_in[iter->get_label()].get_key())
             {
                _asm int 3;
             }                 
          if (var_map_label_vmreg_store_in.find(iter->get_jmplabel()) != var_map_label_vmreg_store_in.end())
          {
             
                var_store_out = var_map_label_vmreg_store_in[iter->get_jmplabel()]; 
                var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(var_cur_label,
                         var_store_out));
                find_out = true;
          }
          else{
                //if (iter->get_jmplabel_type() == TYPE_LABEL)
                if (iter->get_opcode_attribute() == OPCODE_ATTRIBUTE_NORMAL)
                   var_label_in.push_back(iter->get_jmplabel());
          }
       }
       //
       if (iter->get_label() - 1 == var_cur_label)
       {
             if (var_store_out.get_key() != var_map_label_vmreg_store_in[iter->get_label()].get_key())
             {
                _asm int 3;
             }                                                            
          if (var_map_label_vmreg_store_in.find(iter->get_label()) != var_map_label_vmreg_store_in.end())
          {
             var_store_out = var_map_label_vmreg_store_in[iter->get_label()];
             var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(var_cur_label,
                      var_map_label_vmreg_store_in[iter->get_label()]));
             find_out = true;
          }
          else
          {
              //pe() == TYPE_LABEL)      
                 var_label_in.push_back(iter->get_label());
          }
       }
    }

    if (find_out == false)
    {
       VCombosVMCode var_t;
       
       var_t.upset_register_array(var_store_out);
       var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(var_cur_label,var_store_out));
    }
    for (std::vector<int>::iterator iter = var_label_out.begin();
          iter != var_label_out.end();iter++)
    {
         var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(*iter,var_store_out));
    }    

    if (find_in == false)
    {
       VCombosVMCode var_t;
       //RegisterStore var_store;
       var_t.upset_register_array(var_store_in);
       var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(var_cur_label,var_store_in)); 
    }
    for (std::vector<int>::iterator iter = var_label_in.begin();
          iter != var_label_in.end();iter++)
    {
         var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(*iter,var_store_in));
    }  
}/*}}}*/

void BuildVMByteCode::set_lastpiece_register_store(
    std::vector<CodePiece> &var_list_code_piece,
    std::map<int,RegisterStore> & var_map_label_vmreg_store)
{
    VCombosVMCode var_t;
    RegisterStore var_store;
    var_t.upset_register_array(var_store);

    std::vector<CodePiece>::iterator iter = var_list_code_piece.begin();
    for (iter;iter != var_list_code_piece.end();iter++)
    {
        bool set_exit = false;

        if (iter->get_opcode_attribute() == OPCODE_ATTRIBUTE_RET ||
                iter->get_opcode_attribute() == OPCODE_ATTRIBUTE_EXIT)
        {
            printf("LastPieceLabel:%d\n",iter->get_label());

              var_map_label_vmreg_store.insert( std::make_pair<int,RegisterStore>(
                          iter->get_label(),
                          var_store));
        }
    }
}

void BuildVMByteCode::full_register_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out
        )   
{
    VCombosVMCode combs;
    RegisterStore regstore;
    combs.upset_register_array(regstore);

    for (int i = 0; i < (int)var_list_code_piece.size(); i++)
    {
        var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(i,regstore));
        var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(i,regstore));
    }
}

void BuildVMByteCode::set_register_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out,
        std::map<int,RegisterStore> & var_map_lastpiece_vmreg_store)  
{
    std::map<int,RegisterStore>::iterator lastpiece_iter = var_map_lastpiece_vmreg_store.begin();
    std::map<int,RegisterStore>::iterator  store_in_iter = var_map_label_vmreg_store_in.begin();
    std::map<int,RegisterStore>::iterator store_out_iter = var_map_label_vmreg_store_out.begin(); 
    
    //printf_map_register_store(var_map_lastpiece_vmreg_store,"var_map_lastpiece_vmreg_store");
    int i = 0;
    // printf("var_map_lastpiece_vmreg_store大小:%d\n",var_map_lastpiece_vmreg_store.size());     

    while (!var_map_lastpiece_vmreg_store.empty())
    {
        printf("第%d次进入循环,var_map_lastpiece_vmreg_store大小:%d\n",i++,var_map_lastpiece_vmreg_store.size());
        std::map<int,RegisterStore>::iterator var_iter_map_t = lastpiece_iter;
        std::vector<CodePiece>::iterator codepiece_iter = var_list_code_piece.begin();

        for (codepiece_iter; codepiece_iter != var_list_code_piece.end(); codepiece_iter++)
        {
            if (lastpiece_iter->first == codepiece_iter->get_jmplabel() || 
                 (lastpiece_iter->first == (codepiece_iter->get_label() + 1 )) //&&
                  //codepiece_iter->get_jmplabel_type() != TYPE_MEM) 
                 ) {
                var_map_label_vmreg_store_out.insert(std::make_pair<int,RegisterStore>(
                            codepiece_iter->get_label(),
                            lastpiece_iter->second
                            ));
                var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(
                            codepiece_iter->get_label() + 1,
                            lastpiece_iter->second
                            ));
                if (var_map_label_vmreg_store_in.find(codepiece_iter->get_label()) !=
                        var_map_label_vmreg_store_in.end())
                {
                  
                   if (codepiece_iter->get_label() != codepiece_iter->get_jmplabel())
                      var_map_lastpiece_vmreg_store.insert(std::make_pair<int,RegisterStore>(
                            codepiece_iter->get_label() + 1,
                            lastpiece_iter->second
                            )); 
               //printf("aaaaaaaaaaaa %s,%x,%x\n" ,var_list_code_piece[codepiece_iter->get_label() + 1 ]
               //                    .get_piece().back().insn_buffer,codepiece_iter->get_label(),codepiece_iter->get_jmplabel());    
                }
                std::map<int,RegisterStore> var_out;
                std::vector<CodePiece> var_t_CodePiece;
                for (std::vector<CodePiece>::iterator iter_t_codepiece = var_list_code_piece.begin();
                        iter_t_codepiece!= var_list_code_piece.end();
                        iter_t_codepiece++)
                {
                    if (var_map_label_vmreg_store_out.find(iter_t_codepiece->get_label()) != 
                            var_map_label_vmreg_store_out.end())
                    {
                        bool b1 =  (var_map_lastpiece_vmreg_store.find(iter_t_codepiece->get_jmplabel()) ==
                                 var_map_lastpiece_vmreg_store.end());
                        bool b2 = (var_map_label_vmreg_store_in.find(iter_t_codepiece->get_jmplabel()) ==
                                 var_map_label_vmreg_store_in.end()); 
                        bool b3 = iter_t_codepiece->get_opcode_attribute() == OPCODE_ATTRIBUTE_NORMAL; //iter_t_codepiece->get_jmplabel_type() == TYPE_LABEL;
                         if (b1 && b2 && b3)
                         {
                             var_map_lastpiece_vmreg_store.insert(std::make_pair<int,RegisterStore>(
                                         iter_t_codepiece->get_jmplabel(),
                                         lastpiece_iter->second 
                                         ));

                             var_map_label_vmreg_store_in.insert(std::make_pair<int,RegisterStore>(
                                         iter_t_codepiece->get_jmplabel(),
                                         lastpiece_iter->second
                                         ));                           
                         }
                    }
                }                                  
            }   
        }
        var_map_lastpiece_vmreg_store.erase(lastpiece_iter);
        lastpiece_iter = var_map_lastpiece_vmreg_store.begin();
    }
}


```

`BuildVMByteCode.hpp`:

```hpp

#ifndef BUILDVMBYTECODE_HPP
#define BUILDVMBYTECODE_HPP

#include "CombosVMCode.hpp"
#include "VMAddressTable.hpp"
#include "VMCodeBuffer.hpp"
#include "Analysis.hpp"
#include <vector>

class BuildVMByteCode {
public:
    enum ProtectType{
        ComplexIns, //Complex Instruction Set Computer
        ReducudIns, //Reduced Instruction Set Computer
                           //超级精简指令没有数字运算
        UntimateReducedIns //Ultimate Reduced Instruction Set Computer
    };

    VirtualMachine * pVM;
    VMAddressTable * ptr_addr_table;
    std::map<ud_type,long> mapped_vm_register;
    int newlabel_count;
    std::map<int,RegisterStore> var_map_label_vmreg_store;
    std::map<int,RegisterStore> var_map_label_vmreg_store_in;  
    std::map<int,RegisterStore> var_map_label_vmreg_store_out;  
    std::map<int,long>  var_map_label_vmkey;          //标签对应的vmkey
    std::map<int,long>  var_map_label_vmcode_addr;    //标签对应的分配的vmcode地址 
    std::map<int,long>  var_map_newlabel_vmcode_addr;
    std::map<int,VMCodeBufferManage *> var_map_label_vmbuffer_manage;
    std::map<int,VMCodeBufferManage *> var_map_newlabel_vmbuffer_manage;
    std::vector<long*> var_entry_address;
    std::vector<CodePiece> var_list_code_piece;  
    std::vector<VMCodeBufferManage *> var_vmcode_manager_list; 

    BuildVMByteCode(VirtualMachine *vm,
        pCodeBufferInfo ptr_info,
        VMAddressTable *ptr_address_table);

    ~BuildVMByteCode();

    long get_newvm_cur_label();
    VMCodeBufferManage * get_newvm_piece();
    VMCodeBufferManage * create_newvm_piece();
    
    void build_pfx(VCombosVMCode & var_combos_vm_code,ud_t &var_ud,CodePiece &var_cur_piece,bool b_allocator);
    void build_fpu(VCombosVMCode & var_combos_vm_code,ud_t &var_ud);
    void build(VCombosVMCode & var_combos_vm_code,ud_t & var_ud);
    long build_vmcode(bool b_allocator);

    long create_vm_entry(int _label);
    long get_vmcode_address(int _label_index);

    void set_lastpiece_register_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store);
    void set_register_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out,
        std::map<int,RegisterStore> & var_map_lastpiece_vmreg_store);   
    void full_register_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out);    
    void set_vmregister_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out,
        int var_cur_label); 
    void full_vmregister_store(std::vector<CodePiece> &var_list_code_piece,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_in,
        std::map<int,RegisterStore> & var_map_label_vmreg_store_out);

    void vm_operand(VCombosVMCode & var_combos_vm_code,ud_operand & var_operand);
    void write_vm_operand(VCombosVMCode & var_combos_vm_code,ud_operand & var_operand); 
    void read_vm_operand(VCombosVMCode & var_combos_vm_code,ud_operand & var_operand);

    void copy_exec_code_to_stack(VCombosVMCode & var_combos_vm_code,
        const uint8_t * var_code_buffer,
        size_t var_code_size);

    void register_mapped_init();

    long get_vm_register(ud_type _register);
};

#endif /* BUILDVMBYTECODE_HPP */

```

`CombosVMCode.cpp`:

```cpp
/************************************************************
 *                                                         *
 *                                                        *
 *                2015年7月31日                          *
 *                             By:XiaoWei               *
 *                                                     *
 *                                                    *
 *****************************************************/

#include "CombosVMCode.hpp"
#include "algorithms.hpp"
#pragma warning(disable:4309)

#define get_handle(x) ptr_pcode->pcode_info.handle_table.x.handle_i
#define build_vm_mnemonic(x) build_byte_code(x) 

VCombosVMCode::VCombosVMCode()
    :super_protect(false),ptr_pcode(NULL),change_vmregister_flag(true)
{
    memset(&tmp_vmregister_status,false,sizeof(tmp_vmregister_status)); 
}

VCombosVMCode::VCombosVMCode(PCode * p)
    :super_protect(false),ptr_pcode(p),change_vmregister_flag(true)
{
    memset(&tmp_vmregister_status, false, sizeof(tmp_vmregister_status));  
}

VCombosVMCode::~VCombosVMCode()
{
    
}

void VCombosVMCode::set_vmregister_store_in(RegisterStore & store_in)
{
    ptr_pcode->register_store_in = store_in;
}

void VCombosVMCode::set_vmregister_store_out(RegisterStore & store_out)
{
    ptr_pcode->register_store_out = store_out;
}

void *VCombosVMCode::get_code_buf()
{
  if ( ptr_pcode->pcode_info.sign == false)
     return &ptr_pcode->pcode_info.buf
    [ptr_pcode->pcode_info.size - ptr_pcode->pcode_info.offset];
  else
    return ptr_pcode->pcode_info.buf; 
}

long VCombosVMCode::get_code_size()
{
 return (long)ptr_pcode->get_code_size();    
}

#define push_esp push_stack_top_base                         
                                                             



void VCombosVMCode::save_vm_context()
{
    int register_count = ptr_pcode->register_store_in.register_count;
    printf("register_count : %d\n", register_count);

    for (int i = register_count; i > 0; --i)
    {
        pop(ptr_pcode->register_store_in.register_array[i-1]);
    }
}

void VCombosVMCode::recover_vm_context()
{
  int register_count = ptr_pcode->register_store_out.register_count;

  for (int i = 0; i < register_count; ++i)
  {
    if (ptr_pcode->register_store_out.register_array[ i ] ==  T_NAX ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NBX ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NCX ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NDX ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NSP ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NBP ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NSI ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NDI ||
#ifdef PROTECT_X64
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NAX | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NBX | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NCX | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NDX | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NSP | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NBP | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NSI | T_RN ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_NDI | T_RN ||
#endif
        ptr_pcode->register_store_out.register_array[ i ] ==  T_RET ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_KEY ||
        ptr_pcode->register_store_out.register_array[ i ] ==  T_EFLAG)
        push( ptr_pcode->register_store_out.register_array[ i ] );
  }    
}

void VCombosVMCode::upset_register_array(RegisterStore & r )
{
  int register_count = 0;
  
  r.register_array[ register_count++ ] = T_NAX;
  r.register_array[ register_count++ ] = T_NBX;
  r.register_array[ register_count++ ] = T_NCX;
  r.register_array[ register_count++ ] = T_NDX;
  r.register_array[ register_count++ ] = T_NBP;
  r.register_array[ register_count++ ] = T_NSI;
  r.register_array[ register_count++ ] = T_NDI;
  r.register_array[ register_count++ ] = T_EFLAG;
  r.register_array[ register_count++ ] = T_KEY;
#ifdef PROTECT_X64
  r.register_array[ register_count++ ] = T_R8;
  r.register_array[ register_count++ ] = T_R9;
  r.register_array[ register_count++ ] = T_R10;
  r.register_array[ register_count++ ] = T_R11;
  r.register_array[ register_count++ ] = T_R12;
  r.register_array[ register_count++ ] = T_R13;
  r.register_array[ register_count++ ] = T_R14;
  r.register_array[ register_count++ ] = T_R15;
#endif
  r.register_count = register_count;

  RandList<long>( r.register_array, register_count);
} 

void VCombosVMCode::run_stack()
{
    build_vm_mnemonic(get_handle(run_stack));
}

void VCombosVMCode::push_vsp()  //vm_stack_point 虚拟机堆栈指针
{
    build_vm_mnemonic(get_handle(push_stack_top_base));
} 

void VCombosVMCode::pop_vsp()
{
    build_vm_mnemonic(get_handle(pop_stack_top_base));
}

void VCombosVMCode::pushf()
{
    push(T_FLAG);
}

void VCombosVMCode::popf()
{
    pop(T_FLAG);
}

void VCombosVMCode::push(long _register,bool _disable)
{
  ptr_pcode->v_push_register(_register,_disable);
}

void VCombosVMCode::push(long _register)
{
  ptr_pcode->v_push_register(_register,change_vmregister_flag); 
}

void VCombosVMCode::pop(long _register)
{
    ptr_pcode->v_pop_register(_register);
}

void VCombosVMCode::b_push_imm(char b)
{
    build_vm_mnemonic(get_handle(b_push_imm));
    build_byte_code(b);
}

void VCombosVMCode::w_push_imm(short w)
{
    build_vm_mnemonic(get_handle(w_push_imm));
    build_word_code(w);
}

void VCombosVMCode::d_push_imm(int d)
{
    build_vm_mnemonic(get_handle(d_push_imm));
    build_dword_code(d);
}

#ifdef PROTECT_X64
void VCombosVMCode::q_push_imm(long q)
{
    build_vm_mnemonic(get_handle(q_push_imm));
    build_qword_code(q);
}
#endif
    
void VCombosVMCode::b_push_imm_sx(char b)
{
    build_vm_mnemonic(get_handle(b_push_imm_sx));
    build_byte_code(b);
}

void VCombosVMCode::w_push_imm_sx(short w)
{
    build_vm_mnemonic(get_handle(w_push_imm_sx));
    build_word_code(w);
}

#ifdef PROTECT_X64
void VCombosVMCode::d_push_imm_sx(int d)
{
    build_vm_mnemonic(get_handle(d_push_imm_sx));
    build_dword_code(d);
}
#endif
 
void VCombosVMCode::b_push_imm_zx(char b)
{
    build_vm_mnemonic(get_handle(b_push_imm_zx));
    build_byte_code(b);
}

void VCombosVMCode::w_push_imm_zx(short w)
{
    build_vm_mnemonic(get_handle(w_push_imm_zx));
    build_word_code(w);
}

#ifdef PROTECT_X64
void VCombosVMCode::d_push_imm_zx(int d)
{
    build_vm_mnemonic(get_handle(d_push_imm_zx));
    build_dword_code(d);
}
#endif

void VCombosVMCode::b_nand()
{
    build_vm_mnemonic(get_handle(b_nand));
}

void VCombosVMCode::w_nand()
{
    build_vm_mnemonic(get_handle(w_nand));
}

void VCombosVMCode::d_nand()
{
    build_vm_mnemonic(get_handle(d_nand));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_nand()
{
    build_vm_mnemonic(get_handle(q_nand));
}
#endif

void VCombosVMCode::b_not()
{
    build_vm_mnemonic(get_handle(push_stack_top_base));
    build_vm_mnemonic(get_handle(b_read_mem));
    build_vm_mnemonic(get_handle(b_nand));
}

void VCombosVMCode::w_not()
{
    build_vm_mnemonic(get_handle(push_stack_top_base));
    build_vm_mnemonic(get_handle(w_read_mem));
    build_vm_mnemonic(get_handle(w_nand));
}

void VCombosVMCode::d_not()
{
    build_vm_mnemonic(get_handle(push_stack_top_base));
    build_vm_mnemonic(get_handle(d_read_mem));
    build_vm_mnemonic(get_handle(d_nand));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_not()
{
    build_vm_mnemonic(get_handle(push_stack_top_base));
    build_vm_mnemonic(get_handle(q_read_mem));
    build_vm_mnemonic(get_handle(q_nand));
} 
#endif 

void VCombosVMCode::b_neg()
{
    b_push_imm(0);
    b_sub();
    //pop(T_INVALID)
}

void VCombosVMCode::w_neg()
{
    w_push_imm(0);
    w_sub();
}

void VCombosVMCode::d_neg()
{
    d_push_imm(0);
    d_sub();
}

void VCombosVMCode::b_add()
{
   build_vm_mnemonic(get_handle(b_add));
}                                       
void VCombosVMCode::w_add()
{
   build_vm_mnemonic(get_handle(w_add));
}                                        
void VCombosVMCode::d_add()
{
   build_vm_mnemonic(get_handle(d_add));
}                                         
#ifdef PROTECT_X64
void VCombosVMCode::q_add()
{
   build_vm_mnemonic(get_handle(q_add));
}      
#endif

void VCombosVMCode::b_read_mem()
{
    build_vm_mnemonic(get_handle(b_read_mem));
}

void VCombosVMCode::w_read_mem()
{
    build_vm_mnemonic(get_handle(w_read_mem));
}

void VCombosVMCode::d_read_mem()
{
    build_vm_mnemonic(get_handle(d_read_mem));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_read_mem()
{
    build_vm_mnemonic(get_handle(q_read_mem));
}
#endif

 void VCombosVMCode::b_write_mem()
{
    build_vm_mnemonic(get_handle(b_write_mem));
}

void VCombosVMCode::w_write_mem()
{
    build_vm_mnemonic(get_handle(w_write_mem));
}

void VCombosVMCode::d_write_mem()
{
    build_vm_mnemonic(get_handle(d_write_mem));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_write_mem()
{
    build_vm_mnemonic(get_handle(q_write_mem));
}
#endif 

void VCombosVMCode::build_byte_code(unsigned char b)
{
    ptr_pcode->db( b );
}

void VCombosVMCode::build_word_code(unsigned short w)
{
    ptr_pcode->dw( w );
}

void VCombosVMCode::build_dword_code(unsigned int d)
{
    ptr_pcode->dd( d );
}

#ifdef PROTECT_X64
void VCombosVMCode::build_qword_code(unsigned long q)
{
    ptr_pcode->dq( q );
}
#endif


void VCombosVMCode::set_pc(long _key)
{
#ifndef PROTECT_X64
    d_push_imm(_key);
#else
    q_push_imm(_key);
#endif
    build_vm_mnemonic(get_handle(set_key));
}


void VCombosVMCode::set_pc()
{
    build_vm_mnemonic(get_handle(set_pc));
}


void VCombosVMCode::b_shl()
{
    build_vm_mnemonic(get_handle(b_shl));
}

void VCombosVMCode::w_shl()
{
    build_vm_mnemonic(get_handle(w_shl));
}

void VCombosVMCode::d_shl()
{
    build_vm_mnemonic(get_handle(d_shl));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_shl()
{
    build_vm_mnemonic(get_handle(q_shl));
}
#endif

 
void VCombosVMCode::b_shr()
{
    build_vm_mnemonic(get_handle(b_shr));
}

void VCombosVMCode::w_shr()
{
    build_vm_mnemonic(get_handle(w_shr));
}

void VCombosVMCode::d_shr()
{
    build_vm_mnemonic(get_handle(d_shr));
}

#ifdef PROTECT_X64
void VCombosVMCode::q_shr()
{
    build_vm_mnemonic(get_handle(q_shr));
}
#endif                      
                        

void VCombosVMCode::ret()
{
  pushf();
  push(T_NAX);
  push(T_NCX);
  push(T_NDX);
  push(T_NBX);
  //
  push(T_NBP);
  push(T_NSI);
  push(T_NDI);
#ifdef PROTECT_X64
  push(T_R8);
  push(T_R9);
  push(T_R10);
  push(T_R11);
  push(T_R12);
  push(T_R13);
  push(T_R14);
  push(T_R15);  
#endif    
 build_vm_mnemonic(get_handle(ret));
}


/////////////////////Combos/////////////////
void VCombosVMCode::b_and()
{
    int tmp_register = get_tmp_vmregister();
    pop(tmp_register | T_E32X | T_16X | T_8L);

    push_vsp();
    b_read_mem();
    b_nand();
    pop(T_INVALID);
    
    push(tmp_register | T_E32X | T_16X | T_8L);
    push_vsp();
    b_read_mem();
    b_nand();
    pop(T_INVALID);

    b_nand();
    unlock_tmp_vmregister(tmp_register);
}

void VCombosVMCode::w_and()
{
    int tmp_register = get_tmp_vmregister();
    pop(tmp_register | T_E32X | T_16X);

    push_vsp();
    w_read_mem();
    w_nand();
    pop(T_INVALID);
    
    push(tmp_register | T_E32X | T_16X);
    push_vsp();
    w_read_mem();
    w_nand();
    pop(T_INVALID);

    w_nand();
    unlock_tmp_vmregister(tmp_register);  
}

void VCombosVMCode::d_and()
{
    int tmp_register = get_tmp_vmregister();
    pop(tmp_register | T_E32X);

    push_vsp();
    d_read_mem();
    d_nand();
    pop(T_INVALID);
    
    push(tmp_register | T_E32X);
    push_vsp();
    d_read_mem();
    d_nand();
    pop(T_INVALID);

    d_nand();
    unlock_tmp_vmregister(tmp_register); 
}

#ifdef PROTECT_X64
void VCombosVMCode::q_and()
{
    int tmp_register = get_tmp_vmregister();
    pop(tmp_register);

    push_vsp();
    q_read_mem();
    q_nand();
    pop(T_INVALID);
    
    push(tmp_register);
    push_vsp();
    q_read_mem();
    q_nand();
    pop(T_INVALID);

    q_nand();
    unlock_tmp_vmregister(tmp_register); 
}
#endif

void VCombosVMCode::b_or()
{
 int tmp_vmregister  = get_tmp_vmregister();
 push_vsp();
 w_read_mem();
 b_nand();
 pop(T_INVALID);
 pop(tmp_vmregister | T_E32X | T_16X | T_8L);
 b_nand();
 pop(T_INVALID);
 push(tmp_vmregister | T_E32X | T_16X | T_8L);
 b_nand();
 unlock_tmp_vmregister(tmp_vmregister);
}

void VCombosVMCode::w_or()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1 | T_E32X | T_16X);
 pop(tmp_vmregister2 | T_E32X | T_16X);
 impact_vmregister(false);
 push(tmp_vmregister1 | T_E32X | T_16X);
 push(tmp_vmregister2 | T_E32X | T_16X);
 w_nand();
 pop(T_INVALID);
 impact_vmregister(true);  
 push(tmp_vmregister1 | T_E32X | T_16X);
 push(tmp_vmregister2 | T_E32X | T_16X);
 w_nand();
 pop(T_INVALID);                
 w_nand();

 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
}
 
void VCombosVMCode::d_or()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1 | T_E32X);
 pop(tmp_vmregister2 | T_E32X);
 impact_vmregister(false);
 push(tmp_vmregister1 | T_E32X);
 push(tmp_vmregister2 | T_E32X);
 d_nand();
 pop(T_INVALID);
 impact_vmregister(true);    
 push(tmp_vmregister1 | T_E32X);
 push(tmp_vmregister2 | T_E32X);
 d_nand();
 pop(T_INVALID);                
 d_nand();

 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
}
  
#ifdef PROTECT_X64
void VCombosVMCode::q_or()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1 );
 pop(tmp_vmregister2 );
 impact_vmregister(false);
 push(tmp_vmregister1 );
 push(tmp_vmregister2 );
 q_nand();
 pop(T_INVALID);
 impact_vmregister(true);    
 push(tmp_vmregister1 );
 push(tmp_vmregister2 );
 q_nand();
 pop(T_INVALID);                
 q_nand();

 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
} 
#endif


void VCombosVMCode::b_xor()
{
 int tmp_vmregister = get_tmp_vmregister();
 push_vsp();
 w_read_mem();
 b_nand();
 pop(T_INVALID);
 pop(tmp_vmregister | T_E32X | T_16X | T_8L);
 b_and();
 pop(T_INVALID);
 push(tmp_vmregister | T_E32X | T_16X | T_8L);
 b_nand();
 unlock_tmp_vmregister(tmp_vmregister);
}

void VCombosVMCode::w_xor()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1 | T_E32X | T_16X);
 pop(tmp_vmregister2 | T_E32X | T_16X);
 impact_vmregister(false);
 push(tmp_vmregister1 | T_E32X | T_16X);
 push(tmp_vmregister2 | T_E32X | T_16X);
 w_nand();
 pop(T_INVALID);
 impact_vmregister(true);
 push(tmp_vmregister1 | T_E32X | T_16X);
 push(tmp_vmregister2 | T_E32X | T_16X);
 w_and();
 pop(T_INVALID);
 w_nand();
 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
}

void VCombosVMCode::d_xor()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1 | T_E32X);
 pop(tmp_vmregister2 | T_E32X);
 impact_vmregister(false);
 push(tmp_vmregister1 | T_E32X);
 push(tmp_vmregister2 | T_E32X);
 d_nand();
 pop(T_INVALID);
 impact_vmregister(true);
 push(tmp_vmregister1 | T_E32X);
 push(tmp_vmregister2 | T_E32X);
 d_and();
 pop(T_INVALID);
 d_nand();
 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
}

#ifdef PROTECT_X64
void VCombosVMCode::q_xor()
{
 int tmp_vmregister1 = get_tmp_vmregister();
 int tmp_vmregister2 = get_tmp_vmregister();
 pop(tmp_vmregister1);
 pop(tmp_vmregister2);
 impact_vmregister(false);
 push(tmp_vmregister1);
 push(tmp_vmregister2);
 q_nand();
 pop(T_INVALID);
 impact_vmregister(true);
 push(tmp_vmregister1);
 push(tmp_vmregister2);
 q_and();
 pop(T_INVALID);
 q_nand();
 unlock_tmp_vmregister(tmp_vmregister1);
 unlock_tmp_vmregister(tmp_vmregister2);
}  
#endif

void VCombosVMCode::b_sub()
{
#ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","b_sub");
#endif

 int tmp_flag1 = get_tmp_vmregister();
 int tmp_flag2 = get_tmp_vmregister();
 b_not();
 pop(T_INVALID);
 //pop(tmp_vmregister1 | T_E32X);
 b_add();
 pop(tmp_flag1 | T_E32X); 
 push_vsp();
 b_read_mem();
 b_nand();
 pop(tmp_flag2 | T_E32X);
 push(tmp_flag1 | T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0xf7ea);
 d_nand();
 pop(T_INVALID);
 //pop(tmp_flag1);
 
 //pop(tmp_vmregister1 | T_E32X);
 push(tmp_flag2 | T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0x815);
 d_nand();
 pop(T_INVALID);
 d_add();
 pop(T_INVALID);
 unlock_tmp_vmregister(tmp_flag1);
 unlock_tmp_vmregister(tmp_flag2);        
}

void VCombosVMCode::w_sub()
{
#ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","w_sub");
#endif

 int tmp_flag1 = get_tmp_vmregister();
 int tmp_flag2 = get_tmp_vmregister();
 w_not();
 pop(T_INVALID);
 //pop(tmp_vmregister1 | T_E32X);
 w_add();
 pop(tmp_flag1 | T_E32X); 
 push_vsp();
 w_read_mem();
 w_nand();
 pop(tmp_flag2 | T_E32X);
 push(tmp_flag1 | T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0xf7ea);
 d_nand();
 pop(T_INVALID);
 //pop(tmp_flag1);
 
 //pop(tmp_vmregister1 | T_E32X);
 push(tmp_flag2|T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0x815);
 d_nand();
 pop(T_INVALID);
 d_add();
 pop(T_INVALID);
 unlock_tmp_vmregister(tmp_flag1);
 unlock_tmp_vmregister(tmp_flag2);     
}

void VCombosVMCode::d_sub() //[stacktop] - [stacktop-4]
{
 #ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","d_sub");
#endif

 int tmp_flag1 = get_tmp_vmregister();
 int tmp_flag2 = get_tmp_vmregister();
 d_not();
 pop(T_INVALID);
 //pop(tmp_vmregister1 | T_E32X);
 d_add();
 pop(tmp_flag1 | T_E32X); 
 push_vsp();
 d_read_mem();
 d_nand();
 pop(tmp_flag2 | T_E32X);
 push(tmp_flag1 | T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0xf7ea);
 d_nand();
 pop(T_INVALID);
 //pop(tmp_flag1);
 
 //pop(tmp_vmregister1 | T_E32X);
 push(tmp_flag2 | T_E32X);
 d_not();
 pop(T_INVALID);
 w_push_imm_sx(0x815);
 d_nand();
 pop(T_INVALID);
 d_add();
 pop(T_INVALID);
 unlock_tmp_vmregister(tmp_flag1);
 unlock_tmp_vmregister(tmp_flag2);
}

void VCombosVMCode::q_sub()
{
    
}

void VCombosVMCode::b_cmp()
{
#ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","b_cmp");
#endif

   int tmp_vmregister = get_tmp_vmregister();
   b_sub();
   pop(tmp_vmregister);
   pop(T_INVALID | T_E32X | T_16X | T_8L);
   push(tmp_vmregister);
   unlock_tmp_vmregister(tmp_vmregister);
}

void VCombosVMCode::w_cmp()
{
#ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","w_cmp");
#endif
   int tmp_vmregister = get_tmp_vmregister();
   w_sub();
   pop(tmp_vmregister);
   pop(T_INVALID | T_E32X | T_16X );
   push(tmp_vmregister);
   unlock_tmp_vmregister(tmp_vmregister); 
}

void VCombosVMCode::d_cmp()
{
#ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","d_cmp");
#endif
   int tmp_vmregister = get_tmp_vmregister();
   d_sub();
   pop(tmp_vmregister);
   pop(T_INVALID | T_E32X);
   push(tmp_vmregister);
   unlock_tmp_vmregister(tmp_vmregister);       
}

void VCombosVMCode::b_test()
{
    int tmp_vmregister = get_tmp_vmregister();
    b_and();
    pop(tmp_vmregister);
    pop(T_INVALID|T_E32X|T_16X|T_8H);
    push(tmp_vmregister);
    unlock_tmp_vmregister(tmp_vmregister);
}

void VCombosVMCode::w_test()
{
    int tmp_vmregister = get_tmp_vmregister();
    w_and();
    pop(tmp_vmregister);
    pop(T_INVALID|T_E32X|T_16X);
    push(tmp_vmregister);
    unlock_tmp_vmregister(tmp_vmregister);
}

void VCombosVMCode::d_test()
{
    int tmp_vmregister = get_tmp_vmregister();
    d_and();
    pop(tmp_vmregister);
    pop(T_INVALID|T_E32X);
    push(tmp_vmregister);
    unlock_tmp_vmregister(tmp_vmregister);
}


void VCombosVMCode::get_cf()
{
#ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_cf");
#endif
 //d_push_imm(1 << 0);
 b_push_imm_zx(1);
 d_and();
 pop(T_INVALID);  
 b_push_imm(2);   //不是0就是4
 d_shl();
 pop(T_INVALID);
}

void VCombosVMCode::get_pf()
{
#ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_pf");
#endif
 b_push_imm_zx(1 << 2);
 d_and();
 pop(T_INVALID);  
 //b_push_imm(2);   //不是0就是4
 //d_shl();
 //pop(T_INVALID); 
}

void VCombosVMCode::get_af()
{
    #ifdef _DEBUG
  // fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_af");
#endif

 b_push_imm_zx(1 << 4);
 d_and();
 pop(T_INVALID);  
 b_push_imm(2);   //不是0就是4
 d_shr();
 pop(T_INVALID);  
}

void VCombosVMCode::get_zf()
{
    #ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_zf");
#endif

 b_push_imm_zx(1 << 6);
 d_and();
 pop(T_INVALID);  
 b_push_imm(4);   //不是0就是4
 d_shr();
 pop(T_INVALID);  
}

void VCombosVMCode::get_sf()
{
    #ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_sf");
#endif

 b_push_imm_zx(1 << 7);
 d_and();
 pop(T_INVALID);  
 b_push_imm(5);   //不是0就是4
 d_shr();
 pop(T_INVALID);  
}

void VCombosVMCode::get_of()
{
    #ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_of");
#endif

 d_push_imm(1 << 11);
 d_and();
 pop(T_INVALID);  
 b_push_imm(9);   //不是0就是4
 d_shr();
 pop(T_INVALID);  
}

void VCombosVMCode::get_df()
{
#ifdef _DEBUG
   //fprintf(ptr_pcode->get_log(),"\nVCombosHandle:%s()\n","get_df");
#endif

 d_push_imm(1 << 10);
 d_and();
 pop(T_INVALID);  
 b_push_imm(10);   //不是0就是1
 d_shr();
 pop(T_INVALID); 
}

#ifdef _DEBUG
void VCombosVMCode::int3()
{
    build_vm_mnemonic(get_handle(int3));
}
#endif

void VCombosVMCode::fstsw()
{
    build_vm_mnemonic(get_handle(fstsw));
}

//输入：无  返回一个串指令根据df进行加减的数值和地址对其  ret 1 or -1
void VCombosVMCode::get_string_ins_diff()
{
        /*
        *
        * df = 1
        * neg df      ;0xffffffff
        * add edi,df
        * not df      ;0
        * sub edi,df
        *
        * df = 0
        * neg df      ;0
        * add edi,df
        * not df      ;0xffffffff
        * sub edi,df
        *
        */
       int tmp_vmregister_diff = get_tmp_vmregister();
       int tmp_vmregister_df = get_tmp_vmregister();

       impact_vmregister(false);
       //d_push_imm(0x0);

       //neg df    sub 0,df
       push(T_FLAG); //t_edi
       get_df();
       d_push_imm(0);
       d_sub();
       pop(T_INVALID);
       push_vsp();
       d_read_mem();
       pop(tmp_vmregister_df | T_E32X);

       //add edi,df
       d_push_imm(0);
       d_add();
       pop(T_INVALID);
       pop(tmp_vmregister_diff | T_E32X);

       //not df
       push(tmp_vmregister_df | T_E32X);
       d_not();
       pop(T_INVALID);

       //sub edi,df
       push(tmp_vmregister_diff | T_E32X);
       d_sub();
       pop(T_INVALID);

       unlock_tmp_vmregister(tmp_vmregister_diff);
       unlock_tmp_vmregister(tmp_vmregister_df);

       impact_vmregister(true);

}

```

`Libudis86/decode.c`:

```c
/* udis86 - libudis86/decode.c
 * 
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "udint.h"
#include "types.h"
#include "decode.h"

#ifndef __UD_STANDALONE__
# include <string.h>
#endif /* __UD_STANDALONE__ */

/* The max number of prefixes to an instruction */
#define MAX_PREFIXES    15

/* rex prefix bits */
#define REX_W(r)        ( ( 0xF & ( r ) )  >> 3 )
#define REX_R(r)        ( ( 0x7 & ( r ) )  >> 2 )
#define REX_X(r)        ( ( 0x3 & ( r ) )  >> 1 )
#define REX_B(r)        ( ( 0x1 & ( r ) )  >> 0 )
#define REX_PFX_MASK(n) ( ( P_REXW(n) << 3 ) | \
                          ( P_REXR(n) << 2 ) | \
                          ( P_REXX(n) << 1 ) | \
                          ( P_REXB(n) << 0 ) )

/* scable-index-base bits */
#define SIB_S(b)        ( ( b ) >> 6 )
#define SIB_I(b)        ( ( ( b ) >> 3 ) & 7 )
#define SIB_B(b)        ( ( b ) & 7 )

/* modrm bits */
#define MODRM_REG(b)    ( ( ( b ) >> 3 ) & 7 )
#define MODRM_NNN(b)    ( ( ( b ) >> 3 ) & 7 )
#define MODRM_MOD(b)    ( ( ( b ) >> 6 ) & 3 )
#define MODRM_RM(b)     ( ( b ) & 7 )

static int decode_ext(struct ud *u, uint16_t ptr);

enum reg_class { /* register classes */
  REGCLASS_GPR,
  REGCLASS_MMX,
  REGCLASS_CR,
  REGCLASS_DB,
  REGCLASS_SEG,
  REGCLASS_XMM
};

 /* 
 * inp_start
 *    Should be called before each de-code operation.
 */
static void
inp_start(struct ud *u)
{
  u->inp_ctr = 0;
}

   
static uint8_t
inp_next(struct ud *u)
{
  if (u->inp_end == 0) {
    if (u->inp_buf != NULL) {
      if (u->inp_buf_index < u->inp_buf_size) {
        u->inp_ctr++;
        return (u->inp_curr = u->inp_buf[u->inp_buf_index++]);
      }
    } else {
      int c;
      if ((c = u->inp_hook(u)) != UD_EOI) {
        u->inp_curr = c;
        u->inp_sess[u->inp_ctr++] = u->inp_curr;
        return u->inp_curr;
      }
    }
  }
  u->inp_end = 1;
  UDERR(u, "byte expected, eoi received\n");
  return 0;
}

static uint8_t
inp_curr(struct ud *u)
{
  return u->inp_curr;
}


/*
 * inp_uint8
 * int_uint16
 * int_uint32
 * int_uint64
 *    Load little-endian values from input
 */
static uint8_t 
inp_uint8(struct ud* u)
{
  return inp_next(u);
}

static uint16_t 
inp_uint16(struct ud* u)
{
  uint16_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  return ret | (r << 8);
}

static uint32_t 
inp_uint32(struct ud* u)
{
  uint32_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  ret = ret | (r << 8);
  r = inp_next(u);
  ret = ret | (r << 16);
  r = inp_next(u);
  return ret | (r << 24);
}

static uint64_t 
inp_uint64(struct ud* u)
{
  uint64_t r, ret;

  ret = inp_next(u);
  r = inp_next(u);
  ret = ret | (r << 8);
  r = inp_next(u);
  ret = ret | (r << 16);
  r = inp_next(u);
  ret = ret | (r << 24);
  r = inp_next(u);
  ret = ret | (r << 32);
  r = inp_next(u);
  ret = ret | (r << 40);
  r = inp_next(u);
  ret = ret | (r << 48);
  r = inp_next(u);
  return ret | (r << 56);
}


static inline int
eff_opr_mode(int dis_mode, int rex_w, int pfx_opr)
{
  if (dis_mode == 64) {
    return rex_w ? 64 : (pfx_opr ? 16 : 32);
  } else if (dis_mode == 32) {
    return pfx_opr ? 16 : 32;
  } else {
    UD_ASSERT(dis_mode == 16);
    return pfx_opr ? 32 : 16;
  }
}


static inline int
eff_adr_mode(int dis_mode, int pfx_adr)
{
  if (dis_mode == 64) {
    return pfx_adr ? 32 : 64;
  } else if (dis_mode == 32) {
    return pfx_adr ? 16 : 32;
  } else {
    UD_ASSERT(dis_mode == 16);
    return pfx_adr ? 32 : 16;
  }
}


/* 
 * decode_prefixes
 *
 *  Extracts instruction prefixes.
 */
static int 
decode_prefixes(struct ud *u)
{
  int done = 0;
  uint8_t curr = 0, last = 0;
  UD_RETURN_ON_ERROR(u);

  do {
    last = curr;
    curr = inp_next(u); 
    UD_RETURN_ON_ERROR(u);
    if (u->inp_ctr == MAX_INSN_LENGTH) {
      UD_RETURN_WITH_ERROR(u, "max instruction length");
    }
   
    switch (curr)  
    {
    case 0x2E: 
      u->pfx_seg = UD_R_CS; 
      break;
    case 0x36:     
      u->pfx_seg = UD_R_SS; 
      break;
    case 0x3E: 
      u->pfx_seg = UD_R_DS; 
      break;
    case 0x26: 
      u->pfx_seg = UD_R_ES; 
      break;
    case 0x64: 
      u->pfx_seg = UD_R_FS; 
      break;
    case 0x65: 
      u->pfx_seg = UD_R_GS; 
      break;
    case 0x67: /* adress-size override prefix */ 
      u->pfx_adr = 0x67;
      break;
    case 0xF0: 
      u->pfx_lock = 0xF0;
      break;
    case 0x66: 
      u->pfx_opr = 0x66;
      break;
    case 0xF2:
      u->pfx_str = 0xf2;
      break;
    case 0xF3:
      u->pfx_str = 0xf3;
      break;
    default:
      /* consume if rex */
      done = (u->dis_mode == 64 && (curr & 0xF0) == 0x40) ? 0 : 1;
      break;
    }
  } while (!done);
  /* rex prefixes in 64bit mode, must be the last prefix */
  if (u->dis_mode == 64 && (last & 0xF0) == 0x40) {
    u->pfx_rex = last;  
  }
  return 0;
}


static inline unsigned int modrm( struct ud * u )
{
    if ( !u->have_modrm ) {
        u->modrm = inp_next( u );
        u->have_modrm = 1;
    }
    return u->modrm;
}


static unsigned int
resolve_operand_size( const struct ud * u, unsigned int s )
{
    switch ( s ) 
    {
    case SZ_V:
        return ( u->opr_mode );
    case SZ_Z:  
        return ( u->opr_mode == 16 ) ? 16 : 32;
    case SZ_Y:
        return ( u->opr_mode == 16 ) ? 32 : u->opr_mode;
    case SZ_RDQ:
        return ( u->dis_mode == 64 ) ? 64 : 32;
    default:
        return s;
    }
}


static int resolve_mnemonic( struct ud* u )
{
  /* resolve 3dnow weirdness. */
  if ( u->mnemonic == UD_I3dnow ) {
    u->mnemonic = ud_itab[ u->le->table[ inp_curr( u )  ] ].mnemonic;
  }
  /* SWAPGS is only valid in 64bits mode */
  if ( u->mnemonic == UD_Iswapgs && u->dis_mode != 64 ) {
    UDERR(u, "swapgs invalid in 64bits mode\n");
    return -1;
  }

  if (u->mnemonic == UD_Ixchg) {
    if ((u->operand[0].type == UD_OP_REG && u->operand[0].base == UD_R_AX  &&
         u->operand[1].type == UD_OP_REG && u->operand[1].base == UD_R_AX) ||
        (u->operand[0].type == UD_OP_REG && u->operand[0].base == UD_R_EAX &&
         u->operand[1].type == UD_OP_REG && u->operand[1].base == UD_R_EAX)) {
      u->operand[0].type = UD_NONE;
      u->operand[1].type = UD_NONE;
      u->mnemonic = UD_Inop;
    }
  }

  if (u->mnemonic == UD_Inop && u->pfx_repe) {
    u->pfx_repe = 0;
    u->mnemonic = UD_Ipause;
  }
  return 0;
}


/* -----------------------------------------------------------------------------
 * decode_a()- Decodes operands of the type seg:offset
 * -----------------------------------------------------------------------------
 */
static void 
decode_a(struct ud* u, struct ud_operand *op)
{
  if (u->opr_mode == 16) {  
    /* seg16:off16 */
    op->type = UD_OP_PTR;
    op->size = 32;
    op->lval.ptr.off = inp_uint16(u);
    op->lval.ptr.seg = inp_uint16(u);
  } else {
    /* seg16:off32 */
    op->type = UD_OP_PTR;
    op->size = 48;
    op->lval.ptr.off = inp_uint32(u);
    op->lval.ptr.seg = inp_uint16(u);
  }
}

/* -----------------------------------------------------------------------------
 * decode_gpr() - Returns decoded General Purpose Register 
 * -----------------------------------------------------------------------------
 */
static enum ud_type 
decode_gpr(register struct ud* u, unsigned int s, unsigned char rm)
{
  switch (s) {
    case 64:
        return UD_R_RAX + rm;
    case 32:
        return UD_R_EAX + rm;
    case 16:
        return UD_R_AX  + rm;
    case  8:
        if (u->dis_mode == 64 && u->pfx_rex) {
            if (rm >= 4)
                return UD_R_SPL + (rm-4);
            return UD_R_AL + rm;
        } else return UD_R_AL + rm;
    case 0:
        /* invalid size in case of a decode error */
        UD_ASSERT(u->error);
        return UD_NONE;
    default:
        UD_ASSERT(!"invalid operand size");
        return UD_NONE;
  }
}

static void
decode_reg(struct ud *u, 
           struct ud_operand *opr,
           int type,
           int num,
           int size)
{
  int reg;
  size = resolve_operand_size(u, size);
  switch (type) {
    case REGCLASS_GPR : reg = decode_gpr(u, size, num); break;
    case REGCLASS_MMX : reg = UD_R_MM0  + (num & 7); break;
    case REGCLASS_XMM : reg = UD_R_XMM0 + num; break;
    case REGCLASS_CR : reg = UD_R_CR0  + num; break;
    case REGCLASS_DB : reg = UD_R_DR0  + num; break;
    case REGCLASS_SEG : {
      /*
       * Only 6 segment registers, anything else is an error.
       */
      if ((num & 7) > 5) {
        UDERR(u, "invalid segment register value\n");
        return;
      } else {
        reg = UD_R_ES + (num & 7);
      }
      break;
    }
    default:
      UD_ASSERT(!"invalid register type");
      return;
  }
  opr->type = UD_OP_REG;
  opr->base = reg;
  opr->size = size;
}


/*
 * decode_imm 
 *
 *    Decode Immediate values.
 */
static void 
decode_imm(struct ud* u, unsigned int size, struct ud_operand *op)
{
  op->size = resolve_operand_size(u, size);
  op->type = UD_OP_IMM;

  switch (op->size) {
  case  8: op->lval.sbyte = inp_uint8(u);   break;
  case 16: op->lval.uword = inp_uint16(u);  break;
  case 32: op->lval.udword = inp_uint32(u); break;
  case 64: op->lval.uqword = inp_uint64(u); break;
  default: return;
  }
}


/* 
 * decode_mem_disp
 *
 *    Decode mem address displacement.
 */
static void 
decode_mem_disp(struct ud* u, unsigned int size, struct ud_operand *op)
{
  switch (size) {
  case 8:
    op->offset = 8; 
    op->lval.ubyte  = inp_uint8(u);
    break;
  case 16:
    op->offset = 16; 
    op->lval.uword  = inp_uint16(u); 
    break;
  case 32:
    op->offset = 32; 
    op->lval.udword = inp_uint32(u); 
    break;
  case 64:
    op->offset = 64; 
    op->lval.uqword = inp_uint64(u); 
    break;
  default:
      return;
  }
}


/*
 * decode_modrm_reg
 *
 *    Decodes reg field of mod/rm byte
 * 
 */
static inline void
decode_modrm_reg(struct ud         *u, 
                 struct ud_operand *operand,
                 unsigned int       type,
                 unsigned int       size)
{
  uint8_t reg = (REX_R(u->pfx_rex) << 3) | MODRM_REG(modrm(u));
  decode_reg(u, operand, type, reg, size);
}


/*
 * decode_modrm_rm
 *
 *    Decodes rm field of mod/rm byte
 * 
 */
static void 
decode_modrm_rm(struct ud         *u, 
                struct ud_operand *op,
                unsigned char      type,    /* register type */
                unsigned int       size)    /* operand size */

{
  size_t offset = 0;
  unsigned char mod, rm;

  /* get mod, r/m and reg fields */
  mod = MODRM_MOD(modrm(u));
  rm  = (REX_B(u->pfx_rex) << 3) | MODRM_RM(modrm(u));

  /* 
   * If mod is 11b, then the modrm.rm specifies a register.
   *
   */
  if (mod == 3) {
    decode_reg(u, op, type, rm, size);
    return;
  }

  /* 
   * !11b => Memory Address
   */  
  op->type = UD_OP_MEM;
  op->size = resolve_operand_size(u, size);

  if (u->adr_mode == 64) {
    op->base = UD_R_RAX + rm;
    if (mod == 1) {
      offset = 8;
    } else if (mod == 2) {
      offset = 32;
    } else if (mod == 0 && (rm & 7) == 5) {           
      op->base = UD_R_RIP;
      offset = 32;
    } else {
      offset = 0;
    }
    /* 
     * Scale-Index-Base (SIB) 
     */
    if ((rm & 7) == 4) {
      inp_next(u);
      
      op->scale = (1 << SIB_S(inp_curr(u))) & ~1;
      op->index = UD_R_RAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));
      op->base  = UD_R_RAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));

      /* special conditions for base reference */
      if (op->index == UD_R_RSP) {
        op->index = UD_NONE;
        op->scale = UD_NONE;
      }

      if (op->base == UD_R_RBP || op->base == UD_R_R13) {
        if (mod == 0) {
          op->base = UD_NONE;
        } 
        if (mod == 1) {
          offset = 8;
        } else {
          offset = 32;
        }
      }
    }
  } else if (u->adr_mode == 32) {
    op->base = UD_R_EAX + rm;
    if (mod == 1) {
      offset = 8;
    } else if (mod == 2) {
      offset = 32;
    } else if (mod == 0 && rm == 5) {
      op->base = UD_NONE;
      offset = 32;
    } else {
      offset = 0;
    }

    /* Scale-Index-Base (SIB) */
    if ((rm & 7) == 4) {
      inp_next(u);

      op->scale = (1 << SIB_S(inp_curr(u))) & ~1;
      op->index = UD_R_EAX + (SIB_I(inp_curr(u)) | (REX_X(u->pfx_rex) << 3));
      op->base  = UD_R_EAX + (SIB_B(inp_curr(u)) | (REX_B(u->pfx_rex) << 3));

      if (op->index == UD_R_ESP) {
        op->index = UD_NONE;
        op->scale = UD_NONE;
      }

      /* special condition for base reference */
      if (op->base == UD_R_EBP) {
        if (mod == 0) {
          op->base = UD_NONE;
        } 
        if (mod == 1) {
          offset = 8;
        } else {
          offset = 32;
        }
      }
    }
  } else {
    const unsigned int bases[]   = { UD_R_BX, UD_R_BX, UD_R_BP, UD_R_BP,
                                     UD_R_SI, UD_R_DI, UD_R_BP, UD_R_BX };
    const unsigned int indices[] = { UD_R_SI, UD_R_DI, UD_R_SI, UD_R_DI,
                                     UD_NONE, UD_NONE, UD_NONE, UD_NONE };
    op->base  = bases[rm & 7];
    op->index = indices[rm & 7];
    if (mod == 0 && rm == 6) {
      offset = 16;
      op->base = UD_NONE;
    } else if (mod == 1) {
      offset = 8;
    } else if (mod == 2) { 
      offset = 16;
    }
  }

  if (offset) {
    decode_mem_disp(u, (unsigned int)offset, op);
  }
}


/* 
 * decode_moffset
 *    Decode offset-only memory operand
 */
static void
decode_moffset(struct ud *u, unsigned int size, struct ud_operand *opr)
{
  opr->type = UD_OP_MEM;
  opr->size = resolve_operand_size(u, size);
  decode_mem_disp(u, u->adr_mode, opr);
}


/* -----------------------------------------------------------------------------
 * decode_operands() - Disassembles Operands.
 * -----------------------------------------------------------------------------
 */
static int
decode_operand(struct ud           *u, 
               struct ud_operand   *operand,
               enum ud_operand_code type,
               unsigned int         size)
{
  operand->_oprcode = type;

  switch (type) {
    case OP_A :
      decode_a(u, operand);
      break;
    case OP_MR:
      decode_modrm_rm(u, operand, REGCLASS_GPR, 
                      MODRM_MOD(modrm(u)) == 3 ? 
                        Mx_reg_size(size) : Mx_mem_size(size));
      break;
    case OP_F:
      u->br_far  = 1;
      /* intended fall through */
    case OP_M:
      if (MODRM_MOD(modrm(u)) == 3) {
        UDERR(u, "expected modrm.mod != 3\n");
      }
      /* intended fall through */
    case OP_E:
      decode_modrm_rm(u, operand, REGCLASS_GPR, size);
      break;
    case OP_G:
      decode_modrm_reg(u, operand, REGCLASS_GPR, size);
      break;
    case OP_sI:
    case OP_I:
      decode_imm(u, size, operand);
      break;
    case OP_I1:
      operand->type = UD_OP_CONST;
      operand->lval.udword = 1;
      break;
    case OP_N:
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      /* intended fall through */
    case OP_Q:
      decode_modrm_rm(u, operand, REGCLASS_MMX, size);
      break;
    case OP_P:
      decode_modrm_reg(u, operand, REGCLASS_MMX, size);
      break;
    case OP_U:
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      /* intended fall through */
    case OP_W:
      decode_modrm_rm(u, operand, REGCLASS_XMM, size);
      break;
    case OP_V:
      decode_modrm_reg(u, operand, REGCLASS_XMM, size);
      break;
    case OP_MU:
      decode_modrm_rm(u, operand, REGCLASS_XMM, 
                      MODRM_MOD(modrm(u)) == 3 ? 
                        Mx_reg_size(size) : Mx_mem_size(size));
      break;
    case OP_S:
      decode_modrm_reg(u, operand, REGCLASS_SEG, size);
      break;
    case OP_O:
      decode_moffset(u, size, operand);
      break;
    case OP_R0: 
    case OP_R1: 
    case OP_R2: 
    case OP_R3: 
    case OP_R4: 
    case OP_R5: 
    case OP_R6: 
    case OP_R7:
      decode_reg(u, operand, REGCLASS_GPR, 
                 (REX_B(u->pfx_rex) << 3) | (type - OP_R0), size);
      break;
    case OP_AL:
    case OP_AX:
    case OP_eAX:
    case OP_rAX:
      decode_reg(u, operand, REGCLASS_GPR, 0, size);
      break;
    case OP_CL:
    case OP_CX:
    case OP_eCX:
      decode_reg(u, operand, REGCLASS_GPR, 1, size);
      break;
    case OP_DL:
    case OP_DX:
    case OP_eDX:
      decode_reg(u, operand, REGCLASS_GPR, 2, size);
      break;
    case OP_ES: 
    case OP_CS: 
    case OP_DS:
    case OP_SS: 
    case OP_FS: 
    case OP_GS:
      /* in 64bits mode, only fs and gs are allowed */
      if (u->dis_mode == 64) {
        if (type != OP_FS && type != OP_GS) {
          UDERR(u, "invalid segment register in 64bits\n");
        }
      }
      operand->type = UD_OP_REG;
      operand->base = (type - OP_ES) + UD_R_ES;
      operand->size = 16;
      break;
    case OP_J :
      decode_imm(u, size, operand);
      operand->type = UD_OP_JIMM;
      break ;
    case OP_R :
      if (MODRM_MOD(modrm(u)) != 3) {
        UDERR(u, "expected modrm.mod == 3\n");
      }
      decode_modrm_rm(u, operand, REGCLASS_GPR, size);
      break;
    case OP_C:
      decode_modrm_reg(u, operand, REGCLASS_CR, size);
      break;
    case OP_D:
      decode_modrm_reg(u, operand, REGCLASS_DB, size);
      break;
    case OP_I3 :
      operand->type = UD_OP_CONST;
      operand->lval.sbyte = 3;
      break;
    case OP_ST0: 
    case OP_ST1: 
    case OP_ST2: 
    case OP_ST3:
    case OP_ST4:
    case OP_ST5: 
    case OP_ST6: 
    case OP_ST7:
      operand->type = UD_OP_REG;
      operand->base = (type - OP_ST0) + UD_R_ST0;
      operand->size = 80;
      break;
    default :
      break;
  }
  return 0;
}


/* 
 * decode_operands
 *
 *    Disassemble upto 3 operands of the current instruction being
 *    disassembled. By the end of the function, the operand fields
 *    of the ud structure will have been filled.
 */
static int
decode_operands(struct ud* u)
{
  decode_operand(u, &u->operand[0],
                    u->itab_entry->operand1.type,
                    u->itab_entry->operand1.size);
  decode_operand(u, &u->operand[1],
                    u->itab_entry->operand2.type,
                    u->itab_entry->operand2.size);
  decode_operand(u, &u->operand[2],
                    u->itab_entry->operand3.type,
                    u->itab_entry->operand3.size);
  return 0;
}
    
/* -----------------------------------------------------------------------------
 * clear_insn() - clear instruction structure
 * -----------------------------------------------------------------------------
 */
static void
clear_insn(register struct ud* u)
{
  u->error     = 0;
  u->pfx_seg   = 0;
  u->pfx_opr   = 0;
  u->pfx_adr   = 0;
  u->pfx_lock  = 0;
  u->pfx_repne = 0;
  u->pfx_rep   = 0;
  u->pfx_repe  = 0;
  u->pfx_rex   = 0;
  u->pfx_str   = 0;
  u->mnemonic  = UD_Inone;
  u->itab_entry = NULL;
  u->have_modrm = 0;
  u->br_far    = 0;

  memset( &u->operand[ 0 ], 0, sizeof( struct ud_operand ) );
  memset( &u->operand[ 1 ], 0, sizeof( struct ud_operand ) );
  memset( &u->operand[ 2 ], 0, sizeof( struct ud_operand ) );
}


static inline int
resolve_pfx_str(struct ud* u)
{
  if (u->pfx_str == 0xf3) {
    if (P_STR(u->itab_entry->prefix)) {
        u->pfx_rep  = 0xf3;
    } else {
        u->pfx_repe = 0xf3;
    }
  } else if (u->pfx_str == 0xf2) {
    u->pfx_repne = 0xf3;
  }
  return 0;
}


static int
resolve_mode( struct ud* u )
{
  int default64;
  /* if in error state, bail out */
  if ( u->error ) return -1; 

  /* propagate prefix effects */
  if ( u->dis_mode == 64 ) {  /* set 64bit-mode flags */

    /* Check validity of  instruction m64 */
    if ( P_INV64( u->itab_entry->prefix ) ) {
      UDERR(u, "instruction invalid in 64bits\n");
      return -1;
    }

    /* effective rex prefix is the  effective mask for the 
     * instruction hard-coded in the opcode map.
     */
    u->pfx_rex = ( u->pfx_rex & 0x40 ) | 
                 ( u->pfx_rex & REX_PFX_MASK( u->itab_entry->prefix ) ); 

    /* whether this instruction has a default operand size of 
     * 64bit, also hardcoded into the opcode map.
     */
    default64 = P_DEF64( u->itab_entry->prefix ); 
    /* calculate effective operand size */
    if ( REX_W( u->pfx_rex ) ) {
        u->opr_mode = 64;
    } else if ( u->pfx_opr ) {
        u->opr_mode = 16;
    } else {
        /* unless the default opr size of instruction is 64,
         * the effective operand size in the absence of rex.w
         * prefix is 32.
         */
        u->opr_mode = default64 ? 64 : 32;
    }

    /* calculate effective address size */
    u->adr_mode = (u->pfx_adr) ? 32 : 64;
  } else if ( u->dis_mode == 32 ) { /* set 32bit-mode flags */
    u->opr_mode = ( u->pfx_opr ) ? 16 : 32;
    u->adr_mode = ( u->pfx_adr ) ? 16 : 32;
  } else if ( u->dis_mode == 16 ) { /* set 16bit-mode flags */
    u->opr_mode = ( u->pfx_opr ) ? 32 : 16;
    u->adr_mode = ( u->pfx_adr ) ? 32 : 16;
  }

  return 0;
}


static inline int
decode_insn(struct ud *u, uint16_t ptr)
{
  UD_ASSERT((ptr & 0x8000) == 0);
  u->itab_entry = &ud_itab[ ptr ];
  u->mnemonic = u->itab_entry->mnemonic;
  return (resolve_pfx_str(u)  == 0 &&
          resolve_mode(u)     == 0 &&
          decode_operands(u)  == 0 &&
          resolve_mnemonic(u) == 0) ? 0 : -1;
}


/*
 * decode_3dnow()
 *
 *    Decoding 3dnow is a little tricky because of its strange opcode
 *    structure. The final opcode disambiguation depends on the last
 *    byte that comes after the operands have been decoded. Fortunately,
 *    all 3dnow instructions have the same set of operand types. So we
 *    go ahead and decode the instruction by picking an arbitrarily chosen
 *    valid entry in the table, decode the operands, and read the final
 *    byte to resolve the menmonic.
 */
static inline int
decode_3dnow(struct ud* u)
{
  uint16_t ptr;
  UD_ASSERT(u->le->type == UD_TAB__OPC_3DNOW);
  UD_ASSERT(u->le->table[0xc] != 0);
  decode_insn(u, u->le->table[0xc]);
  inp_next(u); 
  if (u->error) {
    return -1;
  }
  ptr = u->le->table[inp_curr(u)]; 
  UD_ASSERT((ptr & 0x8000) == 0);
  u->mnemonic = ud_itab[ptr].mnemonic;
  return 0;
}


static int
decode_ssepfx(struct ud *u)
{
  uint8_t idx;
  uint8_t pfx;
 
  /*
   * String prefixes (f2, f3) take precedence over operand
   * size prefix (66).
   */
  pfx = u->pfx_str;
  if (pfx == 0) {
    pfx = u->pfx_opr;
  }
  idx = ((pfx & 0xf) + 1) / 2;
  if (u->le->table[idx] == 0) {
    idx = 0;
  }
  if (idx && u->le->table[idx] != 0) {
    /*
     * "Consume" the prefix as a part of the opcode, so it is no
     * longer exported as an instruction prefix.
     */
    u->pfx_str = 0;
    if (pfx == 0x66) {
        /* 
         * consume "66" only if it was used for decoding, leaving
         * it to be used as an operands size override for some
         * simd instructions.
         */
        u->pfx_opr = 0;
    }
  }
  return decode_ext(u, u->le->table[idx]);
}


/*
 * decode_ext()
 *
 *    Decode opcode extensions (if any)
 */
static int
decode_ext(struct ud *u, uint16_t ptr)
{
  uint8_t idx = 0;
  if ((ptr & 0x8000) == 0) {
    return decode_insn(u, ptr); 
  }
  u->le = &ud_lookup_table_list[(~0x8000 & ptr)];
  if (u->le->type == UD_TAB__OPC_3DNOW) {
    return decode_3dnow(u);
  }

  switch (u->le->type) {
    case UD_TAB__OPC_MOD:
      /* !11 = 0, 11 = 1 */
      idx = (MODRM_MOD(modrm(u)) + 1) / 4;
      break;
      /* disassembly mode/operand size/address size based tables.
       * 16 = 0,, 32 = 1, 64 = 2
       */
    case UD_TAB__OPC_MODE:
      idx = u->dis_mode != 64 ? 0 : 1;
      break;
    case UD_TAB__OPC_OSIZE:
      idx = eff_opr_mode(u->dis_mode, REX_W(u->pfx_rex), u->pfx_opr) / 32;
      break;
    case UD_TAB__OPC_ASIZE:
      idx = eff_adr_mode(u->dis_mode, u->pfx_adr) / 32;
      break;
    case UD_TAB__OPC_X87:
      idx = modrm(u) - 0xC0;
      break;
    case UD_TAB__OPC_VENDOR:
      if (u->vendor == UD_VENDOR_ANY) {
        /* choose a valid entry */
        idx = (u->le->table[idx] != 0) ? 0 : 1;
      } else if (u->vendor == UD_VENDOR_AMD) {
        idx = 0;
      } else {
        idx = 1;
      }
      break;
    case UD_TAB__OPC_RM:
      idx = MODRM_RM(modrm(u));
      break;
    case UD_TAB__OPC_REG:
      idx = MODRM_REG(modrm(u));
      break;
    case UD_TAB__OPC_SSE:
      return decode_ssepfx(u);
    default:
      UD_ASSERT(!"not reached");
      break;
  }

  return decode_ext(u, u->le->table[idx]);
}


static int
decode_opcode(struct ud *u)
{
  uint16_t ptr;
  UD_ASSERT(u->le->type == UD_TAB__OPC_TABLE);
  UD_RETURN_ON_ERROR(u);
  u->primary_opcode = inp_curr(u);
  ptr = u->le->table[inp_curr(u)];
  if (ptr & 0x8000) {
    u->le = &ud_lookup_table_list[ptr & ~0x8000];
    if (u->le->type == UD_TAB__OPC_TABLE) {
      inp_next(u);
      return decode_opcode(u);
    }
  }
  return decode_ext(u, ptr);
}

 
/* =============================================================================
 * ud_decode() - Instruction decoder. Returns the number of bytes decoded.
 * =============================================================================
 */
unsigned int
ud_decode(struct ud *u)
{
  inp_start(u);
  clear_insn(u);
  u->le = &ud_lookup_table_list[0];
  u->error = decode_prefixes(u) == -1 || 
             decode_opcode(u)   == -1 ||
             u->error;
  /* Handle decode error. */
  if (u->error) {
    /* clear out the decode data. */
    clear_insn(u);
    /* mark the sequence of bytes as invalid. */
    u->itab_entry = &ud_itab[0]; /* entry 0 is invalid */
    u->mnemonic = u->itab_entry->mnemonic;
  } 

    /* maybe this stray segment override byte
     * should be spewed out?
     */
    if ( !P_SEG( u->itab_entry->prefix ) && 
            u->operand[0].type != UD_OP_MEM &&
            u->operand[1].type != UD_OP_MEM )
        u->pfx_seg = 0;

  u->insn_offset = u->pc; /* set offset of instruction */
  u->asm_buf_fill = 0;   /* set translation buffer index to 0 */
  u->pc += u->inp_ctr;    /* move program counter by bytes decoded */

  /* return number of bytes disassembled. */
  return (unsigned int)u->inp_ctr;
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/decode.h`:

```h
/* udis86 - libudis86/decode.h
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_DECODE_H
#define UD_DECODE_H

#include "types.h"
#include "itab.h"

#define MAX_INSN_LENGTH 15

/* itab prefix bits */
#define P_none          ( 0 )
#define P_cast          ( 1 << 0 )
#define P_CAST(n)       ( ( n >> 0 ) & 1 )
#define P_rexb          ( 1 << 1 )
#define P_REXB(n)       ( ( n >> 1 ) & 1 )
#define P_inv64         ( 1 << 4 )
#define P_INV64(n)      ( ( n >> 4 ) & 1 )
#define P_rexw          ( 1 << 5 )
#define P_REXW(n)       ( ( n >> 5 ) & 1 )
#define P_def64         ( 1 << 7 )
#define P_DEF64(n)      ( ( n >> 7 ) & 1 )
#define P_rexr          ( 1 << 8 )
#define P_REXR(n)       ( ( n >> 8 ) & 1 )
#define P_oso           ( 1 << 9 )
#define P_OSO(n)        ( ( n >> 9 ) & 1 )
#define P_aso           ( 1 << 10 )
#define P_ASO(n)        ( ( n >> 10 ) & 1 )
#define P_rexx          ( 1 << 11 )
#define P_REXX(n)       ( ( n >> 11 ) & 1 )
#define P_ImpAddr       ( 1 << 12 )
#define P_IMPADDR(n)    ( ( n >> 12 ) & 1 )
#define P_seg           ( 1 << 13 )
#define P_SEG(n)        ( ( n >> 13 ) & 1 )
#define P_str           ( 1 << 14 )
#define P_STR(n)        ( ( n >> 14 ) & 1 )
#define P_strz          ( 1 << 15 )
#define P_STR_ZF(n)     ( ( n >> 15 ) & 1 )

/* operand type constants -- order is important! */

enum ud_operand_code {
    OP_NONE,

    OP_A,      OP_E,      OP_M,       OP_G,       
    OP_I,      OP_F,

    OP_R0,     OP_R1,     OP_R2,      OP_R3,
    OP_R4,     OP_R5,     OP_R6,      OP_R7,

    OP_AL,     OP_CL,     OP_DL,
    OP_AX,     OP_CX,     OP_DX,
    OP_eAX,    OP_eCX,    OP_eDX,
    OP_rAX,    OP_rCX,    OP_rDX,

    OP_ES,     OP_CS,     OP_SS,      OP_DS,  
    OP_FS,     OP_GS,

    OP_ST0,    OP_ST1,    OP_ST2,     OP_ST3,
    OP_ST4,    OP_ST5,    OP_ST6,     OP_ST7,

    OP_J,      OP_S,      OP_O,          
    OP_I1,     OP_I3,     OP_sI,

    OP_V,      OP_W,      OP_Q,       OP_P, 
    OP_U,      OP_N,      OP_MU,

    OP_R,      OP_C,      OP_D,       

    OP_MR
} UD_ATTR_PACKED;


/* operand size constants */

enum ud_operand_size {
    SZ_NA  = 0,
    SZ_Z   = 1,
    SZ_V   = 2,
    SZ_RDQ = 7,

    /* the following values are used as is,
     * and thus hard-coded. changing them 
     * will break internals 
     */
    SZ_B   = 8,
    SZ_W   = 16,
    SZ_D   = 32,
    SZ_Q   = 64,
    SZ_T   = 80,
    SZ_O   = 128,

    SZ_Y   = 17,

    /*
     * complex size types, that encode sizes for operands
     * of type MR (memory or register), for internal use
     * only. Id space 256 and above.
     */
    SZ_BD  = (SZ_B << 8) | SZ_D,
    SZ_BV  = (SZ_B << 8) | SZ_V,
    SZ_WD  = (SZ_W << 8) | SZ_D,
    SZ_WV  = (SZ_W << 8) | SZ_V,
    SZ_WY  = (SZ_W << 8) | SZ_Y,
    SZ_DY  = (SZ_D << 8) | SZ_Y,
    SZ_WO  = (SZ_W << 8) | SZ_O,
    SZ_DO  = (SZ_D << 8) | SZ_O,
    SZ_QO  = (SZ_Q << 8) | SZ_O,

} UD_ATTR_PACKED;


/* resolve complex size type.
 */
static inline enum ud_operand_size
Mx_mem_size(enum ud_operand_size size)
{
    return (size >> 8) & 0xff;
}

static inline enum ud_operand_size
Mx_reg_size(enum ud_operand_size size)
{
    return size & 0xff;
}

/* A single operand of an entry in the instruction table. 
 * (internal use only)
 */
struct ud_itab_entry_operand 
{
  enum ud_operand_code type;
  enum ud_operand_size size;
};


/* A single entry in an instruction table. 
 *(internal use only)
 */
struct ud_itab_entry 
{
  enum ud_mnemonic_code         mnemonic;
  struct ud_itab_entry_operand  operand1;
  struct ud_itab_entry_operand  operand2;
  struct ud_itab_entry_operand  operand3;
  uint32_t                      prefix;
};

struct ud_lookup_table_list_entry {
    const uint16_t *table;
    enum ud_table_type type;
    const char *meta;
};
     


static inline int
ud_opcode_field_sext(uint8_t primary_opcode)
{
  return (primary_opcode & 0x02) != 0;
}

extern struct ud_itab_entry ud_itab[];
extern struct ud_lookup_table_list_entry ud_lookup_table_list[];

#endif /* UD_DECODE_H */

/* vim:cindent
 * vim:expandtab
 * vim:ts=4
 * vim:sw=4
 */

```

`Libudis86/extern.h`:

```h
/* udis86 - libudis86/extern.h
 *
 * Copyright (c) 2002-2009, 2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_EXTERN_H
#define UD_EXTERN_H

#ifdef __cplusplus
extern "C" {
#endif

#include "types.h"

/* ============================= PUBLIC API ================================= */

extern void ud_init(struct ud*);

extern void ud_set_mode(struct ud*, uint8_t);

extern void ud_set_pc(struct ud*, uint64_t);

extern void ud_set_input_hook(struct ud*, int (*)(struct ud*));

extern void ud_set_input_buffer(struct ud*, const uint8_t*, size_t);

#ifndef __UD_STANDALONE__
extern void ud_set_input_file(struct ud*, FILE*);
#endif /* __UD_STANDALONE__ */

extern void ud_set_vendor(struct ud*, unsigned);

extern void ud_set_syntax(struct ud*, void (*)(struct ud*));

extern void ud_input_skip(struct ud*, size_t);

extern int ud_input_end(const struct ud*);

extern unsigned int ud_decode(struct ud*);

extern unsigned int ud_disassemble(struct ud*);

extern void ud_translate_intel(struct ud*);

extern void ud_translate_att(struct ud*);

extern const char* ud_insn_asm(const struct ud* u);

extern const uint8_t* ud_insn_ptr(const struct ud* u);

extern uint64_t ud_insn_off(const struct ud*);

extern const char* ud_insn_hex(struct ud*);

extern unsigned int ud_insn_len(const struct ud* u);

extern const struct ud_operand* ud_insn_opr(const struct ud *u, unsigned int n);

extern int ud_opr_is_sreg(const struct ud_operand *opr);

extern int ud_opr_is_gpr(const struct ud_operand *opr);

extern enum ud_mnemonic_code ud_insn_mnemonic(const struct ud *u);

extern const char* ud_lookup_mnemonic(enum ud_mnemonic_code c);

extern void ud_set_user_opaque_data(struct ud*, void*);

extern void* ud_get_user_opaque_data(const struct ud*);

extern uint64_t ud_insn_sext_imm(const struct ud*, const struct ud_operand*);

extern void ud_set_asm_buffer(struct ud *u, char *buf, size_t size);

extern void ud_set_sym_resolver(struct ud *u, 
                                const char* (*resolver)(struct ud*, 
                                                        uint64_t addr,
                                                        int64_t *offset));

/* ========================================================================== */

#ifdef __cplusplus
}
#endif
#endif /* UD_EXTERN_H */

```

`Libudis86/itab.c`:

```c
/* itab.c -- generated by udis86:scripts/ud_itab.py, do no edit */
#include "decode.h"

#define GROUP(n) (0x8000 | (n))


static const uint16_t ud_itab__1[] = {
  /*  0 */           7,           0,
};

static const uint16_t ud_itab__2[] = {
  /*  0 */           8,           0,
};

static const uint16_t ud_itab__3[] = {
  /*  0 */          15,           0,
};

static const uint16_t ud_itab__6[] = {
  /*  0 */          16,           0,           0,           0,
};

static const uint16_t ud_itab__7[] = {
  /*  0 */          17,           0,           0,           0,
};

static const uint16_t ud_itab__8[] = {
  /*  0 */          18,           0,           0,           0,
};

static const uint16_t ud_itab__9[] = {
  /*  0 */          19,           0,           0,           0,
};

static const uint16_t ud_itab__10[] = {
  /*  0 */          20,           0,           0,           0,
};

static const uint16_t ud_itab__11[] = {
  /*  0 */          21,           0,           0,           0,
};

static const uint16_t ud_itab__5[] = {
  /*  0 */    GROUP(6),    GROUP(7),    GROUP(8),    GROUP(9),
  /*  4 */   GROUP(10),   GROUP(11),           0,           0,
};

static const uint16_t ud_itab__15[] = {
  /*  0 */          22,           0,
};

static const uint16_t ud_itab__14[] = {
  /*  0 */   GROUP(15),           0,           0,           0,
};

static const uint16_t ud_itab__17[] = {
  /*  0 */          23,           0,
};

static const uint16_t ud_itab__16[] = {
  /*  0 */   GROUP(17),           0,           0,           0,
};

static const uint16_t ud_itab__19[] = {
  /*  0 */          24,           0,
};

static const uint16_t ud_itab__18[] = {
  /*  0 */   GROUP(19),           0,           0,           0,
};

static const uint16_t ud_itab__21[] = {
  /*  0 */          25,           0,
};

static const uint16_t ud_itab__20[] = {
  /*  0 */   GROUP(21),           0,           0,           0,
};

static const uint16_t ud_itab__23[] = {
  /*  0 */          26,           0,
};

static const uint16_t ud_itab__22[] = {
  /*  0 */   GROUP(23),           0,           0,           0,
};

static const uint16_t ud_itab__25[] = {
  /*  0 */          27,           0,
};

static const uint16_t ud_itab__24[] = {
  /*  0 */   GROUP(25),           0,           0,           0,
};

static const uint16_t ud_itab__27[] = {
  /*  0 */          28,           0,
};

static const uint16_t ud_itab__26[] = {
  /*  0 */   GROUP(27),           0,           0,           0,
};

static const uint16_t ud_itab__13[] = {
  /*  0 */   GROUP(14),   GROUP(16),   GROUP(18),   GROUP(20),
  /*  4 */   GROUP(22),           0,   GROUP(24),   GROUP(26),
};

static const uint16_t ud_itab__32[] = {
  /*  0 */           0,          29,           0,
};

static const uint16_t ud_itab__31[] = {
  /*  0 */           0,   GROUP(32),
};

static const uint16_t ud_itab__30[] = {
  /*  0 */   GROUP(31),           0,           0,           0,
};

static const uint16_t ud_itab__35[] = {
  /*  0 */           0,          30,           0,
};

static const uint16_t ud_itab__34[] = {
  /*  0 */           0,   GROUP(35),
};

static const uint16_t ud_itab__33[] = {
  /*  0 */   GROUP(34),           0,           0,           0,
};

static const uint16_t ud_itab__38[] = {
  /*  0 */           0,          31,           0,
};

static const uint16_t ud_itab__37[] = {
  /*  0 */           0,   GROUP(38),
};

static const uint16_t ud_itab__36[] = {
  /*  0 */   GROUP(37),           0,           0,           0,
};

static const uint16_t ud_itab__41[] = {
  /*  0 */           0,          32,           0,
};

static const uint16_t ud_itab__40[] = {
  /*  0 */           0,   GROUP(41),
};

static const uint16_t ud_itab__39[] = {
  /*  0 */   GROUP(40),           0,           0,           0,
};

static const uint16_t ud_itab__29[] = {
  /*  0 */           0,   GROUP(30),   GROUP(33),   GROUP(36),
  /*  4 */   GROUP(39),           0,           0,           0,
};

static const uint16_t ud_itab__44[] = {
  /*  0 */           0,          33,
};

static const uint16_t ud_itab__43[] = {
  /*  0 */   GROUP(44),           0,           0,           0,
};

static const uint16_t ud_itab__46[] = {
  /*  0 */           0,          34,
};

static const uint16_t ud_itab__45[] = {
  /*  0 */   GROUP(46),           0,           0,           0,
};

static const uint16_t ud_itab__42[] = {
  /*  0 */   GROUP(43),   GROUP(45),           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__49[] = {
  /*  0 */           0,          35,
};

static const uint16_t ud_itab__48[] = {
  /*  0 */   GROUP(49),           0,           0,           0,
};

static const uint16_t ud_itab__51[] = {
  /*  0 */           0,          36,
};

static const uint16_t ud_itab__50[] = {
  /*  0 */   GROUP(51),           0,           0,           0,
};

static const uint16_t ud_itab__47[] = {
  /*  0 */   GROUP(48),   GROUP(50),           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__55[] = {
  /*  0 */          37,           0,           0,
};

static const uint16_t ud_itab__54[] = {
  /*  0 */           0,   GROUP(55),
};

static const uint16_t ud_itab__53[] = {
  /*  0 */   GROUP(54),           0,           0,           0,
};

static const uint16_t ud_itab__58[] = {
  /*  0 */          38,           0,           0,
};

static const uint16_t ud_itab__57[] = {
  /*  0 */           0,   GROUP(58),
};

static const uint16_t ud_itab__56[] = {
  /*  0 */   GROUP(57),           0,           0,           0,
};

static const uint16_t ud_itab__61[] = {
  /*  0 */          39,           0,           0,
};

static const uint16_t ud_itab__60[] = {
  /*  0 */           0,   GROUP(61),
};

static const uint16_t ud_itab__59[] = {
  /*  0 */   GROUP(60),           0,           0,           0,
};

static const uint16_t ud_itab__64[] = {
  /*  0 */          40,           0,           0,
};

static const uint16_t ud_itab__63[] = {
  /*  0 */           0,   GROUP(64),
};

static const uint16_t ud_itab__62[] = {
  /*  0 */   GROUP(63),           0,           0,           0,
};

static const uint16_t ud_itab__67[] = {
  /*  0 */          41,           0,           0,
};

static const uint16_t ud_itab__66[] = {
  /*  0 */           0,   GROUP(67),
};

static const uint16_t ud_itab__65[] = {
  /*  0 */   GROUP(66),           0,           0,           0,
};

static const uint16_t ud_itab__70[] = {
  /*  0 */          42,           0,           0,
};

static const uint16_t ud_itab__69[] = {
  /*  0 */           0,   GROUP(70),
};

static const uint16_t ud_itab__68[] = {
  /*  0 */   GROUP(69),           0,           0,           0,
};

static const uint16_t ud_itab__73[] = {
  /*  0 */          43,           0,           0,
};

static const uint16_t ud_itab__72[] = {
  /*  0 */           0,   GROUP(73),
};

static const uint16_t ud_itab__71[] = {
  /*  0 */   GROUP(72),           0,           0,           0,
};

static const uint16_t ud_itab__76[] = {
  /*  0 */          44,           0,           0,
};

static const uint16_t ud_itab__75[] = {
  /*  0 */           0,   GROUP(76),
};

static const uint16_t ud_itab__74[] = {
  /*  0 */   GROUP(75),           0,           0,           0,
};

static const uint16_t ud_itab__52[] = {
  /*  0 */   GROUP(53),   GROUP(56),   GROUP(59),   GROUP(62),
  /*  4 */   GROUP(65),   GROUP(68),   GROUP(71),   GROUP(74),
};

static const uint16_t ud_itab__78[] = {
  /*  0 */           0,          45,
};

static const uint16_t ud_itab__77[] = {
  /*  0 */   GROUP(78),           0,           0,           0,
};

static const uint16_t ud_itab__80[] = {
  /*  0 */           0,          46,
};

static const uint16_t ud_itab__79[] = {
  /*  0 */   GROUP(80),           0,           0,           0,
};

static const uint16_t ud_itab__83[] = {
  /*  0 */           0,          47,
};

static const uint16_t ud_itab__82[] = {
  /*  0 */   GROUP(83),           0,           0,           0,
};

static const uint16_t ud_itab__86[] = {
  /*  0 */          48,           0,           0,
};

static const uint16_t ud_itab__85[] = {
  /*  0 */           0,   GROUP(86),
};

static const uint16_t ud_itab__84[] = {
  /*  0 */   GROUP(85),           0,           0,           0,
};

static const uint16_t ud_itab__81[] = {
  /*  0 */   GROUP(82),   GROUP(84),           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__28[] = {
  /*  0 */   GROUP(29),   GROUP(42),   GROUP(47),   GROUP(52),
  /*  4 */   GROUP(77),           0,   GROUP(79),   GROUP(81),
};

static const uint16_t ud_itab__12[] = {
  /*  0 */   GROUP(13),   GROUP(28),
};

static const uint16_t ud_itab__87[] = {
  /*  0 */          49,           0,           0,           0,
};

static const uint16_t ud_itab__88[] = {
  /*  0 */          50,           0,           0,           0,
};

static const uint16_t ud_itab__89[] = {
  /*  0 */          51,           0,           0,           0,
};

static const uint16_t ud_itab__90[] = {
  /*  0 */          52,           0,           0,           0,
};

static const uint16_t ud_itab__91[] = {
  /*  0 */          53,           0,           0,           0,
};

static const uint16_t ud_itab__92[] = {
  /*  0 */          54,           0,           0,           0,
};

static const uint16_t ud_itab__93[] = {
  /*  0 */          55,           0,           0,           0,
};

static const uint16_t ud_itab__94[] = {
  /*  0 */          56,           0,           0,           0,
};

static const uint16_t ud_itab__96[] = {
  /*  0 */          57,           0,           0,           0,
};

static const uint16_t ud_itab__97[] = {
  /*  0 */          58,           0,           0,           0,
};

static const uint16_t ud_itab__98[] = {
  /*  0 */          59,           0,           0,           0,
};

static const uint16_t ud_itab__99[] = {
  /*  0 */          60,           0,           0,           0,
};

static const uint16_t ud_itab__100[] = {
  /*  0 */          61,           0,           0,           0,
};

static const uint16_t ud_itab__101[] = {
  /*  0 */          62,           0,           0,           0,
};

static const uint16_t ud_itab__102[] = {
  /*  0 */          63,           0,           0,           0,
};

static const uint16_t ud_itab__103[] = {
  /*  0 */          64,           0,           0,           0,
};

static const uint16_t ud_itab__95[] = {
  /*  0 */   GROUP(96),   GROUP(97),   GROUP(98),   GROUP(99),
  /*  4 */  GROUP(100),  GROUP(101),  GROUP(102),  GROUP(103),
};

static const uint16_t ud_itab__104[] = {
  /*  0 */          65,           0,           0,           0,
};

static const uint16_t ud_itab__105[] = {
  /*  0 */           0,           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
  /*  8 */           0,           0,           0,           0,
  /*  c */          66,          67,           0,           0,
  /* 10 */           0,           0,           0,           0,
  /* 14 */           0,           0,           0,           0,
  /* 18 */           0,           0,           0,           0,
  /* 1c */          68,          69,           0,           0,
  /* 20 */           0,           0,           0,           0,
  /* 24 */           0,           0,           0,           0,
  /* 28 */           0,           0,           0,           0,
  /* 2c */           0,           0,           0,           0,
  /* 30 */           0,           0,           0,           0,
  /* 34 */           0,           0,           0,           0,
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
  /* 40 */           0,           0,           0,           0,
  /* 44 */           0,           0,           0,           0,
  /* 48 */           0,           0,           0,           0,
  /* 4c */           0,           0,           0,           0,
  /* 50 */           0,           0,           0,           0,
  /* 54 */           0,           0,           0,           0,
  /* 58 */           0,           0,           0,           0,
  /* 5c */           0,           0,           0,           0,
  /* 60 */           0,           0,           0,           0,
  /* 64 */           0,           0,           0,           0,
  /* 68 */           0,           0,           0,           0,
  /* 6c */           0,           0,           0,           0,
  /* 70 */           0,           0,           0,           0,
  /* 74 */           0,           0,           0,           0,
  /* 78 */           0,           0,           0,           0,
  /* 7c */           0,           0,           0,           0,
  /* 80 */           0,           0,           0,           0,
  /* 84 */           0,           0,           0,           0,
  /* 88 */           0,           0,          70,           0,
  /* 8c */           0,           0,          71,           0,
  /* 90 */          72,           0,           0,           0,
  /* 94 */          73,           0,          74,          75,
  /* 98 */           0,           0,          76,           0,
  /* 9c */           0,           0,          77,           0,
  /* a0 */          78,           0,           0,           0,
  /* a4 */          79,           0,          80,          81,
  /* a8 */           0,           0,          82,           0,
  /* ac */           0,           0,          83,           0,
  /* b0 */          84,           0,           0,           0,
  /* b4 */          85,           0,          86,          87,
  /* b8 */           0,           0,           0,          88,
  /* bc */           0,           0,           0,          89,
  /* c0 */           0,           0,           0,           0,
  /* c4 */           0,           0,           0,           0,
  /* c8 */           0,           0,           0,           0,
  /* cc */           0,           0,           0,           0,
  /* d0 */           0,           0,           0,           0,
  /* d4 */           0,           0,           0,           0,
  /* d8 */           0,           0,           0,           0,
  /* dc */           0,           0,           0,           0,
  /* e0 */           0,           0,           0,           0,
  /* e4 */           0,           0,           0,           0,
  /* e8 */           0,           0,           0,           0,
  /* ec */           0,           0,           0,           0,
  /* f0 */           0,           0,           0,           0,
  /* f4 */           0,           0,           0,           0,
  /* f8 */           0,           0,           0,           0,
  /* fc */           0,           0,           0,           0,
};

static const uint16_t ud_itab__106[] = {
  /*  0 */          90,          91,          92,          93,
};

static const uint16_t ud_itab__107[] = {
  /*  0 */          94,          95,          96,          97,
};

static const uint16_t ud_itab__110[] = {
  /*  0 */          98,           0,
};

static const uint16_t ud_itab__111[] = {
  /*  0 */          99,           0,
};

static const uint16_t ud_itab__112[] = {
  /*  0 */         100,           0,
};

static const uint16_t ud_itab__113[] = {
  /*  0 */         101,           0,
};

static const uint16_t ud_itab__109[] = {
  /*  0 */  GROUP(110),  GROUP(111),  GROUP(112),  GROUP(113),
};

static const uint16_t ud_itab__115[] = {
  /*  0 */           0,         102,
};

static const uint16_t ud_itab__116[] = {
  /*  0 */           0,         103,
};

static const uint16_t ud_itab__117[] = {
  /*  0 */           0,         104,
};

static const uint16_t ud_itab__114[] = {
  /*  0 */  GROUP(115),  GROUP(116),  GROUP(117),           0,
};

static const uint16_t ud_itab__108[] = {
  /*  0 */  GROUP(109),  GROUP(114),
};

static const uint16_t ud_itab__118[] = {
  /*  0 */         105,           0,           0,         106,
};

static const uint16_t ud_itab__119[] = {
  /*  0 */         107,           0,           0,         108,
};

static const uint16_t ud_itab__120[] = {
  /*  0 */         109,           0,           0,         110,
};

static const uint16_t ud_itab__123[] = {
  /*  0 */         111,           0,
};

static const uint16_t ud_itab__124[] = {
  /*  0 */         112,           0,
};

static const uint16_t ud_itab__125[] = {
  /*  0 */         113,           0,
};

static const uint16_t ud_itab__122[] = {
  /*  0 */  GROUP(123),           0,  GROUP(124),  GROUP(125),
};

static const uint16_t ud_itab__127[] = {
  /*  0 */           0,         114,
};

static const uint16_t ud_itab__128[] = {
  /*  0 */           0,         115,
};

static const uint16_t ud_itab__126[] = {
  /*  0 */  GROUP(127),           0,  GROUP(128),           0,
};

static const uint16_t ud_itab__121[] = {
  /*  0 */  GROUP(122),  GROUP(126),
};

static const uint16_t ud_itab__129[] = {
  /*  0 */         116,           0,           0,         117,
};

static const uint16_t ud_itab__131[] = {
  /*  0 */         118,           0,           0,           0,
};

static const uint16_t ud_itab__132[] = {
  /*  0 */         119,           0,           0,           0,
};

static const uint16_t ud_itab__133[] = {
  /*  0 */         120,           0,           0,           0,
};

static const uint16_t ud_itab__134[] = {
  /*  0 */         121,           0,           0,           0,
};

static const uint16_t ud_itab__130[] = {
  /*  0 */  GROUP(131),  GROUP(132),  GROUP(133),  GROUP(134),
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__135[] = {
  /*  0 */         122,           0,           0,           0,
};

static const uint16_t ud_itab__136[] = {
  /*  0 */         123,           0,           0,           0,
};

static const uint16_t ud_itab__137[] = {
  /*  0 */         124,           0,           0,           0,
};

static const uint16_t ud_itab__138[] = {
  /*  0 */         125,           0,           0,           0,
};

static const uint16_t ud_itab__139[] = {
  /*  0 */         126,           0,           0,           0,
};

static const uint16_t ud_itab__140[] = {
  /*  0 */         127,           0,           0,           0,
};

static const uint16_t ud_itab__141[] = {
  /*  0 */         128,           0,           0,           0,
};

static const uint16_t ud_itab__142[] = {
  /*  0 */         129,           0,           0,           0,
};

static const uint16_t ud_itab__143[] = {
  /*  0 */         130,           0,           0,           0,
};

static const uint16_t ud_itab__144[] = {
  /*  0 */         131,           0,           0,           0,
};

static const uint16_t ud_itab__145[] = {
  /*  0 */         132,           0,           0,           0,
};

static const uint16_t ud_itab__146[] = {
  /*  0 */         133,           0,           0,         134,
};

static const uint16_t ud_itab__147[] = {
  /*  0 */         135,           0,           0,         136,
};

static const uint16_t ud_itab__148[] = {
  /*  0 */         137,         138,         139,         140,
};

static const uint16_t ud_itab__149[] = {
  /*  0 */         141,           0,           0,         142,
};

static const uint16_t ud_itab__150[] = {
  /*  0 */         143,         144,         145,         146,
};

static const uint16_t ud_itab__151[] = {
  /*  0 */         147,         148,         149,         150,
};

static const uint16_t ud_itab__152[] = {
  /*  0 */         151,           0,           0,         152,
};

static const uint16_t ud_itab__153[] = {
  /*  0 */         153,           0,           0,         154,
};

static const uint16_t ud_itab__154[] = {
  /*  0 */         155,           0,           0,           0,
};

static const uint16_t ud_itab__155[] = {
  /*  0 */         156,           0,           0,           0,
};

static const uint16_t ud_itab__156[] = {
  /*  0 */         157,           0,           0,           0,
};

static const uint16_t ud_itab__157[] = {
  /*  0 */         158,           0,           0,           0,
};

static const uint16_t ud_itab__160[] = {
  /*  0 */           0,         160,           0,
};

static const uint16_t ud_itab__159[] = {
  /*  0 */         159,  GROUP(160),
};

static const uint16_t ud_itab__158[] = {
  /*  0 */  GROUP(159),           0,           0,           0,
};

static const uint16_t ud_itab__163[] = {
  /*  0 */           0,         162,           0,
};

static const uint16_t ud_itab__162[] = {
  /*  0 */         161,  GROUP(163),
};

static const uint16_t ud_itab__161[] = {
  /*  0 */  GROUP(162),           0,           0,           0,
};

static const uint16_t ud_itab__164[] = {
  /*  0 */         163,           0,           0,           0,
};

static const uint16_t ud_itab__166[] = {
  /*  0 */         164,           0,           0,         165,
};

static const uint16_t ud_itab__167[] = {
  /*  0 */         166,           0,           0,         167,
};

static const uint16_t ud_itab__168[] = {
  /*  0 */         168,           0,           0,         169,
};

static const uint16_t ud_itab__169[] = {
  /*  0 */         170,           0,           0,         171,
};

static const uint16_t ud_itab__170[] = {
  /*  0 */         172,           0,           0,         173,
};

static const uint16_t ud_itab__171[] = {
  /*  0 */         174,           0,           0,         175,
};

static const uint16_t ud_itab__172[] = {
  /*  0 */         176,           0,           0,         177,
};

static const uint16_t ud_itab__173[] = {
  /*  0 */         178,           0,           0,         179,
};

static const uint16_t ud_itab__174[] = {
  /*  0 */         180,           0,           0,         181,
};

static const uint16_t ud_itab__175[] = {
  /*  0 */         182,           0,           0,         183,
};

static const uint16_t ud_itab__176[] = {
  /*  0 */         184,           0,           0,         185,
};

static const uint16_t ud_itab__177[] = {
  /*  0 */         186,           0,           0,         187,
};

static const uint16_t ud_itab__178[] = {
  /*  0 */           0,           0,           0,         188,
};

static const uint16_t ud_itab__179[] = {
  /*  0 */           0,           0,           0,         189,
};

static const uint16_t ud_itab__180[] = {
  /*  0 */           0,           0,           0,         190,
};

static const uint16_t ud_itab__181[] = {
  /*  0 */           0,           0,           0,         191,
};

static const uint16_t ud_itab__182[] = {
  /*  0 */         192,           0,           0,         193,
};

static const uint16_t ud_itab__183[] = {
  /*  0 */         194,           0,           0,         195,
};

static const uint16_t ud_itab__184[] = {
  /*  0 */         196,           0,           0,         197,
};

static const uint16_t ud_itab__185[] = {
  /*  0 */           0,           0,           0,         198,
};

static const uint16_t ud_itab__186[] = {
  /*  0 */           0,           0,           0,         199,
};

static const uint16_t ud_itab__187[] = {
  /*  0 */           0,           0,           0,         200,
};

static const uint16_t ud_itab__188[] = {
  /*  0 */           0,           0,           0,         201,
};

static const uint16_t ud_itab__189[] = {
  /*  0 */           0,           0,           0,         202,
};

static const uint16_t ud_itab__190[] = {
  /*  0 */           0,           0,           0,         203,
};

static const uint16_t ud_itab__191[] = {
  /*  0 */           0,           0,           0,         204,
};

static const uint16_t ud_itab__192[] = {
  /*  0 */           0,           0,           0,         205,
};

static const uint16_t ud_itab__193[] = {
  /*  0 */           0,           0,           0,         206,
};

static const uint16_t ud_itab__194[] = {
  /*  0 */           0,           0,           0,         207,
};

static const uint16_t ud_itab__195[] = {
  /*  0 */           0,           0,           0,         208,
};

static const uint16_t ud_itab__196[] = {
  /*  0 */           0,           0,           0,         209,
};

static const uint16_t ud_itab__197[] = {
  /*  0 */           0,           0,           0,         210,
};

static const uint16_t ud_itab__198[] = {
  /*  0 */           0,           0,           0,         211,
};

static const uint16_t ud_itab__199[] = {
  /*  0 */           0,           0,           0,         212,
};

static const uint16_t ud_itab__200[] = {
  /*  0 */           0,           0,           0,         213,
};

static const uint16_t ud_itab__201[] = {
  /*  0 */           0,           0,           0,         214,
};

static const uint16_t ud_itab__202[] = {
  /*  0 */           0,           0,           0,         215,
};

static const uint16_t ud_itab__203[] = {
  /*  0 */           0,           0,           0,         216,
};

static const uint16_t ud_itab__204[] = {
  /*  0 */           0,           0,           0,         217,
};

static const uint16_t ud_itab__205[] = {
  /*  0 */           0,           0,           0,         218,
};

static const uint16_t ud_itab__206[] = {
  /*  0 */           0,           0,           0,         219,
};

static const uint16_t ud_itab__207[] = {
  /*  0 */           0,           0,           0,         220,
};

static const uint16_t ud_itab__208[] = {
  /*  0 */           0,           0,           0,         221,
};

static const uint16_t ud_itab__209[] = {
  /*  0 */           0,           0,           0,         222,
};

static const uint16_t ud_itab__210[] = {
  /*  0 */           0,           0,           0,         223,
};

static const uint16_t ud_itab__211[] = {
  /*  0 */           0,           0,           0,         224,
};

static const uint16_t ud_itab__214[] = {
  /*  0 */           0,         225,           0,
};

static const uint16_t ud_itab__213[] = {
  /*  0 */           0,  GROUP(214),
};

static const uint16_t ud_itab__212[] = {
  /*  0 */           0,           0,           0,  GROUP(213),
};

static const uint16_t ud_itab__217[] = {
  /*  0 */           0,         226,           0,
};

static const uint16_t ud_itab__216[] = {
  /*  0 */           0,  GROUP(217),
};

static const uint16_t ud_itab__215[] = {
  /*  0 */           0,           0,           0,  GROUP(216),
};

static const uint16_t ud_itab__218[] = {
  /*  0 */           0,           0,           0,         227,
};

static const uint16_t ud_itab__219[] = {
  /*  0 */           0,           0,           0,         228,
};

static const uint16_t ud_itab__220[] = {
  /*  0 */           0,           0,           0,         229,
};

static const uint16_t ud_itab__221[] = {
  /*  0 */           0,           0,           0,         230,
};

static const uint16_t ud_itab__222[] = {
  /*  0 */           0,           0,           0,         231,
};

static const uint16_t ud_itab__223[] = {
  /*  0 */         232,         233,           0,           0,
};

static const uint16_t ud_itab__224[] = {
  /*  0 */         234,         235,           0,           0,
};

static const uint16_t ud_itab__165[] = {
  /*  0 */  GROUP(166),  GROUP(167),  GROUP(168),  GROUP(169),
  /*  4 */  GROUP(170),  GROUP(171),  GROUP(172),  GROUP(173),
  /*  8 */  GROUP(174),  GROUP(175),  GROUP(176),  GROUP(177),
  /*  c */           0,           0,           0,           0,
  /* 10 */  GROUP(178),           0,           0,           0,
  /* 14 */  GROUP(179),  GROUP(180),           0,  GROUP(181),
  /* 18 */           0,           0,           0,           0,
  /* 1c */  GROUP(182),  GROUP(183),  GROUP(184),           0,
  /* 20 */  GROUP(185),  GROUP(186),  GROUP(187),  GROUP(188),
  /* 24 */  GROUP(189),  GROUP(190),           0,           0,
  /* 28 */  GROUP(191),  GROUP(192),  GROUP(193),  GROUP(194),
  /* 2c */           0,           0,           0,           0,
  /* 30 */  GROUP(195),  GROUP(196),  GROUP(197),  GROUP(198),
  /* 34 */  GROUP(199),  GROUP(200),           0,  GROUP(201),
  /* 38 */  GROUP(202),  GROUP(203),  GROUP(204),  GROUP(205),
  /* 3c */  GROUP(206),  GROUP(207),  GROUP(208),  GROUP(209),
  /* 40 */  GROUP(210),  GROUP(211),           0,           0,
  /* 44 */           0,           0,           0,           0,
  /* 48 */           0,           0,           0,           0,
  /* 4c */           0,           0,           0,           0,
  /* 50 */           0,           0,           0,           0,
  /* 54 */           0,           0,           0,           0,
  /* 58 */           0,           0,           0,           0,
  /* 5c */           0,           0,           0,           0,
  /* 60 */           0,           0,           0,           0,
  /* 64 */           0,           0,           0,           0,
  /* 68 */           0,           0,           0,           0,
  /* 6c */           0,           0,           0,           0,
  /* 70 */           0,           0,           0,           0,
  /* 74 */           0,           0,           0,           0,
  /* 78 */           0,           0,           0,           0,
  /* 7c */           0,           0,           0,           0,
  /* 80 */  GROUP(212),  GROUP(215),           0,           0,
  /* 84 */           0,           0,           0,           0,
  /* 88 */           0,           0,           0,           0,
  /* 8c */           0,           0,           0,           0,
  /* 90 */           0,           0,           0,           0,
  /* 94 */           0,           0,           0,           0,
  /* 98 */           0,           0,           0,           0,
  /* 9c */           0,           0,           0,           0,
  /* a0 */           0,           0,           0,           0,
  /* a4 */           0,           0,           0,           0,
  /* a8 */           0,           0,           0,           0,
  /* ac */           0,           0,           0,           0,
  /* b0 */           0,           0,           0,           0,
  /* b4 */           0,           0,           0,           0,
  /* b8 */           0,           0,           0,           0,
  /* bc */           0,           0,           0,           0,
  /* c0 */           0,           0,           0,           0,
  /* c4 */           0,           0,           0,           0,
  /* c8 */           0,           0,           0,           0,
  /* cc */           0,           0,           0,           0,
  /* d0 */           0,           0,           0,           0,
  /* d4 */           0,           0,           0,           0,
  /* d8 */           0,           0,           0,  GROUP(218),
  /* dc */  GROUP(219),  GROUP(220),  GROUP(221),  GROUP(222),
  /* e0 */           0,           0,           0,           0,
  /* e4 */           0,           0,           0,           0,
  /* e8 */           0,           0,           0,           0,
  /* ec */           0,           0,           0,           0,
  /* f0 */  GROUP(223),  GROUP(224),           0,           0,
  /* f4 */           0,           0,           0,           0,
  /* f8 */           0,           0,           0,           0,
  /* fc */           0,           0,           0,           0,
};

static const uint16_t ud_itab__226[] = {
  /*  0 */           0,           0,           0,         236,
};

static const uint16_t ud_itab__227[] = {
  /*  0 */           0,           0,           0,         237,
};

static const uint16_t ud_itab__228[] = {
  /*  0 */           0,           0,           0,         238,
};

static const uint16_t ud_itab__229[] = {
  /*  0 */           0,           0,           0,         239,
};

static const uint16_t ud_itab__230[] = {
  /*  0 */           0,           0,           0,         240,
};

static const uint16_t ud_itab__231[] = {
  /*  0 */           0,           0,           0,         241,
};

static const uint16_t ud_itab__232[] = {
  /*  0 */           0,           0,           0,         242,
};

static const uint16_t ud_itab__233[] = {
  /*  0 */         243,           0,           0,         244,
};

static const uint16_t ud_itab__234[] = {
  /*  0 */           0,           0,           0,         245,
};

static const uint16_t ud_itab__235[] = {
  /*  0 */           0,           0,           0,         246,
};

static const uint16_t ud_itab__237[] = {
  /*  0 */         247,         248,         249,
};

static const uint16_t ud_itab__236[] = {
  /*  0 */           0,           0,           0,  GROUP(237),
};

static const uint16_t ud_itab__238[] = {
  /*  0 */           0,           0,           0,         250,
};

static const uint16_t ud_itab__239[] = {
  /*  0 */           0,           0,           0,         251,
};

static const uint16_t ud_itab__240[] = {
  /*  0 */           0,           0,           0,         252,
};

static const uint16_t ud_itab__242[] = {
  /*  0 */         253,         254,         255,
};

static const uint16_t ud_itab__241[] = {
  /*  0 */           0,           0,           0,  GROUP(242),
};

static const uint16_t ud_itab__243[] = {
  /*  0 */           0,           0,           0,         256,
};

static const uint16_t ud_itab__244[] = {
  /*  0 */           0,           0,           0,         257,
};

static const uint16_t ud_itab__245[] = {
  /*  0 */           0,           0,           0,         258,
};

static const uint16_t ud_itab__246[] = {
  /*  0 */           0,           0,           0,         259,
};

static const uint16_t ud_itab__247[] = {
  /*  0 */           0,           0,           0,         260,
};

static const uint16_t ud_itab__248[] = {
  /*  0 */           0,           0,           0,         261,
};

static const uint16_t ud_itab__249[] = {
  /*  0 */           0,           0,           0,         262,
};

static const uint16_t ud_itab__250[] = {
  /*  0 */           0,           0,           0,         263,
};

static const uint16_t ud_itab__251[] = {
  /*  0 */           0,           0,           0,         264,
};

static const uint16_t ud_itab__225[] = {
  /*  0 */           0,           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
  /*  8 */  GROUP(226),  GROUP(227),  GROUP(228),  GROUP(229),
  /*  c */  GROUP(230),  GROUP(231),  GROUP(232),  GROUP(233),
  /* 10 */           0,           0,           0,           0,
  /* 14 */  GROUP(234),  GROUP(235),  GROUP(236),  GROUP(238),
  /* 18 */           0,           0,           0,           0,
  /* 1c */           0,           0,           0,           0,
  /* 20 */  GROUP(239),  GROUP(240),  GROUP(241),           0,
  /* 24 */           0,           0,           0,           0,
  /* 28 */           0,           0,           0,           0,
  /* 2c */           0,           0,           0,           0,
  /* 30 */           0,           0,           0,           0,
  /* 34 */           0,           0,           0,           0,
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
  /* 40 */  GROUP(243),  GROUP(244),  GROUP(245),           0,
  /* 44 */  GROUP(246),           0,           0,           0,
  /* 48 */           0,           0,           0,           0,
  /* 4c */           0,           0,           0,           0,
  /* 50 */           0,           0,           0,           0,
  /* 54 */           0,           0,           0,           0,
  /* 58 */           0,           0,           0,           0,
  /* 5c */           0,           0,           0,           0,
  /* 60 */  GROUP(247),  GROUP(248),  GROUP(249),  GROUP(250),
  /* 64 */           0,           0,           0,           0,
  /* 68 */           0,           0,           0,           0,
  /* 6c */           0,           0,           0,           0,
  /* 70 */           0,           0,           0,           0,
  /* 74 */           0,           0,           0,           0,
  /* 78 */           0,           0,           0,           0,
  /* 7c */           0,           0,           0,           0,
  /* 80 */           0,           0,           0,           0,
  /* 84 */           0,           0,           0,           0,
  /* 88 */           0,           0,           0,           0,
  /* 8c */           0,           0,           0,           0,
  /* 90 */           0,           0,           0,           0,
  /* 94 */           0,           0,           0,           0,
  /* 98 */           0,           0,           0,           0,
  /* 9c */           0,           0,           0,           0,
  /* a0 */           0,           0,           0,           0,
  /* a4 */           0,           0,           0,           0,
  /* a8 */           0,           0,           0,           0,
  /* ac */           0,           0,           0,           0,
  /* b0 */           0,           0,           0,           0,
  /* b4 */           0,           0,           0,           0,
  /* b8 */           0,           0,           0,           0,
  /* bc */           0,           0,           0,           0,
  /* c0 */           0,           0,           0,           0,
  /* c4 */           0,           0,           0,           0,
  /* c8 */           0,           0,           0,           0,
  /* cc */           0,           0,           0,           0,
  /* d0 */           0,           0,           0,           0,
  /* d4 */           0,           0,           0,           0,
  /* d8 */           0,           0,           0,           0,
  /* dc */           0,           0,           0,  GROUP(251),
  /* e0 */           0,           0,           0,           0,
  /* e4 */           0,           0,           0,           0,
  /* e8 */           0,           0,           0,           0,
  /* ec */           0,           0,           0,           0,
  /* f0 */           0,           0,           0,           0,
  /* f4 */           0,           0,           0,           0,
  /* f8 */           0,           0,           0,           0,
  /* fc */           0,           0,           0,           0,
};

static const uint16_t ud_itab__252[] = {
  /*  0 */         265,           0,           0,           0,
};

static const uint16_t ud_itab__253[] = {
  /*  0 */         266,           0,           0,           0,
};

static const uint16_t ud_itab__254[] = {
  /*  0 */         267,           0,           0,           0,
};

static const uint16_t ud_itab__255[] = {
  /*  0 */         268,           0,           0,           0,
};

static const uint16_t ud_itab__256[] = {
  /*  0 */         269,           0,           0,           0,
};

static const uint16_t ud_itab__257[] = {
  /*  0 */         270,           0,           0,           0,
};

static const uint16_t ud_itab__258[] = {
  /*  0 */         271,           0,           0,           0,
};

static const uint16_t ud_itab__259[] = {
  /*  0 */         272,           0,           0,           0,
};

static const uint16_t ud_itab__260[] = {
  /*  0 */         273,           0,           0,           0,
};

static const uint16_t ud_itab__261[] = {
  /*  0 */         274,           0,           0,           0,
};

static const uint16_t ud_itab__262[] = {
  /*  0 */         275,           0,           0,           0,
};

static const uint16_t ud_itab__263[] = {
  /*  0 */         276,           0,           0,           0,
};

static const uint16_t ud_itab__264[] = {
  /*  0 */         277,           0,           0,           0,
};

static const uint16_t ud_itab__265[] = {
  /*  0 */         278,           0,           0,           0,
};

static const uint16_t ud_itab__266[] = {
  /*  0 */         279,           0,           0,           0,
};

static const uint16_t ud_itab__267[] = {
  /*  0 */         280,           0,           0,           0,
};

static const uint16_t ud_itab__268[] = {
  /*  0 */         281,           0,           0,         282,
};

static const uint16_t ud_itab__269[] = {
  /*  0 */         283,         284,         285,         286,
};

static const uint16_t ud_itab__270[] = {
  /*  0 */         287,           0,         288,           0,
};

static const uint16_t ud_itab__271[] = {
  /*  0 */         289,           0,         290,           0,
};

static const uint16_t ud_itab__272[] = {
  /*  0 */         291,           0,           0,         292,
};

static const uint16_t ud_itab__273[] = {
  /*  0 */         293,           0,           0,         294,
};

static const uint16_t ud_itab__274[] = {
  /*  0 */         295,           0,           0,         296,
};

static const uint16_t ud_itab__275[] = {
  /*  0 */         297,           0,           0,         298,
};

static const uint16_t ud_itab__276[] = {
  /*  0 */         299,         300,         301,         302,
};

static const uint16_t ud_itab__277[] = {
  /*  0 */         303,         304,         305,         306,
};

static const uint16_t ud_itab__278[] = {
  /*  0 */         307,         308,         309,         310,
};

static const uint16_t ud_itab__279[] = {
  /*  0 */         311,           0,         312,         313,
};

static const uint16_t ud_itab__280[] = {
  /*  0 */         314,         315,         316,         317,
};

static const uint16_t ud_itab__281[] = {
  /*  0 */         318,         319,         320,         321,
};

static const uint16_t ud_itab__282[] = {
  /*  0 */         322,         323,         324,         325,
};

static const uint16_t ud_itab__283[] = {
  /*  0 */         326,         327,         328,         329,
};

static const uint16_t ud_itab__284[] = {
  /*  0 */         330,           0,           0,         331,
};

static const uint16_t ud_itab__285[] = {
  /*  0 */         332,           0,           0,         333,
};

static const uint16_t ud_itab__286[] = {
  /*  0 */         334,           0,           0,         335,
};

static const uint16_t ud_itab__287[] = {
  /*  0 */         336,           0,           0,         337,
};

static const uint16_t ud_itab__288[] = {
  /*  0 */         338,           0,           0,         339,
};

static const uint16_t ud_itab__289[] = {
  /*  0 */         340,           0,           0,         341,
};

static const uint16_t ud_itab__290[] = {
  /*  0 */         342,           0,           0,         343,
};

static const uint16_t ud_itab__291[] = {
  /*  0 */         344,           0,           0,         345,
};

static const uint16_t ud_itab__292[] = {
  /*  0 */         346,           0,           0,         347,
};

static const uint16_t ud_itab__293[] = {
  /*  0 */         348,           0,           0,         349,
};

static const uint16_t ud_itab__294[] = {
  /*  0 */         350,           0,           0,         351,
};

static const uint16_t ud_itab__295[] = {
  /*  0 */         352,           0,           0,         353,
};

static const uint16_t ud_itab__296[] = {
  /*  0 */           0,           0,           0,         354,
};

static const uint16_t ud_itab__297[] = {
  /*  0 */           0,           0,           0,         355,
};

static const uint16_t ud_itab__298[] = {
  /*  0 */         356,           0,           0,         357,
};

static const uint16_t ud_itab__299[] = {
  /*  0 */         358,           0,         359,         360,
};

static const uint16_t ud_itab__300[] = {
  /*  0 */         361,         362,         363,         364,
};

static const uint16_t ud_itab__302[] = {
  /*  0 */         365,           0,           0,         366,
};

static const uint16_t ud_itab__303[] = {
  /*  0 */         367,           0,           0,         368,
};

static const uint16_t ud_itab__304[] = {
  /*  0 */         369,           0,           0,         370,
};

static const uint16_t ud_itab__301[] = {
  /*  0 */           0,           0,  GROUP(302),           0,
  /*  4 */  GROUP(303),           0,  GROUP(304),           0,
};

static const uint16_t ud_itab__306[] = {
  /*  0 */         371,           0,           0,         372,
};

static const uint16_t ud_itab__307[] = {
  /*  0 */         373,           0,           0,         374,
};

static const uint16_t ud_itab__308[] = {
  /*  0 */         375,           0,           0,         376,
};

static const uint16_t ud_itab__305[] = {
  /*  0 */           0,           0,  GROUP(306),           0,
  /*  4 */  GROUP(307),           0,  GROUP(308),           0,
};

static const uint16_t ud_itab__310[] = {
  /*  0 */         377,           0,           0,         378,
};

static const uint16_t ud_itab__311[] = {
  /*  0 */           0,           0,           0,         379,
};

static const uint16_t ud_itab__312[] = {
  /*  0 */         380,           0,           0,         381,
};

static const uint16_t ud_itab__313[] = {
  /*  0 */           0,           0,           0,         382,
};

static const uint16_t ud_itab__309[] = {
  /*  0 */           0,           0,  GROUP(310),  GROUP(311),
  /*  4 */           0,           0,  GROUP(312),  GROUP(313),
};

static const uint16_t ud_itab__314[] = {
  /*  0 */         383,           0,           0,         384,
};

static const uint16_t ud_itab__315[] = {
  /*  0 */         385,           0,           0,         386,
};

static const uint16_t ud_itab__316[] = {
  /*  0 */         387,           0,           0,         388,
};

static const uint16_t ud_itab__317[] = {
  /*  0 */         389,           0,           0,           0,
};

static const uint16_t ud_itab__319[] = {
  /*  0 */           0,         390,           0,
};

static const uint16_t ud_itab__318[] = {
  /*  0 */  GROUP(319),           0,           0,           0,
};

static const uint16_t ud_itab__321[] = {
  /*  0 */           0,         391,           0,
};

static const uint16_t ud_itab__320[] = {
  /*  0 */  GROUP(321),           0,           0,           0,
};

static const uint16_t ud_itab__322[] = {
  /*  0 */           0,         392,           0,         393,
};

static const uint16_t ud_itab__323[] = {
  /*  0 */           0,         394,           0,         395,
};

static const uint16_t ud_itab__324[] = {
  /*  0 */         396,           0,         397,         398,
};

static const uint16_t ud_itab__325[] = {
  /*  0 */         399,           0,         400,         401,
};

static const uint16_t ud_itab__326[] = {
  /*  0 */         402,           0,           0,           0,
};

static const uint16_t ud_itab__327[] = {
  /*  0 */         403,           0,           0,           0,
};

static const uint16_t ud_itab__328[] = {
  /*  0 */         404,           0,           0,           0,
};

static const uint16_t ud_itab__329[] = {
  /*  0 */         405,           0,           0,           0,
};

static const uint16_t ud_itab__330[] = {
  /*  0 */         406,           0,           0,           0,
};

static const uint16_t ud_itab__331[] = {
  /*  0 */         407,           0,           0,           0,
};

static const uint16_t ud_itab__332[] = {
  /*  0 */         408,           0,           0,           0,
};

static const uint16_t ud_itab__333[] = {
  /*  0 */         409,           0,           0,           0,
};

static const uint16_t ud_itab__334[] = {
  /*  0 */         410,           0,           0,           0,
};

static const uint16_t ud_itab__335[] = {
  /*  0 */         411,           0,           0,           0,
};

static const uint16_t ud_itab__336[] = {
  /*  0 */         412,           0,           0,           0,
};

static const uint16_t ud_itab__337[] = {
  /*  0 */         413,           0,           0,           0,
};

static const uint16_t ud_itab__338[] = {
  /*  0 */         414,           0,           0,           0,
};

static const uint16_t ud_itab__339[] = {
  /*  0 */         415,           0,           0,           0,
};

static const uint16_t ud_itab__340[] = {
  /*  0 */         416,           0,           0,           0,
};

static const uint16_t ud_itab__341[] = {
  /*  0 */         417,           0,           0,           0,
};

static const uint16_t ud_itab__342[] = {
  /*  0 */         418,           0,           0,           0,
};

static const uint16_t ud_itab__343[] = {
  /*  0 */         419,           0,           0,           0,
};

static const uint16_t ud_itab__344[] = {
  /*  0 */         420,           0,           0,           0,
};

static const uint16_t ud_itab__345[] = {
  /*  0 */         421,           0,           0,           0,
};

static const uint16_t ud_itab__346[] = {
  /*  0 */         422,           0,           0,           0,
};

static const uint16_t ud_itab__347[] = {
  /*  0 */         423,           0,           0,           0,
};

static const uint16_t ud_itab__348[] = {
  /*  0 */         424,           0,           0,           0,
};

static const uint16_t ud_itab__349[] = {
  /*  0 */         425,           0,           0,           0,
};

static const uint16_t ud_itab__350[] = {
  /*  0 */         426,           0,           0,           0,
};

static const uint16_t ud_itab__351[] = {
  /*  0 */         427,           0,           0,           0,
};

static const uint16_t ud_itab__352[] = {
  /*  0 */         428,           0,           0,           0,
};

static const uint16_t ud_itab__353[] = {
  /*  0 */         429,           0,           0,           0,
};

static const uint16_t ud_itab__354[] = {
  /*  0 */         430,           0,           0,           0,
};

static const uint16_t ud_itab__355[] = {
  /*  0 */         431,           0,           0,           0,
};

static const uint16_t ud_itab__356[] = {
  /*  0 */         432,           0,           0,           0,
};

static const uint16_t ud_itab__357[] = {
  /*  0 */         433,           0,           0,           0,
};

static const uint16_t ud_itab__358[] = {
  /*  0 */         434,           0,           0,           0,
};

static const uint16_t ud_itab__359[] = {
  /*  0 */         435,           0,           0,           0,
};

static const uint16_t ud_itab__360[] = {
  /*  0 */         436,           0,           0,           0,
};

static const uint16_t ud_itab__361[] = {
  /*  0 */         437,           0,           0,           0,
};

static const uint16_t ud_itab__362[] = {
  /*  0 */         438,           0,           0,           0,
};

static const uint16_t ud_itab__363[] = {
  /*  0 */         439,           0,           0,           0,
};

static const uint16_t ud_itab__368[] = {
  /*  0 */           0,         440,
};

static const uint16_t ud_itab__367[] = {
  /*  0 */  GROUP(368),           0,           0,           0,
};

static const uint16_t ud_itab__366[] = {
  /*  0 */  GROUP(367),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__371[] = {
  /*  0 */           0,         441,
};

static const uint16_t ud_itab__370[] = {
  /*  0 */  GROUP(371),           0,           0,           0,
};

static const uint16_t ud_itab__369[] = {
  /*  0 */  GROUP(370),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__374[] = {
  /*  0 */           0,         442,
};

static const uint16_t ud_itab__373[] = {
  /*  0 */  GROUP(374),           0,           0,           0,
};

static const uint16_t ud_itab__372[] = {
  /*  0 */  GROUP(373),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__365[] = {
  /*  0 */  GROUP(366),  GROUP(369),  GROUP(372),           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__364[] = {
  /*  0 */           0,  GROUP(365),
};

static const uint16_t ud_itab__379[] = {
  /*  0 */           0,         443,
};

static const uint16_t ud_itab__378[] = {
  /*  0 */  GROUP(379),           0,           0,           0,
};

static const uint16_t ud_itab__377[] = {
  /*  0 */  GROUP(378),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__382[] = {
  /*  0 */           0,         444,
};

static const uint16_t ud_itab__381[] = {
  /*  0 */  GROUP(382),           0,           0,           0,
};

static const uint16_t ud_itab__380[] = {
  /*  0 */  GROUP(381),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__385[] = {
  /*  0 */           0,         445,
};

static const uint16_t ud_itab__384[] = {
  /*  0 */  GROUP(385),           0,           0,           0,
};

static const uint16_t ud_itab__383[] = {
  /*  0 */  GROUP(384),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__388[] = {
  /*  0 */           0,         446,
};

static const uint16_t ud_itab__387[] = {
  /*  0 */  GROUP(388),           0,           0,           0,
};

static const uint16_t ud_itab__386[] = {
  /*  0 */  GROUP(387),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__391[] = {
  /*  0 */           0,         447,
};

static const uint16_t ud_itab__390[] = {
  /*  0 */  GROUP(391),           0,           0,           0,
};

static const uint16_t ud_itab__389[] = {
  /*  0 */  GROUP(390),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__394[] = {
  /*  0 */           0,         448,
};

static const uint16_t ud_itab__393[] = {
  /*  0 */  GROUP(394),           0,           0,           0,
};

static const uint16_t ud_itab__392[] = {
  /*  0 */  GROUP(393),           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__376[] = {
  /*  0 */  GROUP(377),  GROUP(380),  GROUP(383),  GROUP(386),
  /*  4 */  GROUP(389),  GROUP(392),           0,           0,
};

static const uint16_t ud_itab__375[] = {
  /*  0 */           0,  GROUP(376),
};

static const uint16_t ud_itab__395[] = {
  /*  0 */         449,           0,           0,           0,
};

static const uint16_t ud_itab__396[] = {
  /*  0 */         450,           0,           0,           0,
};

static const uint16_t ud_itab__397[] = {
  /*  0 */         451,           0,           0,           0,
};

static const uint16_t ud_itab__398[] = {
  /*  0 */         452,           0,           0,           0,
};

static const uint16_t ud_itab__399[] = {
  /*  0 */         453,           0,           0,           0,
};

static const uint16_t ud_itab__400[] = {
  /*  0 */         454,           0,           0,           0,
};

static const uint16_t ud_itab__404[] = {
  /*  0 */         455,           0,
};

static const uint16_t ud_itab__403[] = {
  /*  0 */  GROUP(404),           0,           0,           0,
};

static const uint16_t ud_itab__406[] = {
  /*  0 */         456,           0,
};

static const uint16_t ud_itab__405[] = {
  /*  0 */  GROUP(406),           0,           0,           0,
};

static const uint16_t ud_itab__408[] = {
  /*  0 */         457,           0,
};

static const uint16_t ud_itab__407[] = {
  /*  0 */  GROUP(408),           0,           0,           0,
};

static const uint16_t ud_itab__410[] = {
  /*  0 */         458,           0,
};

static const uint16_t ud_itab__409[] = {
  /*  0 */  GROUP(410),           0,           0,           0,
};

static const uint16_t ud_itab__412[] = {
  /*  0 */         459,           0,
};

static const uint16_t ud_itab__411[] = {
  /*  0 */  GROUP(412),           0,           0,           0,
};

static const uint16_t ud_itab__414[] = {
  /*  0 */         460,           0,
};

static const uint16_t ud_itab__413[] = {
  /*  0 */  GROUP(414),           0,           0,           0,
};

static const uint16_t ud_itab__416[] = {
  /*  0 */         461,           0,
};

static const uint16_t ud_itab__415[] = {
  /*  0 */  GROUP(416),           0,           0,           0,
};

static const uint16_t ud_itab__402[] = {
  /*  0 */  GROUP(403),  GROUP(405),  GROUP(407),  GROUP(409),
  /*  4 */  GROUP(411),  GROUP(413),           0,  GROUP(415),
};

static const uint16_t ud_itab__420[] = {
  /*  0 */           0,         462,
};

static const uint16_t ud_itab__419[] = {
  /*  0 */  GROUP(420),           0,           0,           0,
};

static const uint16_t ud_itab__422[] = {
  /*  0 */           0,         463,
};

static const uint16_t ud_itab__421[] = {
  /*  0 */  GROUP(422),           0,           0,           0,
};

static const uint16_t ud_itab__424[] = {
  /*  0 */           0,         464,
};

static const uint16_t ud_itab__423[] = {
  /*  0 */  GROUP(424),           0,           0,           0,
};

static const uint16_t ud_itab__426[] = {
  /*  0 */           0,         465,
};

static const uint16_t ud_itab__425[] = {
  /*  0 */  GROUP(426),           0,           0,           0,
};

static const uint16_t ud_itab__428[] = {
  /*  0 */           0,         466,
};

static const uint16_t ud_itab__427[] = {
  /*  0 */  GROUP(428),           0,           0,           0,
};

static const uint16_t ud_itab__430[] = {
  /*  0 */           0,         467,
};

static const uint16_t ud_itab__429[] = {
  /*  0 */  GROUP(430),           0,           0,           0,
};

static const uint16_t ud_itab__432[] = {
  /*  0 */           0,         468,
};

static const uint16_t ud_itab__431[] = {
  /*  0 */  GROUP(432),           0,           0,           0,
};

static const uint16_t ud_itab__434[] = {
  /*  0 */           0,         469,
};

static const uint16_t ud_itab__433[] = {
  /*  0 */  GROUP(434),           0,           0,           0,
};

static const uint16_t ud_itab__418[] = {
  /*  0 */  GROUP(419),  GROUP(421),  GROUP(423),  GROUP(425),
  /*  4 */  GROUP(427),  GROUP(429),  GROUP(431),  GROUP(433),
};

static const uint16_t ud_itab__437[] = {
  /*  0 */           0,         470,
};

static const uint16_t ud_itab__436[] = {
  /*  0 */  GROUP(437),           0,           0,           0,
};

static const uint16_t ud_itab__439[] = {
  /*  0 */           0,         471,
};

static const uint16_t ud_itab__438[] = {
  /*  0 */  GROUP(439),           0,           0,           0,
};

static const uint16_t ud_itab__441[] = {
  /*  0 */           0,         472,
};

static const uint16_t ud_itab__440[] = {
  /*  0 */  GROUP(441),           0,           0,           0,
};

static const uint16_t ud_itab__443[] = {
  /*  0 */           0,         473,
};

static const uint16_t ud_itab__442[] = {
  /*  0 */  GROUP(443),           0,           0,           0,
};

static const uint16_t ud_itab__445[] = {
  /*  0 */           0,         474,
};

static const uint16_t ud_itab__444[] = {
  /*  0 */  GROUP(445),           0,           0,           0,
};

static const uint16_t ud_itab__447[] = {
  /*  0 */           0,         475,
};

static const uint16_t ud_itab__446[] = {
  /*  0 */  GROUP(447),           0,           0,           0,
};

static const uint16_t ud_itab__449[] = {
  /*  0 */           0,         476,
};

static const uint16_t ud_itab__448[] = {
  /*  0 */  GROUP(449),           0,           0,           0,
};

static const uint16_t ud_itab__451[] = {
  /*  0 */           0,         477,
};

static const uint16_t ud_itab__450[] = {
  /*  0 */  GROUP(451),           0,           0,           0,
};

static const uint16_t ud_itab__435[] = {
  /*  0 */  GROUP(436),  GROUP(438),  GROUP(440),  GROUP(442),
  /*  4 */  GROUP(444),  GROUP(446),  GROUP(448),  GROUP(450),
};

static const uint16_t ud_itab__454[] = {
  /*  0 */           0,         478,
};

static const uint16_t ud_itab__453[] = {
  /*  0 */  GROUP(454),           0,           0,           0,
};

static const uint16_t ud_itab__456[] = {
  /*  0 */           0,         479,
};

static const uint16_t ud_itab__455[] = {
  /*  0 */  GROUP(456),           0,           0,           0,
};

static const uint16_t ud_itab__458[] = {
  /*  0 */           0,         480,
};

static const uint16_t ud_itab__457[] = {
  /*  0 */  GROUP(458),           0,           0,           0,
};

static const uint16_t ud_itab__460[] = {
  /*  0 */           0,         481,
};

static const uint16_t ud_itab__459[] = {
  /*  0 */  GROUP(460),           0,           0,           0,
};

static const uint16_t ud_itab__462[] = {
  /*  0 */           0,         482,
};

static const uint16_t ud_itab__461[] = {
  /*  0 */  GROUP(462),           0,           0,           0,
};

static const uint16_t ud_itab__464[] = {
  /*  0 */           0,         483,
};

static const uint16_t ud_itab__463[] = {
  /*  0 */  GROUP(464),           0,           0,           0,
};

static const uint16_t ud_itab__466[] = {
  /*  0 */           0,         484,
};

static const uint16_t ud_itab__465[] = {
  /*  0 */  GROUP(466),           0,           0,           0,
};

static const uint16_t ud_itab__468[] = {
  /*  0 */           0,         485,
};

static const uint16_t ud_itab__467[] = {
  /*  0 */  GROUP(468),           0,           0,           0,
};

static const uint16_t ud_itab__452[] = {
  /*  0 */  GROUP(453),  GROUP(455),  GROUP(457),  GROUP(459),
  /*  4 */  GROUP(461),  GROUP(463),  GROUP(465),  GROUP(467),
};

static const uint16_t ud_itab__417[] = {
  /*  0 */           0,           0,           0,           0,
  /*  4 */           0,  GROUP(418),  GROUP(435),  GROUP(452),
};

static const uint16_t ud_itab__401[] = {
  /*  0 */  GROUP(402),  GROUP(417),
};

static const uint16_t ud_itab__469[] = {
  /*  0 */         486,           0,           0,           0,
};

static const uint16_t ud_itab__470[] = {
  /*  0 */         487,           0,           0,           0,
};

static const uint16_t ud_itab__471[] = {
  /*  0 */         488,           0,           0,           0,
};

static const uint16_t ud_itab__472[] = {
  /*  0 */         489,           0,           0,           0,
};

static const uint16_t ud_itab__473[] = {
  /*  0 */         490,           0,           0,           0,
};

static const uint16_t ud_itab__474[] = {
  /*  0 */         491,           0,           0,           0,
};

static const uint16_t ud_itab__475[] = {
  /*  0 */         492,           0,           0,           0,
};

static const uint16_t ud_itab__476[] = {
  /*  0 */         493,           0,           0,           0,
};

static const uint16_t ud_itab__477[] = {
  /*  0 */         494,           0,           0,           0,
};

static const uint16_t ud_itab__478[] = {
  /*  0 */           0,           0,         495,           0,
};

static const uint16_t ud_itab__480[] = {
  /*  0 */         496,           0,           0,           0,
};

static const uint16_t ud_itab__481[] = {
  /*  0 */         497,           0,           0,           0,
};

static const uint16_t ud_itab__482[] = {
  /*  0 */         498,           0,           0,           0,
};

static const uint16_t ud_itab__483[] = {
  /*  0 */         499,           0,           0,           0,
};

static const uint16_t ud_itab__479[] = {
  /*  0 */           0,           0,           0,           0,
  /*  4 */  GROUP(480),  GROUP(481),  GROUP(482),  GROUP(483),
};

static const uint16_t ud_itab__484[] = {
  /*  0 */         500,           0,           0,           0,
};

static const uint16_t ud_itab__485[] = {
  /*  0 */         501,           0,           0,           0,
};

static const uint16_t ud_itab__486[] = {
  /*  0 */         502,           0,           0,           0,
};

static const uint16_t ud_itab__487[] = {
  /*  0 */         503,           0,           0,           0,
};

static const uint16_t ud_itab__488[] = {
  /*  0 */         504,           0,           0,           0,
};

static const uint16_t ud_itab__489[] = {
  /*  0 */         505,           0,           0,           0,
};

static const uint16_t ud_itab__490[] = {
  /*  0 */         506,           0,           0,           0,
};

static const uint16_t ud_itab__491[] = {
  /*  0 */         507,         508,         509,         510,
};

static const uint16_t ud_itab__492[] = {
  /*  0 */         511,           0,           0,           0,
};

static const uint16_t ud_itab__493[] = {
  /*  0 */         512,           0,           0,         513,
};

static const uint16_t ud_itab__494[] = {
  /*  0 */         514,           0,           0,         515,
};

static const uint16_t ud_itab__495[] = {
  /*  0 */         516,           0,           0,         517,
};

static const uint16_t ud_itab__498[] = {
  /*  0 */         518,         519,         520,
};

static const uint16_t ud_itab__497[] = {
  /*  0 */  GROUP(498),           0,           0,           0,
};

static const uint16_t ud_itab__500[] = {
  /*  0 */           0,         521,           0,
};

static const uint16_t ud_itab__501[] = {
  /*  0 */           0,         522,           0,
};

static const uint16_t ud_itab__502[] = {
  /*  0 */           0,         523,           0,
};

static const uint16_t ud_itab__499[] = {
  /*  0 */  GROUP(500),           0,  GROUP(501),  GROUP(502),
};

static const uint16_t ud_itab__504[] = {
  /*  0 */           0,         524,           0,
};

static const uint16_t ud_itab__503[] = {
  /*  0 */  GROUP(504),           0,           0,           0,
};

static const uint16_t ud_itab__496[] = {
  /*  0 */           0,  GROUP(497),           0,           0,
  /*  4 */           0,           0,  GROUP(499),  GROUP(503),
};

static const uint16_t ud_itab__505[] = {
  /*  0 */         525,           0,           0,           0,
};

static const uint16_t ud_itab__506[] = {
  /*  0 */         526,           0,           0,           0,
};

static const uint16_t ud_itab__507[] = {
  /*  0 */         527,           0,           0,           0,
};

static const uint16_t ud_itab__508[] = {
  /*  0 */         528,           0,           0,           0,
};

static const uint16_t ud_itab__509[] = {
  /*  0 */         529,           0,           0,           0,
};

static const uint16_t ud_itab__510[] = {
  /*  0 */         530,           0,           0,           0,
};

static const uint16_t ud_itab__511[] = {
  /*  0 */         531,           0,           0,           0,
};

static const uint16_t ud_itab__512[] = {
  /*  0 */         532,           0,           0,           0,
};

static const uint16_t ud_itab__513[] = {
  /*  0 */           0,         533,           0,         534,
};

static const uint16_t ud_itab__514[] = {
  /*  0 */         535,           0,           0,         536,
};

static const uint16_t ud_itab__515[] = {
  /*  0 */         537,           0,           0,         538,
};

static const uint16_t ud_itab__516[] = {
  /*  0 */         539,           0,           0,         540,
};

static const uint16_t ud_itab__517[] = {
  /*  0 */         541,           0,           0,         542,
};

static const uint16_t ud_itab__518[] = {
  /*  0 */         543,           0,           0,         544,
};

static const uint16_t ud_itab__519[] = {
  /*  0 */           0,         545,         546,         547,
};

static const uint16_t ud_itab__520[] = {
  /*  0 */         548,           0,           0,         549,
};

static const uint16_t ud_itab__521[] = {
  /*  0 */         550,           0,           0,         551,
};

static const uint16_t ud_itab__522[] = {
  /*  0 */         552,           0,           0,         553,
};

static const uint16_t ud_itab__523[] = {
  /*  0 */         554,           0,           0,         555,
};

static const uint16_t ud_itab__524[] = {
  /*  0 */         556,           0,           0,         557,
};

static const uint16_t ud_itab__525[] = {
  /*  0 */         558,           0,           0,         559,
};

static const uint16_t ud_itab__526[] = {
  /*  0 */         560,           0,           0,         561,
};

static const uint16_t ud_itab__527[] = {
  /*  0 */         562,           0,           0,         563,
};

static const uint16_t ud_itab__528[] = {
  /*  0 */         564,           0,           0,         565,
};

static const uint16_t ud_itab__529[] = {
  /*  0 */         566,           0,           0,         567,
};

static const uint16_t ud_itab__530[] = {
  /*  0 */         568,           0,           0,         569,
};

static const uint16_t ud_itab__531[] = {
  /*  0 */         570,           0,           0,         571,
};

static const uint16_t ud_itab__532[] = {
  /*  0 */         572,           0,           0,         573,
};

static const uint16_t ud_itab__533[] = {
  /*  0 */         574,           0,           0,         575,
};

static const uint16_t ud_itab__534[] = {
  /*  0 */         576,           0,           0,         577,
};

static const uint16_t ud_itab__535[] = {
  /*  0 */           0,         578,         579,         580,
};

static const uint16_t ud_itab__536[] = {
  /*  0 */         581,           0,           0,         582,
};

static const uint16_t ud_itab__537[] = {
  /*  0 */         583,           0,           0,         584,
};

static const uint16_t ud_itab__538[] = {
  /*  0 */         585,           0,           0,         586,
};

static const uint16_t ud_itab__539[] = {
  /*  0 */         587,           0,           0,         588,
};

static const uint16_t ud_itab__540[] = {
  /*  0 */         589,           0,           0,         590,
};

static const uint16_t ud_itab__541[] = {
  /*  0 */         591,           0,           0,         592,
};

static const uint16_t ud_itab__542[] = {
  /*  0 */         593,           0,           0,         594,
};

static const uint16_t ud_itab__543[] = {
  /*  0 */         595,           0,           0,         596,
};

static const uint16_t ud_itab__544[] = {
  /*  0 */         597,           0,           0,         598,
};

static const uint16_t ud_itab__545[] = {
  /*  0 */           0,         599,           0,           0,
};

static const uint16_t ud_itab__546[] = {
  /*  0 */         600,           0,           0,         601,
};

static const uint16_t ud_itab__547[] = {
  /*  0 */         602,           0,           0,         603,
};

static const uint16_t ud_itab__548[] = {
  /*  0 */         604,           0,           0,         605,
};

static const uint16_t ud_itab__549[] = {
  /*  0 */         606,           0,           0,         607,
};

static const uint16_t ud_itab__550[] = {
  /*  0 */         608,           0,           0,         609,
};

static const uint16_t ud_itab__551[] = {
  /*  0 */         610,           0,           0,         611,
};

static const uint16_t ud_itab__554[] = {
  /*  0 */           0,         612,
};

static const uint16_t ud_itab__555[] = {
  /*  0 */           0,         613,
};

static const uint16_t ud_itab__553[] = {
  /*  0 */  GROUP(554),           0,           0,  GROUP(555),
};

static const uint16_t ud_itab__552[] = {
  /*  0 */           0,  GROUP(553),
};

static const uint16_t ud_itab__556[] = {
  /*  0 */         614,           0,           0,         615,
};

static const uint16_t ud_itab__557[] = {
  /*  0 */         616,           0,           0,         617,
};

static const uint16_t ud_itab__558[] = {
  /*  0 */         618,           0,           0,         619,
};

static const uint16_t ud_itab__559[] = {
  /*  0 */         620,           0,           0,         621,
};

static const uint16_t ud_itab__560[] = {
  /*  0 */         622,           0,           0,         623,
};

static const uint16_t ud_itab__561[] = {
  /*  0 */         624,           0,           0,         625,
};

static const uint16_t ud_itab__562[] = {
  /*  0 */         626,           0,           0,         627,
};

static const uint16_t ud_itab__4[] = {
  /*  0 */    GROUP(5),   GROUP(12),   GROUP(87),   GROUP(88),
  /*  4 */           0,   GROUP(89),   GROUP(90),   GROUP(91),
  /*  8 */   GROUP(92),   GROUP(93),           0,   GROUP(94),
  /*  c */           0,   GROUP(95),  GROUP(104),  GROUP(105),
  /* 10 */  GROUP(106),  GROUP(107),  GROUP(108),  GROUP(118),
  /* 14 */  GROUP(119),  GROUP(120),  GROUP(121),  GROUP(129),
  /* 18 */  GROUP(130),  GROUP(135),  GROUP(136),  GROUP(137),
  /* 1c */  GROUP(138),  GROUP(139),  GROUP(140),  GROUP(141),
  /* 20 */  GROUP(142),  GROUP(143),  GROUP(144),  GROUP(145),
  /* 24 */           0,           0,           0,           0,
  /* 28 */  GROUP(146),  GROUP(147),  GROUP(148),  GROUP(149),
  /* 2c */  GROUP(150),  GROUP(151),  GROUP(152),  GROUP(153),
  /* 30 */  GROUP(154),  GROUP(155),  GROUP(156),  GROUP(157),
  /* 34 */  GROUP(158),  GROUP(161),           0,  GROUP(164),
  /* 38 */  GROUP(165),           0,  GROUP(225),           0,
  /* 3c */           0,           0,           0,           0,
  /* 40 */  GROUP(252),  GROUP(253),  GROUP(254),  GROUP(255),
  /* 44 */  GROUP(256),  GROUP(257),  GROUP(258),  GROUP(259),
  /* 48 */  GROUP(260),  GROUP(261),  GROUP(262),  GROUP(263),
  /* 4c */  GROUP(264),  GROUP(265),  GROUP(266),  GROUP(267),
  /* 50 */  GROUP(268),  GROUP(269),  GROUP(270),  GROUP(271),
  /* 54 */  GROUP(272),  GROUP(273),  GROUP(274),  GROUP(275),
  /* 58 */  GROUP(276),  GROUP(277),  GROUP(278),  GROUP(279),
  /* 5c */  GROUP(280),  GROUP(281),  GROUP(282),  GROUP(283),
  /* 60 */  GROUP(284),  GROUP(285),  GROUP(286),  GROUP(287),
  /* 64 */  GROUP(288),  GROUP(289),  GROUP(290),  GROUP(291),
  /* 68 */  GROUP(292),  GROUP(293),  GROUP(294),  GROUP(295),
  /* 6c */  GROUP(296),  GROUP(297),  GROUP(298),  GROUP(299),
  /* 70 */  GROUP(300),  GROUP(301),  GROUP(305),  GROUP(309),
  /* 74 */  GROUP(314),  GROUP(315),  GROUP(316),  GROUP(317),
  /* 78 */  GROUP(318),  GROUP(320),           0,           0,
  /* 7c */  GROUP(322),  GROUP(323),  GROUP(324),  GROUP(325),
  /* 80 */  GROUP(326),  GROUP(327),  GROUP(328),  GROUP(329),
  /* 84 */  GROUP(330),  GROUP(331),  GROUP(332),  GROUP(333),
  /* 88 */  GROUP(334),  GROUP(335),  GROUP(336),  GROUP(337),
  /* 8c */  GROUP(338),  GROUP(339),  GROUP(340),  GROUP(341),
  /* 90 */  GROUP(342),  GROUP(343),  GROUP(344),  GROUP(345),
  /* 94 */  GROUP(346),  GROUP(347),  GROUP(348),  GROUP(349),
  /* 98 */  GROUP(350),  GROUP(351),  GROUP(352),  GROUP(353),
  /* 9c */  GROUP(354),  GROUP(355),  GROUP(356),  GROUP(357),
  /* a0 */  GROUP(358),  GROUP(359),  GROUP(360),  GROUP(361),
  /* a4 */  GROUP(362),  GROUP(363),  GROUP(364),  GROUP(375),
  /* a8 */  GROUP(395),  GROUP(396),  GROUP(397),  GROUP(398),
  /* ac */  GROUP(399),  GROUP(400),  GROUP(401),  GROUP(469),
  /* b0 */  GROUP(470),  GROUP(471),  GROUP(472),  GROUP(473),
  /* b4 */  GROUP(474),  GROUP(475),  GROUP(476),  GROUP(477),
  /* b8 */  GROUP(478),           0,  GROUP(479),  GROUP(484),
  /* bc */  GROUP(485),  GROUP(486),  GROUP(487),  GROUP(488),
  /* c0 */  GROUP(489),  GROUP(490),  GROUP(491),  GROUP(492),
  /* c4 */  GROUP(493),  GROUP(494),  GROUP(495),  GROUP(496),
  /* c8 */  GROUP(505),  GROUP(506),  GROUP(507),  GROUP(508),
  /* cc */  GROUP(509),  GROUP(510),  GROUP(511),  GROUP(512),
  /* d0 */  GROUP(513),  GROUP(514),  GROUP(515),  GROUP(516),
  /* d4 */  GROUP(517),  GROUP(518),  GROUP(519),  GROUP(520),
  /* d8 */  GROUP(521),  GROUP(522),  GROUP(523),  GROUP(524),
  /* dc */  GROUP(525),  GROUP(526),  GROUP(527),  GROUP(528),
  /* e0 */  GROUP(529),  GROUP(530),  GROUP(531),  GROUP(532),
  /* e4 */  GROUP(533),  GROUP(534),  GROUP(535),  GROUP(536),
  /* e8 */  GROUP(537),  GROUP(538),  GROUP(539),  GROUP(540),
  /* ec */  GROUP(541),  GROUP(542),  GROUP(543),  GROUP(544),
  /* f0 */  GROUP(545),  GROUP(546),  GROUP(547),  GROUP(548),
  /* f4 */  GROUP(549),  GROUP(550),  GROUP(551),  GROUP(552),
  /* f8 */  GROUP(556),  GROUP(557),  GROUP(558),  GROUP(559),
  /* fc */  GROUP(560),  GROUP(561),  GROUP(562),           0,
};

static const uint16_t ud_itab__563[] = {
  /*  0 */         634,           0,
};

static const uint16_t ud_itab__564[] = {
  /*  0 */         635,           0,
};

static const uint16_t ud_itab__565[] = {
  /*  0 */         642,           0,
};

static const uint16_t ud_itab__566[] = {
  /*  0 */         643,           0,
};

static const uint16_t ud_itab__567[] = {
  /*  0 */         650,           0,
};

static const uint16_t ud_itab__568[] = {
  /*  0 */         657,           0,
};

static const uint16_t ud_itab__569[] = {
  /*  0 */         664,           0,
};

static const uint16_t ud_itab__570[] = {
  /*  0 */         671,           0,
};

static const uint16_t ud_itab__572[] = {
  /*  0 */         704,           0,
};

static const uint16_t ud_itab__573[] = {
  /*  0 */         705,           0,
};

static const uint16_t ud_itab__571[] = {
  /*  0 */  GROUP(572),  GROUP(573),           0,
};

static const uint16_t ud_itab__575[] = {
  /*  0 */         706,           0,
};

static const uint16_t ud_itab__576[] = {
  /*  0 */         707,           0,
};

static const uint16_t ud_itab__574[] = {
  /*  0 */  GROUP(575),  GROUP(576),           0,
};

static const uint16_t ud_itab__577[] = {
  /*  0 */         708,           0,
};

static const uint16_t ud_itab__578[] = {
  /*  0 */         709,         710,
};

static const uint16_t ud_itab__579[] = {
  /*  0 */         716,         717,           0,
};

static const uint16_t ud_itab__580[] = {
  /*  0 */         719,         720,           0,
};

static const uint16_t ud_itab__581[] = {
  /*  0 */         737,         738,         739,         740,
  /*  4 */         741,         742,         743,         744,
};

static const uint16_t ud_itab__582[] = {
  /*  0 */         745,         746,         747,         748,
  /*  4 */         749,         750,         751,         752,
};

static const uint16_t ud_itab__584[] = {
  /*  0 */         753,           0,
};

static const uint16_t ud_itab__585[] = {
  /*  0 */         754,           0,
};

static const uint16_t ud_itab__586[] = {
  /*  0 */         755,           0,
};

static const uint16_t ud_itab__587[] = {
  /*  0 */         756,           0,
};

static const uint16_t ud_itab__588[] = {
  /*  0 */         757,           0,
};

static const uint16_t ud_itab__589[] = {
  /*  0 */         758,           0,
};

static const uint16_t ud_itab__590[] = {
  /*  0 */         759,           0,
};

static const uint16_t ud_itab__591[] = {
  /*  0 */         760,           0,
};

static const uint16_t ud_itab__583[] = {
  /*  0 */  GROUP(584),  GROUP(585),  GROUP(586),  GROUP(587),
  /*  4 */  GROUP(588),  GROUP(589),  GROUP(590),  GROUP(591),
};

static const uint16_t ud_itab__592[] = {
  /*  0 */         761,         762,         763,         764,
  /*  4 */         765,         766,         767,         768,
};

static const uint16_t ud_itab__593[] = {
  /*  0 */         780,           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__594[] = {
  /*  0 */         789,         790,         791,
};

static const uint16_t ud_itab__595[] = {
  /*  0 */         792,         793,         794,
};

static const uint16_t ud_itab__596[] = {
  /*  0 */         795,           0,
};

static const uint16_t ud_itab__598[] = {
  /*  0 */         797,         798,
};

static const uint16_t ud_itab__599[] = {
  /*  0 */         799,         800,
};

static const uint16_t ud_itab__600[] = {
  /*  0 */           0,         801,
};

static const uint16_t ud_itab__597[] = {
  /*  0 */  GROUP(598),  GROUP(599),  GROUP(600),
};

static const uint16_t ud_itab__602[] = {
  /*  0 */         802,           0,
};

static const uint16_t ud_itab__603[] = {
  /*  0 */         803,         804,
};

static const uint16_t ud_itab__604[] = {
  /*  0 */           0,         805,
};

static const uint16_t ud_itab__601[] = {
  /*  0 */  GROUP(602),  GROUP(603),  GROUP(604),
};

static const uint16_t ud_itab__605[] = {
  /*  0 */         813,         814,         815,
};

static const uint16_t ud_itab__606[] = {
  /*  0 */         817,         818,         819,
};

static const uint16_t ud_itab__607[] = {
  /*  0 */         823,         824,         825,
};

static const uint16_t ud_itab__608[] = {
  /*  0 */         827,         828,         829,
};

static const uint16_t ud_itab__609[] = {
  /*  0 */         831,         832,         833,
};

static const uint16_t ud_itab__610[] = {
  /*  0 */         850,         851,         852,         853,
  /*  4 */         854,         855,         856,         857,
};

static const uint16_t ud_itab__611[] = {
  /*  0 */         858,         859,         860,         861,
  /*  4 */         862,         863,         864,         865,
};

static const uint16_t ud_itab__612[] = {
  /*  0 */         868,           0,
};

static const uint16_t ud_itab__613[] = {
  /*  0 */         869,           0,
};

static const uint16_t ud_itab__614[] = {
  /*  0 */         870,           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__615[] = {
  /*  0 */         871,           0,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__616[] = {
  /*  0 */         878,           0,
};

static const uint16_t ud_itab__617[] = {
  /*  0 */         879,         880,         881,
};

static const uint16_t ud_itab__618[] = {
  /*  0 */         882,         883,         884,         885,
  /*  4 */         886,         887,         888,         889,
};

static const uint16_t ud_itab__619[] = {
  /*  0 */         890,         891,         892,         893,
  /*  4 */         894,         895,         896,         897,
};

static const uint16_t ud_itab__620[] = {
  /*  0 */         898,         899,         900,         901,
  /*  4 */         902,         903,         904,         905,
};

static const uint16_t ud_itab__621[] = {
  /*  0 */         906,         907,         908,         909,
  /*  4 */         910,         911,         912,         913,
};

static const uint16_t ud_itab__622[] = {
  /*  0 */         914,           0,
};

static const uint16_t ud_itab__623[] = {
  /*  0 */         915,           0,
};

static const uint16_t ud_itab__624[] = {
  /*  0 */         916,           0,
};

static const uint16_t ud_itab__627[] = {
  /*  0 */         918,           0,
};

static const uint16_t ud_itab__628[] = {
  /*  0 */         919,           0,
};

static const uint16_t ud_itab__629[] = {
  /*  0 */         920,           0,
};

static const uint16_t ud_itab__630[] = {
  /*  0 */         921,           0,
};

static const uint16_t ud_itab__631[] = {
  /*  0 */         922,           0,
};

static const uint16_t ud_itab__632[] = {
  /*  0 */         923,           0,
};

static const uint16_t ud_itab__633[] = {
  /*  0 */         924,           0,
};

static const uint16_t ud_itab__634[] = {
  /*  0 */         925,           0,
};

static const uint16_t ud_itab__626[] = {
  /*  0 */  GROUP(627),  GROUP(628),  GROUP(629),  GROUP(630),
  /*  4 */  GROUP(631),  GROUP(632),  GROUP(633),  GROUP(634),
};

static const uint16_t ud_itab__636[] = {
  /*  0 */           0,         926,
};

static const uint16_t ud_itab__637[] = {
  /*  0 */           0,         927,
};

static const uint16_t ud_itab__638[] = {
  /*  0 */           0,         928,
};

static const uint16_t ud_itab__639[] = {
  /*  0 */           0,         929,
};

static const uint16_t ud_itab__640[] = {
  /*  0 */           0,         930,
};

static const uint16_t ud_itab__641[] = {
  /*  0 */           0,         931,
};

static const uint16_t ud_itab__642[] = {
  /*  0 */           0,         932,
};

static const uint16_t ud_itab__643[] = {
  /*  0 */           0,         933,
};

static const uint16_t ud_itab__644[] = {
  /*  0 */           0,         934,
};

static const uint16_t ud_itab__645[] = {
  /*  0 */           0,         935,
};

static const uint16_t ud_itab__646[] = {
  /*  0 */           0,         936,
};

static const uint16_t ud_itab__647[] = {
  /*  0 */           0,         937,
};

static const uint16_t ud_itab__648[] = {
  /*  0 */           0,         938,
};

static const uint16_t ud_itab__649[] = {
  /*  0 */           0,         939,
};

static const uint16_t ud_itab__650[] = {
  /*  0 */           0,         940,
};

static const uint16_t ud_itab__651[] = {
  /*  0 */           0,         941,
};

static const uint16_t ud_itab__652[] = {
  /*  0 */           0,         942,
};

static const uint16_t ud_itab__653[] = {
  /*  0 */           0,         943,
};

static const uint16_t ud_itab__654[] = {
  /*  0 */           0,         944,
};

static const uint16_t ud_itab__655[] = {
  /*  0 */           0,         945,
};

static const uint16_t ud_itab__656[] = {
  /*  0 */           0,         946,
};

static const uint16_t ud_itab__657[] = {
  /*  0 */           0,         947,
};

static const uint16_t ud_itab__658[] = {
  /*  0 */           0,         948,
};

static const uint16_t ud_itab__659[] = {
  /*  0 */           0,         949,
};

static const uint16_t ud_itab__660[] = {
  /*  0 */           0,         950,
};

static const uint16_t ud_itab__661[] = {
  /*  0 */           0,         951,
};

static const uint16_t ud_itab__662[] = {
  /*  0 */           0,         952,
};

static const uint16_t ud_itab__663[] = {
  /*  0 */           0,         953,
};

static const uint16_t ud_itab__664[] = {
  /*  0 */           0,         954,
};

static const uint16_t ud_itab__665[] = {
  /*  0 */           0,         955,
};

static const uint16_t ud_itab__666[] = {
  /*  0 */           0,         956,
};

static const uint16_t ud_itab__667[] = {
  /*  0 */           0,         957,
};

static const uint16_t ud_itab__668[] = {
  /*  0 */           0,         958,
};

static const uint16_t ud_itab__669[] = {
  /*  0 */           0,         959,
};

static const uint16_t ud_itab__670[] = {
  /*  0 */           0,         960,
};

static const uint16_t ud_itab__671[] = {
  /*  0 */           0,         961,
};

static const uint16_t ud_itab__672[] = {
  /*  0 */           0,         962,
};

static const uint16_t ud_itab__673[] = {
  /*  0 */           0,         963,
};

static const uint16_t ud_itab__674[] = {
  /*  0 */           0,         964,
};

static const uint16_t ud_itab__675[] = {
  /*  0 */           0,         965,
};

static const uint16_t ud_itab__676[] = {
  /*  0 */           0,         966,
};

static const uint16_t ud_itab__677[] = {
  /*  0 */           0,         967,
};

static const uint16_t ud_itab__678[] = {
  /*  0 */           0,         968,
};

static const uint16_t ud_itab__679[] = {
  /*  0 */           0,         969,
};

static const uint16_t ud_itab__680[] = {
  /*  0 */           0,         970,
};

static const uint16_t ud_itab__681[] = {
  /*  0 */           0,         971,
};

static const uint16_t ud_itab__682[] = {
  /*  0 */           0,         972,
};

static const uint16_t ud_itab__683[] = {
  /*  0 */           0,         973,
};

static const uint16_t ud_itab__684[] = {
  /*  0 */           0,         974,
};

static const uint16_t ud_itab__685[] = {
  /*  0 */           0,         975,
};

static const uint16_t ud_itab__686[] = {
  /*  0 */           0,         976,
};

static const uint16_t ud_itab__687[] = {
  /*  0 */           0,         977,
};

static const uint16_t ud_itab__688[] = {
  /*  0 */           0,         978,
};

static const uint16_t ud_itab__689[] = {
  /*  0 */           0,         979,
};

static const uint16_t ud_itab__690[] = {
  /*  0 */           0,         980,
};

static const uint16_t ud_itab__691[] = {
  /*  0 */           0,         981,
};

static const uint16_t ud_itab__692[] = {
  /*  0 */           0,         982,
};

static const uint16_t ud_itab__693[] = {
  /*  0 */           0,         983,
};

static const uint16_t ud_itab__694[] = {
  /*  0 */           0,         984,
};

static const uint16_t ud_itab__695[] = {
  /*  0 */           0,         985,
};

static const uint16_t ud_itab__696[] = {
  /*  0 */           0,         986,
};

static const uint16_t ud_itab__697[] = {
  /*  0 */           0,         987,
};

static const uint16_t ud_itab__698[] = {
  /*  0 */           0,         988,
};

static const uint16_t ud_itab__699[] = {
  /*  0 */           0,         989,
};

static const uint16_t ud_itab__635[] = {
  /*  0 */  GROUP(636),  GROUP(637),  GROUP(638),  GROUP(639),
  /*  4 */  GROUP(640),  GROUP(641),  GROUP(642),  GROUP(643),
  /*  8 */  GROUP(644),  GROUP(645),  GROUP(646),  GROUP(647),
  /*  c */  GROUP(648),  GROUP(649),  GROUP(650),  GROUP(651),
  /* 10 */  GROUP(652),  GROUP(653),  GROUP(654),  GROUP(655),
  /* 14 */  GROUP(656),  GROUP(657),  GROUP(658),  GROUP(659),
  /* 18 */  GROUP(660),  GROUP(661),  GROUP(662),  GROUP(663),
  /* 1c */  GROUP(664),  GROUP(665),  GROUP(666),  GROUP(667),
  /* 20 */  GROUP(668),  GROUP(669),  GROUP(670),  GROUP(671),
  /* 24 */  GROUP(672),  GROUP(673),  GROUP(674),  GROUP(675),
  /* 28 */  GROUP(676),  GROUP(677),  GROUP(678),  GROUP(679),
  /* 2c */  GROUP(680),  GROUP(681),  GROUP(682),  GROUP(683),
  /* 30 */  GROUP(684),  GROUP(685),  GROUP(686),  GROUP(687),
  /* 34 */  GROUP(688),  GROUP(689),  GROUP(690),  GROUP(691),
  /* 38 */  GROUP(692),  GROUP(693),  GROUP(694),  GROUP(695),
  /* 3c */  GROUP(696),  GROUP(697),  GROUP(698),  GROUP(699),
};

static const uint16_t ud_itab__625[] = {
  /*  0 */  GROUP(626),  GROUP(635),
};

static const uint16_t ud_itab__702[] = {
  /*  0 */         990,           0,
};

static const uint16_t ud_itab__703[] = {
  /*  0 */         991,           0,
};

static const uint16_t ud_itab__704[] = {
  /*  0 */         992,           0,
};

static const uint16_t ud_itab__705[] = {
  /*  0 */         993,           0,
};

static const uint16_t ud_itab__706[] = {
  /*  0 */         994,           0,
};

static const uint16_t ud_itab__707[] = {
  /*  0 */         995,           0,
};

static const uint16_t ud_itab__708[] = {
  /*  0 */         996,           0,
};

static const uint16_t ud_itab__701[] = {
  /*  0 */  GROUP(702),           0,  GROUP(703),  GROUP(704),
  /*  4 */  GROUP(705),  GROUP(706),  GROUP(707),  GROUP(708),
};

static const uint16_t ud_itab__710[] = {
  /*  0 */           0,         997,
};

static const uint16_t ud_itab__711[] = {
  /*  0 */           0,         998,
};

static const uint16_t ud_itab__712[] = {
  /*  0 */           0,         999,
};

static const uint16_t ud_itab__713[] = {
  /*  0 */           0,        1000,
};

static const uint16_t ud_itab__714[] = {
  /*  0 */           0,        1001,
};

static const uint16_t ud_itab__715[] = {
  /*  0 */           0,        1002,
};

static const uint16_t ud_itab__716[] = {
  /*  0 */           0,        1003,
};

static const uint16_t ud_itab__717[] = {
  /*  0 */           0,        1004,
};

static const uint16_t ud_itab__718[] = {
  /*  0 */           0,        1005,
};

static const uint16_t ud_itab__719[] = {
  /*  0 */           0,        1006,
};

static const uint16_t ud_itab__720[] = {
  /*  0 */           0,        1007,
};

static const uint16_t ud_itab__721[] = {
  /*  0 */           0,        1008,
};

static const uint16_t ud_itab__722[] = {
  /*  0 */           0,        1009,
};

static const uint16_t ud_itab__723[] = {
  /*  0 */           0,        1010,
};

static const uint16_t ud_itab__724[] = {
  /*  0 */           0,        1011,
};

static const uint16_t ud_itab__725[] = {
  /*  0 */           0,        1012,
};

static const uint16_t ud_itab__726[] = {
  /*  0 */           0,        1013,
};

static const uint16_t ud_itab__727[] = {
  /*  0 */           0,        1014,
};

static const uint16_t ud_itab__728[] = {
  /*  0 */           0,        1015,
};

static const uint16_t ud_itab__729[] = {
  /*  0 */           0,        1016,
};

static const uint16_t ud_itab__730[] = {
  /*  0 */           0,        1017,
};

static const uint16_t ud_itab__731[] = {
  /*  0 */           0,        1018,
};

static const uint16_t ud_itab__732[] = {
  /*  0 */           0,        1019,
};

static const uint16_t ud_itab__733[] = {
  /*  0 */           0,        1020,
};

static const uint16_t ud_itab__734[] = {
  /*  0 */           0,        1021,
};

static const uint16_t ud_itab__735[] = {
  /*  0 */           0,        1022,
};

static const uint16_t ud_itab__736[] = {
  /*  0 */           0,        1023,
};

static const uint16_t ud_itab__737[] = {
  /*  0 */           0,        1024,
};

static const uint16_t ud_itab__738[] = {
  /*  0 */           0,        1025,
};

static const uint16_t ud_itab__739[] = {
  /*  0 */           0,        1026,
};

static const uint16_t ud_itab__740[] = {
  /*  0 */           0,        1027,
};

static const uint16_t ud_itab__741[] = {
  /*  0 */           0,        1028,
};

static const uint16_t ud_itab__742[] = {
  /*  0 */           0,        1029,
};

static const uint16_t ud_itab__743[] = {
  /*  0 */           0,        1030,
};

static const uint16_t ud_itab__744[] = {
  /*  0 */           0,        1031,
};

static const uint16_t ud_itab__745[] = {
  /*  0 */           0,        1032,
};

static const uint16_t ud_itab__746[] = {
  /*  0 */           0,        1033,
};

static const uint16_t ud_itab__747[] = {
  /*  0 */           0,        1034,
};

static const uint16_t ud_itab__748[] = {
  /*  0 */           0,        1035,
};

static const uint16_t ud_itab__749[] = {
  /*  0 */           0,        1036,
};

static const uint16_t ud_itab__750[] = {
  /*  0 */           0,        1037,
};

static const uint16_t ud_itab__751[] = {
  /*  0 */           0,        1038,
};

static const uint16_t ud_itab__752[] = {
  /*  0 */           0,        1039,
};

static const uint16_t ud_itab__753[] = {
  /*  0 */           0,        1040,
};

static const uint16_t ud_itab__754[] = {
  /*  0 */           0,        1041,
};

static const uint16_t ud_itab__755[] = {
  /*  0 */           0,        1042,
};

static const uint16_t ud_itab__756[] = {
  /*  0 */           0,        1043,
};

static const uint16_t ud_itab__757[] = {
  /*  0 */           0,        1044,
};

static const uint16_t ud_itab__758[] = {
  /*  0 */           0,        1045,
};

static const uint16_t ud_itab__759[] = {
  /*  0 */           0,        1046,
};

static const uint16_t ud_itab__760[] = {
  /*  0 */           0,        1047,
};

static const uint16_t ud_itab__761[] = {
  /*  0 */           0,        1048,
};

static const uint16_t ud_itab__709[] = {
  /*  0 */  GROUP(710),  GROUP(711),  GROUP(712),  GROUP(713),
  /*  4 */  GROUP(714),  GROUP(715),  GROUP(716),  GROUP(717),
  /*  8 */  GROUP(718),  GROUP(719),  GROUP(720),  GROUP(721),
  /*  c */  GROUP(722),  GROUP(723),  GROUP(724),  GROUP(725),
  /* 10 */  GROUP(726),           0,           0,           0,
  /* 14 */           0,           0,           0,           0,
  /* 18 */  GROUP(727),  GROUP(728),  GROUP(729),  GROUP(730),
  /* 1c */  GROUP(731),  GROUP(732),  GROUP(733),  GROUP(734),
  /* 20 */  GROUP(735),  GROUP(736),           0,           0,
  /* 24 */  GROUP(737),  GROUP(738),           0,           0,
  /* 28 */  GROUP(739),  GROUP(740),  GROUP(741),  GROUP(742),
  /* 2c */  GROUP(743),  GROUP(744),  GROUP(745),           0,
  /* 30 */  GROUP(746),  GROUP(747),  GROUP(748),  GROUP(749),
  /* 34 */  GROUP(750),  GROUP(751),  GROUP(752),  GROUP(753),
  /* 38 */  GROUP(754),  GROUP(755),  GROUP(756),  GROUP(757),
  /* 3c */  GROUP(758),  GROUP(759),  GROUP(760),  GROUP(761),
};

static const uint16_t ud_itab__700[] = {
  /*  0 */  GROUP(701),  GROUP(709),
};

static const uint16_t ud_itab__764[] = {
  /*  0 */        1049,           0,
};

static const uint16_t ud_itab__765[] = {
  /*  0 */        1050,           0,
};

static const uint16_t ud_itab__766[] = {
  /*  0 */        1051,           0,
};

static const uint16_t ud_itab__767[] = {
  /*  0 */        1052,           0,
};

static const uint16_t ud_itab__768[] = {
  /*  0 */        1053,           0,
};

static const uint16_t ud_itab__769[] = {
  /*  0 */        1054,           0,
};

static const uint16_t ud_itab__770[] = {
  /*  0 */        1055,           0,
};

static const uint16_t ud_itab__771[] = {
  /*  0 */        1056,           0,
};

static const uint16_t ud_itab__763[] = {
  /*  0 */  GROUP(764),  GROUP(765),  GROUP(766),  GROUP(767),
  /*  4 */  GROUP(768),  GROUP(769),  GROUP(770),  GROUP(771),
};

static const uint16_t ud_itab__773[] = {
  /*  0 */           0,        1057,
};

static const uint16_t ud_itab__774[] = {
  /*  0 */           0,        1058,
};

static const uint16_t ud_itab__775[] = {
  /*  0 */           0,        1059,
};

static const uint16_t ud_itab__776[] = {
  /*  0 */           0,        1060,
};

static const uint16_t ud_itab__777[] = {
  /*  0 */           0,        1061,
};

static const uint16_t ud_itab__778[] = {
  /*  0 */           0,        1062,
};

static const uint16_t ud_itab__779[] = {
  /*  0 */           0,        1063,
};

static const uint16_t ud_itab__780[] = {
  /*  0 */           0,        1064,
};

static const uint16_t ud_itab__781[] = {
  /*  0 */           0,        1065,
};

static const uint16_t ud_itab__782[] = {
  /*  0 */           0,        1066,
};

static const uint16_t ud_itab__783[] = {
  /*  0 */           0,        1067,
};

static const uint16_t ud_itab__784[] = {
  /*  0 */           0,        1068,
};

static const uint16_t ud_itab__785[] = {
  /*  0 */           0,        1069,
};

static const uint16_t ud_itab__786[] = {
  /*  0 */           0,        1070,
};

static const uint16_t ud_itab__787[] = {
  /*  0 */           0,        1071,
};

static const uint16_t ud_itab__788[] = {
  /*  0 */           0,        1072,
};

static const uint16_t ud_itab__789[] = {
  /*  0 */           0,        1073,
};

static const uint16_t ud_itab__790[] = {
  /*  0 */           0,        1074,
};

static const uint16_t ud_itab__791[] = {
  /*  0 */           0,        1075,
};

static const uint16_t ud_itab__792[] = {
  /*  0 */           0,        1076,
};

static const uint16_t ud_itab__793[] = {
  /*  0 */           0,        1077,
};

static const uint16_t ud_itab__794[] = {
  /*  0 */           0,        1078,
};

static const uint16_t ud_itab__795[] = {
  /*  0 */           0,        1079,
};

static const uint16_t ud_itab__796[] = {
  /*  0 */           0,        1080,
};

static const uint16_t ud_itab__797[] = {
  /*  0 */           0,        1081,
};

static const uint16_t ud_itab__798[] = {
  /*  0 */           0,        1082,
};

static const uint16_t ud_itab__799[] = {
  /*  0 */           0,        1083,
};

static const uint16_t ud_itab__800[] = {
  /*  0 */           0,        1084,
};

static const uint16_t ud_itab__801[] = {
  /*  0 */           0,        1085,
};

static const uint16_t ud_itab__802[] = {
  /*  0 */           0,        1086,
};

static const uint16_t ud_itab__803[] = {
  /*  0 */           0,        1087,
};

static const uint16_t ud_itab__804[] = {
  /*  0 */           0,        1088,
};

static const uint16_t ud_itab__805[] = {
  /*  0 */           0,        1089,
};

static const uint16_t ud_itab__772[] = {
  /*  0 */  GROUP(773),  GROUP(774),  GROUP(775),  GROUP(776),
  /*  4 */  GROUP(777),  GROUP(778),  GROUP(779),  GROUP(780),
  /*  8 */  GROUP(781),  GROUP(782),  GROUP(783),  GROUP(784),
  /*  c */  GROUP(785),  GROUP(786),  GROUP(787),  GROUP(788),
  /* 10 */  GROUP(789),  GROUP(790),  GROUP(791),  GROUP(792),
  /* 14 */  GROUP(793),  GROUP(794),  GROUP(795),  GROUP(796),
  /* 18 */  GROUP(797),  GROUP(798),  GROUP(799),  GROUP(800),
  /* 1c */  GROUP(801),  GROUP(802),  GROUP(803),  GROUP(804),
  /* 20 */           0,           0,           0,           0,
  /* 24 */           0,           0,           0,           0,
  /* 28 */           0,  GROUP(805),           0,           0,
  /* 2c */           0,           0,           0,           0,
  /* 30 */           0,           0,           0,           0,
  /* 34 */           0,           0,           0,           0,
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
};

static const uint16_t ud_itab__762[] = {
  /*  0 */  GROUP(763),  GROUP(772),
};

static const uint16_t ud_itab__808[] = {
  /*  0 */        1090,           0,
};

static const uint16_t ud_itab__809[] = {
  /*  0 */        1091,           0,
};

static const uint16_t ud_itab__810[] = {
  /*  0 */        1092,           0,
};

static const uint16_t ud_itab__811[] = {
  /*  0 */        1093,           0,
};

static const uint16_t ud_itab__812[] = {
  /*  0 */        1094,           0,
};

static const uint16_t ud_itab__813[] = {
  /*  0 */        1095,           0,
};

static const uint16_t ud_itab__807[] = {
  /*  0 */  GROUP(808),  GROUP(809),  GROUP(810),  GROUP(811),
  /*  4 */           0,  GROUP(812),           0,  GROUP(813),
};

static const uint16_t ud_itab__815[] = {
  /*  0 */           0,        1096,
};

static const uint16_t ud_itab__816[] = {
  /*  0 */           0,        1097,
};

static const uint16_t ud_itab__817[] = {
  /*  0 */           0,        1098,
};

static const uint16_t ud_itab__818[] = {
  /*  0 */           0,        1099,
};

static const uint16_t ud_itab__819[] = {
  /*  0 */           0,        1100,
};

static const uint16_t ud_itab__820[] = {
  /*  0 */           0,        1101,
};

static const uint16_t ud_itab__821[] = {
  /*  0 */           0,        1102,
};

static const uint16_t ud_itab__822[] = {
  /*  0 */           0,        1103,
};

static const uint16_t ud_itab__823[] = {
  /*  0 */           0,        1104,
};

static const uint16_t ud_itab__824[] = {
  /*  0 */           0,        1105,
};

static const uint16_t ud_itab__825[] = {
  /*  0 */           0,        1106,
};

static const uint16_t ud_itab__826[] = {
  /*  0 */           0,        1107,
};

static const uint16_t ud_itab__827[] = {
  /*  0 */           0,        1108,
};

static const uint16_t ud_itab__828[] = {
  /*  0 */           0,        1109,
};

static const uint16_t ud_itab__829[] = {
  /*  0 */           0,        1110,
};

static const uint16_t ud_itab__830[] = {
  /*  0 */           0,        1111,
};

static const uint16_t ud_itab__831[] = {
  /*  0 */           0,        1112,
};

static const uint16_t ud_itab__832[] = {
  /*  0 */           0,        1113,
};

static const uint16_t ud_itab__833[] = {
  /*  0 */           0,        1114,
};

static const uint16_t ud_itab__834[] = {
  /*  0 */           0,        1115,
};

static const uint16_t ud_itab__835[] = {
  /*  0 */           0,        1116,
};

static const uint16_t ud_itab__836[] = {
  /*  0 */           0,        1117,
};

static const uint16_t ud_itab__837[] = {
  /*  0 */           0,        1118,
};

static const uint16_t ud_itab__838[] = {
  /*  0 */           0,        1119,
};

static const uint16_t ud_itab__839[] = {
  /*  0 */           0,        1120,
};

static const uint16_t ud_itab__840[] = {
  /*  0 */           0,        1121,
};

static const uint16_t ud_itab__841[] = {
  /*  0 */           0,        1122,
};

static const uint16_t ud_itab__842[] = {
  /*  0 */           0,        1123,
};

static const uint16_t ud_itab__843[] = {
  /*  0 */           0,        1124,
};

static const uint16_t ud_itab__844[] = {
  /*  0 */           0,        1125,
};

static const uint16_t ud_itab__845[] = {
  /*  0 */           0,        1126,
};

static const uint16_t ud_itab__846[] = {
  /*  0 */           0,        1127,
};

static const uint16_t ud_itab__847[] = {
  /*  0 */           0,        1128,
};

static const uint16_t ud_itab__848[] = {
  /*  0 */           0,        1129,
};

static const uint16_t ud_itab__849[] = {
  /*  0 */           0,        1130,
};

static const uint16_t ud_itab__850[] = {
  /*  0 */           0,        1131,
};

static const uint16_t ud_itab__851[] = {
  /*  0 */           0,        1132,
};

static const uint16_t ud_itab__852[] = {
  /*  0 */           0,        1133,
};

static const uint16_t ud_itab__853[] = {
  /*  0 */           0,        1134,
};

static const uint16_t ud_itab__854[] = {
  /*  0 */           0,        1135,
};

static const uint16_t ud_itab__855[] = {
  /*  0 */           0,        1136,
};

static const uint16_t ud_itab__856[] = {
  /*  0 */           0,        1137,
};

static const uint16_t ud_itab__857[] = {
  /*  0 */           0,        1138,
};

static const uint16_t ud_itab__858[] = {
  /*  0 */           0,        1139,
};

static const uint16_t ud_itab__859[] = {
  /*  0 */           0,        1140,
};

static const uint16_t ud_itab__860[] = {
  /*  0 */           0,        1141,
};

static const uint16_t ud_itab__861[] = {
  /*  0 */           0,        1142,
};

static const uint16_t ud_itab__862[] = {
  /*  0 */           0,        1143,
};

static const uint16_t ud_itab__863[] = {
  /*  0 */           0,        1144,
};

static const uint16_t ud_itab__864[] = {
  /*  0 */           0,        1145,
};

static const uint16_t ud_itab__814[] = {
  /*  0 */  GROUP(815),  GROUP(816),  GROUP(817),  GROUP(818),
  /*  4 */  GROUP(819),  GROUP(820),  GROUP(821),  GROUP(822),
  /*  8 */  GROUP(823),  GROUP(824),  GROUP(825),  GROUP(826),
  /*  c */  GROUP(827),  GROUP(828),  GROUP(829),  GROUP(830),
  /* 10 */  GROUP(831),  GROUP(832),  GROUP(833),  GROUP(834),
  /* 14 */  GROUP(835),  GROUP(836),  GROUP(837),  GROUP(838),
  /* 18 */  GROUP(839),  GROUP(840),  GROUP(841),  GROUP(842),
  /* 1c */  GROUP(843),  GROUP(844),  GROUP(845),  GROUP(846),
  /* 20 */           0,           0,  GROUP(847),  GROUP(848),
  /* 24 */           0,           0,           0,           0,
  /* 28 */  GROUP(849),  GROUP(850),  GROUP(851),  GROUP(852),
  /* 2c */  GROUP(853),  GROUP(854),  GROUP(855),  GROUP(856),
  /* 30 */  GROUP(857),  GROUP(858),  GROUP(859),  GROUP(860),
  /* 34 */  GROUP(861),  GROUP(862),  GROUP(863),  GROUP(864),
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
};

static const uint16_t ud_itab__806[] = {
  /*  0 */  GROUP(807),  GROUP(814),
};

static const uint16_t ud_itab__867[] = {
  /*  0 */        1146,           0,
};

static const uint16_t ud_itab__868[] = {
  /*  0 */        1147,           0,
};

static const uint16_t ud_itab__869[] = {
  /*  0 */        1148,           0,
};

static const uint16_t ud_itab__870[] = {
  /*  0 */        1149,           0,
};

static const uint16_t ud_itab__871[] = {
  /*  0 */        1150,           0,
};

static const uint16_t ud_itab__872[] = {
  /*  0 */        1151,           0,
};

static const uint16_t ud_itab__873[] = {
  /*  0 */        1152,           0,
};

static const uint16_t ud_itab__874[] = {
  /*  0 */        1153,           0,
};

static const uint16_t ud_itab__866[] = {
  /*  0 */  GROUP(867),  GROUP(868),  GROUP(869),  GROUP(870),
  /*  4 */  GROUP(871),  GROUP(872),  GROUP(873),  GROUP(874),
};

static const uint16_t ud_itab__876[] = {
  /*  0 */           0,        1154,
};

static const uint16_t ud_itab__877[] = {
  /*  0 */           0,        1155,
};

static const uint16_t ud_itab__878[] = {
  /*  0 */           0,        1156,
};

static const uint16_t ud_itab__879[] = {
  /*  0 */           0,        1157,
};

static const uint16_t ud_itab__880[] = {
  /*  0 */           0,        1158,
};

static const uint16_t ud_itab__881[] = {
  /*  0 */           0,        1159,
};

static const uint16_t ud_itab__882[] = {
  /*  0 */           0,        1160,
};

static const uint16_t ud_itab__883[] = {
  /*  0 */           0,        1161,
};

static const uint16_t ud_itab__884[] = {
  /*  0 */           0,        1162,
};

static const uint16_t ud_itab__885[] = {
  /*  0 */           0,        1163,
};

static const uint16_t ud_itab__886[] = {
  /*  0 */           0,        1164,
};

static const uint16_t ud_itab__887[] = {
  /*  0 */           0,        1165,
};

static const uint16_t ud_itab__888[] = {
  /*  0 */           0,        1166,
};

static const uint16_t ud_itab__889[] = {
  /*  0 */           0,        1167,
};

static const uint16_t ud_itab__890[] = {
  /*  0 */           0,        1168,
};

static const uint16_t ud_itab__891[] = {
  /*  0 */           0,        1169,
};

static const uint16_t ud_itab__892[] = {
  /*  0 */           0,        1170,
};

static const uint16_t ud_itab__893[] = {
  /*  0 */           0,        1171,
};

static const uint16_t ud_itab__894[] = {
  /*  0 */           0,        1172,
};

static const uint16_t ud_itab__895[] = {
  /*  0 */           0,        1173,
};

static const uint16_t ud_itab__896[] = {
  /*  0 */           0,        1174,
};

static const uint16_t ud_itab__897[] = {
  /*  0 */           0,        1175,
};

static const uint16_t ud_itab__898[] = {
  /*  0 */           0,        1176,
};

static const uint16_t ud_itab__899[] = {
  /*  0 */           0,        1177,
};

static const uint16_t ud_itab__900[] = {
  /*  0 */           0,        1178,
};

static const uint16_t ud_itab__901[] = {
  /*  0 */           0,        1179,
};

static const uint16_t ud_itab__902[] = {
  /*  0 */           0,        1180,
};

static const uint16_t ud_itab__903[] = {
  /*  0 */           0,        1181,
};

static const uint16_t ud_itab__904[] = {
  /*  0 */           0,        1182,
};

static const uint16_t ud_itab__905[] = {
  /*  0 */           0,        1183,
};

static const uint16_t ud_itab__906[] = {
  /*  0 */           0,        1184,
};

static const uint16_t ud_itab__907[] = {
  /*  0 */           0,        1185,
};

static const uint16_t ud_itab__908[] = {
  /*  0 */           0,        1186,
};

static const uint16_t ud_itab__909[] = {
  /*  0 */           0,        1187,
};

static const uint16_t ud_itab__910[] = {
  /*  0 */           0,        1188,
};

static const uint16_t ud_itab__911[] = {
  /*  0 */           0,        1189,
};

static const uint16_t ud_itab__912[] = {
  /*  0 */           0,        1190,
};

static const uint16_t ud_itab__913[] = {
  /*  0 */           0,        1191,
};

static const uint16_t ud_itab__914[] = {
  /*  0 */           0,        1192,
};

static const uint16_t ud_itab__915[] = {
  /*  0 */           0,        1193,
};

static const uint16_t ud_itab__916[] = {
  /*  0 */           0,        1194,
};

static const uint16_t ud_itab__917[] = {
  /*  0 */           0,        1195,
};

static const uint16_t ud_itab__918[] = {
  /*  0 */           0,        1196,
};

static const uint16_t ud_itab__919[] = {
  /*  0 */           0,        1197,
};

static const uint16_t ud_itab__920[] = {
  /*  0 */           0,        1198,
};

static const uint16_t ud_itab__921[] = {
  /*  0 */           0,        1199,
};

static const uint16_t ud_itab__922[] = {
  /*  0 */           0,        1200,
};

static const uint16_t ud_itab__923[] = {
  /*  0 */           0,        1201,
};

static const uint16_t ud_itab__924[] = {
  /*  0 */           0,        1202,
};

static const uint16_t ud_itab__925[] = {
  /*  0 */           0,        1203,
};

static const uint16_t ud_itab__926[] = {
  /*  0 */           0,        1204,
};

static const uint16_t ud_itab__927[] = {
  /*  0 */           0,        1205,
};

static const uint16_t ud_itab__928[] = {
  /*  0 */           0,        1206,
};

static const uint16_t ud_itab__929[] = {
  /*  0 */           0,        1207,
};

static const uint16_t ud_itab__930[] = {
  /*  0 */           0,        1208,
};

static const uint16_t ud_itab__931[] = {
  /*  0 */           0,        1209,
};

static const uint16_t ud_itab__932[] = {
  /*  0 */           0,        1210,
};

static const uint16_t ud_itab__933[] = {
  /*  0 */           0,        1211,
};

static const uint16_t ud_itab__934[] = {
  /*  0 */           0,        1212,
};

static const uint16_t ud_itab__935[] = {
  /*  0 */           0,        1213,
};

static const uint16_t ud_itab__936[] = {
  /*  0 */           0,        1214,
};

static const uint16_t ud_itab__937[] = {
  /*  0 */           0,        1215,
};

static const uint16_t ud_itab__938[] = {
  /*  0 */           0,        1216,
};

static const uint16_t ud_itab__939[] = {
  /*  0 */           0,        1217,
};

static const uint16_t ud_itab__875[] = {
  /*  0 */  GROUP(876),  GROUP(877),  GROUP(878),  GROUP(879),
  /*  4 */  GROUP(880),  GROUP(881),  GROUP(882),  GROUP(883),
  /*  8 */  GROUP(884),  GROUP(885),  GROUP(886),  GROUP(887),
  /*  c */  GROUP(888),  GROUP(889),  GROUP(890),  GROUP(891),
  /* 10 */  GROUP(892),  GROUP(893),  GROUP(894),  GROUP(895),
  /* 14 */  GROUP(896),  GROUP(897),  GROUP(898),  GROUP(899),
  /* 18 */  GROUP(900),  GROUP(901),  GROUP(902),  GROUP(903),
  /* 1c */  GROUP(904),  GROUP(905),  GROUP(906),  GROUP(907),
  /* 20 */  GROUP(908),  GROUP(909),  GROUP(910),  GROUP(911),
  /* 24 */  GROUP(912),  GROUP(913),  GROUP(914),  GROUP(915),
  /* 28 */  GROUP(916),  GROUP(917),  GROUP(918),  GROUP(919),
  /* 2c */  GROUP(920),  GROUP(921),  GROUP(922),  GROUP(923),
  /* 30 */  GROUP(924),  GROUP(925),  GROUP(926),  GROUP(927),
  /* 34 */  GROUP(928),  GROUP(929),  GROUP(930),  GROUP(931),
  /* 38 */  GROUP(932),  GROUP(933),  GROUP(934),  GROUP(935),
  /* 3c */  GROUP(936),  GROUP(937),  GROUP(938),  GROUP(939),
};

static const uint16_t ud_itab__865[] = {
  /*  0 */  GROUP(866),  GROUP(875),
};

static const uint16_t ud_itab__942[] = {
  /*  0 */        1218,           0,
};

static const uint16_t ud_itab__943[] = {
  /*  0 */        1219,           0,
};

static const uint16_t ud_itab__944[] = {
  /*  0 */        1220,           0,
};

static const uint16_t ud_itab__945[] = {
  /*  0 */        1221,           0,
};

static const uint16_t ud_itab__946[] = {
  /*  0 */        1222,           0,
};

static const uint16_t ud_itab__947[] = {
  /*  0 */        1223,           0,
};

static const uint16_t ud_itab__948[] = {
  /*  0 */        1224,           0,
};

static const uint16_t ud_itab__941[] = {
  /*  0 */  GROUP(942),  GROUP(943),  GROUP(944),  GROUP(945),
  /*  4 */  GROUP(946),           0,  GROUP(947),  GROUP(948),
};

static const uint16_t ud_itab__950[] = {
  /*  0 */           0,        1225,
};

static const uint16_t ud_itab__951[] = {
  /*  0 */           0,        1226,
};

static const uint16_t ud_itab__952[] = {
  /*  0 */           0,        1227,
};

static const uint16_t ud_itab__953[] = {
  /*  0 */           0,        1228,
};

static const uint16_t ud_itab__954[] = {
  /*  0 */           0,        1229,
};

static const uint16_t ud_itab__955[] = {
  /*  0 */           0,        1230,
};

static const uint16_t ud_itab__956[] = {
  /*  0 */           0,        1231,
};

static const uint16_t ud_itab__957[] = {
  /*  0 */           0,        1232,
};

static const uint16_t ud_itab__958[] = {
  /*  0 */           0,        1233,
};

static const uint16_t ud_itab__959[] = {
  /*  0 */           0,        1234,
};

static const uint16_t ud_itab__960[] = {
  /*  0 */           0,        1235,
};

static const uint16_t ud_itab__961[] = {
  /*  0 */           0,        1236,
};

static const uint16_t ud_itab__962[] = {
  /*  0 */           0,        1237,
};

static const uint16_t ud_itab__963[] = {
  /*  0 */           0,        1238,
};

static const uint16_t ud_itab__964[] = {
  /*  0 */           0,        1239,
};

static const uint16_t ud_itab__965[] = {
  /*  0 */           0,        1240,
};

static const uint16_t ud_itab__966[] = {
  /*  0 */           0,        1241,
};

static const uint16_t ud_itab__967[] = {
  /*  0 */           0,        1242,
};

static const uint16_t ud_itab__968[] = {
  /*  0 */           0,        1243,
};

static const uint16_t ud_itab__969[] = {
  /*  0 */           0,        1244,
};

static const uint16_t ud_itab__970[] = {
  /*  0 */           0,        1245,
};

static const uint16_t ud_itab__971[] = {
  /*  0 */           0,        1246,
};

static const uint16_t ud_itab__972[] = {
  /*  0 */           0,        1247,
};

static const uint16_t ud_itab__973[] = {
  /*  0 */           0,        1248,
};

static const uint16_t ud_itab__974[] = {
  /*  0 */           0,        1249,
};

static const uint16_t ud_itab__975[] = {
  /*  0 */           0,        1250,
};

static const uint16_t ud_itab__976[] = {
  /*  0 */           0,        1251,
};

static const uint16_t ud_itab__977[] = {
  /*  0 */           0,        1252,
};

static const uint16_t ud_itab__978[] = {
  /*  0 */           0,        1253,
};

static const uint16_t ud_itab__979[] = {
  /*  0 */           0,        1254,
};

static const uint16_t ud_itab__980[] = {
  /*  0 */           0,        1255,
};

static const uint16_t ud_itab__981[] = {
  /*  0 */           0,        1256,
};

static const uint16_t ud_itab__982[] = {
  /*  0 */           0,        1257,
};

static const uint16_t ud_itab__983[] = {
  /*  0 */           0,        1258,
};

static const uint16_t ud_itab__984[] = {
  /*  0 */           0,        1259,
};

static const uint16_t ud_itab__985[] = {
  /*  0 */           0,        1260,
};

static const uint16_t ud_itab__986[] = {
  /*  0 */           0,        1261,
};

static const uint16_t ud_itab__987[] = {
  /*  0 */           0,        1262,
};

static const uint16_t ud_itab__988[] = {
  /*  0 */           0,        1263,
};

static const uint16_t ud_itab__989[] = {
  /*  0 */           0,        1264,
};

static const uint16_t ud_itab__990[] = {
  /*  0 */           0,        1265,
};

static const uint16_t ud_itab__991[] = {
  /*  0 */           0,        1266,
};

static const uint16_t ud_itab__992[] = {
  /*  0 */           0,        1267,
};

static const uint16_t ud_itab__993[] = {
  /*  0 */           0,        1268,
};

static const uint16_t ud_itab__994[] = {
  /*  0 */           0,        1269,
};

static const uint16_t ud_itab__995[] = {
  /*  0 */           0,        1270,
};

static const uint16_t ud_itab__996[] = {
  /*  0 */           0,        1271,
};

static const uint16_t ud_itab__997[] = {
  /*  0 */           0,        1272,
};

static const uint16_t ud_itab__949[] = {
  /*  0 */  GROUP(950),  GROUP(951),  GROUP(952),  GROUP(953),
  /*  4 */  GROUP(954),  GROUP(955),  GROUP(956),  GROUP(957),
  /*  8 */  GROUP(958),  GROUP(959),  GROUP(960),  GROUP(961),
  /*  c */  GROUP(962),  GROUP(963),  GROUP(964),  GROUP(965),
  /* 10 */  GROUP(966),  GROUP(967),  GROUP(968),  GROUP(969),
  /* 14 */  GROUP(970),  GROUP(971),  GROUP(972),  GROUP(973),
  /* 18 */  GROUP(974),  GROUP(975),  GROUP(976),  GROUP(977),
  /* 1c */  GROUP(978),  GROUP(979),  GROUP(980),  GROUP(981),
  /* 20 */  GROUP(982),  GROUP(983),  GROUP(984),  GROUP(985),
  /* 24 */  GROUP(986),  GROUP(987),  GROUP(988),  GROUP(989),
  /* 28 */  GROUP(990),  GROUP(991),  GROUP(992),  GROUP(993),
  /* 2c */  GROUP(994),  GROUP(995),  GROUP(996),  GROUP(997),
  /* 30 */           0,           0,           0,           0,
  /* 34 */           0,           0,           0,           0,
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
};

static const uint16_t ud_itab__940[] = {
  /*  0 */  GROUP(941),  GROUP(949),
};

static const uint16_t ud_itab__1000[] = {
  /*  0 */        1273,           0,
};

static const uint16_t ud_itab__1001[] = {
  /*  0 */        1274,           0,
};

static const uint16_t ud_itab__1002[] = {
  /*  0 */        1275,           0,
};

static const uint16_t ud_itab__1003[] = {
  /*  0 */        1276,           0,
};

static const uint16_t ud_itab__1004[] = {
  /*  0 */        1277,           0,
};

static const uint16_t ud_itab__1005[] = {
  /*  0 */        1278,           0,
};

static const uint16_t ud_itab__1006[] = {
  /*  0 */        1279,           0,
};

static const uint16_t ud_itab__1007[] = {
  /*  0 */        1280,           0,
};

static const uint16_t ud_itab__999[] = {
  /*  0 */ GROUP(1000), GROUP(1001), GROUP(1002), GROUP(1003),
  /*  4 */ GROUP(1004), GROUP(1005), GROUP(1006), GROUP(1007),
};

static const uint16_t ud_itab__1009[] = {
  /*  0 */           0,        1281,
};

static const uint16_t ud_itab__1010[] = {
  /*  0 */           0,        1282,
};

static const uint16_t ud_itab__1011[] = {
  /*  0 */           0,        1283,
};

static const uint16_t ud_itab__1012[] = {
  /*  0 */           0,        1284,
};

static const uint16_t ud_itab__1013[] = {
  /*  0 */           0,        1285,
};

static const uint16_t ud_itab__1014[] = {
  /*  0 */           0,        1286,
};

static const uint16_t ud_itab__1015[] = {
  /*  0 */           0,        1287,
};

static const uint16_t ud_itab__1016[] = {
  /*  0 */           0,        1288,
};

static const uint16_t ud_itab__1017[] = {
  /*  0 */           0,        1289,
};

static const uint16_t ud_itab__1018[] = {
  /*  0 */           0,        1290,
};

static const uint16_t ud_itab__1019[] = {
  /*  0 */           0,        1291,
};

static const uint16_t ud_itab__1020[] = {
  /*  0 */           0,        1292,
};

static const uint16_t ud_itab__1021[] = {
  /*  0 */           0,        1293,
};

static const uint16_t ud_itab__1022[] = {
  /*  0 */           0,        1294,
};

static const uint16_t ud_itab__1023[] = {
  /*  0 */           0,        1295,
};

static const uint16_t ud_itab__1024[] = {
  /*  0 */           0,        1296,
};

static const uint16_t ud_itab__1025[] = {
  /*  0 */           0,        1297,
};

static const uint16_t ud_itab__1026[] = {
  /*  0 */           0,        1298,
};

static const uint16_t ud_itab__1027[] = {
  /*  0 */           0,        1299,
};

static const uint16_t ud_itab__1028[] = {
  /*  0 */           0,        1300,
};

static const uint16_t ud_itab__1029[] = {
  /*  0 */           0,        1301,
};

static const uint16_t ud_itab__1030[] = {
  /*  0 */           0,        1302,
};

static const uint16_t ud_itab__1031[] = {
  /*  0 */           0,        1303,
};

static const uint16_t ud_itab__1032[] = {
  /*  0 */           0,        1304,
};

static const uint16_t ud_itab__1033[] = {
  /*  0 */           0,        1305,
};

static const uint16_t ud_itab__1034[] = {
  /*  0 */           0,        1306,
};

static const uint16_t ud_itab__1035[] = {
  /*  0 */           0,        1307,
};

static const uint16_t ud_itab__1036[] = {
  /*  0 */           0,        1308,
};

static const uint16_t ud_itab__1037[] = {
  /*  0 */           0,        1309,
};

static const uint16_t ud_itab__1038[] = {
  /*  0 */           0,        1310,
};

static const uint16_t ud_itab__1039[] = {
  /*  0 */           0,        1311,
};

static const uint16_t ud_itab__1040[] = {
  /*  0 */           0,        1312,
};

static const uint16_t ud_itab__1041[] = {
  /*  0 */           0,        1313,
};

static const uint16_t ud_itab__1042[] = {
  /*  0 */           0,        1314,
};

static const uint16_t ud_itab__1043[] = {
  /*  0 */           0,        1315,
};

static const uint16_t ud_itab__1044[] = {
  /*  0 */           0,        1316,
};

static const uint16_t ud_itab__1045[] = {
  /*  0 */           0,        1317,
};

static const uint16_t ud_itab__1046[] = {
  /*  0 */           0,        1318,
};

static const uint16_t ud_itab__1047[] = {
  /*  0 */           0,        1319,
};

static const uint16_t ud_itab__1048[] = {
  /*  0 */           0,        1320,
};

static const uint16_t ud_itab__1049[] = {
  /*  0 */           0,        1321,
};

static const uint16_t ud_itab__1050[] = {
  /*  0 */           0,        1322,
};

static const uint16_t ud_itab__1051[] = {
  /*  0 */           0,        1323,
};

static const uint16_t ud_itab__1052[] = {
  /*  0 */           0,        1324,
};

static const uint16_t ud_itab__1053[] = {
  /*  0 */           0,        1325,
};

static const uint16_t ud_itab__1054[] = {
  /*  0 */           0,        1326,
};

static const uint16_t ud_itab__1055[] = {
  /*  0 */           0,        1327,
};

static const uint16_t ud_itab__1056[] = {
  /*  0 */           0,        1328,
};

static const uint16_t ud_itab__1057[] = {
  /*  0 */           0,        1329,
};

static const uint16_t ud_itab__1058[] = {
  /*  0 */           0,        1330,
};

static const uint16_t ud_itab__1059[] = {
  /*  0 */           0,        1331,
};

static const uint16_t ud_itab__1060[] = {
  /*  0 */           0,        1332,
};

static const uint16_t ud_itab__1061[] = {
  /*  0 */           0,        1333,
};

static const uint16_t ud_itab__1062[] = {
  /*  0 */           0,        1334,
};

static const uint16_t ud_itab__1063[] = {
  /*  0 */           0,        1335,
};

static const uint16_t ud_itab__1064[] = {
  /*  0 */           0,        1336,
};

static const uint16_t ud_itab__1065[] = {
  /*  0 */           0,        1337,
};

static const uint16_t ud_itab__1008[] = {
  /*  0 */ GROUP(1009), GROUP(1010), GROUP(1011), GROUP(1012),
  /*  4 */ GROUP(1013), GROUP(1014), GROUP(1015), GROUP(1016),
  /*  8 */ GROUP(1017), GROUP(1018), GROUP(1019), GROUP(1020),
  /*  c */ GROUP(1021), GROUP(1022), GROUP(1023), GROUP(1024),
  /* 10 */ GROUP(1025), GROUP(1026), GROUP(1027), GROUP(1028),
  /* 14 */ GROUP(1029), GROUP(1030), GROUP(1031), GROUP(1032),
  /* 18 */           0, GROUP(1033),           0,           0,
  /* 1c */           0,           0,           0,           0,
  /* 20 */ GROUP(1034), GROUP(1035), GROUP(1036), GROUP(1037),
  /* 24 */ GROUP(1038), GROUP(1039), GROUP(1040), GROUP(1041),
  /* 28 */ GROUP(1042), GROUP(1043), GROUP(1044), GROUP(1045),
  /* 2c */ GROUP(1046), GROUP(1047), GROUP(1048), GROUP(1049),
  /* 30 */ GROUP(1050), GROUP(1051), GROUP(1052), GROUP(1053),
  /* 34 */ GROUP(1054), GROUP(1055), GROUP(1056), GROUP(1057),
  /* 38 */ GROUP(1058), GROUP(1059), GROUP(1060), GROUP(1061),
  /* 3c */ GROUP(1062), GROUP(1063), GROUP(1064), GROUP(1065),
};

static const uint16_t ud_itab__998[] = {
  /*  0 */  GROUP(999), GROUP(1008),
};

static const uint16_t ud_itab__1068[] = {
  /*  0 */        1338,           0,
};

static const uint16_t ud_itab__1069[] = {
  /*  0 */        1339,           0,
};

static const uint16_t ud_itab__1070[] = {
  /*  0 */        1340,           0,
};

static const uint16_t ud_itab__1071[] = {
  /*  0 */        1341,           0,
};

static const uint16_t ud_itab__1072[] = {
  /*  0 */        1342,           0,
};

static const uint16_t ud_itab__1073[] = {
  /*  0 */        1343,           0,
};

static const uint16_t ud_itab__1074[] = {
  /*  0 */        1344,           0,
};

static const uint16_t ud_itab__1075[] = {
  /*  0 */        1345,           0,
};

static const uint16_t ud_itab__1067[] = {
  /*  0 */ GROUP(1068), GROUP(1069), GROUP(1070), GROUP(1071),
  /*  4 */ GROUP(1072), GROUP(1073), GROUP(1074), GROUP(1075),
};

static const uint16_t ud_itab__1077[] = {
  /*  0 */           0,        1346,
};

static const uint16_t ud_itab__1078[] = {
  /*  0 */           0,        1347,
};

static const uint16_t ud_itab__1079[] = {
  /*  0 */           0,        1348,
};

static const uint16_t ud_itab__1080[] = {
  /*  0 */           0,        1349,
};

static const uint16_t ud_itab__1081[] = {
  /*  0 */           0,        1350,
};

static const uint16_t ud_itab__1082[] = {
  /*  0 */           0,        1351,
};

static const uint16_t ud_itab__1083[] = {
  /*  0 */           0,        1352,
};

static const uint16_t ud_itab__1084[] = {
  /*  0 */           0,        1353,
};

static const uint16_t ud_itab__1085[] = {
  /*  0 */           0,        1354,
};

static const uint16_t ud_itab__1086[] = {
  /*  0 */           0,        1355,
};

static const uint16_t ud_itab__1087[] = {
  /*  0 */           0,        1356,
};

static const uint16_t ud_itab__1088[] = {
  /*  0 */           0,        1357,
};

static const uint16_t ud_itab__1089[] = {
  /*  0 */           0,        1358,
};

static const uint16_t ud_itab__1090[] = {
  /*  0 */           0,        1359,
};

static const uint16_t ud_itab__1091[] = {
  /*  0 */           0,        1360,
};

static const uint16_t ud_itab__1092[] = {
  /*  0 */           0,        1361,
};

static const uint16_t ud_itab__1093[] = {
  /*  0 */           0,        1362,
};

static const uint16_t ud_itab__1094[] = {
  /*  0 */           0,        1363,
};

static const uint16_t ud_itab__1095[] = {
  /*  0 */           0,        1364,
};

static const uint16_t ud_itab__1096[] = {
  /*  0 */           0,        1365,
};

static const uint16_t ud_itab__1097[] = {
  /*  0 */           0,        1366,
};

static const uint16_t ud_itab__1098[] = {
  /*  0 */           0,        1367,
};

static const uint16_t ud_itab__1099[] = {
  /*  0 */           0,        1368,
};

static const uint16_t ud_itab__1100[] = {
  /*  0 */           0,        1369,
};

static const uint16_t ud_itab__1101[] = {
  /*  0 */           0,        1370,
};

static const uint16_t ud_itab__1102[] = {
  /*  0 */           0,        1371,
};

static const uint16_t ud_itab__1103[] = {
  /*  0 */           0,        1372,
};

static const uint16_t ud_itab__1104[] = {
  /*  0 */           0,        1373,
};

static const uint16_t ud_itab__1105[] = {
  /*  0 */           0,        1374,
};

static const uint16_t ud_itab__1106[] = {
  /*  0 */           0,        1375,
};

static const uint16_t ud_itab__1107[] = {
  /*  0 */           0,        1376,
};

static const uint16_t ud_itab__1108[] = {
  /*  0 */           0,        1377,
};

static const uint16_t ud_itab__1109[] = {
  /*  0 */           0,        1378,
};

static const uint16_t ud_itab__1110[] = {
  /*  0 */           0,        1379,
};

static const uint16_t ud_itab__1111[] = {
  /*  0 */           0,        1380,
};

static const uint16_t ud_itab__1112[] = {
  /*  0 */           0,        1381,
};

static const uint16_t ud_itab__1113[] = {
  /*  0 */           0,        1382,
};

static const uint16_t ud_itab__1114[] = {
  /*  0 */           0,        1383,
};

static const uint16_t ud_itab__1115[] = {
  /*  0 */           0,        1384,
};

static const uint16_t ud_itab__1116[] = {
  /*  0 */           0,        1385,
};

static const uint16_t ud_itab__1117[] = {
  /*  0 */           0,        1386,
};

static const uint16_t ud_itab__1118[] = {
  /*  0 */           0,        1387,
};

static const uint16_t ud_itab__1119[] = {
  /*  0 */           0,        1388,
};

static const uint16_t ud_itab__1120[] = {
  /*  0 */           0,        1389,
};

static const uint16_t ud_itab__1121[] = {
  /*  0 */           0,        1390,
};

static const uint16_t ud_itab__1122[] = {
  /*  0 */           0,        1391,
};

static const uint16_t ud_itab__1123[] = {
  /*  0 */           0,        1392,
};

static const uint16_t ud_itab__1124[] = {
  /*  0 */           0,        1393,
};

static const uint16_t ud_itab__1125[] = {
  /*  0 */           0,        1394,
};

static const uint16_t ud_itab__1076[] = {
  /*  0 */ GROUP(1077), GROUP(1078), GROUP(1079), GROUP(1080),
  /*  4 */ GROUP(1081), GROUP(1082), GROUP(1083), GROUP(1084),
  /*  8 */ GROUP(1085), GROUP(1086), GROUP(1087), GROUP(1088),
  /*  c */ GROUP(1089), GROUP(1090), GROUP(1091), GROUP(1092),
  /* 10 */ GROUP(1093), GROUP(1094), GROUP(1095), GROUP(1096),
  /* 14 */ GROUP(1097), GROUP(1098), GROUP(1099), GROUP(1100),
  /* 18 */ GROUP(1101), GROUP(1102), GROUP(1103), GROUP(1104),
  /* 1c */ GROUP(1105), GROUP(1106), GROUP(1107), GROUP(1108),
  /* 20 */ GROUP(1109),           0,           0,           0,
  /* 24 */           0,           0,           0,           0,
  /* 28 */ GROUP(1110), GROUP(1111), GROUP(1112), GROUP(1113),
  /* 2c */ GROUP(1114), GROUP(1115), GROUP(1116), GROUP(1117),
  /* 30 */ GROUP(1118), GROUP(1119), GROUP(1120), GROUP(1121),
  /* 34 */ GROUP(1122), GROUP(1123), GROUP(1124), GROUP(1125),
  /* 38 */           0,           0,           0,           0,
  /* 3c */           0,           0,           0,           0,
};

static const uint16_t ud_itab__1066[] = {
  /*  0 */ GROUP(1067), GROUP(1076),
};

static const uint16_t ud_itab__1126[] = {
  /*  0 */        1398,        1399,        1400,
};

static const uint16_t ud_itab__1127[] = {
  /*  0 */        1407,           0,
};

static const uint16_t ud_itab__1128[] = {
  /*  0 */        1419,        1420,        1421,        1422,
  /*  4 */        1423,        1424,        1425,        1426,
};

static const uint16_t ud_itab__1129[] = {
  /*  0 */        1427,        1428,        1429,        1430,
  /*  4 */        1431,        1432,        1433,        1434,
};

static const uint16_t ud_itab__1130[] = {
  /*  0 */        1441,        1442,           0,           0,
  /*  4 */           0,           0,           0,           0,
};

static const uint16_t ud_itab__1132[] = {
  /*  0 */        1445,        1446,
};

static const uint16_t ud_itab__1131[] = {
  /*  0 */        1443,        1444, GROUP(1132),        1447,
  /*  4 */        1448,        1449,        1450,           0,
};

const uint16_t ud_itab__0[] = {
  /*  0 */           1,           2,           3,           4,
  /*  4 */           5,           6,    GROUP(1),    GROUP(2),
  /*  8 */           9,          10,          11,          12,
  /*  c */          13,          14,    GROUP(3),    GROUP(4),
  /* 10 */         628,         629,         630,         631,
  /* 14 */         632,         633,  GROUP(563),  GROUP(564),
  /* 18 */         636,         637,         638,         639,
  /* 1c */         640,         641,  GROUP(565),  GROUP(566),
  /* 20 */         644,         645,         646,         647,
  /* 24 */         648,         649,           0,  GROUP(567),
  /* 28 */         651,         652,         653,         654,
  /* 2c */         655,         656,           0,  GROUP(568),
  /* 30 */         658,         659,         660,         661,
  /* 34 */         662,         663,           0,  GROUP(569),
  /* 38 */         665,         666,         667,         668,
  /* 3c */         669,         670,           0,  GROUP(570),
  /* 40 */         672,         673,         674,         675,
  /* 44 */         676,         677,         678,         679,
  /* 48 */         680,         681,         682,         683,
  /* 4c */         684,         685,         686,         687,
  /* 50 */         688,         689,         690,         691,
  /* 54 */         692,         693,         694,         695,
  /* 58 */         696,         697,         698,         699,
  /* 5c */         700,         701,         702,         703,
  /* 60 */  GROUP(571),  GROUP(574),  GROUP(577),  GROUP(578),
  /* 64 */           0,           0,           0,           0,
  /* 68 */         711,         712,         713,         714,
  /* 6c */         715,  GROUP(579),         718,  GROUP(580),
  /* 70 */         721,         722,         723,         724,
  /* 74 */         725,         726,         727,         728,
  /* 78 */         729,         730,         731,         732,
  /* 7c */         733,         734,         735,         736,
  /* 80 */  GROUP(581),  GROUP(582),  GROUP(583),  GROUP(592),
  /* 84 */         769,         770,         771,         772,
  /* 88 */         773,         774,         775,         776,
  /* 8c */         777,         778,         779,  GROUP(593),
  /* 90 */         781,         782,         783,         784,
  /* 94 */         785,         786,         787,         788,
  /* 98 */  GROUP(594),  GROUP(595),  GROUP(596),         796,
  /* 9c */  GROUP(597),  GROUP(601),         806,         807,
  /* a0 */         808,         809,         810,         811,
  /* a4 */         812,  GROUP(605),         816,  GROUP(606),
  /* a8 */         820,         821,         822,  GROUP(607),
  /* ac */         826,  GROUP(608),         830,  GROUP(609),
  /* b0 */         834,         835,         836,         837,
  /* b4 */         838,         839,         840,         841,
  /* b8 */         842,         843,         844,         845,
  /* bc */         846,         847,         848,         849,
  /* c0 */  GROUP(610),  GROUP(611),         866,         867,
  /* c4 */  GROUP(612),  GROUP(613),  GROUP(614),  GROUP(615),
  /* c8 */         872,         873,         874,         875,
  /* cc */         876,         877,  GROUP(616),  GROUP(617),
  /* d0 */  GROUP(618),  GROUP(619),  GROUP(620),  GROUP(621),
  /* d4 */  GROUP(622),  GROUP(623),  GROUP(624),         917,
  /* d8 */  GROUP(625),  GROUP(700),  GROUP(762),  GROUP(806),
  /* dc */  GROUP(865),  GROUP(940),  GROUP(998), GROUP(1066),
  /* e0 */        1395,        1396,        1397, GROUP(1126),
  /* e4 */        1401,        1402,        1403,        1404,
  /* e8 */        1405,        1406, GROUP(1127),        1408,
  /* ec */        1409,        1410,        1411,        1412,
  /* f0 */        1413,        1414,        1415,        1416,
  /* f4 */        1417,        1418, GROUP(1128), GROUP(1129),
  /* f8 */        1435,        1436,        1437,        1438,
  /* fc */        1439,        1440, GROUP(1130), GROUP(1131),
};


struct ud_lookup_table_list_entry ud_lookup_table_list[] = {
    /* 000 */ { ud_itab__0, UD_TAB__OPC_TABLE, "table0" },
    /* 001 */ { ud_itab__1, UD_TAB__OPC_MODE, "/m" },
    /* 002 */ { ud_itab__2, UD_TAB__OPC_MODE, "/m" },
    /* 003 */ { ud_itab__3, UD_TAB__OPC_MODE, "/m" },
    /* 004 */ { ud_itab__4, UD_TAB__OPC_TABLE, "0f" },
    /* 005 */ { ud_itab__5, UD_TAB__OPC_REG, "/reg" },
    /* 006 */ { ud_itab__6, UD_TAB__OPC_SSE, "/sse" },
    /* 007 */ { ud_itab__7, UD_TAB__OPC_SSE, "/sse" },
    /* 008 */ { ud_itab__8, UD_TAB__OPC_SSE, "/sse" },
    /* 009 */ { ud_itab__9, UD_TAB__OPC_SSE, "/sse" },
    /* 010 */ { ud_itab__10, UD_TAB__OPC_SSE, "/sse" },
    /* 011 */ { ud_itab__11, UD_TAB__OPC_SSE, "/sse" },
    /* 012 */ { ud_itab__12, UD_TAB__OPC_MOD, "/mod" },
    /* 013 */ { ud_itab__13, UD_TAB__OPC_REG, "/reg" },
    /* 014 */ { ud_itab__14, UD_TAB__OPC_SSE, "/sse" },
    /* 015 */ { ud_itab__15, UD_TAB__OPC_MOD, "/mod" },
    /* 016 */ { ud_itab__16, UD_TAB__OPC_SSE, "/sse" },
    /* 017 */ { ud_itab__17, UD_TAB__OPC_MOD, "/mod" },
    /* 018 */ { ud_itab__18, UD_TAB__OPC_SSE, "/sse" },
    /* 019 */ { ud_itab__19, UD_TAB__OPC_MOD, "/mod" },
    /* 020 */ { ud_itab__20, UD_TAB__OPC_SSE, "/sse" },
    /* 021 */ { ud_itab__21, UD_TAB__OPC_MOD, "/mod" },
    /* 022 */ { ud_itab__22, UD_TAB__OPC_SSE, "/sse" },
    /* 023 */ { ud_itab__23, UD_TAB__OPC_MOD, "/mod" },
    /* 024 */ { ud_itab__24, UD_TAB__OPC_SSE, "/sse" },
    /* 025 */ { ud_itab__25, UD_TAB__OPC_MOD, "/mod" },
    /* 026 */ { ud_itab__26, UD_TAB__OPC_SSE, "/sse" },
    /* 027 */ { ud_itab__27, UD_TAB__OPC_MOD, "/mod" },
    /* 028 */ { ud_itab__28, UD_TAB__OPC_REG, "/reg" },
    /* 029 */ { ud_itab__29, UD_TAB__OPC_RM, "/rm" },
    /* 030 */ { ud_itab__30, UD_TAB__OPC_SSE, "/sse" },
    /* 031 */ { ud_itab__31, UD_TAB__OPC_MOD, "/mod" },
    /* 032 */ { ud_itab__32, UD_TAB__OPC_VENDOR, "intel" },
    /* 033 */ { ud_itab__33, UD_TAB__OPC_SSE, "/sse" },
    /* 034 */ { ud_itab__34, UD_TAB__OPC_MOD, "/mod" },
    /* 035 */ { ud_itab__35, UD_TAB__OPC_VENDOR, "intel" },
    /* 036 */ { ud_itab__36, UD_TAB__OPC_SSE, "/sse" },
    /* 037 */ { ud_itab__37, UD_TAB__OPC_MOD, "/mod" },
    /* 038 */ { ud_itab__38, UD_TAB__OPC_VENDOR, "intel" },
    /* 039 */ { ud_itab__39, UD_TAB__OPC_SSE, "/sse" },
    /* 040 */ { ud_itab__40, UD_TAB__OPC_MOD, "/mod" },
    /* 041 */ { ud_itab__41, UD_TAB__OPC_VENDOR, "intel" },
    /* 042 */ { ud_itab__42, UD_TAB__OPC_RM, "/rm" },
    /* 043 */ { ud_itab__43, UD_TAB__OPC_SSE, "/sse" },
    /* 044 */ { ud_itab__44, UD_TAB__OPC_MOD, "/mod" },
    /* 045 */ { ud_itab__45, UD_TAB__OPC_SSE, "/sse" },
    /* 046 */ { ud_itab__46, UD_TAB__OPC_MOD, "/mod" },
    /* 047 */ { ud_itab__47, UD_TAB__OPC_RM, "/rm" },
    /* 048 */ { ud_itab__48, UD_TAB__OPC_SSE, "/sse" },
    /* 049 */ { ud_itab__49, UD_TAB__OPC_MOD, "/mod" },
    /* 050 */ { ud_itab__50, UD_TAB__OPC_SSE, "/sse" },
    /* 051 */ { ud_itab__51, UD_TAB__OPC_MOD, "/mod" },
    /* 052 */ { ud_itab__52, UD_TAB__OPC_RM, "/rm" },
    /* 053 */ { ud_itab__53, UD_TAB__OPC_SSE, "/sse" },
    /* 054 */ { ud_itab__54, UD_TAB__OPC_MOD, "/mod" },
    /* 055 */ { ud_itab__55, UD_TAB__OPC_VENDOR, "amd" },
    /* 056 */ { ud_itab__56, UD_TAB__OPC_SSE, "/sse" },
    /* 057 */ { ud_itab__57, UD_TAB__OPC_MOD, "/mod" },
    /* 058 */ { ud_itab__58, UD_TAB__OPC_VENDOR, "amd" },
    /* 059 */ { ud_itab__59, UD_TAB__OPC_SSE, "/sse" },
    /* 060 */ { ud_itab__60, UD_TAB__OPC_MOD, "/mod" },
    /* 061 */ { ud_itab__61, UD_TAB__OPC_VENDOR, "amd" },
    /* 062 */ { ud_itab__62, UD_TAB__OPC_SSE, "/sse" },
    /* 063 */ { ud_itab__63, UD_TAB__OPC_MOD, "/mod" },
    /* 064 */ { ud_itab__64, UD_TAB__OPC_VENDOR, "amd" },
    /* 065 */ { ud_itab__65, UD_TAB__OPC_SSE, "/sse" },
    /* 066 */ { ud_itab__66, UD_TAB__OPC_MOD, "/mod" },
    /* 067 */ { ud_itab__67, UD_TAB__OPC_VENDOR, "amd" },
    /* 068 */ { ud_itab__68, UD_TAB__OPC_SSE, "/sse" },
    /* 069 */ { ud_itab__69, UD_TAB__OPC_MOD, "/mod" },
    /* 070 */ { ud_itab__70, UD_TAB__OPC_VENDOR, "amd" },
    /* 071 */ { ud_itab__71, UD_TAB__OPC_SSE, "/sse" },
    /* 072 */ { ud_itab__72, UD_TAB__OPC_MOD, "/mod" },
    /* 073 */ { ud_itab__73, UD_TAB__OPC_VENDOR, "amd" },
    /* 074 */ { ud_itab__74, UD_TAB__OPC_SSE, "/sse" },
    /* 075 */ { ud_itab__75, UD_TAB__OPC_MOD, "/mod" },
    /* 076 */ { ud_itab__76, UD_TAB__OPC_VENDOR, "amd" },
    /* 077 */ { ud_itab__77, UD_TAB__OPC_SSE, "/sse" },
    /* 078 */ { ud_itab__78, UD_TAB__OPC_MOD, "/mod" },
    /* 079 */ { ud_itab__79, UD_TAB__OPC_SSE, "/sse" },
    /* 080 */ { ud_itab__80, UD_TAB__OPC_MOD, "/mod" },
    /* 081 */ { ud_itab__81, UD_TAB__OPC_RM, "/rm" },
    /* 082 */ { ud_itab__82, UD_TAB__OPC_SSE, "/sse" },
    /* 083 */ { ud_itab__83, UD_TAB__OPC_MOD, "/mod" },
    /* 084 */ { ud_itab__84, UD_TAB__OPC_SSE, "/sse" },
    /* 085 */ { ud_itab__85, UD_TAB__OPC_MOD, "/mod" },
    /* 086 */ { ud_itab__86, UD_TAB__OPC_VENDOR, "amd" },
    /* 087 */ { ud_itab__87, UD_TAB__OPC_SSE, "/sse" },
    /* 088 */ { ud_itab__88, UD_TAB__OPC_SSE, "/sse" },
    /* 089 */ { ud_itab__89, UD_TAB__OPC_SSE, "/sse" },
    /* 090 */ { ud_itab__90, UD_TAB__OPC_SSE, "/sse" },
    /* 091 */ { ud_itab__91, UD_TAB__OPC_SSE, "/sse" },
    /* 092 */ { ud_itab__92, UD_TAB__OPC_SSE, "/sse" },
    /* 093 */ { ud_itab__93, UD_TAB__OPC_SSE, "/sse" },
    /* 094 */ { ud_itab__94, UD_TAB__OPC_SSE, "/sse" },
    /* 095 */ { ud_itab__95, UD_TAB__OPC_REG, "/reg" },
    /* 096 */ { ud_itab__96, UD_TAB__OPC_SSE, "/sse" },
    /* 097 */ { ud_itab__97, UD_TAB__OPC_SSE, "/sse" },
    /* 098 */ { ud_itab__98, UD_TAB__OPC_SSE, "/sse" },
    /* 099 */ { ud_itab__99, UD_TAB__OPC_SSE, "/sse" },
    /* 100 */ { ud_itab__100, UD_TAB__OPC_SSE, "/sse" },
    /* 101 */ { ud_itab__101, UD_TAB__OPC_SSE, "/sse" },
    /* 102 */ { ud_itab__102, UD_TAB__OPC_SSE, "/sse" },
    /* 103 */ { ud_itab__103, UD_TAB__OPC_SSE, "/sse" },
    /* 104 */ { ud_itab__104, UD_TAB__OPC_SSE, "/sse" },
    /* 105 */ { ud_itab__105, UD_TAB__OPC_3DNOW, "/3dnow" },
    /* 106 */ { ud_itab__106, UD_TAB__OPC_SSE, "/sse" },
    /* 107 */ { ud_itab__107, UD_TAB__OPC_SSE, "/sse" },
    /* 108 */ { ud_itab__108, UD_TAB__OPC_MOD, "/mod" },
    /* 109 */ { ud_itab__109, UD_TAB__OPC_SSE, "/sse" },
    /* 110 */ { ud_itab__110, UD_TAB__OPC_MOD, "/mod" },
    /* 111 */ { ud_itab__111, UD_TAB__OPC_MOD, "/mod" },
    /* 112 */ { ud_itab__112, UD_TAB__OPC_MOD, "/mod" },
    /* 113 */ { ud_itab__113, UD_TAB__OPC_MOD, "/mod" },
    /* 114 */ { ud_itab__114, UD_TAB__OPC_SSE, "/sse" },
    /* 115 */ { ud_itab__115, UD_TAB__OPC_MOD, "/mod" },
    /* 116 */ { ud_itab__116, UD_TAB__OPC_MOD, "/mod" },
    /* 117 */ { ud_itab__117, UD_TAB__OPC_MOD, "/mod" },
    /* 118 */ { ud_itab__118, UD_TAB__OPC_SSE, "/sse" },
    /* 119 */ { ud_itab__119, UD_TAB__OPC_SSE, "/sse" },
    /* 120 */ { ud_itab__120, UD_TAB__OPC_SSE, "/sse" },
    /* 121 */ { ud_itab__121, UD_TAB__OPC_MOD, "/mod" },
    /* 122 */ { ud_itab__122, UD_TAB__OPC_SSE, "/sse" },
    /* 123 */ { ud_itab__123, UD_TAB__OPC_MOD, "/mod" },
    /* 124 */ { ud_itab__124, UD_TAB__OPC_MOD, "/mod" },
    /* 125 */ { ud_itab__125, UD_TAB__OPC_MOD, "/mod" },
    /* 126 */ { ud_itab__126, UD_TAB__OPC_SSE, "/sse" },
    /* 127 */ { ud_itab__127, UD_TAB__OPC_MOD, "/mod" },
    /* 128 */ { ud_itab__128, UD_TAB__OPC_MOD, "/mod" },
    /* 129 */ { ud_itab__129, UD_TAB__OPC_SSE, "/sse" },
    /* 130 */ { ud_itab__130, UD_TAB__OPC_REG, "/reg" },
    /* 131 */ { ud_itab__131, UD_TAB__OPC_SSE, "/sse" },
    /* 132 */ { ud_itab__132, UD_TAB__OPC_SSE, "/sse" },
    /* 133 */ { ud_itab__133, UD_TAB__OPC_SSE, "/sse" },
    /* 134 */ { ud_itab__134, UD_TAB__OPC_SSE, "/sse" },
    /* 135 */ { ud_itab__135, UD_TAB__OPC_SSE, "/sse" },
    /* 136 */ { ud_itab__136, UD_TAB__OPC_SSE, "/sse" },
    /* 137 */ { ud_itab__137, UD_TAB__OPC_SSE, "/sse" },
    /* 138 */ { ud_itab__138, UD_TAB__OPC_SSE, "/sse" },
    /* 139 */ { ud_itab__139, UD_TAB__OPC_SSE, "/sse" },
    /* 140 */ { ud_itab__140, UD_TAB__OPC_SSE, "/sse" },
    /* 141 */ { ud_itab__141, UD_TAB__OPC_SSE, "/sse" },
    /* 142 */ { ud_itab__142, UD_TAB__OPC_SSE, "/sse" },
    /* 143 */ { ud_itab__143, UD_TAB__OPC_SSE, "/sse" },
    /* 144 */ { ud_itab__144, UD_TAB__OPC_SSE, "/sse" },
    /* 145 */ { ud_itab__145, UD_TAB__OPC_SSE, "/sse" },
    /* 146 */ { ud_itab__146, UD_TAB__OPC_SSE, "/sse" },
    /* 147 */ { ud_itab__147, UD_TAB__OPC_SSE, "/sse" },
    /* 148 */ { ud_itab__148, UD_TAB__OPC_SSE, "/sse" },
    /* 149 */ { ud_itab__149, UD_TAB__OPC_SSE, "/sse" },
    /* 150 */ { ud_itab__150, UD_TAB__OPC_SSE, "/sse" },
    /* 151 */ { ud_itab__151, UD_TAB__OPC_SSE, "/sse" },
    /* 152 */ { ud_itab__152, UD_TAB__OPC_SSE, "/sse" },
    /* 153 */ { ud_itab__153, UD_TAB__OPC_SSE, "/sse" },
    /* 154 */ { ud_itab__154, UD_TAB__OPC_SSE, "/sse" },
    /* 155 */ { ud_itab__155, UD_TAB__OPC_SSE, "/sse" },
    /* 156 */ { ud_itab__156, UD_TAB__OPC_SSE, "/sse" },
    /* 157 */ { ud_itab__157, UD_TAB__OPC_SSE, "/sse" },
    /* 158 */ { ud_itab__158, UD_TAB__OPC_SSE, "/sse" },
    /* 159 */ { ud_itab__159, UD_TAB__OPC_MODE, "/m" },
    /* 160 */ { ud_itab__160, UD_TAB__OPC_VENDOR, "intel" },
    /* 161 */ { ud_itab__161, UD_TAB__OPC_SSE, "/sse" },
    /* 162 */ { ud_itab__162, UD_TAB__OPC_MODE, "/m" },
    /* 163 */ { ud_itab__163, UD_TAB__OPC_VENDOR, "intel" },
    /* 164 */ { ud_itab__164, UD_TAB__OPC_SSE, "/sse" },
    /* 165 */ { ud_itab__165, UD_TAB__OPC_TABLE, "38" },
    /* 166 */ { ud_itab__166, UD_TAB__OPC_SSE, "/sse" },
    /* 167 */ { ud_itab__167, UD_TAB__OPC_SSE, "/sse" },
    /* 168 */ { ud_itab__168, UD_TAB__OPC_SSE, "/sse" },
    /* 169 */ { ud_itab__169, UD_TAB__OPC_SSE, "/sse" },
    /* 170 */ { ud_itab__170, UD_TAB__OPC_SSE, "/sse" },
    /* 171 */ { ud_itab__171, UD_TAB__OPC_SSE, "/sse" },
    /* 172 */ { ud_itab__172, UD_TAB__OPC_SSE, "/sse" },
    /* 173 */ { ud_itab__173, UD_TAB__OPC_SSE, "/sse" },
    /* 174 */ { ud_itab__174, UD_TAB__OPC_SSE, "/sse" },
    /* 175 */ { ud_itab__175, UD_TAB__OPC_SSE, "/sse" },
    /* 176 */ { ud_itab__176, UD_TAB__OPC_SSE, "/sse" },
    /* 177 */ { ud_itab__177, UD_TAB__OPC_SSE, "/sse" },
    /* 178 */ { ud_itab__178, UD_TAB__OPC_SSE, "/sse" },
    /* 179 */ { ud_itab__179, UD_TAB__OPC_SSE, "/sse" },
    /* 180 */ { ud_itab__180, UD_TAB__OPC_SSE, "/sse" },
    /* 181 */ { ud_itab__181, UD_TAB__OPC_SSE, "/sse" },
    /* 182 */ { ud_itab__182, UD_TAB__OPC_SSE, "/sse" },
    /* 183 */ { ud_itab__183, UD_TAB__OPC_SSE, "/sse" },
    /* 184 */ { ud_itab__184, UD_TAB__OPC_SSE, "/sse" },
    /* 185 */ { ud_itab__185, UD_TAB__OPC_SSE, "/sse" },
    /* 186 */ { ud_itab__186, UD_TAB__OPC_SSE, "/sse" },
    /* 187 */ { ud_itab__187, UD_TAB__OPC_SSE, "/sse" },
    /* 188 */ { ud_itab__188, UD_TAB__OPC_SSE, "/sse" },
    /* 189 */ { ud_itab__189, UD_TAB__OPC_SSE, "/sse" },
    /* 190 */ { ud_itab__190, UD_TAB__OPC_SSE, "/sse" },
    /* 191 */ { ud_itab__191, UD_TAB__OPC_SSE, "/sse" },
    /* 192 */ { ud_itab__192, UD_TAB__OPC_SSE, "/sse" },
    /* 193 */ { ud_itab__193, UD_TAB__OPC_SSE, "/sse" },
    /* 194 */ { ud_itab__194, UD_TAB__OPC_SSE, "/sse" },
    /* 195 */ { ud_itab__195, UD_TAB__OPC_SSE, "/sse" },
    /* 196 */ { ud_itab__196, UD_TAB__OPC_SSE, "/sse" },
    /* 197 */ { ud_itab__197, UD_TAB__OPC_SSE, "/sse" },
    /* 198 */ { ud_itab__198, UD_TAB__OPC_SSE, "/sse" },
    /* 199 */ { ud_itab__199, UD_TAB__OPC_SSE, "/sse" },
    /* 200 */ { ud_itab__200, UD_TAB__OPC_SSE, "/sse" },
    /* 201 */ { ud_itab__201, UD_TAB__OPC_SSE, "/sse" },
    /* 202 */ { ud_itab__202, UD_TAB__OPC_SSE, "/sse" },
    /* 203 */ { ud_itab__203, UD_TAB__OPC_SSE, "/sse" },
    /* 204 */ { ud_itab__204, UD_TAB__OPC_SSE, "/sse" },
    /* 205 */ { ud_itab__205, UD_TAB__OPC_SSE, "/sse" },
    /* 206 */ { ud_itab__206, UD_TAB__OPC_SSE, "/sse" },
    /* 207 */ { ud_itab__207, UD_TAB__OPC_SSE, "/sse" },
    /* 208 */ { ud_itab__208, UD_TAB__OPC_SSE, "/sse" },
    /* 209 */ { ud_itab__209, UD_TAB__OPC_SSE, "/sse" },
    /* 210 */ { ud_itab__210, UD_TAB__OPC_SSE, "/sse" },
    /* 211 */ { ud_itab__211, UD_TAB__OPC_SSE, "/sse" },
    /* 212 */ { ud_itab__212, UD_TAB__OPC_SSE, "/sse" },
    /* 213 */ { ud_itab__213, UD_TAB__OPC_MODE, "/m" },
    /* 214 */ { ud_itab__214, UD_TAB__OPC_VENDOR, "intel" },
    /* 215 */ { ud_itab__215, UD_TAB__OPC_SSE, "/sse" },
    /* 216 */ { ud_itab__216, UD_TAB__OPC_MODE, "/m" },
    /* 217 */ { ud_itab__217, UD_TAB__OPC_VENDOR, "intel" },
    /* 218 */ { ud_itab__218, UD_TAB__OPC_SSE, "/sse" },
    /* 219 */ { ud_itab__219, UD_TAB__OPC_SSE, "/sse" },
    /* 220 */ { ud_itab__220, UD_TAB__OPC_SSE, "/sse" },
    /* 221 */ { ud_itab__221, UD_TAB__OPC_SSE, "/sse" },
    /* 222 */ { ud_itab__222, UD_TAB__OPC_SSE, "/sse" },
    /* 223 */ { ud_itab__223, UD_TAB__OPC_SSE, "/sse" },
    /* 224 */ { ud_itab__224, UD_TAB__OPC_SSE, "/sse" },
    /* 225 */ { ud_itab__225, UD_TAB__OPC_TABLE, "3a" },
    /* 226 */ { ud_itab__226, UD_TAB__OPC_SSE, "/sse" },
    /* 227 */ { ud_itab__227, UD_TAB__OPC_SSE, "/sse" },
    /* 228 */ { ud_itab__228, UD_TAB__OPC_SSE, "/sse" },
    /* 229 */ { ud_itab__229, UD_TAB__OPC_SSE, "/sse" },
    /* 230 */ { ud_itab__230, UD_TAB__OPC_SSE, "/sse" },
    /* 231 */ { ud_itab__231, UD_TAB__OPC_SSE, "/sse" },
    /* 232 */ { ud_itab__232, UD_TAB__OPC_SSE, "/sse" },
    /* 233 */ { ud_itab__233, UD_TAB__OPC_SSE, "/sse" },
    /* 234 */ { ud_itab__234, UD_TAB__OPC_SSE, "/sse" },
    /* 235 */ { ud_itab__235, UD_TAB__OPC_SSE, "/sse" },
    /* 236 */ { ud_itab__236, UD_TAB__OPC_SSE, "/sse" },
    /* 237 */ { ud_itab__237, UD_TAB__OPC_OSIZE, "/o" },
    /* 238 */ { ud_itab__238, UD_TAB__OPC_SSE, "/sse" },
    /* 239 */ { ud_itab__239, UD_TAB__OPC_SSE, "/sse" },
    /* 240 */ { ud_itab__240, UD_TAB__OPC_SSE, "/sse" },
    /* 241 */ { ud_itab__241, UD_TAB__OPC_SSE, "/sse" },
    /* 242 */ { ud_itab__242, UD_TAB__OPC_OSIZE, "/o" },
    /* 243 */ { ud_itab__243, UD_TAB__OPC_SSE, "/sse" },
    /* 244 */ { ud_itab__244, UD_TAB__OPC_SSE, "/sse" },
    /* 245 */ { ud_itab__245, UD_TAB__OPC_SSE, "/sse" },
    /* 246 */ { ud_itab__246, UD_TAB__OPC_SSE, "/sse" },
    /* 247 */ { ud_itab__247, UD_TAB__OPC_SSE, "/sse" },
    /* 248 */ { ud_itab__248, UD_TAB__OPC_SSE, "/sse" },
    /* 249 */ { ud_itab__249, UD_TAB__OPC_SSE, "/sse" },
    /* 250 */ { ud_itab__250, UD_TAB__OPC_SSE, "/sse" },
    /* 251 */ { ud_itab__251, UD_TAB__OPC_SSE, "/sse" },
    /* 252 */ { ud_itab__252, UD_TAB__OPC_SSE, "/sse" },
    /* 253 */ { ud_itab__253, UD_TAB__OPC_SSE, "/sse" },
    /* 254 */ { ud_itab__254, UD_TAB__OPC_SSE, "/sse" },
    /* 255 */ { ud_itab__255, UD_TAB__OPC_SSE, "/sse" },
    /* 256 */ { ud_itab__256, UD_TAB__OPC_SSE, "/sse" },
    /* 257 */ { ud_itab__257, UD_TAB__OPC_SSE, "/sse" },
    /* 258 */ { ud_itab__258, UD_TAB__OPC_SSE, "/sse" },
    /* 259 */ { ud_itab__259, UD_TAB__OPC_SSE, "/sse" },
    /* 260 */ { ud_itab__260, UD_TAB__OPC_SSE, "/sse" },
    /* 261 */ { ud_itab__261, UD_TAB__OPC_SSE, "/sse" },
    /* 262 */ { ud_itab__262, UD_TAB__OPC_SSE, "/sse" },
    /* 263 */ { ud_itab__263, UD_TAB__OPC_SSE, "/sse" },
    /* 264 */ { ud_itab__264, UD_TAB__OPC_SSE, "/sse" },
    /* 265 */ { ud_itab__265, UD_TAB__OPC_SSE, "/sse" },
    /* 266 */ { ud_itab__266, UD_TAB__OPC_SSE, "/sse" },
    /* 267 */ { ud_itab__267, UD_TAB__OPC_SSE, "/sse" },
    /* 268 */ { ud_itab__268, UD_TAB__OPC_SSE, "/sse" },
    /* 269 */ { ud_itab__269, UD_TAB__OPC_SSE, "/sse" },
    /* 270 */ { ud_itab__270, UD_TAB__OPC_SSE, "/sse" },
    /* 271 */ { ud_itab__271, UD_TAB__OPC_SSE, "/sse" },
    /* 272 */ { ud_itab__272, UD_TAB__OPC_SSE, "/sse" },
    /* 273 */ { ud_itab__273, UD_TAB__OPC_SSE, "/sse" },
    /* 274 */ { ud_itab__274, UD_TAB__OPC_SSE, "/sse" },
    /* 275 */ { ud_itab__275, UD_TAB__OPC_SSE, "/sse" },
    /* 276 */ { ud_itab__276, UD_TAB__OPC_SSE, "/sse" },
    /* 277 */ { ud_itab__277, UD_TAB__OPC_SSE, "/sse" },
    /* 278 */ { ud_itab__278, UD_TAB__OPC_SSE, "/sse" },
    /* 279 */ { ud_itab__279, UD_TAB__OPC_SSE, "/sse" },
    /* 280 */ { ud_itab__280, UD_TAB__OPC_SSE, "/sse" },
    /* 281 */ { ud_itab__281, UD_TAB__OPC_SSE, "/sse" },
    /* 282 */ { ud_itab__282, UD_TAB__OPC_SSE, "/sse" },
    /* 283 */ { ud_itab__283, UD_TAB__OPC_SSE, "/sse" },
    /* 284 */ { ud_itab__284, UD_TAB__OPC_SSE, "/sse" },
    /* 285 */ { ud_itab__285, UD_TAB__OPC_SSE, "/sse" },
    /* 286 */ { ud_itab__286, UD_TAB__OPC_SSE, "/sse" },
    /* 287 */ { ud_itab__287, UD_TAB__OPC_SSE, "/sse" },
    /* 288 */ { ud_itab__288, UD_TAB__OPC_SSE, "/sse" },
    /* 289 */ { ud_itab__289, UD_TAB__OPC_SSE, "/sse" },
    /* 290 */ { ud_itab__290, UD_TAB__OPC_SSE, "/sse" },
    /* 291 */ { ud_itab__291, UD_TAB__OPC_SSE, "/sse" },
    /* 292 */ { ud_itab__292, UD_TAB__OPC_SSE, "/sse" },
    /* 293 */ { ud_itab__293, UD_TAB__OPC_SSE, "/sse" },
    /* 294 */ { ud_itab__294, UD_TAB__OPC_SSE, "/sse" },
    /* 295 */ { ud_itab__295, UD_TAB__OPC_SSE, "/sse" },
    /* 296 */ { ud_itab__296, UD_TAB__OPC_SSE, "/sse" },
    /* 297 */ { ud_itab__297, UD_TAB__OPC_SSE, "/sse" },
    /* 298 */ { ud_itab__298, UD_TAB__OPC_SSE, "/sse" },
    /* 299 */ { ud_itab__299, UD_TAB__OPC_SSE, "/sse" },
    /* 300 */ { ud_itab__300, UD_TAB__OPC_SSE, "/sse" },
    /* 301 */ { ud_itab__301, UD_TAB__OPC_REG, "/reg" },
    /* 302 */ { ud_itab__302, UD_TAB__OPC_SSE, "/sse" },
    /* 303 */ { ud_itab__303, UD_TAB__OPC_SSE, "/sse" },
    /* 304 */ { ud_itab__304, UD_TAB__OPC_SSE, "/sse" },
    /* 305 */ { ud_itab__305, UD_TAB__OPC_REG, "/reg" },
    /* 306 */ { ud_itab__306, UD_TAB__OPC_SSE, "/sse" },
    /* 307 */ { ud_itab__307, UD_TAB__OPC_SSE, "/sse" },
    /* 308 */ { ud_itab__308, UD_TAB__OPC_SSE, "/sse" },
    /* 309 */ { ud_itab__309, UD_TAB__OPC_REG, "/reg" },
    /* 310 */ { ud_itab__310, UD_TAB__OPC_SSE, "/sse" },
    /* 311 */ { ud_itab__311, UD_TAB__OPC_SSE, "/sse" },
    /* 312 */ { ud_itab__312, UD_TAB__OPC_SSE, "/sse" },
    /* 313 */ { ud_itab__313, UD_TAB__OPC_SSE, "/sse" },
    /* 314 */ { ud_itab__314, UD_TAB__OPC_SSE, "/sse" },
    /* 315 */ { ud_itab__315, UD_TAB__OPC_SSE, "/sse" },
    /* 316 */ { ud_itab__316, UD_TAB__OPC_SSE, "/sse" },
    /* 317 */ { ud_itab__317, UD_TAB__OPC_SSE, "/sse" },
    /* 318 */ { ud_itab__318, UD_TAB__OPC_SSE, "/sse" },
    /* 319 */ { ud_itab__319, UD_TAB__OPC_VENDOR, "intel" },
    /* 320 */ { ud_itab__320, UD_TAB__OPC_SSE, "/sse" },
    /* 321 */ { ud_itab__321, UD_TAB__OPC_VENDOR, "intel" },
    /* 322 */ { ud_itab__322, UD_TAB__OPC_SSE, "/sse" },
    /* 323 */ { ud_itab__323, UD_TAB__OPC_SSE, "/sse" },
    /* 324 */ { ud_itab__324, UD_TAB__OPC_SSE, "/sse" },
    /* 325 */ { ud_itab__325, UD_TAB__OPC_SSE, "/sse" },
    /* 326 */ { ud_itab__326, UD_TAB__OPC_SSE, "/sse" },
    /* 327 */ { ud_itab__327, UD_TAB__OPC_SSE, "/sse" },
    /* 328 */ { ud_itab__328, UD_TAB__OPC_SSE, "/sse" },
    /* 329 */ { ud_itab__329, UD_TAB__OPC_SSE, "/sse" },
    /* 330 */ { ud_itab__330, UD_TAB__OPC_SSE, "/sse" },
    /* 331 */ { ud_itab__331, UD_TAB__OPC_SSE, "/sse" },
    /* 332 */ { ud_itab__332, UD_TAB__OPC_SSE, "/sse" },
    /* 333 */ { ud_itab__333, UD_TAB__OPC_SSE, "/sse" },
    /* 334 */ { ud_itab__334, UD_TAB__OPC_SSE, "/sse" },
    /* 335 */ { ud_itab__335, UD_TAB__OPC_SSE, "/sse" },
    /* 336 */ { ud_itab__336, UD_TAB__OPC_SSE, "/sse" },
    /* 337 */ { ud_itab__337, UD_TAB__OPC_SSE, "/sse" },
    /* 338 */ { ud_itab__338, UD_TAB__OPC_SSE, "/sse" },
    /* 339 */ { ud_itab__339, UD_TAB__OPC_SSE, "/sse" },
    /* 340 */ { ud_itab__340, UD_TAB__OPC_SSE, "/sse" },
    /* 341 */ { ud_itab__341, UD_TAB__OPC_SSE, "/sse" },
    /* 342 */ { ud_itab__342, UD_TAB__OPC_SSE, "/sse" },
    /* 343 */ { ud_itab__343, UD_TAB__OPC_SSE, "/sse" },
    /* 344 */ { ud_itab__344, UD_TAB__OPC_SSE, "/sse" },
    /* 345 */ { ud_itab__345, UD_TAB__OPC_SSE, "/sse" },
    /* 346 */ { ud_itab__346, UD_TAB__OPC_SSE, "/sse" },
    /* 347 */ { ud_itab__347, UD_TAB__OPC_SSE, "/sse" },
    /* 348 */ { ud_itab__348, UD_TAB__OPC_SSE, "/sse" },
    /* 349 */ { ud_itab__349, UD_TAB__OPC_SSE, "/sse" },
    /* 350 */ { ud_itab__350, UD_TAB__OPC_SSE, "/sse" },
    /* 351 */ { ud_itab__351, UD_TAB__OPC_SSE, "/sse" },
    /* 352 */ { ud_itab__352, UD_TAB__OPC_SSE, "/sse" },
    /* 353 */ { ud_itab__353, UD_TAB__OPC_SSE, "/sse" },
    /* 354 */ { ud_itab__354, UD_TAB__OPC_SSE, "/sse" },
    /* 355 */ { ud_itab__355, UD_TAB__OPC_SSE, "/sse" },
    /* 356 */ { ud_itab__356, UD_TAB__OPC_SSE, "/sse" },
    /* 357 */ { ud_itab__357, UD_TAB__OPC_SSE, "/sse" },
    /* 358 */ { ud_itab__358, UD_TAB__OPC_SSE, "/sse" },
    /* 359 */ { ud_itab__359, UD_TAB__OPC_SSE, "/sse" },
    /* 360 */ { ud_itab__360, UD_TAB__OPC_SSE, "/sse" },
    /* 361 */ { ud_itab__361, UD_TAB__OPC_SSE, "/sse" },
    /* 362 */ { ud_itab__362, UD_TAB__OPC_SSE, "/sse" },
    /* 363 */ { ud_itab__363, UD_TAB__OPC_SSE, "/sse" },
    /* 364 */ { ud_itab__364, UD_TAB__OPC_MOD, "/mod" },
    /* 365 */ { ud_itab__365, UD_TAB__OPC_REG, "/reg" },
    /* 366 */ { ud_itab__366, UD_TAB__OPC_RM, "/rm" },
    /* 367 */ { ud_itab__367, UD_TAB__OPC_SSE, "/sse" },
    /* 368 */ { ud_itab__368, UD_TAB__OPC_MOD, "/mod" },
    /* 369 */ { ud_itab__369, UD_TAB__OPC_RM, "/rm" },
    /* 370 */ { ud_itab__370, UD_TAB__OPC_SSE, "/sse" },
    /* 371 */ { ud_itab__371, UD_TAB__OPC_MOD, "/mod" },
    /* 372 */ { ud_itab__372, UD_TAB__OPC_RM, "/rm" },
    /* 373 */ { ud_itab__373, UD_TAB__OPC_SSE, "/sse" },
    /* 374 */ { ud_itab__374, UD_TAB__OPC_MOD, "/mod" },
    /* 375 */ { ud_itab__375, UD_TAB__OPC_MOD, "/mod" },
    /* 376 */ { ud_itab__376, UD_TAB__OPC_REG, "/reg" },
    /* 377 */ { ud_itab__377, UD_TAB__OPC_RM, "/rm" },
    /* 378 */ { ud_itab__378, UD_TAB__OPC_SSE, "/sse" },
    /* 379 */ { ud_itab__379, UD_TAB__OPC_MOD, "/mod" },
    /* 380 */ { ud_itab__380, UD_TAB__OPC_RM, "/rm" },
    /* 381 */ { ud_itab__381, UD_TAB__OPC_SSE, "/sse" },
    /* 382 */ { ud_itab__382, UD_TAB__OPC_MOD, "/mod" },
    /* 383 */ { ud_itab__383, UD_TAB__OPC_RM, "/rm" },
    /* 384 */ { ud_itab__384, UD_TAB__OPC_SSE, "/sse" },
    /* 385 */ { ud_itab__385, UD_TAB__OPC_MOD, "/mod" },
    /* 386 */ { ud_itab__386, UD_TAB__OPC_RM, "/rm" },
    /* 387 */ { ud_itab__387, UD_TAB__OPC_SSE, "/sse" },
    /* 388 */ { ud_itab__388, UD_TAB__OPC_MOD, "/mod" },
    /* 389 */ { ud_itab__389, UD_TAB__OPC_RM, "/rm" },
    /* 390 */ { ud_itab__390, UD_TAB__OPC_SSE, "/sse" },
    /* 391 */ { ud_itab__391, UD_TAB__OPC_MOD, "/mod" },
    /* 392 */ { ud_itab__392, UD_TAB__OPC_RM, "/rm" },
    /* 393 */ { ud_itab__393, UD_TAB__OPC_SSE, "/sse" },
    /* 394 */ { ud_itab__394, UD_TAB__OPC_MOD, "/mod" },
    /* 395 */ { ud_itab__395, UD_TAB__OPC_SSE, "/sse" },
    /* 396 */ { ud_itab__396, UD_TAB__OPC_SSE, "/sse" },
    /* 397 */ { ud_itab__397, UD_TAB__OPC_SSE, "/sse" },
    /* 398 */ { ud_itab__398, UD_TAB__OPC_SSE, "/sse" },
    /* 399 */ { ud_itab__399, UD_TAB__OPC_SSE, "/sse" },
    /* 400 */ { ud_itab__400, UD_TAB__OPC_SSE, "/sse" },
    /* 401 */ { ud_itab__401, UD_TAB__OPC_MOD, "/mod" },
    /* 402 */ { ud_itab__402, UD_TAB__OPC_REG, "/reg" },
    /* 403 */ { ud_itab__403, UD_TAB__OPC_SSE, "/sse" },
    /* 404 */ { ud_itab__404, UD_TAB__OPC_MOD, "/mod" },
    /* 405 */ { ud_itab__405, UD_TAB__OPC_SSE, "/sse" },
    /* 406 */ { ud_itab__406, UD_TAB__OPC_MOD, "/mod" },
    /* 407 */ { ud_itab__407, UD_TAB__OPC_SSE, "/sse" },
    /* 408 */ { ud_itab__408, UD_TAB__OPC_MOD, "/mod" },
    /* 409 */ { ud_itab__409, UD_TAB__OPC_SSE, "/sse" },
    /* 410 */ { ud_itab__410, UD_TAB__OPC_MOD, "/mod" },
    /* 411 */ { ud_itab__411, UD_TAB__OPC_SSE, "/sse" },
    /* 412 */ { ud_itab__412, UD_TAB__OPC_MOD, "/mod" },
    /* 413 */ { ud_itab__413, UD_TAB__OPC_SSE, "/sse" },
    /* 414 */ { ud_itab__414, UD_TAB__OPC_MOD, "/mod" },
    /* 415 */ { ud_itab__415, UD_TAB__OPC_SSE, "/sse" },
    /* 416 */ { ud_itab__416, UD_TAB__OPC_MOD, "/mod" },
    /* 417 */ { ud_itab__417, UD_TAB__OPC_REG, "/reg" },
    /* 418 */ { ud_itab__418, UD_TAB__OPC_RM, "/rm" },
    /* 419 */ { ud_itab__419, UD_TAB__OPC_SSE, "/sse" },
    /* 420 */ { ud_itab__420, UD_TAB__OPC_MOD, "/mod" },
    /* 421 */ { ud_itab__421, UD_TAB__OPC_SSE, "/sse" },
    /* 422 */ { ud_itab__422, UD_TAB__OPC_MOD, "/mod" },
    /* 423 */ { ud_itab__423, UD_TAB__OPC_SSE, "/sse" },
    /* 424 */ { ud_itab__424, UD_TAB__OPC_MOD, "/mod" },
    /* 425 */ { ud_itab__425, UD_TAB__OPC_SSE, "/sse" },
    /* 426 */ { ud_itab__426, UD_TAB__OPC_MOD, "/mod" },
    /* 427 */ { ud_itab__427, UD_TAB__OPC_SSE, "/sse" },
    /* 428 */ { ud_itab__428, UD_TAB__OPC_MOD, "/mod" },
    /* 429 */ { ud_itab__429, UD_TAB__OPC_SSE, "/sse" },
    /* 430 */ { ud_itab__430, UD_TAB__OPC_MOD, "/mod" },
    /* 431 */ { ud_itab__431, UD_TAB__OPC_SSE, "/sse" },
    /* 432 */ { ud_itab__432, UD_TAB__OPC_MOD, "/mod" },
    /* 433 */ { ud_itab__433, UD_TAB__OPC_SSE, "/sse" },
    /* 434 */ { ud_itab__434, UD_TAB__OPC_MOD, "/mod" },
    /* 435 */ { ud_itab__435, UD_TAB__OPC_RM, "/rm" },
    /* 436 */ { ud_itab__436, UD_TAB__OPC_SSE, "/sse" },
    /* 437 */ { ud_itab__437, UD_TAB__OPC_MOD, "/mod" },
    /* 438 */ { ud_itab__438, UD_TAB__OPC_SSE, "/sse" },
    /* 439 */ { ud_itab__439, UD_TAB__OPC_MOD, "/mod" },
    /* 440 */ { ud_itab__440, UD_TAB__OPC_SSE, "/sse" },
    /* 441 */ { ud_itab__441, UD_TAB__OPC_MOD, "/mod" },
    /* 442 */ { ud_itab__442, UD_TAB__OPC_SSE, "/sse" },
    /* 443 */ { ud_itab__443, UD_TAB__OPC_MOD, "/mod" },
    /* 444 */ { ud_itab__444, UD_TAB__OPC_SSE, "/sse" },
    /* 445 */ { ud_itab__445, UD_TAB__OPC_MOD, "/mod" },
    /* 446 */ { ud_itab__446, UD_TAB__OPC_SSE, "/sse" },
    /* 447 */ { ud_itab__447, UD_TAB__OPC_MOD, "/mod" },
    /* 448 */ { ud_itab__448, UD_TAB__OPC_SSE, "/sse" },
    /* 449 */ { ud_itab__449, UD_TAB__OPC_MOD, "/mod" },
    /* 450 */ { ud_itab__450, UD_TAB__OPC_SSE, "/sse" },
    /* 451 */ { ud_itab__451, UD_TAB__OPC_MOD, "/mod" },
    /* 452 */ { ud_itab__452, UD_TAB__OPC_RM, "/rm" },
    /* 453 */ { ud_itab__453, UD_TAB__OPC_SSE, "/sse" },
    /* 454 */ { ud_itab__454, UD_TAB__OPC_MOD, "/mod" },
    /* 455 */ { ud_itab__455, UD_TAB__OPC_SSE, "/sse" },
    /* 456 */ { ud_itab__456, UD_TAB__OPC_MOD, "/mod" },
    /* 457 */ { ud_itab__457, UD_TAB__OPC_SSE, "/sse" },
    /* 458 */ { ud_itab__458, UD_TAB__OPC_MOD, "/mod" },
    /* 459 */ { ud_itab__459, UD_TAB__OPC_SSE, "/sse" },
    /* 460 */ { ud_itab__460, UD_TAB__OPC_MOD, "/mod" },
    /* 461 */ { ud_itab__461, UD_TAB__OPC_SSE, "/sse" },
    /* 462 */ { ud_itab__462, UD_TAB__OPC_MOD, "/mod" },
    /* 463 */ { ud_itab__463, UD_TAB__OPC_SSE, "/sse" },
    /* 464 */ { ud_itab__464, UD_TAB__OPC_MOD, "/mod" },
    /* 465 */ { ud_itab__465, UD_TAB__OPC_SSE, "/sse" },
    /* 466 */ { ud_itab__466, UD_TAB__OPC_MOD, "/mod" },
    /* 467 */ { ud_itab__467, UD_TAB__OPC_SSE, "/sse" },
    /* 468 */ { ud_itab__468, UD_TAB__OPC_MOD, "/mod" },
    /* 469 */ { ud_itab__469, UD_TAB__OPC_SSE, "/sse" },
    /* 470 */ { ud_itab__470, UD_TAB__OPC_SSE, "/sse" },
    /* 471 */ { ud_itab__471, UD_TAB__OPC_SSE, "/sse" },
    /* 472 */ { ud_itab__472, UD_TAB__OPC_SSE, "/sse" },
    /* 473 */ { ud_itab__473, UD_TAB__OPC_SSE, "/sse" },
    /* 474 */ { ud_itab__474, UD_TAB__OPC_SSE, "/sse" },
    /* 475 */ { ud_itab__475, UD_TAB__OPC_SSE, "/sse" },
    /* 476 */ { ud_itab__476, UD_TAB__OPC_SSE, "/sse" },
    /* 477 */ { ud_itab__477, UD_TAB__OPC_SSE, "/sse" },
    /* 478 */ { ud_itab__478, UD_TAB__OPC_SSE, "/sse" },
    /* 479 */ { ud_itab__479, UD_TAB__OPC_REG, "/reg" },
    /* 480 */ { ud_itab__480, UD_TAB__OPC_SSE, "/sse" },
    /* 481 */ { ud_itab__481, UD_TAB__OPC_SSE, "/sse" },
    /* 482 */ { ud_itab__482, UD_TAB__OPC_SSE, "/sse" },
    /* 483 */ { ud_itab__483, UD_TAB__OPC_SSE, "/sse" },
    /* 484 */ { ud_itab__484, UD_TAB__OPC_SSE, "/sse" },
    /* 485 */ { ud_itab__485, UD_TAB__OPC_SSE, "/sse" },
    /* 486 */ { ud_itab__486, UD_TAB__OPC_SSE, "/sse" },
    /* 487 */ { ud_itab__487, UD_TAB__OPC_SSE, "/sse" },
    /* 488 */ { ud_itab__488, UD_TAB__OPC_SSE, "/sse" },
    /* 489 */ { ud_itab__489, UD_TAB__OPC_SSE, "/sse" },
    /* 490 */ { ud_itab__490, UD_TAB__OPC_SSE, "/sse" },
    /* 491 */ { ud_itab__491, UD_TAB__OPC_SSE, "/sse" },
    /* 492 */ { ud_itab__492, UD_TAB__OPC_SSE, "/sse" },
    /* 493 */ { ud_itab__493, UD_TAB__OPC_SSE, "/sse" },
    /* 494 */ { ud_itab__494, UD_TAB__OPC_SSE, "/sse" },
    /* 495 */ { ud_itab__495, UD_TAB__OPC_SSE, "/sse" },
    /* 496 */ { ud_itab__496, UD_TAB__OPC_REG, "/reg" },
    /* 497 */ { ud_itab__497, UD_TAB__OPC_SSE, "/sse" },
    /* 498 */ { ud_itab__498, UD_TAB__OPC_OSIZE, "/o" },
    /* 499 */ { ud_itab__499, UD_TAB__OPC_SSE, "/sse" },
    /* 500 */ { ud_itab__500, UD_TAB__OPC_VENDOR, "intel" },
    /* 501 */ { ud_itab__501, UD_TAB__OPC_VENDOR, "intel" },
    /* 502 */ { ud_itab__502, UD_TAB__OPC_VENDOR, "intel" },
    /* 503 */ { ud_itab__503, UD_TAB__OPC_SSE, "/sse" },
    /* 504 */ { ud_itab__504, UD_TAB__OPC_VENDOR, "intel" },
    /* 505 */ { ud_itab__505, UD_TAB__OPC_SSE, "/sse" },
    /* 506 */ { ud_itab__506, UD_TAB__OPC_SSE, "/sse" },
    /* 507 */ { ud_itab__507, UD_TAB__OPC_SSE, "/sse" },
    /* 508 */ { ud_itab__508, UD_TAB__OPC_SSE, "/sse" },
    /* 509 */ { ud_itab__509, UD_TAB__OPC_SSE, "/sse" },
    /* 510 */ { ud_itab__510, UD_TAB__OPC_SSE, "/sse" },
    /* 511 */ { ud_itab__511, UD_TAB__OPC_SSE, "/sse" },
    /* 512 */ { ud_itab__512, UD_TAB__OPC_SSE, "/sse" },
    /* 513 */ { ud_itab__513, UD_TAB__OPC_SSE, "/sse" },
    /* 514 */ { ud_itab__514, UD_TAB__OPC_SSE, "/sse" },
    /* 515 */ { ud_itab__515, UD_TAB__OPC_SSE, "/sse" },
    /* 516 */ { ud_itab__516, UD_TAB__OPC_SSE, "/sse" },
    /* 517 */ { ud_itab__517, UD_TAB__OPC_SSE, "/sse" },
    /* 518 */ { ud_itab__518, UD_TAB__OPC_SSE, "/sse" },
    /* 519 */ { ud_itab__519, UD_TAB__OPC_SSE, "/sse" },
    /* 520 */ { ud_itab__520, UD_TAB__OPC_SSE, "/sse" },
    /* 521 */ { ud_itab__521, UD_TAB__OPC_SSE, "/sse" },
    /* 522 */ { ud_itab__522, UD_TAB__OPC_SSE, "/sse" },
    /* 523 */ { ud_itab__523, UD_TAB__OPC_SSE, "/sse" },
    /* 524 */ { ud_itab__524, UD_TAB__OPC_SSE, "/sse" },
    /* 525 */ { ud_itab__525, UD_TAB__OPC_SSE, "/sse" },
    /* 526 */ { ud_itab__526, UD_TAB__OPC_SSE, "/sse" },
    /* 527 */ { ud_itab__527, UD_TAB__OPC_SSE, "/sse" },
    /* 528 */ { ud_itab__528, UD_TAB__OPC_SSE, "/sse" },
    /* 529 */ { ud_itab__529, UD_TAB__OPC_SSE, "/sse" },
    /* 530 */ { ud_itab__530, UD_TAB__OPC_SSE, "/sse" },
    /* 531 */ { ud_itab__531, UD_TAB__OPC_SSE, "/sse" },
    /* 532 */ { ud_itab__532, UD_TAB__OPC_SSE, "/sse" },
    /* 533 */ { ud_itab__533, UD_TAB__OPC_SSE, "/sse" },
    /* 534 */ { ud_itab__534, UD_TAB__OPC_SSE, "/sse" },
    /* 535 */ { ud_itab__535, UD_TAB__OPC_SSE, "/sse" },
    /* 536 */ { ud_itab__536, UD_TAB__OPC_SSE, "/sse" },
    /* 537 */ { ud_itab__537, UD_TAB__OPC_SSE, "/sse" },
    /* 538 */ { ud_itab__538, UD_TAB__OPC_SSE, "/sse" },
    /* 539 */ { ud_itab__539, UD_TAB__OPC_SSE, "/sse" },
    /* 540 */ { ud_itab__540, UD_TAB__OPC_SSE, "/sse" },
    /* 541 */ { ud_itab__541, UD_TAB__OPC_SSE, "/sse" },
    /* 542 */ { ud_itab__542, UD_TAB__OPC_SSE, "/sse" },
    /* 543 */ { ud_itab__543, UD_TAB__OPC_SSE, "/sse" },
    /* 544 */ { ud_itab__544, UD_TAB__OPC_SSE, "/sse" },
    /* 545 */ { ud_itab__545, UD_TAB__OPC_SSE, "/sse" },
    /* 546 */ { ud_itab__546, UD_TAB__OPC_SSE, "/sse" },
    /* 547 */ { ud_itab__547, UD_TAB__OPC_SSE, "/sse" },
    /* 548 */ { ud_itab__548, UD_TAB__OPC_SSE, "/sse" },
    /* 549 */ { ud_itab__549, UD_TAB__OPC_SSE, "/sse" },
    /* 550 */ { ud_itab__550, UD_TAB__OPC_SSE, "/sse" },
    /* 551 */ { ud_itab__551, UD_TAB__OPC_SSE, "/sse" },
    /* 552 */ { ud_itab__552, UD_TAB__OPC_MOD, "/mod" },
    /* 553 */ { ud_itab__553, UD_TAB__OPC_SSE, "/sse" },
    /* 554 */ { ud_itab__554, UD_TAB__OPC_MOD, "/mod" },
    /* 555 */ { ud_itab__555, UD_TAB__OPC_MOD, "/mod" },
    /* 556 */ { ud_itab__556, UD_TAB__OPC_SSE, "/sse" },
    /* 557 */ { ud_itab__557, UD_TAB__OPC_SSE, "/sse" },
    /* 558 */ { ud_itab__558, UD_TAB__OPC_SSE, "/sse" },
    /* 559 */ { ud_itab__559, UD_TAB__OPC_SSE, "/sse" },
    /* 560 */ { ud_itab__560, UD_TAB__OPC_SSE, "/sse" },
    /* 561 */ { ud_itab__561, UD_TAB__OPC_SSE, "/sse" },
    /* 562 */ { ud_itab__562, UD_TAB__OPC_SSE, "/sse" },
    /* 563 */ { ud_itab__563, UD_TAB__OPC_MODE, "/m" },
    /* 564 */ { ud_itab__564, UD_TAB__OPC_MODE, "/m" },
    /* 565 */ { ud_itab__565, UD_TAB__OPC_MODE, "/m" },
    /* 566 */ { ud_itab__566, UD_TAB__OPC_MODE, "/m" },
    /* 567 */ { ud_itab__567, UD_TAB__OPC_MODE, "/m" },
    /* 568 */ { ud_itab__568, UD_TAB__OPC_MODE, "/m" },
    /* 569 */ { ud_itab__569, UD_TAB__OPC_MODE, "/m" },
    /* 570 */ { ud_itab__570, UD_TAB__OPC_MODE, "/m" },
    /* 571 */ { ud_itab__571, UD_TAB__OPC_OSIZE, "/o" },
    /* 572 */ { ud_itab__572, UD_TAB__OPC_MODE, "/m" },
    /* 573 */ { ud_itab__573, UD_TAB__OPC_MODE, "/m" },
    /* 574 */ { ud_itab__574, UD_TAB__OPC_OSIZE, "/o" },
    /* 575 */ { ud_itab__575, UD_TAB__OPC_MODE, "/m" },
    /* 576 */ { ud_itab__576, UD_TAB__OPC_MODE, "/m" },
    /* 577 */ { ud_itab__577, UD_TAB__OPC_MODE, "/m" },
    /* 578 */ { ud_itab__578, UD_TAB__OPC_MODE, "/m" },
    /* 579 */ { ud_itab__579, UD_TAB__OPC_OSIZE, "/o" },
    /* 580 */ { ud_itab__580, UD_TAB__OPC_OSIZE, "/o" },
    /* 581 */ { ud_itab__581, UD_TAB__OPC_REG, "/reg" },
    /* 582 */ { ud_itab__582, UD_TAB__OPC_REG, "/reg" },
    /* 583 */ { ud_itab__583, UD_TAB__OPC_REG, "/reg" },
    /* 584 */ { ud_itab__584, UD_TAB__OPC_MODE, "/m" },
    /* 585 */ { ud_itab__585, UD_TAB__OPC_MODE, "/m" },
    /* 586 */ { ud_itab__586, UD_TAB__OPC_MODE, "/m" },
    /* 587 */ { ud_itab__587, UD_TAB__OPC_MODE, "/m" },
    /* 588 */ { ud_itab__588, UD_TAB__OPC_MODE, "/m" },
    /* 589 */ { ud_itab__589, UD_TAB__OPC_MODE, "/m" },
    /* 590 */ { ud_itab__590, UD_TAB__OPC_MODE, "/m" },
    /* 591 */ { ud_itab__591, UD_TAB__OPC_MODE, "/m" },
    /* 592 */ { ud_itab__592, UD_TAB__OPC_REG, "/reg" },
    /* 593 */ { ud_itab__593, UD_TAB__OPC_REG, "/reg" },
    /* 594 */ { ud_itab__594, UD_TAB__OPC_OSIZE, "/o" },
    /* 595 */ { ud_itab__595, UD_TAB__OPC_OSIZE, "/o" },
    /* 596 */ { ud_itab__596, UD_TAB__OPC_MODE, "/m" },
    /* 597 */ { ud_itab__597, UD_TAB__OPC_OSIZE, "/o" },
    /* 598 */ { ud_itab__598, UD_TAB__OPC_MODE, "/m" },
    /* 599 */ { ud_itab__599, UD_TAB__OPC_MODE, "/m" },
    /* 600 */ { ud_itab__600, UD_TAB__OPC_MODE, "/m" },
    /* 601 */ { ud_itab__601, UD_TAB__OPC_OSIZE, "/o" },
    /* 602 */ { ud_itab__602, UD_TAB__OPC_MODE, "/m" },
    /* 603 */ { ud_itab__603, UD_TAB__OPC_MODE, "/m" },
    /* 604 */ { ud_itab__604, UD_TAB__OPC_MODE, "/m" },
    /* 605 */ { ud_itab__605, UD_TAB__OPC_OSIZE, "/o" },
    /* 606 */ { ud_itab__606, UD_TAB__OPC_OSIZE, "/o" },
    /* 607 */ { ud_itab__607, UD_TAB__OPC_OSIZE, "/o" },
    /* 608 */ { ud_itab__608, UD_TAB__OPC_OSIZE, "/o" },
    /* 609 */ { ud_itab__609, UD_TAB__OPC_OSIZE, "/o" },
    /* 610 */ { ud_itab__610, UD_TAB__OPC_REG, "/reg" },
    /* 611 */ { ud_itab__611, UD_TAB__OPC_REG, "/reg" },
    /* 612 */ { ud_itab__612, UD_TAB__OPC_MODE, "/m" },
    /* 613 */ { ud_itab__613, UD_TAB__OPC_MODE, "/m" },
    /* 614 */ { ud_itab__614, UD_TAB__OPC_REG, "/reg" },
    /* 615 */ { ud_itab__615, UD_TAB__OPC_REG, "/reg" },
    /* 616 */ { ud_itab__616, UD_TAB__OPC_MODE, "/m" },
    /* 617 */ { ud_itab__617, UD_TAB__OPC_OSIZE, "/o" },
    /* 618 */ { ud_itab__618, UD_TAB__OPC_REG, "/reg" },
    /* 619 */ { ud_itab__619, UD_TAB__OPC_REG, "/reg" },
    /* 620 */ { ud_itab__620, UD_TAB__OPC_REG, "/reg" },
    /* 621 */ { ud_itab__621, UD_TAB__OPC_REG, "/reg" },
    /* 622 */ { ud_itab__622, UD_TAB__OPC_MODE, "/m" },
    /* 623 */ { ud_itab__623, UD_TAB__OPC_MODE, "/m" },
    /* 624 */ { ud_itab__624, UD_TAB__OPC_MODE, "/m" },
    /* 625 */ { ud_itab__625, UD_TAB__OPC_MOD, "/mod" },
    /* 626 */ { ud_itab__626, UD_TAB__OPC_REG, "/reg" },
    /* 627 */ { ud_itab__627, UD_TAB__OPC_MOD, "/mod" },
    /* 628 */ { ud_itab__628, UD_TAB__OPC_MOD, "/mod" },
    /* 629 */ { ud_itab__629, UD_TAB__OPC_MOD, "/mod" },
    /* 630 */ { ud_itab__630, UD_TAB__OPC_MOD, "/mod" },
    /* 631 */ { ud_itab__631, UD_TAB__OPC_MOD, "/mod" },
    /* 632 */ { ud_itab__632, UD_TAB__OPC_MOD, "/mod" },
    /* 633 */ { ud_itab__633, UD_TAB__OPC_MOD, "/mod" },
    /* 634 */ { ud_itab__634, UD_TAB__OPC_MOD, "/mod" },
    /* 635 */ { ud_itab__635, UD_TAB__OPC_X87, "/x87" },
    /* 636 */ { ud_itab__636, UD_TAB__OPC_MOD, "/mod" },
    /* 637 */ { ud_itab__637, UD_TAB__OPC_MOD, "/mod" },
    /* 638 */ { ud_itab__638, UD_TAB__OPC_MOD, "/mod" },
    /* 639 */ { ud_itab__639, UD_TAB__OPC_MOD, "/mod" },
    /* 640 */ { ud_itab__640, UD_TAB__OPC_MOD, "/mod" },
    /* 641 */ { ud_itab__641, UD_TAB__OPC_MOD, "/mod" },
    /* 642 */ { ud_itab__642, UD_TAB__OPC_MOD, "/mod" },
    /* 643 */ { ud_itab__643, UD_TAB__OPC_MOD, "/mod" },
    /* 644 */ { ud_itab__644, UD_TAB__OPC_MOD, "/mod" },
    /* 645 */ { ud_itab__645, UD_TAB__OPC_MOD, "/mod" },
    /* 646 */ { ud_itab__646, UD_TAB__OPC_MOD, "/mod" },
    /* 647 */ { ud_itab__647, UD_TAB__OPC_MOD, "/mod" },
    /* 648 */ { ud_itab__648, UD_TAB__OPC_MOD, "/mod" },
    /* 649 */ { ud_itab__649, UD_TAB__OPC_MOD, "/mod" },
    /* 650 */ { ud_itab__650, UD_TAB__OPC_MOD, "/mod" },
    /* 651 */ { ud_itab__651, UD_TAB__OPC_MOD, "/mod" },
    /* 652 */ { ud_itab__652, UD_TAB__OPC_MOD, "/mod" },
    /* 653 */ { ud_itab__653, UD_TAB__OPC_MOD, "/mod" },
    /* 654 */ { ud_itab__654, UD_TAB__OPC_MOD, "/mod" },
    /* 655 */ { ud_itab__655, UD_TAB__OPC_MOD, "/mod" },
    /* 656 */ { ud_itab__656, UD_TAB__OPC_MOD, "/mod" },
    /* 657 */ { ud_itab__657, UD_TAB__OPC_MOD, "/mod" },
    /* 658 */ { ud_itab__658, UD_TAB__OPC_MOD, "/mod" },
    /* 659 */ { ud_itab__659, UD_TAB__OPC_MOD, "/mod" },
    /* 660 */ { ud_itab__660, UD_TAB__OPC_MOD, "/mod" },
    /* 661 */ { ud_itab__661, UD_TAB__OPC_MOD, "/mod" },
    /* 662 */ { ud_itab__662, UD_TAB__OPC_MOD, "/mod" },
    /* 663 */ { ud_itab__663, UD_TAB__OPC_MOD, "/mod" },
    /* 664 */ { ud_itab__664, UD_TAB__OPC_MOD, "/mod" },
    /* 665 */ { ud_itab__665, UD_TAB__OPC_MOD, "/mod" },
    /* 666 */ { ud_itab__666, UD_TAB__OPC_MOD, "/mod" },
    /* 667 */ { ud_itab__667, UD_TAB__OPC_MOD, "/mod" },
    /* 668 */ { ud_itab__668, UD_TAB__OPC_MOD, "/mod" },
    /* 669 */ { ud_itab__669, UD_TAB__OPC_MOD, "/mod" },
    /* 670 */ { ud_itab__670, UD_TAB__OPC_MOD, "/mod" },
    /* 671 */ { ud_itab__671, UD_TAB__OPC_MOD, "/mod" },
    /* 672 */ { ud_itab__672, UD_TAB__OPC_MOD, "/mod" },
    /* 673 */ { ud_itab__673, UD_TAB__OPC_MOD, "/mod" },
    /* 674 */ { ud_itab__674, UD_TAB__OPC_MOD, "/mod" },
    /* 675 */ { ud_itab__675, UD_TAB__OPC_MOD, "/mod" },
    /* 676 */ { ud_itab__676, UD_TAB__OPC_MOD, "/mod" },
    /* 677 */ { ud_itab__677, UD_TAB__OPC_MOD, "/mod" },
    /* 678 */ { ud_itab__678, UD_TAB__OPC_MOD, "/mod" },
    /* 679 */ { ud_itab__679, UD_TAB__OPC_MOD, "/mod" },
    /* 680 */ { ud_itab__680, UD_TAB__OPC_MOD, "/mod" },
    /* 681 */ { ud_itab__681, UD_TAB__OPC_MOD, "/mod" },
    /* 682 */ { ud_itab__682, UD_TAB__OPC_MOD, "/mod" },
    /* 683 */ { ud_itab__683, UD_TAB__OPC_MOD, "/mod" },
    /* 684 */ { ud_itab__684, UD_TAB__OPC_MOD, "/mod" },
    /* 685 */ { ud_itab__685, UD_TAB__OPC_MOD, "/mod" },
    /* 686 */ { ud_itab__686, UD_TAB__OPC_MOD, "/mod" },
    /* 687 */ { ud_itab__687, UD_TAB__OPC_MOD, "/mod" },
    /* 688 */ { ud_itab__688, UD_TAB__OPC_MOD, "/mod" },
    /* 689 */ { ud_itab__689, UD_TAB__OPC_MOD, "/mod" },
    /* 690 */ { ud_itab__690, UD_TAB__OPC_MOD, "/mod" },
    /* 691 */ { ud_itab__691, UD_TAB__OPC_MOD, "/mod" },
    /* 692 */ { ud_itab__692, UD_TAB__OPC_MOD, "/mod" },
    /* 693 */ { ud_itab__693, UD_TAB__OPC_MOD, "/mod" },
    /* 694 */ { ud_itab__694, UD_TAB__OPC_MOD, "/mod" },
    /* 695 */ { ud_itab__695, UD_TAB__OPC_MOD, "/mod" },
    /* 696 */ { ud_itab__696, UD_TAB__OPC_MOD, "/mod" },
    /* 697 */ { ud_itab__697, UD_TAB__OPC_MOD, "/mod" },
    /* 698 */ { ud_itab__698, UD_TAB__OPC_MOD, "/mod" },
    /* 699 */ { ud_itab__699, UD_TAB__OPC_MOD, "/mod" },
    /* 700 */ { ud_itab__700, UD_TAB__OPC_MOD, "/mod" },
    /* 701 */ { ud_itab__701, UD_TAB__OPC_REG, "/reg" },
    /* 702 */ { ud_itab__702, UD_TAB__OPC_MOD, "/mod" },
    /* 703 */ { ud_itab__703, UD_TAB__OPC_MOD, "/mod" },
    /* 704 */ { ud_itab__704, UD_TAB__OPC_MOD, "/mod" },
    /* 705 */ { ud_itab__705, UD_TAB__OPC_MOD, "/mod" },
    /* 706 */ { ud_itab__706, UD_TAB__OPC_MOD, "/mod" },
    /* 707 */ { ud_itab__707, UD_TAB__OPC_MOD, "/mod" },
    /* 708 */ { ud_itab__708, UD_TAB__OPC_MOD, "/mod" },
    /* 709 */ { ud_itab__709, UD_TAB__OPC_X87, "/x87" },
    /* 710 */ { ud_itab__710, UD_TAB__OPC_MOD, "/mod" },
    /* 711 */ { ud_itab__711, UD_TAB__OPC_MOD, "/mod" },
    /* 712 */ { ud_itab__712, UD_TAB__OPC_MOD, "/mod" },
    /* 713 */ { ud_itab__713, UD_TAB__OPC_MOD, "/mod" },
    /* 714 */ { ud_itab__714, UD_TAB__OPC_MOD, "/mod" },
    /* 715 */ { ud_itab__715, UD_TAB__OPC_MOD, "/mod" },
    /* 716 */ { ud_itab__716, UD_TAB__OPC_MOD, "/mod" },
    /* 717 */ { ud_itab__717, UD_TAB__OPC_MOD, "/mod" },
    /* 718 */ { ud_itab__718, UD_TAB__OPC_MOD, "/mod" },
    /* 719 */ { ud_itab__719, UD_TAB__OPC_MOD, "/mod" },
    /* 720 */ { ud_itab__720, UD_TAB__OPC_MOD, "/mod" },
    /* 721 */ { ud_itab__721, UD_TAB__OPC_MOD, "/mod" },
    /* 722 */ { ud_itab__722, UD_TAB__OPC_MOD, "/mod" },
    /* 723 */ { ud_itab__723, UD_TAB__OPC_MOD, "/mod" },
    /* 724 */ { ud_itab__724, UD_TAB__OPC_MOD, "/mod" },
    /* 725 */ { ud_itab__725, UD_TAB__OPC_MOD, "/mod" },
    /* 726 */ { ud_itab__726, UD_TAB__OPC_MOD, "/mod" },
    /* 727 */ { ud_itab__727, UD_TAB__OPC_MOD, "/mod" },
    /* 728 */ { ud_itab__728, UD_TAB__OPC_MOD, "/mod" },
    /* 729 */ { ud_itab__729, UD_TAB__OPC_MOD, "/mod" },
    /* 730 */ { ud_itab__730, UD_TAB__OPC_MOD, "/mod" },
    /* 731 */ { ud_itab__731, UD_TAB__OPC_MOD, "/mod" },
    /* 732 */ { ud_itab__732, UD_TAB__OPC_MOD, "/mod" },
    /* 733 */ { ud_itab__733, UD_TAB__OPC_MOD, "/mod" },
    /* 734 */ { ud_itab__734, UD_TAB__OPC_MOD, "/mod" },
    /* 735 */ { ud_itab__735, UD_TAB__OPC_MOD, "/mod" },
    /* 736 */ { ud_itab__736, UD_TAB__OPC_MOD, "/mod" },
    /* 737 */ { ud_itab__737, UD_TAB__OPC_MOD, "/mod" },
    /* 738 */ { ud_itab__738, UD_TAB__OPC_MOD, "/mod" },
    /* 739 */ { ud_itab__739, UD_TAB__OPC_MOD, "/mod" },
    /* 740 */ { ud_itab__740, UD_TAB__OPC_MOD, "/mod" },
    /* 741 */ { ud_itab__741, UD_TAB__OPC_MOD, "/mod" },
    /* 742 */ { ud_itab__742, UD_TAB__OPC_MOD, "/mod" },
    /* 743 */ { ud_itab__743, UD_TAB__OPC_MOD, "/mod" },
    /* 744 */ { ud_itab__744, UD_TAB__OPC_MOD, "/mod" },
    /* 745 */ { ud_itab__745, UD_TAB__OPC_MOD, "/mod" },
    /* 746 */ { ud_itab__746, UD_TAB__OPC_MOD, "/mod" },
    /* 747 */ { ud_itab__747, UD_TAB__OPC_MOD, "/mod" },
    /* 748 */ { ud_itab__748, UD_TAB__OPC_MOD, "/mod" },
    /* 749 */ { ud_itab__749, UD_TAB__OPC_MOD, "/mod" },
    /* 750 */ { ud_itab__750, UD_TAB__OPC_MOD, "/mod" },
    /* 751 */ { ud_itab__751, UD_TAB__OPC_MOD, "/mod" },
    /* 752 */ { ud_itab__752, UD_TAB__OPC_MOD, "/mod" },
    /* 753 */ { ud_itab__753, UD_TAB__OPC_MOD, "/mod" },
    /* 754 */ { ud_itab__754, UD_TAB__OPC_MOD, "/mod" },
    /* 755 */ { ud_itab__755, UD_TAB__OPC_MOD, "/mod" },
    /* 756 */ { ud_itab__756, UD_TAB__OPC_MOD, "/mod" },
    /* 757 */ { ud_itab__757, UD_TAB__OPC_MOD, "/mod" },
    /* 758 */ { ud_itab__758, UD_TAB__OPC_MOD, "/mod" },
    /* 759 */ { ud_itab__759, UD_TAB__OPC_MOD, "/mod" },
    /* 760 */ { ud_itab__760, UD_TAB__OPC_MOD, "/mod" },
    /* 761 */ { ud_itab__761, UD_TAB__OPC_MOD, "/mod" },
    /* 762 */ { ud_itab__762, UD_TAB__OPC_MOD, "/mod" },
    /* 763 */ { ud_itab__763, UD_TAB__OPC_REG, "/reg" },
    /* 764 */ { ud_itab__764, UD_TAB__OPC_MOD, "/mod" },
    /* 765 */ { ud_itab__765, UD_TAB__OPC_MOD, "/mod" },
    /* 766 */ { ud_itab__766, UD_TAB__OPC_MOD, "/mod" },
    /* 767 */ { ud_itab__767, UD_TAB__OPC_MOD, "/mod" },
    /* 768 */ { ud_itab__768, UD_TAB__OPC_MOD, "/mod" },
    /* 769 */ { ud_itab__769, UD_TAB__OPC_MOD, "/mod" },
    /* 770 */ { ud_itab__770, UD_TAB__OPC_MOD, "/mod" },
    /* 771 */ { ud_itab__771, UD_TAB__OPC_MOD, "/mod" },
    /* 772 */ { ud_itab__772, UD_TAB__OPC_X87, "/x87" },
    /* 773 */ { ud_itab__773, UD_TAB__OPC_MOD, "/mod" },
    /* 774 */ { ud_itab__774, UD_TAB__OPC_MOD, "/mod" },
    /* 775 */ { ud_itab__775, UD_TAB__OPC_MOD, "/mod" },
    /* 776 */ { ud_itab__776, UD_TAB__OPC_MOD, "/mod" },
    /* 777 */ { ud_itab__777, UD_TAB__OPC_MOD, "/mod" },
    /* 778 */ { ud_itab__778, UD_TAB__OPC_MOD, "/mod" },
    /* 779 */ { ud_itab__779, UD_TAB__OPC_MOD, "/mod" },
    /* 780 */ { ud_itab__780, UD_TAB__OPC_MOD, "/mod" },
    /* 781 */ { ud_itab__781, UD_TAB__OPC_MOD, "/mod" },
    /* 782 */ { ud_itab__782, UD_TAB__OPC_MOD, "/mod" },
    /* 783 */ { ud_itab__783, UD_TAB__OPC_MOD, "/mod" },
    /* 784 */ { ud_itab__784, UD_TAB__OPC_MOD, "/mod" },
    /* 785 */ { ud_itab__785, UD_TAB__OPC_MOD, "/mod" },
    /* 786 */ { ud_itab__786, UD_TAB__OPC_MOD, "/mod" },
    /* 787 */ { ud_itab__787, UD_TAB__OPC_MOD, "/mod" },
    /* 788 */ { ud_itab__788, UD_TAB__OPC_MOD, "/mod" },
    /* 789 */ { ud_itab__789, UD_TAB__OPC_MOD, "/mod" },
    /* 790 */ { ud_itab__790, UD_TAB__OPC_MOD, "/mod" },
    /* 791 */ { ud_itab__791, UD_TAB__OPC_MOD, "/mod" },
    /* 792 */ { ud_itab__792, UD_TAB__OPC_MOD, "/mod" },
    /* 793 */ { ud_itab__793, UD_TAB__OPC_MOD, "/mod" },
    /* 794 */ { ud_itab__794, UD_TAB__OPC_MOD, "/mod" },
    /* 795 */ { ud_itab__795, UD_TAB__OPC_MOD, "/mod" },
    /* 796 */ { ud_itab__796, UD_TAB__OPC_MOD, "/mod" },
    /* 797 */ { ud_itab__797, UD_TAB__OPC_MOD, "/mod" },
    /* 798 */ { ud_itab__798, UD_TAB__OPC_MOD, "/mod" },
    /* 799 */ { ud_itab__799, UD_TAB__OPC_MOD, "/mod" },
    /* 800 */ { ud_itab__800, UD_TAB__OPC_MOD, "/mod" },
    /* 801 */ { ud_itab__801, UD_TAB__OPC_MOD, "/mod" },
    /* 802 */ { ud_itab__802, UD_TAB__OPC_MOD, "/mod" },
    /* 803 */ { ud_itab__803, UD_TAB__OPC_MOD, "/mod" },
    /* 804 */ { ud_itab__804, UD_TAB__OPC_MOD, "/mod" },
    /* 805 */ { ud_itab__805, UD_TAB__OPC_MOD, "/mod" },
    /* 806 */ { ud_itab__806, UD_TAB__OPC_MOD, "/mod" },
    /* 807 */ { ud_itab__807, UD_TAB__OPC_REG, "/reg" },
    /* 808 */ { ud_itab__808, UD_TAB__OPC_MOD, "/mod" },
    /* 809 */ { ud_itab__809, UD_TAB__OPC_MOD, "/mod" },
    /* 810 */ { ud_itab__810, UD_TAB__OPC_MOD, "/mod" },
    /* 811 */ { ud_itab__811, UD_TAB__OPC_MOD, "/mod" },
    /* 812 */ { ud_itab__812, UD_TAB__OPC_MOD, "/mod" },
    /* 813 */ { ud_itab__813, UD_TAB__OPC_MOD, "/mod" },
    /* 814 */ { ud_itab__814, UD_TAB__OPC_X87, "/x87" },
    /* 815 */ { ud_itab__815, UD_TAB__OPC_MOD, "/mod" },
    /* 816 */ { ud_itab__816, UD_TAB__OPC_MOD, "/mod" },
    /* 817 */ { ud_itab__817, UD_TAB__OPC_MOD, "/mod" },
    /* 818 */ { ud_itab__818, UD_TAB__OPC_MOD, "/mod" },
    /* 819 */ { ud_itab__819, UD_TAB__OPC_MOD, "/mod" },
    /* 820 */ { ud_itab__820, UD_TAB__OPC_MOD, "/mod" },
    /* 821 */ { ud_itab__821, UD_TAB__OPC_MOD, "/mod" },
    /* 822 */ { ud_itab__822, UD_TAB__OPC_MOD, "/mod" },
    /* 823 */ { ud_itab__823, UD_TAB__OPC_MOD, "/mod" },
    /* 824 */ { ud_itab__824, UD_TAB__OPC_MOD, "/mod" },
    /* 825 */ { ud_itab__825, UD_TAB__OPC_MOD, "/mod" },
    /* 826 */ { ud_itab__826, UD_TAB__OPC_MOD, "/mod" },
    /* 827 */ { ud_itab__827, UD_TAB__OPC_MOD, "/mod" },
    /* 828 */ { ud_itab__828, UD_TAB__OPC_MOD, "/mod" },
    /* 829 */ { ud_itab__829, UD_TAB__OPC_MOD, "/mod" },
    /* 830 */ { ud_itab__830, UD_TAB__OPC_MOD, "/mod" },
    /* 831 */ { ud_itab__831, UD_TAB__OPC_MOD, "/mod" },
    /* 832 */ { ud_itab__832, UD_TAB__OPC_MOD, "/mod" },
    /* 833 */ { ud_itab__833, UD_TAB__OPC_MOD, "/mod" },
    /* 834 */ { ud_itab__834, UD_TAB__OPC_MOD, "/mod" },
    /* 835 */ { ud_itab__835, UD_TAB__OPC_MOD, "/mod" },
    /* 836 */ { ud_itab__836, UD_TAB__OPC_MOD, "/mod" },
    /* 837 */ { ud_itab__837, UD_TAB__OPC_MOD, "/mod" },
    /* 838 */ { ud_itab__838, UD_TAB__OPC_MOD, "/mod" },
    /* 839 */ { ud_itab__839, UD_TAB__OPC_MOD, "/mod" },
    /* 840 */ { ud_itab__840, UD_TAB__OPC_MOD, "/mod" },
    /* 841 */ { ud_itab__841, UD_TAB__OPC_MOD, "/mod" },
    /* 842 */ { ud_itab__842, UD_TAB__OPC_MOD, "/mod" },
    /* 843 */ { ud_itab__843, UD_TAB__OPC_MOD, "/mod" },
    /* 844 */ { ud_itab__844, UD_TAB__OPC_MOD, "/mod" },
    /* 845 */ { ud_itab__845, UD_TAB__OPC_MOD, "/mod" },
    /* 846 */ { ud_itab__846, UD_TAB__OPC_MOD, "/mod" },
    /* 847 */ { ud_itab__847, UD_TAB__OPC_MOD, "/mod" },
    /* 848 */ { ud_itab__848, UD_TAB__OPC_MOD, "/mod" },
    /* 849 */ { ud_itab__849, UD_TAB__OPC_MOD, "/mod" },
    /* 850 */ { ud_itab__850, UD_TAB__OPC_MOD, "/mod" },
    /* 851 */ { ud_itab__851, UD_TAB__OPC_MOD, "/mod" },
    /* 852 */ { ud_itab__852, UD_TAB__OPC_MOD, "/mod" },
    /* 853 */ { ud_itab__853, UD_TAB__OPC_MOD, "/mod" },
    /* 854 */ { ud_itab__854, UD_TAB__OPC_MOD, "/mod" },
    /* 855 */ { ud_itab__855, UD_TAB__OPC_MOD, "/mod" },
    /* 856 */ { ud_itab__856, UD_TAB__OPC_MOD, "/mod" },
    /* 857 */ { ud_itab__857, UD_TAB__OPC_MOD, "/mod" },
    /* 858 */ { ud_itab__858, UD_TAB__OPC_MOD, "/mod" },
    /* 859 */ { ud_itab__859, UD_TAB__OPC_MOD, "/mod" },
    /* 860 */ { ud_itab__860, UD_TAB__OPC_MOD, "/mod" },
    /* 861 */ { ud_itab__861, UD_TAB__OPC_MOD, "/mod" },
    /* 862 */ { ud_itab__862, UD_TAB__OPC_MOD, "/mod" },
    /* 863 */ { ud_itab__863, UD_TAB__OPC_MOD, "/mod" },
    /* 864 */ { ud_itab__864, UD_TAB__OPC_MOD, "/mod" },
    /* 865 */ { ud_itab__865, UD_TAB__OPC_MOD, "/mod" },
    /* 866 */ { ud_itab__866, UD_TAB__OPC_REG, "/reg" },
    /* 867 */ { ud_itab__867, UD_TAB__OPC_MOD, "/mod" },
    /* 868 */ { ud_itab__868, UD_TAB__OPC_MOD, "/mod" },
    /* 869 */ { ud_itab__869, UD_TAB__OPC_MOD, "/mod" },
    /* 870 */ { ud_itab__870, UD_TAB__OPC_MOD, "/mod" },
    /* 871 */ { ud_itab__871, UD_TAB__OPC_MOD, "/mod" },
    /* 872 */ { ud_itab__872, UD_TAB__OPC_MOD, "/mod" },
    /* 873 */ { ud_itab__873, UD_TAB__OPC_MOD, "/mod" },
    /* 874 */ { ud_itab__874, UD_TAB__OPC_MOD, "/mod" },
    /* 875 */ { ud_itab__875, UD_TAB__OPC_X87, "/x87" },
    /* 876 */ { ud_itab__876, UD_TAB__OPC_MOD, "/mod" },
    /* 877 */ { ud_itab__877, UD_TAB__OPC_MOD, "/mod" },
    /* 878 */ { ud_itab__878, UD_TAB__OPC_MOD, "/mod" },
    /* 879 */ { ud_itab__879, UD_TAB__OPC_MOD, "/mod" },
    /* 880 */ { ud_itab__880, UD_TAB__OPC_MOD, "/mod" },
    /* 881 */ { ud_itab__881, UD_TAB__OPC_MOD, "/mod" },
    /* 882 */ { ud_itab__882, UD_TAB__OPC_MOD, "/mod" },
    /* 883 */ { ud_itab__883, UD_TAB__OPC_MOD, "/mod" },
    /* 884 */ { ud_itab__884, UD_TAB__OPC_MOD, "/mod" },
    /* 885 */ { ud_itab__885, UD_TAB__OPC_MOD, "/mod" },
    /* 886 */ { ud_itab__886, UD_TAB__OPC_MOD, "/mod" },
    /* 887 */ { ud_itab__887, UD_TAB__OPC_MOD, "/mod" },
    /* 888 */ { ud_itab__888, UD_TAB__OPC_MOD, "/mod" },
    /* 889 */ { ud_itab__889, UD_TAB__OPC_MOD, "/mod" },
    /* 890 */ { ud_itab__890, UD_TAB__OPC_MOD, "/mod" },
    /* 891 */ { ud_itab__891, UD_TAB__OPC_MOD, "/mod" },
    /* 892 */ { ud_itab__892, UD_TAB__OPC_MOD, "/mod" },
    /* 893 */ { ud_itab__893, UD_TAB__OPC_MOD, "/mod" },
    /* 894 */ { ud_itab__894, UD_TAB__OPC_MOD, "/mod" },
    /* 895 */ { ud_itab__895, UD_TAB__OPC_MOD, "/mod" },
    /* 896 */ { ud_itab__896, UD_TAB__OPC_MOD, "/mod" },
    /* 897 */ { ud_itab__897, UD_TAB__OPC_MOD, "/mod" },
    /* 898 */ { ud_itab__898, UD_TAB__OPC_MOD, "/mod" },
    /* 899 */ { ud_itab__899, UD_TAB__OPC_MOD, "/mod" },
    /* 900 */ { ud_itab__900, UD_TAB__OPC_MOD, "/mod" },
    /* 901 */ { ud_itab__901, UD_TAB__OPC_MOD, "/mod" },
    /* 902 */ { ud_itab__902, UD_TAB__OPC_MOD, "/mod" },
    /* 903 */ { ud_itab__903, UD_TAB__OPC_MOD, "/mod" },
    /* 904 */ { ud_itab__904, UD_TAB__OPC_MOD, "/mod" },
    /* 905 */ { ud_itab__905, UD_TAB__OPC_MOD, "/mod" },
    /* 906 */ { ud_itab__906, UD_TAB__OPC_MOD, "/mod" },
    /* 907 */ { ud_itab__907, UD_TAB__OPC_MOD, "/mod" },
    /* 908 */ { ud_itab__908, UD_TAB__OPC_MOD, "/mod" },
    /* 909 */ { ud_itab__909, UD_TAB__OPC_MOD, "/mod" },
    /* 910 */ { ud_itab__910, UD_TAB__OPC_MOD, "/mod" },
    /* 911 */ { ud_itab__911, UD_TAB__OPC_MOD, "/mod" },
    /* 912 */ { ud_itab__912, UD_TAB__OPC_MOD, "/mod" },
    /* 913 */ { ud_itab__913, UD_TAB__OPC_MOD, "/mod" },
    /* 914 */ { ud_itab__914, UD_TAB__OPC_MOD, "/mod" },
    /* 915 */ { ud_itab__915, UD_TAB__OPC_MOD, "/mod" },
    /* 916 */ { ud_itab__916, UD_TAB__OPC_MOD, "/mod" },
    /* 917 */ { ud_itab__917, UD_TAB__OPC_MOD, "/mod" },
    /* 918 */ { ud_itab__918, UD_TAB__OPC_MOD, "/mod" },
    /* 919 */ { ud_itab__919, UD_TAB__OPC_MOD, "/mod" },
    /* 920 */ { ud_itab__920, UD_TAB__OPC_MOD, "/mod" },
    /* 921 */ { ud_itab__921, UD_TAB__OPC_MOD, "/mod" },
    /* 922 */ { ud_itab__922, UD_TAB__OPC_MOD, "/mod" },
    /* 923 */ { ud_itab__923, UD_TAB__OPC_MOD, "/mod" },
    /* 924 */ { ud_itab__924, UD_TAB__OPC_MOD, "/mod" },
    /* 925 */ { ud_itab__925, UD_TAB__OPC_MOD, "/mod" },
    /* 926 */ { ud_itab__926, UD_TAB__OPC_MOD, "/mod" },
    /* 927 */ { ud_itab__927, UD_TAB__OPC_MOD, "/mod" },
    /* 928 */ { ud_itab__928, UD_TAB__OPC_MOD, "/mod" },
    /* 929 */ { ud_itab__929, UD_TAB__OPC_MOD, "/mod" },
    /* 930 */ { ud_itab__930, UD_TAB__OPC_MOD, "/mod" },
    /* 931 */ { ud_itab__931, UD_TAB__OPC_MOD, "/mod" },
    /* 932 */ { ud_itab__932, UD_TAB__OPC_MOD, "/mod" },
    /* 933 */ { ud_itab__933, UD_TAB__OPC_MOD, "/mod" },
    /* 934 */ { ud_itab__934, UD_TAB__OPC_MOD, "/mod" },
    /* 935 */ { ud_itab__935, UD_TAB__OPC_MOD, "/mod" },
    /* 936 */ { ud_itab__936, UD_TAB__OPC_MOD, "/mod" },
    /* 937 */ { ud_itab__937, UD_TAB__OPC_MOD, "/mod" },
    /* 938 */ { ud_itab__938, UD_TAB__OPC_MOD, "/mod" },
    /* 939 */ { ud_itab__939, UD_TAB__OPC_MOD, "/mod" },
    /* 940 */ { ud_itab__940, UD_TAB__OPC_MOD, "/mod" },
    /* 941 */ { ud_itab__941, UD_TAB__OPC_REG, "/reg" },
    /* 942 */ { ud_itab__942, UD_TAB__OPC_MOD, "/mod" },
    /* 943 */ { ud_itab__943, UD_TAB__OPC_MOD, "/mod" },
    /* 944 */ { ud_itab__944, UD_TAB__OPC_MOD, "/mod" },
    /* 945 */ { ud_itab__945, UD_TAB__OPC_MOD, "/mod" },
    /* 946 */ { ud_itab__946, UD_TAB__OPC_MOD, "/mod" },
    /* 947 */ { ud_itab__947, UD_TAB__OPC_MOD, "/mod" },
    /* 948 */ { ud_itab__948, UD_TAB__OPC_MOD, "/mod" },
    /* 949 */ { ud_itab__949, UD_TAB__OPC_X87, "/x87" },
    /* 950 */ { ud_itab__950, UD_TAB__OPC_MOD, "/mod" },
    /* 951 */ { ud_itab__951, UD_TAB__OPC_MOD, "/mod" },
    /* 952 */ { ud_itab__952, UD_TAB__OPC_MOD, "/mod" },
    /* 953 */ { ud_itab__953, UD_TAB__OPC_MOD, "/mod" },
    /* 954 */ { ud_itab__954, UD_TAB__OPC_MOD, "/mod" },
    /* 955 */ { ud_itab__955, UD_TAB__OPC_MOD, "/mod" },
    /* 956 */ { ud_itab__956, UD_TAB__OPC_MOD, "/mod" },
    /* 957 */ { ud_itab__957, UD_TAB__OPC_MOD, "/mod" },
    /* 958 */ { ud_itab__958, UD_TAB__OPC_MOD, "/mod" },
    /* 959 */ { ud_itab__959, UD_TAB__OPC_MOD, "/mod" },
    /* 960 */ { ud_itab__960, UD_TAB__OPC_MOD, "/mod" },
    /* 961 */ { ud_itab__961, UD_TAB__OPC_MOD, "/mod" },
    /* 962 */ { ud_itab__962, UD_TAB__OPC_MOD, "/mod" },
    /* 963 */ { ud_itab__963, UD_TAB__OPC_MOD, "/mod" },
    /* 964 */ { ud_itab__964, UD_TAB__OPC_MOD, "/mod" },
    /* 965 */ { ud_itab__965, UD_TAB__OPC_MOD, "/mod" },
    /* 966 */ { ud_itab__966, UD_TAB__OPC_MOD, "/mod" },
    /* 967 */ { ud_itab__967, UD_TAB__OPC_MOD, "/mod" },
    /* 968 */ { ud_itab__968, UD_TAB__OPC_MOD, "/mod" },
    /* 969 */ { ud_itab__969, UD_TAB__OPC_MOD, "/mod" },
    /* 970 */ { ud_itab__970, UD_TAB__OPC_MOD, "/mod" },
    /* 971 */ { ud_itab__971, UD_TAB__OPC_MOD, "/mod" },
    /* 972 */ { ud_itab__972, UD_TAB__OPC_MOD, "/mod" },
    /* 973 */ { ud_itab__973, UD_TAB__OPC_MOD, "/mod" },
    /* 974 */ { ud_itab__974, UD_TAB__OPC_MOD, "/mod" },
    /* 975 */ { ud_itab__975, UD_TAB__OPC_MOD, "/mod" },
    /* 976 */ { ud_itab__976, UD_TAB__OPC_MOD, "/mod" },
    /* 977 */ { ud_itab__977, UD_TAB__OPC_MOD, "/mod" },
    /* 978 */ { ud_itab__978, UD_TAB__OPC_MOD, "/mod" },
    /* 979 */ { ud_itab__979, UD_TAB__OPC_MOD, "/mod" },
    /* 980 */ { ud_itab__980, UD_TAB__OPC_MOD, "/mod" },
    /* 981 */ { ud_itab__981, UD_TAB__OPC_MOD, "/mod" },
    /* 982 */ { ud_itab__982, UD_TAB__OPC_MOD, "/mod" },
    /* 983 */ { ud_itab__983, UD_TAB__OPC_MOD, "/mod" },
    /* 984 */ { ud_itab__984, UD_TAB__OPC_MOD, "/mod" },
    /* 985 */ { ud_itab__985, UD_TAB__OPC_MOD, "/mod" },
    /* 986 */ { ud_itab__986, UD_TAB__OPC_MOD, "/mod" },
    /* 987 */ { ud_itab__987, UD_TAB__OPC_MOD, "/mod" },
    /* 988 */ { ud_itab__988, UD_TAB__OPC_MOD, "/mod" },
    /* 989 */ { ud_itab__989, UD_TAB__OPC_MOD, "/mod" },
    /* 990 */ { ud_itab__990, UD_TAB__OPC_MOD, "/mod" },
    /* 991 */ { ud_itab__991, UD_TAB__OPC_MOD, "/mod" },
    /* 992 */ { ud_itab__992, UD_TAB__OPC_MOD, "/mod" },
    /* 993 */ { ud_itab__993, UD_TAB__OPC_MOD, "/mod" },
    /* 994 */ { ud_itab__994, UD_TAB__OPC_MOD, "/mod" },
    /* 995 */ { ud_itab__995, UD_TAB__OPC_MOD, "/mod" },
    /* 996 */ { ud_itab__996, UD_TAB__OPC_MOD, "/mod" },
    /* 997 */ { ud_itab__997, UD_TAB__OPC_MOD, "/mod" },
    /* 998 */ { ud_itab__998, UD_TAB__OPC_MOD, "/mod" },
    /* 999 */ { ud_itab__999, UD_TAB__OPC_REG, "/reg" },
    /* 1000 */ { ud_itab__1000, UD_TAB__OPC_MOD, "/mod" },
    /* 1001 */ { ud_itab__1001, UD_TAB__OPC_MOD, "/mod" },
    /* 1002 */ { ud_itab__1002, UD_TAB__OPC_MOD, "/mod" },
    /* 1003 */ { ud_itab__1003, UD_TAB__OPC_MOD, "/mod" },
    /* 1004 */ { ud_itab__1004, UD_TAB__OPC_MOD, "/mod" },
    /* 1005 */ { ud_itab__1005, UD_TAB__OPC_MOD, "/mod" },
    /* 1006 */ { ud_itab__1006, UD_TAB__OPC_MOD, "/mod" },
    /* 1007 */ { ud_itab__1007, UD_TAB__OPC_MOD, "/mod" },
    /* 1008 */ { ud_itab__1008, UD_TAB__OPC_X87, "/x87" },
    /* 1009 */ { ud_itab__1009, UD_TAB__OPC_MOD, "/mod" },
    /* 1010 */ { ud_itab__1010, UD_TAB__OPC_MOD, "/mod" },
    /* 1011 */ { ud_itab__1011, UD_TAB__OPC_MOD, "/mod" },
    /* 1012 */ { ud_itab__1012, UD_TAB__OPC_MOD, "/mod" },
    /* 1013 */ { ud_itab__1013, UD_TAB__OPC_MOD, "/mod" },
    /* 1014 */ { ud_itab__1014, UD_TAB__OPC_MOD, "/mod" },
    /* 1015 */ { ud_itab__1015, UD_TAB__OPC_MOD, "/mod" },
    /* 1016 */ { ud_itab__1016, UD_TAB__OPC_MOD, "/mod" },
    /* 1017 */ { ud_itab__1017, UD_TAB__OPC_MOD, "/mod" },
    /* 1018 */ { ud_itab__1018, UD_TAB__OPC_MOD, "/mod" },
    /* 1019 */ { ud_itab__1019, UD_TAB__OPC_MOD, "/mod" },
    /* 1020 */ { ud_itab__1020, UD_TAB__OPC_MOD, "/mod" },
    /* 1021 */ { ud_itab__1021, UD_TAB__OPC_MOD, "/mod" },
    /* 1022 */ { ud_itab__1022, UD_TAB__OPC_MOD, "/mod" },
    /* 1023 */ { ud_itab__1023, UD_TAB__OPC_MOD, "/mod" },
    /* 1024 */ { ud_itab__1024, UD_TAB__OPC_MOD, "/mod" },
    /* 1025 */ { ud_itab__1025, UD_TAB__OPC_MOD, "/mod" },
    /* 1026 */ { ud_itab__1026, UD_TAB__OPC_MOD, "/mod" },
    /* 1027 */ { ud_itab__1027, UD_TAB__OPC_MOD, "/mod" },
    /* 1028 */ { ud_itab__1028, UD_TAB__OPC_MOD, "/mod" },
    /* 1029 */ { ud_itab__1029, UD_TAB__OPC_MOD, "/mod" },
    /* 1030 */ { ud_itab__1030, UD_TAB__OPC_MOD, "/mod" },
    /* 1031 */ { ud_itab__1031, UD_TAB__OPC_MOD, "/mod" },
    /* 1032 */ { ud_itab__1032, UD_TAB__OPC_MOD, "/mod" },
    /* 1033 */ { ud_itab__1033, UD_TAB__OPC_MOD, "/mod" },
    /* 1034 */ { ud_itab__1034, UD_TAB__OPC_MOD, "/mod" },
    /* 1035 */ { ud_itab__1035, UD_TAB__OPC_MOD, "/mod" },
    /* 1036 */ { ud_itab__1036, UD_TAB__OPC_MOD, "/mod" },
    /* 1037 */ { ud_itab__1037, UD_TAB__OPC_MOD, "/mod" },
    /* 1038 */ { ud_itab__1038, UD_TAB__OPC_MOD, "/mod" },
    /* 1039 */ { ud_itab__1039, UD_TAB__OPC_MOD, "/mod" },
    /* 1040 */ { ud_itab__1040, UD_TAB__OPC_MOD, "/mod" },
    /* 1041 */ { ud_itab__1041, UD_TAB__OPC_MOD, "/mod" },
    /* 1042 */ { ud_itab__1042, UD_TAB__OPC_MOD, "/mod" },
    /* 1043 */ { ud_itab__1043, UD_TAB__OPC_MOD, "/mod" },
    /* 1044 */ { ud_itab__1044, UD_TAB__OPC_MOD, "/mod" },
    /* 1045 */ { ud_itab__1045, UD_TAB__OPC_MOD, "/mod" },
    /* 1046 */ { ud_itab__1046, UD_TAB__OPC_MOD, "/mod" },
    /* 1047 */ { ud_itab__1047, UD_TAB__OPC_MOD, "/mod" },
    /* 1048 */ { ud_itab__1048, UD_TAB__OPC_MOD, "/mod" },
    /* 1049 */ { ud_itab__1049, UD_TAB__OPC_MOD, "/mod" },
    /* 1050 */ { ud_itab__1050, UD_TAB__OPC_MOD, "/mod" },
    /* 1051 */ { ud_itab__1051, UD_TAB__OPC_MOD, "/mod" },
    /* 1052 */ { ud_itab__1052, UD_TAB__OPC_MOD, "/mod" },
    /* 1053 */ { ud_itab__1053, UD_TAB__OPC_MOD, "/mod" },
    /* 1054 */ { ud_itab__1054, UD_TAB__OPC_MOD, "/mod" },
    /* 1055 */ { ud_itab__1055, UD_TAB__OPC_MOD, "/mod" },
    /* 1056 */ { ud_itab__1056, UD_TAB__OPC_MOD, "/mod" },
    /* 1057 */ { ud_itab__1057, UD_TAB__OPC_MOD, "/mod" },
    /* 1058 */ { ud_itab__1058, UD_TAB__OPC_MOD, "/mod" },
    /* 1059 */ { ud_itab__1059, UD_TAB__OPC_MOD, "/mod" },
    /* 1060 */ { ud_itab__1060, UD_TAB__OPC_MOD, "/mod" },
    /* 1061 */ { ud_itab__1061, UD_TAB__OPC_MOD, "/mod" },
    /* 1062 */ { ud_itab__1062, UD_TAB__OPC_MOD, "/mod" },
    /* 1063 */ { ud_itab__1063, UD_TAB__OPC_MOD, "/mod" },
    /* 1064 */ { ud_itab__1064, UD_TAB__OPC_MOD, "/mod" },
    /* 1065 */ { ud_itab__1065, UD_TAB__OPC_MOD, "/mod" },
    /* 1066 */ { ud_itab__1066, UD_TAB__OPC_MOD, "/mod" },
    /* 1067 */ { ud_itab__1067, UD_TAB__OPC_REG, "/reg" },
    /* 1068 */ { ud_itab__1068, UD_TAB__OPC_MOD, "/mod" },
    /* 1069 */ { ud_itab__1069, UD_TAB__OPC_MOD, "/mod" },
    /* 1070 */ { ud_itab__1070, UD_TAB__OPC_MOD, "/mod" },
    /* 1071 */ { ud_itab__1071, UD_TAB__OPC_MOD, "/mod" },
    /* 1072 */ { ud_itab__1072, UD_TAB__OPC_MOD, "/mod" },
    /* 1073 */ { ud_itab__1073, UD_TAB__OPC_MOD, "/mod" },
    /* 1074 */ { ud_itab__1074, UD_TAB__OPC_MOD, "/mod" },
    /* 1075 */ { ud_itab__1075, UD_TAB__OPC_MOD, "/mod" },
    /* 1076 */ { ud_itab__1076, UD_TAB__OPC_X87, "/x87" },
    /* 1077 */ { ud_itab__1077, UD_TAB__OPC_MOD, "/mod" },
    /* 1078 */ { ud_itab__1078, UD_TAB__OPC_MOD, "/mod" },
    /* 1079 */ { ud_itab__1079, UD_TAB__OPC_MOD, "/mod" },
    /* 1080 */ { ud_itab__1080, UD_TAB__OPC_MOD, "/mod" },
    /* 1081 */ { ud_itab__1081, UD_TAB__OPC_MOD, "/mod" },
    /* 1082 */ { ud_itab__1082, UD_TAB__OPC_MOD, "/mod" },
    /* 1083 */ { ud_itab__1083, UD_TAB__OPC_MOD, "/mod" },
    /* 1084 */ { ud_itab__1084, UD_TAB__OPC_MOD, "/mod" },
    /* 1085 */ { ud_itab__1085, UD_TAB__OPC_MOD, "/mod" },
    /* 1086 */ { ud_itab__1086, UD_TAB__OPC_MOD, "/mod" },
    /* 1087 */ { ud_itab__1087, UD_TAB__OPC_MOD, "/mod" },
    /* 1088 */ { ud_itab__1088, UD_TAB__OPC_MOD, "/mod" },
    /* 1089 */ { ud_itab__1089, UD_TAB__OPC_MOD, "/mod" },
    /* 1090 */ { ud_itab__1090, UD_TAB__OPC_MOD, "/mod" },
    /* 1091 */ { ud_itab__1091, UD_TAB__OPC_MOD, "/mod" },
    /* 1092 */ { ud_itab__1092, UD_TAB__OPC_MOD, "/mod" },
    /* 1093 */ { ud_itab__1093, UD_TAB__OPC_MOD, "/mod" },
    /* 1094 */ { ud_itab__1094, UD_TAB__OPC_MOD, "/mod" },
    /* 1095 */ { ud_itab__1095, UD_TAB__OPC_MOD, "/mod" },
    /* 1096 */ { ud_itab__1096, UD_TAB__OPC_MOD, "/mod" },
    /* 1097 */ { ud_itab__1097, UD_TAB__OPC_MOD, "/mod" },
    /* 1098 */ { ud_itab__1098, UD_TAB__OPC_MOD, "/mod" },
    /* 1099 */ { ud_itab__1099, UD_TAB__OPC_MOD, "/mod" },
    /* 1100 */ { ud_itab__1100, UD_TAB__OPC_MOD, "/mod" },
    /* 1101 */ { ud_itab__1101, UD_TAB__OPC_MOD, "/mod" },
    /* 1102 */ { ud_itab__1102, UD_TAB__OPC_MOD, "/mod" },
    /* 1103 */ { ud_itab__1103, UD_TAB__OPC_MOD, "/mod" },
    /* 1104 */ { ud_itab__1104, UD_TAB__OPC_MOD, "/mod" },
    /* 1105 */ { ud_itab__1105, UD_TAB__OPC_MOD, "/mod" },
    /* 1106 */ { ud_itab__1106, UD_TAB__OPC_MOD, "/mod" },
    /* 1107 */ { ud_itab__1107, UD_TAB__OPC_MOD, "/mod" },
    /* 1108 */ { ud_itab__1108, UD_TAB__OPC_MOD, "/mod" },
    /* 1109 */ { ud_itab__1109, UD_TAB__OPC_MOD, "/mod" },
    /* 1110 */ { ud_itab__1110, UD_TAB__OPC_MOD, "/mod" },
    /* 1111 */ { ud_itab__1111, UD_TAB__OPC_MOD, "/mod" },
    /* 1112 */ { ud_itab__1112, UD_TAB__OPC_MOD, "/mod" },
    /* 1113 */ { ud_itab__1113, UD_TAB__OPC_MOD, "/mod" },
    /* 1114 */ { ud_itab__1114, UD_TAB__OPC_MOD, "/mod" },
    /* 1115 */ { ud_itab__1115, UD_TAB__OPC_MOD, "/mod" },
    /* 1116 */ { ud_itab__1116, UD_TAB__OPC_MOD, "/mod" },
    /* 1117 */ { ud_itab__1117, UD_TAB__OPC_MOD, "/mod" },
    /* 1118 */ { ud_itab__1118, UD_TAB__OPC_MOD, "/mod" },
    /* 1119 */ { ud_itab__1119, UD_TAB__OPC_MOD, "/mod" },
    /* 1120 */ { ud_itab__1120, UD_TAB__OPC_MOD, "/mod" },
    /* 1121 */ { ud_itab__1121, UD_TAB__OPC_MOD, "/mod" },
    /* 1122 */ { ud_itab__1122, UD_TAB__OPC_MOD, "/mod" },
    /* 1123 */ { ud_itab__1123, UD_TAB__OPC_MOD, "/mod" },
    /* 1124 */ { ud_itab__1124, UD_TAB__OPC_MOD, "/mod" },
    /* 1125 */ { ud_itab__1125, UD_TAB__OPC_MOD, "/mod" },
    /* 1126 */ { ud_itab__1126, UD_TAB__OPC_ASIZE, "/a" },
    /* 1127 */ { ud_itab__1127, UD_TAB__OPC_MODE, "/m" },
    /* 1128 */ { ud_itab__1128, UD_TAB__OPC_REG, "/reg" },
    /* 1129 */ { ud_itab__1129, UD_TAB__OPC_REG, "/reg" },
    /* 1130 */ { ud_itab__1130, UD_TAB__OPC_REG, "/reg" },
    /* 1131 */ { ud_itab__1131, UD_TAB__OPC_REG, "/reg" },
    /* 1132 */ { ud_itab__1132, UD_TAB__OPC_MODE, "/m" },
};

/* itab entry operand definitions (for readability) */
#define O_AL      { OP_AL,       SZ_B     }
#define O_AX      { OP_AX,       SZ_W     }
#define O_Av      { OP_A,        SZ_V     }
#define O_C       { OP_C,        SZ_NA    }
#define O_CL      { OP_CL,       SZ_B     }
#define O_CS      { OP_CS,       SZ_NA    }
#define O_CX      { OP_CX,       SZ_W     }
#define O_D       { OP_D,        SZ_NA    }
#define O_DL      { OP_DL,       SZ_B     }
#define O_DS      { OP_DS,       SZ_NA    }
#define O_DX      { OP_DX,       SZ_W     }
#define O_E       { OP_E,        SZ_NA    }
#define O_ES      { OP_ES,       SZ_NA    }
#define O_Eb      { OP_E,        SZ_B     }
#define O_Ed      { OP_E,        SZ_D     }
#define O_Eq      { OP_E,        SZ_Q     }
#define O_Ev      { OP_E,        SZ_V     }
#define O_Ew      { OP_E,        SZ_W     }
#define O_Ey      { OP_E,        SZ_Y     }
#define O_Ez      { OP_E,        SZ_Z     }
#define O_FS      { OP_FS,       SZ_NA    }
#define O_Fv      { OP_F,        SZ_V     }
#define O_G       { OP_G,        SZ_NA    }
#define O_GS      { OP_GS,       SZ_NA    }
#define O_Gb      { OP_G,        SZ_B     }
#define O_Gd      { OP_G,        SZ_D     }
#define O_Gq      { OP_G,        SZ_Q     }
#define O_Gv      { OP_G,        SZ_V     }
#define O_Gw      { OP_G,        SZ_W     }
#define O_Gy      { OP_G,        SZ_Y     }
#define O_Gz      { OP_G,        SZ_Z     }
#define O_I1      { OP_I1,       SZ_NA    }
#define O_I3      { OP_I3,       SZ_NA    }
#define O_Ib      { OP_I,        SZ_B     }
#define O_Iv      { OP_I,        SZ_V     }
#define O_Iw      { OP_I,        SZ_W     }
#define O_Iz      { OP_I,        SZ_Z     }
#define O_Jb      { OP_J,        SZ_B     }
#define O_Jv      { OP_J,        SZ_V     }
#define O_Jz      { OP_J,        SZ_Z     }
#define O_M       { OP_M,        SZ_NA    }
#define O_Mb      { OP_M,        SZ_B     }
#define O_MbRd    { OP_MR,       SZ_BD    }
#define O_MbRv    { OP_MR,       SZ_BV    }
#define O_Md      { OP_M,        SZ_D     }
#define O_MdRy    { OP_MR,       SZ_DY    }
#define O_MdU     { OP_MU,       SZ_DO    }
#define O_Mo      { OP_M,        SZ_O     }
#define O_Mq      { OP_M,        SZ_Q     }
#define O_MqU     { OP_MU,       SZ_QO    }
#define O_Ms      { OP_M,        SZ_W     }
#define O_Mt      { OP_M,        SZ_T     }
#define O_Mv      { OP_M,        SZ_V     }
#define O_Mw      { OP_M,        SZ_W     }
#define O_MwRd    { OP_MR,       SZ_WD    }
#define O_MwRv    { OP_MR,       SZ_WV    }
#define O_MwRy    { OP_MR,       SZ_WY    }
#define O_MwU     { OP_MU,       SZ_WO    }
#define O_N       { OP_N,        SZ_Q     }
#define O_NONE    { OP_NONE,     SZ_NA    }
#define O_Ob      { OP_O,        SZ_B     }
#define O_Ov      { OP_O,        SZ_V     }
#define O_Ow      { OP_O,        SZ_W     }
#define O_P       { OP_P,        SZ_Q     }
#define O_Q       { OP_Q,        SZ_Q     }
#define O_R       { OP_R,        SZ_RDQ   }
#define O_R0b     { OP_R0,       SZ_B     }
#define O_R0v     { OP_R0,       SZ_V     }
#define O_R0w     { OP_R0,       SZ_W     }
#define O_R0y     { OP_R0,       SZ_Y     }
#define O_R0z     { OP_R0,       SZ_Z     }
#define O_R1b     { OP_R1,       SZ_B     }
#define O_R1v     { OP_R1,       SZ_V     }
#define O_R1w     { OP_R1,       SZ_W     }
#define O_R1y     { OP_R1,       SZ_Y     }
#define O_R1z     { OP_R1,       SZ_Z     }
#define O_R2b     { OP_R2,       SZ_B     }
#define O_R2v     { OP_R2,       SZ_V     }
#define O_R2w     { OP_R2,       SZ_W     }
#define O_R2y     { OP_R2,       SZ_Y     }
#define O_R2z     { OP_R2,       SZ_Z     }
#define O_R3b     { OP_R3,       SZ_B     }
#define O_R3v     { OP_R3,       SZ_V     }
#define O_R3w     { OP_R3,       SZ_W     }
#define O_R3y     { OP_R3,       SZ_Y     }
#define O_R3z     { OP_R3,       SZ_Z     }
#define O_R4b     { OP_R4,       SZ_B     }
#define O_R4v     { OP_R4,       SZ_V     }
#define O_R4w     { OP_R4,       SZ_W     }
#define O_R4y     { OP_R4,       SZ_Y     }
#define O_R4z     { OP_R4,       SZ_Z     }
#define O_R5b     { OP_R5,       SZ_B     }
#define O_R5v     { OP_R5,       SZ_V     }
#define O_R5w     { OP_R5,       SZ_W     }
#define O_R5y     { OP_R5,       SZ_Y     }
#define O_R5z     { OP_R5,       SZ_Z     }
#define O_R6b     { OP_R6,       SZ_B     }
#define O_R6v     { OP_R6,       SZ_V     }
#define O_R6w     { OP_R6,       SZ_W     }
#define O_R6y     { OP_R6,       SZ_Y     }
#define O_R6z     { OP_R6,       SZ_Z     }
#define O_R7b     { OP_R7,       SZ_B     }
#define O_R7v     { OP_R7,       SZ_V     }
#define O_R7w     { OP_R7,       SZ_W     }
#define O_R7y     { OP_R7,       SZ_Y     }
#define O_R7z     { OP_R7,       SZ_Z     }
#define O_S       { OP_S,        SZ_NA    }
#define O_SS      { OP_SS,       SZ_NA    }
#define O_ST0     { OP_ST0,      SZ_NA    }
#define O_ST1     { OP_ST1,      SZ_NA    }
#define O_ST2     { OP_ST2,      SZ_NA    }
#define O_ST3     { OP_ST3,      SZ_NA    }
#define O_ST4     { OP_ST4,      SZ_NA    }
#define O_ST5     { OP_ST5,      SZ_NA    }
#define O_ST6     { OP_ST6,      SZ_NA    }
#define O_ST7     { OP_ST7,      SZ_NA    }
#define O_U       { OP_U,        SZ_O     }
#define O_V       { OP_V,        SZ_O     }
#define O_W       { OP_W,        SZ_O     }
#define O_eAX     { OP_eAX,      SZ_Z     }
#define O_eCX     { OP_eCX,      SZ_Z     }
#define O_eDX     { OP_eDX,      SZ_Z     }
#define O_rAX     { OP_rAX,      SZ_V     }
#define O_rCX     { OP_rCX,      SZ_V     }
#define O_rDX     { OP_rDX,      SZ_V     }
#define O_sIb     { OP_sI,       SZ_B     }
#define O_sIv     { OP_sI,       SZ_V     }
#define O_sIz     { OP_sI,       SZ_Z     }

struct ud_itab_entry ud_itab[] = {
  /* 0000 */ { UD_Iinvalid, O_NONE, O_NONE, O_NONE, P_none },
  /* 0001 */ { UD_Iadd, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0002 */ { UD_Iadd, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0003 */ { UD_Iadd, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0004 */ { UD_Iadd, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0005 */ { UD_Iadd, O_AL, O_Ib, O_NONE, P_none },
  /* 0006 */ { UD_Iadd, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0007 */ { UD_Ipush, O_ES, O_NONE, O_NONE, P_inv64 },
  /* 0008 */ { UD_Ipop, O_ES, O_NONE, O_NONE, P_inv64 },
  /* 0009 */ { UD_Ior, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0010 */ { UD_Ior, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0011 */ { UD_Ior, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0012 */ { UD_Ior, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0013 */ { UD_Ior, O_AL, O_Ib, O_NONE, P_none },
  /* 0014 */ { UD_Ior, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0015 */ { UD_Ipush, O_CS, O_NONE, O_NONE, P_inv64 },
  /* 0016 */ { UD_Isldt, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0017 */ { UD_Istr, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0018 */ { UD_Illdt, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0019 */ { UD_Iltr, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0020 */ { UD_Iverr, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0021 */ { UD_Iverw, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0022 */ { UD_Isgdt, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0023 */ { UD_Isidt, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0024 */ { UD_Ilgdt, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0025 */ { UD_Ilidt, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0026 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0027 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0028 */ { UD_Iinvlpg, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0029 */ { UD_Ivmcall, O_NONE, O_NONE, O_NONE, P_none },
  /* 0030 */ { UD_Ivmlaunch, O_NONE, O_NONE, O_NONE, P_none },
  /* 0031 */ { UD_Ivmresume, O_NONE, O_NONE, O_NONE, P_none },
  /* 0032 */ { UD_Ivmxoff, O_NONE, O_NONE, O_NONE, P_none },
  /* 0033 */ { UD_Imonitor, O_NONE, O_NONE, O_NONE, P_none },
  /* 0034 */ { UD_Imwait, O_NONE, O_NONE, O_NONE, P_none },
  /* 0035 */ { UD_Ixgetbv, O_NONE, O_NONE, O_NONE, P_none },
  /* 0036 */ { UD_Ixsetbv, O_NONE, O_NONE, O_NONE, P_none },
  /* 0037 */ { UD_Ivmrun, O_NONE, O_NONE, O_NONE, P_none },
  /* 0038 */ { UD_Ivmmcall, O_NONE, O_NONE, O_NONE, P_none },
  /* 0039 */ { UD_Ivmload, O_NONE, O_NONE, O_NONE, P_none },
  /* 0040 */ { UD_Ivmsave, O_NONE, O_NONE, O_NONE, P_none },
  /* 0041 */ { UD_Istgi, O_NONE, O_NONE, O_NONE, P_none },
  /* 0042 */ { UD_Iclgi, O_NONE, O_NONE, O_NONE, P_none },
  /* 0043 */ { UD_Iskinit, O_NONE, O_NONE, O_NONE, P_none },
  /* 0044 */ { UD_Iinvlpga, O_NONE, O_NONE, O_NONE, P_none },
  /* 0045 */ { UD_Ismsw, O_MwRv, O_NONE, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0046 */ { UD_Ilmsw, O_Ew, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0047 */ { UD_Iswapgs, O_NONE, O_NONE, O_NONE, P_none },
  /* 0048 */ { UD_Irdtscp, O_NONE, O_NONE, O_NONE, P_none },
  /* 0049 */ { UD_Ilar, O_Gv, O_Ew, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0050 */ { UD_Ilsl, O_Gv, O_Ew, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0051 */ { UD_Isyscall, O_NONE, O_NONE, O_NONE, P_none },
  /* 0052 */ { UD_Iclts, O_NONE, O_NONE, O_NONE, P_none },
  /* 0053 */ { UD_Isysret, O_NONE, O_NONE, O_NONE, P_none },
  /* 0054 */ { UD_Iinvd, O_NONE, O_NONE, O_NONE, P_none },
  /* 0055 */ { UD_Iwbinvd, O_NONE, O_NONE, O_NONE, P_none },
  /* 0056 */ { UD_Iud2, O_NONE, O_NONE, O_NONE, P_none },
  /* 0057 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0058 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0059 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0060 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0061 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0062 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0063 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0064 */ { UD_Iprefetch, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0065 */ { UD_Ifemms, O_NONE, O_NONE, O_NONE, P_none },
  /* 0066 */ { UD_Ipi2fw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0067 */ { UD_Ipi2fd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0068 */ { UD_Ipf2iw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0069 */ { UD_Ipf2id, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0070 */ { UD_Ipfnacc, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0071 */ { UD_Ipfpnacc, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0072 */ { UD_Ipfcmpge, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0073 */ { UD_Ipfmin, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0074 */ { UD_Ipfrcp, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0075 */ { UD_Ipfrsqrt, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0076 */ { UD_Ipfsub, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0077 */ { UD_Ipfadd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0078 */ { UD_Ipfcmpgt, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0079 */ { UD_Ipfmax, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0080 */ { UD_Ipfrcpit1, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0081 */ { UD_Ipfrsqit1, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0082 */ { UD_Ipfsubr, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0083 */ { UD_Ipfacc, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0084 */ { UD_Ipfcmpeq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0085 */ { UD_Ipfmul, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0086 */ { UD_Ipfrcpit2, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0087 */ { UD_Ipmulhrw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0088 */ { UD_Ipswapd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0089 */ { UD_Ipavgusb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0090 */ { UD_Imovups, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0091 */ { UD_Imovsd, O_V, O_W, O_NONE, P_str|P_aso|P_rexr|P_rexx|P_rexb },
  /* 0092 */ { UD_Imovss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0093 */ { UD_Imovupd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0094 */ { UD_Imovups, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0095 */ { UD_Imovsd, O_W, O_V, O_NONE, P_str|P_aso|P_rexr|P_rexx|P_rexb },
  /* 0096 */ { UD_Imovss, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0097 */ { UD_Imovupd, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0098 */ { UD_Imovlps, O_V, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0099 */ { UD_Imovddup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0100 */ { UD_Imovsldup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0101 */ { UD_Imovlpd, O_V, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0102 */ { UD_Imovhlps, O_V, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0103 */ { UD_Imovddup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0104 */ { UD_Imovsldup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0105 */ { UD_Imovlps, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0106 */ { UD_Imovlpd, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0107 */ { UD_Iunpcklps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0108 */ { UD_Iunpcklpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0109 */ { UD_Iunpckhps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0110 */ { UD_Iunpckhpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0111 */ { UD_Imovhps, O_V, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0112 */ { UD_Imovshdup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0113 */ { UD_Imovhpd, O_V, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0114 */ { UD_Imovlhps, O_V, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0115 */ { UD_Imovshdup, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0116 */ { UD_Imovhps, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0117 */ { UD_Imovhpd, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0118 */ { UD_Iprefetchnta, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0119 */ { UD_Iprefetcht0, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0120 */ { UD_Iprefetcht1, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0121 */ { UD_Iprefetcht2, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0122 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0123 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0124 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0125 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0126 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0127 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0128 */ { UD_Inop, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0129 */ { UD_Imov, O_R, O_C, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0130 */ { UD_Imov, O_R, O_D, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0131 */ { UD_Imov, O_C, O_R, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0132 */ { UD_Imov, O_D, O_R, O_NONE, P_rexr|P_rexw|P_rexb },
  /* 0133 */ { UD_Imovaps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0134 */ { UD_Imovapd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0135 */ { UD_Imovaps, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0136 */ { UD_Imovapd, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0137 */ { UD_Icvtpi2ps, O_V, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0138 */ { UD_Icvtsi2sd, O_V, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0139 */ { UD_Icvtsi2ss, O_V, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0140 */ { UD_Icvtpi2pd, O_V, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0141 */ { UD_Imovntps, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0142 */ { UD_Imovntpd, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0143 */ { UD_Icvttps2pi, O_P, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0144 */ { UD_Icvttsd2si, O_Gy, O_W, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0145 */ { UD_Icvttss2si, O_Gy, O_W, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0146 */ { UD_Icvttpd2pi, O_P, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0147 */ { UD_Icvtps2pi, O_P, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0148 */ { UD_Icvtsd2si, O_Gy, O_W, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0149 */ { UD_Icvtss2si, O_Gy, O_W, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0150 */ { UD_Icvtpd2pi, O_P, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0151 */ { UD_Iucomiss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0152 */ { UD_Iucomisd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0153 */ { UD_Icomiss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0154 */ { UD_Icomisd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0155 */ { UD_Iwrmsr, O_NONE, O_NONE, O_NONE, P_none },
  /* 0156 */ { UD_Irdtsc, O_NONE, O_NONE, O_NONE, P_none },
  /* 0157 */ { UD_Irdmsr, O_NONE, O_NONE, O_NONE, P_none },
  /* 0158 */ { UD_Irdpmc, O_NONE, O_NONE, O_NONE, P_none },
  /* 0159 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, P_none },
  /* 0160 */ { UD_Isysenter, O_NONE, O_NONE, O_NONE, P_none },
  /* 0161 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, P_none },
  /* 0162 */ { UD_Isysexit, O_NONE, O_NONE, O_NONE, P_none },
  /* 0163 */ { UD_Igetsec, O_NONE, O_NONE, O_NONE, P_none },
  /* 0164 */ { UD_Ipshufb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0165 */ { UD_Ipshufb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0166 */ { UD_Iphaddw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0167 */ { UD_Iphaddw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0168 */ { UD_Iphaddd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0169 */ { UD_Iphaddd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0170 */ { UD_Iphaddsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0171 */ { UD_Iphaddsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0172 */ { UD_Ipmaddubsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0173 */ { UD_Ipmaddubsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0174 */ { UD_Iphsubw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0175 */ { UD_Iphsubw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0176 */ { UD_Iphsubd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0177 */ { UD_Iphsubd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0178 */ { UD_Iphsubsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0179 */ { UD_Iphsubsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0180 */ { UD_Ipsignb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0181 */ { UD_Ipsignb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0182 */ { UD_Ipsignw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0183 */ { UD_Ipsignw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0184 */ { UD_Ipsignd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0185 */ { UD_Ipsignd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0186 */ { UD_Ipmulhrsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0187 */ { UD_Ipmulhrsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0188 */ { UD_Ipblendvb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0189 */ { UD_Iblendvps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0190 */ { UD_Iblendvpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0191 */ { UD_Iptest, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0192 */ { UD_Ipabsb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0193 */ { UD_Ipabsb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0194 */ { UD_Ipabsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0195 */ { UD_Ipabsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0196 */ { UD_Ipabsd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0197 */ { UD_Ipabsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0198 */ { UD_Ipmovsxbw, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0199 */ { UD_Ipmovsxbd, O_V, O_MdU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0200 */ { UD_Ipmovsxbq, O_V, O_MwU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0201 */ { UD_Ipmovsxwd, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0202 */ { UD_Ipmovsxwq, O_V, O_MdU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0203 */ { UD_Ipmovsxdq, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0204 */ { UD_Ipmuldq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0205 */ { UD_Ipcmpeqq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0206 */ { UD_Imovntdqa, O_V, O_Mo, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0207 */ { UD_Ipackusdw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0208 */ { UD_Ipmovzxbw, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0209 */ { UD_Ipmovzxbd, O_V, O_MdU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0210 */ { UD_Ipmovzxbq, O_V, O_MwU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0211 */ { UD_Ipmovzxwd, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0212 */ { UD_Ipmovzxwq, O_V, O_MdU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0213 */ { UD_Ipmovzxdq, O_V, O_MqU, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0214 */ { UD_Ipcmpgtq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0215 */ { UD_Ipminsb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0216 */ { UD_Ipminsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0217 */ { UD_Ipminuw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0218 */ { UD_Ipminud, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0219 */ { UD_Ipmaxsb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0220 */ { UD_Ipmaxsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0221 */ { UD_Ipmaxuw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0222 */ { UD_Ipmaxud, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0223 */ { UD_Ipmulld, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0224 */ { UD_Iphminposuw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0225 */ { UD_Iinvept, O_Gq, O_Mo, O_NONE, P_none },
  /* 0226 */ { UD_Iinvvpid, O_Gq, O_Mo, O_NONE, P_none },
  /* 0227 */ { UD_Iaesimc, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0228 */ { UD_Iaesenc, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0229 */ { UD_Iaesenclast, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0230 */ { UD_Iaesdec, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0231 */ { UD_Iaesdeclast, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0232 */ { UD_Imovbe, O_Gv, O_Mv, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0233 */ { UD_Icrc32, O_Gy, O_Eb, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0234 */ { UD_Imovbe, O_Mv, O_Gv, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0235 */ { UD_Icrc32, O_Gy, O_Ev, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0236 */ { UD_Iroundps, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0237 */ { UD_Iroundpd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0238 */ { UD_Iroundss, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0239 */ { UD_Iroundsd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0240 */ { UD_Iblendps, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0241 */ { UD_Iblendpd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0242 */ { UD_Ipblendw, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0243 */ { UD_Ipalignr, O_P, O_Q, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0244 */ { UD_Ipalignr, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0245 */ { UD_Ipextrb, O_MbRv, O_V, O_Ib, P_aso|P_rexx|P_rexr|P_rexb|P_def64 },
  /* 0246 */ { UD_Ipextrw, O_MwRd, O_V, O_Ib, P_aso|P_rexx|P_rexr|P_rexb },
  /* 0247 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 0248 */ { UD_Ipextrd, O_Ed, O_V, O_Ib, P_aso|P_rexr|P_rexx|P_rexw|P_rexb },
  /* 0249 */ { UD_Ipextrq, O_Eq, O_V, O_Ib, P_aso|P_rexr|P_rexw|P_rexb|P_def64 },
  /* 0250 */ { UD_Iextractps, O_MdRy, O_V, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0251 */ { UD_Ipinsrb, O_V, O_MbRd, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0252 */ { UD_Iinsertps, O_V, O_Md, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0253 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0254 */ { UD_Ipinsrd, O_V, O_Ed, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0255 */ { UD_Ipinsrq, O_V, O_Eq, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0256 */ { UD_Idpps, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0257 */ { UD_Idppd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0258 */ { UD_Impsadbw, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0259 */ { UD_Ipclmulqdq, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0260 */ { UD_Ipcmpestrm, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0261 */ { UD_Ipcmpestri, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0262 */ { UD_Ipcmpistrm, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0263 */ { UD_Ipcmpistri, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0264 */ { UD_Iaeskeygenassist, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0265 */ { UD_Icmovo, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0266 */ { UD_Icmovno, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0267 */ { UD_Icmovb, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0268 */ { UD_Icmovae, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0269 */ { UD_Icmovz, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0270 */ { UD_Icmovnz, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0271 */ { UD_Icmovbe, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0272 */ { UD_Icmova, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0273 */ { UD_Icmovs, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0274 */ { UD_Icmovns, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0275 */ { UD_Icmovp, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0276 */ { UD_Icmovnp, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0277 */ { UD_Icmovl, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0278 */ { UD_Icmovge, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0279 */ { UD_Icmovle, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0280 */ { UD_Icmovg, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0281 */ { UD_Imovmskps, O_Gd, O_U, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0282 */ { UD_Imovmskpd, O_Gd, O_U, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0283 */ { UD_Isqrtps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0284 */ { UD_Isqrtsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0285 */ { UD_Isqrtss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0286 */ { UD_Isqrtpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0287 */ { UD_Irsqrtps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0288 */ { UD_Irsqrtss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0289 */ { UD_Ircpps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0290 */ { UD_Ircpss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0291 */ { UD_Iandps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0292 */ { UD_Iandpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0293 */ { UD_Iandnps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0294 */ { UD_Iandnpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0295 */ { UD_Iorps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0296 */ { UD_Iorpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0297 */ { UD_Ixorps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0298 */ { UD_Ixorpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0299 */ { UD_Iaddps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0300 */ { UD_Iaddsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0301 */ { UD_Iaddss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0302 */ { UD_Iaddpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0303 */ { UD_Imulps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0304 */ { UD_Imulsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0305 */ { UD_Imulss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0306 */ { UD_Imulpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0307 */ { UD_Icvtps2pd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0308 */ { UD_Icvtsd2ss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0309 */ { UD_Icvtss2sd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0310 */ { UD_Icvtpd2ps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0311 */ { UD_Icvtdq2ps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0312 */ { UD_Icvttps2dq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0313 */ { UD_Icvtps2dq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0314 */ { UD_Isubps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0315 */ { UD_Isubsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0316 */ { UD_Isubss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0317 */ { UD_Isubpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0318 */ { UD_Iminps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0319 */ { UD_Iminsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0320 */ { UD_Iminss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0321 */ { UD_Iminpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0322 */ { UD_Idivps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0323 */ { UD_Idivsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0324 */ { UD_Idivss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0325 */ { UD_Idivpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0326 */ { UD_Imaxps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0327 */ { UD_Imaxsd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0328 */ { UD_Imaxss, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0329 */ { UD_Imaxpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0330 */ { UD_Ipunpcklbw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0331 */ { UD_Ipunpcklbw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0332 */ { UD_Ipunpcklwd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0333 */ { UD_Ipunpcklwd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0334 */ { UD_Ipunpckldq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0335 */ { UD_Ipunpckldq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0336 */ { UD_Ipacksswb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0337 */ { UD_Ipacksswb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0338 */ { UD_Ipcmpgtb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0339 */ { UD_Ipcmpgtb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0340 */ { UD_Ipcmpgtw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0341 */ { UD_Ipcmpgtw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0342 */ { UD_Ipcmpgtd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0343 */ { UD_Ipcmpgtd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0344 */ { UD_Ipackuswb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0345 */ { UD_Ipackuswb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0346 */ { UD_Ipunpckhbw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0347 */ { UD_Ipunpckhbw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0348 */ { UD_Ipunpckhwd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0349 */ { UD_Ipunpckhwd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0350 */ { UD_Ipunpckhdq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0351 */ { UD_Ipunpckhdq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0352 */ { UD_Ipackssdw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0353 */ { UD_Ipackssdw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0354 */ { UD_Ipunpcklqdq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0355 */ { UD_Ipunpckhqdq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0356 */ { UD_Imovd, O_P, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0357 */ { UD_Imovd, O_V, O_Ey, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0358 */ { UD_Imovq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0359 */ { UD_Imovdqu, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0360 */ { UD_Imovdqa, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0361 */ { UD_Ipshufw, O_P, O_Q, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0362 */ { UD_Ipshuflw, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0363 */ { UD_Ipshufhw, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0364 */ { UD_Ipshufd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0365 */ { UD_Ipsrlw, O_N, O_Ib, O_NONE, P_none },
  /* 0366 */ { UD_Ipsrlw, O_U, O_Ib, O_NONE, P_rexb },
  /* 0367 */ { UD_Ipsraw, O_N, O_Ib, O_NONE, P_none },
  /* 0368 */ { UD_Ipsraw, O_U, O_Ib, O_NONE, P_rexb },
  /* 0369 */ { UD_Ipsllw, O_N, O_Ib, O_NONE, P_none },
  /* 0370 */ { UD_Ipsllw, O_U, O_Ib, O_NONE, P_rexb },
  /* 0371 */ { UD_Ipsrld, O_N, O_Ib, O_NONE, P_none },
  /* 0372 */ { UD_Ipsrld, O_U, O_Ib, O_NONE, P_rexb },
  /* 0373 */ { UD_Ipsrad, O_N, O_Ib, O_NONE, P_none },
  /* 0374 */ { UD_Ipsrad, O_U, O_Ib, O_NONE, P_rexb },
  /* 0375 */ { UD_Ipslld, O_N, O_Ib, O_NONE, P_none },
  /* 0376 */ { UD_Ipslld, O_U, O_Ib, O_NONE, P_rexb },
  /* 0377 */ { UD_Ipsrlq, O_N, O_Ib, O_NONE, P_none },
  /* 0378 */ { UD_Ipsrlq, O_U, O_Ib, O_NONE, P_rexb },
  /* 0379 */ { UD_Ipsrldq, O_U, O_Ib, O_NONE, P_rexb },
  /* 0380 */ { UD_Ipsllq, O_N, O_Ib, O_NONE, P_none },
  /* 0381 */ { UD_Ipsllq, O_U, O_Ib, O_NONE, P_rexb },
  /* 0382 */ { UD_Ipslldq, O_U, O_Ib, O_NONE, P_rexb },
  /* 0383 */ { UD_Ipcmpeqb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0384 */ { UD_Ipcmpeqb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0385 */ { UD_Ipcmpeqw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0386 */ { UD_Ipcmpeqw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0387 */ { UD_Ipcmpeqd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0388 */ { UD_Ipcmpeqd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0389 */ { UD_Iemms, O_NONE, O_NONE, O_NONE, P_none },
  /* 0390 */ { UD_Ivmread, O_Ey, O_Gy, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0391 */ { UD_Ivmwrite, O_Gy, O_Ey, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0392 */ { UD_Ihaddps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0393 */ { UD_Ihaddpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0394 */ { UD_Ihsubps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0395 */ { UD_Ihsubpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0396 */ { UD_Imovd, O_Ey, O_P, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0397 */ { UD_Imovq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0398 */ { UD_Imovd, O_Ey, O_V, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0399 */ { UD_Imovq, O_Q, O_P, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0400 */ { UD_Imovdqu, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0401 */ { UD_Imovdqa, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0402 */ { UD_Ijo, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0403 */ { UD_Ijno, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0404 */ { UD_Ijb, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0405 */ { UD_Ijae, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0406 */ { UD_Ijz, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0407 */ { UD_Ijnz, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0408 */ { UD_Ijbe, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0409 */ { UD_Ija, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0410 */ { UD_Ijs, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0411 */ { UD_Ijns, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0412 */ { UD_Ijp, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0413 */ { UD_Ijnp, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0414 */ { UD_Ijl, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0415 */ { UD_Ijge, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0416 */ { UD_Ijle, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0417 */ { UD_Ijg, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0418 */ { UD_Iseto, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0419 */ { UD_Isetno, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0420 */ { UD_Isetb, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0421 */ { UD_Isetae, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0422 */ { UD_Isetz, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0423 */ { UD_Isetnz, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0424 */ { UD_Isetbe, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0425 */ { UD_Iseta, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0426 */ { UD_Isets, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0427 */ { UD_Isetns, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0428 */ { UD_Isetp, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0429 */ { UD_Isetnp, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0430 */ { UD_Isetl, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0431 */ { UD_Isetge, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0432 */ { UD_Isetle, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0433 */ { UD_Isetg, O_Eb, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0434 */ { UD_Ipush, O_FS, O_NONE, O_NONE, P_none },
  /* 0435 */ { UD_Ipop, O_FS, O_NONE, O_NONE, P_none },
  /* 0436 */ { UD_Icpuid, O_NONE, O_NONE, O_NONE, P_none },
  /* 0437 */ { UD_Ibt, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0438 */ { UD_Ishld, O_Ev, O_Gv, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0439 */ { UD_Ishld, O_Ev, O_Gv, O_CL, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0440 */ { UD_Imontmul, O_NONE, O_NONE, O_NONE, P_none },
  /* 0441 */ { UD_Ixsha1, O_NONE, O_NONE, O_NONE, P_none },
  /* 0442 */ { UD_Ixsha256, O_NONE, O_NONE, O_NONE, P_none },
  /* 0443 */ { UD_Ixstore, O_NONE, O_NONE, O_NONE, P_none },
  /* 0444 */ { UD_Ixcryptecb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0445 */ { UD_Ixcryptcbc, O_NONE, O_NONE, O_NONE, P_none },
  /* 0446 */ { UD_Ixcryptctr, O_NONE, O_NONE, O_NONE, P_none },
  /* 0447 */ { UD_Ixcryptcfb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0448 */ { UD_Ixcryptofb, O_NONE, O_NONE, O_NONE, P_none },
  /* 0449 */ { UD_Ipush, O_GS, O_NONE, O_NONE, P_none },
  /* 0450 */ { UD_Ipop, O_GS, O_NONE, O_NONE, P_none },
  /* 0451 */ { UD_Irsm, O_NONE, O_NONE, O_NONE, P_none },
  /* 0452 */ { UD_Ibts, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0453 */ { UD_Ishrd, O_Ev, O_Gv, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0454 */ { UD_Ishrd, O_Ev, O_Gv, O_CL, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0455 */ { UD_Ifxsave, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0456 */ { UD_Ifxrstor, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0457 */ { UD_Ildmxcsr, O_Md, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0458 */ { UD_Istmxcsr, O_Md, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0459 */ { UD_Ixsave, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0460 */ { UD_Ixrstor, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0461 */ { UD_Iclflush, O_M, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0462 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0463 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0464 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0465 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0466 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0467 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0468 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0469 */ { UD_Ilfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0470 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0471 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0472 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0473 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0474 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0475 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0476 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0477 */ { UD_Imfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0478 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0479 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0480 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0481 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0482 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0483 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0484 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0485 */ { UD_Isfence, O_NONE, O_NONE, O_NONE, P_none },
  /* 0486 */ { UD_Iimul, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0487 */ { UD_Icmpxchg, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0488 */ { UD_Icmpxchg, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0489 */ { UD_Ilss, O_Gv, O_M, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0490 */ { UD_Ibtr, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0491 */ { UD_Ilfs, O_Gz, O_M, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0492 */ { UD_Ilgs, O_Gz, O_M, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0493 */ { UD_Imovzx, O_Gv, O_Eb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0494 */ { UD_Imovzx, O_Gy, O_Ew, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0495 */ { UD_Ipopcnt, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexr|P_rexw|P_rexx|P_rexb },
  /* 0496 */ { UD_Ibt, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0497 */ { UD_Ibts, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0498 */ { UD_Ibtr, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0499 */ { UD_Ibtc, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0500 */ { UD_Ibtc, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0501 */ { UD_Ibsf, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0502 */ { UD_Ibsr, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0503 */ { UD_Imovsx, O_Gv, O_Eb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0504 */ { UD_Imovsx, O_Gy, O_Ew, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0505 */ { UD_Ixadd, O_Eb, O_Gb, O_NONE, P_aso|P_oso|P_rexr|P_rexx|P_rexb },
  /* 0506 */ { UD_Ixadd, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0507 */ { UD_Icmpps, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0508 */ { UD_Icmpsd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0509 */ { UD_Icmpss, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0510 */ { UD_Icmppd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0511 */ { UD_Imovnti, O_M, O_Gy, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0512 */ { UD_Ipinsrw, O_P, O_MwRy, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0513 */ { UD_Ipinsrw, O_V, O_MwRy, O_Ib, P_aso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0514 */ { UD_Ipextrw, O_Gd, O_N, O_Ib, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0515 */ { UD_Ipextrw, O_Gd, O_U, O_Ib, P_aso|P_rexr|P_rexb },
  /* 0516 */ { UD_Ishufps, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0517 */ { UD_Ishufpd, O_V, O_W, O_Ib, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0518 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0519 */ { UD_Icmpxchg8b, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0520 */ { UD_Icmpxchg16b, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0521 */ { UD_Ivmptrld, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0522 */ { UD_Ivmxon, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0523 */ { UD_Ivmclear, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0524 */ { UD_Ivmptrst, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0525 */ { UD_Ibswap, O_R0y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0526 */ { UD_Ibswap, O_R1y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0527 */ { UD_Ibswap, O_R2y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0528 */ { UD_Ibswap, O_R3y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0529 */ { UD_Ibswap, O_R4y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0530 */ { UD_Ibswap, O_R5y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0531 */ { UD_Ibswap, O_R6y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0532 */ { UD_Ibswap, O_R7y, O_NONE, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0533 */ { UD_Iaddsubps, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0534 */ { UD_Iaddsubpd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0535 */ { UD_Ipsrlw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0536 */ { UD_Ipsrlw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0537 */ { UD_Ipsrld, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0538 */ { UD_Ipsrld, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0539 */ { UD_Ipsrlq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0540 */ { UD_Ipsrlq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0541 */ { UD_Ipaddq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0542 */ { UD_Ipaddq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0543 */ { UD_Ipmullw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0544 */ { UD_Ipmullw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0545 */ { UD_Imovdq2q, O_P, O_U, O_NONE, P_aso|P_rexb },
  /* 0546 */ { UD_Imovq2dq, O_V, O_N, O_NONE, P_aso|P_rexr },
  /* 0547 */ { UD_Imovq, O_W, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0548 */ { UD_Ipmovmskb, O_Gd, O_N, O_NONE, P_oso|P_rexr|P_rexb },
  /* 0549 */ { UD_Ipmovmskb, O_Gd, O_U, O_NONE, P_rexr|P_rexb },
  /* 0550 */ { UD_Ipsubusb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0551 */ { UD_Ipsubusb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0552 */ { UD_Ipsubusw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0553 */ { UD_Ipsubusw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0554 */ { UD_Ipminub, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0555 */ { UD_Ipminub, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0556 */ { UD_Ipand, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0557 */ { UD_Ipand, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0558 */ { UD_Ipaddusb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0559 */ { UD_Ipaddusb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0560 */ { UD_Ipaddusw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0561 */ { UD_Ipaddusw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0562 */ { UD_Ipmaxub, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0563 */ { UD_Ipmaxub, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0564 */ { UD_Ipandn, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0565 */ { UD_Ipandn, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0566 */ { UD_Ipavgb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0567 */ { UD_Ipavgb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0568 */ { UD_Ipsraw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0569 */ { UD_Ipsraw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0570 */ { UD_Ipsrad, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0571 */ { UD_Ipsrad, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0572 */ { UD_Ipavgw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0573 */ { UD_Ipavgw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0574 */ { UD_Ipmulhuw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0575 */ { UD_Ipmulhuw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0576 */ { UD_Ipmulhw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0577 */ { UD_Ipmulhw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0578 */ { UD_Icvtpd2dq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0579 */ { UD_Icvtdq2pd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0580 */ { UD_Icvttpd2dq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0581 */ { UD_Imovntq, O_M, O_P, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0582 */ { UD_Imovntdq, O_M, O_V, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0583 */ { UD_Ipsubsb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0584 */ { UD_Ipsubsb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0585 */ { UD_Ipsubsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0586 */ { UD_Ipsubsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0587 */ { UD_Ipminsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0588 */ { UD_Ipminsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0589 */ { UD_Ipor, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0590 */ { UD_Ipor, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0591 */ { UD_Ipaddsb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0592 */ { UD_Ipaddsb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0593 */ { UD_Ipaddsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0594 */ { UD_Ipaddsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0595 */ { UD_Ipmaxsw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0596 */ { UD_Ipmaxsw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0597 */ { UD_Ipxor, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0598 */ { UD_Ipxor, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0599 */ { UD_Ilddqu, O_V, O_M, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0600 */ { UD_Ipsllw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0601 */ { UD_Ipsllw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0602 */ { UD_Ipslld, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0603 */ { UD_Ipslld, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0604 */ { UD_Ipsllq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0605 */ { UD_Ipsllq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0606 */ { UD_Ipmuludq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0607 */ { UD_Ipmuludq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0608 */ { UD_Ipmaddwd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0609 */ { UD_Ipmaddwd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0610 */ { UD_Ipsadbw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0611 */ { UD_Ipsadbw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0612 */ { UD_Imaskmovq, O_P, O_N, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0613 */ { UD_Imaskmovdqu, O_V, O_U, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0614 */ { UD_Ipsubb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0615 */ { UD_Ipsubb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0616 */ { UD_Ipsubw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0617 */ { UD_Ipsubw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0618 */ { UD_Ipsubd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0619 */ { UD_Ipsubd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0620 */ { UD_Ipsubq, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0621 */ { UD_Ipsubq, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0622 */ { UD_Ipaddb, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0623 */ { UD_Ipaddb, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0624 */ { UD_Ipaddw, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0625 */ { UD_Ipaddw, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0626 */ { UD_Ipaddd, O_P, O_Q, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0627 */ { UD_Ipaddd, O_V, O_W, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0628 */ { UD_Iadc, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0629 */ { UD_Iadc, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0630 */ { UD_Iadc, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0631 */ { UD_Iadc, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0632 */ { UD_Iadc, O_AL, O_Ib, O_NONE, P_none },
  /* 0633 */ { UD_Iadc, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0634 */ { UD_Ipush, O_SS, O_NONE, O_NONE, P_inv64 },
  /* 0635 */ { UD_Ipop, O_SS, O_NONE, O_NONE, P_inv64 },
  /* 0636 */ { UD_Isbb, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0637 */ { UD_Isbb, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0638 */ { UD_Isbb, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0639 */ { UD_Isbb, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0640 */ { UD_Isbb, O_AL, O_Ib, O_NONE, P_none },
  /* 0641 */ { UD_Isbb, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0642 */ { UD_Ipush, O_DS, O_NONE, O_NONE, P_inv64 },
  /* 0643 */ { UD_Ipop, O_DS, O_NONE, O_NONE, P_inv64 },
  /* 0644 */ { UD_Iand, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0645 */ { UD_Iand, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0646 */ { UD_Iand, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0647 */ { UD_Iand, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0648 */ { UD_Iand, O_AL, O_Ib, O_NONE, P_none },
  /* 0649 */ { UD_Iand, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0650 */ { UD_Idaa, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0651 */ { UD_Isub, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0652 */ { UD_Isub, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0653 */ { UD_Isub, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0654 */ { UD_Isub, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0655 */ { UD_Isub, O_AL, O_Ib, O_NONE, P_none },
  /* 0656 */ { UD_Isub, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0657 */ { UD_Idas, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0658 */ { UD_Ixor, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0659 */ { UD_Ixor, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0660 */ { UD_Ixor, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0661 */ { UD_Ixor, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0662 */ { UD_Ixor, O_AL, O_Ib, O_NONE, P_none },
  /* 0663 */ { UD_Ixor, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0664 */ { UD_Iaaa, O_NONE, O_NONE, O_NONE, P_none },
  /* 0665 */ { UD_Icmp, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0666 */ { UD_Icmp, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0667 */ { UD_Icmp, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0668 */ { UD_Icmp, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0669 */ { UD_Icmp, O_AL, O_Ib, O_NONE, P_none },
  /* 0670 */ { UD_Icmp, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0671 */ { UD_Iaas, O_NONE, O_NONE, O_NONE, P_none },
  /* 0672 */ { UD_Iinc, O_R0z, O_NONE, O_NONE, P_oso },
  /* 0673 */ { UD_Iinc, O_R1z, O_NONE, O_NONE, P_oso },
  /* 0674 */ { UD_Iinc, O_R2z, O_NONE, O_NONE, P_oso },
  /* 0675 */ { UD_Iinc, O_R3z, O_NONE, O_NONE, P_oso },
  /* 0676 */ { UD_Iinc, O_R4z, O_NONE, O_NONE, P_oso },
  /* 0677 */ { UD_Iinc, O_R5z, O_NONE, O_NONE, P_oso },
  /* 0678 */ { UD_Iinc, O_R6z, O_NONE, O_NONE, P_oso },
  /* 0679 */ { UD_Iinc, O_R7z, O_NONE, O_NONE, P_oso },
  /* 0680 */ { UD_Idec, O_R0z, O_NONE, O_NONE, P_oso },
  /* 0681 */ { UD_Idec, O_R1z, O_NONE, O_NONE, P_oso },
  /* 0682 */ { UD_Idec, O_R2z, O_NONE, O_NONE, P_oso },
  /* 0683 */ { UD_Idec, O_R3z, O_NONE, O_NONE, P_oso },
  /* 0684 */ { UD_Idec, O_R4z, O_NONE, O_NONE, P_oso },
  /* 0685 */ { UD_Idec, O_R5z, O_NONE, O_NONE, P_oso },
  /* 0686 */ { UD_Idec, O_R6z, O_NONE, O_NONE, P_oso },
  /* 0687 */ { UD_Idec, O_R7z, O_NONE, O_NONE, P_oso },
  /* 0688 */ { UD_Ipush, O_R0v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0689 */ { UD_Ipush, O_R1v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0690 */ { UD_Ipush, O_R2v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0691 */ { UD_Ipush, O_R3v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0692 */ { UD_Ipush, O_R4v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0693 */ { UD_Ipush, O_R5v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0694 */ { UD_Ipush, O_R6v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0695 */ { UD_Ipush, O_R7v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0696 */ { UD_Ipop, O_R0v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0697 */ { UD_Ipop, O_R1v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0698 */ { UD_Ipop, O_R2v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0699 */ { UD_Ipop, O_R3v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0700 */ { UD_Ipop, O_R4v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0701 */ { UD_Ipop, O_R5v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0702 */ { UD_Ipop, O_R6v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0703 */ { UD_Ipop, O_R7v, O_NONE, O_NONE, P_oso|P_rexb|P_def64 },
  /* 0704 */ { UD_Ipusha, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 0705 */ { UD_Ipushad, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 0706 */ { UD_Ipopa, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 0707 */ { UD_Ipopad, O_NONE, O_NONE, O_NONE, P_oso|P_inv64 },
  /* 0708 */ { UD_Ibound, O_Gv, O_M, O_NONE, P_aso|P_oso },
  /* 0709 */ { UD_Iarpl, O_Ew, O_Gw, O_NONE, P_aso },
  /* 0710 */ { UD_Imovsxd, O_Gq, O_Ed, O_NONE, P_aso|P_oso|P_rexw|P_rexx|P_rexr|P_rexb },
  /* 0711 */ { UD_Ipush, O_sIz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0712 */ { UD_Iimul, O_Gv, O_Ev, O_Iz, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0713 */ { UD_Ipush, O_sIb, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0714 */ { UD_Iimul, O_Gv, O_Ev, O_sIb, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0715 */ { UD_Iinsb, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0716 */ { UD_Iinsw, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0717 */ { UD_Iinsd, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0718 */ { UD_Ioutsb, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0719 */ { UD_Ioutsw, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0720 */ { UD_Ioutsd, O_NONE, O_NONE, O_NONE, P_str|P_oso|P_seg },
  /* 0721 */ { UD_Ijo, O_Jb, O_NONE, O_NONE, P_none },
  /* 0722 */ { UD_Ijno, O_Jb, O_NONE, O_NONE, P_none },
  /* 0723 */ { UD_Ijb, O_Jb, O_NONE, O_NONE, P_none },
  /* 0724 */ { UD_Ijae, O_Jb, O_NONE, O_NONE, P_none },
  /* 0725 */ { UD_Ijz, O_Jb, O_NONE, O_NONE, P_none },
  /* 0726 */ { UD_Ijnz, O_Jb, O_NONE, O_NONE, P_none },
  /* 0727 */ { UD_Ijbe, O_Jb, O_NONE, O_NONE, P_none },
  /* 0728 */ { UD_Ija, O_Jb, O_NONE, O_NONE, P_none },
  /* 0729 */ { UD_Ijs, O_Jb, O_NONE, O_NONE, P_none },
  /* 0730 */ { UD_Ijns, O_Jb, O_NONE, O_NONE, P_none },
  /* 0731 */ { UD_Ijp, O_Jb, O_NONE, O_NONE, P_none },
  /* 0732 */ { UD_Ijnp, O_Jb, O_NONE, O_NONE, P_none },
  /* 0733 */ { UD_Ijl, O_Jb, O_NONE, O_NONE, P_none },
  /* 0734 */ { UD_Ijge, O_Jb, O_NONE, O_NONE, P_none },
  /* 0735 */ { UD_Ijle, O_Jb, O_NONE, O_NONE, P_none },
  /* 0736 */ { UD_Ijg, O_Jb, O_NONE, O_NONE, P_none },
  /* 0737 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0738 */ { UD_Ior, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0739 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0740 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0741 */ { UD_Iand, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0742 */ { UD_Isub, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0743 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0744 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0745 */ { UD_Iadd, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0746 */ { UD_Ior, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0747 */ { UD_Iadc, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0748 */ { UD_Isbb, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0749 */ { UD_Iand, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0750 */ { UD_Isub, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0751 */ { UD_Ixor, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0752 */ { UD_Icmp, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0753 */ { UD_Iadd, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0754 */ { UD_Ior, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0755 */ { UD_Iadc, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0756 */ { UD_Isbb, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0757 */ { UD_Iand, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0758 */ { UD_Isub, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0759 */ { UD_Ixor, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0760 */ { UD_Icmp, O_Eb, O_Ib, O_NONE, P_aso|P_rexr|P_rexx|P_rexb|P_inv64 },
  /* 0761 */ { UD_Iadd, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0762 */ { UD_Ior, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0763 */ { UD_Iadc, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0764 */ { UD_Isbb, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0765 */ { UD_Iand, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0766 */ { UD_Isub, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0767 */ { UD_Ixor, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0768 */ { UD_Icmp, O_Ev, O_sIb, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0769 */ { UD_Itest, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0770 */ { UD_Itest, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0771 */ { UD_Ixchg, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0772 */ { UD_Ixchg, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0773 */ { UD_Imov, O_Eb, O_Gb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0774 */ { UD_Imov, O_Ev, O_Gv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0775 */ { UD_Imov, O_Gb, O_Eb, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0776 */ { UD_Imov, O_Gv, O_Ev, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0777 */ { UD_Imov, O_MwRv, O_S, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0778 */ { UD_Ilea, O_Gv, O_M, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0779 */ { UD_Imov, O_S, O_MwRv, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0780 */ { UD_Ipop, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 0781 */ { UD_Ixchg, O_R0v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0782 */ { UD_Ixchg, O_R1v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0783 */ { UD_Ixchg, O_R2v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0784 */ { UD_Ixchg, O_R3v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0785 */ { UD_Ixchg, O_R4v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0786 */ { UD_Ixchg, O_R5v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0787 */ { UD_Ixchg, O_R6v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0788 */ { UD_Ixchg, O_R7v, O_rAX, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0789 */ { UD_Icbw, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0790 */ { UD_Icwde, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0791 */ { UD_Icdqe, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0792 */ { UD_Icwd, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0793 */ { UD_Icdq, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0794 */ { UD_Icqo, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0795 */ { UD_Icall, O_Av, O_NONE, O_NONE, P_oso },
  /* 0796 */ { UD_Iwait, O_NONE, O_NONE, O_NONE, P_none },
  /* 0797 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0798 */ { UD_Ipushfw, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 0799 */ { UD_Ipushfd, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0800 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 0801 */ { UD_Ipushfq, O_NONE, O_NONE, O_NONE, P_oso|P_rexw|P_def64 },
  /* 0802 */ { UD_Ipopfw, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0803 */ { UD_Ipopfd, O_NONE, O_NONE, O_NONE, P_oso },
  /* 0804 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0805 */ { UD_Ipopfq, O_NONE, O_NONE, O_NONE, P_oso|P_def64 },
  /* 0806 */ { UD_Isahf, O_NONE, O_NONE, O_NONE, P_none },
  /* 0807 */ { UD_Ilahf, O_NONE, O_NONE, O_NONE, P_none },
  /* 0808 */ { UD_Imov, O_AL, O_Ob, O_NONE, P_none },
  /* 0809 */ { UD_Imov, O_rAX, O_Ov, O_NONE, P_aso|P_oso|P_rexw },
  /* 0810 */ { UD_Imov, O_Ob, O_AL, O_NONE, P_none },
  /* 0811 */ { UD_Imov, O_Ov, O_rAX, O_NONE, P_aso|P_oso|P_rexw },
  /* 0812 */ { UD_Imovsb, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0813 */ { UD_Imovsw, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0814 */ { UD_Imovsd, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0815 */ { UD_Imovsq, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0816 */ { UD_Icmpsb, O_NONE, O_NONE, O_NONE, P_strz|P_seg },
  /* 0817 */ { UD_Icmpsw, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0818 */ { UD_Icmpsd, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0819 */ { UD_Icmpsq, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw|P_seg },
  /* 0820 */ { UD_Itest, O_AL, O_Ib, O_NONE, P_none },
  /* 0821 */ { UD_Itest, O_rAX, O_sIz, O_NONE, P_oso|P_rexw },
  /* 0822 */ { UD_Istosb, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0823 */ { UD_Istosw, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0824 */ { UD_Istosd, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0825 */ { UD_Istosq, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0826 */ { UD_Ilodsb, O_NONE, O_NONE, O_NONE, P_str|P_seg },
  /* 0827 */ { UD_Ilodsw, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0828 */ { UD_Ilodsd, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0829 */ { UD_Ilodsq, O_NONE, O_NONE, O_NONE, P_str|P_seg|P_oso|P_rexw },
  /* 0830 */ { UD_Iscasb, O_NONE, O_NONE, O_NONE, P_strz },
  /* 0831 */ { UD_Iscasw, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 0832 */ { UD_Iscasd, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 0833 */ { UD_Iscasq, O_NONE, O_NONE, O_NONE, P_strz|P_oso|P_rexw },
  /* 0834 */ { UD_Imov, O_R0b, O_Ib, O_NONE, P_rexb },
  /* 0835 */ { UD_Imov, O_R1b, O_Ib, O_NONE, P_rexb },
  /* 0836 */ { UD_Imov, O_R2b, O_Ib, O_NONE, P_rexb },
  /* 0837 */ { UD_Imov, O_R3b, O_Ib, O_NONE, P_rexb },
  /* 0838 */ { UD_Imov, O_R4b, O_Ib, O_NONE, P_rexb },
  /* 0839 */ { UD_Imov, O_R5b, O_Ib, O_NONE, P_rexb },
  /* 0840 */ { UD_Imov, O_R6b, O_Ib, O_NONE, P_rexb },
  /* 0841 */ { UD_Imov, O_R7b, O_Ib, O_NONE, P_rexb },
  /* 0842 */ { UD_Imov, O_R0v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0843 */ { UD_Imov, O_R1v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0844 */ { UD_Imov, O_R2v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0845 */ { UD_Imov, O_R3v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0846 */ { UD_Imov, O_R4v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0847 */ { UD_Imov, O_R5v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0848 */ { UD_Imov, O_R6v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0849 */ { UD_Imov, O_R7v, O_Iv, O_NONE, P_oso|P_rexw|P_rexb },
  /* 0850 */ { UD_Irol, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0851 */ { UD_Iror, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0852 */ { UD_Ircl, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0853 */ { UD_Ircr, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0854 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0855 */ { UD_Ishr, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0856 */ { UD_Ishl, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0857 */ { UD_Isar, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0858 */ { UD_Irol, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0859 */ { UD_Iror, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0860 */ { UD_Ircl, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0861 */ { UD_Ircr, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0862 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0863 */ { UD_Ishr, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0864 */ { UD_Ishl, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0865 */ { UD_Isar, O_Ev, O_Ib, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0866 */ { UD_Iret, O_Iw, O_NONE, O_NONE, P_none },
  /* 0867 */ { UD_Iret, O_NONE, O_NONE, O_NONE, P_none },
  /* 0868 */ { UD_Iles, O_Gv, O_M, O_NONE, P_aso|P_oso },
  /* 0869 */ { UD_Ilds, O_Gv, O_M, O_NONE, P_aso|P_oso },
  /* 0870 */ { UD_Imov, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0871 */ { UD_Imov, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0872 */ { UD_Ienter, O_Iw, O_Ib, O_NONE, P_def64 },
  /* 0873 */ { UD_Ileave, O_NONE, O_NONE, O_NONE, P_none },
  /* 0874 */ { UD_Iretf, O_Iw, O_NONE, O_NONE, P_none },
  /* 0875 */ { UD_Iretf, O_NONE, O_NONE, O_NONE, P_none },
  /* 0876 */ { UD_Iint3, O_NONE, O_NONE, O_NONE, P_none },
  /* 0877 */ { UD_Iint, O_Ib, O_NONE, O_NONE, P_none },
  /* 0878 */ { UD_Iinto, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0879 */ { UD_Iiretw, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0880 */ { UD_Iiretd, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0881 */ { UD_Iiretq, O_NONE, O_NONE, O_NONE, P_oso|P_rexw },
  /* 0882 */ { UD_Irol, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0883 */ { UD_Iror, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0884 */ { UD_Ircl, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0885 */ { UD_Ircr, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0886 */ { UD_Ishl, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0887 */ { UD_Ishr, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0888 */ { UD_Ishl, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0889 */ { UD_Isar, O_Eb, O_I1, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0890 */ { UD_Irol, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0891 */ { UD_Iror, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0892 */ { UD_Ircl, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0893 */ { UD_Ircr, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0894 */ { UD_Ishl, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0895 */ { UD_Ishr, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0896 */ { UD_Ishl, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0897 */ { UD_Isar, O_Ev, O_I1, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0898 */ { UD_Irol, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0899 */ { UD_Iror, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0900 */ { UD_Ircl, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0901 */ { UD_Ircr, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0902 */ { UD_Ishl, O_Eb, O_CL, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0903 */ { UD_Ishr, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0904 */ { UD_Ishl, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0905 */ { UD_Isar, O_Eb, O_CL, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0906 */ { UD_Irol, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0907 */ { UD_Iror, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0908 */ { UD_Ircl, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0909 */ { UD_Ircr, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0910 */ { UD_Ishl, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0911 */ { UD_Ishr, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0912 */ { UD_Ishl, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0913 */ { UD_Isar, O_Ev, O_CL, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 0914 */ { UD_Iaam, O_Ib, O_NONE, O_NONE, P_none },
  /* 0915 */ { UD_Iaad, O_Ib, O_NONE, O_NONE, P_none },
  /* 0916 */ { UD_Isalc, O_NONE, O_NONE, O_NONE, P_inv64 },
  /* 0917 */ { UD_Ixlatb, O_NONE, O_NONE, O_NONE, P_rexw|P_seg },
  /* 0918 */ { UD_Ifadd, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0919 */ { UD_Ifmul, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0920 */ { UD_Ifcom, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0921 */ { UD_Ifcomp, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0922 */ { UD_Ifsub, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0923 */ { UD_Ifsubr, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0924 */ { UD_Ifdiv, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0925 */ { UD_Ifdivr, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0926 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, P_none },
  /* 0927 */ { UD_Ifadd, O_ST0, O_ST1, O_NONE, P_none },
  /* 0928 */ { UD_Ifadd, O_ST0, O_ST2, O_NONE, P_none },
  /* 0929 */ { UD_Ifadd, O_ST0, O_ST3, O_NONE, P_none },
  /* 0930 */ { UD_Ifadd, O_ST0, O_ST4, O_NONE, P_none },
  /* 0931 */ { UD_Ifadd, O_ST0, O_ST5, O_NONE, P_none },
  /* 0932 */ { UD_Ifadd, O_ST0, O_ST6, O_NONE, P_none },
  /* 0933 */ { UD_Ifadd, O_ST0, O_ST7, O_NONE, P_none },
  /* 0934 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, P_none },
  /* 0935 */ { UD_Ifmul, O_ST0, O_ST1, O_NONE, P_none },
  /* 0936 */ { UD_Ifmul, O_ST0, O_ST2, O_NONE, P_none },
  /* 0937 */ { UD_Ifmul, O_ST0, O_ST3, O_NONE, P_none },
  /* 0938 */ { UD_Ifmul, O_ST0, O_ST4, O_NONE, P_none },
  /* 0939 */ { UD_Ifmul, O_ST0, O_ST5, O_NONE, P_none },
  /* 0940 */ { UD_Ifmul, O_ST0, O_ST6, O_NONE, P_none },
  /* 0941 */ { UD_Ifmul, O_ST0, O_ST7, O_NONE, P_none },
  /* 0942 */ { UD_Ifcom, O_ST0, O_ST0, O_NONE, P_none },
  /* 0943 */ { UD_Ifcom, O_ST0, O_ST1, O_NONE, P_none },
  /* 0944 */ { UD_Ifcom, O_ST0, O_ST2, O_NONE, P_none },
  /* 0945 */ { UD_Ifcom, O_ST0, O_ST3, O_NONE, P_none },
  /* 0946 */ { UD_Ifcom, O_ST0, O_ST4, O_NONE, P_none },
  /* 0947 */ { UD_Ifcom, O_ST0, O_ST5, O_NONE, P_none },
  /* 0948 */ { UD_Ifcom, O_ST0, O_ST6, O_NONE, P_none },
  /* 0949 */ { UD_Ifcom, O_ST0, O_ST7, O_NONE, P_none },
  /* 0950 */ { UD_Ifcomp, O_ST0, O_ST0, O_NONE, P_none },
  /* 0951 */ { UD_Ifcomp, O_ST0, O_ST1, O_NONE, P_none },
  /* 0952 */ { UD_Ifcomp, O_ST0, O_ST2, O_NONE, P_none },
  /* 0953 */ { UD_Ifcomp, O_ST0, O_ST3, O_NONE, P_none },
  /* 0954 */ { UD_Ifcomp, O_ST0, O_ST4, O_NONE, P_none },
  /* 0955 */ { UD_Ifcomp, O_ST0, O_ST5, O_NONE, P_none },
  /* 0956 */ { UD_Ifcomp, O_ST0, O_ST6, O_NONE, P_none },
  /* 0957 */ { UD_Ifcomp, O_ST0, O_ST7, O_NONE, P_none },
  /* 0958 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, P_none },
  /* 0959 */ { UD_Ifsub, O_ST0, O_ST1, O_NONE, P_none },
  /* 0960 */ { UD_Ifsub, O_ST0, O_ST2, O_NONE, P_none },
  /* 0961 */ { UD_Ifsub, O_ST0, O_ST3, O_NONE, P_none },
  /* 0962 */ { UD_Ifsub, O_ST0, O_ST4, O_NONE, P_none },
  /* 0963 */ { UD_Ifsub, O_ST0, O_ST5, O_NONE, P_none },
  /* 0964 */ { UD_Ifsub, O_ST0, O_ST6, O_NONE, P_none },
  /* 0965 */ { UD_Ifsub, O_ST0, O_ST7, O_NONE, P_none },
  /* 0966 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, P_none },
  /* 0967 */ { UD_Ifsubr, O_ST0, O_ST1, O_NONE, P_none },
  /* 0968 */ { UD_Ifsubr, O_ST0, O_ST2, O_NONE, P_none },
  /* 0969 */ { UD_Ifsubr, O_ST0, O_ST3, O_NONE, P_none },
  /* 0970 */ { UD_Ifsubr, O_ST0, O_ST4, O_NONE, P_none },
  /* 0971 */ { UD_Ifsubr, O_ST0, O_ST5, O_NONE, P_none },
  /* 0972 */ { UD_Ifsubr, O_ST0, O_ST6, O_NONE, P_none },
  /* 0973 */ { UD_Ifsubr, O_ST0, O_ST7, O_NONE, P_none },
  /* 0974 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, P_none },
  /* 0975 */ { UD_Ifdiv, O_ST0, O_ST1, O_NONE, P_none },
  /* 0976 */ { UD_Ifdiv, O_ST0, O_ST2, O_NONE, P_none },
  /* 0977 */ { UD_Ifdiv, O_ST0, O_ST3, O_NONE, P_none },
  /* 0978 */ { UD_Ifdiv, O_ST0, O_ST4, O_NONE, P_none },
  /* 0979 */ { UD_Ifdiv, O_ST0, O_ST5, O_NONE, P_none },
  /* 0980 */ { UD_Ifdiv, O_ST0, O_ST6, O_NONE, P_none },
  /* 0981 */ { UD_Ifdiv, O_ST0, O_ST7, O_NONE, P_none },
  /* 0982 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, P_none },
  /* 0983 */ { UD_Ifdivr, O_ST0, O_ST1, O_NONE, P_none },
  /* 0984 */ { UD_Ifdivr, O_ST0, O_ST2, O_NONE, P_none },
  /* 0985 */ { UD_Ifdivr, O_ST0, O_ST3, O_NONE, P_none },
  /* 0986 */ { UD_Ifdivr, O_ST0, O_ST4, O_NONE, P_none },
  /* 0987 */ { UD_Ifdivr, O_ST0, O_ST5, O_NONE, P_none },
  /* 0988 */ { UD_Ifdivr, O_ST0, O_ST6, O_NONE, P_none },
  /* 0989 */ { UD_Ifdivr, O_ST0, O_ST7, O_NONE, P_none },
  /* 0990 */ { UD_Ifld, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0991 */ { UD_Ifst, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0992 */ { UD_Ifstp, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0993 */ { UD_Ifldenv, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0994 */ { UD_Ifldcw, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0995 */ { UD_Ifnstenv, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0996 */ { UD_Ifnstcw, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 0997 */ { UD_Ifld, O_ST0, O_NONE, O_NONE, P_none },
  /* 0998 */ { UD_Ifld, O_ST1, O_NONE, O_NONE, P_none },
  /* 0999 */ { UD_Ifld, O_ST2, O_NONE, O_NONE, P_none },
  /* 1000 */ { UD_Ifld, O_ST3, O_NONE, O_NONE, P_none },
  /* 1001 */ { UD_Ifld, O_ST4, O_NONE, O_NONE, P_none },
  /* 1002 */ { UD_Ifld, O_ST5, O_NONE, O_NONE, P_none },
  /* 1003 */ { UD_Ifld, O_ST6, O_NONE, O_NONE, P_none },
  /* 1004 */ { UD_Ifld, O_ST7, O_NONE, O_NONE, P_none },
  /* 1005 */ { UD_Ifxch, O_ST0, O_ST0, O_NONE, P_none },
  /* 1006 */ { UD_Ifxch, O_ST0, O_ST1, O_NONE, P_none },
  /* 1007 */ { UD_Ifxch, O_ST0, O_ST2, O_NONE, P_none },
  /* 1008 */ { UD_Ifxch, O_ST0, O_ST3, O_NONE, P_none },
  /* 1009 */ { UD_Ifxch, O_ST0, O_ST4, O_NONE, P_none },
  /* 1010 */ { UD_Ifxch, O_ST0, O_ST5, O_NONE, P_none },
  /* 1011 */ { UD_Ifxch, O_ST0, O_ST6, O_NONE, P_none },
  /* 1012 */ { UD_Ifxch, O_ST0, O_ST7, O_NONE, P_none },
  /* 1013 */ { UD_Ifnop, O_NONE, O_NONE, O_NONE, P_none },
  /* 1014 */ { UD_Ifstp1, O_ST0, O_NONE, O_NONE, P_none },
  /* 1015 */ { UD_Ifstp1, O_ST1, O_NONE, O_NONE, P_none },
  /* 1016 */ { UD_Ifstp1, O_ST2, O_NONE, O_NONE, P_none },
  /* 1017 */ { UD_Ifstp1, O_ST3, O_NONE, O_NONE, P_none },
  /* 1018 */ { UD_Ifstp1, O_ST4, O_NONE, O_NONE, P_none },
  /* 1019 */ { UD_Ifstp1, O_ST5, O_NONE, O_NONE, P_none },
  /* 1020 */ { UD_Ifstp1, O_ST6, O_NONE, O_NONE, P_none },
  /* 1021 */ { UD_Ifstp1, O_ST7, O_NONE, O_NONE, P_none },
  /* 1022 */ { UD_Ifchs, O_NONE, O_NONE, O_NONE, P_none },
  /* 1023 */ { UD_Ifabs, O_NONE, O_NONE, O_NONE, P_none },
  /* 1024 */ { UD_Iftst, O_NONE, O_NONE, O_NONE, P_none },
  /* 1025 */ { UD_Ifxam, O_NONE, O_NONE, O_NONE, P_none },
  /* 1026 */ { UD_Ifld1, O_NONE, O_NONE, O_NONE, P_none },
  /* 1027 */ { UD_Ifldl2t, O_NONE, O_NONE, O_NONE, P_none },
  /* 1028 */ { UD_Ifldl2e, O_NONE, O_NONE, O_NONE, P_none },
  /* 1029 */ { UD_Ifldpi, O_NONE, O_NONE, O_NONE, P_none },
  /* 1030 */ { UD_Ifldlg2, O_NONE, O_NONE, O_NONE, P_none },
  /* 1031 */ { UD_Ifldln2, O_NONE, O_NONE, O_NONE, P_none },
  /* 1032 */ { UD_Ifldz, O_NONE, O_NONE, O_NONE, P_none },
  /* 1033 */ { UD_If2xm1, O_NONE, O_NONE, O_NONE, P_none },
  /* 1034 */ { UD_Ifyl2x, O_NONE, O_NONE, O_NONE, P_none },
  /* 1035 */ { UD_Ifptan, O_NONE, O_NONE, O_NONE, P_none },
  /* 1036 */ { UD_Ifpatan, O_NONE, O_NONE, O_NONE, P_none },
  /* 1037 */ { UD_Ifxtract, O_NONE, O_NONE, O_NONE, P_none },
  /* 1038 */ { UD_Ifprem1, O_NONE, O_NONE, O_NONE, P_none },
  /* 1039 */ { UD_Ifdecstp, O_NONE, O_NONE, O_NONE, P_none },
  /* 1040 */ { UD_Ifincstp, O_NONE, O_NONE, O_NONE, P_none },
  /* 1041 */ { UD_Ifprem, O_NONE, O_NONE, O_NONE, P_none },
  /* 1042 */ { UD_Ifyl2xp1, O_NONE, O_NONE, O_NONE, P_none },
  /* 1043 */ { UD_Ifsqrt, O_NONE, O_NONE, O_NONE, P_none },
  /* 1044 */ { UD_Ifsincos, O_NONE, O_NONE, O_NONE, P_none },
  /* 1045 */ { UD_Ifrndint, O_NONE, O_NONE, O_NONE, P_none },
  /* 1046 */ { UD_Ifscale, O_NONE, O_NONE, O_NONE, P_none },
  /* 1047 */ { UD_Ifsin, O_NONE, O_NONE, O_NONE, P_none },
  /* 1048 */ { UD_Ifcos, O_NONE, O_NONE, O_NONE, P_none },
  /* 1049 */ { UD_Ifiadd, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1050 */ { UD_Ifimul, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1051 */ { UD_Ificom, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1052 */ { UD_Ificomp, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1053 */ { UD_Ifisub, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1054 */ { UD_Ifisubr, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1055 */ { UD_Ifidiv, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1056 */ { UD_Ifidivr, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1057 */ { UD_Ifcmovb, O_ST0, O_ST0, O_NONE, P_none },
  /* 1058 */ { UD_Ifcmovb, O_ST0, O_ST1, O_NONE, P_none },
  /* 1059 */ { UD_Ifcmovb, O_ST0, O_ST2, O_NONE, P_none },
  /* 1060 */ { UD_Ifcmovb, O_ST0, O_ST3, O_NONE, P_none },
  /* 1061 */ { UD_Ifcmovb, O_ST0, O_ST4, O_NONE, P_none },
  /* 1062 */ { UD_Ifcmovb, O_ST0, O_ST5, O_NONE, P_none },
  /* 1063 */ { UD_Ifcmovb, O_ST0, O_ST6, O_NONE, P_none },
  /* 1064 */ { UD_Ifcmovb, O_ST0, O_ST7, O_NONE, P_none },
  /* 1065 */ { UD_Ifcmove, O_ST0, O_ST0, O_NONE, P_none },
  /* 1066 */ { UD_Ifcmove, O_ST0, O_ST1, O_NONE, P_none },
  /* 1067 */ { UD_Ifcmove, O_ST0, O_ST2, O_NONE, P_none },
  /* 1068 */ { UD_Ifcmove, O_ST0, O_ST3, O_NONE, P_none },
  /* 1069 */ { UD_Ifcmove, O_ST0, O_ST4, O_NONE, P_none },
  /* 1070 */ { UD_Ifcmove, O_ST0, O_ST5, O_NONE, P_none },
  /* 1071 */ { UD_Ifcmove, O_ST0, O_ST6, O_NONE, P_none },
  /* 1072 */ { UD_Ifcmove, O_ST0, O_ST7, O_NONE, P_none },
  /* 1073 */ { UD_Ifcmovbe, O_ST0, O_ST0, O_NONE, P_none },
  /* 1074 */ { UD_Ifcmovbe, O_ST0, O_ST1, O_NONE, P_none },
  /* 1075 */ { UD_Ifcmovbe, O_ST0, O_ST2, O_NONE, P_none },
  /* 1076 */ { UD_Ifcmovbe, O_ST0, O_ST3, O_NONE, P_none },
  /* 1077 */ { UD_Ifcmovbe, O_ST0, O_ST4, O_NONE, P_none },
  /* 1078 */ { UD_Ifcmovbe, O_ST0, O_ST5, O_NONE, P_none },
  /* 1079 */ { UD_Ifcmovbe, O_ST0, O_ST6, O_NONE, P_none },
  /* 1080 */ { UD_Ifcmovbe, O_ST0, O_ST7, O_NONE, P_none },
  /* 1081 */ { UD_Ifcmovu, O_ST0, O_ST0, O_NONE, P_none },
  /* 1082 */ { UD_Ifcmovu, O_ST0, O_ST1, O_NONE, P_none },
  /* 1083 */ { UD_Ifcmovu, O_ST0, O_ST2, O_NONE, P_none },
  /* 1084 */ { UD_Ifcmovu, O_ST0, O_ST3, O_NONE, P_none },
  /* 1085 */ { UD_Ifcmovu, O_ST0, O_ST4, O_NONE, P_none },
  /* 1086 */ { UD_Ifcmovu, O_ST0, O_ST5, O_NONE, P_none },
  /* 1087 */ { UD_Ifcmovu, O_ST0, O_ST6, O_NONE, P_none },
  /* 1088 */ { UD_Ifcmovu, O_ST0, O_ST7, O_NONE, P_none },
  /* 1089 */ { UD_Ifucompp, O_NONE, O_NONE, O_NONE, P_none },
  /* 1090 */ { UD_Ifild, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1091 */ { UD_Ifisttp, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1092 */ { UD_Ifist, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1093 */ { UD_Ifistp, O_Md, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1094 */ { UD_Ifld, O_Mt, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1095 */ { UD_Ifstp, O_Mt, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1096 */ { UD_Ifcmovnb, O_ST0, O_ST0, O_NONE, P_none },
  /* 1097 */ { UD_Ifcmovnb, O_ST0, O_ST1, O_NONE, P_none },
  /* 1098 */ { UD_Ifcmovnb, O_ST0, O_ST2, O_NONE, P_none },
  /* 1099 */ { UD_Ifcmovnb, O_ST0, O_ST3, O_NONE, P_none },
  /* 1100 */ { UD_Ifcmovnb, O_ST0, O_ST4, O_NONE, P_none },
  /* 1101 */ { UD_Ifcmovnb, O_ST0, O_ST5, O_NONE, P_none },
  /* 1102 */ { UD_Ifcmovnb, O_ST0, O_ST6, O_NONE, P_none },
  /* 1103 */ { UD_Ifcmovnb, O_ST0, O_ST7, O_NONE, P_none },
  /* 1104 */ { UD_Ifcmovne, O_ST0, O_ST0, O_NONE, P_none },
  /* 1105 */ { UD_Ifcmovne, O_ST0, O_ST1, O_NONE, P_none },
  /* 1106 */ { UD_Ifcmovne, O_ST0, O_ST2, O_NONE, P_none },
  /* 1107 */ { UD_Ifcmovne, O_ST0, O_ST3, O_NONE, P_none },
  /* 1108 */ { UD_Ifcmovne, O_ST0, O_ST4, O_NONE, P_none },
  /* 1109 */ { UD_Ifcmovne, O_ST0, O_ST5, O_NONE, P_none },
  /* 1110 */ { UD_Ifcmovne, O_ST0, O_ST6, O_NONE, P_none },
  /* 1111 */ { UD_Ifcmovne, O_ST0, O_ST7, O_NONE, P_none },
  /* 1112 */ { UD_Ifcmovnbe, O_ST0, O_ST0, O_NONE, P_none },
  /* 1113 */ { UD_Ifcmovnbe, O_ST0, O_ST1, O_NONE, P_none },
  /* 1114 */ { UD_Ifcmovnbe, O_ST0, O_ST2, O_NONE, P_none },
  /* 1115 */ { UD_Ifcmovnbe, O_ST0, O_ST3, O_NONE, P_none },
  /* 1116 */ { UD_Ifcmovnbe, O_ST0, O_ST4, O_NONE, P_none },
  /* 1117 */ { UD_Ifcmovnbe, O_ST0, O_ST5, O_NONE, P_none },
  /* 1118 */ { UD_Ifcmovnbe, O_ST0, O_ST6, O_NONE, P_none },
  /* 1119 */ { UD_Ifcmovnbe, O_ST0, O_ST7, O_NONE, P_none },
  /* 1120 */ { UD_Ifcmovnu, O_ST0, O_ST0, O_NONE, P_none },
  /* 1121 */ { UD_Ifcmovnu, O_ST0, O_ST1, O_NONE, P_none },
  /* 1122 */ { UD_Ifcmovnu, O_ST0, O_ST2, O_NONE, P_none },
  /* 1123 */ { UD_Ifcmovnu, O_ST0, O_ST3, O_NONE, P_none },
  /* 1124 */ { UD_Ifcmovnu, O_ST0, O_ST4, O_NONE, P_none },
  /* 1125 */ { UD_Ifcmovnu, O_ST0, O_ST5, O_NONE, P_none },
  /* 1126 */ { UD_Ifcmovnu, O_ST0, O_ST6, O_NONE, P_none },
  /* 1127 */ { UD_Ifcmovnu, O_ST0, O_ST7, O_NONE, P_none },
  /* 1128 */ { UD_Ifclex, O_NONE, O_NONE, O_NONE, P_none },
  /* 1129 */ { UD_Ifninit, O_NONE, O_NONE, O_NONE, P_none },
  /* 1130 */ { UD_Ifucomi, O_ST0, O_ST0, O_NONE, P_none },
  /* 1131 */ { UD_Ifucomi, O_ST0, O_ST1, O_NONE, P_none },
  /* 1132 */ { UD_Ifucomi, O_ST0, O_ST2, O_NONE, P_none },
  /* 1133 */ { UD_Ifucomi, O_ST0, O_ST3, O_NONE, P_none },
  /* 1134 */ { UD_Ifucomi, O_ST0, O_ST4, O_NONE, P_none },
  /* 1135 */ { UD_Ifucomi, O_ST0, O_ST5, O_NONE, P_none },
  /* 1136 */ { UD_Ifucomi, O_ST0, O_ST6, O_NONE, P_none },
  /* 1137 */ { UD_Ifucomi, O_ST0, O_ST7, O_NONE, P_none },
  /* 1138 */ { UD_Ifcomi, O_ST0, O_ST0, O_NONE, P_none },
  /* 1139 */ { UD_Ifcomi, O_ST0, O_ST1, O_NONE, P_none },
  /* 1140 */ { UD_Ifcomi, O_ST0, O_ST2, O_NONE, P_none },
  /* 1141 */ { UD_Ifcomi, O_ST0, O_ST3, O_NONE, P_none },
  /* 1142 */ { UD_Ifcomi, O_ST0, O_ST4, O_NONE, P_none },
  /* 1143 */ { UD_Ifcomi, O_ST0, O_ST5, O_NONE, P_none },
  /* 1144 */ { UD_Ifcomi, O_ST0, O_ST6, O_NONE, P_none },
  /* 1145 */ { UD_Ifcomi, O_ST0, O_ST7, O_NONE, P_none },
  /* 1146 */ { UD_Ifadd, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1147 */ { UD_Ifmul, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1148 */ { UD_Ifcom, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1149 */ { UD_Ifcomp, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1150 */ { UD_Ifsub, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1151 */ { UD_Ifsubr, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1152 */ { UD_Ifdiv, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1153 */ { UD_Ifdivr, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1154 */ { UD_Ifadd, O_ST0, O_ST0, O_NONE, P_none },
  /* 1155 */ { UD_Ifadd, O_ST1, O_ST0, O_NONE, P_none },
  /* 1156 */ { UD_Ifadd, O_ST2, O_ST0, O_NONE, P_none },
  /* 1157 */ { UD_Ifadd, O_ST3, O_ST0, O_NONE, P_none },
  /* 1158 */ { UD_Ifadd, O_ST4, O_ST0, O_NONE, P_none },
  /* 1159 */ { UD_Ifadd, O_ST5, O_ST0, O_NONE, P_none },
  /* 1160 */ { UD_Ifadd, O_ST6, O_ST0, O_NONE, P_none },
  /* 1161 */ { UD_Ifadd, O_ST7, O_ST0, O_NONE, P_none },
  /* 1162 */ { UD_Ifmul, O_ST0, O_ST0, O_NONE, P_none },
  /* 1163 */ { UD_Ifmul, O_ST1, O_ST0, O_NONE, P_none },
  /* 1164 */ { UD_Ifmul, O_ST2, O_ST0, O_NONE, P_none },
  /* 1165 */ { UD_Ifmul, O_ST3, O_ST0, O_NONE, P_none },
  /* 1166 */ { UD_Ifmul, O_ST4, O_ST0, O_NONE, P_none },
  /* 1167 */ { UD_Ifmul, O_ST5, O_ST0, O_NONE, P_none },
  /* 1168 */ { UD_Ifmul, O_ST6, O_ST0, O_NONE, P_none },
  /* 1169 */ { UD_Ifmul, O_ST7, O_ST0, O_NONE, P_none },
  /* 1170 */ { UD_Ifcom2, O_ST0, O_NONE, O_NONE, P_none },
  /* 1171 */ { UD_Ifcom2, O_ST1, O_NONE, O_NONE, P_none },
  /* 1172 */ { UD_Ifcom2, O_ST2, O_NONE, O_NONE, P_none },
  /* 1173 */ { UD_Ifcom2, O_ST3, O_NONE, O_NONE, P_none },
  /* 1174 */ { UD_Ifcom2, O_ST4, O_NONE, O_NONE, P_none },
  /* 1175 */ { UD_Ifcom2, O_ST5, O_NONE, O_NONE, P_none },
  /* 1176 */ { UD_Ifcom2, O_ST6, O_NONE, O_NONE, P_none },
  /* 1177 */ { UD_Ifcom2, O_ST7, O_NONE, O_NONE, P_none },
  /* 1178 */ { UD_Ifcomp3, O_ST0, O_NONE, O_NONE, P_none },
  /* 1179 */ { UD_Ifcomp3, O_ST1, O_NONE, O_NONE, P_none },
  /* 1180 */ { UD_Ifcomp3, O_ST2, O_NONE, O_NONE, P_none },
  /* 1181 */ { UD_Ifcomp3, O_ST3, O_NONE, O_NONE, P_none },
  /* 1182 */ { UD_Ifcomp3, O_ST4, O_NONE, O_NONE, P_none },
  /* 1183 */ { UD_Ifcomp3, O_ST5, O_NONE, O_NONE, P_none },
  /* 1184 */ { UD_Ifcomp3, O_ST6, O_NONE, O_NONE, P_none },
  /* 1185 */ { UD_Ifcomp3, O_ST7, O_NONE, O_NONE, P_none },
  /* 1186 */ { UD_Ifsubr, O_ST0, O_ST0, O_NONE, P_none },
  /* 1187 */ { UD_Ifsubr, O_ST1, O_ST0, O_NONE, P_none },
  /* 1188 */ { UD_Ifsubr, O_ST2, O_ST0, O_NONE, P_none },
  /* 1189 */ { UD_Ifsubr, O_ST3, O_ST0, O_NONE, P_none },
  /* 1190 */ { UD_Ifsubr, O_ST4, O_ST0, O_NONE, P_none },
  /* 1191 */ { UD_Ifsubr, O_ST5, O_ST0, O_NONE, P_none },
  /* 1192 */ { UD_Ifsubr, O_ST6, O_ST0, O_NONE, P_none },
  /* 1193 */ { UD_Ifsubr, O_ST7, O_ST0, O_NONE, P_none },
  /* 1194 */ { UD_Ifsub, O_ST0, O_ST0, O_NONE, P_none },
  /* 1195 */ { UD_Ifsub, O_ST1, O_ST0, O_NONE, P_none },
  /* 1196 */ { UD_Ifsub, O_ST2, O_ST0, O_NONE, P_none },
  /* 1197 */ { UD_Ifsub, O_ST3, O_ST0, O_NONE, P_none },
  /* 1198 */ { UD_Ifsub, O_ST4, O_ST0, O_NONE, P_none },
  /* 1199 */ { UD_Ifsub, O_ST5, O_ST0, O_NONE, P_none },
  /* 1200 */ { UD_Ifsub, O_ST6, O_ST0, O_NONE, P_none },
  /* 1201 */ { UD_Ifsub, O_ST7, O_ST0, O_NONE, P_none },
  /* 1202 */ { UD_Ifdivr, O_ST0, O_ST0, O_NONE, P_none },
  /* 1203 */ { UD_Ifdivr, O_ST1, O_ST0, O_NONE, P_none },
  /* 1204 */ { UD_Ifdivr, O_ST2, O_ST0, O_NONE, P_none },
  /* 1205 */ { UD_Ifdivr, O_ST3, O_ST0, O_NONE, P_none },
  /* 1206 */ { UD_Ifdivr, O_ST4, O_ST0, O_NONE, P_none },
  /* 1207 */ { UD_Ifdivr, O_ST5, O_ST0, O_NONE, P_none },
  /* 1208 */ { UD_Ifdivr, O_ST6, O_ST0, O_NONE, P_none },
  /* 1209 */ { UD_Ifdivr, O_ST7, O_ST0, O_NONE, P_none },
  /* 1210 */ { UD_Ifdiv, O_ST0, O_ST0, O_NONE, P_none },
  /* 1211 */ { UD_Ifdiv, O_ST1, O_ST0, O_NONE, P_none },
  /* 1212 */ { UD_Ifdiv, O_ST2, O_ST0, O_NONE, P_none },
  /* 1213 */ { UD_Ifdiv, O_ST3, O_ST0, O_NONE, P_none },
  /* 1214 */ { UD_Ifdiv, O_ST4, O_ST0, O_NONE, P_none },
  /* 1215 */ { UD_Ifdiv, O_ST5, O_ST0, O_NONE, P_none },
  /* 1216 */ { UD_Ifdiv, O_ST6, O_ST0, O_NONE, P_none },
  /* 1217 */ { UD_Ifdiv, O_ST7, O_ST0, O_NONE, P_none },
  /* 1218 */ { UD_Ifld, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1219 */ { UD_Ifisttp, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1220 */ { UD_Ifst, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1221 */ { UD_Ifstp, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1222 */ { UD_Ifrstor, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1223 */ { UD_Ifnsave, O_M, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1224 */ { UD_Ifnstsw, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1225 */ { UD_Iffree, O_ST0, O_NONE, O_NONE, P_none },
  /* 1226 */ { UD_Iffree, O_ST1, O_NONE, O_NONE, P_none },
  /* 1227 */ { UD_Iffree, O_ST2, O_NONE, O_NONE, P_none },
  /* 1228 */ { UD_Iffree, O_ST3, O_NONE, O_NONE, P_none },
  /* 1229 */ { UD_Iffree, O_ST4, O_NONE, O_NONE, P_none },
  /* 1230 */ { UD_Iffree, O_ST5, O_NONE, O_NONE, P_none },
  /* 1231 */ { UD_Iffree, O_ST6, O_NONE, O_NONE, P_none },
  /* 1232 */ { UD_Iffree, O_ST7, O_NONE, O_NONE, P_none },
  /* 1233 */ { UD_Ifxch4, O_ST0, O_NONE, O_NONE, P_none },
  /* 1234 */ { UD_Ifxch4, O_ST1, O_NONE, O_NONE, P_none },
  /* 1235 */ { UD_Ifxch4, O_ST2, O_NONE, O_NONE, P_none },
  /* 1236 */ { UD_Ifxch4, O_ST3, O_NONE, O_NONE, P_none },
  /* 1237 */ { UD_Ifxch4, O_ST4, O_NONE, O_NONE, P_none },
  /* 1238 */ { UD_Ifxch4, O_ST5, O_NONE, O_NONE, P_none },
  /* 1239 */ { UD_Ifxch4, O_ST6, O_NONE, O_NONE, P_none },
  /* 1240 */ { UD_Ifxch4, O_ST7, O_NONE, O_NONE, P_none },
  /* 1241 */ { UD_Ifst, O_ST0, O_NONE, O_NONE, P_none },
  /* 1242 */ { UD_Ifst, O_ST1, O_NONE, O_NONE, P_none },
  /* 1243 */ { UD_Ifst, O_ST2, O_NONE, O_NONE, P_none },
  /* 1244 */ { UD_Ifst, O_ST3, O_NONE, O_NONE, P_none },
  /* 1245 */ { UD_Ifst, O_ST4, O_NONE, O_NONE, P_none },
  /* 1246 */ { UD_Ifst, O_ST5, O_NONE, O_NONE, P_none },
  /* 1247 */ { UD_Ifst, O_ST6, O_NONE, O_NONE, P_none },
  /* 1248 */ { UD_Ifst, O_ST7, O_NONE, O_NONE, P_none },
  /* 1249 */ { UD_Ifstp, O_ST0, O_NONE, O_NONE, P_none },
  /* 1250 */ { UD_Ifstp, O_ST1, O_NONE, O_NONE, P_none },
  /* 1251 */ { UD_Ifstp, O_ST2, O_NONE, O_NONE, P_none },
  /* 1252 */ { UD_Ifstp, O_ST3, O_NONE, O_NONE, P_none },
  /* 1253 */ { UD_Ifstp, O_ST4, O_NONE, O_NONE, P_none },
  /* 1254 */ { UD_Ifstp, O_ST5, O_NONE, O_NONE, P_none },
  /* 1255 */ { UD_Ifstp, O_ST6, O_NONE, O_NONE, P_none },
  /* 1256 */ { UD_Ifstp, O_ST7, O_NONE, O_NONE, P_none },
  /* 1257 */ { UD_Ifucom, O_ST0, O_NONE, O_NONE, P_none },
  /* 1258 */ { UD_Ifucom, O_ST1, O_NONE, O_NONE, P_none },
  /* 1259 */ { UD_Ifucom, O_ST2, O_NONE, O_NONE, P_none },
  /* 1260 */ { UD_Ifucom, O_ST3, O_NONE, O_NONE, P_none },
  /* 1261 */ { UD_Ifucom, O_ST4, O_NONE, O_NONE, P_none },
  /* 1262 */ { UD_Ifucom, O_ST5, O_NONE, O_NONE, P_none },
  /* 1263 */ { UD_Ifucom, O_ST6, O_NONE, O_NONE, P_none },
  /* 1264 */ { UD_Ifucom, O_ST7, O_NONE, O_NONE, P_none },
  /* 1265 */ { UD_Ifucomp, O_ST0, O_NONE, O_NONE, P_none },
  /* 1266 */ { UD_Ifucomp, O_ST1, O_NONE, O_NONE, P_none },
  /* 1267 */ { UD_Ifucomp, O_ST2, O_NONE, O_NONE, P_none },
  /* 1268 */ { UD_Ifucomp, O_ST3, O_NONE, O_NONE, P_none },
  /* 1269 */ { UD_Ifucomp, O_ST4, O_NONE, O_NONE, P_none },
  /* 1270 */ { UD_Ifucomp, O_ST5, O_NONE, O_NONE, P_none },
  /* 1271 */ { UD_Ifucomp, O_ST6, O_NONE, O_NONE, P_none },
  /* 1272 */ { UD_Ifucomp, O_ST7, O_NONE, O_NONE, P_none },
  /* 1273 */ { UD_Ifiadd, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1274 */ { UD_Ifimul, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1275 */ { UD_Ificom, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1276 */ { UD_Ificomp, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1277 */ { UD_Ifisub, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1278 */ { UD_Ifisubr, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1279 */ { UD_Ifidiv, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1280 */ { UD_Ifidivr, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1281 */ { UD_Ifaddp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1282 */ { UD_Ifaddp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1283 */ { UD_Ifaddp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1284 */ { UD_Ifaddp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1285 */ { UD_Ifaddp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1286 */ { UD_Ifaddp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1287 */ { UD_Ifaddp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1288 */ { UD_Ifaddp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1289 */ { UD_Ifmulp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1290 */ { UD_Ifmulp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1291 */ { UD_Ifmulp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1292 */ { UD_Ifmulp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1293 */ { UD_Ifmulp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1294 */ { UD_Ifmulp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1295 */ { UD_Ifmulp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1296 */ { UD_Ifmulp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1297 */ { UD_Ifcomp5, O_ST0, O_NONE, O_NONE, P_none },
  /* 1298 */ { UD_Ifcomp5, O_ST1, O_NONE, O_NONE, P_none },
  /* 1299 */ { UD_Ifcomp5, O_ST2, O_NONE, O_NONE, P_none },
  /* 1300 */ { UD_Ifcomp5, O_ST3, O_NONE, O_NONE, P_none },
  /* 1301 */ { UD_Ifcomp5, O_ST4, O_NONE, O_NONE, P_none },
  /* 1302 */ { UD_Ifcomp5, O_ST5, O_NONE, O_NONE, P_none },
  /* 1303 */ { UD_Ifcomp5, O_ST6, O_NONE, O_NONE, P_none },
  /* 1304 */ { UD_Ifcomp5, O_ST7, O_NONE, O_NONE, P_none },
  /* 1305 */ { UD_Ifcompp, O_NONE, O_NONE, O_NONE, P_none },
  /* 1306 */ { UD_Ifsubrp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1307 */ { UD_Ifsubrp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1308 */ { UD_Ifsubrp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1309 */ { UD_Ifsubrp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1310 */ { UD_Ifsubrp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1311 */ { UD_Ifsubrp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1312 */ { UD_Ifsubrp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1313 */ { UD_Ifsubrp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1314 */ { UD_Ifsubp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1315 */ { UD_Ifsubp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1316 */ { UD_Ifsubp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1317 */ { UD_Ifsubp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1318 */ { UD_Ifsubp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1319 */ { UD_Ifsubp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1320 */ { UD_Ifsubp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1321 */ { UD_Ifsubp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1322 */ { UD_Ifdivrp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1323 */ { UD_Ifdivrp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1324 */ { UD_Ifdivrp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1325 */ { UD_Ifdivrp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1326 */ { UD_Ifdivrp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1327 */ { UD_Ifdivrp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1328 */ { UD_Ifdivrp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1329 */ { UD_Ifdivrp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1330 */ { UD_Ifdivp, O_ST0, O_ST0, O_NONE, P_none },
  /* 1331 */ { UD_Ifdivp, O_ST1, O_ST0, O_NONE, P_none },
  /* 1332 */ { UD_Ifdivp, O_ST2, O_ST0, O_NONE, P_none },
  /* 1333 */ { UD_Ifdivp, O_ST3, O_ST0, O_NONE, P_none },
  /* 1334 */ { UD_Ifdivp, O_ST4, O_ST0, O_NONE, P_none },
  /* 1335 */ { UD_Ifdivp, O_ST5, O_ST0, O_NONE, P_none },
  /* 1336 */ { UD_Ifdivp, O_ST6, O_ST0, O_NONE, P_none },
  /* 1337 */ { UD_Ifdivp, O_ST7, O_ST0, O_NONE, P_none },
  /* 1338 */ { UD_Ifild, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1339 */ { UD_Ifisttp, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1340 */ { UD_Ifist, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1341 */ { UD_Ifistp, O_Mw, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1342 */ { UD_Ifbld, O_Mt, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1343 */ { UD_Ifild, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1344 */ { UD_Ifbstp, O_Mt, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1345 */ { UD_Ifistp, O_Mq, O_NONE, O_NONE, P_aso|P_rexr|P_rexx|P_rexb },
  /* 1346 */ { UD_Iffreep, O_ST0, O_NONE, O_NONE, P_none },
  /* 1347 */ { UD_Iffreep, O_ST1, O_NONE, O_NONE, P_none },
  /* 1348 */ { UD_Iffreep, O_ST2, O_NONE, O_NONE, P_none },
  /* 1349 */ { UD_Iffreep, O_ST3, O_NONE, O_NONE, P_none },
  /* 1350 */ { UD_Iffreep, O_ST4, O_NONE, O_NONE, P_none },
  /* 1351 */ { UD_Iffreep, O_ST5, O_NONE, O_NONE, P_none },
  /* 1352 */ { UD_Iffreep, O_ST6, O_NONE, O_NONE, P_none },
  /* 1353 */ { UD_Iffreep, O_ST7, O_NONE, O_NONE, P_none },
  /* 1354 */ { UD_Ifxch7, O_ST0, O_NONE, O_NONE, P_none },
  /* 1355 */ { UD_Ifxch7, O_ST1, O_NONE, O_NONE, P_none },
  /* 1356 */ { UD_Ifxch7, O_ST2, O_NONE, O_NONE, P_none },
  /* 1357 */ { UD_Ifxch7, O_ST3, O_NONE, O_NONE, P_none },
  /* 1358 */ { UD_Ifxch7, O_ST4, O_NONE, O_NONE, P_none },
  /* 1359 */ { UD_Ifxch7, O_ST5, O_NONE, O_NONE, P_none },
  /* 1360 */ { UD_Ifxch7, O_ST6, O_NONE, O_NONE, P_none },
  /* 1361 */ { UD_Ifxch7, O_ST7, O_NONE, O_NONE, P_none },
  /* 1362 */ { UD_Ifstp8, O_ST0, O_NONE, O_NONE, P_none },
  /* 1363 */ { UD_Ifstp8, O_ST1, O_NONE, O_NONE, P_none },
  /* 1364 */ { UD_Ifstp8, O_ST2, O_NONE, O_NONE, P_none },
  /* 1365 */ { UD_Ifstp8, O_ST3, O_NONE, O_NONE, P_none },
  /* 1366 */ { UD_Ifstp8, O_ST4, O_NONE, O_NONE, P_none },
  /* 1367 */ { UD_Ifstp8, O_ST5, O_NONE, O_NONE, P_none },
  /* 1368 */ { UD_Ifstp8, O_ST6, O_NONE, O_NONE, P_none },
  /* 1369 */ { UD_Ifstp8, O_ST7, O_NONE, O_NONE, P_none },
  /* 1370 */ { UD_Ifstp9, O_ST0, O_NONE, O_NONE, P_none },
  /* 1371 */ { UD_Ifstp9, O_ST1, O_NONE, O_NONE, P_none },
  /* 1372 */ { UD_Ifstp9, O_ST2, O_NONE, O_NONE, P_none },
  /* 1373 */ { UD_Ifstp9, O_ST3, O_NONE, O_NONE, P_none },
  /* 1374 */ { UD_Ifstp9, O_ST4, O_NONE, O_NONE, P_none },
  /* 1375 */ { UD_Ifstp9, O_ST5, O_NONE, O_NONE, P_none },
  /* 1376 */ { UD_Ifstp9, O_ST6, O_NONE, O_NONE, P_none },
  /* 1377 */ { UD_Ifstp9, O_ST7, O_NONE, O_NONE, P_none },
  /* 1378 */ { UD_Ifnstsw, O_AX, O_NONE, O_NONE, P_none },
  /* 1379 */ { UD_Ifucomip, O_ST0, O_ST0, O_NONE, P_none },
  /* 1380 */ { UD_Ifucomip, O_ST0, O_ST1, O_NONE, P_none },
  /* 1381 */ { UD_Ifucomip, O_ST0, O_ST2, O_NONE, P_none },
  /* 1382 */ { UD_Ifucomip, O_ST0, O_ST3, O_NONE, P_none },
  /* 1383 */ { UD_Ifucomip, O_ST0, O_ST4, O_NONE, P_none },
  /* 1384 */ { UD_Ifucomip, O_ST0, O_ST5, O_NONE, P_none },
  /* 1385 */ { UD_Ifucomip, O_ST0, O_ST6, O_NONE, P_none },
  /* 1386 */ { UD_Ifucomip, O_ST0, O_ST7, O_NONE, P_none },
  /* 1387 */ { UD_Ifcomip, O_ST0, O_ST0, O_NONE, P_none },
  /* 1388 */ { UD_Ifcomip, O_ST0, O_ST1, O_NONE, P_none },
  /* 1389 */ { UD_Ifcomip, O_ST0, O_ST2, O_NONE, P_none },
  /* 1390 */ { UD_Ifcomip, O_ST0, O_ST3, O_NONE, P_none },
  /* 1391 */ { UD_Ifcomip, O_ST0, O_ST4, O_NONE, P_none },
  /* 1392 */ { UD_Ifcomip, O_ST0, O_ST5, O_NONE, P_none },
  /* 1393 */ { UD_Ifcomip, O_ST0, O_ST6, O_NONE, P_none },
  /* 1394 */ { UD_Ifcomip, O_ST0, O_ST7, O_NONE, P_none },
  /* 1395 */ { UD_Iloopne, O_Jb, O_NONE, O_NONE, P_none },
  /* 1396 */ { UD_Iloope, O_Jb, O_NONE, O_NONE, P_none },
  /* 1397 */ { UD_Iloop, O_Jb, O_NONE, O_NONE, P_none },
  /* 1398 */ { UD_Ijcxz, O_Jb, O_NONE, O_NONE, P_aso },
  /* 1399 */ { UD_Ijecxz, O_Jb, O_NONE, O_NONE, P_aso },
  /* 1400 */ { UD_Ijrcxz, O_Jb, O_NONE, O_NONE, P_aso },
  /* 1401 */ { UD_Iin, O_AL, O_Ib, O_NONE, P_none },
  /* 1402 */ { UD_Iin, O_eAX, O_Ib, O_NONE, P_oso },
  /* 1403 */ { UD_Iout, O_Ib, O_AL, O_NONE, P_none },
  /* 1404 */ { UD_Iout, O_Ib, O_eAX, O_NONE, P_oso },
  /* 1405 */ { UD_Icall, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1406 */ { UD_Ijmp, O_Jz, O_NONE, O_NONE, P_oso|P_def64 },
  /* 1407 */ { UD_Ijmp, O_Av, O_NONE, O_NONE, P_oso },
  /* 1408 */ { UD_Ijmp, O_Jb, O_NONE, O_NONE, P_def64 },
  /* 1409 */ { UD_Iin, O_AL, O_DX, O_NONE, P_none },
  /* 1410 */ { UD_Iin, O_eAX, O_DX, O_NONE, P_oso },
  /* 1411 */ { UD_Iout, O_DX, O_AL, O_NONE, P_none },
  /* 1412 */ { UD_Iout, O_DX, O_eAX, O_NONE, P_oso },
  /* 1413 */ { UD_Ilock, O_NONE, O_NONE, O_NONE, P_none },
  /* 1414 */ { UD_Iint1, O_NONE, O_NONE, O_NONE, P_none },
  /* 1415 */ { UD_Irepne, O_NONE, O_NONE, O_NONE, P_none },
  /* 1416 */ { UD_Irep, O_NONE, O_NONE, O_NONE, P_none },
  /* 1417 */ { UD_Ihlt, O_NONE, O_NONE, O_NONE, P_none },
  /* 1418 */ { UD_Icmc, O_NONE, O_NONE, O_NONE, P_none },
  /* 1419 */ { UD_Itest, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1420 */ { UD_Itest, O_Eb, O_Ib, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1421 */ { UD_Inot, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1422 */ { UD_Ineg, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1423 */ { UD_Imul, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1424 */ { UD_Iimul, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1425 */ { UD_Idiv, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1426 */ { UD_Iidiv, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1427 */ { UD_Itest, O_Ev, O_sIz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1428 */ { UD_Itest, O_Ev, O_Iz, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1429 */ { UD_Inot, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1430 */ { UD_Ineg, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1431 */ { UD_Imul, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1432 */ { UD_Iimul, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1433 */ { UD_Idiv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1434 */ { UD_Iidiv, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1435 */ { UD_Iclc, O_NONE, O_NONE, O_NONE, P_none },
  /* 1436 */ { UD_Istc, O_NONE, O_NONE, O_NONE, P_none },
  /* 1437 */ { UD_Icli, O_NONE, O_NONE, O_NONE, P_none },
  /* 1438 */ { UD_Isti, O_NONE, O_NONE, O_NONE, P_none },
  /* 1439 */ { UD_Icld, O_NONE, O_NONE, O_NONE, P_none },
  /* 1440 */ { UD_Istd, O_NONE, O_NONE, O_NONE, P_none },
  /* 1441 */ { UD_Iinc, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1442 */ { UD_Idec, O_Eb, O_NONE, O_NONE, P_aso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1443 */ { UD_Iinc, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1444 */ { UD_Idec, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1445 */ { UD_Icall, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1446 */ { UD_Icall, O_Eq, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1447 */ { UD_Icall, O_Fv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1448 */ { UD_Ijmp, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
  /* 1449 */ { UD_Ijmp, O_Fv, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb },
  /* 1450 */ { UD_Ipush, O_Ev, O_NONE, O_NONE, P_aso|P_oso|P_rexw|P_rexr|P_rexx|P_rexb|P_def64 },
};


const char * ud_mnemonics_str[] = {
"invalid",
    "3dnow",
    "none",
    "db",
    "pause",
    "aaa",
    "aad",
    "aam",
    "aas",
    "adc",
    "add",
    "addpd",
    "addps",
    "addsd",
    "addss",
    "and",
    "andpd",
    "andps",
    "andnpd",
    "andnps",
    "arpl",
    "movsxd",
    "bound",
    "bsf",
    "bsr",
    "bswap",
    "bt",
    "btc",
    "btr",
    "bts",
    "call",
    "cbw",
    "cwde",
    "cdqe",
    "clc",
    "cld",
    "clflush",
    "clgi",
    "cli",
    "clts",
    "cmc",
    "cmovo",
    "cmovno",
    "cmovb",
    "cmovae",
    "cmovz",
    "cmovnz",
    "cmovbe",
    "cmova",
    "cmovs",
    "cmovns",
    "cmovp",
    "cmovnp",
    "cmovl",
    "cmovge",
    "cmovle",
    "cmovg",
    "cmp",
    "cmppd",
    "cmpps",
    "cmpsb",
    "cmpsw",
    "cmpsd",
    "cmpsq",
    "cmpss",
    "cmpxchg",
    "cmpxchg8b",
    "cmpxchg16b",
    "comisd",
    "comiss",
    "cpuid",
    "cvtdq2pd",
    "cvtdq2ps",
    "cvtpd2dq",
    "cvtpd2pi",
    "cvtpd2ps",
    "cvtpi2ps",
    "cvtpi2pd",
    "cvtps2dq",
    "cvtps2pi",
    "cvtps2pd",
    "cvtsd2si",
    "cvtsd2ss",
    "cvtsi2ss",
    "cvtss2si",
    "cvtss2sd",
    "cvttpd2pi",
    "cvttpd2dq",
    "cvttps2dq",
    "cvttps2pi",
    "cvttsd2si",
    "cvtsi2sd",
    "cvttss2si",
    "cwd",
    "cdq",
    "cqo",
    "daa",
    "das",
    "dec",
    "div",
    "divpd",
    "divps",
    "divsd",
    "divss",
    "emms",
    "enter",
    "f2xm1",
    "fabs",
    "fadd",
    "faddp",
    "fbld",
    "fbstp",
    "fchs",
    "fclex",
    "fcmovb",
    "fcmove",
    "fcmovbe",
    "fcmovu",
    "fcmovnb",
    "fcmovne",
    "fcmovnbe",
    "fcmovnu",
    "fucomi",
    "fcom",
    "fcom2",
    "fcomp3",
    "fcomi",
    "fucomip",
    "fcomip",
    "fcomp",
    "fcomp5",
    "fcompp",
    "fcos",
    "fdecstp",
    "fdiv",
    "fdivp",
    "fdivr",
    "fdivrp",
    "femms",
    "ffree",
    "ffreep",
    "ficom",
    "ficomp",
    "fild",
    "fincstp",
    "fninit",
    "fiadd",
    "fidivr",
    "fidiv",
    "fisub",
    "fisubr",
    "fist",
    "fistp",
    "fisttp",
    "fld",
    "fld1",
    "fldl2t",
    "fldl2e",
    "fldpi",
    "fldlg2",
    "fldln2",
    "fldz",
    "fldcw",
    "fldenv",
    "fmul",
    "fmulp",
    "fimul",
    "fnop",
    "fpatan",
    "fprem",
    "fprem1",
    "fptan",
    "frndint",
    "frstor",
    "fnsave",
    "fscale",
    "fsin",
    "fsincos",
    "fsqrt",
    "fstp",
    "fstp1",
    "fstp8",
    "fstp9",
    "fst",
    "fnstcw",
    "fnstenv",
    "fnstsw",
    "fsub",
    "fsubp",
    "fsubr",
    "fsubrp",
    "ftst",
    "fucom",
    "fucomp",
    "fucompp",
    "fxam",
    "fxch",
    "fxch4",
    "fxch7",
    "fxrstor",
    "fxsave",
    "fxtract",
    "fyl2x",
    "fyl2xp1",
    "hlt",
    "idiv",
    "in",
    "imul",
    "inc",
    "insb",
    "insw",
    "insd",
    "int1",
    "int3",
    "int",
    "into",
    "invd",
    "invept",
    "invlpg",
    "invlpga",
    "invvpid",
    "iretw",
    "iretd",
    "iretq",
    "jo",
    "jno",
    "jb",
    "jae",
    "jz",
    "jnz",
    "jbe",
    "ja",
    "js",
    "jns",
    "jp",
    "jnp",
    "jl",
    "jge",
    "jle",
    "jg",
    "jcxz",
    "jecxz",
    "jrcxz",
    "jmp",
    "lahf",
    "lar",
    "lddqu",
    "ldmxcsr",
    "lds",
    "lea",
    "les",
    "lfs",
    "lgs",
    "lidt",
    "lss",
    "leave",
    "lfence",
    "lgdt",
    "lldt",
    "lmsw",
    "lock",
    "lodsb",
    "lodsw",
    "lodsd",
    "lodsq",
    "loopne",
    "loope",
    "loop",
    "lsl",
    "ltr",
    "maskmovq",
    "maxpd",
    "maxps",
    "maxsd",
    "maxss",
    "mfence",
    "minpd",
    "minps",
    "minsd",
    "minss",
    "monitor",
    "montmul",
    "mov",
    "movapd",
    "movaps",
    "movd",
    "movhpd",
    "movhps",
    "movlhps",
    "movlpd",
    "movlps",
    "movhlps",
    "movmskpd",
    "movmskps",
    "movntdq",
    "movnti",
    "movntpd",
    "movntps",
    "movntq",
    "movq",
    "movsb",
    "movsw",
    "movsd",
    "movsq",
    "movss",
    "movsx",
    "movupd",
    "movups",
    "movzx",
    "mul",
    "mulpd",
    "mulps",
    "mulsd",
    "mulss",
    "mwait",
    "neg",
    "nop",
    "not",
    "or",
    "orpd",
    "orps",
    "out",
    "outsb",
    "outsw",
    "outsd",
    "packsswb",
    "packssdw",
    "packuswb",
    "paddb",
    "paddw",
    "paddd",
    "paddsb",
    "paddsw",
    "paddusb",
    "paddusw",
    "pand",
    "pandn",
    "pavgb",
    "pavgw",
    "pcmpeqb",
    "pcmpeqw",
    "pcmpeqd",
    "pcmpgtb",
    "pcmpgtw",
    "pcmpgtd",
    "pextrb",
    "pextrd",
    "pextrq",
    "pextrw",
    "pinsrb",
    "pinsrw",
    "pinsrd",
    "pinsrq",
    "pmaddwd",
    "pmaxsw",
    "pmaxub",
    "pminsw",
    "pminub",
    "pmovmskb",
    "pmulhuw",
    "pmulhw",
    "pmullw",
    "pop",
    "popa",
    "popad",
    "popfw",
    "popfd",
    "popfq",
    "por",
    "prefetch",
    "prefetchnta",
    "prefetcht0",
    "prefetcht1",
    "prefetcht2",
    "psadbw",
    "pshufw",
    "psllw",
    "pslld",
    "psllq",
    "psraw",
    "psrad",
    "psrlw",
    "psrld",
    "psrlq",
    "psubb",
    "psubw",
    "psubd",
    "psubsb",
    "psubsw",
    "psubusb",
    "psubusw",
    "punpckhbw",
    "punpckhwd",
    "punpckhdq",
    "punpcklbw",
    "punpcklwd",
    "punpckldq",
    "pi2fw",
    "pi2fd",
    "pf2iw",
    "pf2id",
    "pfnacc",
    "pfpnacc",
    "pfcmpge",
    "pfmin",
    "pfrcp",
    "pfrsqrt",
    "pfsub",
    "pfadd",
    "pfcmpgt",
    "pfmax",
    "pfrcpit1",
    "pfrsqit1",
    "pfsubr",
    "pfacc",
    "pfcmpeq",
    "pfmul",
    "pfrcpit2",
    "pmulhrw",
    "pswapd",
    "pavgusb",
    "push",
    "pusha",
    "pushad",
    "pushfw",
    "pushfd",
    "pushfq",
    "pxor",
    "rcl",
    "rcr",
    "rol",
    "ror",
    "rcpps",
    "rcpss",
    "rdmsr",
    "rdpmc",
    "rdtsc",
    "rdtscp",
    "repne",
    "rep",
    "ret",
    "retf",
    "rsm",
    "rsqrtps",
    "rsqrtss",
    "sahf",
    "salc",
    "sar",
    "shl",
    "shr",
    "sbb",
    "scasb",
    "scasw",
    "scasd",
    "scasq",
    "seto",
    "setno",
    "setb",
    "setae",
    "setz",
    "setnz",
    "setbe",
    "seta",
    "sets",
    "setns",
    "setp",
    "setnp",
    "setl",
    "setge",
    "setle",
    "setg",
    "sfence",
    "sgdt",
    "shld",
    "shrd",
    "shufpd",
    "shufps",
    "sidt",
    "sldt",
    "smsw",
    "sqrtps",
    "sqrtpd",
    "sqrtsd",
    "sqrtss",
    "stc",
    "std",
    "stgi",
    "sti",
    "skinit",
    "stmxcsr",
    "stosb",
    "stosw",
    "stosd",
    "stosq",
    "str",
    "sub",
    "subpd",
    "subps",
    "subsd",
    "subss",
    "swapgs",
    "syscall",
    "sysenter",
    "sysexit",
    "sysret",
    "test",
    "ucomisd",
    "ucomiss",
    "ud2",
    "unpckhpd",
    "unpckhps",
    "unpcklps",
    "unpcklpd",
    "verr",
    "verw",
    "vmcall",
    "vmclear",
    "vmxon",
    "vmptrld",
    "vmptrst",
    "vmlaunch",
    "vmresume",
    "vmxoff",
    "vmread",
    "vmwrite",
    "vmrun",
    "vmmcall",
    "vmload",
    "vmsave",
    "wait",
    "wbinvd",
    "wrmsr",
    "xadd",
    "xchg",
    "xgetbv",
    "xlatb",
    "xor",
    "xorpd",
    "xorps",
    "xcryptecb",
    "xcryptcbc",
    "xcryptctr",
    "xcryptcfb",
    "xcryptofb",
    "xrstor",
    "xsave",
    "xsetbv",
    "xsha1",
    "xsha256",
    "xstore",
    "aesdec",
    "aesdeclast",
    "aesenc",
    "aesenclast",
    "aesimc",
    "aeskeygenassist",
    "pclmulqdq",
    "getsec",
    "movdqa",
    "maskmovdqu",
    "movdq2q",
    "movdqu",
    "movq2dq",
    "paddq",
    "psubq",
    "pmuludq",
    "pshufhw",
    "pshuflw",
    "pshufd",
    "pslldq",
    "psrldq",
    "punpckhqdq",
    "punpcklqdq",
    "addsubpd",
    "addsubps",
    "haddpd",
    "haddps",
    "hsubpd",
    "hsubps",
    "movddup",
    "movshdup",
    "movsldup",
    "pabsb",
    "pabsw",
    "pabsd",
    "pshufb",
    "phaddw",
    "phaddd",
    "phaddsw",
    "pmaddubsw",
    "phsubw",
    "phsubd",
    "phsubsw",
    "psignb",
    "psignd",
    "psignw",
    "pmulhrsw",
    "palignr",
    "pblendvb",
    "pmuldq",
    "pminsb",
    "pminsd",
    "pminuw",
    "pminud",
    "pmaxsb",
    "pmaxsd",
    "pmaxud",
    "pmaxuw",
    "pmulld",
    "phminposuw",
    "roundps",
    "roundpd",
    "roundss",
    "roundsd",
    "blendpd",
    "pblendw",
    "blendps",
    "blendvpd",
    "blendvps",
    "dpps",
    "dppd",
    "mpsadbw",
    "extractps",
    "insertps",
    "movntdqa",
    "packusdw",
    "pmovsxbw",
    "pmovsxbd",
    "pmovsxbq",
    "pmovsxwd",
    "pmovsxwq",
    "pmovsxdq",
    "pmovzxbw",
    "pmovzxbd",
    "pmovzxbq",
    "pmovzxwd",
    "pmovzxwq",
    "pmovzxdq",
    "pcmpeqq",
    "popcnt",
    "ptest",
    "pcmpestri",
    "pcmpestrm",
    "pcmpgtq",
    "pcmpistri",
    "pcmpistrm",
    "movbe",
    "crc32"
};

```

`Libudis86/itab.h`:

```h
#ifndef UD_ITAB_H
#define UD_ITAB_H

/* itab.h -- generated by udis86:scripts/ud_itab.py, do no edit */

/* ud_table_type -- lookup table types (see decode.c) */
enum ud_table_type {
    UD_TAB__OPC_TABLE,
    UD_TAB__OPC_X87,
    UD_TAB__OPC_MOD,
    UD_TAB__OPC_VEX_M,
    UD_TAB__OPC_VEX_P,
    UD_TAB__OPC_RM,
    UD_TAB__OPC_VENDOR,
    UD_TAB__OPC_OSIZE,
    UD_TAB__OPC_MODE,
    UD_TAB__OPC_3DNOW,
    UD_TAB__OPC_REG,
    UD_TAB__OPC_ASIZE,
    UD_TAB__OPC_SSE
};

/* ud_mnemonic -- mnemonic constants */
enum ud_mnemonic_code {
    UD_Iinvalid,
    UD_I3dnow,
    UD_Inone,
    UD_Idb,
    UD_Ipause,
    UD_Iaaa,
    UD_Iaad,
    UD_Iaam,
    UD_Iaas,
    UD_Iadc,
    UD_Iadd,
    UD_Iaddpd,
    UD_Iaddps,
    UD_Iaddsd,
    UD_Iaddss,
    UD_Iand,
    UD_Iandpd,
    UD_Iandps,
    UD_Iandnpd,
    UD_Iandnps,
    UD_Iarpl,
    UD_Imovsxd,
    UD_Ibound,
    UD_Ibsf,
    UD_Ibsr,
    UD_Ibswap,
    UD_Ibt,
    UD_Ibtc,
    UD_Ibtr,
    UD_Ibts,
    UD_Icall,
    UD_Icbw,
    UD_Icwde,
    UD_Icdqe,
    UD_Iclc,
    UD_Icld,
    UD_Iclflush,
    UD_Iclgi,
    UD_Icli,
    UD_Iclts,
    UD_Icmc,
    UD_Icmovo,
    UD_Icmovno,
    UD_Icmovb,
    UD_Icmovae,
    UD_Icmovz,
    UD_Icmovnz,
    UD_Icmovbe,
    UD_Icmova,
    UD_Icmovs,
    UD_Icmovns,
    UD_Icmovp,
    UD_Icmovnp,
    UD_Icmovl,
    UD_Icmovge,
    UD_Icmovle,
    UD_Icmovg,
    UD_Icmp,
    UD_Icmppd,
    UD_Icmpps,
    UD_Icmpsb,
    UD_Icmpsw,
    UD_Icmpsd,
    UD_Icmpsq,
    UD_Icmpss,
    UD_Icmpxchg,
    UD_Icmpxchg8b,
    UD_Icmpxchg16b,
    UD_Icomisd,
    UD_Icomiss,
    UD_Icpuid,
    UD_Icvtdq2pd,
    UD_Icvtdq2ps,
    UD_Icvtpd2dq,
    UD_Icvtpd2pi,
    UD_Icvtpd2ps,
    UD_Icvtpi2ps,
    UD_Icvtpi2pd,
    UD_Icvtps2dq,
    UD_Icvtps2pi,
    UD_Icvtps2pd,
    UD_Icvtsd2si,
    UD_Icvtsd2ss,
    UD_Icvtsi2ss,
    UD_Icvtss2si,
    UD_Icvtss2sd,
    UD_Icvttpd2pi,
    UD_Icvttpd2dq,
    UD_Icvttps2dq,
    UD_Icvttps2pi,
    UD_Icvttsd2si,
    UD_Icvtsi2sd,
    UD_Icvttss2si,
    UD_Icwd,
    UD_Icdq,
    UD_Icqo,
    UD_Idaa,
    UD_Idas,
    UD_Idec,
    UD_Idiv,
    UD_Idivpd,
    UD_Idivps,
    UD_Idivsd,
    UD_Idivss,
    UD_Iemms,
    UD_Ienter,
    UD_If2xm1,
    UD_Ifabs,
    UD_Ifadd,
    UD_Ifaddp,
    UD_Ifbld,
    UD_Ifbstp,
    UD_Ifchs,
    UD_Ifclex,
    UD_Ifcmovb,
    UD_Ifcmove,
    UD_Ifcmovbe,
    UD_Ifcmovu,
    UD_Ifcmovnb,
    UD_Ifcmovne,
    UD_Ifcmovnbe,
    UD_Ifcmovnu,
    UD_Ifucomi,
    UD_Ifcom,
    UD_Ifcom2,
    UD_Ifcomp3,
    UD_Ifcomi,
    UD_Ifucomip,
    UD_Ifcomip,
    UD_Ifcomp,
    UD_Ifcomp5,
    UD_Ifcompp,
    UD_Ifcos,
    UD_Ifdecstp,
    UD_Ifdiv,
    UD_Ifdivp,
    UD_Ifdivr,
    UD_Ifdivrp,
    UD_Ifemms,
    UD_Iffree,
    UD_Iffreep,
    UD_Ificom,
    UD_Ificomp,
    UD_Ifild,
    UD_Ifincstp,
    UD_Ifninit,
    UD_Ifiadd,
    UD_Ifidivr,
    UD_Ifidiv,
    UD_Ifisub,
    UD_Ifisubr,
    UD_Ifist,
    UD_Ifistp,
    UD_Ifisttp,
    UD_Ifld,
    UD_Ifld1,
    UD_Ifldl2t,
    UD_Ifldl2e,
    UD_Ifldpi,
    UD_Ifldlg2,
    UD_Ifldln2,
    UD_Ifldz,
    UD_Ifldcw,
    UD_Ifldenv,
    UD_Ifmul,
    UD_Ifmulp,
    UD_Ifimul,
    UD_Ifnop,
    UD_Ifpatan,
    UD_Ifprem,
    UD_Ifprem1,
    UD_Ifptan,
    UD_Ifrndint,
    UD_Ifrstor,
    UD_Ifnsave,
    UD_Ifscale,
    UD_Ifsin,
    UD_Ifsincos,
    UD_Ifsqrt,
    UD_Ifstp,
    UD_Ifstp1,
    UD_Ifstp8,
    UD_Ifstp9,
    UD_Ifst,
    UD_Ifnstcw,
    UD_Ifnstenv,
    UD_Ifnstsw,
    UD_Ifsub,
    UD_Ifsubp,
    UD_Ifsubr,
    UD_Ifsubrp,
    UD_Iftst,
    UD_Ifucom,
    UD_Ifucomp,
    UD_Ifucompp,
    UD_Ifxam,
    UD_Ifxch,
    UD_Ifxch4,
    UD_Ifxch7,
    UD_Ifxrstor,
    UD_Ifxsave,
    UD_Ifxtract,
    UD_Ifyl2x,
    UD_Ifyl2xp1,
    UD_Ihlt,
    UD_Iidiv,
    UD_Iin,
    UD_Iimul,
    UD_Iinc,
    UD_Iinsb,
    UD_Iinsw,
    UD_Iinsd,
    UD_Iint1,
    UD_Iint3,
    UD_Iint,
    UD_Iinto,
    UD_Iinvd,
    UD_Iinvept,
    UD_Iinvlpg,
    UD_Iinvlpga,
    UD_Iinvvpid,
    UD_Iiretw,
    UD_Iiretd,
    UD_Iiretq,
    UD_Ijo,
    UD_Ijno,
    UD_Ijb,
    UD_Ijae,
    UD_Ijz,
    UD_Ijnz,
    UD_Ijbe,
    UD_Ija,
    UD_Ijs,
    UD_Ijns,
    UD_Ijp,
    UD_Ijnp,
    UD_Ijl,
    UD_Ijge,
    UD_Ijle,
    UD_Ijg,
    UD_Ijcxz,
    UD_Ijecxz,
    UD_Ijrcxz,
    UD_Ijmp,
    UD_Ilahf,
    UD_Ilar,
    UD_Ilddqu,
    UD_Ildmxcsr,
    UD_Ilds,
    UD_Ilea,
    UD_Iles,
    UD_Ilfs,
    UD_Ilgs,
    UD_Ilidt,
    UD_Ilss,
    UD_Ileave,
    UD_Ilfence,
    UD_Ilgdt,
    UD_Illdt,
    UD_Ilmsw,
    UD_Ilock,
    UD_Ilodsb,
    UD_Ilodsw,
    UD_Ilodsd,
    UD_Ilodsq,
    UD_Iloopne,
    UD_Iloope,
    UD_Iloop,
    UD_Ilsl,
    UD_Iltr,
    UD_Imaskmovq,
    UD_Imaxpd,
    UD_Imaxps,
    UD_Imaxsd,
    UD_Imaxss,
    UD_Imfence,
    UD_Iminpd,
    UD_Iminps,
    UD_Iminsd,
    UD_Iminss,
    UD_Imonitor,
    UD_Imontmul,
    UD_Imov,
    UD_Imovapd,
    UD_Imovaps,
    UD_Imovd,
    UD_Imovhpd,
    UD_Imovhps,
    UD_Imovlhps,
    UD_Imovlpd,
    UD_Imovlps,
    UD_Imovhlps,
    UD_Imovmskpd,
    UD_Imovmskps,
    UD_Imovntdq,
    UD_Imovnti,
    UD_Imovntpd,
    UD_Imovntps,
    UD_Imovntq,
    UD_Imovq,
    UD_Imovsb,
    UD_Imovsw,
    UD_Imovsd,
    UD_Imovsq,
    UD_Imovss,
    UD_Imovsx,
    UD_Imovupd,
    UD_Imovups,
    UD_Imovzx,
    UD_Imul,
    UD_Imulpd,
    UD_Imulps,
    UD_Imulsd,
    UD_Imulss,
    UD_Imwait,
    UD_Ineg,
    UD_Inop,
    UD_Inot,
    UD_Ior,
    UD_Iorpd,
    UD_Iorps,
    UD_Iout,
    UD_Ioutsb,
    UD_Ioutsw,
    UD_Ioutsd,
    UD_Ipacksswb,
    UD_Ipackssdw,
    UD_Ipackuswb,
    UD_Ipaddb,
    UD_Ipaddw,
    UD_Ipaddd,
    UD_Ipaddsb,
    UD_Ipaddsw,
    UD_Ipaddusb,
    UD_Ipaddusw,
    UD_Ipand,
    UD_Ipandn,
    UD_Ipavgb,
    UD_Ipavgw,
    UD_Ipcmpeqb,
    UD_Ipcmpeqw,
    UD_Ipcmpeqd,
    UD_Ipcmpgtb,
    UD_Ipcmpgtw,
    UD_Ipcmpgtd,
    UD_Ipextrb,
    UD_Ipextrd,
    UD_Ipextrq,
    UD_Ipextrw,
    UD_Ipinsrb,
    UD_Ipinsrw,
    UD_Ipinsrd,
    UD_Ipinsrq,
    UD_Ipmaddwd,
    UD_Ipmaxsw,
    UD_Ipmaxub,
    UD_Ipminsw,
    UD_Ipminub,
    UD_Ipmovmskb,
    UD_Ipmulhuw,
    UD_Ipmulhw,
    UD_Ipmullw,
    UD_Ipop,
    UD_Ipopa,
    UD_Ipopad,
    UD_Ipopfw,
    UD_Ipopfd,
    UD_Ipopfq,
    UD_Ipor,
    UD_Iprefetch,
    UD_Iprefetchnta,
    UD_Iprefetcht0,
    UD_Iprefetcht1,
    UD_Iprefetcht2,
    UD_Ipsadbw,
    UD_Ipshufw,
    UD_Ipsllw,
    UD_Ipslld,
    UD_Ipsllq,
    UD_Ipsraw,
    UD_Ipsrad,
    UD_Ipsrlw,
    UD_Ipsrld,
    UD_Ipsrlq,
    UD_Ipsubb,
    UD_Ipsubw,
    UD_Ipsubd,
    UD_Ipsubsb,
    UD_Ipsubsw,
    UD_Ipsubusb,
    UD_Ipsubusw,
    UD_Ipunpckhbw,
    UD_Ipunpckhwd,
    UD_Ipunpckhdq,
    UD_Ipunpcklbw,
    UD_Ipunpcklwd,
    UD_Ipunpckldq,
    UD_Ipi2fw,
    UD_Ipi2fd,
    UD_Ipf2iw,
    UD_Ipf2id,
    UD_Ipfnacc,
    UD_Ipfpnacc,
    UD_Ipfcmpge,
    UD_Ipfmin,
    UD_Ipfrcp,
    UD_Ipfrsqrt,
    UD_Ipfsub,
    UD_Ipfadd,
    UD_Ipfcmpgt,
    UD_Ipfmax,
    UD_Ipfrcpit1,
    UD_Ipfrsqit1,
    UD_Ipfsubr,
    UD_Ipfacc,
    UD_Ipfcmpeq,
    UD_Ipfmul,
    UD_Ipfrcpit2,
    UD_Ipmulhrw,
    UD_Ipswapd,
    UD_Ipavgusb,
    UD_Ipush,
    UD_Ipusha,
    UD_Ipushad,
    UD_Ipushfw,
    UD_Ipushfd,
    UD_Ipushfq,
    UD_Ipxor,
    UD_Ircl,
    UD_Ircr,
    UD_Irol,
    UD_Iror,
    UD_Ircpps,
    UD_Ircpss,
    UD_Irdmsr,
    UD_Irdpmc,
    UD_Irdtsc,
    UD_Irdtscp,
    UD_Irepne,
    UD_Irep,
    UD_Iret,
    UD_Iretf,
    UD_Irsm,
    UD_Irsqrtps,
    UD_Irsqrtss,
    UD_Isahf,
    UD_Isalc,
    UD_Isar,
    UD_Ishl,
    UD_Ishr,
    UD_Isbb,
    UD_Iscasb,
    UD_Iscasw,
    UD_Iscasd,
    UD_Iscasq,
    UD_Iseto,
    UD_Isetno,
    UD_Isetb,
    UD_Isetae,
    UD_Isetz,
    UD_Isetnz,
    UD_Isetbe,
    UD_Iseta,
    UD_Isets,
    UD_Isetns,
    UD_Isetp,
    UD_Isetnp,
    UD_Isetl,
    UD_Isetge,
    UD_Isetle,
    UD_Isetg,
    UD_Isfence,
    UD_Isgdt,
    UD_Ishld,
    UD_Ishrd,
    UD_Ishufpd,
    UD_Ishufps,
    UD_Isidt,
    UD_Isldt,
    UD_Ismsw,
    UD_Isqrtps,
    UD_Isqrtpd,
    UD_Isqrtsd,
    UD_Isqrtss,
    UD_Istc,
    UD_Istd,
    UD_Istgi,
    UD_Isti,
    UD_Iskinit,
    UD_Istmxcsr,
    UD_Istosb,
    UD_Istosw,
    UD_Istosd,
    UD_Istosq,
    UD_Istr,
    UD_Isub,
    UD_Isubpd,
    UD_Isubps,
    UD_Isubsd,
    UD_Isubss,
    UD_Iswapgs,
    UD_Isyscall,
    UD_Isysenter,
    UD_Isysexit,
    UD_Isysret,
    UD_Itest,
    UD_Iucomisd,
    UD_Iucomiss,
    UD_Iud2,
    UD_Iunpckhpd,
    UD_Iunpckhps,
    UD_Iunpcklps,
    UD_Iunpcklpd,
    UD_Iverr,
    UD_Iverw,
    UD_Ivmcall,
    UD_Ivmclear,
    UD_Ivmxon,
    UD_Ivmptrld,
    UD_Ivmptrst,
    UD_Ivmlaunch,
    UD_Ivmresume,
    UD_Ivmxoff,
    UD_Ivmread,
    UD_Ivmwrite,
    UD_Ivmrun,
    UD_Ivmmcall,
    UD_Ivmload,
    UD_Ivmsave,
    UD_Iwait,
    UD_Iwbinvd,
    UD_Iwrmsr,
    UD_Ixadd,
    UD_Ixchg,
    UD_Ixgetbv,
    UD_Ixlatb,
    UD_Ixor,
    UD_Ixorpd,
    UD_Ixorps,
    UD_Ixcryptecb,
    UD_Ixcryptcbc,
    UD_Ixcryptctr,
    UD_Ixcryptcfb,
    UD_Ixcryptofb,
    UD_Ixrstor,
    UD_Ixsave,
    UD_Ixsetbv,
    UD_Ixsha1,
    UD_Ixsha256,
    UD_Ixstore,
    UD_Iaesdec,
    UD_Iaesdeclast,
    UD_Iaesenc,
    UD_Iaesenclast,
    UD_Iaesimc,
    UD_Iaeskeygenassist,
    UD_Ipclmulqdq,
    UD_Igetsec,
    UD_Imovdqa,
    UD_Imaskmovdqu,
    UD_Imovdq2q,
    UD_Imovdqu,
    UD_Imovq2dq,
    UD_Ipaddq,
    UD_Ipsubq,
    UD_Ipmuludq,
    UD_Ipshufhw,
    UD_Ipshuflw,
    UD_Ipshufd,
    UD_Ipslldq,
    UD_Ipsrldq,
    UD_Ipunpckhqdq,
    UD_Ipunpcklqdq,
    UD_Iaddsubpd,
    UD_Iaddsubps,
    UD_Ihaddpd,
    UD_Ihaddps,
    UD_Ihsubpd,
    UD_Ihsubps,
    UD_Imovddup,
    UD_Imovshdup,
    UD_Imovsldup,
    UD_Ipabsb,
    UD_Ipabsw,
    UD_Ipabsd,
    UD_Ipshufb,
    UD_Iphaddw,
    UD_Iphaddd,
    UD_Iphaddsw,
    UD_Ipmaddubsw,
    UD_Iphsubw,
    UD_Iphsubd,
    UD_Iphsubsw,
    UD_Ipsignb,
    UD_Ipsignd,
    UD_Ipsignw,
    UD_Ipmulhrsw,
    UD_Ipalignr,
    UD_Ipblendvb,
    UD_Ipmuldq,
    UD_Ipminsb,
    UD_Ipminsd,
    UD_Ipminuw,
    UD_Ipminud,
    UD_Ipmaxsb,
    UD_Ipmaxsd,
    UD_Ipmaxud,
    UD_Ipmaxuw,
    UD_Ipmulld,
    UD_Iphminposuw,
    UD_Iroundps,
    UD_Iroundpd,
    UD_Iroundss,
    UD_Iroundsd,
    UD_Iblendpd,
    UD_Ipblendw,
    UD_Iblendps,
    UD_Iblendvpd,
    UD_Iblendvps,
    UD_Idpps,
    UD_Idppd,
    UD_Impsadbw,
    UD_Iextractps,
    UD_Iinsertps,
    UD_Imovntdqa,
    UD_Ipackusdw,
    UD_Ipmovsxbw,
    UD_Ipmovsxbd,
    UD_Ipmovsxbq,
    UD_Ipmovsxwd,
    UD_Ipmovsxwq,
    UD_Ipmovsxdq,
    UD_Ipmovzxbw,
    UD_Ipmovzxbd,
    UD_Ipmovzxbq,
    UD_Ipmovzxwd,
    UD_Ipmovzxwq,
    UD_Ipmovzxdq,
    UD_Ipcmpeqq,
    UD_Ipopcnt,
    UD_Iptest,
    UD_Ipcmpestri,
    UD_Ipcmpestrm,
    UD_Ipcmpgtq,
    UD_Ipcmpistri,
    UD_Ipcmpistrm,
    UD_Imovbe,
    UD_Icrc32,
    UD_MAX_MNEMONIC_CODE
} UD_ATTR_PACKED;

extern const char * ud_mnemonics_str[];

#endif /* UD_ITAB_H */

```

`Libudis86/stdint.h`:

```h
/* ISO C9x  7.18  Integer types <stdint.h>
 * Based on ISO/IEC SC22/WG14 9899 Committee draft (SC22 N2794)
 *
 *  THIS SOFTWARE IS NOT COPYRIGHTED
 *
 *  Contributor: Danny Smith <danny_r_smith_2001@yahoo.co.nz>
 *
 *  This source code is offered for use in the public domain. You may
 *  use, modify or distribute it freely.
 *
 *  This code is distributed in the hope that it will be useful but
 *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
 *  DISCLAIMED. This includes but is not limited to warranties of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  Date: 2000-12-02
 */


#ifndef _STDINT_H
#define _STDINT_H
#define __need_wint_t
#define __need_wchar_t
#include <stddef.h>

/* 7.18.1.1  Exact-width integer types */
typedef signed char int8_t;
typedef unsigned char   uint8_t;
typedef short  int16_t;
typedef unsigned short  uint16_t;
typedef int  int32_t;
typedef unsigned   uint32_t;
typedef long long  int64_t;
typedef unsigned long long   uint64_t;

/* 7.18.1.2  Minimum-width integer types */
typedef signed char int_least8_t;
typedef unsigned char   uint_least8_t;
typedef short  int_least16_t;
typedef unsigned short  uint_least16_t;
typedef int  int_least32_t;
typedef unsigned   uint_least32_t;
typedef long long  int_least64_t;
typedef unsigned long long   uint_least64_t;

/*  7.18.1.3  Fastest minimum-width integer types 
 *  Not actually guaranteed to be fastest for all purposes
 *  Here we use the exact-width types for 8 and 16-bit ints. 
 */
typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short  int_fast16_t;
typedef unsigned short  uint_fast16_t;
typedef int  int_fast32_t;
typedef unsigned  int  uint_fast32_t;
typedef long long  int_fast64_t;
typedef unsigned long long   uint_fast64_t;

/* 7.18.1.4  Integer types capable of holding object pointers */

#ifndef _INTPTR_T_DEFINED
#define _INTPTR_T_DEFINED
#ifdef _WIN64
  typedef __int64 intptr_t;
#else
  typedef int intptr_t;
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#define _UINTPTR_T_DEFINED
#ifdef _WIN64
  typedef unsigned __int64 uintptr_t;
#else
  typedef unsigned int uintptr_t;
#endif
#endif

/* 7.18.1.5  Greatest-width integer types */
typedef long long  intmax_t;
typedef unsigned long long uintmax_t;

/* 7.18.2  Limits of specified-width integer types */
#if !defined ( __cplusplus) || defined (__STDC_LIMIT_MACROS)

/* 7.18.2.1  Limits of exact-width integer types */
#define INT8_MIN (-128) 
#define INT16_MIN (-32768)
#define INT32_MIN (-2147483647 - 1)
#define INT64_MIN  (-9223372036854775807LL - 1)

#define INT8_MAX 127
#define INT16_MAX 32767
#define INT32_MAX 2147483647
#define INT64_MAX 9223372036854775807LL

#define UINT8_MAX 0xff /* 255U */
#define UINT16_MAX 0xffff /* 65535U */
#define UINT32_MAX 0xffffffff  /* 4294967295U */
#define UINT64_MAX 0xffffffffffffffffULL /* 18446744073709551615ULL */

/* 7.18.2.2  Limits of minimum-width integer types */
#define INT_LEAST8_MIN INT8_MIN
#define INT_LEAST16_MIN INT16_MIN
#define INT_LEAST32_MIN INT32_MIN
#define INT_LEAST64_MIN INT64_MIN

#define INT_LEAST8_MAX INT8_MAX
#define INT_LEAST16_MAX INT16_MAX
#define INT_LEAST32_MAX INT32_MAX
#define INT_LEAST64_MAX INT64_MAX

#define UINT_LEAST8_MAX UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

/* 7.18.2.3  Limits of fastest minimum-width integer types */
#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT16_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN

#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT16_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX

#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT16_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX

/* 7.18.2.4  Limits of integer types capable of holding
    object pointers */
#ifdef _WIN64
#define INTPTR_MIN INT64_MIN
#define INTPTR_MAX INT64_MAX
#define UINTPTR_MAX UINT64_MAX
#else
#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX
#endif

/* 7.18.2.5  Limits of greatest-width integer types */
#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#define UINTMAX_MAX UINT64_MAX

/* 7.18.3  Limits of other integer types */
#define PTRDIFF_MIN INTPTR_MIN
#define PTRDIFF_MAX INTPTR_MAX

#define SIG_ATOMIC_MIN INTPTR_MIN
#define SIG_ATOMIC_MAX INTPTR_MAX

#define SIZE_MAX UINTPTR_MAX

#ifndef WCHAR_MIN  /* also in wchar.h */ 
#define WCHAR_MIN 0
#define WCHAR_MAX 0xffff /* UINT16_MAX */
#endif

/*
 * wint_t is unsigned short for compatibility with MS runtime
 */
#define WINT_MIN 0
#define WINT_MAX 0xffff /* UINT16_MAX */

#endif /* !defined ( __cplusplus) || defined __STDC_LIMIT_MACROS */


/* 7.18.4  Macros for integer constants */
#if !defined ( __cplusplus) || defined (__STDC_CONSTANT_MACROS)

/* 7.18.4.1  Macros for minimum-width integer constants

    Accoding to Douglas Gwyn <gwyn@arl.mil>:
	"This spec was changed in ISO/IEC 9899:1999 TC1; in ISO/IEC
	9899:1999 as initially published, the expansion was required
	to be an integer constant of precisely matching type, which
	is impossible to accomplish for the shorter types on most
	platforms, because C99 provides no standard way to designate
	an integer constant with width less than that of type int.
	TC1 changed this to require just an integer constant
	*expression* with *promoted* type."
*/

#define INT8_C(val) val
#define UINT8_C(val) val
#define INT16_C(val) val
#define UINT16_C(val) val

#define INT32_C(val) val
#define UINT32_C(val) val##U
#define INT64_C(val) val##LL
#define UINT64_C(val) val##ULL

/* 7.18.4.2  Macros for greatest-width integer constants */
#define INTMAX_C(val)  INT64_C(val)
#define UINTMAX_C(val) UINT64_C(val)

#endif  /* !defined ( __cplusplus) || defined __STDC_CONSTANT_MACROS */

#endif

```

`Libudis86/syn-att.c`:

```c
/* udis86 - libudis86/syn-att.c
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "extern.h"
#include "decode.h"
#include "itab.h"
#include "syn.h"
#include "udint.h"

/* -----------------------------------------------------------------------------
 * opr_cast() - Prints an operand cast.
 * -----------------------------------------------------------------------------
 */
static void 
opr_cast(struct ud* u, struct ud_operand* op)
{
  switch(op->size) {
  case 16 : case 32 :
    ud_asmprintf(u, "*");   break;
  default: break;
  }
}

/* -----------------------------------------------------------------------------
 * gen_operand() - Generates assembly output for each operand.
 * -----------------------------------------------------------------------------
 */
static void 
gen_operand(struct ud* u, struct ud_operand* op)
{
  switch(op->type) {
  case UD_OP_CONST:
    ud_asmprintf(u, "$0x%x", op->lval.udword);
    break;

  case UD_OP_REG:
    ud_asmprintf(u, "%%%s", ud_reg_tab[op->base - UD_R_AL]);
    break;

  case UD_OP_MEM:
    if (u->br_far) {
        opr_cast(u, op);
    }
    if (u->pfx_seg) {
      ud_asmprintf(u, "%%%s:", ud_reg_tab[u->pfx_seg - UD_R_AL]);
    }
    if (op->offset != 0) { 
      ud_syn_print_mem_disp(u, op, 0);
    }
    if (op->base) {
      ud_asmprintf(u, "(%%%s", ud_reg_tab[op->base - UD_R_AL]);
    }
    if (op->index) {
      if (op->base) {
        ud_asmprintf(u, ",");
      } else {
        ud_asmprintf(u, "(");
      }
      ud_asmprintf(u, "%%%s", ud_reg_tab[op->index - UD_R_AL]);
    }
    if (op->scale) {
      ud_asmprintf(u, ",%d", op->scale);
    }
    if (op->base || op->index) {
      ud_asmprintf(u, ")");
    }
    break;

  case UD_OP_IMM:
    ud_asmprintf(u, "$");
    ud_syn_print_imm(u, op);
    break;

  case UD_OP_JIMM:
    ud_syn_print_addr(u, ud_syn_rel_target(u, op));
    break;

  case UD_OP_PTR:
    switch (op->size) {
      case 32:
        ud_asmprintf(u, "$0x%x, $0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off & 0xFFFF);
        break;
      case 48:
        ud_asmprintf(u, "$0x%x, $0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off);
        break;
    }
    break;
      
  default: return;
  }
}

/* =============================================================================
 * translates to AT&T syntax 
 * =============================================================================
 */
extern void 
ud_translate_att(struct ud *u)
{
  int size = 0;
  int star = 0;

  /* check if P_OSO prefix is used */
  if (! P_OSO(u->itab_entry->prefix) && u->pfx_opr) {
  switch (u->dis_mode) {
    case 16: 
      ud_asmprintf(u, "o32 ");
      break;
    case 32:
    case 64:
      ud_asmprintf(u, "o16 ");
      break;
  }
  }

  /* check if P_ASO prefix was used */
  if (! P_ASO(u->itab_entry->prefix) && u->pfx_adr) {
  switch (u->dis_mode) {
    case 16: 
      ud_asmprintf(u, "a32 ");
      break;
    case 32:
      ud_asmprintf(u, "a16 ");
      break;
    case 64:
      ud_asmprintf(u, "a32 ");
      break;
  }
  }

  if (u->pfx_lock)
    ud_asmprintf(u,  "lock ");
  if (u->pfx_rep) {
    ud_asmprintf(u, "rep ");
  } else if (u->pfx_rep) {
    ud_asmprintf(u, "repe ");
  } else if (u->pfx_repne) {
    ud_asmprintf(u, "repne ");
  }

  /* special instructions */
  switch (u->mnemonic) {
  case UD_Iretf: 
    ud_asmprintf(u, "lret "); 
    break;
  case UD_Idb:
    ud_asmprintf(u, ".byte 0x%x", u->operand[0].lval.ubyte);
    return;
  case UD_Ijmp:
  case UD_Icall:
    if (u->br_far) ud_asmprintf(u,  "l");
        if (u->operand[0].type == UD_OP_REG) {
          star = 1;
        }
    ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));
    break;
  case UD_Ibound:
  case UD_Ienter:
    if (u->operand[0].type != UD_NONE)
      gen_operand(u, &u->operand[0]);
    if (u->operand[1].type != UD_NONE) {
      ud_asmprintf(u, ",");
      gen_operand(u, &u->operand[1]);
    }
    return;
  default:
    ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));
  }

  if (size == 8)
  ud_asmprintf(u, "b");
  else if (size == 16)
  ud_asmprintf(u, "w");
  else if (size == 64)
  ud_asmprintf(u, "q");

  if (star) {
    ud_asmprintf(u, " *");
  } else {
    ud_asmprintf(u, " ");
  }

  if (u->operand[2].type != UD_NONE) {
  gen_operand(u, &u->operand[2]);
  ud_asmprintf(u, ", ");
  }

  if (u->operand[1].type != UD_NONE) {
  gen_operand(u, &u->operand[1]);
  ud_asmprintf(u, ", ");
  }

  if (u->operand[0].type != UD_NONE)
  gen_operand(u, &u->operand[0]);
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/syn-intel.c`:

```c
/* udis86 - libudis86/syn-intel.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "extern.h"
#include "decode.h"
#include "itab.h"
#include "syn.h"
#include "udint.h"

/* -----------------------------------------------------------------------------
 * opr_cast() - Prints an operand cast.
 * -----------------------------------------------------------------------------
 */
static void 
opr_cast(struct ud* u, struct ud_operand* op)
{
  if (u->br_far) {
    ud_asmprintf(u, "far "); 
  }
  switch(op->size) {
  case  8: ud_asmprintf(u, "byte " ); break;
  case 16: ud_asmprintf(u, "word " ); break;
  case 32: ud_asmprintf(u, "dword "); break;
  case 64: ud_asmprintf(u, "qword "); break;
  case 80: ud_asmprintf(u, "tword "); break;
  default: break;
  }
}

/* -----------------------------------------------------------------------------
 * gen_operand() - Generates assembly output for each operand.
 * -----------------------------------------------------------------------------
 */
static void gen_operand(struct ud* u, struct ud_operand* op, int syn_cast)
{
  switch(op->type) {
  case UD_OP_REG:
    ud_asmprintf(u, "%s", ud_reg_tab[op->base - UD_R_AL]);
    break;

  case UD_OP_MEM:
    if (syn_cast) {
      opr_cast(u, op);
    }
    ud_asmprintf(u, "[");
    if (u->pfx_seg) {
      ud_asmprintf(u, "%s:", ud_reg_tab[u->pfx_seg - UD_R_AL]);
    }
    if (op->base) {
      ud_asmprintf(u, "%s", ud_reg_tab[op->base - UD_R_AL]);
    }
    if (op->index) {
      ud_asmprintf(u, "%s%s", op->base != UD_NONE? "+" : "",
                              ud_reg_tab[op->index - UD_R_AL]);
      if (op->scale) {
        ud_asmprintf(u, "*%d", op->scale);
      }
    }
    if (op->offset != 0) {
      ud_syn_print_mem_disp(u, op, (op->base  != UD_NONE || 
                                    op->index != UD_NONE) ? 1 : 0);
    }
    ud_asmprintf(u, "]");
    break;
      
  case UD_OP_IMM:
    ud_syn_print_imm(u, op);
    break;


  case UD_OP_JIMM:
    ud_syn_print_addr(u, ud_syn_rel_target(u, op));
    break;

  case UD_OP_PTR:
    switch (op->size) {
      case 32:
        ud_asmprintf(u, "word 0x%x:0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off & 0xFFFF);
        break;
      case 48:
        ud_asmprintf(u, "dword 0x%x:0x%x", op->lval.ptr.seg, 
          op->lval.ptr.off);
        break;
    }
    break;

  case UD_OP_CONST:
    if (syn_cast) opr_cast(u, op);
    ud_asmprintf(u, "%d", op->lval.udword);
    break;

  default: return;
  }
}

/* =============================================================================
 * translates to intel syntax 
 * =============================================================================
 */
extern void
ud_translate_intel(struct ud* u)
{
  /* check if P_OSO prefix is used */
  if (!P_OSO(u->itab_entry->prefix) && u->pfx_opr) {
    switch (u->dis_mode) {
    case 16: ud_asmprintf(u, "o32 "); break;
    case 32:
    case 64: ud_asmprintf(u, "o16 "); break;
    }
  }

  /* check if P_ASO prefix was used */
  if (!P_ASO(u->itab_entry->prefix) && u->pfx_adr) {
    switch (u->dis_mode) {
    case 16: ud_asmprintf(u, "a32 "); break;
    case 32: ud_asmprintf(u, "a16 "); break;
    case 64: ud_asmprintf(u, "a32 "); break;
    }
  }

  if (u->pfx_seg &&
      u->operand[0].type != UD_OP_MEM &&
      u->operand[1].type != UD_OP_MEM ) {
    ud_asmprintf(u, "%s ", ud_reg_tab[u->pfx_seg - UD_R_AL]);
  }

  if (u->pfx_lock) {
    ud_asmprintf(u, "lock ");
  }
  if (u->pfx_rep) {
    ud_asmprintf(u, "rep ");
  } else if (u->pfx_repe) {
    ud_asmprintf(u, "repe ");
  } else if (u->pfx_repne) {
    ud_asmprintf(u, "repne ");
  }

  /* print the instruction mnemonic */
  ud_asmprintf(u, "%s", ud_lookup_mnemonic(u->mnemonic));

  if (u->operand[0].type != UD_NONE) {
    int cast = 0;
    ud_asmprintf(u, " ");
    if (u->operand[0].type == UD_OP_MEM) {
      if (u->operand[1].type == UD_OP_IMM   ||
          u->operand[1].type == UD_OP_CONST ||
          u->operand[1].type == UD_NONE     ||
          (u->operand[0].size != u->operand[1].size && 
           u->operand[1].type != UD_OP_REG)) {
          cast = 1;
      } else if (u->operand[1].type == UD_OP_REG &&
                 u->operand[1].base == UD_R_CL) {
          switch (u->mnemonic) {
          case UD_Ircl:
          case UD_Irol:
          case UD_Iror:
          case UD_Ircr:
          case UD_Ishl:
          case UD_Ishr:
          case UD_Isar:
              cast = 1;
              break;
          default: break;
          }
      }
    }
    gen_operand(u, &u->operand[0], cast);
  }

  if (u->operand[1].type != UD_NONE) {
    int cast = 0;
    ud_asmprintf(u, ", ");
    if (u->operand[1].type == UD_OP_MEM &&
        u->operand[0].size != u->operand[1].size && 
        !ud_opr_is_sreg(&u->operand[0])) {
      cast = 1;
    }
    gen_operand(u, &u->operand[1], cast);
  }

  if (u->operand[2].type != UD_NONE) {
    ud_asmprintf(u, ", ");
    gen_operand(u, &u->operand[2], 0);
  }
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/syn.c`:

```c
/* udis86 - libudis86/syn.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "types.h"
#include "decode.h"
#include "syn.h"
#include "udint.h"

#if defined(_MSC_VER)
#pragma warning(disable:4996)
#endif

/* -----------------------------------------------------------------------------
 * Intel Register Table - Order Matters (types.h)!
 * -----------------------------------------------------------------------------
 */
const char* ud_reg_tab[] = 
{
  "al",   "cl",   "dl",   "bl",
  "ah",   "ch",   "dh",   "bh",
  "spl",  "bpl",    "sil",    "dil",
  "r8b",  "r9b",    "r10b",   "r11b",
  "r12b", "r13b",   "r14b",   "r15b",

  "ax",   "cx",   "dx",   "bx",
  "sp",   "bp",   "si",   "di",
  "r8w",  "r9w",    "r10w",   "r11w",
  "r12w", "r13w"  , "r14w",   "r15w",
  
  "eax",  "ecx",    "edx",    "ebx",
  "esp",  "ebp",    "esi",    "edi",
  "r8d",  "r9d",    "r10d",   "r11d",
  "r12d", "r13d",   "r14d",   "r15d",
  
  "rax",  "rcx",    "rdx",    "rbx",
  "rsp",  "rbp",    "rsi",    "rdi",
  "r8",   "r9",   "r10",    "r11",
  "r12",  "r13",    "r14",    "r15",

  "es",   "cs",   "ss",   "ds",
  "fs",   "gs", 

  "cr0",  "cr1",    "cr2",    "cr3",
  "cr4",  "cr5",    "cr6",    "cr7",
  "cr8",  "cr9",    "cr10",   "cr11",
  "cr12", "cr13",   "cr14",   "cr15",
  
  "dr0",  "dr1",    "dr2",    "dr3",
  "dr4",  "dr5",    "dr6",    "dr7",
  "dr8",  "dr9",    "dr10",   "dr11",
  "dr12", "dr13",   "dr14",   "dr15",

  "mm0",  "mm1",    "mm2",    "mm3",
  "mm4",  "mm5",    "mm6",    "mm7",

  "st0",  "st1",    "st2",    "st3",
  "st4",  "st5",    "st6",    "st7", 

  "xmm0", "xmm1",   "xmm2",   "xmm3",
  "xmm4", "xmm5",   "xmm6",   "xmm7",
  "xmm8", "xmm9",   "xmm10",  "xmm11",
  "xmm12",  "xmm13",  "xmm14",  "xmm15",

  "rip"
};


uint64_t
ud_syn_rel_target(struct ud *u, struct ud_operand *opr)
{
  const uint64_t trunc_mask = 0xffffffffffffffffull >> (64 - u->opr_mode);
  switch (opr->size) {
  case 8 : return (u->pc + opr->lval.sbyte)  & trunc_mask;
  case 16: return (u->pc + opr->lval.sword)  & trunc_mask;
  case 32: return (u->pc + opr->lval.sdword) & trunc_mask;
  default: UD_ASSERT(!"invalid relative offset size.");
    return 0ull;
  }
}


/*
 * asmprintf
 *    Printf style function for printing translated assembly
 *    output. Returns the number of characters written and
 *    moves the buffer pointer forward. On an overflow,
 *    returns a negative number and truncates the output.
 */
int
ud_asmprintf(struct ud *u, const char *fmt, ...)
{
  int ret;
  int avail;
  va_list ap;
  va_start(ap, fmt);
  avail = (int)(u->asm_buf_size - u->asm_buf_fill - 1) /* nullchar */;
  ret = vsnprintf((char*) u->asm_buf + u->asm_buf_fill, avail, fmt, ap);
  if (ret < 0 || ret > avail) {
      u->asm_buf_fill = u->asm_buf_size - 1;
  } else {
      u->asm_buf_fill += ret;
  }
  va_end(ap);
  return ret;
}


void
ud_syn_print_addr(struct ud *u, uint64_t addr)
{
  const char *name = NULL;
  if (u->sym_resolver) {
    int64_t offset = 0;
    name = u->sym_resolver(u, addr, &offset);
    if (name) {
      if (offset) {
        ud_asmprintf(u, "%s%+" FMT64 "d", name, offset);
      } else {
        ud_asmprintf(u, "%s", name);
      }
      return;
    }
  }
  ud_asmprintf(u, "0x%" FMT64 "x", addr);
}


void
ud_syn_print_imm(struct ud* u, const struct ud_operand *op)
{
  uint64_t v;
  if (op->_oprcode == OP_sI && op->size != u->opr_mode) {
    if (op->size == 8) {
      v = (int64_t)op->lval.sbyte;
    } else {
      UD_ASSERT(op->size == 32);
      v = (int64_t)op->lval.sdword;
    }
    if (u->opr_mode < 64) {
      v = v & ((1ull << u->opr_mode) - 1ull);
    }
  } else {
    switch (op->size) {
    case 8 : v = op->lval.ubyte;  break;
    case 16: v = op->lval.uword;  break;
    case 32: v = op->lval.udword; break;
    case 64: v = op->lval.uqword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
  }
  ud_asmprintf(u, "0x%" FMT64 "x", v);
}


void
ud_syn_print_mem_disp(struct ud* u, const struct ud_operand *op, int sign)
{
  UD_ASSERT(op->offset != 0);
 if (op->base == UD_NONE && op->index == UD_NONE) {
    uint64_t v;
    UD_ASSERT(op->scale == UD_NONE && op->offset != 8);
    /* unsigned mem-offset */
    switch (op->offset) {
    case 16: v = op->lval.uword;  break;
    case 32: v = op->lval.udword; break;
    case 64: v = op->lval.uqword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
    ud_asmprintf(u, "0x%" FMT64 "x", v);
  } else {
    int64_t v;
    UD_ASSERT(op->offset != 64);
    switch (op->offset) {
    case 8 : v = op->lval.sbyte;  break;
    case 16: v = op->lval.sword;  break;
    case 32: v = op->lval.sdword; break;
    default: UD_ASSERT(!"invalid offset"); v = 0; /* keep cc happy */
    }
    if (v < 0) {
      ud_asmprintf(u, "-0x%" FMT64 "x", -v);
    } else if (v > 0) {
      ud_asmprintf(u, "%s0x%" FMT64 "x", sign? "+" : "", v);
    }
  }
}

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/syn.h`:

```h
/* udis86 - libudis86/syn.h
 *
 * Copyright (c) 2002-2009
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_SYN_H
#define UD_SYN_H

#include "types.h"
#ifndef __UD_STANDALONE__
# include <stdarg.h>
#endif /* __UD_STANDALONE__ */

extern const char* ud_reg_tab[];

uint64_t ud_syn_rel_target(struct ud*, struct ud_operand*);

#ifdef __GNUC__
int ud_asmprintf(struct ud *u, const char *fmt, ...)
    __attribute__ ((format (printf, 2, 3)));
#else
int ud_asmprintf(struct ud *u, const char *fmt, ...);
#endif

void ud_syn_print_addr(struct ud *u, uint64_t addr);
void ud_syn_print_imm(struct ud* u, const struct ud_operand *op);
void ud_syn_print_mem_disp(struct ud* u, const struct ud_operand *, int sign);

#endif /* UD_SYN_H */

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/types.h`:

```h
/* udis86 - libudis86/types.h
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UD_TYPES_H
#define UD_TYPES_H

#ifdef __KERNEL__
  /* -D__KERNEL__ is automatically passed on the command line when
     building something as part of the Linux kernel */
# include <linux/kernel.h>
# include <linux/string.h>
# ifndef __UD_STANDALONE__
#  define __UD_STANDALONE__ 1
#endif
#endif /* __KERNEL__ */

#if defined(_MSC_VER) || defined(__BORLANDC__)
# include "stdint.h"
# include <stdio.h>
# define inline __inline /* MS Visual Studio requires __inline 
                            instead of inline for C code */
#elif !defined(__UD_STANDALONE__)
# include <stdio.h>
# include <inttypes.h>
#endif /* !__UD_STANDALONE__ */

/* gcc specific extensions */
#ifdef __GNUC__
# define UD_ATTR_PACKED __attribute__((packed))
#else
# define UD_ATTR_PACKED
#endif /* UD_ATTR_PACKED */


/* -----------------------------------------------------------------------------
 * All possible "types" of objects in udis86. Order is Important!
 * -----------------------------------------------------------------------------
 */
enum ud_type
{
  UD_NONE,

  /* 8 bit GPRs */
  UD_R_AL,  UD_R_CL,  UD_R_DL,  UD_R_BL,
  UD_R_AH,  UD_R_CH,  UD_R_DH,  UD_R_BH,
  UD_R_SPL, UD_R_BPL, UD_R_SIL, UD_R_DIL,
  UD_R_R8B, UD_R_R9B, UD_R_R10B,  UD_R_R11B,
  UD_R_R12B,  UD_R_R13B,  UD_R_R14B,  UD_R_R15B,

  /* 16 bit GPRs */
  UD_R_AX,  UD_R_CX,  UD_R_DX,  UD_R_BX,
  UD_R_SP,  UD_R_BP,  UD_R_SI,  UD_R_DI,
  UD_R_R8W, UD_R_R9W, UD_R_R10W,  UD_R_R11W,
  UD_R_R12W,  UD_R_R13W,  UD_R_R14W,  UD_R_R15W,
  
  /* 32 bit GPRs */
  UD_R_EAX, UD_R_ECX, UD_R_EDX, UD_R_EBX,
  UD_R_ESP, UD_R_EBP, UD_R_ESI, UD_R_EDI,
  UD_R_R8D, UD_R_R9D, UD_R_R10D,  UD_R_R11D,
  UD_R_R12D,  UD_R_R13D,  UD_R_R14D,  UD_R_R15D,
  
  /* 64 bit GPRs */
  UD_R_RAX, UD_R_RCX, UD_R_RDX, UD_R_RBX,
  UD_R_RSP, UD_R_RBP, UD_R_RSI, UD_R_RDI,
  UD_R_R8,  UD_R_R9,  UD_R_R10, UD_R_R11,
  UD_R_R12, UD_R_R13, UD_R_R14, UD_R_R15,

  /* segment registers */
  UD_R_ES,  UD_R_CS,  UD_R_SS,  UD_R_DS,
  UD_R_FS,  UD_R_GS,  

  /* control registers*/
  UD_R_CR0, UD_R_CR1, UD_R_CR2, UD_R_CR3,
  UD_R_CR4, UD_R_CR5, UD_R_CR6, UD_R_CR7,
  UD_R_CR8, UD_R_CR9, UD_R_CR10,  UD_R_CR11,
  UD_R_CR12,  UD_R_CR13,  UD_R_CR14,  UD_R_CR15,
  
  /* debug registers */
  UD_R_DR0, UD_R_DR1, UD_R_DR2, UD_R_DR3,
  UD_R_DR4, UD_R_DR5, UD_R_DR6, UD_R_DR7,
  UD_R_DR8, UD_R_DR9, UD_R_DR10,  UD_R_DR11,
  UD_R_DR12,  UD_R_DR13,  UD_R_DR14,  UD_R_DR15,

  /* mmx registers */
  UD_R_MM0, UD_R_MM1, UD_R_MM2, UD_R_MM3,
  UD_R_MM4, UD_R_MM5, UD_R_MM6, UD_R_MM7,

  /* x87 registers */
  UD_R_ST0, UD_R_ST1, UD_R_ST2, UD_R_ST3,
  UD_R_ST4, UD_R_ST5, UD_R_ST6, UD_R_ST7, 

  /* extended multimedia registers */
  UD_R_XMM0,  UD_R_XMM1,  UD_R_XMM2,  UD_R_XMM3,
  UD_R_XMM4,  UD_R_XMM5,  UD_R_XMM6,  UD_R_XMM7,
  UD_R_XMM8,  UD_R_XMM9,  UD_R_XMM10, UD_R_XMM11,
  UD_R_XMM12, UD_R_XMM13, UD_R_XMM14, UD_R_XMM15,

  UD_R_RIP,

  /* Operand Types */
  UD_OP_REG,  UD_OP_MEM,  UD_OP_PTR,  UD_OP_IMM,  
  UD_OP_JIMM, UD_OP_CONST
};

#include "itab.h"

union ud_lval {
  int8_t     sbyte;
  uint8_t    ubyte;
  int16_t    sword;
  uint16_t   uword;
  int32_t    sdword;
  uint32_t   udword;
  int64_t    sqword;
  uint64_t   uqword;
  struct {
    uint16_t seg;
    uint32_t off;
  } ptr;
};

/* -----------------------------------------------------------------------------
 * struct ud_operand - Disassembled instruction Operand.
 * -----------------------------------------------------------------------------
 */
struct ud_operand {
  enum ud_type    type;
  uint8_t         size;
  enum ud_type    base;
  enum ud_type    index;
  uint8_t         scale;  
  uint8_t         offset;
  union ud_lval   lval;
  /*
   * internal use only
   */
  uint64_t        _legacy; /* this will be removed in 1.8 */
  uint8_t         _oprcode;
};

/* -----------------------------------------------------------------------------
 * struct ud - The udis86 object.
 * -----------------------------------------------------------------------------
 */
struct ud
{
  /*
   * input buffering
   */
  int       (*inp_hook) (struct ud*);
#ifndef __UD_STANDALONE__
  FILE*     inp_file;
#endif
  const uint8_t* inp_buf;
  size_t    inp_buf_size;
  size_t    inp_buf_index;
  uint8_t   inp_curr;
  size_t    inp_ctr;
  uint8_t   inp_sess[64];
  int       inp_end;

  void      (*translator)(struct ud*);
  uint64_t  insn_offset;
  char      insn_hexcode[64];

  /*
   * Assembly output buffer
   */
  char     *asm_buf;
  //char asm_buf[64];
  size_t    asm_buf_size;
  size_t    asm_buf_fill;
  char      asm_buf_int[128];

  /*
   * Symbol resolver for use in the translation phase.
   */
  const char* (*sym_resolver)(struct ud*, uint64_t addr, int64_t *offset);

  uint8_t   dis_mode;
  uint64_t  pc;
  uint8_t   vendor;
  enum ud_mnemonic_code mnemonic;
  struct ud_operand operand[3];
  uint8_t   error;
  uint8_t   pfx_rex;
  uint8_t   pfx_seg;
  uint8_t   pfx_opr;
  uint8_t   pfx_adr;
  uint8_t   pfx_lock;
  uint8_t   pfx_str;
  uint8_t   pfx_rep;
  uint8_t   pfx_repe;
  uint8_t   pfx_repne;
  uint8_t   opr_mode;
  uint8_t   adr_mode;
  uint8_t   br_far;
  uint8_t   br_near;
  uint8_t   have_modrm;
  uint8_t   modrm;
  uint8_t   primary_opcode;
  void *    user_opaque_data;
  struct ud_itab_entry * itab_entry;
  struct ud_lookup_table_list_entry *le;
};

/* -----------------------------------------------------------------------------
 * Type-definitions
 * -----------------------------------------------------------------------------
 */
typedef enum ud_type          ud_type_t;
typedef enum ud_mnemonic_code ud_mnemonic_code_t;

typedef struct ud             ud_t;
typedef struct ud_operand     ud_operand_t;

#define UD_SYN_INTEL          ud_translate_intel
#define UD_SYN_ATT            ud_translate_att
#define UD_EOI                (-1)
#define UD_INP_CACHE_SZ       32
#define UD_VENDOR_AMD         0
#define UD_VENDOR_INTEL       1
#define UD_VENDOR_ANY         2

#endif

/*
vim: set ts=2 sw=2 expandtab
*/

```

`Libudis86/udint.h`:

```h
/* udis86 - libudis86/udint.h -- definitions for internal use only
 * 
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef _UDINT_H_
#define _UDINT_H_

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */

#if defined(UD_DEBUG) && HAVE_ASSERT_H
# include <assert.h>
# define UD_ASSERT(_x) assert(_x)
#else
# define UD_ASSERT(_x)
#endif /* !HAVE_ASSERT_H */

#if defined(UD_DEBUG)
  #define UDERR(u, msg) \
    do { \
      (u)->error = 1; \
      fprintf(stderr, "decode-error: %s:%d: %s", \
              __FILE__, __LINE__, (msg)); \
    } while (0)
#else
  #define UDERR(u, m) \
    do { \
      (u)->error = 1; \
    } while (0)
#endif /* !LOGERR */

#define UD_RETURN_ON_ERROR(u) \
  do { \
    if ((u)->error != 0) { \
      return (u)->error; \
    } \
  } while (0)

#define UD_RETURN_WITH_ERROR(u, m) \
  do { \
    UDERR(u, m); \
    return (u)->error; \
  } while (0)

#ifndef __UD_STANDALONE__
# define UD_NON_STANDALONE(x) x
#else
# define UD_NON_STANDALONE(x)
#endif

/* printf formatting int64 specifier */
#ifdef FMT64
# undef FMT64
#endif
#if defined(_MSC_VER) || defined(__BORLANDC__)
# define FMT64 "I64"
#else
# if defined(__APPLE__)
#  define FMT64 "ll"
# elif defined(__amd64__) || defined(__x86_64__)
#  define FMT64 "l"
# else 
#  define FMT64 "ll"
# endif /* !x64 */
#endif

#endif /* _UDINT_H_ */

```

`Libudis86/udis86.c`:

```c
/* udis86 - libudis86/udis86.c
 *
 * Copyright (c) 2002-2013 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "udint.h"
#include "extern.h"
#include "decode.h"

#if !defined(__UD_STANDALONE__)
# if HAVE_STRING_H
#  include <string.h>
# endif
#endif /* !__UD_STANDALONE__ */

static void ud_inp_init(struct ud *u);

/* =============================================================================
 * ud_init
 *    Initializes ud_t object.
 * =============================================================================
 */
extern void 
ud_init(struct ud* u)
{
  memset((void*)u, 0, sizeof(struct ud));
  ud_set_mode(u, 16);
  u->mnemonic = UD_Iinvalid;
  ud_set_pc(u, 0);
#ifndef __UD_STANDALONE__
  ud_set_input_file(u, stdin);
#endif /* __UD_STANDALONE__ */

  ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));
}


/* =============================================================================
 * ud_disassemble
 *    Disassembles one instruction and returns the number of 
 *    bytes disassembled. A zero means end of disassembly.
 * =============================================================================
 */
extern unsigned int
ud_disassemble(struct ud* u)
{
  int len;
  if (u->inp_end) {
    return 0;
  }
  if ((len = ud_decode(u)) > 0) {
    if (u->translator != NULL) {
      u->asm_buf[0] = '\0';
      u->translator(u);
    }
  }
  return len;
}


/* =============================================================================
 * ud_set_mode() - Set Disassemly Mode.
 * =============================================================================
 */
extern void 
ud_set_mode(struct ud* u, uint8_t m)
{
  switch(m) {
  case 16:
  case 32:
  case 64: u->dis_mode = m ; return;
  default: u->dis_mode = 16; return;
  }
}

/* =============================================================================
 * ud_set_vendor() - Set vendor.
 * =============================================================================
 */
extern void 
ud_set_vendor(struct ud* u, unsigned v)
{
  switch(v) {
  case UD_VENDOR_INTEL:
    u->vendor = v;
    break;
  case UD_VENDOR_ANY:
    u->vendor = v;
    break;
  default:
    u->vendor = UD_VENDOR_AMD;
  }
}

/* =============================================================================
 * ud_set_pc() - Sets code origin. 
 * =============================================================================
 */
extern void 
ud_set_pc(struct ud* u, uint64_t o)
{
  u->pc = o;
}

/* =============================================================================
 * ud_set_syntax() - Sets the output syntax.
 * =============================================================================
 */
extern void 
ud_set_syntax(struct ud* u, void (*t)(struct ud*))
{
  u->translator = t;
}

/* =============================================================================
 * ud_insn() - returns the disassembled instruction
 * =============================================================================
 */
const char* 
ud_insn_asm(const struct ud* u) 
{
  return u->asm_buf;
}

/* =============================================================================
 * ud_insn_offset() - Returns the offset.
 * =============================================================================
 */
uint64_t
ud_insn_off(const struct ud* u) 
{
  return u->insn_offset;
}


/* =============================================================================
 * ud_insn_hex() - Returns hex form of disassembled instruction.
 * =============================================================================
 */
const char* 
ud_insn_hex(struct ud* u) 
{
  u->insn_hexcode[0] = 0;
  if (!u->error) {
    unsigned int i;
    const unsigned char *src_ptr = ud_insn_ptr(u);
    char* src_hex;
    src_hex = (char*) u->insn_hexcode;
    /* for each byte used to decode instruction */
    for (i = 0; i < ud_insn_len(u) && i < sizeof(u->insn_hexcode) / 2;
         ++i, ++src_ptr) {
      sprintf_s(src_hex, 64, "%02x", *src_ptr & 0xFF);
      src_hex += 2;
    }
  }
  return u->insn_hexcode;
}


/* =============================================================================
 * ud_insn_ptr
 *    Returns a pointer to buffer containing the bytes that were
 *    disassembled.
 * =============================================================================
 */
extern const uint8_t* 
ud_insn_ptr(const struct ud* u) 
{
  return (u->inp_buf == NULL) ? 
            u->inp_sess : u->inp_buf + (u->inp_buf_index - u->inp_ctr);
}


/* =============================================================================
 * ud_insn_len
 *    Returns the count of bytes disassembled.
 * =============================================================================
 */
extern unsigned int 
ud_insn_len(const struct ud* u) 
{
  return (unsigned int)u->inp_ctr;
}


/* =============================================================================
 * ud_insn_get_opr
 *    Return the operand struct representing the nth operand of
 *    the currently disassembled instruction. Returns NULL if
 *    there's no such operand.
 * =============================================================================
 */
const struct ud_operand*
ud_insn_opr(const struct ud *u, unsigned int n)
{
  if (n > 2 || u->operand[n].type == UD_NONE) {
    return NULL; 
  } else {
    return &u->operand[n];
  }
}


/* =============================================================================
 * ud_opr_is_sreg
 *    Returns non-zero if the given operand is of a segment register type.
 * =============================================================================
 */
int
ud_opr_is_sreg(const struct ud_operand *opr)
{
  return opr->type == UD_OP_REG && 
         opr->base >= UD_R_ES   &&
         opr->base <= UD_R_GS;
}


/* =============================================================================
 * ud_opr_is_sreg
 *    Returns non-zero if the given operand is of a general purpose
 *    register type.
 * =============================================================================
 */
int
ud_opr_is_gpr(const struct ud_operand *opr)
{
  return opr->type == UD_OP_REG && 
         opr->base >= UD_R_AL   &&
         opr->base <= UD_R_R15;
}


/* =============================================================================
 * ud_set_user_opaque_data
 * ud_get_user_opaque_data
 *    Get/set user opaqute data pointer
 * =============================================================================
 */
void
ud_set_user_opaque_data(struct ud * u, void* opaque)
{
  u->user_opaque_data = opaque;
}

void*
ud_get_user_opaque_data(const struct ud *u)
{
  return u->user_opaque_data;
}


/* =============================================================================
 * ud_set_asm_buffer
 *    Allow the user to set an assembler output buffer. If `buf` is NULL,
 *    we switch back to the internal buffer.
 * =============================================================================
 */
void
ud_set_asm_buffer(struct ud *u, char *buf, size_t size)
{
  if (buf == NULL) {
    ud_set_asm_buffer(u, u->asm_buf_int, sizeof(u->asm_buf_int));
  } else {
    u->asm_buf = buf;
    u->asm_buf_size = size;
  }
}


/* =============================================================================
 * ud_set_sym_resolver
 *    Set symbol resolver for relative targets used in the translation
 *    phase.
 *
 *    The resolver is a function that takes a uint64_t address and returns a
 *    symbolic name for the that address. The function also takes a second
 *    argument pointing to an integer that the client can optionally set to a
 *    non-zero value for offsetted targets. (symbol+offset) The function may
 *    also return NULL, in which case the translator only prints the target
 *    address.
 *
 *    The function pointer maybe NULL which resets symbol resolution.
 * =============================================================================
 */
void
ud_set_sym_resolver(struct ud *u, const char* (*resolver)(struct ud*, 
                                                          uint64_t addr,
                                                          int64_t *offset))
{
  u->sym_resolver = resolver;
}


/* =============================================================================
 * ud_insn_mnemonic
 *    Return the current instruction mnemonic.
 * =============================================================================
 */
enum ud_mnemonic_code
ud_insn_mnemonic(const struct ud *u)
{
  return u->mnemonic;
}


/* =============================================================================
 * ud_lookup_mnemonic
 *    Looks up mnemonic code in the mnemonic string table.
 *    Returns NULL if the mnemonic code is invalid.
 * =============================================================================
 */
const char*
ud_lookup_mnemonic(enum ud_mnemonic_code c)
{
  if (c < UD_MAX_MNEMONIC_CODE) {
    return ud_mnemonics_str[c];
  } else {
    return NULL;
  }
}


/* 
 * ud_inp_init
 *    Initializes the input system.
 */
static void
ud_inp_init(struct ud *u)
{
  u->inp_hook      = NULL;
  u->inp_buf       = NULL;
  u->inp_buf_size  = 0;
  u->inp_buf_index = 0;
  u->inp_curr      = 0;
  u->inp_ctr       = 0;
  u->inp_end       = 0;
  UD_NON_STANDALONE(u->inp_file = NULL);
}


/* =============================================================================
 * ud_inp_set_hook
 *    Sets input hook.
 * =============================================================================
 */
void 
ud_set_input_hook(register struct ud* u, int (*hook)(struct ud*))
{
  ud_inp_init(u);
  u->inp_hook = hook;
}

/* =============================================================================
 * ud_inp_set_buffer
 *    Set buffer as input.
 * =============================================================================
 */
void 
ud_set_input_buffer(register struct ud* u, const uint8_t* buf, size_t len)
{
  ud_inp_init(u);
  u->inp_buf = buf;
  u->inp_buf_size = len;
  u->inp_buf_index = 0;
}


#ifndef __UD_STANDALONE__
/* =============================================================================
 * ud_input_set_file
 *    Set FILE as input.
 * =============================================================================
 */
static int 
inp_file_hook(struct ud* u)
{
  return fgetc(u->inp_file);
}

void 
ud_set_input_file(register struct ud* u, FILE* f)
{
  ud_inp_init(u);
  u->inp_hook = inp_file_hook;
  u->inp_file = f;
}
#endif /* __UD_STANDALONE__ */


/* =============================================================================
 * ud_input_skip
 *    Skip n input bytes.
 * ============================================================================
 */
void 
ud_input_skip(struct ud* u, size_t n)
{
  if (u->inp_end) {
    return;
  }
  if (u->inp_buf == NULL) {
    while (n--) {
      int c = u->inp_hook(u);
      if (c == UD_EOI) {
        goto eoi;
      }
    }
    return;
  } else {
    if (n > u->inp_buf_size ||
        u->inp_buf_index > u->inp_buf_size - n) {
      u->inp_buf_index = u->inp_buf_size; 
      goto eoi;
    }
    u->inp_buf_index += n; 
    return;
  }
eoi:
  u->inp_end = 1;
  UDERR(u, "cannot skip, eoi received\b");
  return;
}


/* =============================================================================
 * ud_input_end
 *    Returns non-zero on end-of-input.
 * =============================================================================
 */
int
ud_input_end(const struct ud *u)
{
  return u->inp_end;
}

/* vim:set ts=2 sw=2 expandtab */

```

`Libudis86/udis86.h`:

```h
/* udis86 - udis86.h
 *
 * Copyright (c) 2002-2009 Vivek Thampi
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, 
 *       this list of conditions and the following disclaimer in the documentation 
 *       and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef UDIS86_H
#define UDIS86_H

#include "types.h"
#include "extern.h"
#include "itab.h"
#define insn_buffer asm_buf_int

#endif

```

`OutDetailedInformation.cpp`:

```cpp
#include "OutDetailedInformation.hpp"


OutDI::OutDI()
  :_begin_text(""),_end_text("")
{
    
}

OutDI::~OutDI()
{
    
}
void OutDI::print_vmregister_information(long _register)
{
  switch ( _register )
  {
  case T_EAX:
    printf("%s%s" ,_begin_text,"eax" );
    break;
  case T_EBX:
    printf("%s%s" ,_begin_text,"ebx" );
    break;
  case T_ECX:
    printf("%s%s" ,_begin_text,"ecx" );
    break;
  case T_EDX:
    printf("%s%s" ,_begin_text,"edx" );
    break;
  case T_ESP:
    printf("%s%s" ,_begin_text,"esp" );
    break;
  case T_EBP:
    printf("%s%s" ,_begin_text,"ebp" );
    break;
  case T_ESI:
    printf("%s%s" ,_begin_text,"esi" );
    break;
  case T_EDI:
    printf("%s%s" ,_begin_text,"edi" );
    break;
   case T_AX:
    printf("%s%s" ,_begin_text,"ax" );
    break;
  case T_BX:
    printf("%s%s" ,_begin_text,"bx" );
    break;
  case T_CX:
    printf("%s%s" ,_begin_text,"cx" );
    break;
  case T_DX:
    printf("%s%s" ,_begin_text,"dx" );
    break;
  case T_SP:
    printf("%s%s" ,_begin_text,"sp" );
    break;
  case T_BP:
    printf("%s%s" ,_begin_text,"bp" );
    break;
  case T_SI:
    printf("%s%s" ,_begin_text,"si" );
    break;
  case T_DI:
    printf("%s%s" ,_begin_text,"di" );
    break;       
  case T_AL:
    printf("%s%s" ,_begin_text,"al" );
    break;
  case T_AH:
    printf("%s%s" ,_begin_text,"ah" );
    break;
  case T_BL:
    printf("%s%s" ,_begin_text,"bl" );
    break;
  case T_BH:
    printf("%s%s" ,_begin_text,"bh" );
    break;
  case T_CL:
    printf("%s%s" ,_begin_text,"cl" );
    break;
  case T_CH:
    printf("%s%s" ,_begin_text,"ch" );
    break;
  case T_DL:
    printf("%s%s" ,_begin_text,"dl" );
    break;
  case T_DH:
    printf("%s%s" ,_begin_text,"dh" );
    break;                       
  case T_KEY:
    printf("%s%s" ,_begin_text,"key" );
    break;
  case T_RET:
    printf("%s%s" ,_begin_text,"ret" );
    break;
  case T_EFLAG:
    printf("%s%s" ,_begin_text,"eflag" );
    break;
  case T_TMP_REGISTER1:
    printf("%s%s" ,_begin_text,"tmp1" );    
    break;
  case T_TMP_REGISTER2:
    printf("%s%s" ,_begin_text,"tmp2" );
    break;
  case T_TMP_REGISTER3:
    printf("%s%s" ,_begin_text,"tmp3" );    
    break;
  case T_TMP_REGISTER4:
    printf("%s%s" ,_begin_text,"tmp4" );    
    break;
  case T_TMP_REGISTER5:
    printf("%s%s" ,_begin_text,"tmp5" );
    break;
  case T_TMP_REGISTER6:
    printf("%s%s" ,_begin_text,"tmp6" );    
    break;
  case T_TMP_REGISTER7:
    printf("%s%s" ,_begin_text,"tmp7" );    
    break;
  case T_TMP_REGISTER8:
    printf("%s%s" ,_begin_text,"tmp8" );    
    break;
  case T_INVALID:
    printf("%s%s" ,_begin_text,"invalid");
    break;
  default:
    printf("unregister code:%x\n",_register);
    break;    
  }
  printf("%s",_end_text);
}


void OutDI::print_vmregister_information(RegisterStore &store)
{
  for(int i = 0;i<store.register_count;i++)
  {
       print_vmregister_information(store.register_array[i]);
  }
}

void OutDI::set_begin_text(char * _text)
{
  _begin_text = _text;
}

void OutDI::set_end_text(char * _text)
{
  _end_text = _text;
}

```

`OutDetailedInformation.hpp`:

```hpp
#ifndef OUTDETAILEDINFORMATION_HPP_D54GBQU3
#define OUTDETAILEDINFORMATION_HPP_D54GBQU3

#include <iostream>
#include "VOperand.hpp"
#include "PCode.hpp"
using namespace std;

class OutDI{
    public:
    OutDI();
    ~OutDI();

    enum Out_Type { Out_Text = 0, Out_Characters = 1 };
    void print_vmregister_information(long _register);

    void print_vmregister_information(RegisterStore & store);
    //void out_information(RegisterStore & store)
    void set_begin_text(char * _text);
    void set_end_text(char * _text);
    private:
    char * _begin_text;
    char * _end_text;
    int default_out_type;
};


#endif /* end of include guard: OUTDETAILEDINFORMATION_HPP_D54GBQU3 */

```

`PCode.cpp`:

```cpp
/*
 *   Copyright (C) Sun Jun  9 22:03:40 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#include "PCode.hpp"
#include <string.h>
#include "algorithms.hpp"
#define _STDINT_H
#include "Libudis86/udis86.h"

#pragma warning(disable:4244)
#pragma warning(disable:4996)

void PCode::out_log_file(char * file_name)
{
 #ifdef _DEBUG
    v_log = NULL;//fopen(file_name, "wb");
#endif
}

#ifdef _DEBUG
void PCode::out_info(char * _sz)
{
    fprintf(v_log, "%s", _sz);
}
#endif

PCode::PCode()
  : _key_(rand()),
  key(_key_),
  r_pc_size(0),
  is_begin_vmcode(false),
  current_instruction(NULL),
  vmcode_size(0)
#ifdef _DEBUG
  ,v_log(stdout)
#endif
{
  pcode_info.size = DEFAULT_ALLOC_SIZE;
  pcode_info.buf  = new unsigned char [pcode_info.size];
  pcode_info.offset = 0;
  for (int i = 0; i < REG_NUMBER; i++)
  {
    v_reg_context.vr[i].reg_id     = T_INVALID;
    v_reg_context.vr[i].reg_offset = i*4;
  }
}

PCode::PCode(vm_handle table,bool sign)
  : _key_(rand()),key(_key_),r_pc_size(0),is_begin_vmcode(false)
#ifdef _DEBUG
  ,v_log(stdout)
#endif
{
  pcode_info.size = DEFAULT_ALLOC_SIZE;
  pcode_info.buf = new unsigned char [pcode_info.size];
  pcode_info.offset = 0;
  init_handle_table(table);
  init_sign(sign);
  for (int i = 0; i < REG_NUMBER; i++)
  {
    v_reg_context.vr[i].reg_id = T_INVALID;
    v_reg_context.vr[i].reg_offset = i*4;
  }
}

PCode::~PCode()
{
  if (pcode_info.buf)
  {
    delete [] pcode_info.buf;
    pcode_info.buf = NULL;
  }
#ifdef _DEBUG
  if (v_log != stdout)
  {
    fclose(v_log);
  }
#endif
}

#ifdef PROTECT_X64
const unsigned long
#else
const unsigned int
#endif
PCode::get_original_key() 
{
  return _key_;
}

void PCode::set_key( const 
#ifdef PROTECT_X64
                    unsigned long _key
#else
                    unsigned int _key
#endif
                    )
{
  if ( _key_ != key )
  {
    cout << "程序已经开始运行,无法改变Key\r\n" << endl;
    throw ;
    return;
  }
  _key_ = _key;
  key   = _key;
}

#ifdef PROTECT_X64
const unsigned long
#else
const unsigned int
#endif
PCode::get_current_key()
{
  return key;
}

typedef unsigned char  (*b_MyFn)(unsigned char  *);
typedef unsigned short (*w_MyFn)(unsigned short *);
typedef unsigned int   (*d_MyFn)(unsigned int   *);
typedef unsigned long  (*q_MyFn)(unsigned long  *);

#ifdef PROTECT_X64
typedef q_MyFn KeyFn;
#else
typedef d_MyFn KeyFn;
#endif

size_t PCode::get_code_size()
{
  return pcode_info.offset;
}

void PCode::call_encode_pcode_fn(vcode_encryption::MyFn fn,void *data,long *ikey)
{
    using namespace AsmJit;
    AsmJit::Assembler a;

    if (*ikey)
        a.mov(nax,(long)ikey);
    else
        a.mov(nax,(long)&key);

    a.push(nax);
    a.mov(nax,(long)data);
    a.push(nax);
#ifdef PROTECT_X64
    a.call((void*)fn);
    a.add(nsp,16);
    a.ret();
#else
    a.call((void*)fn);
    a.add(nsp,8);
    a.ret();
#endif

    typedef void (*f)();
    f mycall = function_cast<f>(a.make());
    mycall();
}

void PCode::count_vmcode_begin()
{
  vmcode_size = 0;
  is_begin_vmcode = true;
}

size_t PCode::count_vmcode_end()
{
  is_begin_vmcode = false;
  return vmcode_size;
}


void PCode::db(unsigned char b)
{
    if (is_begin_vmcode)
    {
        vmcode_size++;
        return;
    }

    if (!r_pc_size)
    {
        pVMHandleInfo instruction = (pVMHandleInfo)&pcode_info.handle_table;  //这里拦截VM指令
        int count = sizeof(vm_handle)/sizeof(VMHandleInfo);
        while (count != 0)
        {
            if (instruction->handle_i == b) //获取到handle了
            {
                v_log = stdout;
                char *f = "VM_Handle: ";
                char *l = "";
                if      (pcode_info.handle_table.b_read_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_read_stack",l);
                else if (pcode_info.handle_table.w_read_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_read_stack",l);
                else if (pcode_info.handle_table.d_read_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_read_stack",l);

                else if (pcode_info.handle_table.b_write_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_write_stack",l);
                else if (pcode_info.handle_table.w_write_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_write_stack",l);
                else if (pcode_info.handle_table.d_write_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_write_stack",l);

#ifdef PROTECT_X64
                else if (pcode_info.handle_table.q_nand.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_nand",l);
                else if (pcode_info.handle_table.q_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_push_imm",l);
                else if (pcode_info.handle_table.q_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_shl",l);
                else if (pcode_info.handle_table.q_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_push_imm",l);
                else if (pcode_info.handle_table.q_pop_reg.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_pop_reg",l);
                else if (pcode_info.handle_table.q_push_reg.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_push_reg",l);
                else if (pcode_info.handle_table.q_read_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_read_stack",l);
                else if (pcode_info.handle_table.q_write_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_write_stack",l);
                else if (pcode_info.handle_table.q_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_shl",l);
                else if (pcode_info.handle_table.q_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_shr",l);
                else if (pcode_info.handle_table.q_ror.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_ror",l);
                else if (pcode_info.handle_table.q_add.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_add",l);
                else if (pcode_info.handle_table.q_rol.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_rol",l);
                else if (pcode_info.handle_table.q_read_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_read_mem",l);
                else if (pcode_info.handle_table.q_write_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"q_write_mem",l);
                else if (pcode_info.handle_table.d_push_imm_sx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_push_imm_sx",l);
                else if (pcode_info.handle_table.d_push_imm_zx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_push_imm_zx",l);          
#endif
                else if (pcode_info.handle_table.b_push_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"b_push_reg",l);
                }
                else if (pcode_info.handle_table.w_push_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"w_push_reg",l);
                }
                else if (pcode_info.handle_table.d_push_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"d_push_reg",l);
                }
                else if (pcode_info.handle_table.b_pop_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"b_pop_reg",l);
                }
                else if (pcode_info.handle_table.w_pop_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"w_pop_reg",l);
                }
                else if (pcode_info.handle_table.d_pop_reg.handle_i == b)
                {
                    fprintf(v_log,"%s%s%s",f,"d_pop_reg",l);
                }
                else if (pcode_info.handle_table.b_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_push_imm",l);
                else if (pcode_info.handle_table.w_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_push_imm",l);
                else if (pcode_info.handle_table.d_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_push_imm",l);

                else if (pcode_info.handle_table.b_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_shl",l);
                else if (pcode_info.handle_table.w_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_shl",l);
                else if (pcode_info.handle_table.d_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_shl",l);

                else if (pcode_info.handle_table.b_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_shr",l);
                else if (pcode_info.handle_table.w_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_shr",l);
                else if (pcode_info.handle_table.d_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_shr",l);
                else if (pcode_info.handle_table.b_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_push_imm",l);
                else if (pcode_info.handle_table.w_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_push_imm",l);
                else if (pcode_info.handle_table.d_push_imm.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_push_imm",l);
                else if (pcode_info.handle_table.b_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_shl",l);
                else if (pcode_info.handle_table.w_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_shl",l);
                else if (pcode_info.handle_table.d_shl.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_shl",l);

                else if (pcode_info.handle_table.b_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_shr",l);
                else if (pcode_info.handle_table.w_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_shr",l);
                else if (pcode_info.handle_table.d_shr.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_shr",l);

                else if (pcode_info.handle_table.shld.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"shld",l);
                else if (pcode_info.handle_table.shrd.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"shrd",l);
                else if (pcode_info.handle_table.b_nand.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_nand",l);
                else if (pcode_info.handle_table.w_nand.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_nand",l);
                else if (pcode_info.handle_table.d_nand.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_nand",l);
                else if (pcode_info.handle_table.set_pc.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"set_pc",l);
                else if (pcode_info.handle_table.ret.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"ret",l);
                else if (pcode_info.handle_table.in.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"in",l);
                else if (pcode_info.handle_table.rdtsc.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"rdtsc",l);
                else if (pcode_info.handle_table.cpuid.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"cpuid",l);
                else if (pcode_info.handle_table.check_stack.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"check_stack",l);
                else if (pcode_info.handle_table.dispatch.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"dispatch",l);
                else if (pcode_info.handle_table.push_stack_top_base.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"push_vsp",l);
                else if (pcode_info.handle_table.b_read_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_read_mem",l);
                else if (pcode_info.handle_table.w_read_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_read_mem",l);
                else if (pcode_info.handle_table.d_read_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_read_mem",l);
                else if (pcode_info.handle_table.b_write_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_write_mem",l);
                else if (pcode_info.handle_table.w_write_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_write_mem",l);
                else if (pcode_info.handle_table.d_write_mem.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_write_mem",l);


                else if (pcode_info.handle_table.pop_stack_top_base.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"pop_stack_top_base",l);
                else if (pcode_info.handle_table.b_push_imm_sx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_push_imm_sx",l);
                else if (pcode_info.handle_table.w_push_imm_sx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_push_imm_sx",l);
                else if (pcode_info.handle_table.b_push_imm_zx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_push_imm_zx",l);
                else if (pcode_info.handle_table.w_push_imm_zx.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_push_imm_zx",l);
                else if (pcode_info.handle_table.b_add.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_add",l);
                else if (pcode_info.handle_table.w_add.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_add",l);
                else if (pcode_info.handle_table.d_add.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_add",l);

                else if (pcode_info.handle_table.b_rol.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_rol",l);
                else if (pcode_info.handle_table.w_rol.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_rol",l);
                else if (pcode_info.handle_table.d_rol.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_rol",l);

                else if (pcode_info.handle_table.b_ror.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"b_ror",l);
                else if (pcode_info.handle_table.w_ror.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"w_ror",l);
                else if (pcode_info.handle_table.d_ror.handle_i == b)
                    fprintf(v_log,"%s%s%s",f,"d_ror",l);
                else if (pcode_info.handle_table.set_key.handle_i == b )
                    fprintf( v_log,"%s%s%s",f,"set_key",l );
                else if (pcode_info.handle_table.run_stack.handle_i == b)
                    fprintf( v_log,"%s%s%s",f,"run_stack",l);
                else if (pcode_info.handle_table.int3.handle_i == b)
                    fprintf( v_log,"%s%s%s",f,"int3",l);
                else if (pcode_info.handle_table.fstsw.handle_i == b)
                    fprintf( v_log,"%s%s%s",f,"fstsw",l);

                r_pc_size = instruction->type;
                fprintf(v_log,"\n");

                if (r_pc_size == 0)
                {
                    fprintf(v_log,"()\n");
                }

                pVMHandleInfo dispatch_en_key = &pcode_info.handle_table.dispatch;
                for (vector<encryption>::iterator iter = dispatch_en_key->encode_key->begin();
                    iter != dispatch_en_key->encode_key->end();
                    ++iter)
                {
                    iter->en_fn(&key);  // 对Key进行变换

//                     ud_t ud_obj;
//                     ud_init(&ud_obj);
//                     ud_set_mode(&ud_obj, 32);
//                     ud_set_input_buffer(&ud_obj, (uint8_t*)iter->en_fn, 26);
//                     ud_set_syntax(&ud_obj, UD_SYN_INTEL);
//                     printf("\n");
//                     while (ud_disassemble(&ud_obj)) {
//                         printf("%s\n",ud_insn_asm(&ud_obj));
//                     }
                }

                for (list<vcode_encryption>::reverse_iterator iter =
                            dispatch_en_key->encode_pcode->rbegin();
                    iter != dispatch_en_key->encode_pcode->rend();
                    ++iter)
                {
                    call_encode_pcode_fn(iter->fn,&b,&iter->key);
                }

                ////先动态加密KEY////
                for (vector<encryption>::iterator iter2 = instruction->encode_key->begin();
                    iter2 != instruction->encode_key->end();
                    ++iter2) //可能出现q_read_mem错误
                {
                    iter2->en_fn(&key);
                }

                current_instruction = instruction;
                break;
            }
            instruction++; //这个不能放在前面否则会导致读取到q_read_mem
            count--;
        }
    }
    else
    {
#ifdef _DEBUG
        if (strcmp(reg_name,"") == 0)
        {
            fprintf(v_log,"(0%x)\n",b);
        }
        else
        {
            if (b != 0)
            {
                if (b % sizeof(long) == 0)
                {
                    fprintf(v_log,"(%s) index:(%x)\n",reg_name,b);
                }
                else
                {
                    fprintf(v_log,"(%s) index:(%x) offset:(%d)\n",reg_name,b / sizeof(long),b % sizeof(long));
                }
            }
            else
                fprintf(v_log,"(%s) index:(%x)\n",reg_name,b);
            if (b >= REG_NUMBER * 4)
            {
                printf("虚拟寄存器引索超过边界\n");
                __asm int 3;
            }
            strcpy(reg_name,"");
        }
#endif

        for (list<vcode_encryption>::reverse_iterator iter = current_instruction->encode_pcode->rbegin();
            iter != current_instruction->encode_pcode->rend();
            ++iter) //可能出现q_read_mem错误
        {
            call_encode_pcode_fn(iter->fn,&b,&iter->key); //兼容64程序
        }
        current_instruction = NULL;
        r_pc_size = 0; //不是虚拟pcode而是读取数据
    }

    check_pcode_buf();

    if (pcode_info.sign == false)
        pcode_info.buf[pcode_info.size - 1 - pcode_info.offset] = b;
    else
        pcode_info.buf[pcode_info.offset] = b;

    pcode_info.offset++;
}

void PCode::dw(unsigned short w)
{
  if (is_begin_vmcode)
  {   
    vmcode_size+=2;
    return;
  }

  if (r_pc_size)
  {
#ifdef _DEBUG
    fprintf(v_log,"(0%x)\r\n",w);
#endif
     for (list<vcode_encryption>::reverse_iterator iter = current_instruction->encode_pcode->rbegin();
              iter != current_instruction->encode_pcode->rend();
              ++iter) //可能出现q_read_mem错误
     {
       call_encode_pcode_fn(iter->fn,&w,&iter->key);
     }
     current_instruction = NULL;    
    r_pc_size = 0;
  }
  check_pcode_buf();

  if (pcode_info.sign == false)
  {
    unsigned short * buf = (unsigned short *)&pcode_info.buf[pcode_info.size - 2 - pcode_info.offset];
    *buf = w;
  }
  else
  {
    unsigned short * buf = (unsigned short *)&pcode_info.buf[pcode_info.offset];
    *buf = w;
  }
  pcode_info.offset += 2;
}

void PCode::dd(unsigned int d)
{
  if (is_begin_vmcode)
  {  
    vmcode_size += 4;
    return;
  } 

  if (r_pc_size)
  {
     for (list<vcode_encryption>::reverse_iterator iter = current_instruction->encode_pcode->rbegin();
              iter != current_instruction->encode_pcode->rend();
              ++iter) //可能出现q_read_mem错误
     {
       call_encode_pcode_fn(iter->fn,&d,&iter->key);
     }
     current_instruction = NULL;    
    r_pc_size = 0;
  }

  check_pcode_buf();

  unsigned int * buf;
  if (pcode_info.sign == false)
     buf = (unsigned int *)&pcode_info.buf[pcode_info.size - 4 - pcode_info.offset];
  else
     buf = (unsigned int *)&pcode_info.buf[pcode_info.size - 4 - pcode_info.offset];

  *buf = d;
  pcode_info.offset += 4;
}

void PCode::dq(unsigned long long q)
{
  if (is_begin_vmcode)
  {   
    vmcode_size += 8;
    return;
  }

  if (r_pc_size)
  {
#ifdef _DEBUG
    fprintf(v_log,"(0%x)\r\n",q);
#endif
     for (list<vcode_encryption>::reverse_iterator iter = current_instruction->encode_pcode->rbegin();
              iter != current_instruction->encode_pcode->rend();
              ++iter) //可能出现q_read_mem错误
     {
       call_encode_pcode_fn(iter->fn,&q,&iter->key);
     }
     current_instruction = NULL;    
    r_pc_size = 0;
  }
  check_pcode_buf();
  if (pcode_info.sign == false)
  {
    unsigned long long * buf = (unsigned long long *)pcode_info.buf[pcode_info.size - 8 - pcode_info.offset];
    *buf = q;
  }
  else
  {
    unsigned long long * buf = (unsigned long long *)pcode_info.buf[pcode_info.offset];
    *buf = q;
  }
  pcode_info.offset += 8;
}

void PCode::da(long a)  // address 说明是一个地址
{
  if (is_begin_vmcode)
  {   
    vmcode_size += sizeof(long);
    return;
  }

  if (r_pc_size)
  {
#ifdef _DEBUG
    fprintf(v_log,"(0%x)\r\n",a);
#endif
     for (list<vcode_encryption>::reverse_iterator iter = current_instruction->encode_pcode->rbegin();
              iter != current_instruction->encode_pcode->rend(); ++iter) //可能出现q_read_mem错误
     {
       call_encode_pcode_fn(iter->fn,&a,&iter->key);
     }
     current_instruction = NULL;    
    r_pc_size = 0;
  }
  check_pcode_buf();
  if (pcode_info.sign == false)
  {
    unsigned long long * buf = (unsigned long long *)pcode_info.buf[pcode_info.size - sizeof(long) - pcode_info.offset];
    *buf = a;
  }
  else
  {
    unsigned long long * buf = (unsigned long long *)pcode_info.buf[pcode_info.offset];
    *buf = a;
  }
  pcode_info.offset += sizeof(long);  
}

void PCode::init_handle_table(vm_handle table)
{
  memcpy(&pcode_info.handle_table,&table,sizeof(table));
}

void PCode::init_sign(bool b)
{
  pcode_info.sign = b;
}


void PCode::check_pcode_buf()
{
    if (pcode_info.offset + 8 > pcode_info.size)
    {
        if (pcode_info.sign == false)
        {
            unsigned char *newbuf = new unsigned char [pcode_info.size + DEFAULT_ALLOC_SIZE];
            memset(newbuf,0,pcode_info.size + DEFAULT_ALLOC_SIZE);
            memcpy(&newbuf[DEFAULT_ALLOC_SIZE],pcode_info.buf,pcode_info.size);
            pcode_info.size += DEFAULT_ALLOC_SIZE;
            delete [] pcode_info.buf;
            pcode_info.buf = newbuf;
        }
        else
        {
            unsigned char *newbuf = new unsigned char [pcode_info.size + DEFAULT_ALLOC_SIZE];
            memset(newbuf,0,pcode_info.size + DEFAULT_ALLOC_SIZE);
            memcpy(newbuf,pcode_info.buf,pcode_info.size);
            pcode_info.size += DEFAULT_ALLOC_SIZE;
            delete [] pcode_info.buf;
            pcode_info.buf = newbuf;
        }
    }
}


#ifdef _DEBUG  
void PCode::set_register_name(long _register)
{
    switch (_register & T_ALL_REGISTER)
    {
    case T_RAX:
        strcpy(reg_name,"rax");
        break;
    case T_RBX:
        strcpy(reg_name,"rbx");
        break;
    case T_RCX:
        strcpy(reg_name,"rcx");
        break;
    case T_RDX:
        strcpy(reg_name,"rdx");
        break;
    case T_RSP:
        strcpy(reg_name,"rsp");
        break;
    case T_RBP:
        strcpy(reg_name,"rbp");
        break;
    case T_RSI:
        strcpy(reg_name,"rsi");
        break;
    case T_RDI:
        strcpy(reg_name,"rdi");
        break;
    case T_KEY64:
        strcpy(reg_name,"key");
        break;
    case T_EFLAG_:
        strcpy(reg_name,"flag");
        break;
    case T_TMP_R64_1:
        strcpy(reg_name,"tr1");
        break;
    case T_TMP_R64_2:
        strcpy(reg_name,"tr2"); 
        break;
    case T_TMP_R64_3:
        strcpy(reg_name,"tr3"); 
        break;
    case T_TMP_R64_4:
        strcpy(reg_name,"tr4"); 
        break;
    case T_TMP_R64_5:
        strcpy(reg_name,"tr5"); 
        break;
    case T_TMP_R64_6:
        strcpy(reg_name,"tr6"); 
        break;
    case T_TMP_R64_7:
        strcpy(reg_name,"tr7"); 
        break;
    case T_TMP_R64_8:
        strcpy(reg_name,"tr8"); 
        break; 
    case T_JMPINSADDR64:
        strcpy(reg_name,"jcc");
        break;
    case T_NEXTINSADDR64:
        strcpy(reg_name,"pc");
        break;
    default:
        strcpy(reg_name,"invalid" );
        break;
    }

    if (_register & T_E32X)
    {
        if (reg_name[0] == 'r')
            reg_name[0] = 'e';

        if (_register & T_16X)   
        {
            if (_register & T_8H)
            {
                strcat(reg_name,"|8h");
            } 
            else if (_register & T_8L)
            {
                strcat(reg_name,"|8l");
            } else      
                strcat(reg_name,"|16l"); 
        }
        else
        {
            strcat(reg_name,"|32l");
        }
    } 
}
#endif  

void PCode::v_push_register(long _register,bool _disable)
{
#ifdef _DEBUG
  set_register_name(_register);
#endif

  if (_register & T_INVALID)
  {
  //没找到寄存器
    pvm_reg invalid_r = find_invalid_register();
  //#ifdef PROTECT_X64
    if (_register & T_8H)
    {
        db(pcode_info.handle_table.b_push_reg.handle_i);
        db(invalid_r->reg_offset + 1);
        return;
    } else if (_register & T_8L)
    {
      db(pcode_info.handle_table.b_push_reg.handle_i);
    } else if (_register & T_16X)
    {
      db(pcode_info.handle_table.w_push_reg.handle_i);
    } else if (_register & T_E32X)
    {
      db(pcode_info.handle_table.d_push_reg.handle_i);
    } else
    {
#ifdef PROTECT_X64
      db(pcode_info.handle_table.q_push_reg.handle_i);
#else
      db(pcode_info.handle_table.d_push_reg.handle_i);
#endif
    }
    db(invalid_r->reg_offset);
    return;
  }
  
  size_t size = get_code_size();
  for (int i = 0; i < REG_NUMBER; i++)
  {
    long regid = T_ALL_REGISTER & _register;
    long vregid = v_reg_context.vr[i].reg_id;
    if ( regid && ((vregid & T_ALL_REGISTER) == regid) )
    {
      long reg_offset = v_reg_context.vr[i].reg_offset;
      long reg_status = v_reg_context.vr[i].status;
    
      //表示有寄存器类型
      if (_register & T_E32X )
      {
        //表示是32位寄存器
        if (_register & T_16X)
        {
          //表示是16位寄存器
          if (_register & T_8H)
          {
            //8位寄存器高位
            db(pcode_info.handle_table.b_push_reg.handle_i);
            db(reg_offset + 1);
            return ;
          } 
          else if (_register & T_8L)
          {
            //8位寄存器低位
            db(pcode_info.handle_table.b_push_reg.handle_i);
            db(reg_offset);
            return;
          } 
          else 
          {
            //16位寄存器
            db(pcode_info.handle_table.w_push_reg.handle_i);
            db(reg_offset);
            return;
            
          }
        }
        else 
        {
          //32位寄存器
          db(pcode_info.handle_table.d_push_reg.handle_i);
          db(reg_offset);
#ifndef PROTECT_X64
          if (_disable)
          v_reg_context.vr[i].reg_id = T_INVALID;
          return;
#endif
        }
      }
      else
      {
#ifndef PROTECT_X64
#ifdef _DEBUG
        printf("保护32位程序却要push 64位寄存器\n");
        __asm int 3;
#endif
#endif     
#ifdef PROTECT_X64
        //64位寄存器
        if (_register & T_RN) 
        {
          //R8-R15
          db(pcode_info.handle_table.q_push_reg.handle_i);
          db(reg_offset);
        } else
        {
          //RAX-RDI
          db(pcode_info.handle_table.q_push_reg.handle_i);
          db(reg_offset);
        }
        if (_disable)
        v_reg_context.vr[i].reg_id = T_INVALID; //设置为无效
        return;
#endif        
      }
      v_reg_context.vr[i].status = _register & disable;
    }
  }

  if (size == get_code_size( ))
  {
#ifdef _DEBUG
      set_register_name(_register);

      printf("没有找到寄存器%s\n", reg_name);
      __asm int 3;
#endif
  }
}

pvm_reg PCode::find_invalid_register()
{
  int invalid_register_array[REG_NUMBER];
  int invalid_register_count = 0;

  for (int i = 0; i < REG_NUMBER; i++)
  {
    if (v_reg_context.vr[i].reg_id & T_INVALID)
    {
      invalid_register_array[invalid_register_count++] = i;
    }
  }

  if (invalid_register_count)
  {
    int r = invalid_register_array[rand()%invalid_register_count];
    return &v_reg_context.vr[r];
  }

    return NULL;
}

void PCode::v_pop_register(long _register)
{
#ifdef _DEBUG
    set_register_name(_register);
    printf("register : %s\n", reg_name);
#endif  

    for (int i = 0; i < REG_NUMBER; i++)
    {
        long regid = T_ALL_REGISTER & _register;
        long vregid = v_reg_context.vr[i].reg_id;
        if ( regid && ((vregid & T_ALL_REGISTER) == regid) )  //表示有寄存器类型
        {
            long reg_offset = v_reg_context.vr[i].reg_offset;
            
            if (_register & T_E32X)       //表示是32位寄存器
            {
                if (_register & T_16X)    //表示是16位寄存器
                {
                    if (_register & T_8H) //8位寄存器高位
                    {
                        db(pcode_info.handle_table.b_pop_reg.handle_i);
                        db(reg_offset + 1);
                        v_reg_context.vr[i].status = _register & enable;
                        return;
                    }
                    else if (_register & T_8L) //8位寄存器低位
                    {

                        db(pcode_info.handle_table.b_pop_reg.handle_i);
                        db(reg_offset);
                        v_reg_context.vr[i].status = _register & enable;
                        return;
                    }
                    else  //16位寄存器
                    {
                        db(pcode_info.handle_table.w_pop_reg.handle_i);
                        db(reg_offset);
                        v_reg_context.vr[i].status = _register & enable;
                        return;
                    }
                }
                else  //32位寄存器
                {
                    db(pcode_info.handle_table.d_pop_reg.handle_i);
                    db(reg_offset);
                    v_reg_context.vr[i].status = _register & enable;
                    return;
                }
            }
            else
            {
#ifndef PROTECT_X64
#ifdef _DEBUG
                printf("保护32位程序却要pop 64位寄存器\n");
                __asm int 3;
#endif 
#else
                //64位寄存器
                if (_register & T_RN) 
                {
                    //R8-R15
                    db(pcode_info.handle_table.q_pop_reg.handle_i);
                    db(reg_offset);
                    v_reg_context.vr[i].status = _register & enable;
                    return;
                }
                else
                {
                    //RAX-RDI
                    db(pcode_info.handle_table.q_pop_reg.handle_i);
                    db(reg_offset);
                    v_reg_context.vr[i].status = _register & enable;
                    return;
                }
#endif
            }
        }
    }

    //没找到寄存器
    pvm_reg invalid_r = find_invalid_register();

    if (_register & T_8H)
    {
        db(pcode_info.handle_table.b_pop_reg.handle_i);
        db(invalid_r->reg_offset + 1);
        invalid_r->reg_id = _register;
        invalid_r->status = _register & disable;
        return;
    } else if (_register & T_8L)
    {
        db(pcode_info.handle_table.b_pop_reg.handle_i);
    } else if (_register & T_16X)
    {
        db(pcode_info.handle_table.w_pop_reg.handle_i);
    } else if (_register & T_E32X)
    {
        db(pcode_info.handle_table.d_pop_reg.handle_i);
    } else
    {
#ifdef PROTECT_X64
        db(pcode_info.handle_table.q_pop_reg.handle_i);
#else
        db(pcode_info.handle_table.d_pop_reg.handle_i);
#endif
    }
    db(invalid_r->reg_offset);
    invalid_r->reg_id = _register;
    invalid_r->status = _register & disable;
}


```

`PCode.hpp`:

```hpp
/*
 *   Copyrigth (C) Mon May 20 01:02:51 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _PCODE_H_
#define _PCODE_H_

#include <iostream>
#include <list>
#include <vector>
using namespace std;

#include "VMHandle.h"
#include "VOperand.hpp"
//#include "CryptoPP/crc.h"

typedef struct V_HANDLE_CONTEXT_
{
    std::vector <encryption> *encode_key;
    std::list <vcode_encryption> *encode_pcode;
    long type;
    unsigned char handle_i;  // handle_index

}VMHandleInfo,*pVMHandleInfo;

typedef struct _VM_HANDLE_
{
  VMHandleInfo  b_read_stack; 
  VMHandleInfo  w_read_stack; 
  VMHandleInfo  d_read_stack;  
  
  VMHandleInfo  b_write_stack;
  VMHandleInfo  w_write_stack;
  VMHandleInfo  d_write_stack;

  VMHandleInfo  b_push_reg;
  VMHandleInfo  w_push_reg;
  VMHandleInfo  d_push_reg;

  VMHandleInfo  b_pop_reg;
  VMHandleInfo  w_pop_reg;
  VMHandleInfo  d_pop_reg;

  VMHandleInfo  b_push_imm;
  VMHandleInfo  w_push_imm;
  VMHandleInfo  d_push_imm;

  VMHandleInfo  b_shl;
  VMHandleInfo  w_shl;
  VMHandleInfo  d_shl;

  VMHandleInfo  b_shr;
  VMHandleInfo  w_shr;
  VMHandleInfo  d_shr;

  VMHandleInfo  shld;
  VMHandleInfo  shrd;

  VMHandleInfo  b_nand;
  VMHandleInfo  w_nand;
  VMHandleInfo  d_nand;
  
  VMHandleInfo  set_pc;
  VMHandleInfo  ret;
  VMHandleInfo  in;
  VMHandleInfo  rdtsc;
  VMHandleInfo  cpuid;
  VMHandleInfo  check_stack;
  VMHandleInfo  dispatch;
  VMHandleInfo  push_stack_top_base;
  VMHandleInfo  b_read_mem;
  VMHandleInfo  w_read_mem;
  VMHandleInfo  d_read_mem;

  VMHandleInfo  b_write_mem;
  VMHandleInfo  w_write_mem;
  VMHandleInfo  d_write_mem;

  VMHandleInfo pop_stack_top_base;
  VMHandleInfo b_push_imm_sx;
  VMHandleInfo w_push_imm_sx;

  VMHandleInfo b_push_imm_zx;
  VMHandleInfo w_push_imm_zx;

  VMHandleInfo b_add;
  VMHandleInfo w_add;
  VMHandleInfo d_add;

  VMHandleInfo b_rol;
  VMHandleInfo w_rol;
  VMHandleInfo d_rol;

  VMHandleInfo b_ror;
  VMHandleInfo w_ror;
  VMHandleInfo d_ror;

  VMHandleInfo set_key;
  VMHandleInfo run_stack;

  VMHandleInfo fstsw;
  VMHandleInfo int3;

#ifdef PROTECT_X64
  VMHandleInfo d_push_imm_sx;  
  VMHandleInfo d_push_imm_zx;  
  VMHandleInfo  q_read_stack;
  VMHandleInfo  q_write_stack;
  VMHandleInfo  q_push_reg;
  VMHandleInfo  q_pop_reg;
  VMHandleInfo  q_push_imm;
  VMHandleInfo  q_shl;
  VMHandleInfo  q_shr;
  VMHandleInfo  q_nand;
  VMHandleInfo  q_read_mem;
  VMHandleInfo  q_write_mem;
  VMHandleInfo q_rol;
  VMHandleInfo q_ror;
  VMHandleInfo q_add;
#endif
}vm_handle,*pvm_handle;
  
typedef struct _VM_BUF_INFO_
{
  unsigned char * buf;
  unsigned long size;
  unsigned long offset;
  bool sign;  //true表示正 flase表示负
  vm_handle handle_table;
}vm_buf_info,*pvm_buf_info;


typedef struct _V_REG_
{
  long reg_id;
  long reg_offset;
  long status;
}vm_reg,*pvm_reg;


typedef struct _VM_REG_CONTEXT_
{
  vm_reg vr[REG_NUMBER];
  pvm_reg nax;
  pvm_reg nbx;
  pvm_reg ncx;
  pvm_reg ndx;
  pvm_reg nsp;
  pvm_reg nbp;
  pvm_reg ndi;
  pvm_reg nsi;
  pvm_reg eflag;
  pvm_reg r8;
  pvm_reg r9;
  pvm_reg r10;
  pvm_reg r11;
  pvm_reg r12;
  pvm_reg r13;
  pvm_reg r14;
  pvm_reg r15;
}vm_reg_context,*pvm_reg_context;

typedef struct _REGISTER_STORE_
{
  long register_array[REG_NUMBER];
  long register_count;

  _REGISTER_STORE_(  )
  {
    memset( register_array, T_INVALID, sizeof(long)*REG_NUMBER );
    register_count = 0;
  }

  ~_REGISTER_STORE_(  )
  {
  }

  void operator = ( const _REGISTER_STORE_ & rhs )
  {
    register_count = rhs.register_count;
    memcpy( &register_array,&rhs.register_array,sizeof( long )*REG_NUMBER );
  }

  long get_key()
  {
      //CryptoPP::CRC32 crc;

    int _key = 0;
    for (int i = 0; i < register_count; i++)
    {
        //crc.Update((byte*)&register_array[i],4);
    }
    //crc.Final((byte*)&_key);
    return _key;
  }
}RegisterStore,*pRegisterStore;

#define DEFAULT_ALLOC_SIZE 0x150
  
class PCode
{
public:
  PCode();
  PCode(vm_handle table,bool sign);
  virtual ~PCode();

  RegisterStore register_store_in;   //进来的时候寄存器储存顺序
  RegisterStore register_store_out;  //出去的时候寄存器储存顺序
  vm_buf_info pcode_info;
  vm_reg_context v_reg_context;

  void count_vmcode_begin();
  size_t count_vmcode_end();
  
  void check_pcode_buf();

  void db(unsigned char  b);
  void dw(unsigned short w);
  void dd(unsigned int   d);
  void dq(unsigned long long q);
  void da(long a);

  void init_handle_table(vm_handle table);
  void init_sign(bool b);
  char get_rand_reg();
  void v_push_register(long _register,bool _disable = true);
  void v_pop_register(long _register);
  pvm_reg find_invalid_register();
  void call_encode_pcode_fn(vcode_encryption::MyFn fn,void *data,long * ikey);
  size_t get_code_size();
  void out_log_file(char * file_name);

#ifdef PROTECT_X64
  unsigned long _key_;  // = rand(); //PCode的KEY 而不是VM KEY 保存原始KEY
  unsigned long key;    // = _key_;  //这个KEY是变化的
  const unsigned long get_original_key();
  const unsigned long get_current_key();
  void set_key(const unsigned long _key);
#else
  unsigned int _key_;
  unsigned int key;
  const unsigned int get_original_key();
  const unsigned int get_current_key();
  void set_key(const unsigned int _key);
#endif

  pVMHandleInfo current_instruction;

  FILE *v_log;
  char reg_name[256];
  FILE *get_log(){ return v_log; }
  void set_register_name(long _register);
  void out_info(char *_sz);

  void operator = ( const PCode & rhs )
  {
    memcpy( &register_store_in.register_array,
        &rhs.register_store_out.register_array,
        sizeof( long )*REG_NUMBER );
    register_store_in.register_count = rhs.register_store_out.register_count;

    if ( _key_ != key )
    {
      printf("程序已经开始运行,无法改变Key\n");    
      throw;
      return;
    }
    _key_ = rhs.key;
    key = rhs.key;    
  }
  
  long r_pc_size; //虚拟指令要读取pc多少个字节

private:
  size_t vmcode_size;  //计数
  bool is_begin_vmcode;
};

#endif /* _PCODE_H_ */

```

`PE/PEExport.cpp`:

```cpp

#include "PEFile.h"

CPEExport::CPEExport(void)
{
}


CPEExport::~CPEExport(void)
{
}

void CPEExport::operator =(CPEFile& PeFile)
{
	SetInfo(PeFile.GetInfo());
}

PIMAGE_EXPORT_DIRECTORY CPEExport::GetExportTab()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc;
	pExportDesc=(PIMAGE_EXPORT_DIRECTORY)GetDirectoryEntryToData(IMAGE_DIRECTORY_ENTRY_EXPORT);
	if (pExportDesc==NULL)
	{
		return NULL;
	}
	return pExportDesc;
}

int CPEExport::GetFuncCount()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc=GetExportTab();
	if (pExportDesc)
	{
		return pExportDesc->NumberOfFunctions;
	}
	return -1;
}

int CPEExport::GetNameCount()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc=GetExportTab();
	if (pExportDesc)
	{
		return pExportDesc->NumberOfNames;
	}
	return -1;
}

DWORD CPEExport::GetFirstFunc()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc=GetExportTab();
	if (pExportDesc)
	{
		return pExportDesc->AddressOfFunctions;
	}
	return 0;
}

DWORD CPEExport::GetFunc(int nIndex)
{
	if (nIndex<GetFuncCount())
	{
		DWORD dwFirstFunc=GetFirstFunc();
		return dwFirstFunc+nIndex*4;
	}
	return 0;
}

DWORD CPEExport::GetFuncValue(int nIndex)
{
	DWORD dwFuncRva=GetFunc(nIndex);
	if (dwFuncRva)
	{
		return *(DWORD*)RvaToPtr(dwFuncRva);
	}
	return NULL;
}

DWORD CPEExport::GetFirstName()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc=GetExportTab();
	if (pExportDesc)
	{
		return pExportDesc->AddressOfNames;
	}
	return 0;
}

DWORD CPEExport::GetName(int nIndex)
{
	if (nIndex<GetNameCount())
	{
		DWORD dwFirstName=GetFirstName();
		return dwFirstName+nIndex*4;
	}
	return 0;
} 

char* CPEExport::GetNameValue(int nIndex)
{
	DWORD dwNameRva=GetName(nIndex);
	if (dwNameRva)
	{
		DWORD dwNameValueRva=*(DWORD*)RvaToPtr(dwNameRva);
		return (char*)RvaToPtr(dwNameValueRva);
	}
	return NULL;
}

DWORD CPEExport::GetFirstNameOrd()
{
	PIMAGE_EXPORT_DIRECTORY pExportDesc=GetExportTab();
	if (pExportDesc)
	{
		return pExportDesc->AddressOfNameOrdinals;
	}
	return 0;
}

DWORD CPEExport::GetNameOrd(int nIndex)
{
	if (nIndex<GetNameCount())
	{
		DWORD dwFirstNameOrd=GetFirstNameOrd();
		return dwFirstNameOrd+nIndex*2;
	}
	return 0;
}

WORD CPEExport::GetNameOrdValue(int nIndex)
{
	DWORD dwNameOrdRva=GetNameOrd(nIndex);
	if (dwNameOrdRva)
	{
		return *(WORD*)RvaToPtr(dwNameOrdRva);
	}
	return NULL;
}

```

`PE/PEFile.cpp`:

```cpp

#include "PEFile.h"
#pragma warning(disable:4312)

CPEFile::CPEFile()
{
	m_pFile = new MAP_FILE_STRUCT;
	memset(m_pFile,0,sizeof(MAP_FILE_STRUCT));
}

PMAP_FILE_STRUCT CPEFile::GetInfo()
{
	return m_pFile;
}

bool CPEFile::SetInfo(PMAP_FILE_STRUCT pMapFile)
{
	this->m_pFile = pMapFile;
	return true;
}

bool CPEFile::LoadPEFile(char *file_name)
{
	if (m_pFile->ImageBase)
    {
        delete [] m_pFile->ImageBase;
        m_pFile->ImageBase = NULL;
        m_pFile->Size = 0;
    }

	FILE *pFile;
    fopen_s( &pFile, file_name, "rb" );
	if (!pFile)
    {
        return false;
    }

	fseek(pFile,0,SEEK_END);
	int len = ftell(pFile);
	m_pFile->ImageBase = new unsigned char[len];
	rewind(pFile);
	fread(m_pFile->ImageBase,1,len,pFile);
	fclose(pFile);
	m_pFile->Size = len;
	return true;
}

bool CPEFile::LoadPEFile(void *file_buf,unsigned long size)
{
	if (m_pFile->ImageBase)
		{
			delete [] m_pFile->ImageBase;
			m_pFile->ImageBase = NULL;
			m_pFile->Size = 0;
		}
	m_pFile->ImageBase = new unsigned char[size+1];
	memcpy(m_pFile->ImageBase,file_buf,size);
	return true;
}

void CPEFile::Free()
{
	if (m_pFile->ImageBase)
		{
			delete [] m_pFile->ImageBase;
			m_pFile->ImageBase = NULL;
			m_pFile->Size = 0;
		}
	if (m_pFile)
		{
			delete [] m_pFile;
			m_pFile = NULL;
		}
}

void CPEFile::VacantBuf(unsigned long size)
{
	if (m_pFile->ImageBase)
		{
			delete [] m_pFile->ImageBase;
			m_pFile->ImageBase = NULL;
			m_pFile->Size = 0;
		}
	m_pFile->ImageBase = new unsigned char[size];
	memset(m_pFile->ImageBase,0,size);
	m_pFile->Size = size;
}

void *CPEFile::GetImage()  // done!
{
	return m_pFile->ImageBase;
}

PIMAGE_DOS_HEADER CPEFile::GetDosHeader()  // done!
{
	return (PIMAGE_DOS_HEADER)GetImage();
}

PIMAGE_NT_HEADERS32 CPEFile::GetNtHeader()  // done!
{
	PIMAGE_DOS_HEADER pDH = GetDosHeader();
	if (pDH)
		return (PIMAGE_NT_HEADERS32)((DWORD)GetImage()+pDH->e_lfanew);

	return NULL;
}

PIMAGE_OPTIONAL_HEADER32 CPEFile::GetNtOptionalHeader()  // done!
{
	PIMAGE_NT_HEADERS32 pNth=GetNtHeader();
	if (pNth)
		return (PIMAGE_OPTIONAL_HEADER32)&pNth->OptionalHeader;

	return NULL;
}

PIMAGE_DATA_DIRECTORY CPEFile::GetDataDirectory()
{
    PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = GetNtOptionalHeader();
    if (pOptionalHeader)
        return (PIMAGE_DATA_DIRECTORY) pOptionalHeader->DataDirectory;

    return NULL;
}

PIMAGE_FILE_HEADER CPEFile::GetNtFileHeader()  // done!
{
	PIMAGE_NT_HEADERS32 pNth = GetNtHeader();
	if (pNth)
		return (PIMAGE_FILE_HEADER)&pNth->FileHeader;

	return NULL;
}

PIMAGE_DATA_DIRECTORY CPEFile::GetDataDirectory(int index)
{
	if (index>=0 && index<16)
	{
			PIMAGE_DATA_DIRECTORY pDataDir = GetDataDirectory();
			if(pDataDir)
			{
					return &pDataDir[index];
			}
	}
	return NULL;
}

int CPEFile::GetSectionCount()
{
	PIMAGE_FILE_HEADER pNtFileHeader = GetNtFileHeader();
	if (pNtFileHeader)
		{
			return pNtFileHeader->NumberOfSections;
		}
	return 0;
}

PIMAGE_SECTION_HEADER CPEFile::GetFirstSectionHeader()  // done!
{
	PIMAGE_NT_HEADERS32 pNth = GetNtHeader();
	if (pNth)
			return IMAGE_FIRST_SECTION(pNth);

	return NULL;
}

PIMAGE_SECTION_HEADER CPEFile::GetSection(int index)  // done!
{
	int nCount = GetSectionCount();
	if (index >= nCount || index < 0)
		return NULL;

	PIMAGE_SECTION_HEADER pFirstSection = GetFirstSectionHeader();
	for (int i = 0; i < nCount; i++,pFirstSection++ )
		if (i == index)
			return pFirstSection;
	return NULL;
}

bool CPEFile::IsPEFile()  // done!
{
	PIMAGE_DOS_HEADER pDosHeader = GetDosHeader();
	if (pDosHeader->e_magic == IMAGE_DOS_SIGNATURE)
    {
        PIMAGE_NT_HEADERS32 pNtHeader = GetNtHeader();
        if (pNtHeader->Signature == IMAGE_NT_SIGNATURE)
            return true;
    }
	return false;
}

void * CPEFile::GetDirectoryEntryToData(unsigned short DirectoryEntry)
{
	DWORD dwDataStartRVA;
	void * pDirData = NULL;
	PIMAGE_NT_HEADERS32 pNth = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOh = NULL;

	pNth = GetNtHeader();
	if (!pNth)
		return NULL;
	dwDataStartRVA = GetDataDirectory(DirectoryEntry)->VirtualAddress;
	if (!dwDataStartRVA)
		return NULL;

	pDirData = RvaToPtr(dwDataStartRVA);
	if (!pDirData)
		return NULL;
	return pDirData;
}

PIMAGE_SECTION_HEADER
CPEFile::ImageRvaToSection(
    PIMAGE_NT_HEADERS32 NtHeader,
    void *  BaseAddress,
    ULONG Rva)
{
    PIMAGE_SECTION_HEADER Section;
    ULONG Va;
    ULONG Count;
	

    Count = NtHeader->FileHeader.NumberOfSections;
    Section = IMAGE_FIRST_SECTION(NtHeader);

    while (Count--)
    {
        Va = Section->VirtualAddress;
        if ( (Va <= Rva) &&
             (Rva < Va + Section->Misc.VirtualSize) )
            return Section;
        Section++;
    }
    return NULL;
}

void * CPEFile::ImageRvaToVa(PIMAGE_NT_HEADERS32 NtHeader,
					void * BaseAddress,
					ULONG Rva,
					PIMAGE_SECTION_HEADER *SectionHeader)
{
    PIMAGE_SECTION_HEADER Section = NULL;

    if (SectionHeader)
        Section = *SectionHeader;

    if (Section == NULL ||
            Rva <  Section->VirtualAddress ||
            Rva >= Section->VirtualAddress + Section->Misc.VirtualSize)
    {
        Section = ImageRvaToSection (NtHeader, BaseAddress, Rva);
        if (Section == NULL)
            return 0;

        if (SectionHeader)
            *SectionHeader = Section;
    }

    return (void *)((ULONG_PTR)BaseAddress + Rva +
                   Section->PointerToRawData - (ULONG_PTR)Section->VirtualAddress);
}

void * CPEFile::RvaToPtr(DWORD dwRVA)
{
	PIMAGE_NT_HEADERS32 pNth = GetNtHeader();
	return ImageRvaToVa(pNth,m_pFile->ImageBase,dwRVA,NULL);
}

void * CPEFile::VaToPtr(DWORD dwVA)
{
	PIMAGE_NT_HEADERS32 pNth = GetNtHeader();
	DWORD dwRVA = dwVA-GetNtOptionalHeader()->ImageBase;
	return ImageRvaToVa(pNth,m_pFile->ImageBase,dwRVA,NULL);
}

bool CPEFile::SavePEFile(char *save_file_name)
{
	FILE * pFile;
    fopen_s( &pFile, save_file_name, "wb" );
	if (pFile)
    {
        fwrite(m_pFile->ImageBase,m_pFile->Size,1,pFile);
        fclose(pFile);
        return true;
    }
	return false;
}

```

`PE/PEFile.h`:

```h

#pragma once
#include <stdio.h>
#include <windows.h>
#pragma warning(disable:4311)

typedef struct _MAP_FILE_STRUCT
{
	void *ImageBase;
	unsigned long Size;
}MAP_FILE_STRUCT,*PMAP_FILE_STRUCT;

class CPEFile
{
public:
	CPEFile();
	bool LoadPEFile(char * file_name);
	bool LoadPEFile(void * file_buf,unsigned long size);
	bool IsPEFile();
	void Free();
	void VacantBuf(unsigned long size);
	MAP_FILE_STRUCT * m_pFile;
	void * GetImage();
	PIMAGE_DOS_HEADER GetDosHeader();
	PIMAGE_NT_HEADERS32 GetNtHeader();
	PIMAGE_FILE_HEADER GetNtFileHeader();
    PIMAGE_OPTIONAL_HEADER32 GetNtOptionalHeader();
	PIMAGE_DATA_DIRECTORY GetDataDirectory();
	PIMAGE_DATA_DIRECTORY GetDataDirectory(int index);
	int GetSectionCount();
	PIMAGE_SECTION_HEADER GetFirstSectionHeader();
    bool SavePEFile(char *save_file_name);
	PMAP_FILE_STRUCT GetInfo();
	bool SetInfo(PMAP_FILE_STRUCT pMapFile);
	PIMAGE_SECTION_HEADER GetSection(int index);
	void * GetDirectoryEntryToData(unsigned short DirectoryEntry);
	PIMAGE_SECTION_HEADER
    ImageRvaToSection(
    PIMAGE_NT_HEADERS32 NtHeader,
    void * BaseAddress,
    ULONG Rva);
	void * ImageRvaToVa(PIMAGE_NT_HEADERS32 NtHeader,
					void * BaseAddress,
					ULONG Rva,
					PIMAGE_SECTION_HEADER *SectionHeader);
	void * RvaToPtr(DWORD dwRVA);
	void * VaToPtr(DWORD dwVA);
};

class CPESection : public CPEFile
{
public:
    CPESection();
public:
    void operator=(CPEFile &PeFile);
    int RvaToSectionIndex(DWORD dwRva);
    int OffsetToSectionIndex(DWORD dwOffset);
    DWORD GetVRk(int nSectionIndex);
    DWORD RvaToOffset(DWORD dwRva);
    DWORD OffsetToRva(DWORD dwOffset);
    DWORD RvaToVa(DWORD dwRva);
    BOOL AddSection(char *pSectionName, DWORD dwSectionSize, DWORD dwSectionCharacteristics);
    BYTE* GetSectionData(int nIndex, DWORD *rdwSize);
    BOOL WriteSectionData(int nIndex, DWORD dwOffset, BYTE *lpBuffer, DWORD dwSize);
    DWORD VaToOffset(DWORD dwVa);
    DWORD GetSectionVa(int nIndex, DWORD dwOffset);
    DWORD GetSectionPtr(int nIndex, DWORD dwOffset);

    DWORD GetNewSectionBase();              // 创建一个新节并返回其起始VA
    DWORD GetSectionMaxAddress();
    DWORD GetSectionMinAddress();
    BOOL CheckAddressValidity(DWORD Addr);
    DWORD GetCharacteristics(int i);        // 获取该节节头中的Characteristics
};

class CPEImport : public CPEFile
{
public:
    CPEImport(void);
    ~CPEImport(void);
public:
    void operator =(CPEFile& lPeFile);
    PIMAGE_IMPORT_DESCRIPTOR GetFirstImportDesc();
    int GetImportDesCount();
    PIMAGE_IMPORT_DESCRIPTOR GetImportDesc(int index);
    PIMAGE_IMPORT_BY_NAME GetImportFucByName(DWORD RavThunk);
    DWORD GetImportThunk(PIMAGE_IMPORT_DESCRIPTOR pImportDesc);
    BOOL ReLocalImport(DWORD dwRVA);
    PIMAGE_IMPORT_DESCRIPTOR ForceGetImportDesc(int index);
};

class CPEExport : public CPEFile
{
public:
    CPEExport(void);
    ~CPEExport(void);
public:
    void operator =(CPEFile& PeFile);
    PIMAGE_EXPORT_DIRECTORY GetExportTab();
    int GetFuncCount();
    int GetNameCount();
    DWORD GetFirstFunc();
    DWORD GetFunc(int nIndex);
    DWORD GetFuncValue(int nIndex);
    DWORD GetFirstName();
    DWORD GetName(int nIndex);
    char* GetNameValue(int nIndex);
    DWORD GetFirstNameOrd();
    DWORD GetNameOrd(int nIndex);
    WORD GetNameOrdValue(int nIndex);
};

class CPEReloc : public CPEFile
{
public:
    CPEReloc();
    ~CPEReloc();
public:
    void operator=(CPEFile &PeFile);
    DWORD GetBaseReloc();
    void DeleteReloc();
};
```

`PE/PEImport.cpp`:

```cpp

#include "PEFile.h"

CPEImport::CPEImport(void)
{
}


CPEImport::~CPEImport(void)
{
}


void CPEImport::operator =(CPEFile& lPeFile)
{
	SetInfo(lPeFile.GetInfo());
}

//µÃµœÕûžöÊ×žöµŒÈë±í
PIMAGE_IMPORT_DESCRIPTOR CPEImport::GetFirstImportDesc()
{
	PIMAGE_IMPORT_DESCRIPTOR pImportDesc;
	pImportDesc=(PIMAGE_IMPORT_DESCRIPTOR)GetDirectoryEntryToData(IMAGE_DIRECTORY_ENTRY_IMPORT);
	if(!pImportDesc)
		return NULL;	 
	return  pImportDesc;
}
//µÃµœ¹²ÓÐ¶àÉÙžödll
int CPEImport::GetImportDesCount()
{
	int i=0;
	PIMAGE_IMPORT_DESCRIPTOR pTempImport=GetFirstImportDesc();
	while (pTempImport->FirstThunk)
	{
		++i;
		++pTempImport;
	}
	return i;
}

// µÃµœÄ³žödllµŒÈë±í
PIMAGE_IMPORT_DESCRIPTOR CPEImport::GetImportDesc(int index)
{
	int i=GetImportDesCount();
	if (index>=i)
	{
		return NULL;
	}
	PIMAGE_IMPORT_DESCRIPTOR pTempImport=GetFirstImportDesc();
	return &pTempImport[index];
}

// Ç¿ÖÆµÃµœÄ³žödllµŒÈë±í
PIMAGE_IMPORT_DESCRIPTOR CPEImport::ForceGetImportDesc(int index)
{
	PIMAGE_IMPORT_DESCRIPTOR pTempImport=GetFirstImportDesc();
	return &pTempImport[index];
}

//µÃµœÄ³žöAPI º¯ÊýµÄÃû×Ö
PIMAGE_IMPORT_BY_NAME CPEImport::GetImportFucByName(DWORD RavThunk)
{
	PIMAGE_NT_HEADERS32     pNtH=NULL;
	PIMAGE_IMPORT_BY_NAME pApiName=NULL;

	pApiName=(PIMAGE_IMPORT_BY_NAME)RvaToPtr(RavThunk);

	return pApiName;
}

DWORD CPEImport::GetImportThunk(PIMAGE_IMPORT_DESCRIPTOR pImportDesc)
{
	return pImportDesc->OriginalFirstThunk?pImportDesc->OriginalFirstThunk:pImportDesc->FirstThunk;
}


BOOL CPEImport::ReLocalImport(DWORD dwRVA)
{
	int iCount=GetImportDesCount();
	CPEImport  lPeSection;
	lPeSection.SetInfo(GetInfo());

	for (int i=0;i<iCount;i++)
	{
		PIMAGE_IMPORT_DESCRIPTOR  pImport=GetImportDesc(i);
		DWORD dwOrThunk=pImport->OriginalFirstThunk;
		DWORD dwIatThunk=pImport->FirstThunk;

		pImport->OriginalFirstThunk+=(dwRVA-0x2000);
		pImport->Name+=(dwRVA-0x2000);
		pImport->FirstThunk+=(dwRVA-0x2000);

		while(*(DWORD*)RvaToPtr(dwOrThunk)!=0)
		{
			*(DWORD*)RvaToPtr(dwOrThunk)+=(dwRVA-0x2000);
			*(DWORD*)RvaToPtr(dwIatThunk)+=(dwRVA-0x2000);
			dwOrThunk+=sizeof(DWORD);
			dwIatThunk+=sizeof(DWORD);
		}
	}
	return TRUE;
}

```

`PE/PEReloc.cpp`:

```cpp

#include "PEFile.h"

CPEReloc::CPEReloc()
{

}

CPEReloc::~CPEReloc()
{

}

void CPEReloc::operator=(CPEFile &PeFile)
{
   SetInfo(PeFile.GetInfo());
}

DWORD CPEReloc::GetBaseReloc() 
{
   PIMAGE_OPTIONAL_HEADER32 NtOptionHead = GetNtOptionalHeader();
   IMAGE_DATA_DIRECTORY Roc = NtOptionHead->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
       return Roc.VirtualAddress;
}

void CPEReloc::DeleteReloc()
{
    PIMAGE_OPTIONAL_HEADER32 NtOptionHead = GetNtOptionalHeader();
    IMAGE_DATA_DIRECTORY DataReloc = NtOptionHead->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if (DataReloc.VirtualAddress == 0)
        return;
    PIMAGE_BASE_RELOCATION pLoc = (PIMAGE_BASE_RELOCATION)
        VaToPtr(NtOptionHead->ImageBase + DataReloc.VirtualAddress);
    pLoc->VirtualAddress = 0;
    pLoc->SizeOfBlock = 0;
}


```

`PE/PESection.cpp`:

```cpp

#include "PEFile.h"

#define  ZALIGN(x,a)(((x-1)/a+1)*a)

CPESection::CPESection(void)
{
}

void CPESection::operator=(CPEFile& PeFile)
{
	SetInfo(PeFile.GetInfo());
}

int CPESection::RvaToSectionIndex(DWORD dwRva)
{
	int iSectionIndex=-1;
	int iSectionCount=GetSectionCount();
	for (int i=0;i<iSectionCount;i++)
	{
		PIMAGE_SECTION_HEADER pTempSectionHeader=GetSection(i);
		if (pTempSectionHeader->VirtualAddress<=dwRva)
		{
			if (dwRva<=pTempSectionHeader->Misc.VirtualSize+pTempSectionHeader->VirtualAddress)
			{
				iSectionIndex=i;
				break;
			}
		}
	}
	return iSectionIndex;
}

int CPESection::OffsetToSectionIndex(DWORD dwOffset)
{
	int iSectionIndex=0;
	int iSectionCount=GetSectionCount();
    for (int i=0;i<iSectionCount;i++)
	{
		PIMAGE_SECTION_HEADER pTempSectionHeader=GetSection(i);
		if (pTempSectionHeader->PointerToRawData<dwOffset)
		{
			if (dwOffset<=pTempSectionHeader->PointerToRawData+pTempSectionHeader->SizeOfRawData)
			{
				iSectionIndex=i;
				break;
			}
		}
	}
	return iSectionIndex;
}

DWORD CPESection::GetVRk(int nSeciotnIndex)
{
	PIMAGE_SECTION_HEADER pTempSectionHeader=GetSection(nSeciotnIndex);
	DWORD dwVRk=pTempSectionHeader->VirtualAddress-pTempSectionHeader->PointerToRawData;
	return dwVRk;
}

DWORD CPESection::RvaToOffset(DWORD dwRva)
{
	int nSectionIdex=RvaToSectionIndex(dwRva);
	DWORD dwVRk=GetVRk(nSectionIdex);
	return dwRva-dwVRk;
}

DWORD CPESection::OffsetToRva(DWORD dwOffset)
{
	int nSectionIndex=OffsetToSectionIndex(dwOffset);
	DWORD dwVRk=GetVRk(nSectionIndex);
	return dwVRk+dwOffset;
}

DWORD CPESection::VaToOffset(DWORD dwVa)
{
	return RvaToOffset(dwVa-GetNtOptionalHeader()->ImageBase);
}

DWORD CPESection::RvaToVa(DWORD dwRva)
{
	return dwRva+GetNtOptionalHeader()->ImageBase;
}

BOOL CPESection::AddSection(char *pSectionName, DWORD dwSectionSize, DWORD dwSectionCharacteristics)
{
	LPVOID lPointer = NULL;
	PBYTE  pData    = NULL;

	if (!IsPEFile())
	{
		return false;
	}

	PIMAGE_NT_HEADERS32 pNTHdr=GetNtHeader();
	if ((pNTHdr->FileHeader.NumberOfSections+1)*sizeof(IMAGE_SECTION_HEADER) > pNTHdr->OptionalHeader.SizeOfHeaders)
	{
		return FALSE;
	}

	DWORD uCodeDelta=ZALIGN(dwSectionSize,pNTHdr->OptionalHeader.SectionAlignment);
	DWORD uFileDelta=ZALIGN(dwSectionSize,pNTHdr->OptionalHeader.FileAlignment);

	PIMAGE_SECTION_HEADER pNewSec =(PIMAGE_SECTION_HEADER)(pNTHdr+1)+pNTHdr->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pLaseSec=pNewSec-1;

	strcpy_s((char*)pNewSec->Name, IMAGE_SIZEOF_SHORT_NAME, pSectionName);
	pNewSec->VirtualAddress   = pLaseSec->VirtualAddress+ZALIGN(pLaseSec->Misc.VirtualSize, pNTHdr->OptionalHeader.SectionAlignment);
	pNewSec->PointerToRawData = pLaseSec->PointerToRawData+pLaseSec->SizeOfRawData;
	pNewSec->Misc.VirtualSize = dwSectionSize;
	pNewSec->SizeOfRawData    = uFileDelta;
	pNewSec->Characteristics  = dwSectionCharacteristics;

	pNTHdr->FileHeader.NumberOfSections++;
	pNTHdr->OptionalHeader.SizeOfCode  += uFileDelta;
	pNTHdr->OptionalHeader.SizeOfImage += uCodeDelta;

	pNTHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size=0;
	pNTHdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress=0;

	//啪脛卤盲脳脭脡铆脢媒鸥脻
	DWORD dwOldSize = m_pFile->Size;
	m_pFile->Size += uFileDelta;
	
	BYTE*lpNewImageBase=new BYTE[m_pFile->Size];
	memset(lpNewImageBase,0,m_pFile->Size);
	memcpy(lpNewImageBase,m_pFile->ImageBase,dwOldSize);
	delete [] m_pFile->ImageBase;
	m_pFile->ImageBase=lpNewImageBase;

	return TRUE;
}

BYTE* CPESection::GetSectionData(int nIndex, DWORD *rdwSize)
{
	BYTE* lpBuffer=NULL;
	PIMAGE_SECTION_HEADER pSection=GetSection(nIndex);
	if (pSection->SizeOfRawData>0)
	{
		DWORD dwFileOffset=pSection->PointerToRawData;
		*rdwSize=pSection->SizeOfRawData;
		lpBuffer = (BYTE*)GetImage()+dwFileOffset;
    }

	return lpBuffer;
}

BOOL CPESection::WriteSectionData(int nIndex, DWORD dwOffset, BYTE *lpBuffer, DWORD dwSize)
{
	BOOL bIsOK=false;
	DWORD dwSectionSize;
	BYTE *lpMyBuffer = GetSectionData(nIndex,&dwSectionSize);

	if ( lpMyBuffer && dwSectionSize >= (dwSize+dwOffset) )
	{
		lpMyBuffer=lpMyBuffer+dwOffset;
		memcpy(lpMyBuffer,lpBuffer,dwSize);
		bIsOK=TRUE;
	}
	return bIsOK;
}

DWORD CPESection::GetSectionPtr(int nIndex, DWORD dwOffset)
{
	BOOL bIsOK=false;
	DWORD dwSectionSize;
	BYTE* lpMyBuffer=NULL;
	lpMyBuffer=GetSectionData(nIndex,&dwSectionSize);
	if (lpMyBuffer!=NULL&&dwSectionSize>=dwOffset)
	{
		lpMyBuffer=lpMyBuffer+dwOffset;
		return (DWORD)lpMyBuffer;
	}
	return 0;
}


DWORD CPESection::GetSectionVa(int nIndex, DWORD dwOffset)
{
    BOOL bIsOK=false;
    DWORD dwSectionSize;
    BYTE* p=GetSectionData(nIndex,&dwSectionSize);

    if (p && dwSectionSize>=dwOffset)
    {
        p=p+dwOffset;
        DWORD rva = OffsetToRva( (DWORD)p - (DWORD)GetImage());
        return RvaToVa( rva );
    }
    return 0;
}

// 创建一个新节并返回其起始VA
DWORD CPESection::GetNewSectionBase()
{
	PIMAGE_NT_HEADERS32 pNTHdr=GetNtHeader();
	PIMAGE_SECTION_HEADER pNewSec=(PIMAGE_SECTION_HEADER)(pNTHdr+1)+pNTHdr->FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pLastSec=pNewSec-1;
	DWORD newSectionAddr =
        pLastSec->VirtualAddress + ZALIGN(pLastSec->Misc.VirtualSize,pNTHdr->OptionalHeader.SectionAlignment);
	return RvaToVa(newSectionAddr);
}


DWORD CPESection::GetSectionMaxAddress()
{
    int i = GetSectionCount() - 1;
    PIMAGE_SECTION_HEADER psection = GetSection(i);
    //return GetSectionVa(i,psection->SizeOfRawData);
    return RvaToVa(psection->VirtualAddress);
}

DWORD CPESection::GetSectionMinAddress()
{
    PIMAGE_SECTION_HEADER psection = GetSection(0);
    //return GetSectionVa(0,psection->SizeOfRawData);
    return RvaToVa(psection->VirtualAddress);
}

BOOL CPESection::CheckAddressValidity(DWORD Addr)
{
   if (Addr <= GetSectionMaxAddress() && Addr >= GetSectionMinAddress())
   {
       return TRUE;
   }
   return FALSE;
}

// 获取该节节头中的Characteristics
DWORD CPESection::GetCharacteristics(int i)
{
    return GetSection(i)->Characteristics;
}

```

`SeniorVMHandle.cpp`:

```cpp

#include "SeniorVMHandle.hpp"
#include "algorithms.hpp"
#pragma warning(disable:4244)
#pragma warning(disable:4309)

SeniorVMHandle::SeniorVMHandle() : super_protect(false)
{
}

SeniorVMHandle::SeniorVMHandle(PCode *p) : super_protect(false)
{
  pcode = p;
}

SeniorVMHandle::~SeniorVMHandle()
{
}

void SeniorVMHandle::link_pcode(PCode *p)
{
  pcode = p;
}

void SeniorVMHandle::set_protect_grade(bool b )
{
  super_protect = b;
}

long SeniorVMHandle::get_code_size( )
{
  return (long)pcode->get_code_size( );
}

#define HANDLE pcode->pcode_info.handle_table

#define push_esp push_stack_top_base 
#define GET_HANDLE(x) pcode->pcode_info.handle_table.x.handle_i

void* SeniorVMHandle::get_code_buf( )
{
  if ( pcode->pcode_info.sign == false)
     return &pcode->pcode_info.buf
    [pcode->pcode_info.size - pcode->pcode_info.offset];
  else
    return pcode->pcode_info.buf;
}

void SeniorVMHandle::save_vm_context()
{
  int register_count = pcode->register_store_in.register_count;
  for (int i = register_count; i > 0; --i)
  {
    pop(pcode->register_store_in.register_array[i-1]);
  }
}

void SeniorVMHandle::upset_register_array(RegisterStore & r )
{
  int register_count = 0;

  r.register_array[ register_count++ ] = T_NAX;
  r.register_array[ register_count++ ] = T_NBX;
  r.register_array[ register_count++ ] = T_NCX;
  r.register_array[ register_count++ ] = T_NDX;
  // r.register_array[ register_count++ ] = T_NSP;
  r.register_array[ register_count++ ] = T_NBP;
  r.register_array[ register_count++ ] = T_NSI;
  r.register_array[ register_count++ ] = T_NDI;
  r.register_array[ register_count++ ] = T_EFLAG;
  r.register_array[ register_count++ ] = T_KEY;
  r.register_array[ register_count++ ] = T_RET;
#ifdef PROTECT_X64
  r.register_array[ register_count++ ] = T_R8;
  r.register_array[ register_count++ ] = T_R9;
  r.register_array[ register_count++ ] = T_R10;
  r.register_array[ register_count++ ] = T_R11;
  r.register_array[ register_count++ ] = T_R12;
  r.register_array[ register_count++ ] = T_R13;
  r.register_array[ register_count++ ] = T_R14;
  r.register_array[ register_count++ ] = T_R15;
#endif
  r.register_count = register_count;
  RandList<long>( r.register_array, register_count);
}

void SeniorVMHandle::recover_vm_context()
{
  int register_count = pcode->register_store_out.register_count;

  for (int i = 0; i < register_count; ++i)
  {
    if (pcode->register_store_out.register_array[ i ] ==  T_NAX ||
        pcode->register_store_out.register_array[ i ] ==  T_NBX ||
        pcode->register_store_out.register_array[ i ] ==  T_NCX ||
        pcode->register_store_out.register_array[ i ] ==  T_NDX ||
        pcode->register_store_out.register_array[ i ] ==  T_NSP ||
        pcode->register_store_out.register_array[ i ] ==  T_NBP ||
        pcode->register_store_out.register_array[ i ] ==  T_NSI ||
        pcode->register_store_out.register_array[ i ] ==  T_NDI ||
#ifdef PROTECT_X64
        pcode->register_store_out.register_array[ i ] ==  T_NAX | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NBX | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NCX | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NDX | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NSP | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NBP | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NSI | T_RN ||
        pcode->register_store_out.register_array[ i ] ==  T_NDI | T_RN ||
#endif
        pcode->register_store_out.register_array[ i ] ==  T_RET ||
        pcode->register_store_out.register_array[ i ] ==  T_KEY ||
        pcode->register_store_out.register_array[ i ] ==  T_EFLAG)

    push( pcode->register_store_out.register_array[ i ] );
  }
}


void SeniorVMHandle::push(long _register,bool _disable)
{
#ifdef _DEBUG
  char *type = "push(" ;
  switch ( _register )
  {
  case T_NAX:
    printf("%s%s" ,type,"nax" );
    break;
  case T_NBX:
    printf("%s%s" ,type,"nbx" );
    break;
  case T_NCX:
    printf("%s%s" ,type,"ncx" );
    break;
  case T_NDX:
    printf("%s%s" ,type,"ndx" );
    break;
  case T_NSP:
    printf("%s%s" ,type,"nsp" );
    break;
  case T_NBP:
    printf("%s%s" ,type,"nbp" );
    break;
  case T_NSI:
    printf("%s%s" ,type,"nsi" );
    break;
  case T_NDI:
    printf("%s%s" ,type,"ndi" );
    break;
  case T_KEY:
    printf("%s%s" ,type,"key" );
    break;
  case T_RET:
    printf("%s%s" ,type,"ret" );
    break;
  case T_EFLAG:
    printf("%s%s" ,type,"eflag" );
    break;
  case T_TMP_REGISTER1:
    printf("%s%s" ,type,"tmp1" );    
    break;
  case T_TMP_REGISTER2:
    printf("%s%s" ,type,"tmp2" );
    break;
  case T_TMP_REGISTER3:
    printf("%s%s" ,type,"tmp3" );    
    break;
  case T_TMP_REGISTER4:
    printf("%s%s" ,type,"tmp4" );    
    break;
  case T_TMP_REGISTER5:
    printf("%s%s" ,type,"tmp5" );
    break;
  case T_TMP_REGISTER6:
    printf("%s%s" ,type,"tmp6" );    
    break;
  case T_TMP_REGISTER7:
    printf("%s%s" ,type,"tmp7" );    
    break;
  case T_TMP_REGISTER8:
    printf("%s%s" ,type,"tmp8" );    
    break;
  case T_INVALID:
    printf("%s%s",type,"invalid");
  default:
    printf("%sunregister",type);
    break;
  }
  printf( ")\r\n" );
#endif
   pcode->v_push_register(_register,_disable);
}

void SeniorVMHandle::pop(long _register)
{
#ifdef _DEBUG
  char *type = "pop(" ;
  switch ( _register )
  {
  case T_NAX:
    printf("%s%s" ,type,"nax" );
    break;
  case T_NBX:
    printf("%s%s" ,type,"nbx" );
    break;
  case T_NCX:
    printf("%s%s" ,type,"ncx" );
    break;
  case T_NDX:
    printf("%s%s" ,type,"ndx" );
    break;
  case T_NSP:
    printf("%s%s" ,type,"nsp" );
    break;
  case T_NBP:
    printf("%s%s" ,type,"nbp" );
    break;
  case T_NSI:
    printf("%s%s" ,type,"nsi" );
    break;
  case T_NDI:
    printf("%s%s" ,type,"ndi" );
    break;
  case T_KEY:
    printf("%s%s" ,type,"key" );
    break;
  case T_RET:
    printf("%s%s" ,type,"ret" );
    break;
  case T_EFLAG:
    printf("%s%s" ,type,"eflag" );
    break;
  case T_TMP_REGISTER1:
    printf("%s%s" ,type,"tmp1" );    
    break;
  case T_TMP_REGISTER2:
    printf("%s%s" ,type,"tmp2" );
    break;
  case T_TMP_REGISTER3:
    printf("%s%s" ,type,"tmp3" );    
    break;
  case T_TMP_REGISTER4:
    printf("%s%s" ,type,"tmp4" );    
    break;
  case T_TMP_REGISTER5:
    printf("%s%s" ,type,"tmp5" );
    break;
  case T_TMP_REGISTER6:
    printf("%s%s" ,type,"tmp6" );    
    break;
  case T_TMP_REGISTER7:
    printf("%s%s" ,type,"tmp7" );    
    break;
  case T_TMP_REGISTER8:
    printf("%s%s" ,type,"tmp8" );    
    break;
  case T_INVALID:
    printf("%s%s" ,type,"invalid");
    break;
  default:
    printf("unregister code:%x\r\n",_register);
    break;    
  }
  printf( ")\r\n" );
#endif  
  pcode->v_pop_register(_register);
}

void SeniorVMHandle::b_not(long _register,bool is_data)
{
  if (is_data)
  {
    b_push_imm( _register );
    b_copy_stack();
    db( GET_HANDLE( b_nand ) );
  }
  if (_register == 0)
  {
    db(HANDLE.b_nand.handle_i);
    return;
  }  
  push(_register);
  db(HANDLE.push_stack_top_base.handle_i);
  db(HANDLE.b_read_mem.handle_i);
  db(HANDLE.b_nand.handle_i);
}

void SeniorVMHandle::w_not(long _register,bool is_data)
{
  if (is_data)
  {
    w_push_imm( _register );
    w_copy_stack();
    db( GET_HANDLE( w_nand ) );
    return;
  }
  if (_register == 0)
  {
    db(HANDLE.w_nand.handle_i);
    return;
  }
  push(_register);
  db(HANDLE.push_stack_top_base.handle_i);
  db(HANDLE.w_read_mem.handle_i);
  db(HANDLE.w_nand.handle_i);
}

void SeniorVMHandle::d_not(long _register,bool is_data) //如果第二个参数为true 那第一个参数就是 要Not的立即数
{
  if (is_data)
  {
    d_push_imm(_register);
    d_copy_stack();
    db( GET_HANDLE(d_nand) );
    return;
  }
  if (_register == 0)
  {
    db(HANDLE.d_nand.handle_i);
    return;
  }
/*
  char n = rand()%101;
  if (n <= 10)
  {
    d_not(_register); //a = nand(_r,_r);
    pop(T_INVALID);
    d_not(_register); //b = nand(_r,_r);
    pop(T_INVALID);
    db(HANDLE.d_nand.handle_i); //nand(a,b)
    pop(T_INVALID);
    d_not(_register); //a = nand(_r,_r);
    pop(T_INVALID);
    d_not(_register); //b = nand(_r,_r);
    pop(T_INVALID);
    db(HANDLE.d_nand.handle_i); //nand(a,b)
    pop(T_INVALID);
    db(HANDLE.d_nand.handle_i);
    return;
    }*/
  push(_register,false);
  db(HANDLE.push_stack_top_base.handle_i);
  db(HANDLE.d_read_mem.handle_i);
  //#ifndef PROTECT_X64
  //db(HANDLE.push_stack_top_base.handle_i);
  //db(HANDLE.d_read_mem.handle_i);
  //pop(_register);
  //#endif
  db(HANDLE.d_nand.handle_i);
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_not(long _register,bool is_data)
{
  if (is_data)
  {
    q_push_imm(_register);
    q_copy_stack(  );
    db( GET_HANDLE( q_nand ) );
    return;
  }
  if (_register == 0)
  {
    db(HANDLE.q_nand.handle_i);
    return;
  }
  push(_register,false);
  db(HANDLE.push_stack_top_base.handle_i);
  db(HANDLE.q_read_mem.handle_i);

  //db(HANDLE.push_stack_top_base.handle_i);
  //db(HANDLE.q_read_mem.handle_i);
  //pop(_register);

  db(HANDLE.q_nand.handle_i);
}
#endif

char SeniorVMHandle::v_not( pVOperand o1 )
{
  return v_not_and( o1,o1 );
}

void SeniorVMHandle::b_not_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    b_push_imm( _register2 );
    push( _register1 );
    db( GET_HANDLE( b_nand ) );
    return;
  }
  if (_register1 == 0 || _register2 == 0)
  {
    db(HANDLE.b_nand.handle_i);
    return;
  }
  push(_register2);
  push(_register1);
  db(HANDLE.b_nand.handle_i);
}

void SeniorVMHandle::w_not_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    w_push_imm( _register2 );
    push( _register1 );
    db( GET_HANDLE( w_nand ) );
    return;
  }  
  if (_register1 == 0 || _register2 == 0)
  {
    db(HANDLE.w_nand.handle_i);
    return;
  }
  push(_register2);
  push(_register1);
  db(HANDLE.w_nand.handle_i);
}

void SeniorVMHandle::d_not_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    d_push_imm( _register2 );
    push( _register1 );
    db( GET_HANDLE( d_nand ) );
    return;
  }
  if (_register1 == 0 || _register2 == 0)
  {
    db(HANDLE.d_nand.handle_i);
    return;
  }
  push(_register2,false);
  //  db(HANDLE.push_esp.handle_i);
  //db(HANDLE.d_read_mem.handle_i);
  //pop(_register2);
  
  push(_register1,false);
  //db(HANDLE.push_esp.handle_i);
  //db(HANDLE.d_read_mem.handle_i);
  //pop(_register1);
  db(HANDLE.d_nand.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_not_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    q_push_imm( _register2 );
    push( _register1 );
    db( GET_HANDLE( q_nand ) );
    return;
  }  
  if (_register1 == 0 || _register2 == 0)
  {
    db(HANDLE.q_nand.handle_i);
    return;
  }
  push(_register2,false);
  //db(HANDLE.push_esp.handle_i);
  //db(HANDLE.q_read_mem.handle_i);
  //pop(_register2);
  
  push(_register1,false);
  //db(HANDLE.push_esp.handle_i);
  //db(HANDLE.q_read_mem.handle_i);
  //pop(_register1);
  db(HANDLE.q_nand.handle_i);
}
#endif

char SeniorVMHandle::push_operand( pVOperand o )
{
  if (o == NULL)
  {
    return 0;
  }
  if (o->is_mem(  ))
  {
    r_get_mem( o->_mem.base,o->_mem.index,o->_mem.scale,o->_mem.lval );
    switch (o->_mem.size )
    {
    case 1:
      db( GET_HANDLE( b_read_mem ) );
      return 1;
      break;
    case 2:
      db( GET_HANDLE( w_read_mem ) );
      return 2;
      break;
    case 4:
      db( GET_HANDLE( d_read_mem ) );
      return 4;
      break;
#ifdef PROTECT_X64
    case 8:
        db( GET_HANDLE( q_read_mem ) );
        return 8;
      break;
#endif
    }
  } else if (o->is_reg(  ))
  {
    push( o->_reg.base );
    if (o->_reg.base & T_E32X)
    {
      return 4;
    } else if (o->_reg.base & T_16X)
    {
      return 2;
    } else if ( o->_reg.base & T_8L || o->_reg.base & T_8H)
    {
      return 1;
    } else
      return 8;
      
  } else if (o->is_imm(  ))
  {
    switch( o->_imm.size )
    {
    case 1:
      b_push_imm(o->_imm.value);
      return 1;
      break;
    case 2:
      w_push_imm( o->_imm.value );
      return 2;
      break;
    case 4:
      d_push_imm( o->_imm.value );
      return 4;
      break;
#ifdef PROTECT_X64
    case 8:
      q_push_imm( o->_imm.value );
      return 8;
      break;
#endif
    }
  } else if (o->is_none(  ))
  {
    return 0;
  }
  else {
    cout << "未知操作数\r\n" << endl;
    throw;
    return -1;
  }
  return 0;
}


char SeniorVMHandle::pop_operand( pVOperand o )
{
  if (o == NULL)
  {
    return 0;
  }
  if (o->is_mem(  ))
  {
    r_get_mem( o->_mem.base,o->_mem.index,o->_mem.scale,o->_mem.lval );
    switch (o->_mem.size )
    {
    case 1:
      db( GET_HANDLE( b_write_mem ) );
      return 1;
      break;
    case 2:
      db( GET_HANDLE( w_write_mem ) );
      return 2;
      break;
    case 4:
      db( GET_HANDLE( d_write_mem ) );
      return 4;
      break;
#ifdef PROTECT_X64
    case 8:
      db( GET_HANDLE( q_write_mem ) );
      return 8;
      break;
#endif
    }
  } else if (o->is_reg(  ))
  {
    pop( o->_reg.base );
    if (o->_reg.base & T_E32X)
    {
      return 4;
    } else if (o->_reg.base & T_16X)
    {
      return 2;
    } else if ( o->_reg.base & T_8L || o->_reg.base & T_8H)
    {
      return 1;
    } else
      return 8;
  } else if (o->is_none(  ))
  {
    return 0;
  }
  else {
    cout << "未知操作数\r\n" << endl;
    throw;
    return -1;
  }
  return 0;
}

char SeniorVMHandle::v_not_and( pVOperand  o1,pVOperand o2 )
{
  char s1 = push_operand(o1);
  char s2 = push_operand(o2);
  switch ( s1?s1:s2 )
  {
  case 1:
    db( GET_HANDLE( b_nand ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_nand ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_nand ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_nand ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_nand ) );
      return 8;
#else
      db( GET_HANDLE( d_nand ) );
      return 4;
#endif
    }
  }
  return 0;
}

void SeniorVMHandle::b_and(long _register1,long _register2,bool is_data) //如果is_data为真 那register2为数据 
{
  if (is_data)
  {
    b_not( _register2 , true );
    pop( T_INVALID );
    b_not( _register1 );
    pop( T_INVALID );
    db( GET_HANDLE( b_nand ) );
    return;
  }
  b_not(_register2);
  pop(T_INVALID);
  b_not(_register1);
  pop(T_INVALID);
  db(HANDLE.b_nand.handle_i);
}

void SeniorVMHandle::w_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    w_not( _register2 , true );
    pop( T_INVALID );
    w_not( _register1 );
    pop( T_INVALID );
    db( GET_HANDLE( w_nand ) );
    return;
  }  

  w_not(_register2);
  pop(T_INVALID);
  w_not(_register1);
  pop(T_INVALID);
  db(HANDLE.w_nand.handle_i);
}

void SeniorVMHandle::d_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    d_not( _register2 , true );
    pop( T_INVALID );
    d_not( _register1 );
    pop( T_INVALID );
    db( GET_HANDLE( d_nand ) );
    return;
  }    
  d_not(_register2);
  pop(T_INVALID);
  d_not(_register1);
  pop(T_INVALID);
  db(HANDLE.d_nand.handle_i);
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_and(long _register1,long _register2,bool is_data)
{
  if (is_data)
  {
    q_not( _register2 , true );
    pop( T_INVALID );
    q_not( _register1 );
    pop( T_INVALID );
    db( GET_HANDLE( q_nand ) );
    return;
  }    
  q_not(_register2);
  pop(T_INVALID);
  q_not(_register1);
  pop(T_INVALID);
  db(HANDLE.q_nand.handle_i);
}
#endif

char SeniorVMHandle::v_and( pVOperand o1,pVOperand o2 )
{
  char s1 = v_not_and(o1,o1);
  pop( T_INVALID );
  char s2 = v_not_and(o2,o2);
  pop( T_INVALID );
  switch ( s1?s1:s2 )
  {
  case 1:
    db( GET_HANDLE( b_nand ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_nand ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_nand ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_nand ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_nand ) );
      return 8;
#else
      db( GET_HANDLE( d_nand ) );
      return 4;
#endif
    }
  }
  return 0;  
}

void SeniorVMHandle::b_or(long _register1,long _register2,bool is_data)
{
  b_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  b_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.b_nand.handle_i);
}

void SeniorVMHandle::w_or(long _register1,long _register2,bool is_data)
{
  w_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  w_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.w_nand.handle_i);
}

void SeniorVMHandle::d_or(long _register1,long _register2,bool is_data)
{
  d_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  d_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.d_nand.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_or(long _register1,long _register2,bool is_data)
{
  q_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  q_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.q_nand.handle_i);
}
#endif

char SeniorVMHandle::v_or( pVOperand o1,pVOperand o2 )
{
  char s1 = v_not_and( o1,o2 );
  pop( T_INVALID );
  char s2 = v_not_and( o1,o2 );
  pop( T_INVALID );
  switch ( s1?s1:s2 )
  {
  case 1:
    db( GET_HANDLE( b_nand ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_nand ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_nand ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_nand ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_nand ) );
      return 8;
#else
      db( GET_HANDLE( d_nand ) );
      return 4;
#endif
    }
  }
  return 0;  
}

void SeniorVMHandle::b_xor(long _register1,long _register2,bool is_data)
{
  b_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  b_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.b_nand.handle_i);
}

void SeniorVMHandle::w_xor(long _register1,long _register2,bool is_data)
{
  w_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  w_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.w_nand.handle_i);
}

void SeniorVMHandle::d_xor(long _register1,long _register2,bool is_data)
{
  d_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  d_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.d_nand.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_xor(long _register1,long _register2,bool is_data)
{
  q_not_and(_register1,_register2,is_data);
  pop(T_INVALID);
  q_and(_register1,_register2,is_data);
  pop(T_INVALID);
  db(HANDLE.q_nand.handle_i);
}
#endif

char SeniorVMHandle::v_xor( pVOperand o1,pVOperand o2 )
{
  char s1 = v_not_and( o1,o2 );
  pop( T_INVALID );
  char s2 = v_and( o1,o2 );
  pop( T_INVALID );
  switch ( s1?s1:s2 )
  {
  case 1:
    db( GET_HANDLE( b_nand ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_nand ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_nand ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_nand ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_nand ) );
      return 8;
#else
      db( GET_HANDLE( d_nand ) );
      return 4;
#endif
    }
  }
  return 0;    
}



void SeniorVMHandle::pushf()
{
  pcode->v_push_register(T_EFLAG);
}

void SeniorVMHandle::pushad()
{
  push(T_NAX);
  push(T_NCX);
  push(T_NDX);
  push(T_NBX);
  //  push(T_RSP | mode);
  push(T_NBP);
  push(T_NSI);
  push(T_NDI);
#ifdef PROTECT_X64
  push(T_R8);
  push(T_R9);
  push(T_R10);
  push(T_R11);
  push(T_R12);
  push(T_R13);
  push(T_R14);
  push(T_R15);  
#endif
}

void SeniorVMHandle::b_shl(long _register,char n,bool is_data)
{
  if ( is_data )
    b_push_imm( _register );
  else
    push(_register);
  b_push_imm(n);
  db(HANDLE.b_shl.handle_i);
}

void SeniorVMHandle::w_shl(long _register,char n,bool is_data)
{
  if ( is_data )
    w_push_imm( _register );
  else
    push(_register);
  b_push_imm(n);
  db(HANDLE.w_shl.handle_i);
}

void SeniorVMHandle::d_shl(long _register,char n,bool is_data)
{
  if ( is_data )
    d_push_imm( _register );
  else
    push(_register,false);
  b_push_imm(n);
  db(HANDLE.d_shl.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_shl(long _register,char n,bool is_data)
{
  if ( is_data )
    q_push_imm( _register );
  else
    push(_register,false);
  b_push_imm(n);
  db(HANDLE.q_shl.handle_i);
}
#endif

char SeniorVMHandle::v_shl( pVOperand o1,pVOperand o2 )
{
  char s1 = push_operand(o1);
  char s2 = push_operand(o2);
  if ( s2 > 1 )
  {
    cout << "shl第二个操作数不可能大于cl" << endl;
    throw;
  }
  
  switch ( s1 )
  {
  case 1:
    db( GET_HANDLE( b_shl ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_shl ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_shl ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_shl ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_shl ) );
      return 8;
#else
      db( GET_HANDLE( d_shl ) );
      return 4;
#endif
    }
  }
  return 0;      
}

void SeniorVMHandle::b_shr(long _register,char n,bool is_data)
{
  if ( is_data )
    b_push_imm( _register );
  else
    push(_register);
  b_push_imm(n);
  db(HANDLE.b_shr.handle_i);
}

void SeniorVMHandle::w_shr(long _register,char n,bool is_data)
{
  if ( is_data )
    w_push_imm( _register );
  else
    push(_register);
  b_push_imm(n);
  db(HANDLE.w_shr.handle_i);
}

void SeniorVMHandle::d_shr(long _register,char n,bool is_data)
{
  if ( is_data )
    d_push_imm( _register );
  else
    push(_register,false);
  b_push_imm(n);
  db(HANDLE.d_shr.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_shr(long _register,char n,bool is_data)
{
  if ( is_data )
    q_push_imm( _register );
  else
    push(_register,false);
  b_push_imm(n);
  db(HANDLE.q_shr.handle_i);
}
#endif


char SeniorVMHandle::v_shr( pVOperand o1,pVOperand o2 )
{
  char s1 = push_operand(o1);
  char s2 = push_operand(o2);
  if ( s2 > 1 )
  {
    cout << "shr第二个操作数不可能大于cl" << endl;
    throw;
  }
  
  switch ( s1 )
  {
  case 1:
    db( GET_HANDLE( b_shr ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_shr ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_shr ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_shr ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_shr ) );
      return 8;
#else
      db( GET_HANDLE( d_shr ) );
      return 4;
#endif
    }
  }
  return 0;      
}


void SeniorVMHandle::b_push_imm(char n)
{
  db(HANDLE.b_push_imm.handle_i);
  db(n);
}

void SeniorVMHandle::w_push_imm(short n)
{
  db(HANDLE.w_push_imm.handle_i);
  dw(n);
}

void SeniorVMHandle::d_push_imm(int n)
{
  db(HANDLE.d_push_imm.handle_i);
  dd(n);
}

void SeniorVMHandle::a_push_imm(long a)
{
#ifdef PROTECT_X64
  db(HANDLE.q_push_imm.handle_i);
  dq(a);
#else
  db(HANDLE.d_push_imm.handle_i);
  dd(a);
#endif
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_push_imm(long n)
{
  db(HANDLE.q_push_imm.handle_i);
  dq(n);
}
#endif

char SeniorVMHandle::v_push_imm( pVOperand o1)
{
  return push_operand(o1);
}

void SeniorVMHandle::popad()
{
#ifdef PROTECT_X64
  pcode->v_pop_register(T_R15);
  pcode->v_pop_register(T_R14);
  pcode->v_pop_register(T_R13);
  pcode->v_pop_register(T_R12);
  pcode->v_pop_register(T_R11);
  pcode->v_pop_register(T_R10);
  pcode->v_pop_register(T_R9);
  pcode->v_pop_register(T_R8);
#endif
  
  int mode = 0;
#ifndef PROTECT_X64
  mode = T_E32X;
#endif
  pcode->v_pop_register(T_RDI | mode);
  pcode->v_pop_register(T_RSI | mode);
  pcode->v_pop_register(T_RBP | mode);
  //pcode->v_pop_register(T_RSP | mode);
  pcode->v_pop_register(T_RBX | mode);
  pcode->v_pop_register(T_RDX | mode);
  pcode->v_pop_register(T_RCX | mode);
  pcode->v_pop_register(T_RAX | mode);
}

void SeniorVMHandle::popf()
{
  pcode->v_pop_register(T_EFLAG);
}

void SeniorVMHandle::exit()
{
  //pcode->v_push_register(T_RET);
  pushf();
  pushad();
  db(HANDLE.ret.handle_i);
}

void SeniorVMHandle::start()
{
  //popad();
  //popf();
  //pop(T_KEY);
  //pop(T_RET);
  save_vm_context();
}

#define T_TMP_EFLAG T_TMP_REGISTER5

void SeniorVMHandle::b_add_b(long _register1,long _register2)
{
  d_push_imm(0);
  pop(T_TMP_REGISTER3);
  
  b_and(_register1,_register2);
  pop(T_INVALID);
  b_xor(_register1,_register2);
  pop(T_INVALID);
  pop(T_TMP_R8_1H);
  b_push_imm(1<<7);
  pop(T_TMP_R8_1L);
  pop(T_TMP_R8_2H);
  b_and(T_TMP_R8_2H,T_TMP_R8_1L);
  pop(T_INVALID);
  pop(T_TMP_R8_3L);
  d_shr(T_TMP_REGISTER3,7);
  pop(T_INVALID);
  pop(T_TMP_REGISTER3);
  d_or(T_TMP_REGISTER3,T_TMP_EFLAG);
  pop(T_INVALID);
  pop(T_TMP_EFLAG);

  d_push_imm(0);
  pop(T_TMP_REGISTER3);
  
  b_push_imm(1<<3);
  pop(T_TMP_R8_3H);
  b_and(T_TMP_R8_3H,T_TMP_R8_2H);
  pop(T_INVALID);
  pop(T_TMP_R8_2L);
  
  b_shl(T_TMP_R8_2L,1);
  pop(T_INVALID);
  pop(T_TMP_R8_3L);
  d_or(T_TMP_REGISTER3,T_TMP_EFLAG);
  pop(T_INVALID);
  pop(T_TMP_EFLAG);
  b_shl(T_TMP_R8_2H,1);
  pop(T_INVALID);
  pop(T_TMP_R8_2H);
}

void SeniorVMHandle::b_add(long _register1,long _register2,bool is_data)
{
  push(_register1);
  if ( is_data )
    b_push_imm( _register2 );
  else
    push(_register2);
  db(HANDLE.b_add.handle_i);
}

char SeniorVMHandle::v_add( pVOperand o1,pVOperand o2 )
{
  char s1 = push_operand(o1);
  char s2 = push_operand(o2);
  
  switch ( s1 )
  {
  case 1:
    db( GET_HANDLE( b_add ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_add ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_add ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_add ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_add ) );
      return 8;
#else
      db( GET_HANDLE( d_add ) );
      return 4;
#endif
    }
  }  
}
  

void SeniorVMHandle::w_add(long _register1,long _register2,bool is_data)
{
  push(_register1);
  if ( is_data )
    w_push_imm( _register2 );
  else
    push(_register2);
  db(HANDLE.w_add.handle_i);
}

void SeniorVMHandle::d_add_d(long _register1,long _register2)
{
  d_and(_register1,_register2);  //8
  pcode->v_pop_register(T_INVALID); //4
  
  d_xor(_register1,_register2); 
  pcode->v_pop_register(T_INVALID); //4
  //pcode->v_pop_register(T_TMPconst T_TMP_R8_3H_R8_1L);
  pcode->v_pop_register(T_TMP_REGISTER1);


  ///这里保存CF 判断是否进位
  // pcode->v_push_register(T_TMP_REGISTER4);

  db(HANDLE.d_push_imm.handle_i); // var1 = 1<<31
  dd(1<<31);  //8
  pcode->v_pop_register(T_TMP_REGISTER4); //4
  pcode->v_pop_register(T_TMP_REGISTER3);//AND结果 0
  
  d_and(T_TMP_REGISTER4,T_TMP_REGISTER3); //8
  pcode->v_pop_register(T_INVALID); //4
 
  db(HANDLE.b_push_imm.handle_i);
  db(31);
  db(HANDLE.d_shr.handle_i);
  pcode->v_pop_register(T_INVALID);
  
  pcode->v_pop_register(T_TMP_REGISTER4);//AND结果  //0
  d_or(T_TMP_REGISTER4,T_TMP_EFLAG); 
  pcode->v_pop_register(T_INVALID);
    
  pcode->v_pop_register(T_TMP_EFLAG); //0
  ///end

  ///这里保存AF 判断bit3是否进位到bit4
  db(HANDLE.d_push_imm.handle_i);
  dd(1<<3);
  pcode->v_pop_register(T_TMP_REGISTER4);
  d_and(T_TMP_REGISTER4,T_TMP_REGISTER3); //8
  pcode->v_pop_register(T_INVALID);

  db(HANDLE.b_push_imm.handle_i); //左移一位
  db(1);
  db(HANDLE.d_shl.handle_i);
  
  pcode->v_pop_register(T_INVALID);
  
  pcode->v_pop_register(T_TMP_REGISTER4); //0

  
  d_or(T_TMP_REGISTER4,T_TMP_EFLAG); //8
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_EFLAG); //0*/
  
  //pcode->v_pop_register(T_INVALID); //第一个and的标志位
  pcode->v_push_register(T_TMP_REGISTER3);
  db(HANDLE.b_push_imm.handle_i);
  db(1);
  db(HANDLE.d_shl.handle_i);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER2);  
}

//OF 原本是0 结果变成1 或者相反    = 1 否这 = 0
//CF 超出能数值表示范围 至 = 1
//AF

void SeniorVMHandle::d_add(long _register1,long _register2,bool is_data)
{
  if (!super_protect)
  {
    push(_register1,false);
    if ( is_data )
      d_push_imm( _register2 );
    else
      push(_register2,false);
    db(HANDLE.d_add.handle_i);
    return;
  }

  //return;
  
  /*  db(HANDLE.d_push_imm.handle_i);
  dd(1<<31);
  pcode->v_pop_register(T_TMP_REGISTER3);
  d_and(_register1,T_TMP_REGISTER3);
  pcode->v_pop_register(T_INVALID);
  db(HANDLE.b_push_imm.handle_i);
  db(20);
  db(HANDLE.d_shr.handle_i);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_EFLAG);*/
  d_xor(_register1,_register2);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER1);
  d_not(T_TMP_REGISTER1);
  pcode->v_pop_register(T_INVALID);
  db(HANDLE.d_push_imm.handle_i);
  dd(0x80000000);
  pcode->v_pop_register(T_TMP_REGISTER2);
  pcode->v_pop_register(T_TMP_REGISTER3);
  d_and(T_TMP_REGISTER3,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);
  //  db(HANDLE.b_push_imm.handle_i);
  //  db(20);
  //  db(HANDLE.d_shr.handle_i);
  //  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_EFLAG);
  
  d_add_d(_register1,_register2);
 for (int i = 0; i < 31; ++i) //6次 留一次填充标志位
 {
    d_add_d(T_TMP_REGISTER2,T_TMP_REGISTER1);
 }
//pcode->v_push_register(T_TMP_R32_2);
// pcode->v_push_register(T_TMP_EFLAG);
 //pcode->v_push_register(T_TMP_REGISTER1);

  ///OF 判断是否溢出


  d_xor(_register2,T_TMP_REGISTER1);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER3);
 db(HANDLE.d_push_imm.handle_i);
 dd(0x80000000);
 pcode->v_pop_register(T_TMP_REGISTER4);
 d_and(T_TMP_REGISTER4,T_TMP_REGISTER3);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER3);

 d_and(T_TMP_EFLAG,T_TMP_REGISTER3);
 pcode->v_pop_register(T_INVALID);
 
 db(HANDLE.b_push_imm.handle_i);
 db(20);
 db(HANDLE.d_shr.handle_i);
 
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER4);
 //db(HANDLE.d_push_imm.handle_i);
 //dd(0x800);
 //pcode->v_pop_register(T_TMP_REGISTER3);
 // d_and(T_TMP_REGISTER3,T_TMP_REGISTER4);
 // pcode->v_pop_register(T_INVALID);
 //pcode->v_pop_register(T_TMP_REGISTER3);
 //d_and(T_TMP_EFLAG,T_TMP_REGISTER3); //这时候的OF还在最高位
 //pcode->v_pop_register(T_INVALID);
 //pcode->v_pop_register(T_TMP_REGISTER3);
 //db(HANDLE.d_push_imm.handle_i);
 //dd(0xFFFFF7FF);
 //pcode->v_pop_register(T_TMP_REGISTER3);
 //d_or(T_TMP_REGISTER3,T_TMP_REGISTER4);
 //pcode->v_pop_register(T_INVALID);
 //pcode->v_pop_register(T_TMP_REGISTER4);
 
 d_or(T_TMP_EFLAG,T_TMP_REGISTER4);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_EFLAG);
 /*pcode->v_push_register(T_TMP_EFLAG); 
 db(HANDLE.push_esp.handle_i);
 db(HANDLE.d_read_mem.handle_i); 
 pcode->v_pop_register(T_TMP_EFLAG);
 db(HANDLE.b_push_imm.handle_i);
 db(20);
 db(HANDLE.d_shl.handle_i);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER3);
 
 d_xor(_register1,T_TMP_REGISTER3);
 pcode->v_pop_register(T_INVALID);
 //pcode->v_pop_register(T_TMP_REGISTER3);
  db(HANDLE.b_push_imm.handle_i);
 db(20);
 db(HANDLE.d_shr.handle_i);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER4);
 db(HANDLE.d_push_imm.handle_i);
 dd(0x800);
 pcode->v_pop_register(T_TMP_REGISTER3);
 d_and(T_TMP_REGISTER3,T_TMP_REGISTER4);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER3);
 d_and(T_TMP_EFLAG,T_TMP_REGISTER3);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_REGISTER3);
 d_or(T_TMP_EFLAG,T_TMP_REGISTER3);
 pcode->v_pop_register(T_INVALID);
 pcode->v_pop_register(T_TMP_EFLAG);*/
 /////end OF
  d_and(T_TMP_REGISTER1,T_TMP_REGISTER1);
  pcode->v_pop_register(T_TMP_REGISTER2); //EFLAG
  d_or(T_TMP_EFLAG,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);
  /* 
  pcode->v_push_register(T_TMP_EFLAG);
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.d_read_mem.handle_i);
  pcode->v_pop_register(T_TMP_EFLAG);
  db(HANDLE.b_push_imm.handle_i);
  db(31);
  db(HANDLE.d_shr.handle_i);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER3);
  d_or(T_TMP_REGISTER3,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);
  /*  pcode->v_pop_register(T_TMP_REGISTER2);
  
  pcode->v_push_register(T_TMP_EFLAG);
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.d_read_mem.handle_i);
  pcode->v_pop_register(T_TMP_EFLAG);
  db(HANDLE.b_push_imm.handle_i);
  db(3);
  db(HANDLE.d_shr.handle_i);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER3);
  d_and(T_TMP_REGISTER3,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER2);

  pcode->v_push_register(T_TMP_EFLAG);
  db(HANDLE.d_push_imm.handle_i);
  db(1<<11);
  pcode->v_pop_register(T_TMP_REGISTER3);
  d_xor(T_TMP_REGISTER3,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);
  //pcode->v_push_register(T_TMP_REGISTER3);
  pcode->v_pop_register(T_TMP_REGISTER4);
  d_and(T_TMP_REGISTER3,T_TMP_REGISTER4);
  pcode->v_pop_register(T_INVALID);
  pcode->v_pop_register(T_TMP_REGISTER4);
  d_or(T_TMP_REGISTER4,T_TMP_REGISTER2);
  pcode->v_pop_register(T_INVALID);*/
  
//db(HANDLE.push_esp.handle_i);
//db(HANDLE.d_read_mem.handle_i);

//  pcode->v_pop_register(T_EAX);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_add(long _register1,long _register2,bool is_data)
{
  push(_register1);
  if ( is_data )
    q_push_imm( _register2 );
  else
    push(_register2);
  db(HANDLE.q_add.handle_i);
}
#endif



void SeniorVMHandle::b_push_imm_sx(char n)
{
  db(HANDLE.b_push_imm_sx.handle_i);
  db(n);
}

void SeniorVMHandle::w_push_imm_sx(short n)
{
  db(HANDLE.w_push_imm_sx.handle_i);
  dw(n);
}
#ifdef PROTECT_X64
void SeniorVMHandle::d_push_imm_sx(int n)
{
  db(HANDLE.d_push_imm_sx.handle_i);
  dd(n);
}
#endif
void SeniorVMHandle::b_push_imm_zx(char n)
{
  db(HANDLE.b_push_imm_zx.handle_i);
  db(n);
}

void SeniorVMHandle::w_push_imm_zx(short n)
{
  db(HANDLE.w_push_imm_zx.handle_i);
  dw(n);
}
#ifdef PROTECT_X64
void SeniorVMHandle::d_push_imm_zx(int n)
{
  db(HANDLE.d_push_imm_zx.handle_i);
  dd(n);
}
#endif
void SeniorVMHandle::b_copy_stack()
{
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.b_read_mem.handle_i);
}

void SeniorVMHandle::w_copy_stack()
{
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.w_read_mem.handle_i);
}

void SeniorVMHandle::d_copy_stack()
{
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.d_read_mem.handle_i);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_copy_stack()
{
  db(HANDLE.push_esp.handle_i);
  db(HANDLE.q_read_mem.handle_i);
}
#endif

void SeniorVMHandle::b_read_mem(  )
{
  db( GET_HANDLE( b_read_mem ) );
}

void SeniorVMHandle::w_read_mem(  )
{
  db( GET_HANDLE( w_read_mem ) );
}

void SeniorVMHandle::d_read_mem(  )
{
  db( GET_HANDLE( d_read_mem ) );
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_read_mem(  )
{
  db( GET_HANDLE( q_read_mem ) );
}
#endif

void SeniorVMHandle::b_write_mem(  )
{
  db( GET_HANDLE( b_write_mem ) );
}

void SeniorVMHandle::w_write_mem(  )
{
  db( GET_HANDLE( w_write_mem ) );
}

void SeniorVMHandle::d_write_mem(  )
{
  db( GET_HANDLE( d_write_mem ) );
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_write_mem(  )
{
  db( GET_HANDLE( q_write_mem ) );
}
#endif

/* 
char SeniorVMHandle::v_sub( pVOperand o1,pVOperand o2 )
{
  //char s1 = push_operand(o1);
  char s2 = push_operand(o2);
  
  switch ( s1 )
  {
  case 1:
    db( GET_HANDLE( b_sub ) );
    return 1;
    break;
  case 2:
    db( GET_HANDLE( w_sub ) );
    return 2;
    break;
  case 4:
    db( GET_HANDLE( d_sub ) );
    return 4;
    break;
#ifdef PROTECT_X64
  case 8:
    db( GET_HANDLE( q_sub ) );
    return 8;
    break;
#endif
  default:
    {
#ifdef PROTECT_X64
      db( GET_HANDLE( q_sub) );
      return 8;
#else
      db( GET_HANDLE( d_sub ) );
      return 4;
#endif
    }
  }  
}  */
  
                       


void SeniorVMHandle::b_sub(long _register1,long _register2)
{
  b_not(_register1);
  pop(T_INVALID);
  pop(T_TMP_R8_8L);
  b_add(T_TMP_R8_8L,_register2);
  //  pop(T_INVALID);
  pop(T_TMP_REGISTER6); //eflag 1
  b_copy_stack();
  b_not_and();
  pop(T_TMP_REGISTER7); //eflag 2 
  //pop(T_TMP_REGISTER8); //结果

  d_not(T_TMP_REGISTER6);
  pop(T_INVALID);
  w_push_imm_sx(0xf7ea);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER6);
  
  d_not(T_TMP_REGISTER7);
  pop(T_INVALID);
  w_push_imm_sx(0x815);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER7);
  d_add(T_TMP_REGISTER6,T_TMP_REGISTER7);
  pop(T_INVALID);
}

void SeniorVMHandle::w_sub(long _register1,long _register2)
{
  w_not(_register1);  //sub eax,ebx = add((not eax),ebx) 
  pop(T_INVALID);
  pop(T_TMP_R16_8);
  b_add(T_TMP_R16_8,_register2);
  //  pop(T_INVALID);
  pop(T_TMP_REGISTER6); //eflag 1
  w_copy_stack();
  w_not_and();
  pop(T_TMP_REGISTER7); //eflag 2 
  //pop(T_TMP_REGISTER8); //结果

  d_not(T_TMP_REGISTER6);
  pop(T_INVALID);
  w_push_imm_sx(0xf7ea);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER6);
  
  d_not(T_TMP_REGISTER7);
  pop(T_INVALID);
  w_push_imm_sx(0x815);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER7);
  d_add(T_TMP_REGISTER6,T_TMP_REGISTER7);
  pop(T_INVALID);
}

void SeniorVMHandle::d_sub(long _register1,long _register2)
{
  d_not(_register1);
  pop(T_INVALID);
  pop(T_TMP_REGISTER8);
  d_add(T_TMP_REGISTER8,_register2);
  //  pop(T_INVALID);
  pop(T_TMP_REGISTER6); //eflag 1
  d_copy_stack();
  d_not_and();
  pop(T_TMP_REGISTER7); //eflag 2 
  //pop(T_TMP_REGISTER8); //结果

  d_not(T_TMP_REGISTER6);
  pop(T_INVALID);
  w_push_imm_sx(0xf7ea);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER6);
  
  d_not(T_TMP_REGISTER7);
  pop(T_INVALID);
  w_push_imm_sx(0x815);
  d_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER7);
  d_add(T_TMP_REGISTER6,T_TMP_REGISTER7);
  pop(T_INVALID);
}
#ifdef PROTECT_X64
void SeniorVMHandle::q_sub(long _register1,long _register2)
{
  q_not(_register1);
  pop(T_INVALID);
  pop(T_TMP_REGISTER8);
  q_add(T_TMP_REGISTER8,_register2);
  //  pop(T_INVALID);
  pop(T_TMP_REGISTER6); //eflag 1
  q_copy_stack();
  q_not_and();
  pop(T_TMP_REGISTER7); //eflag 2 
  //pop(T_TMP_REGISTER8); //结果

  q_not(T_TMP_REGISTER6);
  pop(T_INVALID);
  w_push_imm_sx(0xf7ea);
  q_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER6);
  
  q_not(T_TMP_REGISTER7);
  pop(T_INVALID);
  w_push_imm_sx(0x815);
  q_not_and();
  pop(T_INVALID);
  pop(T_TMP_REGISTER7);
  q_add(T_TMP_REGISTER6,T_TMP_REGISTER7);
  pop(T_INVALID);
}
#endif

void SeniorVMHandle::b_cmp(long _register1,long _register2)
{
  b_sub(_register1,_register2);
  pop(T_EFLAG);
  pop(T_INVALID8H);
}

void SeniorVMHandle::w_cmp(long _register1,long _register2)
{
  w_sub(_register1,_register2);
  pop(T_EFLAG);
  pop(T_INVALID16);
}

void SeniorVMHandle::d_cmp(long _register1,long _register2)
{
  d_sub(_register1,_register2);
  pop(T_EFLAG);
  pop(T_INVALID32);
}

#ifdef PROTECT_X64
void SeniorVMHandle::q_cmp(long _register1,long _register2)
{
  q_sub(_register1,_register2);
  pop(T_EFLAG);
  pop(T_INVALID);
}
#endif

//带r的表示real真实的
//比如这条指令计算真正的内存地址

void SeniorVMHandle::r_get_mem(
                                  long _register_base,
                                  long _register_index,
                                  long _scale,
                                  long _lval)
{
  if (_register_base == T_NSP)
  {
    db( GET_HANDLE( push_esp ) );
    pop( T_ESP );
  }
  d_push_imm( _lval );
  pop( T_TMP_REGISTER4 );
  if ( _register_index ) {
    char sn = 0;
    for (int i = 0; i < 32; i++)
    {
      if (_scale == 1<<i)
      {
        sn = i;
        break;
      }
    }
    d_shl( _register_index,sn );
    pop( T_INVALID );
    pop( T_TMP_REGISTER5 );
    d_add(T_TMP_REGISTER4,T_TMP_REGISTER5  );
    pop( T_INVALID );
    pop( T_TMP_REGISTER4 );
  }
  if (_register_base)
  {
    d_add( _register_base,T_TMP_REGISTER4 );
    pop( T_INVALID );
  }
}


void SeniorVMHandle::push_vesp(  )
{
  db( GET_HANDLE( push_esp ) );
}


void SeniorVMHandle::db( unsigned char b)
{
  pcode->db( b );
}

void SeniorVMHandle::dw( unsigned short w )
{
  pcode->dw( w );
}

void SeniorVMHandle::dd( unsigned int d )
{
  pcode->dd( d );
}

#ifdef PROTECT_X64
void SeniorVMHandle::dq( unsigned long q )
{
  pcode->dq( q );
}
#endif

void SeniorVMHandle::set_pc(  )
{
  db( GET_HANDLE( set_pc ) );
}

void SeniorVMHandle::set_key( long _key )
{
  //recover_vm_context();
#ifndef PROTECT_X64
  d_push_imm( _key  );
#else
  q_push_imm( _key  );
#endif
  db( GET_HANDLE( set_key ) );
}

void SeniorVMHandle::mov(pVOperand o1,pVOperand o2)
{
  
}

void SeniorVMHandle::test(pVOperand o1,pVOperand o2)
{
  v_and(o1,o2);
  pop(T_EFLAG);
  pop(T_INVALID);
}


void SeniorVMHandle::lea(pVOperand o1,pVOperand o2)
{
}

void SeniorVMHandle::cmp(pVOperand o1,pVOperand o2)
{
}

void SeniorVMHandle::sar(pVOperand o1,pVOperand o2)
{
}

void SeniorVMHandle::cdq(pVOperand o1)
{
}

void SeniorVMHandle::div(pVOperand o1)
{
}


void SeniorVMHandle::sar(pVOperand o1)
{
}

void SeniorVMHandle::imul(pVOperand o1,pVOperand o2,pVOperand o3)
{
}

void SeniorVMHandle::jnz(long addr1,long addr2)
{
}

void SeniorVMHandle::jz(long addr1,long addr2)
{
}

```

`VMAddressTable.hpp`:

```hpp
/*
 *   Copyright (C) Tue Jun 25 17:48:43 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _VMADDRESSTABLE_H_
#define _VMADDRESSTABLE_H_

#include "SeniorVMHandle.hpp"
#include "CombosVMCode.hpp"
#include "AddressTable.hpp"
#include "algorithms.hpp"

typedef struct _v_table_
{
  VCombosVMCode *v;
  _v_table_()
    :vesp_diff( 0 ),key_status( false ),key( 0 ),v( NULL )
  {  
  }
  ~_v_table_()
  {  
  }
  long base;
  long reloc_address;
  long id;
  long vesp_diff;
  long key;
  bool key_status;
}VTable, *pVTable;

class VMAddressTable : public AddressTable<VTable>
{
public:
    char *buffer;
    unsigned long buffer_size;

  VMAddressTable(long _base, unsigned long _size, bool _sign)
    :AddressTable( _base,_size,_sign ),buffer(NULL),buffer_size(0)
#ifdef _DEBUG
     ,vmcode_piece_count(0)
#endif
  {
    
  }

  virtual ~VMAddressTable()
  {
    if (buffer)
    {
      delete [] buffer;
    }
  }

  
  void update(VCombosVMCode * p )
  {
    for (list<space>::iterator iter = addr_used.begin(); iter != addr_used.end(); ++iter)
    {
      if (iter->data.v == p)
      {
        if ( get_sign() )
          iter->end = iter->begin + p->get_code_size();
        else
          iter->begin = iter->end - p->get_code_size();
      }
    }
  }
  
  void init_buffer()
  {
      buffer = new char[size];
      buffer_size = size;   
  }

  long copy(unsigned char * buf,unsigned long size)
  {
    long address = assign_address(size);
    memcpy(&(buffer[address - base]),buf,size);
    return address;
  }

  void *copy(long address, unsigned char *buf, unsigned long size)
  {
    if (buffer == NULL)
      init_buffer();

    void * buff = &(buffer[address-base]);
    memcpy(buff,buf,size);

    return buff;
  }
  
  void * copy(unsigned char * buf)
  {
    addr_used_sort();
    for (list<space>::iterator iter = addr_used.begin( ) ; iter !=
           addr_used.end(); ++iter)
    {
      space d = *iter;
      if ( get_sign() )
      {
        memcpy(&buf[d.begin - base],
               d.data.v->get_code_buf(),
               d.data.v->get_code_size());
      }
      else
      {
        memcpy( &buf[ d.begin - base ],
                d.data.v->get_code_buf(),
                d.data.v->get_code_size());
      }  
    }
    return buf;
  }

#ifdef _DEBUG
  size_t vmcode_piece_count;
#endif

  void * copy()
  {
    if (buffer == NULL)
      init_buffer();

    addr_used_sort();

#ifdef _DEBUG
    char buildvmcode_name[256];
    sprintf_s(buildvmcode_name, 256, "buildvmcode%d.log",vmcode_piece_count++);
    FILE *file;
    fopen_s(&file, buildvmcode_name, "wb");
#endif

    for (list<space>::iterator iter = addr_used.begin();
        iter != addr_used.end();
        ++iter)
    {
      space & d = *iter;
      if (d.data.v)
        if (d.end - d.begin != d.data.v->get_code_size())
        {
          printf("字节不对,分配:%d,使用:%d\n",d.end-d.begin,d.data.v->get_code_size());
          throw;
        }          
      if ( get_sign() )
      {    
#ifdef _DEBUG
        if (d.data.v)
        {
          fprintf(file,"代码地址:%x,虚拟代码地址:%x,标志位%d\r\n",d.data.base,d.begin,get_sign());
          for (int i = 0; i < d.data.v->get_code_size(); ++i)
          {
              fprintf(file," ");

            unsigned char code = *(unsigned char*)((char*)d.data.v->get_code_buf() + i);
            code = code & 0xff;
              fprintf(file,"%02c",code);
              if ((i + 1) % 16 == 0)
              {
              fprintf(file,"\r\n");
              }
          }
          fprintf(file,"\r\n");
        }
        //printf("%s",file);
#endif               
        if (d.data.v)
        {
            memcpy(&buffer[d.begin - base],
               d.data.v->get_code_buf(),
               d.data.v->get_code_size());
            d.data.v = NULL;
        }
      }
      else
      {
#ifdef _DEBUG
        if (d.data.v)
        {
          fprintf(file,"代码地址:%x,虚拟代码地址:%x,标志位置%d\r\n",d.data.base,d.end,get_sign());
          for (int i = 0; i < d.data.v->get_code_size(); ++i)
          {
            fprintf(file," ");
            //fwrite((char*)d.data.v->get_code_buf() + i,1,1,file);
           unsigned char code = *(unsigned char*)((char*)d.data.v->get_code_buf() + i);
            code = code & 0xff;
            fprintf(file,"%x",code);
            if ((i + 1) % 16 == 0)
            {
              fprintf(file,"\r\n");
            }
          }
          fprintf(file,"\r\n");
        }
#endif
        if (d.data.v)        
        {
          memcpy( &buffer[ d.begin - base ],
                d.data.v->get_code_buf(),
                d.data.v->get_code_size());
          d.data.v = NULL;   
        }
      }
    }

#ifdef _DEBUG
    fclose(file);
#endif

    return buffer;    
  }  // copy()

  VTable * get_data( long _base )
  {
    for (list<space>::iterator iter = addr_used.begin( ) ;
        iter != addr_used.end();
        ++iter)
    {
      if (iter->begin == _base)
        return &iter->data;
    }
    return NULL;
  }

  unsigned long get_size( )
  {
    return size;
  }

  unsigned long assign_address(unsigned long _size,const VTable & _data)
  {
    unsigned long addr = (unsigned long)AddressTable::assign_address(_size, _data);
    addr_used.back().data.base = addr;
    if (buffer)
    {
      if (buffer_size < size)
      {
        char * newbuf = new char[size];
        memcpy(newbuf,buffer,buffer_size);
        delete [] buffer;
        buffer = newbuf;
        buffer_size = size;
      }
    }    
    return addr;
  }

  unsigned long assign_address(unsigned long _size)
  {
    unsigned long addr = (unsigned long)AddressTable::assign_address(_size);

    if (buffer)
    {
      if (buffer_size < size)
      {
        char * newbuf = new char[size];
        memcpy(newbuf, buffer, buffer_size);
        delete [] buffer;
        buffer = newbuf;
        buffer_size = size;
      }
    }
    return addr;
  }
};  // class VMAddressTable

#endif /* _VMADDRESSTABLE_H_ */

```

`VMHandle.cpp`:

```cpp
/*
 *   Copyright (C) Mon May  6 05:21:23 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#include <time.h>
#include <string.h>
#include "algorithms.hpp"
#include "VMHandle.h"

#pragma warning(disable:4312)
#pragma warning(disable:4996)

FileLogger logger(stdout);

#ifndef _DEBUG
#define _DEBUG
#endif

VMHandle::VMHandle()
{
    l_initialization = a.newLabel();
    l_set_pc = a.newLabel();
    l_ret = a.newLabel();

    l_dispatch = a.newLabel();
    l_check_stack = a.newLabel();
    l_push_stack_top_base = a.newLabel();
    l_pop_stack_top_base = a.newLabel();
    l_run_stack_code = a.newLabel();

    l_set_key = a.newLabel();
    l_key_dispatch = a.newLabel(); //set_key之后直接跳转到这里

  	l_b_read_stack = a.newLabel(); //byte
	l_w_read_stack = a.newLabel(); //word
	l_d_read_stack = a.newLabel(); //dword
    l_q_read_stack = a.newLabel();

    l_b_write_stack = a.newLabel();
    l_w_write_stack = a.newLabel();
    l_d_write_stack = a.newLabel();
    l_q_write_stack = a.newLabel();

    l_b_push_reg = a.newLabel();
    l_w_push_reg = a.newLabel();
    l_d_push_reg = a.newLabel();
    l_q_push_reg = a.newLabel();

    l_b_pop_reg = a.newLabel();
    l_w_pop_reg = a.newLabel();
    l_d_pop_reg = a.newLabel();
    l_q_pop_reg = a.newLabel();

    l_b_push_imm = a.newLabel();
    l_w_push_imm = a.newLabel();
    l_d_push_imm = a.newLabel();
    l_q_push_imm = a.newLabel();

    l_b_shl = a.newLabel();
    l_w_shl = a.newLabel();
    l_d_shl = a.newLabel();
    l_q_shl = a.newLabel();

    l_b_shr = a.newLabel();
    l_w_shr = a.newLabel();
    l_d_shr = a.newLabel();
    l_q_shr = a.newLabel();

    l_shld = a.newLabel();
    l_shrd = a.newLabel();

    l_b_nand = a.newLabel();
    l_w_nand = a.newLabel();
    l_d_nand = a.newLabel();
    l_q_nand = a.newLabel();

    l_b_read_mem = a.newLabel();
    l_d_read_mem = a.newLabel();
    l_w_read_mem = a.newLabel();
    l_q_read_mem = a.newLabel();

    l_b_write_mem = a.newLabel();
    l_w_write_mem = a.newLabel();
    l_d_write_mem = a.newLabel();
    l_q_write_mem = a.newLabel();

    l_b_push_imm_sx = a.newLabel();
    l_w_push_imm_sx = a.newLabel();
    l_d_push_imm_sx = a.newLabel();

    l_b_push_imm_zx = a.newLabel();
    l_w_push_imm_zx = a.newLabel();
    l_d_push_imm_zx = a.newLabel();
    
    l_b_add = a.newLabel();
    l_w_add = a.newLabel();
    l_d_add = a.newLabel();
    l_q_add = a.newLabel();

    l_b_rol = a.newLabel();
    l_w_rol = a.newLabel();
    l_d_rol = a.newLabel();
    l_q_rol = a.newLabel();

    l_b_ror = a.newLabel();
    l_w_ror = a.newLabel();
    l_d_ror = a.newLabel();
    l_q_ror = a.newLabel();

    l_in    = a.newLabel();
    l_rdtsc = a.newLabel();
    l_cpuid = a.newLabel();
    l_fstsw = a.newLabel();
    l_int3  = a.newLabel();

    //srand((unsigned int)time(NULL));
    key = rand(); //随机key
}

VMHandle::~VMHandle()
{
}

#define FULL_BEGIN  1

void c_add(encryption &_en,decryption &_de,const GPReg &_op_r)
{
  _de.defuc = new Assembler;
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);

  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();

   if (bB)
   {
      char r = rand()%0x100;  
      _de.defuc->add(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->add(byte_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);
    }
   else if (bW)
    {
      short r = rand()%0x10000;  
      _de.defuc->add(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->add(word_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);
    }
   else if (bD)
    {
      int r = rand()%0xFFFFFFFF;  
      _de.defuc->add(_op_r,imm(r));
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
        GPVar result(_en.enfuc->newGP());
      _en.enfuc->add(dword_ptr(_en.enfuc->argGP(0)),imm(r));
#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);
#else
      _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
      _en.enfuc->ret(result);
    }
   else if(bQ)
    {
      long r = rand();  
      _de.defuc->add(_op_r,r);
#ifdef PROTECT_X64
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
#endif
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->add(qword_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);
    }
      _en.enfuc->endFunction();
}

void c_sub(encryption &_en,decryption &_de,const GPReg &_op_r)
{
  _de.defuc = new Assembler;
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);
 
  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();

   if (bB)
   {
      char r = rand()%0x100;  
      _de.defuc->sub(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->sub(byte_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);
    }
   else if (bW)
    {
      short r = rand()%0x10000;  
      _de.defuc->sub(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
      GPVar result(_en.enfuc->newGP());      
      _en.enfuc->sub(word_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);      
    }
   else if (bD)
    {
      int r = rand()%0xFFFFFFFF;  
      _de.defuc->sub(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
      GPVar result(_en.enfuc->newGP());            
      _en.enfuc->sub(dword_ptr(_en.enfuc->argGP(0)),r);
#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);
#else
      _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
      _en.enfuc->ret(result);      
    }
   else if(bQ)
    {
       long r = rand();  
      _de.defuc->sub(_op_r,r);
#ifdef PROTECT_X64
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
#endif
      GPVar result(_en.enfuc->newGP());            
      _en.enfuc->sub(qword_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);      
    }

     _en.enfuc->endFunction();
}

void c_rol(encryption &_en,decryption &_de,const GPReg & _op_r )
{
#ifdef PROTECT_X64
  char r = rand()%64;
#else
  char r = rand()%32;
#endif
  _de.defuc = new Assembler;
  _de.defuc->rol(_op_r,r);
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);

  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();

  if (bB)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
    GPVar result(_en.enfuc->newGP());
    _en.enfuc->rol(byte_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
  else if (bW)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->rol(word_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
  else if (bD)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->rol(dword_ptr(_en.enfuc->argGP(0)),r);
#ifdef PROTECT_X64
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->and_(result,0x00000000ffffffff);    
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
    _en.enfuc->ret(result);    
  }

#ifdef PROTECT_X64
  else
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->rol(qword_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
#endif

  _en.enfuc->endFunction();
}

void c_ror(encryption &_en,decryption &_de,const GPReg & _op_r )
{
#ifdef PROTECT_X64
  char r = rand()%64;
#else
  char r = rand()%32;
#endif

  _de.defuc = new Assembler;
  _de.defuc->ror(_op_r,r);
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);


  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();

  if (bB)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
    GPVar result(_en.enfuc->newGP());
    _en.enfuc->ror(byte_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);    
  }
  else if (bW)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
    GPVar result(_en.enfuc->newGP());    
     _en.enfuc->ror(word_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);    
  }
  else if (bD)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->ror(dword_ptr(_en.enfuc->argGP(0)),r);
#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);    
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
    _en.enfuc->ret(result);    
  }
#ifdef PROTECT_X64
  else
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->ror(qword_ptr(_en.enfuc->argGP(0)),r);
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
#endif
  _en.enfuc->endFunction();  
}

void c_inc(encryption &_en,decryption &_de,const GPReg & _op_r)
{
  _de.defuc = new Assembler;
  _de.defuc->inc(_op_r);
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);
 
  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();
  if (bB)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->inc(byte_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
  else if (bW)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->inc(word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
  else if (bD)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->inc(dword_ptr(_en.enfuc->argGP(0)));
#ifdef PROTECT_X64
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->and_(result,0x00000000ffffffff);        
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
    _en.enfuc->ret(result);    
  }
#ifdef PROTECT_X64
  else
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->inc(qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
#endif
  _en.enfuc->endFunction();
}

void c_dec(encryption &_en,decryption &_de,const GPReg & _op_r )
{
  _de.defuc = new Assembler;
  _de.defuc->dec(_op_r);
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);
 
  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();
  if (bB)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->dec(byte_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);    
  }
  else if (bW)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
    GPVar result(_en.enfuc->newGP());
     _en.enfuc->dec(word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);    
  }
  else if (bD)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
      GPVar result(_en.enfuc->newGP());  
    _en.enfuc->dec(dword_ptr(_en.enfuc->argGP(0)));
#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);         
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
      _en.enfuc->ret(result);    
  }
#ifdef PROTECT_X64
  else
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->dec(qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
#endif
  _en.enfuc->endFunction();
}

void c_not(encryption &_en,decryption &_de,const GPReg & _op_r )
{
  _de.defuc = new Assembler;
  _de.defuc->not_(_op_r);
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);

  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();
  if (bB)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
    GPVar result(_en.enfuc->newGP());  
    _en.enfuc->not_(byte_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);    
  }
  else if (bW)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
    GPVar result(_en.enfuc->newGP());
    _en.enfuc->not_(word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
  else if (bD)
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->not_(dword_ptr(_en.enfuc->argGP(0)));

#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);             
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif

    _en.enfuc->ret(result);  
  }
#ifdef PROTECT_X64
  else
  {
    _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
    GPVar result(_en.enfuc->newGP());    
    _en.enfuc->not_(qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
    _en.enfuc->ret(result);    
  }
#endif
  _en.enfuc->endFunction();
}

void c_xor(encryption &_en,decryption &_de,const GPReg  & _op_r)
{
  _de.defuc = new Assembler;
  _en.enfuc = new Compiler;
  //_en.enfuc->setLogger(&logger);

  bool bD = _op_r.isGPD();
  bool bQ = _op_r.isGPQ();
  bool bW = _op_r.isGPW();
  bool bB = _op_r.isGPB();
   if (bB)
   {
      char r = rand()%0x100;  
      _de.defuc->xor_(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned char,unsigned char*>());
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->xor_(byte_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,byte_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);      
    } else if (bW)
    {
      short r = rand()%0x10000;  
      _de.defuc->xor_(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned short,unsigned short*>());
      GPVar result(_en.enfuc->newGP());      
      _en.enfuc->xor_(word_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->movzx(result,word_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);      
    } else if (bD)
    {
      int r = rand()%0xFFFFFFFF;  
      _de.defuc->xor_(_op_r,r);
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned int,unsigned int*>());
      GPVar result(_en.enfuc->newGP());
      _en.enfuc->xor_(dword_ptr(_en.enfuc->argGP(0)),r);
#ifdef PROTECT_X64
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->and_(result,0x00000000ffffffff);             
#else
    _en.enfuc->mov(result,dword_ptr(_en.enfuc->argGP(0)));
#endif
      _en.enfuc->ret(result);    
    } else if(bQ)
    {
       long r = rand();  
      _de.defuc->xor_(_op_r,r);
#ifdef PROTECT_X64
      _en.enfuc->newFunction(CALL_CONV_DEFAULT, FunctionBuilder1<unsigned long,unsigned long*>());
#endif
      GPVar result(_en.enfuc->newGP());      
      _en.enfuc->xor_(qword_ptr(_en.enfuc->argGP(0)),r);
      _en.enfuc->mov(result,qword_ptr(_en.enfuc->argGP(0)));
      _en.enfuc->ret(result);      
    }
     _en.enfuc->endFunction();
}

void vcode_c_xor(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
 _de.defuc = new Assembler;
 _en.enfuc = new Assembler;
 //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();
  bool b_register = false;

  long _key_ = 0;
  long _data_ = 1;
#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
#else
  _key_ = 8;
  _data_ = 4;
#endif
  if (rand()%50 >= 25)
  {
    b_register = true;
  }
  if (b_register)
  {
    _en.key = 0;
    _de.defuc->xor_(_rdata,_rkey);
  }
#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,qword_ptr(nsp,_key_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,dword_ptr(nsp,_key_));
#endif

  if (bB)
  {
    if (!b_register)
    {
      _en.key = rand()%0xff + 1;
      _de.defuc->xor_(_rdata,_en.key);
    }
    _en.enfuc->mov(al,byte_ptr(nsi));
    _en.enfuc->xor_(byte_ptr(ndi),al);
    _en.enfuc->ret();
  }
  else if (bW)
  {
    if (!b_register)
    {
      _en.key = rand()%0xffff + 1;
      _de.defuc->xor_(_rdata,_en.key);
    }
    _en.enfuc->mov(ax,word_ptr(nsi));
    _en.enfuc->xor_(word_ptr(ndi),ax);
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    if (!b_register)
    {
      _en.key = rand()%0xffffffff + 1;
      _de.defuc->xor_(_rdata,_en.key);
    }
    _en.enfuc->mov(eax,dword_ptr(nsi));
    _en.enfuc->xor_(dword_ptr(ndi),eax);
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    if (!b_register)
    {
      _en.key = rand()%0xffffffffffffffff + 1;
      _de.defuc->xor_(_rdata,_en.key);
    }
    _en.enfuc->mov(rax,qword_ptr(nsi));
    _en.enfuc->xor_(qword_ptr(ndi),rax);
    _en.enfuc->ret();
  }
#endif
  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

void vcode_c_add(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
  //printf("vcode_c_add()\n");
  _de.defuc = new Assembler;
  _en.enfuc = new Assembler;
  //_en.enfuc->setLogger(&logger);

  _de.defuc->add(_rdata,_rkey);

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,8));
  _en.enfuc->mov(nsi,qword_ptr(nsp,16));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,4));
  _en.enfuc->mov(nsi,dword_ptr(nsp,8));
#endif

  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();
  if (bB)
  {
    _en.enfuc->mov(al,byte_ptr(nsi));
    _en.enfuc->sub(byte_ptr(ndi),al);
    _en.enfuc->ret();
  }
  else if (bW)
  {
    _en.enfuc->mov(ax,word_ptr(nsi));
    _en.enfuc->sub(word_ptr(ndi),ax);
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    _en.enfuc->mov(eax,dword_ptr(nsi));
    _en.enfuc->sub(dword_ptr(ndi),eax);
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    _en.enfuc->mov(rax,qword_ptr(nsi));
    _en.enfuc->sub(qword_ptr(ndi),rax);
    _en.enfuc->ret();
  }
#endif

  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

void vcode_c_sub(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
  //printf("vcode_c_sub()\n");
  _de.defuc = new Assembler;
  _en.enfuc = new Assembler;
  //_en.enfuc->setLogger(&logger);

  _de.defuc->sub(_rdata,_rkey);

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,8));
  _en.enfuc->mov(nsi,qword_ptr(nsp,16));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,4));
  _en.enfuc->mov(nsi,dword_ptr(nsp,8));
#endif

  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();
  if (bB)
  {
    _en.enfuc->mov(al,byte_ptr(nsi));
    _en.enfuc->add(byte_ptr(ndi),al);
    _en.enfuc->ret();
  }
  else if (bW)
  {
    _en.enfuc->mov(ax,word_ptr(nsi));
    _en.enfuc->add(word_ptr(ndi),ax);
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    _en.enfuc->mov(eax,dword_ptr(nsi));
    _en.enfuc->add(dword_ptr(ndi),eax);
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    _en.enfuc->mov(rax,qword_ptr(nsi));
    _en.enfuc->add(qword_ptr(ndi),rax);
    _en.enfuc->ret();
  }
#endif

  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

const GPReg & get_register_l(const GPReg & r)
{
  GPReg reg_array[4][8]=
    {
      al,bl,cl,dl,ah,bh,ch,dh,
      ax,bx,cx,dx,sp,bp,si,di,
      eax,ebx,ecx,edx,esp,ebp,esi,edi,
      nax,nbx,ncx,ndx,nsp,nbp,nsi,ndi
    };

  for (int i = 0; i < 4; ++i)
  {
    for (int j = 0; j < 8; ++j)
    {
      if (memcmp(&reg_array[i][j],&r,sizeof(GPReg))==0)
      {
        return  reg_array[0][j];
      }
    }
  }

  printf("get_register_l error!\n");
  return reg_array[0][0];
}

void vcode_c_ror(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
 _de.defuc = new Assembler;
 _en.enfuc = new Assembler;
 //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();
  bool b_register = false;

  long _key_ = 0;
  long _data_ = 1;
  long max_r;

#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
  max_r = 64;
#else
  _key_ = 8;
  _data_ = 4;
  max_r = 32;
#endif

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,qword_ptr(nsp,_key_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,dword_ptr(nsp,_key_));
#endif

  if (bB)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->ror(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->rol(byte_ptr(ndi),cl);
    _en.enfuc->ret();
  }
  else if (bW)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->ror(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->rol(word_ptr(ndi),cl);
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->ror(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->rol(dword_ptr(ndi),cl);
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->ror(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->rol(qword_ptr(ndi),cl);
    _en.enfuc->ret();
  }
#endif

  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}


void vcode_c_rol(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
 _de.defuc = new Assembler;
 _en.enfuc = new Assembler;
 //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();
  bool b_register = false;

  long _key_ = 0;
  long _data_ = 1;
  long max_r;
#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
  max_r = 64;
#else
  _key_ = 8;
  _data_ = 4;
  max_r = 32;
#endif
  if (rand()%50 >= 25)
  {
    b_register = true; //进入这里会造成计算错误
  }
  b_register = false;
  if (b_register)
  {
    _en.key = 0;
    _de.defuc->mov(cl,get_register_l(_rkey));
    _de.defuc->rol(_rdata,cl);
  }

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,qword_ptr(nsp,_key_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
  _en.enfuc->mov(nsi,dword_ptr(nsp,_key_));
#endif

  if (bB)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->rol(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->ror(byte_ptr(ndi),cl);
    _en.enfuc->ret();
  }
  else if (bW)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->rol(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->ror(word_ptr(ndi),cl);
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->rol(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->ror(dword_ptr(ndi),cl);
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    if (!b_register)
    {
      _en.key = rand()%max_r+1;
      _de.defuc->rol(_rdata,_en.key);
    }
    _en.enfuc->mov(cl,byte_ptr(nsi));
    _en.enfuc->ror(qword_ptr(ndi),cl);
    _en.enfuc->ret();
  }
#endif
  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

void vcode_c_not(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
 _de.defuc = new Assembler;
 _en.enfuc = new Assembler;
 //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();

  long _key_ = 0;
  long _data_ = 1;
  long max_r;
#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
  max_r = 64;
#else
  _key_ = 8;
  _data_ = 4;
  max_r = 32;
#endif

  _de.defuc->not_(_rdata);

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
#endif

  if (bB)
  {
    _en.enfuc->not_(byte_ptr(ndi));
    _en.enfuc->ret();
  }
  else if (bW)
  {
    _en.enfuc->not_(word_ptr(ndi));
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    _en.enfuc->not_(dword_ptr(ndi));
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    _en.enfuc->not_(qword_ptr(ndi));
    _en.enfuc->ret();
  }
#endif
  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

void vcode_c_dec(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
  _de.defuc = new Assembler;
  _en.enfuc = new Assembler;
  //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();

  long _key_ = 0;
  long _data_ = 1;
  long max_r;
#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
  max_r = 64;
#else
  _key_ = 8;
  _data_ = 4;
  max_r = 32;
#endif
  _de.defuc->dec(_rdata);

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
#endif


  if (bB)
  {
    _en.enfuc->inc(byte_ptr(ndi));
    _en.enfuc->ret();
  }
  else if (bW)
  {
    _en.enfuc->inc(word_ptr(ndi));
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    _en.enfuc->inc(dword_ptr(ndi));
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    _en.enfuc->inc(qword_ptr(ndi));
    _en.enfuc->ret();
  }
#endif
  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}


void vcode_c_inc(vcode_encryption &_en,vcode_decryption &_de,const GPReg  & _rdata,const GPReg & _rkey)
{
  _de.defuc = new Assembler;
  _en.enfuc = new Assembler;
  //_en.enfuc->setLogger(&logger);
  
  bool bD = _rdata.isGPD();
  bool bQ = _rdata.isGPQ();
  bool bW = _rdata.isGPW();
  bool bB = _rdata.isGPB();

  long _key_ = 0;
  long _data_ = 1;
  long max_r;
#ifdef PROTECT_X64
  _key_ = 16;
  _data_ = 8;
  max_r = 64;
#else
  _key_ = 8;
  _data_ = 4;
  max_r = 32;
#endif
  _de.defuc->inc(_rdata);

#ifdef PROTECT_X64
  _en.enfuc->mov(ndi,qword_ptr(nsp,_data_));
#else
  _en.enfuc->mov(ndi,dword_ptr(nsp,_data_));
#endif

  if (bB)
  {
    _en.enfuc->dec(byte_ptr(ndi));
    _en.enfuc->ret();
  }
  else if (bW)
  {
    _en.enfuc->dec(word_ptr(ndi));
    _en.enfuc->ret();    
  }
  else if (bD)
  {
    _en.enfuc->dec(dword_ptr(ndi));
    _en.enfuc->ret();    
  }
#ifdef PROTECT_X64
  else if (bQ)
  {
    _en.enfuc->dec(qword_ptr(ndi));
    _en.enfuc->ret();
  }
#endif
  _en.fn = function_cast<vcode_encryption::MyFn>(_en.enfuc->make());
}

 typedef void (*algorithm) (encryption &,decryption &,const GPReg &);
 algorithm alg_fuc_array[] = 
 {
     c_add,
     c_sub,
     c_inc,
     c_dec,
     c_xor,
     c_not,
     c_rol,
     c_ror
 };
 int alg_count = sizeof(alg_fuc_array)/sizeof(alg_fuc_array[0]);

void VMHandle::full_handle_info(handle_info & info,char flag)
{
    info.type   = 0;
    info.size   = 0;
    info.buf    = NULL;
    info.offset = a.getOffset();
    
    encryption en;
    decryption de;
    de.defuc = NULL;
    en.enfuc = NULL;

    GPReg random_register_array[] = {bl,bx,ebx,nbx};
    int size = sizeof(random_register_array)/sizeof(random_register_array[0]);

    algorithm fuc = alg_fuc_array[rand()%alg_count];
    int r_reg = rand()%size;
    fuc(en,de,random_register_array[r_reg]);

    unsigned char * code = de.defuc->getCode();
    int CodeSize         = de.defuc->getCodeSize();

    for (int i = 0; i < CodeSize; ++i)
    {
        a.db(code[i]);
    }
    delete de.defuc;

    en.en_fn = function_cast<encryption::MyFn>(en.enfuc->make());
    en.key   = rand();
    info.encode.push_back(en);
    info.encode.back().en_fn(&en.key);
}

typedef void (*algorithms_vcode) (vcode_encryption &,vcode_decryption &,const GPReg &,const GPReg &);
algorithms_vcode alg_vcode_fuc_array[]=
{
    vcode_c_add,
    vcode_c_sub,
    vcode_c_xor,
    vcode_c_not,
    vcode_c_rol,
    vcode_c_ror,
    vcode_c_inc,
    vcode_c_dec
};
int alg_vcode_count = sizeof(alg_vcode_fuc_array)/sizeof(alg_vcode_fuc_array[0]);

handle_info VMHandle::dispatch(long table_addr)
{
    handle_info info;
#ifdef _DEBUG
    strcpy(info.handle_name,"dispatch");
#endif
    a.bind(l_dispatch);
    info.label = &l_dispatch;
    full_handle_info(info,FULL_BEGIN);

    a.bind( l_key_dispatch );
    if (sign)
    {
        a.movzx(nax,byte_ptr(nsi));
        a.inc(nsi);
    }
    else
    {
        a.movzx(nax,byte_ptr(nsi,-1));
        a.dec(nsi);
    }

    info.type = READ_BYTE;
    vcode_encryption en;
    vcode_decryption de;
    en.key = 0;

    algorithms_vcode fuc = alg_vcode_fuc_array[rand()%alg_vcode_count];
    fuc(en,de,al,bl);
    for (int i = 0; i < de.defuc->getCodeSize(); ++i)
    {
        unsigned char * code = de.defuc->getCode();
        a.db(code[i]);
    }      
    info.encode_pcode.push_back(en);
    delete de.defuc;

#ifdef PROTECT_X64
    a.push(qword_ptr_abs((void*)table_addr,nax,3));
#else
    a.push(dword_ptr_abs((void*)table_addr,nax,2));
#endif
    a.ret();

    info.size = a.getCodeSize()-info.size;
    return info;
}

void VMHandle::read_pc_byte(handle_info & info)
{
    if (sign)
    {
        a.mov(al,byte_ptr(esi));
        a.inc(esi);
    }
    else
    {
        a.mov(al,byte_ptr(esi,-1));
        a.dec(esi);
    }

    info.type = READ_BYTE;
    int r = rand()%alg_vcode_count;
    vcode_encryption en;
    vcode_decryption de;
    en.key = 0;
    for (int i = 0; i < r; ++i)
    {
        algorithms_vcode fuc = alg_vcode_fuc_array[rand()%alg_vcode_count];
        fuc(en,de,al,bl);

        unsigned char * code = de.defuc->getCode();
        int CodeSize = de.defuc->getCodeSize();
        for (int i = 0; i < CodeSize; ++i)
        {
            a.db(code[i]);
        }
        delete de.defuc;

        info.encode_pcode.push_back(en);
    }
}

void VMHandle::read_pc_word(handle_info &info)
{
  if (sign)
  {
    a.mov(ax,word_ptr(esi));
    a.add(esi,2);
  }
  else
  {
    a.mov(ax,word_ptr(esi,-2));
    a.sub(esi,2);
  }

  info.type = READ_WORD;
  int r = rand()%alg_vcode_count;
  vcode_encryption en;
  vcode_decryption de;
  en.key = 0;
  for (int i = 0; i < r; ++i)
  {
      algorithms_vcode fuc = alg_vcode_fuc_array[rand()%alg_vcode_count];
      fuc(en,de,ax,bx);
      for (int i = 0; i < de.defuc->getCodeSize(); ++i)
      {
          unsigned char * code = de.defuc->getCode();
          a.db(code[i]);
      }      
      info.encode_pcode.push_back(en);
      delete de.defuc;
  } 
}

void VMHandle::read_pc_dword(handle_info &info)
{
  if (sign)
  {
    a.mov(eax,dword_ptr(esi));
    a.add(esi,4);
  }
  else
  {
    a.mov(eax,dword_ptr(esi,-4));
    a.sub(esi,4);
  }

  info.type = READ_DWORD;
  int r = rand()%alg_vcode_count;
  vcode_encryption en;
  vcode_decryption de;
  en.key = 0;
  for (int i = 0; i < r; ++i)
  {
      algorithms_vcode fuc = alg_vcode_fuc_array[rand()%alg_vcode_count];
      fuc(en,de,eax,ebx);
      for (int i = 0; i < de.defuc->getCodeSize(); ++i)
      {
          unsigned char * code = de.defuc->getCode();
          a.db(code[i]);
      }      
      info.encode_pcode.push_back(en);
      delete de.defuc;
  } 
}

void VMHandle::read_pc_qword(handle_info &info)
{
  if (sign)
  {
    a.mov(nax,qword_ptr(nsi));
    a.add(nsi,4);
  }
  else
  {
    a.mov(nax,qword_ptr(nsi,-8));
    a.sub(nsi,8);
  }

  info.type = READ_QWORD;
  int r = rand()%alg_vcode_count;
  vcode_encryption en;
  vcode_decryption de;
  en.key = 0;
  for (int i = 0; i < r; ++i)
  {
      algorithms_vcode fuc = alg_vcode_fuc_array[rand()%alg_vcode_count];
      fuc(en,de,nax,nbx);
      for (int i = 0; i < de.defuc->getCodeSize(); ++i)
      {
          unsigned char * code = de.defuc->getCode();
          a.db(code[i]);
      }      
      info.encode_pcode.push_back(en);
      delete de.defuc;
  }  
}

handle_info VMHandle::b_read_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_read_stack");
#endif
  a.bind(l_b_read_stack);
  info.label = &l_b_read_stack;
  full_handle_info(info,FULL_BEGIN);

#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif

  a.mov(al,byte_ptr(nax,nbp));
  a.sub(nbp,1);
  a.mov(byte_ptr(nbp),al);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_read_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_read_stack");
#endif
  a.bind(l_w_read_stack);
  info.label = &l_w_read_stack;
  full_handle_info(info,FULL_BEGIN);

#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif

  a.mov(ax,word_ptr(nbp,nax));
  a.sub(nbp,2);
  a.mov(word_ptr(nbp),ax);
  a.jmp(l_check_stack);

  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_read_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_read_stack");
#endif
  a.bind(l_d_read_stack);
  info.label = &l_d_read_stack;
  full_handle_info(info,FULL_BEGIN);

#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif

  a.mov(nax,dword_ptr(nbp,nax));
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),eax);
  a.jmp(l_check_stack);

  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_read_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_read_stack");
#endif
  a.bind(l_q_read_stack);
  info.label = &l_q_read_stack;
  full_handle_info(info,FULL_BEGIN);

#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif

  a.mov(nax,qword_ptr(nbp,nax));
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
  a.jmp(l_check_stack);

  info.size = a.getCodeSize()-info.size;
  return info;
}


handle_info VMHandle::initialization(long pcode_base)
{
  handle_info info;
  a.bind(l_initialization);
  info.label = &l_initialization;
  full_handle_info(info,FULL_BEGIN);

  a.pushf();
#ifndef PROTECT_X64
  a.pushad();
#else
  a.push(nax);
  a.push(ndx);
  a.push(ncx);
  a.push(nbx);
  a.push(nsp);
  a.push(nbp);
  a.push(nsi);
  a.push(ndi);
  a.push(r8);
  a.push(r9);
  a.push(r10);
  a.push(r11);
  a.push(r12);
  a.push(r13);
  a.push(r14);
  a.push(r15);
#endif

  a.mov(nbp,nsp);
#ifndef PROTECT_X64
  a.sub(nsp,0xc0);
#else
  a.sub(nsp,0xc0 * 2);
#endif
  a.mov(ndi,nsp);
  a.mov(nsi,pcode_base);
  a.jmp(l_dispatch);

  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_write_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_write_stack");
#endif
  a.bind(l_b_write_stack);
  info.label = &l_b_write_stack;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif
  a.mov(dl,byte_ptr(nbp));
  a.mov(byte_ptr(nbp,nax),dl);
  //a.add(nbp,1);
  a.inc(nbp);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}
handle_info VMHandle::w_write_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_write_stack");
#endif  
  a.bind(l_w_write_stack);
  info.label = &l_w_write_stack;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif
  a.mov(dx,word_ptr(nbp));
  a.mov(word_ptr(nbp,nax),dx);
  a.add(nbp,2);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_write_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_write_stack");
#endif  
  a.bind(l_d_write_stack);
  info.label = &l_d_write_stack;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif
  a.mov(edx,dword_ptr(nbp));
  a.mov(dword_ptr(nbp,nax),edx);
  a.add(nbp,4);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_write_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_write_stack");
#endif  
  a.bind(l_q_write_stack);
  info.label = &l_q_write_stack;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  read_pc_dword(info);
#else
  read_pc_qword(info);
#endif
  a.mov(ndx,qword_ptr(nbp));
  a.mov(qword_ptr(nbp,nax),ndx);
  a.add(nbp,8);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_push_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_push_reg");
#endif  
  a.bind(l_b_push_reg);
  info.label = &l_b_push_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(al,byte_ptr(ndi,nax));
  a.dec(nbp);
  a.mov(byte_ptr(nbp),al);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_puah_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_push_reg");
#endif
  a.bind(l_w_push_reg);
  info.label = &l_w_push_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(ax,word_ptr(ndi,nax));
  a.sub(nbp,2);
  a.mov(word_ptr(nbp),ax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_push_reg()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_push_reg");
#endif    
  a.bind(l_d_push_reg);
  info.label = &l_d_push_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(eax,dword_ptr(ndi,nax));
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),eax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_push_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_push_reg");
#endif  
  a.bind(l_q_push_reg);
  info.label = &l_q_push_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(al,qword_ptr(ndi,nax));
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_pop_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_pop_reg");
#endif  
  a.bind(l_b_pop_reg);
  info.label = &l_b_pop_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(dl,byte_ptr(nbp));
  a.mov(byte_ptr(ndi,nax),dl);
  a.inc(nbp);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_pop_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_pop_reg");
#endif  
  a.bind(l_w_pop_reg);
  info.label = &l_w_pop_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(dx,word_ptr(nbp));
  a.mov(word_ptr(ndi,nax),dx);
  a.add(nbp,2);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_pop_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_pop_reg");
#endif  
  a.bind(l_d_pop_reg);
  info.label = &l_d_pop_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(edx,dword_ptr(nbp));
  a.mov(dword_ptr(ndi,nax),edx);
  a.add(nbp,4);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_pop_reg()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_pop_reg");
#endif  
  a.bind(l_q_pop_reg);
  info.label = &l_q_pop_reg;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.movzx(nax,al);
  a.mov(ndx,qword_ptr(nbp));
  a.mov(qword_ptr(ndi,nax),ndx);
  a.add(nbp,8);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_push_imm()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_push_imm");
#endif  
  a.bind(l_b_push_imm);
  info.label = &l_b_push_imm;
  full_handle_info(info,FULL_BEGIN);

  read_pc_byte(info);

  a.dec(nbp);
  a.mov(byte_ptr(nbp),al);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_push_imm()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_push_imm");
#endif  
  a.bind(l_w_push_imm);
  info.label = &l_w_push_imm;
  full_handle_info(info,FULL_BEGIN);

  read_pc_word(info);

  a.sub(nbp,2);
  a.mov(word_ptr(nbp),ax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_push_imm()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_push_imm");
#endif    
  a.bind(l_d_push_imm);
  info.label = &l_d_push_imm;
  full_handle_info(info,FULL_BEGIN);

  read_pc_dword(info);

  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),eax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_push_imm()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_push_imm");
#endif    
  a.bind(l_q_push_imm);
  info.label = &l_q_push_imm;
  full_handle_info(info,FULL_BEGIN);

  read_pc_qword(info);

  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_shl() //ebp 俩个byte  变成 5个byte 栈顶是eflag
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_shl");
#endif  
  a.bind(l_b_shl);
  info.label = &l_b_shl;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(al,byte_ptr(nbp));
  a.shl(al,cl);
  a.mov(byte_ptr(nbp),al);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_shl() //栈顶3个byte变成6个Byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_shl");
#endif  
  a.bind(l_w_shl);
  info.label = &l_w_shl;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(ax,word_ptr(nbp));
  a.shl(ax,cl);
  a.mov(word_ptr(nbp),ax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_shl() //5 byte  to  8 byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_shl");
#endif
  
  a.bind(l_d_shl);
  info.label = &l_d_shl;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(eax,dword_ptr(nbp));
  a.shl(eax,cl);
  a.mov(dword_ptr(nbp),eax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_shl() //9 byte to 16 byte
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_shl");
#endif    
  a.bind(l_q_shl);
  info.label = &l_q_shl;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(nax,qword_ptr(nbp));
  a.shl(nax,cl);
  a.mov(qword_ptr(nbp),nax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_shr()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_shr");
#endif  
  a.bind(l_b_shr);
  info.label = &l_b_shr;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(al,byte_ptr(nbp));
  a.shr(al,cl);
  a.mov(byte_ptr(nbp),al);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_shr()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_shr");
#endif  
  a.bind(l_w_shr);
  info.label = &l_w_shr;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(ax,word_ptr(nbp));
  a.shr(ax,cl);
  a.mov(word_ptr(nbp),ax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_shr()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_shr");
#endif  
  a.bind(l_d_shr);
  info.label = &l_d_shr;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(eax,dword_ptr(nbp));
  a.shr(eax,cl);
  a.mov(dword_ptr(nbp),eax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_shr()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_shr");
#endif  
  a.bind(l_q_shr);
  info.label = &l_q_shr;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(nax,qword_ptr(nbp));
  a.shl(nax,cl);
  a.mov(qword_ptr(nbp),nax);
  a.pushf();
#ifndef PROTECT_X64
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#else
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::shld() //9byte to 8byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"shld");
#endif
  a.bind(l_shld);
  info.label = &l_shld;
  full_handle_info(info,FULL_BEGIN);
  a.mov(eax,dword_ptr(nbp));
  a.mov(edx,dword_ptr(nbp,4));
  a.mov(cl,byte_ptr(nbp,8));
  a.inc(nbp);
  a.shld(eax,edx,cl);
  a.mov(dword_ptr(nbp,4),eax);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,4);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::shrd()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"shrd");
#endif  
  a.bind(l_shrd);
  info.label = &l_shrd;
  full_handle_info(info,FULL_BEGIN);
  a.mov(eax,dword_ptr(nbp));
  a.mov(edx,dword_ptr(nbp,4));
  a.mov(cl,byte_ptr(nbp,8));
  a.inc(nbp);
  a.shrd(eax,edx,cl);
  a.mov(dword_ptr(nbp,4),eax);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,4);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_nand() //2byte to 5byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_nand");
#endif  
  a.bind(l_b_nand);
  info.label = &l_b_nand;
  full_handle_info(info,FULL_BEGIN);
  a.mov(al,byte_ptr(nbp));
  a.not_(al);
  a.inc(nbp);
  a.mov(dl,byte_ptr(nbp));
  a.not_(dl);
  a.and_(al,dl);
  a.mov(byte_ptr(nbp),al);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_nand() //4byte to 6byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_nand");
#endif
  a.bind(l_w_nand);
  info.label = &l_w_nand;
  full_handle_info(info,FULL_BEGIN);
  a.mov(ax,word_ptr(nbp));
  a.not_(ax);
  a.add(nbp,2);
  a.mov(dx,word_ptr(nbp));
  a.not_(dx);
  a.and_(ax,dx);
  a.mov(word_ptr(nbp),ax);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_nand() //4 byte to 8 byte
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_nand");
#endif  
  a.bind(l_d_nand);
  info.label = &l_d_nand;
  full_handle_info(info,FULL_BEGIN);
  a.mov(eax,dword_ptr(nbp));
  a.not_(eax);
  a.add(nbp,4);
  a.mov(edx,dword_ptr(nbp));
  a.not_(edx);
  a.and_(eax,edx);
  a.mov(dword_ptr(nbp),eax);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_nand()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_nand");
#endif  
  a.bind(l_q_nand);
  info.label = &l_q_nand;
  full_handle_info(info,FULL_BEGIN);
  a.mov(nax,qword_ptr(nbp));
  a.not_(nax);
  a.sub(nbp,8);
  a.mov(ndx,qword_ptr(nbp));
  a.not_(ndx);
  a.and_(nax,ndx);
  a.mov(qword_ptr(nbp),nax);
#ifdef PROTECT_X64
  a.pushf();
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.pushf();
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::set_pc()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"set_pc");
#endif
  a.bind(l_set_pc);
  info.label = &l_set_pc;
  full_handle_info(info,FULL_BEGIN);
#ifdef PROTECT_X64
  a.mov(nax,qword_ptr(nbp));
  a.mov(nsi,nax);
  a.add(nbp,8);
#else
  a.mov(nax,dword_ptr(nbp));
  a.mov(nsi,nax);
  a.add(nbp,4);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  
  return info;
}

handle_info VMHandle::ret()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"ret");
#endif    
    a.bind(l_ret);
    info.label = &l_ret;
    full_handle_info(info,FULL_BEGIN);
    a.mov(nsp,nbp);
#ifdef PROTECT_X64
    a.pop(r15);
    a.pop(r14);
    a.pop(r13);
    a.pop(r12);
    a.pop(r11);
    a.pop(r10);
    a.pop(r9);
    a.pop(r8);
#endif
    a.pop(ndi);
    a.pop(nsi);
    //a.pop(nsp);
    a.pop(nbp);
    a.pop(nbx);
    a.pop(ndx);
    a.pop(ncx);
    a.pop(nax);
    a.popf();
    a.ret();
    info.size = a.getCodeSize()-info.size;
    return info;
}

handle_info VMHandle::push_stack_top_base()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"push_stack_top_base");
#endif  
  a.bind(l_push_stack_top_base);
  info.label = &l_push_stack_top_base;
  full_handle_info(info,FULL_BEGIN);
  
  a.mov(nax,nbp);
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::in()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"in");
#endif
  a.bind(l_in);
  info.label = &l_in;
  full_handle_info(info,FULL_BEGIN);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::rdtsc()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"rdtsc");
#endif  
  a.bind(l_rdtsc);
  info.label = &l_rdtsc;
  full_handle_info(info,FULL_BEGIN);
  a.rdtsc();

#ifdef PROTECT_X64
  a.sub(nbp,8*2);
  a.mov(qword_ptr(nbp),ndx);
  a.mov(qword_ptr(nbp,8),nax);
#else
  a.sub(nbp,4*2);
  a.mov(dword_ptr(nbp),ndx);
  a.mov(dword_ptr(nbp,4),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::cpuid()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"cpuid");
#endif  
  a.bind(l_cpuid);
  info.label = &l_cpuid;
  full_handle_info(info,FULL_BEGIN);
  a.cpuid();

#ifdef PROTECT_X64
  a.sub(nbp,4*8);
  a.mov(qword_ptr(nbp,8*3),nax);
  a.mov(qword_ptr(nbp,8*2),nbx);
  a.mov(qword_ptr(nbp,8),ncx);
  a.mov(qword_ptr(nbp),ndx);
#else
  a.sub(nbp,4*4);
  a.mov(dword_ptr(nbp,4*3),nax);
  a.mov(dword_ptr(nbp,4*2),nbx);
  a.mov(dword_ptr(nbp,4),ncx);
  a.mov(dword_ptr(nbp),ndx);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::check_stack()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"check_stack");
#endif  
  a.bind(l_check_stack);
  info.label = &l_check_stack;

  unsigned char * code = a.getCode();
  info.size   = a.getCodeSize();
  info.buf    = &code[a.getCodeSize()];
  info.offset = a.getOffset();

#ifdef PROTECT_X64
  int align = 8;
#else
  int align = 4;
#endif

  a.lea(nax,ptr(ndi,REG_NUMBER * align));
  a.cmp(nbp,nax);
  a.ja(l_dispatch);
  a.mov(ndx,nsp);
  a.lea(ncx,ptr(ndi,REG_NUMBER * align + 4));
  a.sub(ncx,ndx);
  a.jmp(l_dispatch);

  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_read_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_read_mem");
#endif  
  a.bind(l_b_read_mem);
  info.label = &l_b_read_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
  a.add(nbp,3);
#else
  a.mov(nax,qword_ptr(nbp));
  a.add(nbp,7);
#endif
  a.mov(al,byte_ptr(nax));
  a.mov(byte_ptr(nbp),al);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_read_mem()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_read_mem");
#endif    
  a.bind(l_w_read_mem);
  info.label = &l_w_read_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
  a.add(nbp,2);
#else
  a.mov(nax,qword_ptr(nbp));
  a.add(nbp,6);
#endif
  a.mov(ax,word_ptr(nax));
  a.mov(word_ptr(nbp),ax);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_read_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_read_mem");
#endif  
  a.bind(l_d_read_mem);
  info.label = &l_d_read_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
#else
  a.mov(nax,qword_ptr(nbp));
  a.add(nbp,4);
#endif
  a.mov(eax,dword_ptr(nax));
  a.mov(dword_ptr(nbp),eax);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_read_mem()
{
    handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_read_mem");
#endif    
  a.bind(l_q_read_mem);
  info.label = &l_q_read_mem;
  full_handle_info(info,FULL_BEGIN);
  a.mov(nax,qword_ptr(nbp));
  a.mov(nax,qword_ptr(nax));
  a.mov(qword_ptr(nbp),nax);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_write_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_write_mem");
#endif  
  a.bind(l_b_write_mem);
  info.label = &l_b_write_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
  a.mov(dl,byte_ptr(nbp,4));
  a.add(nbp,5);
#else
  a.mov(nax,qword_ptr(nbp));
  a.mov(dl,byte_ptr(nbp,8));
  a.add(nbp,9);
#endif
  a.mov(byte_ptr(nax),dl);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_write_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_write_mem");
#endif  
  a.bind(l_w_write_mem);
  info.label = &l_w_write_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
  a.mov(dx,word_ptr(nbp,4));
  a.add(nbp,6);
#else
  a.mov(nax,qword_ptr(nbp));
  a.mov(dx,word_ptr(nbp,8));
  a.add(nbp,10);
#endif
  a.mov(byte_ptr(nax),dx);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_write_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_write_mem");
#endif  
  a.bind(l_d_write_mem);
  info.label = &l_d_write_mem;
  full_handle_info(info,FULL_BEGIN);
#ifndef PROTECT_X64
  a.mov(nax,dword_ptr(nbp));
  a.mov(ndx,dword_ptr(nbp,4));
  a.add(nbp,8);
#else
  a.mov(nax,qword_ptr(nbp));
  a.mov(ndx,dword_ptr(nbp,8));
  a.add(nbp,12);
#endif
  a.mov(dword_ptr(nax),ndx);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_write_mem()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_write_mem");
#endif  
  a.bind(l_q_write_mem);
  info.label = &l_q_write_mem;
  full_handle_info(info,FULL_BEGIN);

  a.mov(nax,qword_ptr(nbp));
  a.mov(ndx,qword_ptr(nbp,8));
  a.add(nbp,16);

  a.mov(qword_ptr(nax),ndx);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_push_imm_sx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_push_imm_sx");
#endif  
  a.bind(l_b_push_imm_sx);
  info.label = &l_b_push_imm_sx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_byte(info);
  a.movsx(nax,al);
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_push_imm_sx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_push_imm_sx");
#endif  
  a.bind(l_w_push_imm_sx);
  info.label = &l_w_push_imm_sx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_word(info);
  a.movsx(nax,ax);
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_push_imm_sx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_push_imm_sx");
#endif  
  a.bind(l_d_push_imm_sx);
  info.label = &l_d_push_imm_sx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_dword(info);
  //a.movsx(nax,eax);
#ifdef PROTECT_X64
  a.and_(nax,0xFFFFFFFF00000000);
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_push_imm_zx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_push_imm_zx");
#endif  
  a.bind(l_b_push_imm_zx);
  info.label = &l_b_push_imm_zx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_byte(info);
  a.movzx(nax,al);
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_push_imm_zx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_push_imm_zx");
#endif  
  a.bind(l_w_push_imm_zx);
  info.label = &l_w_push_imm_zx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_word(info);
  a.movzx(nax,ax);
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_push_imm_zx()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_push_imm_zx");
#endif  
  a.bind(l_d_push_imm_zx);
  info.label = &l_d_push_imm_zx;
  full_handle_info(info,FULL_BEGIN);
  read_pc_dword(info);
#ifdef PROTECT_X64
  a.and_(nax,0x00000000FFFFFFFF);  
  a.sub(nbp,8);
  a.mov(qword_ptr(nbp),nax);
#else
  a.sub(nbp,4);
  a.mov(dword_ptr(nbp),nax);
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}


handle_info VMHandle::b_add()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_add");
#endif  
  a.bind(l_b_add);
  info.label = &l_b_add;
  full_handle_info(info,FULL_BEGIN);
  a.mov(al,byte_ptr(nbp));
  a.add(byte_ptr(nbp,1),al);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,7);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,3);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_add()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_add");
#endif  
  a.bind(l_w_add);
  info.label = &l_w_add;
  full_handle_info(info,FULL_BEGIN);
  a.mov(ax,word_ptr(nbp));
  a.add(word_ptr(nbp,2),ax);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,6);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,2);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_add()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_add");
#endif  
  a.bind(l_d_add);
  info.label = &l_d_add;
  full_handle_info(info,FULL_BEGIN);
  a.mov(nax,dword_ptr(nbp));
  a.add(dword_ptr(nbp,4),nax);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,4);
  a.pop(qword_ptr(nbp));
#else
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_add()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_add");
#endif  
  a.bind(l_q_add);
  info.label = &l_q_add;
  full_handle_info(info,FULL_BEGIN);
  a.mov(nax,qword_ptr(nbp));
  a.add(qword_ptr(nbp,8),nax);
  a.pushf();

  a.pop(qword_ptr(nbp));

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::pop_stack_top_base()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"pop_stack_top_base");
#endif  
  a.bind(l_pop_stack_top_base);
  info.label = &l_pop_stack_top_base;
  full_handle_info(info,FULL_BEGIN);
#ifdef PROTECT_X64
  a.mov(nbp,qword_ptr(nbp));
#else
  a.mov(nbp,dword_ptr(nbp));
#endif

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::b_rol()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_rol");
#endif  
  a.bind(l_b_rol);
  info.label = &l_b_rol;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);

  a.mov(al,byte_ptr(nbp));
  
  a.rol(al,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_rol()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_rol");
#endif  
  a.bind(l_w_rol);
  info.label = &l_w_rol;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(ax,word_ptr(nbp));
  a.rol(ax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_rol()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_rol");
#endif  
  a.bind(l_d_rol);
  info.label = &l_d_rol;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(eax,dword_ptr(nbp));
  a.rol(eax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_rol()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_rol");
#endif  
  a.bind(l_q_rol);
  info.label = &l_q_rol;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(nax,qword_ptr(nbp));
  a.rol(nax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}


 
handle_info VMHandle::b_ror()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"b_ror");
#endif  
  a.bind(l_b_ror);
  info.label = &l_b_ror;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);

  a.mov(al,byte_ptr(nbp));
  
  a.ror(al,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::w_ror()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"w_ror");
#endif  
  a.bind(l_w_ror);
  info.label = &l_w_ror;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(ax,word_ptr(nbp));
  a.ror(ax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::d_ror()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"d_ror");
#endif  
  a.bind(l_d_ror);
  info.label = &l_d_ror;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(eax,dword_ptr(nbp));
  a.ror(eax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::q_ror()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"q_ror");
#endif  
  a.bind(l_q_ror);
  info.label = &l_q_ror;
  full_handle_info(info,FULL_BEGIN);
  a.mov(cl,byte_ptr(nbp));
  a.inc(nbp);
  a.mov(nax,qword_ptr(nbp));
  a.ror(nax,cl);
  a.pushf();
#ifdef PROTECT_X64
  a.sub(nbp,8);
  a.pop(qword_ptr(nbp));
#else
  a.sub(nbp,4);
  a.pop(dword_ptr(nbp));
#endif
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}


handle_info VMHandle::set_key()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"set_key");
#endif  
  a.bind(l_set_key);
  info.label = &l_set_key;
  full_handle_info(info,FULL_BEGIN);
  
#ifdef PROTECT_X64
  a.mov( nbx,qword_ptr( nbp ) );
  a.add(nbp,8);
#else
  a.mov( nbx,dword_ptr( nbp ) );
  a.add(nbp,4);
#endif

#ifdef PROTECT_X64
  a.mov(nax,qword_ptr(nbp));
  a.mov(nsi,nax);
  a.add(nbp,8);
#else
  a.mov(nax,dword_ptr(nbp));
  a.mov(nsi,nax);
  a.add(nbp,4);
#endif
  
  a.jmp(l_dispatch);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::run_stack_code()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"run_stack_code");
#endif
  a.bind(l_run_stack_code);
  info.label = &l_run_stack_code;
  full_handle_info(info,FULL_BEGIN);

  a.mov(al,byte_ptr( nbp ));
  a.movzx(nax,al);
  a.inc(nbp);
  a.mov(ndx,nbp);
  a.add(nbp,nax);

  a.call(ndx);

  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

handle_info VMHandle::fstsw()
{
  handle_info info;
#ifdef _DEBUG
  strcpy(info.handle_name,"fstsw");
#endif
  a.bind(l_fstsw);
  info.label = &l_fstsw;
  full_handle_info(info,FULL_BEGIN);

  a.sub(nbp,2);
  a.fstsw(ax);
  a.mov(word_ptr(nbp),ax);
  a.jmp(l_check_stack);
  info.size = a.getCodeSize()-info.size;
  return info;
}

#ifdef _DEBUG
handle_info VMHandle::int3()
{
  handle_info info;
  strcpy(info.handle_name,"int3");
  a.bind(l_int3);
  info.label = &l_int3;

  full_handle_info(info,FULL_BEGIN);
  a.int3();
  a.jmp(l_dispatch);
  info.size = a.getCodeSize()-info.size;
  return info;
}
#endif

```

`VMHandle.h`:

```h
#ifndef _VMHANDLE_H_
#define _VMHANDLE_H_

#include <stdio.h>
#include <list>
#include <vector>
#include "AsmJit/AsmJit.h"
using namespace AsmJit;

#define REG_NUMBER         25 //虚拟机寄存器数量
#define VMSTACK_MIN_COUNT  25
/* 32位 eax,ebx,ecx,edx,ebp,esi,edi,eflag 和 8个临时寄存器 + 跳转寄存器 + 密钥寄存器 */

typedef struct _pcode_encryption_
{
  long key;
  Assembler *enfuc;
  typedef void ( *MyFn )( void *,void * );
  MyFn fn;
}vcode_encryption;

typedef struct _pcode_decryption_
{
    Assembler *defuc;
}vcode_decryption;

typedef struct _encryption_  //加密在PCODE的时候加密
{
  int key;
  Compiler  *enfuc;  //ebx的加解
  typedef void ( *MyFn )( void * );
  MyFn en_fn;
}encryption;

typedef struct _decryption_  //解密嵌入程序
{
  Assembler  *defuc; //这个是解密Key的
}decryption;

////////////类型
#define READ_BYTE  1
#define READ_WORD  2
#define READ_DWORD 4
#define READ_QWORD 8

typedef struct _handle_info
{
    Label *label; //标签指针

    char handle_name[20];

    unsigned char *buf;
    unsigned long size;
    unsigned long offset;
    unsigned long type; //1-8是从esi读取的字节

    std::vector <encryption> encode;
    std::vector <decryption> decode_key;
    std::list <vcode_encryption> encode_pcode;
    std::list <vcode_decryption> decode_pcode;
  
}handle_info;

class VMHandle{
public:
	VMHandle();
	~VMHandle();
    //
    Assembler a;
    long key;
    bool sign;

    void full_handle_info( handle_info & info, char flag );

    handle_info set_pc();
    handle_info push_stack_top_base();
    handle_info pop_stack_top_base();
    handle_info run_stack_code();
    handle_info check_stack();
    handle_info set_key();

    handle_info initialization(long pcode_base); //pcode地址
    handle_info dispatch(long table_addr);
    handle_info ret();

	handle_info b_read_stack(); //byte
	handle_info w_read_stack(); //word
	handle_info d_read_stack(); //dword
    handle_info q_read_stack();

    handle_info b_write_stack();
    handle_info w_write_stack();
    handle_info d_write_stack();
    handle_info q_write_stack();

    handle_info b_push_reg();
    handle_info w_puah_reg();
    handle_info d_push_reg();
    handle_info q_push_reg();

    handle_info b_pop_reg();
    handle_info w_pop_reg();
    handle_info d_pop_reg();
    handle_info q_pop_reg();

    handle_info b_push_imm();
    handle_info w_push_imm();
    handle_info d_push_imm();
    handle_info q_push_imm();

    handle_info b_shl();
    handle_info w_shl();
    handle_info d_shl();
    handle_info q_shl();

    handle_info b_shr();
    handle_info w_shr();
    handle_info d_shr();
    handle_info q_shr();

    handle_info shld();
    handle_info shrd();

    handle_info b_nand();
    handle_info w_nand();
    handle_info d_nand();
    handle_info q_nand();

    handle_info b_read_mem();
    handle_info w_read_mem();
    handle_info d_read_mem();
    handle_info q_read_mem();

    handle_info b_write_mem();
    handle_info w_write_mem();
    handle_info d_write_mem();
    handle_info q_write_mem();

    handle_info b_push_imm_sx();
    handle_info w_push_imm_sx();
    handle_info d_push_imm_sx();
    handle_info b_push_imm_zx();
    handle_info w_push_imm_zx();
    handle_info d_push_imm_zx();
    
    handle_info b_add();
    handle_info w_add();
    handle_info d_add();
    handle_info q_add();

    handle_info b_rol();
    handle_info w_rol();
    handle_info d_rol();
    handle_info q_rol();

    handle_info b_ror();
    handle_info w_ror();
    handle_info d_ror();
    handle_info q_ror();

    handle_info b_bool();
    handle_info w_bool();
    handle_info d_bool();
    handle_info q_bool();

    handle_info cpuid();
    handle_info in();
    handle_info rdtsc();
    handle_info fstsw();
    handle_info int3();

    ///////label/////
    Label l_set_pc;
    Label l_push_stack_top_base;
    Label l_pop_stack_top_base;
    Label l_run_stack_code;
    Label l_check_stack;
    Label l_set_key;
    Label l_key_dispatch;

    Label l_initialization;
    Label l_dispatch;
    Label l_ret;

    Label l_b_read_mem;
    Label l_w_read_mem;
    Label l_d_read_mem;
    Label l_q_read_mem;

    Label l_b_write_mem;
    Label l_w_write_mem;
    Label l_d_write_mem;
    Label l_q_write_mem;
    
	Label l_b_read_stack; //byte
	Label l_w_read_stack; //word
	Label l_d_read_stack; //dword
    Label l_q_read_stack;

    Label l_b_write_stack;
    Label l_w_write_stack;
    Label l_d_write_stack;
    Label l_q_write_stack;

    Label l_b_push_reg;
    Label l_w_push_reg;
    Label l_d_push_reg;
    Label l_q_push_reg;

    Label l_b_pop_reg;
    Label l_w_pop_reg;
    Label l_d_pop_reg;
    Label l_q_pop_reg;

    Label l_b_push_imm;
    Label l_w_push_imm;
    Label l_d_push_imm;
    Label l_q_push_imm;

    Label l_b_shl;
    Label l_w_shl;
    Label l_d_shl;
    Label l_q_shl;

    Label l_b_shr;
    Label l_w_shr;
    Label l_d_shr;
    Label l_q_shr;

    Label l_shld;
    Label l_shrd;

    Label l_b_nand;
    Label l_w_nand;
    Label l_d_nand;
    Label l_q_nand;

    Label l_b_push_imm_sx;
    Label l_w_push_imm_sx;
    Label l_d_push_imm_sx;
    Label l_b_push_imm_zx;
    Label l_w_push_imm_zx;
    Label l_d_push_imm_zx;
    
    Label l_b_add;
    Label l_w_add;
    Label l_d_add;
    Label l_q_add;

    Label l_b_rol;
    Label l_w_rol;
    Label l_d_rol;
    Label l_q_rol;
    Label l_b_ror;
    Label l_w_ror;
    Label l_d_ror;
    Label l_q_ror;

    Label l_in;
    Label l_rdtsc;
    Label l_cpuid;
    Label l_fstsw;
    Label l_int3;

private:
    void read_pc_byte (handle_info &info);
    void read_pc_word (handle_info &info);
    void read_pc_dword(handle_info &info);
    void read_pc_qword(handle_info &info);
};

#endif /* _VMHANDLE_H_ */

```

`VirtualMachine.cpp`:

```cpp
/*
 *   Copyrigth (C) Mon May 20 10:39:21 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#include "VirtualMachine.h"
#include "PCode.hpp"
#define _STDINT_H
#include "Libudis86/udis86.h"
#include "algorithms.hpp"

VirtualMachine::VirtualMachine(long base)
{
  build_vm_handle(base);
}

VirtualMachine::VirtualMachine(long base, bool sign)
{
  handle.sign = sign;
  build_vm_handle(base);
}

VirtualMachine::~VirtualMachine()
{
  for (list <ppcode_block_info>::iterator iter = pcode_list.begin(); iter != pcode_list.end(); ++iter)
  {
    ppcode_block_info info = *iter;
    delete info;
  }
  
  for (list <handle_info>::iterator iter = handle_info_list.begin(); iter != handle_info_list.end(); ++iter)
  {
    handle_info hi = *iter;
   
    for (vector <encryption>::iterator eiter = hi.encode.begin(); eiter != hi.encode.end();++eiter) //删除encode对象
    {
      if (eiter->enfuc)
      {
        delete eiter->enfuc;
        eiter->enfuc = NULL;
      }
    }

    for (vector <decryption>::iterator diter = hi.decode_key.begin(); diter != hi.decode_key.end();++diter) //删除decode对象
    {
      if (diter->defuc)
      {
        delete diter->defuc;
        diter->defuc = NULL;
      }
    }

    for (list <vcode_encryption>::iterator eiter = hi.encode_pcode.begin(); eiter != hi.encode_pcode.end();++eiter)
    {
      if (eiter->enfuc)
      {
        delete eiter->enfuc;
        eiter->enfuc = NULL;
      }
    }

    for (list <vcode_decryption>::iterator diter = hi.decode_pcode.begin(); diter != hi.decode_pcode.end();++diter)
    {
      if (diter->defuc)
      {
        delete diter->defuc;
        diter->defuc = NULL;
      }
    }
  }
}
 
typedef handle_info (VMHandle::*v_handle)();

void VirtualMachine::build_vm_handle(long base)
{
  v_handle handle_array[] =
  {
    &VMHandle::b_read_stack,
    &VMHandle::w_read_stack,
    &VMHandle::d_read_stack,
    
    &VMHandle::b_write_stack,
    &VMHandle::w_write_stack,
    &VMHandle::d_write_stack,
    
    &VMHandle::b_push_reg,
    &VMHandle::w_puah_reg,
    &VMHandle::d_push_reg,
   
    &VMHandle::b_pop_reg,
    &VMHandle::w_pop_reg,
    &VMHandle::d_pop_reg,
    
    &VMHandle::b_push_imm,
    &VMHandle::w_push_imm,
    &VMHandle::d_push_imm,
    
    &VMHandle::b_shl,
    &VMHandle::w_shl,
    &VMHandle::d_shl,
    
    &VMHandle::b_shr,
    &VMHandle::w_shr,
    &VMHandle::d_shr,
    
    &VMHandle::shld,
    &VMHandle::shrd,
    &VMHandle::b_nand,
    &VMHandle::w_nand,
    &VMHandle::d_nand,
    
    &VMHandle::set_pc,
    &VMHandle::ret,
    &VMHandle::in,
    &VMHandle::rdtsc,
    &VMHandle::cpuid,
    &VMHandle::check_stack,
    &VMHandle::push_stack_top_base,
    &VMHandle::b_read_mem,
    &VMHandle::w_read_mem,
    &VMHandle::d_read_mem,
   
    &VMHandle::b_write_mem,
    &VMHandle::w_write_mem,
    &VMHandle::d_write_mem,
    
    &VMHandle::pop_stack_top_base,
    &VMHandle::b_push_imm_sx,
    &VMHandle::w_push_imm_sx,
    
    &VMHandle::b_push_imm_zx,
    &VMHandle::w_push_imm_zx,
   
    &VMHandle::b_add,
    &VMHandle::w_add,
    &VMHandle::d_add,

    &VMHandle::b_rol,
    &VMHandle::w_rol,
    &VMHandle::d_rol,
    &VMHandle::b_ror,
    &VMHandle::w_ror,
    &VMHandle::d_ror,

    &VMHandle::set_key,
    &VMHandle::run_stack_code,
    &VMHandle::fstsw
#ifdef _DEBUG
    ,&VMHandle::int3
#endif

#ifdef PROTECT_X64
    ,&VMHandle::q_read_stack,
    &VMHandle::q_write_stack,
    &VMHandle::q_push_reg,
    &VMHandle::q_pop_reg,
    &VMHandle::q_push_imm,
    &VMHandle::q_shl,
    &VMHandle::q_shr,
    &VMHandle::q_nand,
    &VMHandle::q_read_mem,
    &VMHandle::q_write_mem,
    &VMHandle::d_push_imm_sx,
    &VMHandle::d_push_imm_zx,
    &VMHandle::q_add,
    &VMHandle::q_rol,
    &VMHandle::q_ror
#endif
  };

  unsigned long handle_count = sizeof(handle_array) / sizeof (v_handle);
  printf("共有0x%x个VM_handle\n", handle_count);

  RandList<v_handle>(handle_array, handle_count);

  handle_info info;
  for (unsigned int i = 0; i < handle_count; i++)
  {
    v_handle r_fuc = handle_array[i];
    info = (handle.*r_fuc)();

#ifdef _DEBUG
    printf("0x%2x %s()\n", i, info.handle_name);
#endif

    handle_info_list.push_back(info);
  }

  long size = handle.a.getCodeSize();

  for (unsigned int i = 0; i < 0xFF; i++)  // 占位置，供full_handle_table用
  {
#ifdef PROTECT_X64
    handle.a.dq(rand());
#else
    handle.a.dd(rand());
#endif
  }
  
  dispatch_base = handle.a.getCodeSize() + base;  // VM_table后的地址

  info = handle.dispatch(base + size);

  full_handle_table(base,size);

  handle_info_list.push_back(info);
  
  handle_pcode.dispatch.encode_key   = &handle_info_list.back().encode;
  handle_pcode.dispatch.encode_pcode = &handle_info_list.back().encode_pcode;

  handle.a.relocCode(handle.a.getCode(), base);
  vm_info.base = base;
  vm_info.buf  = handle.a.getCode();
  vm_info.size = handle.a.getCodeSize();
  printf("vm_info %p, size:0x%x\n", vm_info.buf, vm_info.size);
}

void VirtualMachine::add_pcode(AsmJit::Assembler &a,PCode *code,long base,long ret_address,long v_key,long decryption_key) //true表示正
{
  using namespace AsmJit;

  int register_count = code->register_store_in.register_count;
  
  for (int i = 0; i < register_count; ++i)
  {
    switch (code->register_store_in.register_array[i])
    {
    case T_NAX:
      a.push(nax);
      break;
    case T_NBX:
      a.push(nbx);
      break;
    case T_NCX:
      a.push(ncx);
      break;
    case T_NDX:
      a.push(ndx);
      break;
    case T_NSP:
      a.push(nsp);
      break;
    case T_NBP:
      a.push(nbp);
      break;
    case T_NSI:
      a.push(nsi);
      break;
    case T_NDI:
      a.push(ndi);
      break;
    case T_EFLAG:
#ifndef PROTECT_X64
      a.pushfd();
#else
      a.pushfq();
#endif
      break;
    case T_KEY:
      a.push(v_key);
      break;
    case T_RET:
      a.push(ret_address);
      break;
#ifdef PROTECT_X64
    case T_R8:
      a.push(r8);
      break;
    case T_R9:
      a.push(r9);
      break;
    case T_R10:
      a.push(r10);
      break;
    case T_R11:
      a.push(r11);
      break;
    case T_R12:
      a.push(r12);
      break;
    case T_R13:
      a.push(r13);
      break;
    case T_R14:
      a.push(r14);
      break;
    case T_R15:
      a.push(r15);
      break;
#endif
    }
  }
      a.mov(nbx,decryption_key);
      a.mov(nbp,nsp);
#ifndef PROTECT_X64
      a.sub(nsp,REG_NUMBER * 4 + VMSTACK_MIN_COUNT * 4 );
#else
      a.sub(nsp,REG_NUMBER * 8 + VMSTACK_MIN_COUNT * 8);
#endif
      a.mov(ndi,nsp);
      if (code->pcode_info.sign)
        a.mov(nsi,base + 50);
      else
        a.mov(esi,base + 50 + code->pcode_info.offset);
      a.jmp(dispatch_base);
}


// DeDf : 1
ppcode_block_info VirtualMachine::create_function_head(long reloc_base,
                                                       long pcode_base,
                                                       PCode *pcode,
                                                       long v_key,
                                                       long Handle_i_key)
{
    printf("create_function_head():\n"
           "  reloc_base  : %x\n"
           "  pcode_base  : %x\n",
           reloc_base, pcode_base);

  using namespace AsmJit;
  ppcode_block_info info = new pcode_block_info;
  info->entry = pcode_base;
  int register_count = pcode->register_store_in.register_count;
  
  for (int i = 0; i < register_count; ++i)
  {
    switch (pcode->register_store_in.register_array[i])
    {
    case T_NAX:
      info->a.push(nax);
      break;
    case T_NBX:
      info->a.push(nbx);
      break;
    case T_NCX:
      info->a.push(ncx);
      break;
    case T_NDX:
      info->a.push(ndx);
      break;
    case T_NSP:
      info->a.push(nsp);
      break;
    case T_NBP:
      info->a.push(nbp);
      break;
    case T_NSI:
      info->a.push(nsi);
      break;
    case T_NDI:
      info->a.push(ndi);
      break;
    case T_EFLAG:
#ifndef PROTECT_X64
      info->a.pushfd();
#else
      info->a.pushfq();
#endif
      break;
    case T_KEY:
      info->a.push(v_key);
      break;

#ifdef PROTECT_X64
    case T_R8:
      info->a.push(r8);
      break;
    case T_R9:
      info->a.push(r9);
      break;
    case T_R10:
      info->a.push(r10);
      break;
    case T_R11:
      info->a.push(r11);
      break;
    case T_R12:
      info->a.push(r12);
      break;
    case T_R13:
      info->a.push(r13);
      break;
    case T_R14:
      info->a.push(r14);
      break;
    case T_R15:
      info->a.push(r15);
      break;
#endif
    }
  }
      info->a.mov(nbx,Handle_i_key);
      info->a.mov(nbp,nsp);

#ifndef PROTECT_X64
      info->a.sub(nsp,REG_NUMBER * 4 + VMSTACK_MIN_COUNT * 4);
#else
      info->a.sub(nsp,REG_NUMBER * 8 + VMSTACK_MIN_COUNT * 8);
#endif
  
  info->a.mov(ndi,nsp);
  info->a.mov(nsi,pcode_base);
  info->a.jmp(dispatch_base);
  info->a.relocCode(info->a.getCode(),reloc_base);
  info->buf  = info->a.getCode();
  info->size = info->a.getCodeSize();
  pcode_list.push_back(info);
  return info;
}

//俩个key 一个是vm_context使用的 一个是ebx使用的解密Pcode key
ppcode_block_info VirtualMachine::add_new_function(long base,PCode *code,long ret_address,long v_key,long decryption_key)
{
  using namespace AsmJit;
  
  pcode_block_info *info = new pcode_block_info;
  info->entry = base;
  add_pcode(info->a,code,base,ret_address,v_key,decryption_key);
  if (code->pcode_info.sign)
  {
    info->pcode_base = base + 50;
    long init_handle_size = 50 - info->a.getCodeSize();
    for (int i = 0; i < init_handle_size; i++)
    {
      info->a.db(0xff & rand());
    }
    for (unsigned int i = 0; i < code->pcode_info.offset; i++)
    {
      info->a.db(code->pcode_info.buf[i]);
    }
  }
  else
  {
    info->pcode_base = base + 50 + code->pcode_info.offset;
    long init_handle_size = 50 - info->a.getCodeSize();
    for (int i = 0; i < init_handle_size; i++)
    {
      info->a.db(0xff & rand());
    }
    for (unsigned int i = code->pcode_info.size - code->pcode_info.offset;
        i < code->pcode_info.size;
        i++)
    {
      info->a.db(code->pcode_info.buf[i]);
    }
  }

  info->a.relocCode(info->a.getCode(),base);
  info->buf  = info->a.getCode();
  info->size = info->a.getCodeSize();
  pcode_list.push_back(info);
  return info;
}


void VirtualMachine::full_handle_table(long base,long table_offset)
{
  unsigned char * asmbuf = handle.a.getCode();
  unsigned long * buf = (unsigned long *)(asmbuf + table_offset);
  unsigned long count = 1;

  FILE *file;
  fopen_s(&file, "VMHandleAddress.txt", "wb");

  for (list <handle_info>::iterator iter = handle_info_list.begin(); iter != handle_info_list.end(); ++iter)
  {
    pVMHandleInfo instruction = NULL;
    handle_info info = *iter;
    buf[count] = info.offset + base;
    fprintf(file, "%20s : %x\r\n", info.handle_name, buf[count]);

    if ( info.label == &handle.l_b_read_stack )
    {
        instruction = &handle_pcode.b_read_stack;
    } else  if ( info.label == &handle.l_w_read_stack )
    {
        instruction = &handle_pcode.w_read_stack;
    } else  if ( info.label == &handle.l_d_read_stack )
    {
        instruction = &handle_pcode.d_read_stack;
    } else  if ( info.label == &handle.l_b_write_stack )
    {
        instruction = &handle_pcode.b_write_stack;
    } else  if ( info.label == &handle.l_w_write_stack )
    {
        instruction = &handle_pcode.w_write_stack;
    } else  if ( info.label == &handle.l_d_write_stack )
    {
        instruction = &handle_pcode.d_write_stack;
    }  else  if ( info.label == &handle.l_b_push_reg )
    {
        instruction = &handle_pcode.b_push_reg;
    } else  if ( info.label == &handle.l_w_push_reg )
    {
        instruction = &handle_pcode.w_push_reg;
    } else  if ( info.label == &handle.l_d_push_reg )
    {
        instruction = &handle_pcode.d_push_reg;
    }  else  if ( info.label == &handle.l_b_pop_reg )
    {
        instruction = &handle_pcode.b_pop_reg;
    } else  if ( info.label == &handle.l_w_pop_reg )
    {
        instruction = &handle_pcode.w_pop_reg;
    } else  if ( info.label == &handle.l_d_pop_reg )
    {
        instruction = &handle_pcode.d_pop_reg;
    }  else  if ( info.label == &handle.l_b_push_imm )
    {
        instruction = &handle_pcode.b_push_imm;
    } else  if ( info.label == &handle.l_w_push_imm )
    {
        instruction = &handle_pcode.w_push_imm;
    } else  if ( info.label == &handle.l_d_push_imm )
    {
        instruction = &handle_pcode.d_push_imm;
    }  else  if ( info.label == &handle.l_b_shl )
    {
        instruction = &handle_pcode.b_shl;
    } else  if ( info.label == &handle.l_w_shl )
    {
        instruction = &handle_pcode.w_shl;
    } else  if ( info.label == &handle.l_d_shl )
    {
        instruction = &handle_pcode.d_shl;
    }  else  if ( info.label == &handle.l_b_shr )
    {
        instruction = &handle_pcode.b_shr;
    } else  if ( info.label == &handle.l_w_shr )
    {
        instruction = &handle_pcode.w_shr;
    } else  if ( info.label == &handle.l_d_shr )
    {
        instruction = &handle_pcode.d_shr;
    }  else  if ( info.label == &handle.l_shld )
    {
        instruction = &handle_pcode.shld;
    } else  if ( info.label == &handle.l_shrd )
    {
        instruction = &handle_pcode.shrd;
    } else  if ( info.label == &handle.l_b_nand )
    {
        instruction = &handle_pcode.b_nand;
    } else  if ( info.label == &handle.l_w_nand )
    {
        instruction = &handle_pcode.w_nand;
    } else  if ( info.label == &handle.l_d_nand )
    {
        instruction = &handle_pcode.d_nand;
    }  else  if ( info.label == &handle.l_set_pc )
    {
        instruction = &handle_pcode.set_pc;
    } else  if ( info.label == &handle.l_ret )
    {
        instruction = &handle_pcode.ret;
    } else  if ( info.label == &handle.l_in )
    {
        instruction = &handle_pcode.in;
    } else  if ( info.label == &handle.l_rdtsc )
    {
        instruction = &handle_pcode.rdtsc;
    } else  if ( info.label == &handle.l_cpuid )
    {
        instruction = &handle_pcode.cpuid;
    } else  if ( info.label == &handle.l_check_stack )
    {
        instruction = &handle_pcode.check_stack;
    } else  if ( info.label == &handle.l_dispatch )
    {
        instruction = &handle_pcode.dispatch;
    } else  if ( info.label == &handle.l_push_stack_top_base )
    {
        instruction = &handle_pcode.push_stack_top_base;
    } else if ( info.label == &handle.l_b_read_mem)
    {
        instruction = &handle_pcode.b_read_mem;
    } else if ( info.label == &handle.l_w_read_mem)
    {
        instruction = &handle_pcode.w_read_mem;
    } else if ( info.label == &handle.l_d_read_mem)
    {
        instruction = &handle_pcode.d_read_mem;
    }  else if ( info.label == &handle.l_b_write_mem)
    {
        instruction = &handle_pcode.b_write_mem;
    } else if ( info.label == &handle.l_w_write_mem)
    {
        instruction = &handle_pcode.w_write_mem;
    } else if ( info.label == &handle.l_d_write_mem)
    {
        instruction = &handle_pcode.d_write_mem;
    }  else if ( info.label == &handle.l_b_push_imm_sx )
    {
        instruction = &handle_pcode.b_push_imm_sx;
    } else if ( info.label == &handle.l_w_push_imm_sx )
    {
        instruction = &handle_pcode.w_push_imm_sx;
    }  else if ( info.label == &handle.l_b_push_imm_zx )
    {
        instruction = &handle_pcode.b_push_imm_zx;
    } else if ( info.label == &handle.l_w_push_imm_zx )
    {
        instruction = &handle_pcode.w_push_imm_zx;
    }  else if ( info.label == &handle.l_pop_stack_top_base)
    {
        instruction = &handle_pcode.pop_stack_top_base;
    } else if ( info.label == &handle.l_b_add)
    {
        instruction = &handle_pcode.b_add;
    } else if ( info.label == &handle.l_w_add)
    {
        instruction = &handle_pcode.w_add;
    } else if ( info.label == &handle.l_d_add)
    {
        instruction = &handle_pcode.d_add;
    }  else if ( info.label == &handle.l_b_rol)
    {
        instruction = &handle_pcode.b_rol;
    } else if ( info.label == &handle.l_w_rol)
    {
        instruction = &handle_pcode.w_rol;
    } else if ( info.label == &handle.l_d_rol)
    {
        instruction = &handle_pcode.d_rol;
    }  else if ( info.label == &handle.l_b_ror)
    {
        instruction = &handle_pcode.b_ror;
    } else if ( info.label == &handle.l_w_ror)
    {
        instruction = &handle_pcode.w_ror;
    } else if ( info.label == &handle.l_d_ror)
    {
        instruction = &handle_pcode.d_ror;
    } else if ( info.label == &handle.l_set_key )
    {
       instruction = &handle_pcode.set_key;
    } else if ( info.label == &handle.l_run_stack_code)
    {
        instruction = &handle_pcode.run_stack;
    } else if ( info.label == &handle.l_fstsw)
    {
        instruction = &handle_pcode.fstsw;
    }
#ifdef _DEBUG
    else if ( info.label == &handle.l_int3)
    {
        instruction = &handle_pcode.int3;
    }
#endif

#ifdef PROTECT_X64
    else if ( info.label == &handle.l_q_ror)
    {
        instruction = &handle_pcode.q_ror;
    }else  if ( info.label == &handle.l_q_read_stack )
    {
        instruction = &handle_pcode.q_read_stack;
    }  else  if ( info.label == &handle.l_q_write_stack )
    {
        instruction = &handle_pcode.q_write_stack;
    }else  if ( info.label == &handle.l_q_push_reg )
    {
        instruction = &handle_pcode.q_push_reg;
    }else  if ( info.label == &handle.l_q_pop_reg )
    {
        instruction = &handle_pcode.q_pop_reg;
    }else  if ( info.label == &handle.l_q_push_imm )
    {
        instruction = &handle_pcode.q_push_imm;
    }else  if ( info.label == &handle.l_q_shl )
    {
        instruction = &handle_pcode.q_shl;
    }else  if ( info.label == &handle.l_q_shr )
    {
        instruction = &handle_pcode.q_shr;
    }else  if ( info.label == &handle.l_q_nand )
    {
        instruction = &handle_pcode.q_nand;
    }else if ( info.label == &handle.l_q_read_mem)
    {
        instruction = &handle_pcode.q_read_mem;
    }else if ( info.label == &handle.l_q_write_mem)
    {
        instruction = &handle_pcode.q_write_mem;
    }else if ( info.label == &handle.l_d_push_imm_sx )
    {
        instruction = &handle_pcode.d_push_imm_sx;
    }else if ( info.label == &handle.l_d_push_imm_zx )
    {
        instruction = &handle_pcode.d_push_imm_zx;
    }else if ( info.label == &handle.l_q_add)
    {
        instruction = &handle_pcode.q_add;
    }else if ( info.label == &handle.l_q_rol)
    {
        instruction = &handle_pcode.q_rol;
    }
#endif

    if (instruction == NULL)
    {
      printf("!!ERROR %s:%d:%s\r\n", __FILE__, __LINE__, info.handle_name);
    }

    instruction->handle_i = (unsigned char)count++;
    instruction->encode_key = &iter->encode;
    instruction->type = info.type;
    instruction->encode_pcode = &iter->encode_pcode;
  }

  fclose(file);
}

```

`WProtect.vcproj`:

```vcproj
<?xml version="1.0" encoding="gb2312"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="WProtect"
	ProjectGUID="{6719023E-E9E6-44DF-857E-3780D184C80F}"
	RootNamespace="My1"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				AdditionalIncludeDirectories=""
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="0"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="源文件"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\1_main.cpp"
				>
			</File>
			<File
				RelativePath=".\Analysis.cpp"
				>
			</File>
			<File
				RelativePath=".\BuildVMByteCode.cpp"
				>
			</File>
			<File
				RelativePath=".\CombosVMCode.cpp"
				>
			</File>
			<File
				RelativePath=".\OutDetailedInformation.cpp"
				>
			</File>
			<File
				RelativePath=".\PCode.cpp"
				>
			</File>
			<File
				RelativePath=".\SeniorVMHandle.cpp"
				>
			</File>
			<File
				RelativePath=".\VirtualMachine.cpp"
				>
			</File>
			<File
				RelativePath=".\VMHandle.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="AsmJit"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\AsmJit\Assembl.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\AssemblerX86X64.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\CodeGenerator.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\Compiler.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\CompilerX86X64.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\CpuInfo.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\Defs.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\DefsX86X64.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\Logger.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\MemoryManager.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\MemoryMarker.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\opcode_table.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\OperandX86X64.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\Platform.cpp"
				>
			</File>
			<File
				RelativePath=".\AsmJit\Util.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="PE"
			>
			<File
				RelativePath=".\PE\PEExport.cpp"
				>
			</File>
			<File
				RelativePath=".\PE\PEFile.cpp"
				>
			</File>
			<File
				RelativePath=".\PE\PEFile.h"
				>
			</File>
			<File
				RelativePath=".\PE\PEImport.cpp"
				>
			</File>
			<File
				RelativePath=".\PE\PEReloc.cpp"
				>
			</File>
			<File
				RelativePath=".\PE\PESection.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="udis86"
			>
			<File
				RelativePath=".\Libudis86\decode.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\decode.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\extern.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\itab.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\itab.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\stdint.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\syn-att.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\syn-intel.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\syn.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\syn.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\types.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\udint.h"
				>
			</File>
			<File
				RelativePath=".\Libudis86\udis86.c"
				>
			</File>
			<File
				RelativePath=".\Libudis86\udis86.h"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`algorithms.hpp`:

```hpp
/*
*   Copyright (C) Thu Jun 20 15:58:03 2013 XiaoWei
*
*                       handsomexiaowei@gmail.com
*/

#ifndef _ALGORITHMS_H_
#define _ALGORITHMS_H_

template <class T>
void RandList(T *list, unsigned long count)  //把数据乱序后返回
{
    T t;

    while (count)
    {
        unsigned long rd = rand() % count;
        count--;

        t = list[rd];
        list[rd] = list[count];
        list[count] = t;
    }
}

#endif /* _ALGORITHMS_H_ */

```

`analysis.hpp`:

```hpp
/*
 *   Copyright (C) Wed May 29 04:00:49 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _ANALYSIS_H_
#define _ANALYSIS_H_

#include <iostream>
#include <vector>
#include <list>
#include <map>
#include "Libudis86/udis86.h"

typedef struct ANALYSIS_OPTIONS
{
	long addr;
    void *buf;
    long size;
}CodeBufferInfo,*pCodeBufferInfo;

#ifdef PC_NONE
#undef PC_NONE
#endif
#define PC_NONE -1
#define PC_RET  -2
#define PC_EXIT -3
#define PC_MEM  -4
#define PC_MIN -10000

#define PC_LABEL_MAX  10000
#define TYPE_LABEL 1
#define TYPE_ADDR  2   
#define TYPE_MEM   3
#define TYPE_RET   4
#define TYPE_CALL  5

enum OPCODE_ATTRIBUTE{
    OPCODE_ATTRIBUTE_NORMAL,
    OPCODE_ATTRIBUTE_CALL,
    OPCODE_ATTRIBUTE_EXTERNAL_CALL,
    OPCODE_ATTRIBUTE_JMP,
    OPCODE_ATTRIBUTE_EXTERNAL_JMP,
    OPCODE_ATTRIBUTE_JCC,
    OPCODE_ATTRIBUTE_EXTERNAL_JCC,
    OPCODE_ATTRIBUTE_RET,
    OPCODE_ATTRIBUTE_EXIT
};

typedef struct ASSEMBLER_PIECE_INFO   //反汇编信息 块 
{
  ud_t u;  //包含各种信息
}AssemblerInfo,*pAssemblerInfo;

typedef struct ASSEMBLER_TREE
{
  //long address; //块地址
  bool set_key;
  long key;
  long jcc_addr; //跳转到的地址
  long next_instruction; //下一条指令跳转地址 mov eax,1  jmp hello mov eax,2 hello: ret    mov eax,2就是这个
  long reloc_address;   //冲定位到
  long id; //代码块id 从0开始
  long base; //代码块开始地址  //块地址
  long size; //代码块大小

  // std::list<ud_t>asmpiect;
  long eflag;
  //pAssemblerInfo asmpiece;  //指向汇编块头
	ASSEMBLER_TREE *LeftChild; //左孩纸
	ASSEMBLER_TREE *RightChild; //右孩纸
	std::vector <ud_t> asmpiece;
}AssemblerTree,*pAssemblerTree;
 
typedef struct _AddressArray
{
  private:
   long * a_array;
   size_t a_size;

  public:
   _AddressArray(int _size)
   {
     a_array = new long[_size];
     a_size = _size;
   }
   
   ~_AddressArray()
   {
#ifndef _DEBUG  // 这里Debug版会自动释放内存！
     if(a_array != NULL)
       delete [] a_array;
#endif
   }

   long &operator[](size_t _index)
   {
     if (_index >= a_size || a_array == NULL) {
       printf("Address_Array数组访问越界");
     }
     return a_array[_index];
   }

   size_t get_size()
   {
     return a_size;
   }

   void set_size(size_t _size)
   {
     a_size = _size;
   }
}AddressArray;
      

typedef struct _CodePiece
{
  _CodePiece():is_jcc(false){}
  ~_CodePiece(){}
  void set_label(int id)
  {
    label = id;
  }
  void set_jmplabel(int jmpid)
  {
    jmp_to_label = jmpid;
  }
  void add_assemble(ud_t & ud)
  {
    piece.push_back(ud);
  }
  int get_jmplabel()
  {
    return jmp_to_label;
  }
  int get_label()
  {
    return label;
  }
  void set_is_jcc(bool _is_jcc)
  {
    is_jcc = _is_jcc;
  }
  bool get_is_jcc()
  {
    return is_jcc;
  }
  std::list<ud_t> & get_piece()
  {
    return piece;
  }

  void set_opcode_attribute(OPCODE_ATTRIBUTE attribute)
  {
      opcode_attribute = attribute;
  }
  OPCODE_ATTRIBUTE get_opcode_attribute()
  {
      return opcode_attribute;
  }

private:
  int label;
  int jmp_to_label;
  OPCODE_ATTRIBUTE opcode_attribute;
  bool is_jcc;
  std::list<ud_t> piece;
}CodePiece;


class Analysis
{
public:
    long base;
    long size;
    pAssemblerTree root;
    long block_count;
    const bool L;// = false;
    const bool R;// = true;
    //
    Analysis();
    virtual ~Analysis();
    size_t reloc_asm_address(long old_address,long new_address); //返回一个成功重定位个数 0为没找到
    void reloc_asm_address();
    AddressArray analysis_code_piece_address(pCodeBufferInfo pinfo); 
    void disasm(pCodeBufferInfo pinfo,std::vector<CodePiece> & code);
    void printf_piece(std::vector<CodePiece>& var_piece);
    pAssemblerTree add_tree(pAssemblerTree parent, pAssemblerTree child,bool l_r);
    pAssemblerTree disasm(pCodeBufferInfo pinfo);
    void set_label_address(pCodeBufferInfo pinfo,AddressArray & _addra,std::map<long,int> &_map);
    void link_tree();

    pAssemblerTree find_tree(long addr); //传递一个地址
    pAssemblerTree get_tree(long id);
    void analysis_address_table(pCodeBufferInfo pinfo,std::vector<long> & addr_entry_table,long addr_min,long addr_max);
    void clean_tree();

    void set_eflag();

    bool check_address(long addr);
};
#endif /* _ANALYSIS_H_ */

```

`clean.bat`:

```bat
del *.ncb
del *.sln
del *.suo /ah
del *.user

rd /s /q "Debug"
rd /s /q "Release"
```

`combosvmcode.hpp`:

```hpp
#ifndef COMBOSVMCODE_HPP
#define COMBOSVMCODE_HPP

#include "VMHandle.h"
#include "PCode.hpp"
#include "VOperand.hpp"

class VCombosVMCode{

public:
    enum ProtectFlag{
        EncryConst = 1 << 0,//
        EncryRegister = 1 << 1,//
        EncryInstruction = 1 << 2,
        Normal = 0
    };

    //variable area
    PCode *ptr_pcode;
    bool super_protect;          //模拟所有运算
    int  protect_flag;
    bool change_vmregister_flag;
    bool tmp_vmregister_status[8];


    //function area
    VCombosVMCode();
    VCombosVMCode(PCode * p);
    ~VCombosVMCode();

    void *get_code_buf();
    long get_code_size();

    void impact_vmregister(bool _change_vmregister)
    {
        change_vmregister_flag = _change_vmregister;
    }

    long get_tmp_vmregister()
    {
        for (int i = 0; i < sizeof(tmp_vmregister_status);i++)
        {
            if (tmp_vmregister_status[i] == false)
            {
                tmp_vmregister_status[i] = true;
#ifdef PROTECT_X64
                return T_TMP_REGISTER1 << i;
#else
                return ((T_TMP_REGISTER1 & T_ALL_TMPREGISTER) << i) | T_E32X;
#endif
            }
        }
        printf("没有可用的临时寄存器\n");
        __asm int 3;
    }
    void unlock_tmp_vmregister(long _tmp_register)
    {
        bool free = false;
        for (int i = 0;i < sizeof(tmp_vmregister_status);i++)
        {
#ifdef PROTECT_X64
            if ((_tmp_register & T_ALL_REGISTER) == (T_TMP_REGISTER1 << i))
#else
            if ((_tmp_register & T_ALL_TMPREGISTER) == ((T_TMP_REGISTER1 << i) & T_ALL_TMPREGISTER))
#endif
            {
                tmp_vmregister_status[i] = false;
                free = true;
            }
        } 
        if (free == false)
        {
            printf("没有找到需要释放临时寄存器\n");
        }
    }
    long get_tmp_vmregister_count()
    {
        int count = 0;
        for (int i = 0; i < sizeof(tmp_vmregister_status);i++)
        {
            if (tmp_vmregister_status[i] == false)
            {
                count++;
            }
        }
        return count;  
    }
    void attach_pcode(PCode * p);

    void set_vmregister_store_in(RegisterStore & store_in);
    void set_vmregister_store_out(RegisterStore & store_out);

    void save_vm_context();
    void recover_vm_context();
    void upset_register_array(RegisterStore & r);

    void run_stack();
    void pushf();
    void popf();

    void push_vsp();
    void pop_vsp();
    void push(long _register,bool _disable);
    void push(long _register);
    void pop(long _register);

    void build_byte_code(unsigned char b);
    void build_word_code(unsigned short w);
    void build_dword_code(unsigned int d); 
    void build_qword_code(unsigned long q);

    void set_pc(long _key);
    void set_pc();

    void b_push_imm(char b);
    void w_push_imm(short w);
    void d_push_imm(int d);
    void q_push_imm(long q);

    void b_push_imm_sx(char b);
    void w_push_imm_sx(short w);
    void d_push_imm_sx(int d);
    void b_push_imm_zx(char b);
    void w_push_imm_zx(short w);
    void d_push_imm_zx(int d);

    void b_read_mem();
    void w_read_mem();
    void d_read_mem();
    void q_read_mem();

    void b_write_mem();
    void w_write_mem();
    void d_write_mem();
    void q_write_mem();

    void b_nand();
    void w_nand();
    void d_nand();
    void q_nand();

    void b_not();                        
    void w_not();
    void d_not();
    void q_not();

    void b_neg();
    void w_neg();
    void d_neg();
    void q_neg();

    void b_and();                        
    void w_and();
    void d_and();
    void q_and();  

    void b_or();                        
    void w_or();
    void d_or();
    void q_or();   

    void b_xor();                        
    void w_xor();
    void d_xor();
    void q_xor();   

    void b_add();
    void w_add();
    void d_add();
    void q_add();

    void b_sub();
    void w_sub();
    void d_sub();
    void q_sub();

    void b_cmp();
    void w_cmp();
    void d_cmp();
    void q_cmp();

    void b_test();
    void w_test();
    void d_test();
    void q_test();

    void b_div();
    void w_div();
    void d_div();
    void q_div();

    void b_mult();
    void w_mult();
    void d_mult();
    void q_mult();

    void b_shr();
    void w_shr();
    void d_shr();
    void q_shr();

    void b_shl();
    void w_shl();
    void d_shl();
    void q_shl(); 

    void ret();

    void fstsw();
    void get_cf();
    void get_pf();
    void get_af();
    void get_zf();
    void get_sf();
    void get_of();
    void get_df();
#ifdef _DEBUG
    void int3();
#endif
    void get_string_ins_diff();
};

#endif /* COMBOSVMCODE_HPP */
```

`seniorvmhandle.hpp`:

```hpp
/*
 *
 *   Copyright (C) Mon May 20 00:07:29 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 *
 *
 */

#ifndef _SENIORVMHANDLE_H_
#define _SENIORVMHANDLE_H_

//操作组合

#include "VMHandle.h"
#include "PCode.hpp"

#include "VOperand.hpp"

class SeniorVMHandle
{
 public:
  SeniorVMHandle();
  SeniorVMHandle(PCode *p);
  ~SeniorVMHandle(  );


  bool super_protect;

  long get_code_size();
  void link_pcode(PCode *p);
  void set_protect_grade(bool b );
  char push_operand( pVOperand o );
  char pop_operand(pVOperand o);
  void b_not_and(long _register1 = 0,long _register2 = 0,bool is_data = false);
  void w_not_and(long _register1 = 0,long _register2 = 0,bool is_data = false);
  void d_not_and(long _register1 = 0,long _register2 = 0,bool is_data = false);
  void q_not_and(long _register1 = 0,long _register2 = 0,bool is_data = false);
  char v_not_and(pVOperand o1,pVOperand o2  );


  void b_not(long _register,bool is_data = false);
  void w_not(long _register,bool is_data = false);
  void d_not(long _register,bool is_data = false);
  void q_not(long _register,bool is_data = false);
  char v_not( pVOperand o1 );
  
  void b_and(long _register1,long _register2,bool is_data = false);
  void w_and(long _register1,long _register2,bool is_data = false);
  void d_and(long _register1,long _register2,bool is_data = false);
  void q_and(long _register1,long _register2,bool is_data = false);

  char v_and( pVOperand o1,pVOperand o2 );
  void b_or(long _register1,long _register2,bool is_data = false);
  void w_or(long _register1,long _register2,bool is_data = false);
  void d_or(long _register1,long _register2,bool is_data = false);
  void q_or(long _register1,long _register2,bool is_data = false);

  char v_or( pVOperand o1,pVOperand o2 );
  
  void b_xor(long _register1,long _register2,bool is_data = false);
  void w_xor(long _register1,long _register2,bool is_data = false);
  void d_xor(long _register1,long _register2,bool is_data = false);
  void q_xor(long _register1,long _register2,bool is_data = false);

  char v_xor( pVOperand o1,pVOperand o2 );
  
  void b_shl(long _register,char n,bool is_data = false);
  void w_shl(long _register,char n,bool is_data = false);
  void d_shl(long _register,char n,bool is_data = false);
  void q_shl(long _register,char n,bool is_data = false);
  
  char v_shl( pVOperand o1,pVOperand o2 );
  
  void b_shr(long _register,char n,bool is_data = false);
  void w_shr(long _register,char n,bool is_data = false);
  void d_shr(long _register,char n,bool is_data = false);
  void q_shr(long _register,char n,bool is_data = false);
  
  char v_shr( pVOperand o1,pVOperand o2 );
  
  void b_push_imm(char n);
  void w_push_imm(short n);
  void d_push_imm(int n);
  void a_push_imm(long n);
  void q_push_imm(long n);

  char v_push_imm( pVOperand o1 );
  
  void b_push_imm_sx(char n);
  void w_push_imm_sx(short n);
  void d_push_imm_sx(int n);

  void b_push_imm_zx(char n);
  void w_push_imm_zx(short n);
  void d_push_imm_zx(int n);

  void b_copy_stack();
  void w_copy_stack();
  void d_copy_stack();
  void q_copy_stack();
  
  void pushf();
  void pushad();
  void popad();
  void popf();
  void exit();
  void start();


  void save_vm_context();
  void recover_vm_context();
  void b_read_mem(  );
  void w_read_mem(  );
  void d_read_mem(  );
  void q_read_mem(  );
  void b_write_mem(  );
  void w_write_mem(  );
  void d_write_mem(  );
  void q_write_mem(  );  
  void b_add_b(long _register1,long _register2);
  void b_add(long _register1,long _register2,bool is_data = false);
  void w_add(long _register1,long _register2,bool is_data = false);
  void d_add_d(long _register1,long _register2);
  void d_add(long _register1,long _register2,bool is_data = false);
  void q_add(long _register1,long _register2,bool is_data = false);
  char v_add( pVOperand o1,pVOperand o2 );

  void b_sub(long _register1,long _register2);
  void w_sub(long _register1,long _register2);
  void d_sub(long _register1,long _register2);
  void q_sub(long _register1,long _register2);
  char v_sub(pVOperand o1,pVOperand o2 );
  

  void b_div(long _register1,long _register2);
  void w_div(long _register1,long _register2);
  void d_div(long _register1,long _register2);
  void q_div(long _register1,long _register2);

  void push(long _register,bool _disable = true);
  void pop(long _register);

  void b_cmp(long _register1,long _register2);
  void w_cmp(long _register1,long _register2);
  void d_cmp(long _register1,long _register2);
  void q_cmp(long _register1,long _register2);  
  
  void r_get_mem(
                                  long _register_index,
                                  long _register_base,
                                  long _scale,
                                  long _lval);

  void * get_code_buf(  );
  void push_vesp(  );
  void db( unsigned char b );
  void dw( unsigned short w );
  void dd( unsigned int d );
  void dq( unsigned long q );
  void set_pc(  );
  void set_key( long _key );
  void upset_register_array( RegisterStore & r );
  PCode *pcode;

  void mov(pVOperand o1,pVOperand o2);
  void test(pVOperand o1,pVOperand o2);
  void lea(pVOperand o1,pVOperand o2);
  void cmp(pVOperand o1,pVOperand o2);
  void sar(pVOperand o1,pVOperand o2);
  void cdq(pVOperand o1);
  void div(pVOperand o1);
  void sar(pVOperand o1);
  void imul(pVOperand o1,pVOperand o2,pVOperand o3);
  void jnz(long addr1,long addr2);
  void jz(long addr1,long addr2);
};

#endif /* _SENIORVMHANDLE_H_ */

```

`virtualmachine.h`:

```h
/*
 *   Copyrigth (C) Mon May 20 10:36:14 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _VIRTUALMACHINE_H_
#define _VIRTUALMACHINE_H_

#include <list>

#include "VMHandle.h"
#include "PCode.hpp"
#include "AsmJit/AsmJit.h"

using namespace std;

typedef struct PCODE_BLOCK_INFO
{
  long entry;      //vm_init的地址
  long pcode_base; //pcode地址
  unsigned char *buf;
  unsigned long size;
  AsmJit::Assembler a;
}pcode_block_info, *ppcode_block_info;

typedef struct VIRTUAL_MACHINE_CODE_INFO
{
  unsigned char *buf;
  unsigned long size;
  unsigned long base; //虚拟机基址
}VirtualMachineCode,*pVirtualMachineCode;

class VirtualMachine
{
 public:
  VirtualMachine(  );
  VirtualMachine(long base);
  VirtualMachine(long base, bool sign);
  ~VirtualMachine(  );
  
  vm_handle handle_pcode;
  vm_handle & get_vm_handle_table()
  {
   return handle_pcode;
  }

  VMHandle handle;
  VMHandle & get_vm_handle()
  {
   return handle;
  }

  void build_vm_handle(long base );
  void full_handle_table(long base, long table_offset);
  list <handle_info> handle_info_list;
  ppcode_block_info add_new_function( long base,PCode *code ,long ret_address,long v_key,long decryption_key);
  ppcode_block_info create_function_head(long reloc_base, long base, PCode *code, long v_key, long decryption_key);  
  long dispatch_base;
  list <ppcode_block_info> pcode_list;
  void init(AsmJit::Assembler &a);
  void add_pcode(AsmJit::Assembler &a,PCode *code,long base,long ret_address,long v_key,long decryption_key);
  VirtualMachineCode vm_info;
};

#endif /* _VIRTUALMACHINE_H_ */

```

`vmcodebuffer.hpp`:

```hpp
/*
 *   Copyright (C) Wed Jun 26 18:49:56 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _VMCODEBUFFER_H_
#define _VMCODEBUFFER_H_

#include "PCode.hpp"
#include "CombosVMCode.hpp"
#include "VirtualMachine.h"

class VMCodeBufferManage
{
public:

  explicit VMCodeBufferManage( VirtualMachine *vm )
    :var_combos(&var_pcode)
  {
    if ( !vm )
      throw;
     var_pcode.init_handle_table(vm->get_vm_handle_table());
     var_pcode.init_sign( vm->get_vm_handle().sign );
  }
  
  VMCodeBufferManage( VirtualMachine *vm,
                      unsigned long key)
    :var_combos(&var_pcode)
  {
    if ( !vm )
      throw;
     var_pcode.init_handle_table(vm->get_vm_handle_table());
     var_pcode.init_sign( vm->get_vm_handle().sign );
     var_pcode.set_key(key);
  }

  virtual ~VMCodeBufferManage() {}
  
  VCombosVMCode var_combos;
  //
  VCombosVMCode & get_generator(  )
  {
    return var_combos;
  }

  PCode var_pcode;
  //
  PCode & get_pcode()
  {
    return var_pcode;
  }

  int var_label;
  //
  void set_vmcode_label(int _label)
  {
     var_label = _label;
  }
};

#endif /* _VMCODEBUFFER_H_ */

```

`voperand.hpp`:

```hpp
/*
 *   Copyright (C) Tue Jul  2 05:16:49 2013 XiaoWei
 *
 *                       handsomexiaowei@gmail.com
 */

#ifndef _VOPERAND_H_
#define _VOPERAND_H_

enum 
{
  T_RAX = 1 << 0,
  T_RBX = 1 << 1,//2,
  T_RCX = 1 << 2,//4,
  T_RDX = 1 << 3,//8,
  T_RSP = 1 << 4,//16,
  T_RBP = 1 << 5,//32,
  T_RSI = 1 << 6,//64,
  T_RDI = 1 << 7,//128,
  T_EFLAG_ = 1 << 8,//256,
  T_TMP_R64_1 = 1 << 9,//512,
  T_TMP_R64_2 = 1 << 10,//1024,
  T_TMP_R64_3 = 1 << 11,//2048,
  T_TMP_R64_4 = 1 << 12,//4096,

  T_TMP_R64_5 = 1 << 13,//32768, //保留
  T_TMP_R64_6 = 1 << 14,//65536,
  T_TMP_R64_7 = 1 << 15,//131072,
  T_TMP_R64_8 = 1 << 16,//262144, //跳转寄存器

  T_KEY64 = 1 << 17,//8192,
  T_RET64 = 1 << 18,//16384,   

  T_JMPINSADDR64 =  1 << 19,
  T_NEXTINSADDR64 = 1 << 20,

  T_ALL_TMPREGISTER = 0x1FE00,
  T_ALL_REGISTER = 0x1FFFFF,    //上面所有的寄存器

  T_XXX5 = 1 << 23,//524288,

  T_INVALID = 1 << 24,//1048576,

  T_E32X = 1 << 25,//16777216, //只有64位程序时才有  
  T_16X  = (1 << 26),//2097152, //AX
  T_8H =  (1 << 27),//4194304, //AH
  T_8L =  (1 << 28),//8388608,

  T_RN = 1 << 29,//33554432,       //R8 - R15

  disable = 1 << 30,
  enable = 1 << 31,
  T_KEY32 = (T_KEY64 | T_E32X),
  T_RET32 = (T_RET64 | T_E32X),

  T_TMP_R32_1 = (T_TMP_R64_1 | T_E32X),
  T_TMP_R32_2 = (T_TMP_R64_2 | T_E32X),
  T_TMP_R32_3 = (T_TMP_R64_3 | T_E32X),
  T_TMP_R32_4 = (T_TMP_R64_4 | T_E32X),
  T_TMP_R32_5 = (T_TMP_R64_5 | T_E32X),
  T_TMP_R32_6 = (T_TMP_R64_6 | T_E32X),
  T_TMP_R32_7 = (T_TMP_R64_7 | T_E32X),
  T_TMP_R32_8 = (T_TMP_R64_8 | T_E32X),
  T_INVALID_R32 = (T_INVALID | T_E32X),

  T_TMP_R16_1 = (T_TMP_R32_1 | T_16X),
  T_TMP_R16_2 = (T_TMP_R32_2 | T_16X),
  T_TMP_R16_3 = (T_TMP_R32_3 | T_16X),
  T_TMP_R16_4 = (T_TMP_R32_4 | T_16X),
  T_TMP_R16_5 = (T_TMP_R32_5 | T_16X),
  T_TMP_R16_6 = (T_TMP_R32_6 | T_16X),
  T_TMP_R16_7 = (T_TMP_R32_7 | T_16X),
  T_TMP_R16_8 = (T_TMP_R32_8 | T_16X),
  T_INVALID_R16 = (T_INVALID_R32 | T_16X),

  T_TMP_R8_1H = (T_TMP_R16_1 | T_8H),
  T_TMP_R8_2H = (T_TMP_R16_2 | T_8H),
  T_TMP_R8_3H = (T_TMP_R16_3 | T_8H),
  T_TMP_R8_4H = (T_TMP_R16_4 | T_8H),
  T_TMP_R8_5H = (T_TMP_R16_5 | T_8H),
  T_TMP_R8_6H = (T_TMP_R16_6 | T_8H),
  T_TMP_R8_7H = (T_TMP_R16_7 | T_8H),
  T_TMP_R8_8H = (T_TMP_R16_8 | T_8H),
  T_INVALID_R8 = (T_INVALID_R16 | T_8H),

  T_TMP_R8_1L = (T_TMP_R16_1 | T_8L),
  T_TMP_R8_2L = (T_TMP_R16_2 | T_8L),
  T_TMP_R8_3L = (T_TMP_R16_3 | T_8L),
  T_TMP_R8_4L = (T_TMP_R16_4 | T_8L),
  T_TMP_R8_5L = (T_TMP_R16_5 | T_8L),
  T_TMP_R8_6L = (T_TMP_R16_6 | T_8L),
  T_TMP_R8_7L = (T_TMP_R16_7 | T_8L),
  T_TMP_R8_8L = (T_TMP_R16_8 | T_8L),

  T_INVALID32 = (T_INVALID | T_E32X),
  T_INVALID16 = (T_INVALID | T_16X),
  T_INVALID8L  = (T_INVALID | T_8L),
  T_INVALID8H  = (T_INVALID | T_8H),

  T_R8 = (T_RAX | T_RN),
  T_R9 = (T_RBX | T_RN),
  T_R10 = (T_RCX | T_RN),
  T_R11 = (T_RDX | T_RN),
  T_R12 = (T_RSP | T_RN),
  T_R13 = (T_RBP | T_RN),
  T_R14 = (T_RSI | T_RN),
  T_R15 = (T_RDI | T_RN),

  T_EAX = (T_RAX | T_E32X),
  T_EBX = (T_RBX | T_E32X),
  T_ECX = (T_RCX | T_E32X),
  T_EDX = (T_RDX | T_E32X),
  T_ESP = (T_RSP | T_E32X),
  T_EBP = (T_RBP | T_E32X),
  T_ESI = (T_RSI | T_E32X),
  T_EDI = (T_RDI | T_E32X),

  T_AX = (T_EAX | T_16X),
  T_BX = (T_EBX | T_16X),
  T_CX = (T_ECX | T_16X),
  T_DX = (T_EDX | T_16X),
  T_SP = (T_ESP | T_16X),
  T_BP = (T_EBP | T_16X),
  T_SI = (T_ESI | T_16X),
  T_DI = (T_EDI | T_16X),

  T_AH = (T_AX | T_8H),
  T_AL = (T_AX | T_8L),
  T_CH = (T_CX | T_8H),
  T_CL = (T_CX | T_8L),
  T_DH = (T_DX | T_8H),
  T_DL = (T_DX | T_8L),
  T_BH = (T_BX | T_8H),
  T_BL = (T_BX | T_8L),

  T_EFLAG8H = (T_EFLAG_ | T_8H),
  T_EFLAG8L = (T_EFLAG_ | T_8L),
  T_EFLAG16 = (T_EFLAG_ | T_16X),
  T_EFLAG32 = (T_EFLAG_ | T_E32X) 
};

#ifdef PROTECT_X64
#define T_FLAG T_EFLAG_
#define T_EFLAG T_EFLAG_
#define T_KEY T_KEY64
#define T_RET T_RET64
#define T_NEXTINSADDR T_NEXTINSADDR64
#define T_JMPINSADDR T_JMPINSADDR64
#define T_TMP_REGISTER1 T_TMP_R64_1
#define T_TMP_REGISTER2 T_TMP_R64_2
#define T_TMP_REGISTER3 T_TMP_R64_3
#define T_TMP_REGISTER4 T_TMP_R64_4
#define T_TMP_REGISTER5 T_TMP_R64_5
#define T_TMP_REGISTER6 T_TMP_R64_6
#define T_TMP_REGISTER7 T_TMP_R64_7
#define T_TMP_REGISTER8 T_TMP_R64_8
#define T_NAX T_RAX
#define T_NBX T_RBX
#define T_NCX T_RCX
#define T_NDX T_RDX
#define T_NSP T_RSP
#define T_NBP T_RBP
#define T_NSI T_RSI
#define T_NDI T_RDI
#else
#define T_FLAG (T_EFLAG32)
#define T_EFLAG (T_EFLAG32)
#define T_NEXTINSADDR (T_NEXTINSADDR64 | T_E32X)
#define T_JMPINSADDR (T_JMPINSADDR64 | T_E32X)
#define T_KEY (T_KEY32)
#define T_RET (T_RET32)
#define T_TMP_REGISTER1 T_TMP_R32_1
#define T_TMP_REGISTER2 T_TMP_R32_2
#define T_TMP_REGISTER3 T_TMP_R32_3
#define T_TMP_REGISTER4 T_TMP_R32_4
#define T_TMP_REGISTER5 T_TMP_R32_5
#define T_TMP_REGISTER6 T_TMP_R32_6
#define T_TMP_REGISTER7 T_TMP_R32_7
#define T_TMP_REGISTER8 T_TMP_R32_8
#define T_NAX T_EAX
#define T_NBX T_EBX
#define T_NCX T_ECX
#define T_NDX T_EDX
#define T_NSP T_ESP
#define T_NBP T_EBP
#define T_NSI T_ESI
#define T_NDI T_EDI
#endif

#ifdef PROTECT_X64
#define  T_JCC_REGISTER  T_TMP_R64_8
#define  T_MEM_REGISTER  T_TMP_R64_7
#define  T_DATA_REGISTER T_TMP_R64_6
#else
#define  T_JCC_REGISTER  T_TMP_R32_8
#define  T_MEM_REGISTER  T_TMP_R32_7
#define  T_DATA_REGISTER T_TMP_R32_6
#endif

enum V_OPERAND_TYPE
{
  VOPERAND_NONE = 0x00,
  VOPERAND_REG  = 0x01,
  VOPERAND_IMM  = 0x02,
  VOPERAND_MEM  = 0x04,
  VOPERAND_JIMM = 0x08
};


typedef struct _V_Operand
{
  typedef struct _BASE_DATA
  {
	 long id;
    char op;
    char size;
  }BaseData;
  
  typedef struct _MEM_DATA
  {
    char op;
    char size;  //指的是内存大小 比如dword_ptr为4    
    long id;
    long base;
    long index;
    long scale;
    long lval;
  }MemData;
  typedef struct _REG_DATA
  {
    char op;
    char size;    
    long id;    
    long base;
  }RegData;
  typedef struct _IMM_DATA
  {
    char op;
    char size;    
    long id;    
    long value;
  }ImmData;
  
  union
  {
    BaseData _base;
    MemData _mem;
    RegData _reg;
    ImmData _imm;
  };

  inline size_t get_size(  ) const {
    return _base.size;
  }
  inline long get_id(  ) const {
    return _base.id;
  }
  inline bool is_mem(  ) const {
    return ( _base.op == VOPERAND_MEM );
  }
  inline bool is_reg(  ) const {
    return ( _base.op == VOPERAND_REG );
  }
  inline bool is_imm(  ) const {
    return ( _base.op == VOPERAND_IMM );
  }
  inline bool is_none(  ) const {
    return ( _base.op == VOPERAND_NONE );
  }
  inline bool isGPD(  ) const {
    if (_reg.base == T_EAX ||
        _reg.base == T_EBX ||
        _reg.base == T_ECX ||
        _reg.base == T_EDX ||
        _reg.base == T_ESP ||
        _reg.base == T_EBP ||
        _reg.base == T_ESI ||
        _reg.base == T_EDI
#ifndef PROTECT_X64
        ||_reg.base == T_EFLAG
#endif
        )
    {
        return true;
    } else
        return false;
  }
  inline bool isGPW(  ) const {
    if (_reg.base == T_AX||
        _reg.base == T_BX||
        _reg.base == T_CX||
        _reg.base == T_DX||
        _reg.base == T_SP||
        _reg.base == T_BP||
        _reg.base == T_SI||
        _reg.base == T_DI)
    {
      return true;
    } else return false;
  }
  inline bool isGPBLo(  ) const {
    if (_reg.base == T_AL||
        _reg.base == T_BL||
        _reg.base == T_CL||
        _reg.base == T_DL)
    {
      return true;
    } else return false;
  }
  inline bool isGPBHi(  ) const {
    if (_reg.base == T_AH||
        _reg.base == T_BH||
        _reg.base == T_CH||
        _reg.base == T_DH)
    {
      return true;
    } else return false;    
  }
  inline bool isGPB(  ) const {
    return ( isGPBHi(  ) || isGPBLo(  ) );
  }
  inline bool isGPQ(  ) const {
    if (_reg.base == T_NAX ||
        _reg.base == T_NBX ||
        _reg.base == T_NCX ||
        _reg.base == T_NDX ||
        _reg.base == T_NSP ||
        _reg.base == T_NBP ||
        _reg.base == T_NSI ||
        _reg.base == T_NDI
#ifdef PROTECT_X64
        ||_reg.base == T_EFLAG
#endif        
        )
    {
      return true;
    } else return false;    
  }
}VOperand,*pVOperand;


typedef struct _VImm : public VOperand 
{
  _VImm( long _value , char _size) {
    _imm.op = VOPERAND_IMM;
    _imm.value = _value;
    _imm.size = _size;
  }
  _VImm( long _value ) {
    _imm.op = VOPERAND_IMM;    
    _imm.value = _value;
#ifdef PROTECT_X64
    _imm.size = 8;
#else
    _imm.size = 4;
#endif
  }
  ~_VImm(  ) {
    
  }
}VImm;

typedef struct _VReg : public VOperand
{
  _VReg( long _register,char _size )
  {
    _reg.op = VOPERAND_REG;
    _reg.base = _register;
    _reg.size = _size;
  }
  _VReg( long _register )
  {
    _reg.op = VOPERAND_REG;
    _reg.base = _register;
#ifdef PROTECT_X64
    char defsize = 8;
#else
    char defsize = 4;
#endif
    switch( _register )
    {
    case T_RAX:
      _reg.size = defsize;
      break;
    case T_RBX:
      _reg.size = defsize;
      break;
    case T_RCX:
      _reg.size = defsize;
      break;
    case T_RDX:
      _reg.size = defsize;
      break;
    case T_RSP:
      _reg.size = defsize;
      break;
    case T_RBP:
      _reg.size = defsize;
      break;
    case T_RSI:
      _reg.size = defsize;
      break;
    case T_RDI:
      _reg.size = defsize;
      break;
    case T_EAX:
      _reg.size = 4;
      break;
    case T_EBX:
      _reg.size = 4;
      break;
    case T_ECX:
      _reg.size = 4;
      break;
    case T_EDX:
      _reg.size = 4;
      break;
    case T_ESP:
      _reg.size = 4;
      break;
    case T_EBP:
      _reg.size = 4;
      break;
    case T_ESI:
      _reg.size = 4;
      break;
    case T_EDI:
      _reg.size = 4;
      break;      
    case T_AX:
      _reg.size = 2;
      break;
    case T_BX:
      _reg.size = 2;
      break;
    case T_CX:
      _reg.size = 2;
      break;
    case T_DX:
      _reg.size = 2;      
      break;
    case T_SI:
      _reg.size = 2;
      break;
    case T_DI:
      _reg.size = 2;
      break;
    case T_SP:
      _reg.size = 2;
      break;
    case T_BP:
      _reg.size = 2;
      break;
    case T_AL:
      _reg.size = 1;
      break;
    case T_BH:
      _reg.size = 1;
      break;
    case T_CL:
      _reg.size = 1;
      break;
    case T_CH:
      _reg.size = 1;
      break;
    case T_DL:
      _reg.size = 1;
      break;
    case T_AH:
      _reg.size = 1;
      break;
    case T_BL:
      _reg.size = 1;
      break;
    case T_DH:
      _reg.size = 1;
      break;
    }    
  }
  ~_VReg(  )
  {
    
  }
}VReg;

typedef struct _VMem : public VOperand
{
  _VMem( long base,long index,long scale,long lval,char _size)
  {
    _mem.op = VOPERAND_MEM;
    _mem.base  = base;
    _mem.index = index;
    _mem.scale = scale;
    _mem.lval  = lval;
    _mem.size  = _size;
  }
  ~_VMem(  )
  {
    
  }
}VMem;

  
VImm vimm( long _value );
VReg vreg( long _register );
VMem vmem( long _base,long _index,long _scale,long _lval,char _size );

#endif /* _VOPERAND_H_ */ 

```