Project Path: arc_securityjoes_ThreatResearch_c076bvjd

Source Tree:

```txt
arc_securityjoes_ThreatResearch_c076bvjd
├── ConfigExtractors
│   ├── README.md
│   ├── decrypt_templateX.py
│   ├── plug_x_analyzer.py
│   ├── redline_config_extractor.py
│   └── remcos_config_extractor.py
└── README.md

```

`ConfigExtractors/README.md`:

```md
# Config Extractors

## What we have here?
Some scripts used by our team to extract configs from some analyzed samples.

### PlugX
> PlugX is a malware family first spotted in 2008. It is a Remote Access Trojan that has been used by several threat actors and provides them with full control over infected machines. It has continually evolved over time, adding new features and functionalities with each iteration. Hence, it is important to keep following and documenting its transformations.
>
> Currently, it remains as one of the most popular tools in the Asian cybercrime community, given its flexibility and trajectory in the market; and it is still actively used by notorious threat actors such as Mustang Panda, Winnti, Gallium, DragonOK and Earth Berberoka.

[Read more](https://secjoes-reports.s3.eu-central-1.amazonaws.com/Dissecting+PlugX+to+Extract+Its+Crown+Jewels.pdf)

### Remcos
> Remcos (acronym of Remote Control & Surveillance Software) is a Remote Access Software used to remotely control computers.
Remcos, once installed, opens a backdoor on the computer, granting full access to the remote user.
Remcos can be used for surveillance and penetration testing purposes, and in some instances has been used in hacking campaigns.

[Read more](https://malpedia.caad.fkie.fraunhofer.de/details/win.remcos)

### templateX

> Decrypt templateX payload used by APT-Q-27

[Read more](https://www.ctfiot.com/40522.html)

### Redline Stealer
> RedLine Stealer is a malware available on underground forums for sale apparently as standalone ($100/$150 depending on the version) or also on a subscription basis ($100/month). This malware harvests information from browsers such as saved credentials, autocomplete data, and credit card information. A system inventory is also taken when running on a target machine, to include details such as the username, location data, hardware configuration, and information regarding installed security software. More recent versions of RedLine added the ability to steal cryptocurrency. FTP and IM clients are also apparently targeted by this family, and this malware has the ability to upload and download files, execute commands, and periodically send back information about the infected computer.

[Read more](https://malpedia.caad.fkie.fraunhofer.de/details/win.redline_stealer)

```

`ConfigExtractors/decrypt_templateX.py`:

```py
# coding: utf-8

#-------------------------------------------------------------------------------
# Name:        decrypt_templateX
# Purpose:     Decrypt templateX payload used by APT-Q-27
#
# Author:      Charles Lomboni
# Created:     10/08/2022
# Company:     Security Joes
#-------------------------------------------------------------------------------

import argparse
import lznt1

def getargs():
    parser = argparse.ArgumentParser("decrypt_templateX")
    parser.add_argument("path", help="Path to encrypted file.")
    return parser.parse_args()

def decryptFile(fileName):
    print("[+] Reading templateX ...")
    byteToModify = bytearray(open(fileName, 'rb').read())
    result = bytes([])

    bytesLen = len(byteToModify)

    print("[+] Decrypting templateX ...")
    # main logic to decrypt
    for i in range(bytesLen):
        result += bytes([(((byteToModify[i]) - 0x7A) & 0xFF) ^ 0x19])

    print("[+] Decompressing ...")
    for j in range(512, 2048):
        pe_hdr = result[j:j + 2]

        if pe_hdr == b'MZ':
            break
    
    bytesDecompressed = lznt1.decompress(result[j - 3:])
    savedFilename = fileName + '_decrypted.dll'
    print("[+] Saving file ", savedFilename)
    open(savedFilename, 'wb').write(bytesDecompressed)
    
def main():

    args = getargs()

    print ("[+] Started...")
    decryptFile(args.path) 
    print ("[+] Finished!")
    pass

if __name__ == '__main__':
    main()
```

`ConfigExtractors/plug_x_analyzer.py`:

```py
import argparse
import re
import struct

import lznt1
import pefile

from capstone import *


def read_file(file_path):
    """
    Given a file path return a buffer with the data

    :param file_path:
    :return:
    """
    with open(file_path, 'rb') as f:
        buffer = f.read()
    return buffer


def save_file(file_path, buffer):
    """
    Given a file path and a buffer creates a file in disk

    :param file_path:
    :param buffer:
    :return:
    """
    with open(file_path, 'wb') as f:
        f.write(buffer)


def brute_force_location(buffer, target, start=0, window=512):
    """
    Given an encrypted buffer, the window and the target word return the starting address of the encrypted data

    :param buffer:
    :param target:
    :param start:
    :param window:
    :return:
    """
    index = start

    while True:
        tmp = xor_decrypt(buffer[index:index + window])

        if target in tmp:
            break

        index += 1
    return index


def brute_force_pe_location(buffer):
    """
    Given an encrypted buffer containing a PE, returns the starting address of the encrypted PE

    :param buffer:
    :return:
    """
    return brute_force_location(buffer, b'This')


def brute_force_pe_extraction(buffer, address, size=2500):
    """
    Given a buffer and the PE start address returns the decrypted PE

    :param buffer:
    :param address:
    :param size:
    :return:
    """
    while True:
        try:
            return lznt1.decompress(xor_decrypt(buffer[address:address + size])[16:])
        except ValueError:
            size += 1


def xor_decrypt(buffer):
    """
    Decrypt PlugX payload and config

    :param buffer:
    :return:
    """
    key = struct.unpack('<I', buffer[0:4])[0]
    key_a, key_b, key_c = key, key, key
    result = bytes([])

    for char in buffer:
        key = (key + (key >> 3) - 0x11111111) & 0xFFFFFFFF
        key_a = (key_a + (key_a >> 5) - 0x22222222) & 0xFFFFFFFF
        key_b = (key_b - (key_b << 7) + 0x33333333) & 0xFFFFFFFF
        key_c = (key_c - (key_c << 9) + 0x44444444) & 0xFFFFFFFF

        result += bytes([char ^ ((key + key_a + key_b + key_c) & 0x000000FF)])

    return result


def get_data_section(file_path):
    """
    Locate configuration section

    :param file_path:
    :return:
    """
    return pefile.PE(file_path).sections[2].get_data()


def x64_analysis(sc):
    """
    Run analysis logic for x64 binaries

    :param sc:
    :return:
    """
    # Find main shellcode function
    print('[+] Finding main shellcode function')
    main_index = sc.index(b'\xe8\x05', 0, 96)

    # Find DLL pointer in shellcode
    print('[+] Extracting address of the encrypted DLL')
    dll_index = main_index - 30
    dll_ptr = struct.unpack('<I', sc[dll_index:dll_index + 4])[0]

    # Find DLL size
    print('[+] Extracting size of the encrypted DLL')
    size_index = main_index - 24
    size = struct.unpack('<I', sc[size_index:size_index + 4])[0]

    # Extract DLL
    print('[+] Decrypting PlugX DLL')
    dll_data = lznt1.decompress(xor_decrypt(sc[dll_ptr:dll_ptr + size])[16:])

    # Saving DLL
    print('[+] Saving PlugX DLL')
    save_file('plug_x_dll.bin', dll_data)

    # Extracting embedded DLL
    print('[+] Extracting embedded DLL (Privilege Escalation)')
    section_data = get_data_section('plug_x_dll.bin')
    embedded_dll_data = brute_force_pe_extraction(section_data, brute_force_pe_location(section_data))
    save_file('plug_x_embedded_dll.bin', embedded_dll_data)

    # Extract config
    print('[+] Decrypting attack configuration')
    config_data = xor_decrypt(sc[dll_ptr + size:])
    save_file('config.bin', config_data)

    servers = re.finditer(b'(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]', config_data)

    print('[+] C2 servers:')
    for server in servers:
        port = struct.unpack('<I', config_data[server.start() - 2:server.start()] + b'\x00\x00')[0]
        print(f'\t[-] {config_data[server.start():server.end()].decode()}:{port}')


def x32_analysis(sc):
    """
    Run analysis logic for x32 binaries

    :param sc:
    :return:
    """
    # Find DLL pointer in shellcode
    print('[+] Extracting address of the encrypted DLL')
    dll_ptr = brute_force_pe_location(sc)

    # Find DLL size
    print('[+] Extracting size of the encrypted DLL')
    size_index = dll_ptr - 9
    dll_size = struct.unpack('<I', sc[size_index:size_index + 4])[0]
    flag_old_version = False

    if 100000 < dll_size > 300000:
        # Brute-forced size
        try:
            main_index = sc.index(b'\xe8\x01', 0, 2048)

            size_index = main_index - 23
            dll_size = struct.unpack('<I', sc[size_index:size_index + 4])[0]
            flag_old_version = True
        except ValueError:
            print('[+] Cleaning shellcode')
            x32_analysis(x32_clean_shellcode(sc))
            exit()

    # Extract DLL
    print('[+] Decrypting PlugX DLL')
    dll_data = lznt1.decompress(xor_decrypt(sc[dll_ptr:dll_ptr + dll_size])[16:])

    # Saving DLL
    print('[+] Saving PlugX DLL')
    save_file('plug_x_dll.bin', dll_data)

    # Extracting embedded DLL
    print('[+] Extracting embedded DLL (Privilege Escalation)')
    section_data = get_data_section('plug_x_dll.bin')
    embedded_dll_ptr = brute_force_pe_location(section_data)
    embedded_dll_data = brute_force_pe_extraction(section_data, embedded_dll_ptr, 500 if flag_old_version else 2500)
    save_file('plug_x_embedded_dll.bin', embedded_dll_data)

    # Extract config
    print('[+] Decrypting attack configuration')
    config_size = 5388
    config_ptr = brute_force_location(sc, b'HTTP', dll_ptr + dll_size if config_size > dll_ptr else 0, config_size)
    config_data = xor_decrypt(sc[config_ptr:config_ptr + config_size])
    save_file('config.bin', config_data)

    servers = re.finditer(b'(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9][a-z0-9-]{0,61}[a-z0-9]', config_data)

    print('[+] C2 servers:')
    for server in servers:
        port = struct.unpack('<I', config_data[server.start() - 2:server.start()] + b'\x00\x00')[0]
        print(f'\t[-] {config_data[server.start():server.end()].decode()}:{port}')


def get_sc_encryption_values(buffer):
    """
    Gets x86 assembly instructions

    :param buffer:
    :return:
    """
    disassembler = Cs(CS_ARCH_X86, CS_MODE_32)
    add_value, xor_value, sub_value = 0, 0, 0

    for x in disassembler.disasm(buffer, 0):
        if 'byte ptr' in x.op_str:
            if x.mnemonic == 'add':
                add_value = int(x.op_str.split(',')[1], 16)
            elif x.mnemonic == 'xor':
                xor_value = int(x.op_str.split(',')[1], 16)
            elif x.mnemonic == 'sub':
                sub_value = int(x.op_str.split(',')[1], 16)

        # Exit loop if all values were extracted
        if add_value != 0 and xor_value != 0 and sub_value != 0:
            break
    return add_value, xor_value, sub_value


def x32_clean_shellcode(sc):
    """
    Given an encrypted shellcode returns the unprotected version

    :param sc:
    :return:
    """
    add_value, xor_value, sub_value = get_sc_encryption_values(sc[:0x200])
    result = bytearray([])

    for char in sc[:0x5E8]:
        result += bytes([((((char + add_value) & 0xFF) ^ xor_value) - sub_value) & 0xFF])
    return result + sc[0x5E8:]


def main(file_path):
    """
    Main logic of the script

    :return:
    """
    print(f'[+] Analyzing shellcode at "{file_path}"')
    sc = read_file(file_path)
    try:
        print(f'[+] Attempting x64 analysis')
        x64_analysis(sc)
    except:
        print(f'[+] x64 analysis failed! Now running x32 analysis')
        x32_analysis(sc)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='PlugX Payload and Config Extractor.')
    parser.add_argument('file_path', type=str, help='File path of the PlugX Shellcode')
    parser.add_argument('--mode', type=str, default='sc', help='Shellcode analysis')

    args = parser.parse_args()

    if args.mode != 'config':
        main(args.file_path)
    else:
        print(f'[+] Analyzing config file at "{args.file_path}"')
        data = read_file(args.file_path)

        with open('config.bin', 'wb') as f:
            f.write(xor_decrypt(data))

```

`ConfigExtractors/redline_config_extractor.py`:

```py
#-------------------------------------------------------------------------------
# Sha256:      9b838df19999f417961e05a4af98f5cfb5c4dd4a255e03cc937cda384d6e7955
#
# Author:      Charles Lomboni
# Created:     26/12/2022
# Company:     Security Joes
#-------------------------------------------------------------------------------

import re
from dotnetfile import DotNetPE
import base64
import argparse

# https://arpitbhayani.me/blogs/decipher-repeated-key-xor
def repeating_key_xor(text: bytes, key: bytes) -> bytes:
    """Given a plain text `text` as bytes and an encryption key `key`
    as bytes, the function encrypts the text by performing
    XOR of all the bytes and the `key` (in repeated manner) and returns
    the resultant XORed byte stream.
    """

    # we update the encryption key by repeating it such that it
    # matches the length of the text to be processed.
    repetitions = 1 + (len(text) // len(key))
    key = key * repetitions
    key = key[:len(text)]

    # XOR text and key generated above and return the raw bytes
    return bytes([b ^ k for b, k in zip(text, key)])

def config_extractor(file_name, str_key):

    dotnet_file = DotNetPE(file_name)
    us_stream_strings = dotnet_file.get_user_stream_strings()

    print("[+] Decrypting data")
    for string in us_stream_strings:

        # base64 regex
        x = re.search("^(?:[a-zA-Z0-9+\/]{4})*(?:|(?:[a-zA-Z0-9+\/]{3}=)|(?:[a-zA-Z0-9+\/]{2}==)|(?:[a-zA-Z0-9+\/]{1}===))$", string)

        if x:
            try:
                extracted = base64.b64decode(repeating_key_xor(base64.b64decode(string), str_key.encode())).decode()
                if extracted:
                    print(f"[>] {extracted}")
            except:
                try:
                    print(f"[>] {base64.b64decode(string).decode('ascii')}")
                except UnicodeDecodeError:
                    pass                
                pass

def get_args():

    parser = argparse.ArgumentParser(description='Redline Config Extractor.')
    parser.add_argument("-f", "--file_path", type=str, help='File path of the Redline binary')

    args = parser.parse_args()

    return args

def main():

    args = get_args()

    print(f"[+] Reading the file: {args.file_path}")
    config_extractor(args.file_path, str_key="Repoint")

    print("[+] Done!")


if __name__ == '__main__':
    main()
```

`ConfigExtractors/remcos_config_extractor.py`:

```py
from arc4 import ARC4
import binascii
import pefile
import argparse

def rc4_decrypt(key, data):
    cipher = ARC4(key)
    decrypted = cipher.decrypt(data)

    print("[+] Config extracted!")
    return decrypted.decode("latin-1")

def read_resource_in_hex(pe_name, resource_name):
    
    pe = pefile.PE(pe_name)

    settings_resource = "" 
    offset = 0x0
    size = 0x0

    for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        for entry in rsrc.directory.entries:
            if entry.name is not None:
                if entry.name.__str__() == resource_name:
                    offset = entry.directory.entries[0].data.struct.OffsetToData
                    size = entry.directory.entries[0].data.struct.Size

    if offset != 0x0 and size != 0x0:
        print(f"[+] Reading the resource: {resource_name}")
        settings_resource = pe.get_memory_mapped_image()[offset:offset+size]
        return settings_resource.hex()
    else:
        print("[-] Error while trying to read the resource")

def get_args():

    parser = argparse.ArgumentParser(description='Remcos Config Extractor.')
    parser.add_argument("-f", "--file_path", type=str, help='File path of the Remcos binary')
    parser.add_argument("-r", "--res_name", type=str, help='Name of the resource file inside the Remcos binary')

    args = parser.parse_args()

    return args

def main():

    args = get_args()

    print(f"[+] Reading the file: {args.file_path}")
    settings_resource = read_resource_in_hex(args.file_path, args.res_name)

    print("[+] Getting the key")
    key = binascii.unhexlify(settings_resource[2:194])
    
    print("[+] Getting the data")
    data = binascii.unhexlify(settings_resource[194:])

    print("[+] Decrypting data")
    print(rc4_decrypt(key, data))

if __name__ == '__main__':
    main()
```

`README.md`:

```md
# Config Extractors

Some used scripts by our team to extract configs from some analyzed samples.

- [PlugX](ConfigExtractors/plug_x_analyzer.py)
- [Remcos](ConfigExtractors/remcos_config_extractor.py)
- [templateX](ConfigExtractors/decrypt_templateX.py)
- [RedLine Stealer](ConfigExtractors/redline_config_extractor.py)

```