Project Path: arc_AndroidModLoader_AndroidModLoader_vew_gnxa

Source Tree:

```txt
arc_AndroidModLoader_AndroidModLoader_vew_gnxa
├── AML_PrecompiledLibs
├── ARMPatch
├── Android.mk
├── Application.mk
├── LICENSE
├── README.md
├── alog.cpp
├── aml.cpp
├── curl
├── curl_config.h
├── external
│   ├── README.md
│   └── java
│       └── net
│           └── rusjj
│               ├── amlcore.java
│               └── amlcore.smali
├── icfg.cpp
├── icfg_desc.h
├── il2cpp
│   ├── functions.cpp
│   ├── functions.h
│   ├── gc.cpp
│   ├── typedefs.h
│   └── types.h
├── include
│   ├── aml.h
│   ├── defines.h
│   ├── interfaces.h
│   ├── jnifn.h
│   ├── mls.h
│   ├── modpaks.h
│   └── modslist.h
├── interface.cpp
├── main.cpp
├── mls.cpp
├── mod
│   ├── amlmod.h
│   ├── config.cpp
│   ├── config.h
│   ├── config_inipp.cpp
│   ├── iaml.h
│   ├── icfg.h
│   ├── il2cpp.h
│   ├── interface.h
│   ├── listitem.h
│   ├── logger.cpp
│   ├── logger.h
│   └── thirdparty
│       ├── INICPP_LICENSE
│       ├── STB_LICENSE
│       ├── inicpp.h
│       └── stb_sprintf.h
├── modpaks.cpp
├── modslist.cpp
├── news.txt
├── signal.cpp
├── template_of_mod
│   ├── Android.mk
│   ├── Application.mk
│   ├── main.cpp
│   └── mod
│       ├── amlmod.h
│       ├── config.cpp
│       ├── config.h
│       ├── config_inipp.cpp
│       ├── iaml.h
│       ├── icfg.h
│       ├── il2cpp.h
│       ├── interface.h
│       ├── listitem.h
│       ├── logger.cpp
│       ├── logger.h
│       └── thirdparty
│           ├── INICPP_LICENSE
│           ├── STB_LICENSE
│           ├── inicpp.h
│           └── stb_sprintf.h
├── vtable_hooker.cpp
├── vtable_hooker.h
├── wolfssl
└── zlib

```

`Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)


# ARMPatch

include $(CLEAR_VARS)
LOCAL_MODULE := armpatch
LOCAL_SRC_FILES := obj/local/$(TARGET_ARCH_ABI)/libarmpatch.a
include $(PREBUILT_STATIC_LIBRARY)


# ThirdParty libraries

include $(CLEAR_VARS)
LOCAL_MODULE := substrate
LOCAL_SRC_FILES := obj/local/$(TARGET_ARCH_ABI)/libsubstrate.a
include $(PREBUILT_STATIC_LIBRARY)

# include $(CLEAR_VARS)
# LOCAL_MODULE := dobby
# LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libdobby.a
# include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := gloss
LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libGlossHook.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := libz
LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libz.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := wolfssl
LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libwolfssl.a
include $(PREBUILT_STATIC_LIBRARY)

include $(CLEAR_VARS)
LOCAL_MODULE := curl
LOCAL_SHARED_LIBRARIES := libz wolfssl
LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libcurl.a
include $(PREBUILT_STATIC_LIBRARY)


# xUnwind

include $(CLEAR_VARS)
LOCAL_MODULE := xUnwind
LOCAL_SHARED_LIBRARIES := armpatch
LOCAL_SRC_FILES := AML_PrecompiledLibs/$(TARGET_ARCH_ABI)/libxUnwind.a
include $(PREBUILT_STATIC_LIBRARY)


# AML library

include $(CLEAR_VARS)
LOCAL_CPP_EXTENSION     := .cpp .cc
LOCAL_SHARED_LIBRARIES  := armpatch substrate curl gloss xUnwind
LOCAL_MODULE            := AML
LOCAL_SRC_FILES         := main.cpp interface.cpp aml.cpp modpaks.cpp signal.cpp \
                           modslist.cpp icfg.cpp vtable_hooker.cpp alog.cpp mls.cpp \
                           mod/logger.cpp mod/config.cpp

 ## FLAGS ##
LOCAL_CFLAGS += -O2 -mfloat-abi=softfp -DNDEBUG -D__AML -DNO_HOOKDEFINES -DFASTMAN92_CODE -std=c17 -mthumb
LOCAL_CXXFLAGS += -O2 -mfloat-abi=softfp -DNDEBUG -D__AML -DNO_HOOKDEFINES -DFASTMAN92_CODE -std=c++17 -mthumb -fexceptions
LOCAL_C_INCLUDES += $(LOCAL_PATH)/include $(LOCAL_PATH)/curl $(LOCAL_PATH)/curl/include $(LOCAL_PATH)/wolfssl $(LOCAL_PATH)/AML_PrecompiledLibs/include
LOCAL_LDLIBS += -llog -ldl -landroid

# Uncomment these two lines to add IL2CPP support! (NOT WORKING)
#    LOCAL_SRC_FILES += il2cpp/gc.cpp il2cpp/functions.cpp
#    LOCAL_CFLAGS += -D__IL2CPPUTILS
# Uncomment these two lines to add IL2CPP support! (NOT WORKING)

 ## BUILD ##
include $(BUILD_SHARED_LIBRARY)
```

`Application.mk`:

```mk
APP_STL := c++_static
APP_ABI := armeabi-v7a arm64-v8a
APP_OPTIM := release
APP_PLATFORM := android-21
NDK_TOOLCHAIN_VERSION := clang
```

`LICENSE`:

```
MIT License

Copyright (c) 2021 RusJJ

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# What is that?!
AML is a mod loader for almost ANY android game or application!

AML has been started as a GTA-series mod loader AND as a Gorilla Tag mod loader. Since Gorilla Tag is a Unity-application, AML should be "upgraded" with some IL2CPP tools that are NOT ready now. That means you CAN mod for Unity-games but you NEED some external tools.

# How is this working?
AML provides you an interface system (like in Source Engine). You can add your own interfaces or get an AML Interface (does automatically on mod declaration) that can you help with: patching, memory writing, functions hooking & more (it uses ARMPatch that was made using of 4x11's ARMhook and DobbyHook).

AML should be loaded after all libraries somehow. For example: added through the smali code (easiest way?).

AML supports hard dependencies and can help you get info about mod (if it's loaded) just like a SOFT dependency. That's really cool.

# Examples
For any examples visit the repository for all official mods: https://github.com/AndroidModLoader?tab=repositories

# Discord
Discord Server of this project located here: https://discord.gg/2MY7W39kBg

# Web
We now have a WEB site everyone may use now! It`s still in progress so everything may look bad: https://aml-mods.ru/

# YouTube
We DO have a YouTube channel but it`s inactive for a reason: https://www.youtube.com/@amloader

```

`alog.cpp`:

```cpp
#include <stdarg.h>
#include <fstream>
#include <time.h>
#include <aml.h>
#include <mod/logger.h>
#include <android/log.h>

void* hAndroidLog;
bool bAndroidLog_OnlyImportant, bAndroidLog_NoAfter;
std::ofstream oAndroidLogFile;

inline const char* EnumPriority(int prio)
{
    switch(prio)
    {
        case ANDROID_LOG_UNKNOWN: return "UNKNOWN";
        case ANDROID_LOG_DEFAULT: return "DEFAULT";
        case ANDROID_LOG_VERBOSE: return "VERBOSE";
        case ANDROID_LOG_DEBUG:   return "DEBUG";
        case ANDROID_LOG_INFO:    return "INFO";
        case ANDROID_LOG_WARN:    return "WARN";
        case ANDROID_LOG_ERROR:   return "ERROR";
        case ANDROID_LOG_FATAL:   return "FATAL";
        case ANDROID_LOG_SILENT:  return "SILENT";
    }
    return "UNKNOWN";
}
inline bool IsImportantLogLevel(int prio)
{
    switch(prio)
    {
        case ANDROID_LOG_DEBUG:
        case ANDROID_LOG_WARN:
        case ANDROID_LOG_ERROR:
        case ANDROID_LOG_FATAL:
            return true;
    }
    return false;
}

char text[4096]; // Log texts are not bigger than 4kb
extern DECL_HOOKv(__aml_log_print, int prio, const char *tag, const char *fmt, ...);
DECL_HOOKv(__aml_log_vprint, int prio, const char *tag, const char *fmt, va_list ap)
{
    if(!fmt) return;
    if(!tag) tag = "AML: Untagged sender";

    vsprintf(text, fmt, ap);
    __aml_log_print(prio, tag, text);

    if(bAndroidLog_OnlyImportant && !IsImportantLogLevel(prio)) return;

    time_t rawtime;
    time ( &rawtime );

    oAndroidLogFile << asctime(localtime ( &rawtime )) << " [" << EnumPriority(prio) << "][AML Hook: " << tag << "] " << text << std::endl << std::endl;
    oAndroidLogFile.flush();
}

DECL_HOOKv(__aml_log_print, int prio, const char *tag, const char *fmt, ...)
{
    if(!fmt) return;

    va_list ap;
    va_start(ap, fmt);
    if(!bAndroidLog_NoAfter) HookOf___aml_log_vprint(prio, tag, fmt, ap);
    va_end(ap);
}

void HookALog()
{
    hAndroidLog = aml->GetLibHandle("liblog.so");
    if(!hAndroidLog) return;

    uintptr_t __android_log_print_addr = aml->GetSym(hAndroidLog, "__android_log_print");
    uintptr_t __android_log_vprint_addr = aml->GetSym(hAndroidLog, "__android_log_vprint");

    if(!__android_log_print_addr && !__android_log_vprint_addr)
    {
        logger->Error("AML Core just failed to patch logs function!");
        return;
    }

    char path[320];
    sprintf(path, "%s/android_log_print.txt", aml->GetAndroidDataRootPath());
    oAndroidLogFile.open(path, std::ios::out | std::ios::trunc);

    if(oAndroidLogFile.is_open())
    {
        if(__android_log_print_addr) HOOK(__aml_log_print, __android_log_print_addr);
        if(__android_log_vprint_addr) HOOK(__aml_log_vprint, __android_log_vprint_addr);
    }
    else
    {
      an_epic_fail_ever:
        logger->Error("AML Core just failed to open log file!");
    }
}
```

`aml.cpp`:

```cpp
#include <aml.h>
#include <mod/logger.h>
#include <ARMPatch/armpatch_src/ARMPatch.h>
#include <vtable_hooker.h>
#include <modslist.h>
#include <mls.h>

#include <curl/curl.h>
#define WC_NO_HARDEN // suppress the annoying warning.
#include <wolfssl/wolfcrypt/md5.h>
#include <stdio.h>
#include <time.h>
#include <jnifn.h>

#include <Gloss.h>

char g_szAMLFeatures[2048] = "AML ARMPATCH HOOK CONFIG INTERFACE GLOSS ";
extern char g_szAppName[256], g_szFakeAppName[256];
extern char g_szCfgPath[256];
extern char g_szAndroidDataDir[256];
extern char g_szAndroidDataRootDir[256];
extern char g_szInternalStoragePath[256];
extern char g_szInternalModsDir[256];
extern char g_szUserAgent[256];
extern const char* g_szDataDir;
extern jobject appContext;
extern JNIEnv* env;
extern bool g_bEnableFileDownloads;
extern CURL* curl;
extern int g_nDownloadTimeout;

extern JavaVM *g_pJavaVM;
JNIEnv* GetCurrentJNI();
jobject GetCurrentContext();

inline bool HasFakeAppName()
{
    return (g_szFakeAppName[0] != 0 && strlen(g_szFakeAppName) > 5);
}

const char* AML::GetCurrentGame()
{
    return HasFakeAppName() ? g_szFakeAppName : g_szAppName;
}

const char* AML::GetConfigPath()
{
    return g_szCfgPath;
}

const char* AML::GetDataPath()
{
    return g_szDataDir;
}

const char* AML::GetAndroidDataPath()
{
    return g_szAndroidDataDir;
}

bool AML::HasMod(const char* szGUID)
{
    return modlist->HasMod(szGUID);
}

bool AML::HasModOfVersion(const char* szGUID, const char* szVersion)
{
    return modlist->HasModOfVersion(szGUID, szVersion);
}

uintptr_t AML::GetLib(const char* szLib)
{
    return ARMPatch::GetLib(szLib);
}

uintptr_t AML::GetSym(void* handle, const char* sym)
{
    return ARMPatch::GetSym(handle, sym);
}

uintptr_t AML::GetSym(uintptr_t libAddr, const char* sym)
{
    return ARMPatch::GetSym(libAddr, sym);
}

bool AML::Hook(void* handle, void* fnAddress, void** orgFnAddress)
{
    return ARMPatch::hookInternal(handle, fnAddress, orgFnAddress);
}

bool AML::HookPLT(void* handle, void* fnAddress, void** orgFnAddress)
{
    return ARMPatch::hookPLTInternal(handle, fnAddress, orgFnAddress);
}

int AML::Unprot(uintptr_t handle, size_t len)
{
    return ARMPatch::Unprotect(handle, len);
}

void AML::Write(uintptr_t dest, uintptr_t src, size_t size)
{
    ARMPatch::Write(dest, src, size);
}

void AML::Read(uintptr_t src, uintptr_t dest, size_t size)
{
    ARMPatch::Read(src, dest, size);
}

int AML::PlaceNOP(uintptr_t addr, size_t count)
{
    return ARMPatch::WriteNOP(addr, count);
}

int AML::PlaceJMP(uintptr_t addr, uintptr_t dest)
{
    return ARMPatch::WriteB(addr, dest);
}

int AML::PlaceRET(uintptr_t addr)
{
    return ARMPatch::WriteRET(addr);
}

uintptr_t AML::GetLibLength(const char* szLib)
{
    return ARMPatch::GetLibLength(szLib);
}

int AML::Redirect(uintptr_t addr, uintptr_t to)
{
    return ARMPatch::Redirect(addr, to);
}

void AML::PlaceBL(uintptr_t addr, uintptr_t dest)
{
    ARMPatch::WriteBL(addr, dest);
}

void AML::PlaceBLX(uintptr_t addr, uintptr_t dest)
{
#ifdef AML32
    ARMPatch::WriteBLX(addr, dest);
#else // AML64
    ARMPatch::WriteBL(addr, dest);
#endif
}

uintptr_t AML::PatternScan(const char* pattern, const char* soLib)
{
    return ARMPatch::GetAddressFromPattern(pattern, soLib);
}

uintptr_t AML::PatternScan(const char* pattern, uintptr_t libStart, uintptr_t scanLen)
{
    return ARMPatch::GetAddressFromPattern(pattern, libStart, scanLen);
}

void AML::PatchForThumb(bool forThumb)
{
    ARMPatch::bThumbMode = forThumb;
}

const char* AML::GetFeatures()
{
    return g_szAMLFeatures;
}

void AML::AddFeature(const char* f)
{
    strcat(g_szAMLFeatures, f);
    strcat(g_szAMLFeatures, " ");
}

void AML::HookVtableFunc(void* ptr, unsigned int funcNum, void* func, void** original, bool instantiate)
{
    HookVtableFunc(ptr, funcNum, func, original, instantiate);
}

bool AML::IsGameFaked()
{
    return HasFakeAppName();
}

const char* AML::GetRealCurrentGame()
{
    return g_szAppName;
}

void* AML::GetLibHandle(const char* soLib)
{
    return ARMPatch::GetLibHandle(soLib);
}

void* AML::GetLibHandle(uintptr_t addr)
{
    return ARMPatch::GetLibHandle(addr);
}

bool AML::IsCorrectXDLHandle(void* ptr)
{
    return ARMPatch::IsCorrectXDLHandle(ptr);
}

uintptr_t AML::GetLibXDL(void* ptr)
{
    return ARMPatch::GetLibXDL(ptr);
}

uintptr_t AML::GetAddrBaseXDL(uintptr_t addr)
{
    return ARMPatch::GetAddrBaseXDL(addr);
}

size_t AML::GetSymSizeXDL(void* ptr)
{
    return ARMPatch::GetSymSizeXDL(ptr);
}

const char* AML::GetSymNameXDL(void* ptr)
{
    return ARMPatch::GetSymNameXDL(ptr);
}

void AML::ShowToast(bool longerDuration, const char* fmt, ...)
{
    if(!fmt) return;
    
    static char txt[512];
    va_list args;
    va_start(args, fmt);
    vsnprintf(txt, sizeof(txt), fmt, args);
    ShowToastMessage(GetCurrentJNI(), appContext, txt, longerDuration ? 1 : 0);
    va_end(args);
}

static size_t WriteToFileCB(void* buffer, size_t size, size_t nmemb, void* userdata)
{
    FILE* file = fopen((const char*)userdata, "wb");
    if(!file) return 0;
    
    size_t written = fwrite(buffer, size, nmemb, file);
    fclose(file);
    return written;
}
bool AML::DownloadFile(const char* url, const char* saveto)
{
    if(!g_bEnableFileDownloads) return false;
    if(!curl) return false;
    curl_easy_reset(curl);
    
    FILE* file = fopen(saveto, "a");
    if(!file) return false; // Dont clean it up first!
    fclose(file);
    
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // cURL fails at SSL/TLS here, for some reason
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteToFileCB);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, saveto);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, g_nDownloadTimeout);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, g_szUserAgent);
    
    CURLcode res = curl_easy_perform(curl);
    return res != CURLE_OK;
}

static size_t WriteToDataCB(void* buffer, size_t size, size_t nmemb, MemChunk_t* chunk)
{
    return snprintf(chunk->out, chunk->out_len, "%s", (const char*)buffer);
}
bool AML::DownloadFileToData(const char* url, char* out, size_t outLen)
{
    if(!g_bEnableFileDownloads) return false;
    if(!curl) return false;
    curl_easy_reset(curl);
    
    MemChunk_t chunk = { out, outLen - 1 };
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // cURL fails at SSL/TLS here, for some reason
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteToDataCB);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &chunk);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, g_nDownloadTimeout);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, g_szUserAgent);
    
    CURLcode res = curl_easy_perform(curl);
    out[outLen - 1] = 0;
    return res == CURLE_OK;
}

void AML::FileMD5(const char* path, char* out, size_t out_len)
{
    if(!out || out_len < MINIMUM_MD5_BUF_SIZE) return;
    
    FILE *file;
    wc_Md5 md5Context;
    unsigned char md5Digest[WC_MD5_DIGEST_SIZE];
    out[0] = 0;

    // Open file for reading
    file = fopen(path, "rb");
    if(!file) return;

    // Initialize MD5 context
    wc_InitMd5(&md5Context);

    // Read file contents and update MD5 context
    unsigned char buffer[1024];
    size_t bytesRead;
    while((bytesRead = fread(buffer, 1, sizeof(buffer), file))) {
        wc_Md5Update(&md5Context, buffer, bytesRead);
    }

    // Finalize MD5 context and get hash value
    wc_Md5Final(&md5Context, md5Digest);

    // Save MD5 hash value as hexadecimal string
    char hex[3];
    for(uint8_t i = 0; i < WC_MD5_DIGEST_SIZE; ++i)
    {
        sprintf(hex, "%02x", md5Digest[i]);
        strcat(out, hex);
    }
    out[2 * WC_MD5_DIGEST_SIZE] = 0;

    // Close file
    fclose(file);
}

int AML::GetModsLoadedCount()
{
    return modlist->GetModsNum();
}

JNIEnv* AML::GetJNIEnvironment()
{
    return GetCurrentJNI();
}

jobject AML::GetAppContextObject()
{
    return appContext;
}

bool AML::HasModOfBiggerVersion(const char* szGUID, const char* szVersion)
{
    return modlist->HasModOfBiggerVersion(szGUID, szVersion);
}

void AML::HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* func, void** original, bool instantiate)
{
    HookVtableFunc(ptr, funcNum, count, func, original, instantiate);
}

int AML::PlaceNOP4(uintptr_t addr, size_t count)
{
    return ARMPatch::WriteNOP4(addr, count);
}

const char* AML::GetAndroidDataRootPath()
{
    return g_szAndroidDataRootDir;
}

bool AML::HookB(void* handle, void* fnAddress, void** orgFnAddress)
{
    return ARMPatch::hookBranchInternal(handle, fnAddress, orgFnAddress);
}

bool AML::HookBL(void* handle, void* fnAddress, void** orgFnAddress)
{
    return ARMPatch::hookBranchLinkInternal(handle, fnAddress, orgFnAddress);
}

bool AML::HookBLX(void* handle, void* fnAddress, void** orgFnAddress)
{
#ifdef AML32
    return ARMPatch::hookBranchLinkXInternal(handle, fnAddress, orgFnAddress);
#else // AML64
    return ARMPatch::hookBranchLinkInternal(handle, fnAddress, orgFnAddress);
#endif
}

void AML::MLSSaveFile()
{
    MLS::SaveFile();
}

bool AML::MLSHasValue(const char* key)
{
    return MLS::HasValue(key);
}

void AML::MLSDeleteValue(const char* key)
{
    MLS::DeleteValue(key);
}

void AML::MLSSetInt(const char* key, int32_t val)
{
    MLS::SetInt(key, val);
}

void AML::MLSSetFloat(const char* key, float val)
{
    MLS::SetFloat(key, val);
}

void AML::MLSSetInt64(const char* key, int64_t val)
{
    MLS::SetInt64(key, val);
}

void AML::MLSSetStr(const char* key, const char *val)
{
    MLS::SetStr(key, val);
}

bool AML::MLSGetInt(const char* key, int32_t *val)
{
    return MLS::GetInt(key, val);
}

bool AML::MLSGetFloat(const char* key, float *val)
{
    return MLS::GetFloat(key, val);
}

bool AML::MLSGetInt64(const char* key, int64_t *val)
{
    return MLS::GetInt64(key, val);
}

bool AML::MLSGetStr(const char* key, char *val, size_t len)
{
    return MLS::GetStr(key, val, len);
}

bool AML::IsThumbAddr(uintptr_t addr)
{
    return ARMPatch::IsThumbAddr(addr);
}

uintptr_t AML::GetBranchDest(uintptr_t addr)
{
    return ARMPatch::GetBranchDest(addr);
}

int AML::GetAndroidVersion()
{
    return g_nAndroidSDKVersion;
}

bool AML_CopyFile(const char* file, const char* dest);
bool AML::CopyFile(const char* file, const char* dest)
{
    return AML_CopyFile(file, dest);
}

void AML::RedirectReg(uintptr_t addr, uintptr_t to, bool doShortHook, GlossRegisters::e_reg targetReg)
{
#ifdef AML64
    if(doShortHook) Gloss::Inst::MakeArm64AbsoluteJump32(addr, to, (gloss_reg::e_reg)targetReg);
    else Gloss::Inst::MakeArm64AbsoluteJump(addr, to, (gloss_reg::e_reg)targetReg);
#endif
}

bool AML::HasAddrExecFlag(uintptr_t addr)
{
    return IsAddrExecute(addr);
}

void AML::ToggleHook(PHookHandle hook, bool enable)
{
    if(!hook) return;
    if(enable) GlossHookEnable(hook);
    else GlossHookDisable(hook);
}

void AML::DeHook(PHookHandle hook)
{
    if(!hook) return;
    GlossHookDelete(hook);
}

PHookHandle AML::HookInline(void* fnAddress, HookWithRegistersFn newFn, bool doShortHook)
{
#ifdef AML32
    uintptr_t addr = (uintptr_t)fnAddress;
    if(ARMPatch::IsThumbAddr(addr)) addr |= 0x1;
    return GlossHookInternal((void*)addr, (GlossHookInternalCallback)newFn, doShortHook, (addr & 0x1) ? i_set::$THUMB : i_set::$ARM);
#else // AML64
    return GlossHookInternal(fnAddress, (GlossHookInternalCallback)newFn, doShortHook, i_set::$ARM64);
#endif
}

bool bAML_HasFastmanModified = false;
bool AML::HasFastmanAPKModified()
{
    return bAML_HasFastmanModified;
}

const char* AML::GetInternalPath()
{
    return g_szInternalStoragePath;
}

const char* AML::GetInternalModsPath()
{
    return g_szInternalModsDir;
}

JavaVM* AML::GetJavaVM()
{
    return g_pJavaVM;
}

jobject AML::GetCurrentContext()
{
    return ::GetCurrentContext();
}

jobject g_VibratorObject;
jmethodID g_VibrateLongMethod, g_VibratePatternMethod, g_VibrateCancelMethod;
bool g_bVibratorInited = false;
inline bool InitVibroJNI(JNIEnv* env)
{
    jobject curCtx = ::GetCurrentContext();
    if(!curCtx) return false;

    if(!g_bVibratorInited)
    {
        jclass vibratorCls = env->FindClass("android/os/Vibrator");
        if(!vibratorCls) return false;

        jclass contextCls = env->FindClass("android/content/Context");
        if(!contextCls) return false;

        jmethodID sysServiceMethod = env->GetMethodID(contextCls, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
        jfieldID vibratorSrvField = env->GetStaticFieldID(contextCls, "VIBRATOR_SERVICE", "Ljava/lang/String;");
        jstring vibratorFieldStr = (jstring)env->GetStaticObjectField(contextCls, vibratorSrvField);
        jobject localVibrateObject = env->CallObjectMethod(curCtx, sysServiceMethod, vibratorFieldStr);
        g_VibratorObject = env->NewGlobalRef(localVibrateObject);
        g_VibrateLongMethod = env->GetMethodID(vibratorCls, "vibrate", "(J)V");
        g_VibratePatternMethod = env->GetMethodID(vibratorCls, "vibrate", "([JI)V");
        g_VibrateCancelMethod = env->GetMethodID(vibratorCls, "cancel", "()V");

        env->DeleteLocalRef(vibratorFieldStr);
        env->DeleteLocalRef(vibratorCls);
        env->DeleteLocalRef(contextCls);

        g_bVibratorInited = true;
    }
    return true;
}
void AML::DoVibro(int msTime)
{
    if(msTime < 1 || msTime > 3000) return; // do not vibrate THAT MUCH

    JNIEnv* env = GetCurrentJNI();
    if(!env) return;

    if(InitVibroJNI(env))
    {
        env->CallVoidMethod(g_VibratorObject, g_VibrateLongMethod, (jlong)msTime);
    }
}
void AML::DoVibro(jlong* pattern, int patternItems)
{
    JNIEnv* env = GetCurrentJNI();
    if(!env) return;

    if(InitVibroJNI(env))
    {
        jlongArray patternArray = env->NewLongArray(patternItems);
        env->SetLongArrayRegion(patternArray, 0, patternItems, pattern);
        env->CallVoidMethod(g_VibratorObject, g_VibratePatternMethod, patternArray, -1);

        env->DeleteLocalRef(patternArray);
    }
}
void AML::CancelVibro()
{
    JNIEnv* env = GetCurrentJNI();
    if(env) env->CallVoidMethod(g_VibratorObject, g_VibrateCancelMethod);
}

bool g_bBatteryInited = false;
jstring g_pLevelStr;
float g_fCachedScale;
jmethodID g_GetLevelMethod;
jobject g_BatteryIntent;
float AML::GetBatteryLevel()
{
    JNIEnv* env = GetCurrentJNI();
    if(!env) return -1.0f;

    if(!g_bBatteryInited)
    {
        jclass intentFilterCls = env->FindClass("android/content/IntentFilter");
        jmethodID ctor = env->GetMethodID(intentFilterCls, "<init>", "(Ljava/lang/String;)V");
        jstring action = env->NewStringUTF("android.intent.action.BATTERY_CHANGED");
        jobject filter = env->NewObject(intentFilterCls, ctor, action);
        env->DeleteLocalRef(action);

        jclass contextCls = env->GetObjectClass(::GetCurrentContext());
        jmethodID registerReceiver = env->GetMethodID(contextCls, "registerReceiver", "(Landroid/content/BroadcastReceiver;Landroid/content/IntentFilter;)Landroid/content/Intent;");
        g_BatteryIntent = env->NewGlobalRef(env->CallObjectMethod(::GetCurrentContext(), registerReceiver, NULL, filter));

        jclass intentCls = env->GetObjectClass(g_BatteryIntent);
        g_GetLevelMethod = env->GetMethodID(intentCls, "getIntExtra", "(Ljava/lang/String;I)I");
        g_pLevelStr = (jstring)env->NewGlobalRef(env->NewStringUTF("level"));
        jstring scaleStr = env->NewStringUTF("scale");
        g_fCachedScale = (float)env->CallIntMethod(g_BatteryIntent, g_GetLevelMethod, scaleStr, -1);
        env->DeleteLocalRef(scaleStr);

        g_bBatteryInited = true;
    }

    jint level = env->CallIntMethod(g_BatteryIntent, g_GetLevelMethod, g_pLevelStr, -1);
    return ((level * 100.0f) / g_fCachedScale);
}


static AML amlLocal;
IAML* aml = (IAML*)&amlLocal;
AML* g_pAML = &amlLocal;
```

`curl_config.h`:

```h
/* lib/curl_config.h.  Generated from curl_config.h.in by configure.  */
/* lib/curl_config.h.in.  Generated from configure.ac by autoheader.  */
/* when building libcurl itself */
/* #undef BUILDING_LIBCURL */
/* Location of default ca bundle */
#define CURL_CA_BUNDLE "/etc/ssl/certs/ca-certificates.crt"
/* Location of default ca path */
/* #undef CURL_CA_PATH */
/* to disable cookies support */
/* #undef CURL_DISABLE_COOKIES */
/* to disable cryptographic authentication */
/* #undef CURL_DISABLE_CRYPTO_AUTH */
/* to disable DICT */
/* #undef CURL_DISABLE_DICT */
/* to disable FILE */
/* #undef CURL_DISABLE_FILE */
/* to disable FTP */
/* #undef CURL_DISABLE_FTP */
/* to disable HTTP */
/* #undef CURL_DISABLE_HTTP */
/* to disable IMAP */
/* #undef CURL_DISABLE_IMAP */
/* to disable LDAP */
#define CURL_DISABLE_LDAP 1
/* to disable LDAPS */
#define CURL_DISABLE_LDAPS 1
/* to disable POP3 */
/* #undef CURL_DISABLE_POP3 */
/* to disable proxies */
/* #undef CURL_DISABLE_PROXY */
/* to disable RTSP */
/* #undef CURL_DISABLE_RTSP */
/* to disable SMTP */
/* #undef CURL_DISABLE_SMTP */
/* to disable TELNET */
/* #undef CURL_DISABLE_TELNET */
/* to disable TFTP */
/* #undef CURL_DISABLE_TFTP */
/* to disable verbose strings */
/* #undef CURL_DISABLE_VERBOSE_STRINGS */
/* to make a symbol visible */
/* #undef CURL_EXTERN_SYMBOL */
/* to enable hidden symbols */
/* #undef CURL_HIDDEN_SYMBOLS */
/* W$ LDAP with non-W$ compiler */
/* #undef CURL_LDAP_HYBRID */
/* Use W$ LDAP implementation */
/* #undef CURL_LDAP_WIN */
/* when not building a shared library */
/* #undef CURL_STATICLIB */
/* your Entropy Gathering Daemon socket pathname */
/* #undef EGD_SOCKET */
/* Define if you want to enable IPv6 support */
#define ENABLE_IPV6 1
/* Define to the type qualifier of arg 1 for getnameinfo. */
#define GETNAMEINFO_QUAL_ARG1 const
/* Define to the type of arg 1 for getnameinfo. */
#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *
/* Define to the type of arg 2 for getnameinfo. */
#define GETNAMEINFO_TYPE_ARG2 socklen_t
/* Define to the type of args 4 and 6 for getnameinfo. */
#define GETNAMEINFO_TYPE_ARG46 socklen_t
/* Define to the type of arg 7 for getnameinfo. */
#define GETNAMEINFO_TYPE_ARG7 unsigned int
/* Specifies the number of arguments to getservbyport_r */
#define GETSERVBYPORT_R_ARGS 6
/* Specifies the size of the buffer to pass to getservbyport_r */
#define GETSERVBYPORT_R_BUFSIZE 4096
/* Define to 1 if you have the alarm function. */
#define HAVE_ALARM 1
/* Define to 1 if you have the <alloca.h> header file. */
#define HAVE_ALLOCA_H 1
/* Define to 1 if you have the <arpa/inet.h> header file. */
#define HAVE_ARPA_INET_H 1
/* Define to 1 if you have the <arpa/tftp.h> header file. */
#define HAVE_ARPA_TFTP_H 1
/* Define to 1 if you have the <assert.h> header file. */
#define HAVE_ASSERT_H 1
/* Define to 1 if you have the basename function. */
#define HAVE_BASENAME 1
/* Define to 1 if bool is an available type. */
#define HAVE_BOOL_T 1
/* Define to 1 if you have the clock_gettime function and monotonic timer. */
#define HAVE_CLOCK_GETTIME_MONOTONIC 1
/* Define to 1 if you have the closesocket function. */
/* #undef HAVE_CLOSESOCKET */
/* Define to 1 if you have the CloseSocket camel case function. */
/* #undef HAVE_CLOSESOCKET_CAMEL */
/* Define to 1 if you have the connect function. */
#define HAVE_CONNECT 1
/* Define to 1 if you have the `CRYPTO_cleanup_all_ex_data' function. */
#define HAVE_CRYPTO_CLEANUP_ALL_EX_DATA 1
/* Define to 1 if you have the <crypto.h> header file. */
/* #undef HAVE_CRYPTO_H */
/* Define to 1 if you have the <des.h> header file. */
/* #undef HAVE_DES_H */
/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1
/* Define to 1 if you have the `ENGINE_cleanup' function. */
//#define HAVE_ENGINE_CLEANUP 1
/* Define to 1 if you have the `ENGINE_load_builtin_engines' function. */
//#define HAVE_ENGINE_LOAD_BUILTIN_ENGINES 1
/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1
/* Define to 1 if you have the <err.h> header file. */
/* #undef HAVE_ERR_H */
/* Define to 1 if you have the fcntl function. */
#define HAVE_FCNTL 1
/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1
/* Define to 1 if you have a working fcntl O_NONBLOCK function. */
#define HAVE_FCNTL_O_NONBLOCK 1
/* Define to 1 if you have the fdopen function. */
#define HAVE_FDOPEN 1
/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1
/* Define to 1 if you have the freeaddrinfo function. */
#define HAVE_FREEADDRINFO 1
/* Define to 1 if you have the freeifaddrs function. */
// not in bionic
//#define HAVE_FREEIFADDRS 1
/* Define to 1 if you have the ftruncate function. */
#define HAVE_FTRUNCATE 1
/* Define to 1 if you have a working getaddrinfo function. */
#define HAVE_GETADDRINFO 1
/* Define to 1 if the getaddrinfo function is threadsafe. */
#define HAVE_GETADDRINFO_THREADSAFE 1
/* Define to 1 if you have the `geteuid' function. */
#define HAVE_GETEUID 1
/* Define to 1 if you have the gethostbyaddr function. */
#define HAVE_GETHOSTBYADDR 1
/* Define to 1 if you have the gethostbyaddr_r function. */
#define HAVE_GETHOSTBYADDR_R 1
/* gethostbyaddr_r() takes 5 args */
/* #undef HAVE_GETHOSTBYADDR_R_5 */
/* gethostbyaddr_r() takes 7 args */
/* #undef HAVE_GETHOSTBYADDR_R_7 */
/* gethostbyaddr_r() takes 8 args */
#define HAVE_GETHOSTBYADDR_R_8 1
/* Define to 1 if you have the gethostbyname function. */
#define HAVE_GETHOSTBYNAME 1
/* Define to 1 if you have the gethostbyname_r function. */
#define HAVE_GETHOSTBYNAME_R 1
/* gethostbyname_r() takes 3 args */
/* #undef HAVE_GETHOSTBYNAME_R_3 */
/* gethostbyname_r() takes 5 args */
/* #undef HAVE_GETHOSTBYNAME_R_5 */
/* gethostbyname_r() takes 6 args */
#define HAVE_GETHOSTBYNAME_R_6 1
/* Define to 1 if you have the gethostname function. */
#define HAVE_GETHOSTNAME 1
/* Define to 1 if you have a working getifaddrs function. */
// not in bionic
//#define HAVE_GETIFADDRS 1
/* Define to 1 if you have the getnameinfo function. */
#define HAVE_GETNAMEINFO 1
/* Define to 1 if you have the `getpass_r' function. */
/* #undef HAVE_GETPASS_R */
/* Define to 1 if you have the `getppid' function. */
#define HAVE_GETPPID 1
/* Define to 1 if you have the `getprotobyname' function. */
#define HAVE_GETPROTOBYNAME 1
/* Define to 1 if you have the `getpwuid' function. */
#define HAVE_GETPWUID 1
/* Define to 1 if you have the `getrlimit' function. */
#define HAVE_GETRLIMIT 1
/* Define to 1 if you have the getservbyport_r function. */
#define HAVE_GETSERVBYPORT_R 1
/* Define to 1 if you have the `gettimeofday' function. */
#define HAVE_GETTIMEOFDAY 1
/* Define to 1 if you have a working glibc-style strerror_r function. */
/* #undef HAVE_GLIBC_STRERROR_R */
/* Define to 1 if you have a working gmtime_r function. */
#define HAVE_GMTIME_R 1
/* if you have the gssapi libraries */
/* #undef HAVE_GSSAPI */
/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
/* #undef HAVE_GSSAPI_GSSAPI_GENERIC_H */
/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
/* #undef HAVE_GSSAPI_GSSAPI_H */
/* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */
/* #undef HAVE_GSSAPI_GSSAPI_KRB5_H */
/* if you have the GNU gssapi libraries */
/* #undef HAVE_GSSGNU */
/* if you have the Heimdal gssapi libraries */
/* #undef HAVE_GSSHEIMDAL */
/* if you have the MIT gssapi libraries */
/* #undef HAVE_GSSMIT */
/* Define to 1 if you have the `idna_strerror' function. */
/* #undef HAVE_IDNA_STRERROR */
/* Define to 1 if you have the `idn_free' function. */
/* #undef HAVE_IDN_FREE */
/* Define to 1 if you have the <idn-free.h> header file. */
/* #undef HAVE_IDN_FREE_H */
/* Define to 1 if you have the <ifaddrs.h> header file. */
// not in bionic
// #define HAVE_IFADDRS_H 1
/* Define to 1 if you have the `inet_addr' function. */
#define HAVE_INET_ADDR 1
/* Define to 1 if you have the inet_ntoa_r function. */
/* #undef HAVE_INET_NTOA_R */
/* inet_ntoa_r() takes 2 args */
/* #undef HAVE_INET_NTOA_R_2 */
/* inet_ntoa_r() takes 3 args */
/* #undef HAVE_INET_NTOA_R_3 */
/* Define to 1 if you have a IPv6 capable working inet_ntop function. */
#define HAVE_INET_NTOP 1
/* Define to 1 if you have a IPv6 capable working inet_pton function. */
#define HAVE_INET_PTON 1
/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1
/* Define to 1 if you have the ioctl function. */
// Defined by AndroidConfig.h that is automticaly included in builds
#undef HAVE_IOCTL
#define HAVE_IOCTL 1
/* Define to 1 if you have the ioctlsocket function. */
/* #undef HAVE_IOCTLSOCKET */
/* Define to 1 if you have the IoctlSocket camel case function. */
/* #undef HAVE_IOCTLSOCKET_CAMEL */
/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.
   */
/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */
/* Define to 1 if you have a working ioctlsocket FIONBIO function. */
/* #undef HAVE_IOCTLSOCKET_FIONBIO */
/* Define to 1 if you have a working ioctl FIONBIO function. */
#define HAVE_IOCTL_FIONBIO 1
/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */
#define HAVE_IOCTL_SIOCGIFADDR 1
/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */
/* if you have the Kerberos4 libraries (including -ldes) */
/* #undef HAVE_KRB4 */
/* Define to 1 if you have the `krb_get_our_ip_for_realm' function. */
/* #undef HAVE_KRB_GET_OUR_IP_FOR_REALM */
/* Define to 1 if you have the <krb.h> header file. */
/* #undef HAVE_KRB_H */
/* Define to 1 if you have the lber.h header file. */
/* #undef HAVE_LBER_H */
/* Define to 1 if you have the ldapssl.h header file. */
/* #undef HAVE_LDAPSSL_H */
/* Define to 1 if you have the ldap.h header file. */
/* #undef HAVE_LDAP_H */
/* Use LDAPS implementation */
/* #undef HAVE_LDAP_SSL */
/* Define to 1 if you have the ldap_ssl.h header file. */
/* #undef HAVE_LDAP_SSL_H */
/* Define to 1 if you have the `ldap_url_parse' function. */
/* #undef HAVE_LDAP_URL_PARSE */
/* Define to 1 if you have the <libgen.h> header file. */
#define HAVE_LIBGEN_H 1
/* Define to 1 if you have the `idn' library (-lidn). */
/* #undef HAVE_LIBIDN */
/* Define to 1 if you have the `resolv' library (-lresolv). */
/* #undef HAVE_LIBRESOLV */
/* Define to 1 if you have the `resolve' library (-lresolve). */
/* #undef HAVE_LIBRESOLVE */
/* Define to 1 if you have the `ssh2' library (-lssh2). */
/* #undef HAVE_LIBSSH2 */
/* Define to 1 if you have the <libssh2.h> header file. */
/* #undef HAVE_LIBSSH2_H */
/* Define to 1 if you have the `libssh2_version' function. */
/* #undef HAVE_LIBSSH2_VERSION */
/* Define to 1 if you have the `ssl' library (-lssl). */
#define HAVE_LIBSSL 1
/* if zlib is available */
#define HAVE_LIBZ 1
/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1
/* if your compiler supports LL */
#define HAVE_LL 1
/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1
/* Define to 1 if you have a working localtime_r function. */
#define HAVE_LOCALTIME_R 1
/* Define to 1 if the compiler supports the 'long long' data type. */
#define HAVE_LONGLONG 1
/* Define to 1 if you have the malloc.h header file. */
// Defined by AndroidConfig.h that is automticaly included in builds
#undef HAVE_MALLOC_H
#define HAVE_MALLOC_H 1
/* Define to 1 if you have the memory.h header file. */
#define HAVE_MEMORY_H 1
/* Define to 1 if you have the memrchr function or macro. */
/* #undef HAVE_MEMRCHR */
/* Define to 1 if you have the MSG_NOSIGNAL flag. */
#define HAVE_MSG_NOSIGNAL 1
/* Define to 1 if you have the <netdb.h> header file. */
#define HAVE_NETDB_H 1
/* Define to 1 if you have the <netinet/in.h> header file. */
#define HAVE_NETINET_IN_H 1
/* Define to 1 if you have the <netinet/tcp.h> header file. */
#define HAVE_NETINET_TCP_H 1
/* Define to 1 if you have the <net/if.h> header file. */
#define HAVE_NET_IF_H 1
/* Define to 1 if NI_WITHSCOPEID exists and works. */
/* #undef HAVE_NI_WITHSCOPEID */
/* if you have an old MIT gssapi library, lacking GSS_C_NT_HOSTBASED_SERVICE
   */
/* #undef HAVE_OLD_GSSMIT */
/* Define to 1 if you have the <openssl/crypto.h> header file. */
#define HAVE_OPENSSL_CRYPTO_H 1
/* Define to 1 if you have the <openssl/engine.h> header file. */
//#define HAVE_OPENSSL_ENGINE_H 1
/* Define to 1 if you have the <openssl/err.h> header file. */
#define HAVE_OPENSSL_ERR_H 1
/* Define to 1 if you have the <openssl/pem.h> header file. */
#define HAVE_OPENSSL_PEM_H 1
/* Define to 1 if you have the <openssl/pkcs12.h> header file. */
#define HAVE_OPENSSL_PKCS12_H 1
/* Define to 1 if you have the <openssl/rsa.h> header file. */
#define HAVE_OPENSSL_RSA_H 1
/* Define to 1 if you have the <openssl/ssl.h> header file. */
#define HAVE_OPENSSL_SSL_H 1
/* Define to 1 if you have the <openssl/x509.h> header file. */
#define HAVE_OPENSSL_X509_H 1
/* Define to 1 if you have the <pem.h> header file. */
/* #undef HAVE_PEM_H */
/* Define to 1 if you have the `perror' function. */
#define HAVE_PERROR 1
/* Define to 1 if you have the `pipe' function. */
#define HAVE_PIPE 1
/* if you have the function PK11_CreateGenericObject */
/* #undef HAVE_PK11_CREATEGENERICOBJECT */
/* Define to 1 if you have a working poll function. */
#define HAVE_POLL 1
/* If you have a fine poll */
#define HAVE_POLL_FINE 1
/* Define to 1 if you have the <poll.h> header file. */
#define HAVE_POLL_H 1
/* Define to 1 if you have a working POSIX-style strerror_r function. */
#define HAVE_POSIX_STRERROR_R 1
/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1
/* Define to 1 if you have the `RAND_egd' function. */
#define HAVE_RAND_EGD 1
/* Define to 1 if you have the `RAND_screen' function. */
/* #undef HAVE_RAND_SCREEN */
/* Define to 1 if you have the `RAND_status' function. */
#define HAVE_RAND_STATUS 1
/* Define to 1 if you have the recv function. */
#define HAVE_RECV 1
/* Define to 1 if you have the recvfrom function. */
#define HAVE_RECVFROM 1
/* Define to 1 if you have the <rsa.h> header file. */
/* #undef HAVE_RSA_H */
/* Define to 1 if you have the select function. */
#define HAVE_SELECT 1
/* Define to 1 if you have the send function. */
#define HAVE_SEND 1
/* Define to 1 if you have the <setjmp.h> header file. */
#define HAVE_SETJMP_H 1
/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1
/* Define to 1 if you have the `setmode' function. */
/* #undef HAVE_SETMODE */
/* Define to 1 if you have the `setrlimit' function. */
#define HAVE_SETRLIMIT 1
/* Define to 1 if you have the setsockopt function. */
#define HAVE_SETSOCKOPT 1
/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */
/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */
/* Define to 1 if you have the <sgtty.h> header file. */
#define HAVE_SGTTY_H 1
/* Define to 1 if you have the sigaction function. */
#define HAVE_SIGACTION 1
/* Define to 1 if you have the siginterrupt function. */
#define HAVE_SIGINTERRUPT 1
/* Define to 1 if you have the signal function. */
#define HAVE_SIGNAL 1
/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1
/* Define to 1 if you have the sigsetjmp function or macro. */
#define HAVE_SIGSETJMP 1
/* Define to 1 if sig_atomic_t is an available typedef. */
#define HAVE_SIG_ATOMIC_T 1
/* Define to 1 if sig_atomic_t is already defined as volatile. */
/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */
/* Define to 1 if struct sockaddr_in6 has the sin6_scope_id member */
#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1
/* Define to 1 if you have the socket function. */
#define HAVE_SOCKET 1
/* Define to 1 if you have the <socket.h> header file. */
/* #undef HAVE_SOCKET_H */
/* Define this if you have the SPNEGO library fbopenssl */
/* #undef HAVE_SPNEGO */
/* Define to 1 if you have the `SSL_get_shutdown' function. */
#define HAVE_SSL_GET_SHUTDOWN 1
/* Define to 1 if you have the <ssl.h> header file. */
/* #undef HAVE_SSL_H */
/* Define to 1 if you have the <stdbool.h> header file. */
#define HAVE_STDBOOL_H 1
/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1
/* Define to 1 if you have the <stdio.h> header file. */
#define HAVE_STDIO_H 1
/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1
/* Define to 1 if you have the strcasecmp function. */
#define HAVE_STRCASECMP 1
/* Define to 1 if you have the strcasestr function. */
/* #undef HAVE_STRCASESTR */
/* Define to 1 if you have the strcmpi function. */
/* #undef HAVE_STRCMPI */
/* Define to 1 if you have the strdup function. */
#define HAVE_STRDUP 1
/* Define to 1 if you have the strerror_r function. */
#define HAVE_STRERROR_R 1
/* Define to 1 if you have the stricmp function. */
/* #undef HAVE_STRICMP */
/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1
/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1
/* Define to 1 if you have the strlcat function. */
/* #undef HAVE_STRLCAT */
/* Define to 1 if you have the `strlcpy' function. */
/* #undef HAVE_STRLCPY */
/* Define to 1 if you have the strncasecmp function. */
#define HAVE_STRNCASECMP 1
/* Define to 1 if you have the strncmpi function. */
/* #undef HAVE_STRNCMPI */
/* Define to 1 if you have the strnicmp function. */
/* #undef HAVE_STRNICMP */
/* Define to 1 if you have the <stropts.h> header file. */
// not in bionic
//#define HAVE_STROPTS_H 1
/* Define to 1 if you have the strstr function. */
#define HAVE_STRSTR 1
/* Define to 1 if you have the strtok_r function. */
#define HAVE_STRTOK_R 1
/* Define to 1 if you have the strtoll function. */
#define HAVE_STRTOLL 1
/* if struct sockaddr_storage is defined */
#define HAVE_STRUCT_SOCKADDR_STORAGE 1
/* Define to 1 if you have the timeval struct. */
#define HAVE_STRUCT_TIMEVAL 1
/* Define to 1 if you have the <sys/filio.h> header file. */
/* #undef HAVE_SYS_FILIO_H */
/* Define to 1 if you have the <sys/ioctl.h> header file. */
#define HAVE_SYS_IOCTL_H 1
/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1
/* Define to 1 if you have the <sys/poll.h> header file. */
#define HAVE_SYS_POLL_H 1
/* Define to 1 if you have the <sys/resource.h> header file. */
#define HAVE_SYS_RESOURCE_H 1
/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1
/* Define to 1 if you have the <sys/socket.h> header file. */
#define HAVE_SYS_SOCKET_H 1
/* Define to 1 if you have the <sys/sockio.h> header file. */
/* #undef HAVE_SYS_SOCKIO_H */
/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1
/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1
/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1
/* Define to 1 if you have the <sys/uio.h> header file. */
// Defined by AndroidConfig.h that is automticaly included in builds
#undef HAVE_SYS_UIO_H
#define HAVE_SYS_UIO_H 1
/* Define to 1 if you have the <sys/un.h> header file. */
#define HAVE_SYS_UN_H 1
/* Define to 1 if you have the <sys/utime.h> header file. */
/* #undef HAVE_SYS_UTIME_H */
/* Define to 1 if you have the <termios.h> header file. */
#define HAVE_TERMIOS_H 1
/* Define to 1 if you have the <termio.h> header file. */
// Defined by AndroidConfig.h that is automticaly included in builds
#undef HAVE_TERMIO_H
#define HAVE_TERMIO_H 1
/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1
/* Define to 1 if you have the <tld.h> header file. */
/* #undef HAVE_TLD_H */
/* Define to 1 if you have the `tld_strerror' function. */
/* #undef HAVE_TLD_STRERROR */
/* Define to 1 if you have the `uname' function. */
#define HAVE_UNAME 1
/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1
/* Define to 1 if you have the `utime' function. */
#define HAVE_UTIME 1
/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1
/* Define to 1 if compiler supports C99 variadic macro style. */
#define HAVE_VARIADIC_MACROS_C99 1
/* Define to 1 if compiler supports old gcc variadic macro style. */
#define HAVE_VARIADIC_MACROS_GCC 1
/* Define to 1 if you have the winber.h header file. */
/* #undef HAVE_WINBER_H */
/* Define to 1 if you have the windows.h header file. */
/* #undef HAVE_WINDOWS_H */
/* Define to 1 if you have the winldap.h header file. */
/* #undef HAVE_WINLDAP_H */
/* Define to 1 if you have the winsock2.h header file. */
/* #undef HAVE_WINSOCK2_H */
/* Define to 1 if you have the winsock.h header file. */
/* #undef HAVE_WINSOCK_H */
/* Define this symbol if your OS supports changing the contents of argv */
#define HAVE_WRITABLE_ARGV 1
/* Define to 1 if you have the writev function. */
#define HAVE_WRITEV 1
/* Define to 1 if you have the ws2tcpip.h header file. */
/* #undef HAVE_WS2TCPIP_H */
/* Define to 1 if you have the <x509.h> header file. */
/* #undef HAVE_X509_H */
/* if you have the zlib.h header file */
#define HAVE_ZLIB_H 1
/* Define to the sub-directory in which libtool stores uninstalled libraries.
   */
#define LT_OBJDIR ".libs/"
/* Define to 1 if you are building a native Windows target. */
/* #undef NATIVE_WINDOWS */
/* Define to 1 if you need the lber.h header file even with ldap.h */
/* #undef NEED_LBER_H */
/* Define to 1 if you need the malloc.h header file even with stdlib.h */
/* #undef NEED_MALLOC_H */
/* Define to 1 if you need the memory.h header file even with stdlib.h */
/* #undef NEED_MEMORY_H */
/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */
/* #undef NEED_REENTRANT */
/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */
/* #undef NEED_THREAD_SAFE */
/* cpu-machine-OS */
#define OS "arm-unknown-eabi"
/* Name of package */
#define PACKAGE "curl"
/* Define to the address where bug reports for this package should be sent. */
#define PACKAGE_BUGREPORT "a suitable curl mailing list => http://curl.haxx.se/mail/"
/* Define to the full name of this package. */
#define PACKAGE_NAME "curl"
/* Define to the full name and version of this package. */
#define PACKAGE_STRING "curl -"
/* Define to the one symbol short name of this package. */
#define PACKAGE_TARNAME "curl"
/* Define to the home page for this package. */
#define PACKAGE_URL ""
/* Define to the version of this package. */
#define PACKAGE_VERSION "-"
/* a suitable file to read random data from */
#define RANDOM_FILE "/dev/urandom"
/* Define to the type of arg 1 for recvfrom. */
#define RECVFROM_TYPE_ARG1 int
/* Define to the type pointed by arg 2 for recvfrom. */
#define RECVFROM_TYPE_ARG2 void
/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */
#define RECVFROM_TYPE_ARG2_IS_VOID 1
/* Define to the type of arg 3 for recvfrom. */
#define RECVFROM_TYPE_ARG3 size_t
/* Define to the type of arg 4 for recvfrom. */
#define RECVFROM_TYPE_ARG4 int
/* Define to the type pointed by arg 5 for recvfrom. */
#define RECVFROM_TYPE_ARG5 struct sockaddr
/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */
/* #undef RECVFROM_TYPE_ARG5_IS_VOID */
/* Define to the type pointed by arg 6 for recvfrom. */
#define RECVFROM_TYPE_ARG6 socklen_t
/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */
/* #undef RECVFROM_TYPE_ARG6_IS_VOID */
/* Define to the function return type for recvfrom. */
#define RECVFROM_TYPE_RETV ssize_t
/* Define to the type of arg 1 for recv. */
#define RECV_TYPE_ARG1 int
/* Define to the type of arg 2 for recv. */
#define RECV_TYPE_ARG2 void *
/* Define to the type of arg 3 for recv. */
#define RECV_TYPE_ARG3 size_t
/* Define to the type of arg 4 for recv. */
#define RECV_TYPE_ARG4 int
/* Define to the function return type for recv. */
#define RECV_TYPE_RETV ssize_t
/* Define as the return type of signal handlers (`int' or `void'). */
#define RETSIGTYPE void
/* Define to the type qualifier of arg 5 for select. */
#define SELECT_QUAL_ARG5 
/* Define to the type of arg 1 for select. */
#define SELECT_TYPE_ARG1 int
/* Define to the type of args 2, 3 and 4 for select. */
#define SELECT_TYPE_ARG234 fd_set *
/* Define to the type of arg 5 for select. */
#define SELECT_TYPE_ARG5 struct timeval *
/* Define to the function return type for select. */
#define SELECT_TYPE_RETV int
/* Define to the type qualifier of arg 2 for send. */
#define SEND_QUAL_ARG2 const
/* Define to the type of arg 1 for send. */
#define SEND_TYPE_ARG1 int
/* Define to the type of arg 2 for send. */
#define SEND_TYPE_ARG2 void *
/* Define to the type of arg 3 for send. */
#define SEND_TYPE_ARG3 size_t
/* Define to the type of arg 4 for send. */
#define SEND_TYPE_ARG4 int
/* Define to the function return type for send. */
#define SEND_TYPE_RETV ssize_t
/* The size of `int', as computed by sizeof. */
#define SIZEOF_INT 4
/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 8
/* The size of `off_t', as computed by sizeof. */
#define SIZEOF_OFF_T 8
/* The size of `short', as computed by sizeof. */
#define SIZEOF_SHORT 2
/* The size of `size_t', as computed by sizeof. */
#define SIZEOF_SIZE_T 8
/* The size of `time_t', as computed by sizeof. */
#define SIZEOF_TIME_T 8
/* The size of `void*', as computed by sizeof. */
#define SIZEOF_VOIDP 8
/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1
/* Define to the type of arg 3 for strerror_r. */
#define STRERROR_R_TYPE_ARG3 size_t
/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1
/* Define to enable c-ares support */
/* #undef USE_ARES */
/* Define to disable non-blocking sockets. */
/* #undef USE_BLOCKING_SOCKETS */
/* if GnuTLS is enabled */
/* #undef USE_GNUTLS */
/* if libSSH2 is in use */
/* #undef USE_LIBSSH2 */
/* If you want to build curl with the built-in manual */
#define USE_MANUAL 1
/* if NSS is enabled */
/* #undef USE_NSS */
/* if OpenSSL is in use */
#define USE_OPENSSL 1
/* if SSL is enabled */
#define USE_SSLEAY 1
/* Define to 1 if you are building a Windows target without large file
   support. */
/* #undef USE_WIN32_LARGE_FILES */
/* to enable SSPI support */
/* #undef USE_WINDOWS_SSPI */
/* Define to 1 if using yaSSL in OpenSSL compatibility mode. */
/* #undef USE_YASSLEMUL */
/* Version number of package */
#define VERSION "7.20.1"
/* Define to avoid automatic inclusion of winsock.h */
/* #undef WIN32_LEAN_AND_MEAN */
/* Define to 1 if OS is AIX. */
#ifndef _ALL_SOURCE
/* #  undef _ALL_SOURCE */
#endif
/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */
/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */
/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */
/* Type to use in place of in_addr_t when system does not provide it. */
/* #undef in_addr_t */
/* Define to `__inline__' or `__inline' if that's what the C compiler
   calls it, or to nothing if 'inline' is not supported under any name.  */
#ifndef __cplusplus
/* #undef inline */
#endif
/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */
/* the signed version of size_t */
/* #undef ssize_t */




#define SIZEOF_CURL_OFF_T 8
```

`external/README.md`:

```md
### How do i start an AML core? (AML 1.3 and earlier)
Open classes.dex of an application, head to the class which loads the library you want to modify (System.loadLibrary).
Modify smali code by adding this after the library you want to mod (to ensure its okay):
```
const-string v0, "AML"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
```
Please make sure register **v0** is not in use or use another one.

### How do i start an AML core? (AML 1.4 and later)
Starting with AML v1.4 there is an additional way to load the library before the application library loads (kinda).
If you prefer the old way, just load the game but also call an additional native Java function:
```
const-string v0, "AML"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
invoke-static {}, Lnet/rusjj/amlcore;->launchAMLCore()V
```
Make sure you've already added a Java-class (amlcore.smali) to your project.

A variant of loading AML early looks like that:
```
const-string v0, "AML"
invoke-static {v0}, Ljava/lang/System;->loadLibrary(Ljava/lang/String;)V
const-string v0, "libENGINE.so"
const-string v1, "libGAME.so"
invoke-static {v0, v1}, Lnet/rusjj/amlcore;->earlyLaunchAMLCore(Ljava/lang/String;Ljava/lang/String;)V
```
That way you can replace an original System.loadLibrary call because this function will load the application library.
Currently it only is loading BEFORE JNI_OnLoad. You cannot work with init arrays.
```

`external/java/net/rusjj/amlcore.java`:

```java
package net.rusjj;
public class amlcore
{
    public native void launchAMLCore();
    public native void earlyLaunchAMLCore(String lib1, String lib2);
}
```

`external/java/net/rusjj/amlcore.smali`:

```smali
.class public Lnet/rusjj/amlcore;
.super Ljava/lang/Object;
.source "amlcore.java"

.method public constructor <init>()V
    .registers 1
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V
    return-void
.end method

.method public static native earlyLaunchAMLCore(Ljava/lang/String;Ljava/lang/String;)V
.end method

.method public static native launchAMLCore()V
.end method
```

`icfg.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include <icfg_desc.h>
#include <mod/thirdparty/inicpp.h>
#include <mod/logger.h>
#include <fstream>

#include <mod/iaml.h>

extern char g_szCfgPath[0xFF];

void* CFG::InitIniPointer()
{
    void* ret = new ini::IniFile;
    return ret;
}
void CFG::ParseInputStream(void* iniPointer, const char* szFilename)
{
    char path[0xFF];
    snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, szFilename);
    ((ini::IniFile*)iniPointer)->load(path);
}
void CFG::GenerateToOutputStream(void* iniPointer, const char* szFilename)
{
    char path[0xFF];
    snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, szFilename);
    ((ini::IniFile*)iniPointer)->save(path);
}
const char* CFG::GetValueFrom(void* iniPointer, const char* szSection, const char* szKey)
{
    return (*(ini::IniFile*)iniPointer)[szSection][szKey].as<const char*>();
}
void CFG::SetValueTo(void* iniPointer, const char* szSection, const char* szKey, const char* szValue)
{
    (*(ini::IniFile*)iniPointer)[szSection][szKey] = szValue;
}

```

`icfg_desc.h`:

```h
#include <mod/icfg.h>

class CFG : public ICFG
{
public:
    void* InitIniPointer();
    void ParseInputStream(void* iniPointer, const char* szFilename);
    void GenerateToOutputStream(void* iniPointer, const char* szFilename);
    const char* GetValueFrom(void* iniPointer, const char* szSection, const char* szKey);
    void SetValueTo(void* iniPointer, const char* szSection, const char* szKey, const char* szValue);
};
```

`il2cpp/functions.cpp`:

```cpp
#include <mod/iaml.h>
#include <mod/logger.h>
#include <dlfcn.h>

namespace IL2CPP::Func
{
    void* pIL2CPP = NULL;
    static bool m_bInitialized = false;
    void HookFunctions()
    {
        if(m_bInitialized) return;

        if(!(pIL2CPP = dlopen("libil2cpp.so", RTLD_LAZY)))
        {
            logger->Error("IL2CPP: Looks like this is not a Unity game?");
            return;
        }

        m_bInitialized = true;
    }
}
```

`il2cpp/functions.h`:

```h
#include <mod/il2cpp.h>
#include "types.h"
#include "typedefs.h"

namespace IL2CPP::Func
{
    /* Just a functions of our Utils */
    void HookFunctions();

    /* Pointers to IL2 functions */
	  #ifdef UNITY_2019
        int (*init)(const char* domain_name);
        int (*init_utf16)(const IL2Char * domain_name);
    #else
        void (*init)(const char* domain_name);
        void (*init_utf16)(const IL2Char * domain_name);
    #endif
    void (*shutdown)();
    void (*set_config_dir)(const char *config_path);
    void (*set_data_dir)(const char *data_path);
    void (*set_temp_dir)(const char *temp_path);
    void (*set_commandline_arguments)(int argc, const char* const argv[], const char* basedir);
    void (*set_commandline_arguments_utf16)(int argc, const IL2Char * const argv[], const char* basedir);
    void (*set_config_utf16)(const IL2Char * executablePath);
    void (*set_config)(const char* executablePath);
    void (*set_memory_callbacks)(IL2MemoryCallbacks * callbacks);
    const IL2Image* (*get_corlib)();
    void (*add_internal_call)(const char* name, IL2MethodPointer method);
    IL2MethodPointer (*resolve_icall)(const char* name);
    void* (*alloc)(size_t size);
    void (*free)(void* ptr);
    IL2Class* (*array_class_get)(IL2Class * element_class, uint32_t rank);
    uint32_t (*array_length)(IL2Array * array);
    uint32_t (*array_get_byte_length)(IL2Array * array);
    IL2Array* (*array_new)(IL2Class * elementTypeInfo, IL2ArraySize_t length);
    IL2Array* (*array_new_specific)(IL2Class * arrayTypeInfo, IL2ArraySize_t length);
    IL2Array* (*array_new_full)(IL2Class * array_class, IL2ArraySize_t * lengths, IL2ArraySize_t * lower_bounds);
    IL2Class* (*bounded_array_class_get)(IL2Class * element_class, uint32_t rank, bool bounded);
    int (*array_element_size)(const IL2Class * array_class);
    const IL2Image* (*assembly_get_image)(const IL2Assembly * assembly);
    #ifdef UNITY_2019
		void (*class_for_each)(void(*klassReportFunc)(IL2Class* klass, void* userData), void* userData);
    #endif
    const IL2Type* (*class_enum_basetype)(IL2Class * klass);
    bool (*class_is_generic)(const IL2Class * klass);
    bool (*class_is_inflated)(const IL2Class * klass);
    bool (*class_is_assignable_from)(IL2Class * klass, IL2Class * oklass);
    bool (*class_is_subclass_of)(IL2Class * klass, IL2Class * klassc, bool check_interfaces);
    bool (*class_has_parent)(IL2Class * klass, IL2Class * klassc);
    IL2Class* (*class_from_IL2_type)(const IL2Type * type);
    IL2Class* (*class_from_name)(const IL2Image * image, const char* namespaze, const char *name);
    IL2Class* (*class_from_system_type)(IL2ReflectionType * type);
    IL2Class* (*class_get_element_class)(IL2Class * klass);
    const EventInfo* (*class_get_events)(IL2Class * klass, void* *iter);
    FieldInfo* (*class_get_fields)(IL2Class * klass, void* *iter);
    IL2Class* (*class_get_nested_types)(IL2Class * klass, void* *iter);
    IL2Class* (*class_get_interfaces)(IL2Class * klass, void* *iter);
    const PropertyInfo* (*class_get_properties)(IL2Class * klass, void* *iter);
    const PropertyInfo* (*class_get_property_from_name)(IL2Class * klass, const char *name);
    FieldInfo* (*class_get_field_from_name)(IL2Class * klass, const char *name);
    const MethodInfo* (*class_get_methods)(IL2Class * klass, void* *iter);
    const MethodInfo* (*class_get_method_from_name)(const IL2Class * klass, const char* name, int argsCount);
    const char* (*class_get_name)(const IL2Class * klass);
    #ifdef UNITY_2019
		void (*type_get_name_chunked)(const IL2Type * type, void(*chunkReportFunc)(void* data, void* userData), void* userData);
    #endif
    const char* (*class_get_namespace)(const IL2Class * klass);
    IL2Class* (*class_get_parent)(IL2Class * klass);
    IL2Class* (*class_get_declaring_type)(const IL2Class * klass);
    int32_t (*class_instance_size)(IL2Class * klass);
    size_t (*class_num_fields)(const IL2Class * enumKlass);
    bool (*class_is_valuetype)(const IL2Class * klass);
    int32_t (*class_value_size)(IL2Class * klass, uint32_t * align);
    bool (*class_is_blittable)(const IL2Class * klass);
    int (*class_get_flags)(const IL2Class * klass);
    bool (*class_is_abstract)(const IL2Class * klass);
    bool (*class_is_interface)(const IL2Class * klass);
    int (*class_array_element_size)(const IL2Class * klass);
    IL2Class* (*class_from_type)(const IL2Type * type);
    const IL2Type* (*class_get_type)(IL2Class * klass);
    uint32_t (*class_get_type_token)(IL2Class * klass);
    bool (*class_has_attribute)(IL2Class * klass, IL2Class * attr_class);
    bool (*class_has_references)(IL2Class * klass);
    bool (*class_is_enum)(const IL2Class * klass);
    const IL2Image* (*class_get_image)(IL2Class * klass);
    const char* (*class_get_assemblyname)(const IL2Class * klass);
    int (*class_get_rank)(const IL2Class * klass);
    #ifdef UNITY_2019
		uint32_t (*class_get_data_size)(const IL2Class * klass);
		void* (*class_get_static_field_data)(const IL2Class * klass);
    #endif
    size_t (*class_get_bitmap_size)(const IL2Class * klass);
    void (*class_get_bitmap)(IL2Class * klass, size_t * bitmap);
    bool (*stats_dump_to_file)(const char *path);
    uint64_t (*stats_get_value)(IL2Stat stat);
    IL2Domain* (*domain_get)();
    const IL2Assembly* (*domain_assembly_open)(IL2Domain * domain, const char* name);
    const IL2Assembly** (*domain_get_assemblies)(const IL2Domain * domain, size_t * size);
    #ifdef UNITY_2019
		void (*raise_exception)(IL2Exception*);
    #endif
    IL2Exception* (*exception_from_name_msg)(const IL2Image * image, const char *name_space, const char *name, const char *msg);
    IL2Exception* (*get_exception_argument_null)(const char *arg);
    void (*format_exception)(const IL2Exception * ex, char* message, int message_size);
    void (*format_stack_trace)(const IL2Exception * ex, char* output, int output_size);
    void (*unhandled_exception)(IL2Exception*);
    int (*field_get_flags)(FieldInfo * field);
    const char* (*field_get_name)(FieldInfo * field);
    IL2Class* (*field_get_parent)(FieldInfo * field);
    size_t (*field_get_offset)(FieldInfo * field);
    const IL2Type* (*field_get_type)(FieldInfo * field);
    void (*field_get_value)(IL2Object * obj, FieldInfo * field, void *value);
    IL2Object* (*field_get_value_object)(FieldInfo * field, IL2Object * obj);
    bool (*field_has_attribute)(FieldInfo * field, IL2Class * attr_class);
    void (*field_set_value)(IL2Object * obj, FieldInfo * field, void *value);
    void (*field_static_get_value)(FieldInfo * field, void *value);
    void (*field_static_set_value)(FieldInfo * field, void *value);
    void (*field_set_value_object)(IL2Object * instance, FieldInfo * field, IL2Object * value);
    #ifdef UNITY_2019
		bool (*field_is_literal)(FieldInfo * field);
    #endif
    void (*gc_collect)(int maxGenerations);
    int32_t (*gc_collect_a_little)();
    void (*gc_disable)();
    void (*gc_enable)();
    bool (*gc_is_disabled)();
    #ifdef UNITY_2019
		int64_t (*gc_get_max_time_slice_ns)();
		void (*gc_set_max_time_slice_ns)(int64_t maxTimeSlice);
		bool (*gc_is_incremental)();
    #endif
    int64_t (*gc_get_used_size)();
    int64_t (*gc_get_heap_size)();
    void (*gc_wbarrier_set_field)(IL2Object * obj, void **targetAddress, void *object);
    #ifdef UNITY_2019
		bool (*gc_has_strict_wbarriers)();
		void (*gc_set_external_allocation_tracker)(void(*func)(void*, size_t, int));
		void (*gc_set_external_wbarrier_tracker)(void(*func)(void**));
		void (*gc_foreach_heap)(void(*func)(void* data, void* userData), void* userData);
		void (*stop_gc_world)();
		void (*start_gc_world)();
    #endif
    uint32_t (*gchandle_new)(IL2Object * obj, bool pinned);
    uint32_t (*gchandle_new_weakref)(IL2Object * obj, bool track_resurrection);
    IL2Object* (*gchandle_get_target)(uint32_t gchandle);
    void (*gchandle_free)(uint32_t gchandle);
    #ifdef UNITY_2019
		void (*gchandle_foreach_get_target)(void(*func)(void* data, void* userData), void* userData);
		uint32_t (*object_header_size)();
		uint32_t (*array_object_header_size)();
		uint32_t (*offset_of_array_length_in_array_object_header)();
		uint32_t (*offset_of_array_bounds_in_array_object_header)();
		uint32_t (*allocation_granularity)();
    #endif
    void* (*unity_liveness_calculation_begin)(IL2Class * filter, int max_object_count, IL2RegisterObjectCB callback, void* userdata, IL2WorldChangedCB onWorldStarted, IL2WorldChangedCB onWorldStopped);
    void (*unity_liveness_calculation_end)(void* state);
    void (*unity_liveness_calculation_from_root)(IL2Object * root, void* state);
    void (*unity_liveness_calculation_from_statics)(void* state);
    const IL2Type* (*method_get_return_type)(const MethodInfo * method);
    IL2Class* (*method_get_declaring_type)(const MethodInfo * method);
    const char* (*method_get_name)(const MethodInfo * method);
    const MethodInfo* (*method_get_from_reflection)(const IL2ReflectionMethod * method);
    IL2ReflectionMethod* (*method_get_object)(const MethodInfo * method, IL2Class * refclass);
    bool (*method_is_generic)(const MethodInfo * method);
    bool (*method_is_inflated)(const MethodInfo * method);
    bool (*method_is_instance)(const MethodInfo * method);
    uint32_t (*method_get_param_count)(const MethodInfo * method);
    const IL2Type* (*method_get_param)(const MethodInfo * method, uint32_t index);
    IL2Class* (*method_get_class)(const MethodInfo * method);
    bool (*method_has_attribute)(const MethodInfo * method, IL2Class * attr_class);
    uint32_t (*method_get_flags)(const MethodInfo * method, uint32_t * iflags);
    uint32_t (*method_get_token)(const MethodInfo * method);
    const char* (*method_get_param_name)(const MethodInfo * method, uint32_t index);

    // ONLY IF THE PROFILER EXISTS FOR UNITY_2019
    void (*profiler_install)(IL2Profiler * prof, IL2ProfileFunc shutdown_callback);
    void (*profiler_set_events)(IL2ProfileFlags events);
    void (*profiler_install_enter_leave)(IL2ProfileMethodFunc enter, IL2ProfileMethodFunc fleave);
    void (*profiler_install_allocation)(IL2ProfileAllocFunc callback);
    void (*profiler_install_gc)(IL2ProfileGCFunc callback, IL2ProfileGCResizeFunc heap_resize_callback);
    void (*profiler_install_fileio)(IL2ProfileFileIOFunc callback);
    void (*profiler_install_thread)(IL2ProfileThreadFunc start, IL2ProfileThreadFunc end);

    uint32_t (*property_get_flags)(const PropertyInfo * prop);
    const MethodInfo* (*property_get_get_method)(const PropertyInfo * prop);
    const MethodInfo* (*property_get_set_method)(const PropertyInfo * prop);
    const char* (*property_get_name)(const PropertyInfo * prop);
    IL2Class* (*property_get_parent)(const PropertyInfo * prop);
    IL2Class* (*object_get_class)(IL2Object * obj);
    uint32_t (*object_get_size)(IL2Object * obj);
    const MethodInfo* (*object_get_virtual_method)(IL2Object * obj, const MethodInfo * method);
    IL2Object* (*object_new)(const IL2Class * klass);
    void* (*object_unbox)(IL2Object * obj);
    IL2Object* (*value_box)(IL2Class * klass, void* data);
    void (*monitor_enter)(IL2Object * obj);
    bool (*monitor_try_enter)(IL2Object * obj, uint32_t timeout);
    void (*monitor_exit)(IL2Object * obj);
    void (*monitor_pulse)(IL2Object * obj);
    void (*monitor_pulse_all)(IL2Object * obj);
    void (*monitor_wait)(IL2Object * obj);
    bool (*monitor_try_wait)(IL2Object * obj, uint32_t timeout);
    IL2Object* (*runtime_invoke)(const MethodInfo * method, void *obj, void **params, IL2Exception **exc);
    IL2Object* (*runtime_invoke_convert_args)(const MethodInfo * method, void *obj, IL2Object **params, int paramCount, IL2Exception **exc);
    void (*runtime_class_init)(IL2Class * klass);
    void (*runtime_object_init)(IL2Object * obj);
    void (*runtime_object_init_exception)(IL2Object * obj, IL2Exception** exc);
    void (*runtime_unhandled_exception_policy_set)(IL2RuntimeUnhandledExceptionPolicy value);
    int32_t (*string_length)(IL2String * str);
    IL2Char* (*string_chars)(IL2String * str);
    IL2String* (*string_new)(const char* str);
    IL2String* (*string_new_len)(const char* str, uint32_t length);
    IL2String* (*string_new_utf16)(const IL2Char * text, int32_t len);
    IL2String* (*string_new_wrapper)(const char* str);
    IL2String* (*string_intern)(IL2String * str);
    IL2String* (*string_is_interned)(IL2String * str);
    IL2Thread* (*thread_current)();
    IL2Thread* (*thread_attach)(IL2Domain * domain);
    void (*thread_detach)(IL2Thread * thread);
    IL2Thread** (*thread_get_all_attached_threads)(size_t * size);
    bool (*is_vm_thread)(IL2Thread * thread);
    void (*current_thread_walk_frame_stack)(IL2FrameWalkFunc func, void* user_data);
    void (*thread_walk_frame_stack)(IL2Thread * thread, IL2FrameWalkFunc func, void* user_data);
    bool (*current_thread_get_top_frame)(IL2StackFrameInfo * frame);
    bool (*thread_get_top_frame)(IL2Thread * thread, IL2StackFrameInfo * frame);
    bool (*current_thread_get_frame_at)(int32_t offset, IL2StackFrameInfo * frame);
    bool (*thread_get_frame_at)(IL2Thread * thread, int32_t offset, IL2StackFrameInfo * frame);
    int32_t (*current_thread_get_stack_depth)();
    int32_t (*thread_get_stack_depth)(IL2Thread * thread);
    #ifdef UNITY_2019
		void (*override_stack_backtrace)(IL2BacktraceFunc stackBacktraceFunc);
    #endif
    IL2Object* (*type_get_object)(const IL2Type * type);
    int (*type_get_type)(const IL2Type * type);
    IL2Class* (*type_get_class_or_element_class)(const IL2Type * type);
    char* (*type_get_name)(const IL2Type * type);
    bool (*type_is_byref)(const IL2Type * type);
    uint32_t (*type_get_attrs)(const IL2Type * type);
    bool (*type_equals)(const IL2Type * type, const IL2Type * otherType);
    char* (*type_get_assembly_qualified_name)(const IL2Type * type);
    #ifdef UNITY_2019
		bool (*type_is_static)(const IL2Type * type);
		bool (*type_is_pointer_type)(const IL2Type * type);
    #endif
    const IL2Assembly* (*image_get_assembly)(const IL2Image * image);
    const char* (*image_get_name)(const IL2Image * image);
    const char* (*image_get_filename)(const IL2Image * image);
    const MethodInfo* (*image_get_entry_point)(const IL2Image * image);
    size_t (*image_get_class_count)(const IL2Image * image);
    const IL2Class* (*image_get_class)(const IL2Image * image, size_t index);
    IL2ManagedMemorySnapshot* (*capture_memory_snapshot)();
    void (*free_captured_memory_snapshot)(IL2ManagedMemorySnapshot * snapshot);
    void (*set_find_plugin_callback)(IL2SetFindPlugInCallback method);
    void (*register_log_callback)(IL2LogCallback method);
    void (*debugger_set_agent_options)(const char* options);
    bool (*is_debugger_attached)();
    #ifdef UNITY_2019
		void (*register_debugger_agent_transport)(IL2DebuggerTransport * debuggerTransport);
		bool (*debug_get_method_info)(const MethodInfo*, IL2MethodDebugInfo * methodDebugInfo);
    #endif
    void (*unity_install_unitytls_interface)(const void* unitytlsInterfaceStruct);
    IL2CustomAttrInfo* (*custom_attrs_from_class)(IL2Class * klass);
    IL2CustomAttrInfo* (*custom_attrs_from_method)(const MethodInfo * method);
    IL2Object* (*custom_attrs_get_attr)(IL2CustomAttrInfo * ainfo, IL2Class * attr_klass);
    bool (*custom_attrs_has_attr)(IL2CustomAttrInfo * ainfo, IL2Class * attr_klass);
    IL2Array* (*custom_attrs_construct)(IL2CustomAttrInfo * cinfo);
    void (*custom_attrs_free)(IL2CustomAttrInfo * ainfo);
    #ifdef UNITY_2019
		void (*class_set_userdata)(IL2Class * klass, void* userdata);
		int (*class_get_userdata_offset)();
    #endif
}
```

`il2cpp/gc.cpp`:

```cpp
#include <cstdio>
#include <cstring>

namespace IL2CPP::GC
{
    void Free(void* ptr)
    {

    }
    void* Alloc(size_t size)
    {
        void* ptr;

        return ptr;
    }
    void* Realloc(void* ptr, size_t size)
    {
        void* ptr_new;
        memcpy(ptr_new, ptr, size);
        Free(ptr);
        return ptr_new;
    }
}
```

`il2cpp/typedefs.h`:

```h
typedef size_t il2cpp_array_size_t;
```

`il2cpp/types.h`:

```h
struct IL2Assembly;
struct IL2Object;
struct IL2Class;
struct IL2Image;
struct IL2Array;
struct IL2Type;
struct IL2Char;
struct IL2Domain;
struct IL2ReflectionType;
struct IL2Exception;
struct IL2Profiler;
struct IL2String;
struct IL2ProfileFunc;
struct IL2Thread;
struct IL2ReflectionMethod;
struct IL2ManagedMemorySnapshot;
struct IL2StackFrameInfo;
struct IL2CustomAttrInfo;
struct IL2GenericClass;
struct IL2Defaults;
struct IL2MemoryCallbacks;
struct IL2MethodPointer;
struct IL2TypeDefinition;
struct IL2GenericParameter;
struct IL2GenericContainer;
struct Il2CppDomain;
struct IL2ProfileFlags;
struct IL2ProfileMethodFunc;
struct IL2ProfileAllocFunc;
struct IL2ProfileGCFunc;
struct IL2ProfileFileIOFunc;
struct IL2ProfileThreadFunc;
struct IL2RegisterObjectCB;
struct IL2WorldChangedCB;

struct IL2LogCallback;
struct IL2SetFindPlugInCallback;
struct IL2FrameWalkFunc;
struct IL2RuntimeUnhandledExceptionPolicy;
struct IL2ProfileGCResizeFunc;
struct IL2Stat;
struct IL2ArraySize_t;

struct MethodInfo;
struct FieldInfo;
struct PropertyInfo;
struct EventInfo;
```

`include/aml.h`:

```h
#include <mod/iaml.h>

class AML : public IAML
{
public:
    /* AML 1.0.0.0 */
    const char* GetCurrentGame();
    const char* GetConfigPath();
    bool        HasMod(const char* szGUID);
    bool        HasModOfVersion(const char* szGUID, const char* szVersion);
    uintptr_t   GetLib(const char* szLib);
    uintptr_t   GetSym(void* handle, const char* sym);
    bool        Hook(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    bool        HookPLT(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    int         Unprot(uintptr_t handle, size_t len = PAGE_SIZE);
    void        Write(uintptr_t dest, uintptr_t src, size_t size);
    void        Read(uintptr_t src, uintptr_t dest, size_t size);
    int         PlaceNOP(uintptr_t addr, size_t count = 1);
    int         PlaceJMP(uintptr_t addr, uintptr_t dest);
    int         PlaceRET(uintptr_t addr);
    /* AML 1.0.0.4 */
    const char* GetDataPath();
    /* AML 1.0.0.5 */
    const char* GetAndroidDataPath();
    uintptr_t   GetSym(uintptr_t libAddr, const char* sym);
    /* AML 1.0.0.6 */
    uintptr_t   GetLibLength(const char* szLib);
    int         Redirect(uintptr_t addr, uintptr_t to);
    void        PlaceBL(uintptr_t addr, uintptr_t dest);
    void        PlaceBLX(uintptr_t addr, uintptr_t dest);
    uintptr_t   PatternScan(const char* pattern, const char* soLib);
    uintptr_t   PatternScan(const char* pattern, uintptr_t libStart, uintptr_t scanLen);
    /* AML 1.0.1 */
    void        PatchForThumb(bool forThumb);
    const char* GetFeatures();
    void        AddFeature(const char* feature); // Not in interface
    void        HookVtableFunc(void* ptr, unsigned int funcNum, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false);
    bool        IsGameFaked();
    const char* GetRealCurrentGame();
    void*       GetLibHandle(const char* soLib);
    void*       GetLibHandle(uintptr_t addr);
    // xDL
    bool        IsCorrectXDLHandle(void* ptr);
    uintptr_t   GetLibXDL(void* ptr);
    uintptr_t   GetAddrBaseXDL(uintptr_t addr);
    size_t      GetSymSizeXDL(void* ptr);
    const char* GetSymNameXDL(void* ptr);
    /* AML 1.0.2 */
    void        ShowToast(bool longerDuration, const char* fmt, ...);
    bool        DownloadFile(const char* url, const char* saveto);
    bool        DownloadFileToData(const char* url, char* out, size_t outLen);
    void        FileMD5(const char* path, char* out, size_t out_len);
    int         GetModsLoadedCount();
    JNIEnv*     GetJNIEnvironment();
    jobject     GetAppContextObject();
    /* AML 1.0.2.1 */
    bool        HasModOfBiggerVersion(const char* szGUID, const char* szVersion);
    /* AML 1.0.4 */
    void        HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false);
    int         PlaceNOP4(uintptr_t addr, size_t count = 1);
    const char* GetAndroidDataRootPath();
    // GlossHook
    bool        HookB(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    bool        HookBL(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    bool        HookBLX(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    /* AML 1.2 */
    void        MLSSaveFile();
    bool        MLSHasValue(const char* key);
    void        MLSDeleteValue(const char* key);
    void        MLSSetInt(const char* key, int32_t val);
    void        MLSSetFloat(const char* key, float val);
    void        MLSSetInt64(const char* key, int64_t val);
    void        MLSSetStr(const char* key, const char *val);
    bool        MLSGetInt(const char* key, int32_t *val);
    bool        MLSGetFloat(const char* key, float *val);
    bool        MLSGetInt64(const char* key, int64_t *val);
    bool        MLSGetStr(const char* key, char *val, size_t len);
    /* AML 1.2.1 */
    bool        IsThumbAddr(uintptr_t addr);
    uintptr_t   GetBranchDest(uintptr_t addr);
    /* AML 1.2.2 */
    int         GetAndroidVersion();
    bool        CopyFile(const char* file, const char* dest);
    void        RedirectReg(uintptr_t addr, uintptr_t to, bool doShortHook, GlossRegisters::e_reg targetReg);
    bool        HasAddrExecFlag(uintptr_t addr);
    void        ToggleHook(PHookHandle hook, bool enable);
    void        DeHook(PHookHandle hook);
    PHookHandle HookInline(void* fnAddress, HookWithRegistersFn newFn, bool doShortHook = false);
    /* AML 1.2.3 */
    bool        HasFastmanAPKModified();
    const char* GetInternalPath();
    const char* GetInternalModsPath();
    /* AML 1.3.0 */
    JavaVM*     GetJavaVM();
    jobject     GetCurrentContext();
    void        DoVibro(int msTime);
    void        DoVibro(jlong* pattern, int patternItems);
    void        CancelVibro();
    float       GetBatteryLevel();
};

extern char g_szAMLFeatures[2048];
extern AML* g_pAML;
extern int g_nAndroidSDKVersion;
```

`include/defines.h`:

```h
#define CONVERT_THIS_MACRO_CONTENTS_TO_STRING(_macro) #_macro
#define MACROSTRING(_macro) CONVERT_THIS_MACRO_CONTENTS_TO_STRING(_macro) // Use this.
```

`include/interfaces.h`:

```h
#pragma once

class InterfaceSys
{
public:
	void							Register(const char* szInterfaceName, void* pInterfacePointer);
	void*							Get(const char* szInterfaceName);
};

extern InterfaceSys* interfaces;
```

`include/jnifn.h`:

```h
#include <jni.h>

extern JavaVM *g_pJavaVM;

inline jobject GetGlobalContext(JNIEnv *env)
{
    jclass activityThread = env->FindClass("android/app/ActivityThread");
    jmethodID currentActivityThread = env->GetStaticMethodID(activityThread, "currentActivityThread", "()Landroid/app/ActivityThread;");
    jobject at = env->CallStaticObjectMethod(activityThread, currentActivityThread);
    jmethodID getApplication = env->GetMethodID(activityThread, "getApplication", "()Landroid/app/Application;");
    jobject context = env->CallObjectMethod(at, getApplication);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return context;
}

inline jstring GetPackageName(JNIEnv *env, jobject jActivity)
{
    jmethodID method = env->GetMethodID(env->GetObjectClass(jActivity), "getPackageName", "()Ljava/lang/String;");
    jstring ret = (jstring)env->CallObjectMethod(jActivity, method);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

inline jobject GetFilesDir(JNIEnv *env, jobject jActivity)
{
    jmethodID method = env->GetMethodID(env->GetObjectClass(jActivity), "getFilesDir", "()Ljava/io/File;");
    jstring ret = (jstring)env->CallObjectMethod(jActivity, method);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

inline jstring GetAbsolutePath(JNIEnv *env, jobject jFile)
{
    jmethodID method = env->GetMethodID(env->GetObjectClass(jFile), "getAbsolutePath", "()Ljava/lang/String;");
    jstring ret = (jstring)env->CallObjectMethod(jFile, method);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

inline jstring GetAndroidPermission(JNIEnv* env, const char* szPermissionName)
{
    jclass ClassManifestPermission = env->FindClass("android/Manifest$permission");
    jfieldID lid_PERM = env->GetStaticFieldID(ClassManifestPermission, szPermissionName, "Ljava/lang/String;");
    jstring ret = (jstring)env->GetStaticObjectField(ClassManifestPermission, lid_PERM);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

inline bool HasPermissionGranted(JNIEnv* env, jobject jActivity, const char* szPermissionName)
{
    jclass ClassPackageManager = env->FindClass("android/content/pm/PackageManager");
    //bool result = false;
    jstring ls_PERM = GetAndroidPermission(env, szPermissionName);
    jfieldID lid_PERMISSION_GRANTED = env->GetStaticFieldID(ClassPackageManager, "PERMISSION_GRANTED", "I");
    jint PERMISSION_GRANTED = jint(-1);

    PERMISSION_GRANTED = env->GetStaticIntField(ClassPackageManager, lid_PERMISSION_GRANTED);
    jint int_result = env->CallIntMethod(jActivity, env->GetMethodID(env->FindClass("android/content/Context"), "checkSelfPermission", "(Ljava/lang/String;)I"), ls_PERM);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return (int_result == PERMISSION_GRANTED);
}

/*inline void RequestPermissions(JNIEnv* env, jobject jActivity)
{
    jobjectArray perm_array = env->NewObjectArray(2, env->FindClass("java/lang/String"), env->NewStringUTF(""));
    env->SetObjectArrayElement(perm_array, 0, GetAndroidPermission(env, "READ_EXTERNAL_STORAGE"));
    env->SetObjectArrayElement(perm_array, 1, GetAndroidPermission(env, "WRITE_EXTERNAL_STORAGE"));
    env->CallVoidMethod(jActivity, env->GetMethodID(env->FindClass("android/app/Activity"), "requestPermissions", "([Ljava/lang/String;I)V"), perm_array, 0);
}*/

inline jobject GetExternalFilesDir(JNIEnv* env, jobject jActivity) // getExternalFilesDir creates directory in Android/data, lol
{
    jmethodID method = env->GetMethodID(env->GetObjectClass(jActivity), "getExternalFilesDir", "(Ljava/lang/String;)Ljava/io/File;");
    jstring ret = (jstring)env->CallObjectMethod(jActivity, method, NULL);
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

// fastman92
#ifdef FASTMAN92_CODE
inline bool GetExternalFilesDir_FLA(JNIEnv* env, jobject context, char* strPath, size_t bufferSize)
{
    jobject objectFile;
    bool bReadFromF92launcher = false;
    jmethodID methodIDgetExternalFilesDir;

    jclass classF92launcherSettings = env->FindClass("com/fastman92/main_activity_launcher/Settings");

    if (classF92launcherSettings)
    {
        methodIDgetExternalFilesDir = env->GetStaticMethodID(classF92launcherSettings, "getExternalFilesDir", "(Landroid/content/Context;)Ljava/io/File;");
        
        if (methodIDgetExternalFilesDir)
        {
            objectFile = env->CallStaticObjectMethod(classF92launcherSettings, methodIDgetExternalFilesDir, context);
            bReadFromF92launcher = true;
        }
    }

    if (!bReadFromF92launcher)
    {
        if (env->ExceptionCheck()) env->ExceptionClear();

        jclass android_content_Context = env->GetObjectClass(context);

        methodIDgetExternalFilesDir = env->GetMethodID(android_content_Context, "getExternalFilesDir", "(Ljava/lang/String;)Ljava/io/File;");

        objectFile = (jstring)env->CallObjectMethod(context, methodIDgetExternalFilesDir, nullptr);
    }
        
    jclass classFile = env->GetObjectClass(objectFile);

    jmethodID methodIDgetAbsolutePath = env->GetMethodID(classFile, "getAbsolutePath", "()Ljava/lang/String;");
    jstring stringPath = (jstring)env->CallObjectMethod(objectFile, methodIDgetAbsolutePath);

    if (stringPath)
    {
        const char* strPathValueStr = env->GetStringUTFChars(stringPath, NULL);

        strxcpy(strPath, strPathValueStr, bufferSize);
        env->ReleaseStringUTFChars(stringPath, strPathValueStr);
    }
    return bReadFromF92launcher;
}
#endif

inline jobject GetStorageDir(JNIEnv* env) // /storage/emulated/0 instead of /sdcard (example)
{
    jclass classEnvironment = env->FindClass("android/os/Environment");
    jstring ret = (jstring)env->CallStaticObjectMethod(classEnvironment, env->GetStaticMethodID(classEnvironment, "getExternalStorageDirectory", "()Ljava/io/File;"));
    if (env->ExceptionCheck()) env->ExceptionClear();
    return ret;
}

inline void ShowToastMessage(JNIEnv* env, jobject jActivity, const char* txt, int msDuration)
{
    jclass ToastClass = env->FindClass("android/widget/Toast");
    jmethodID makeTextMethodID = env->GetStaticMethodID(ToastClass, "makeText", "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");
    jmethodID showMethodID = env->GetMethodID(ToastClass, "show", "()V");

    jstring message = env->NewStringUTF(txt);
    jint duration = msDuration; // can be Toast.LENGTH_SHORT or Toast.LENGTH_LONG

    jobject toast = env->CallStaticObjectMethod(ToastClass, makeTextMethodID, jActivity, message, duration);
    env->CallVoidMethod(toast, showMethodID);
    
    env->DeleteLocalRef(message);

    if (env->ExceptionCheck()) env->ExceptionClear();
}

inline void ShowToastMessage2(JNIEnv* env, jobject jActivity, const char* txt, jint duration)
{
    jclass ToastClass = env->FindClass("android/widget/Toast");
    jmethodID makeTextMethodID = env->GetStaticMethodID(ToastClass, "makeText", "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");
    jmethodID showMethodID = env->GetMethodID(ToastClass, "show", "()V");
    jmethodID setDurationMethodID = env->GetMethodID(ToastClass, "setDuration", "(I)V");

    jstring message = env->NewStringUTF(txt);
    jobject toast = env->CallStaticObjectMethod(ToastClass, makeTextMethodID, jActivity, message, duration);
    env->CallVoidMethod(toast, setDurationMethodID, duration);
    env->CallVoidMethod(toast, showMethodID);

    env->DeleteLocalRef(message);

    if (env->ExceptionCheck()) env->ExceptionClear();
}
```

`include/mls.h`:

```h
#include <cstdint>

#define MAX_KEY_LEN 12 // Maximum KEY NAME length!
#define MAX_VAL_LEN 24 // Maximum STR VALUE length!

class MLS
{
public:

// Generic
    static void LoadFile();
    static void SaveFile();
    static bool HasValue(const char* key);
    static void DeleteValue(const char* key);

// Set
    static void SetInt(const char* key, int32_t val);
    static void SetFloat(const char* key, float val);
    static void SetInt64(const char* key, int64_t val);
    static void SetStr(const char* key, const char *val);

// Get
    static bool GetInt(const char* key, int32_t *val);
    static bool GetFloat(const char* key, float *val);
    static bool GetInt64(const char* key, int64_t *val);
    static bool GetStr(const char* key, char *val, size_t len);
};
```

`include/modpaks.h`:

```h
#include <curl/curl.h>
#include <modslist.h>

#define FILE_DATA_SIZE 8192

extern CURL* curl;
extern char szFileData[FILE_DATA_SIZE];

void InitCURL();
CURLcode DownloadFile(const char* url, const char* path);
CURLcode DownloadFileToData(const char* url);
void ProcessData(ModDesc* d);

```

`include/modslist.h`:

```h
#ifndef __MODSLIST_H
#define __MODSLIST_H

#include <fstream>
#include <mod/amlmod.h>

class Mods;
extern Mods* listMods;

typedef void (*OnInterfaceAddedFn)(const char*, const void*);
typedef const char* (*GetUpdaterURLFn)();
typedef void (*OnModLoadFn)();
typedef ModInfoDependency* (*GetDependenciesListFn)();
typedef void (*OnGameCrashedFn)(const char*, int, int, uintptr_t, mcontext_t*);
struct ModDesc
{
    ModInfo*            m_pInfo;
    void*               m_pHandle;
    ModInfoDependency*  m_aDependencies;
    char                m_szLibPath[256];

    OnModLoadFn         m_fnOnModLoaded;
    OnModLoadFn         m_fnOnModUnloaded;
    OnModLoadFn         m_fnOnAllModsLoaded;
    GetUpdaterURLFn     m_fnRequestUpdaterURL;
    OnInterfaceAddedFn  m_fnInterfaceAddedCB;
    OnGameCrashedFn     m_fnGameCrashedCB;

    ModDesc()
    {
        m_szLibPath[0] = 0;
        m_fnOnModLoaded = NULL;
        m_fnOnModUnloaded = NULL;
        m_fnOnAllModsLoaded = NULL;
        m_fnRequestUpdaterURL = NULL;
        m_fnInterfaceAddedCB = NULL;
        m_fnGameCrashedCB = NULL;
    }
};

class ModsList
{
// Functions
public:
    bool AddMod(ModInfo* modinfo, void* modhandle, const char* path);
    bool RemoveMod(ModInfo* modinfo);
    bool RemoveMod(const char* szGUID);
    bool HasMod(const char* szGUID);
    bool HasModOfVersion(const char* szGUID, const char* szVersion);
    bool HasModOfBiggerVersion(const char* szGUID, const char* szVersion);
    void ProcessDependencies();
    void ProcessPreLoading();
    void ProcessLoading();
    void ProcessUnloading();
    void ProcessUpdater();
    void ProcessCrash(const char* szLibName, int sig, int code, uintptr_t libaddr, mcontext_t* mcontext);
    int  GetModsNum();
    void PrintModsList(std::ofstream& logfile);

// Callbacks
public:
    void OnInterfaceAdded(const char* name, const void* ptr);
    void OnAllModsLoaded();
};

extern ModsList* modlist;

#endif // __MODSLIST_H

```

`interface.cpp`:

```cpp
#include <jni.h>
#include "interfaces.h"
#include "mod/logger.h"
#define _IAML // Do not include "interface" twice!
#include "modslist.h"
#include "mod/listitem.h"

class Interfaces;
Interfaces* listInterfaces = NULL;
LIST_START(Interfaces)

    LIST_INITSTART(Interfaces)
        pInterface = NULL;
        szName[0] = 0;
    LIST_INITEND()

    static void AddNew(const char* name, void* interface)
    {
        Interfaces* newItem = new Interfaces;
        newItem->pInterface = interface;
        strxcpy(newItem->szName, name, 48);
        newItem->Push(&listInterfaces);
    }
    static void* Get(const char* name)
    {
        LIST_FOR_FAST(listInterfaces)
        {
            if (!strcmp(item->szName, name)) return item->pInterface;
        }
        return NULL;
    }

    void* pInterface;
    char szName[48];
LIST_END()

void InterfaceSys::Register(const char* szInterfaceName, void* pInterfacePointer)
{
    if(szInterfaceName == NULL)
    {
        logger->Error("Failed to add unknown interface to the list because it`s NULL!");
        return;
    }
    if(pInterfacePointer == NULL)
    {
        logger->Error("Failed to add interface %s to the list because it`s NULL!", szInterfaceName);
        return;
    }
    if(Interfaces::Get(szInterfaceName) != NULL)
    {
        logger->Error("Failed to add interface %s to the list because it`s already registered!", szInterfaceName);
        return;
    }
    Interfaces::AddNew(szInterfaceName, pInterfacePointer);
    modlist->OnInterfaceAdded(szInterfaceName, pInterfacePointer);
}

void* InterfaceSys::Get(const char* szInterfaceName)
{
    return Interfaces::Get(szInterfaceName);
}

static InterfaceSys interfacesLocal;
InterfaceSys* interfaces = &interfacesLocal;

extern "C"
{
    JNIEXPORT void* GetInterface(const char* szInterfaceName)
    {
        return interfacesLocal.Get(szInterfaceName);
    }
    JNIEXPORT void CreateInterface(const char* szInterfaceName, void* pInterface)
    {
        return interfacesLocal.Register(szInterfaceName, pInterface);
    }
}
```

`main.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h> // mkdir
#include <sys/sendfile.h> // sendfile
#include <fcntl.h> // "open" flags
#include <dlfcn.h>

#include <aml.h>
#include <defines.h>
#include <modpaks.h>
#include <mls.h>
#include <mod/amlmod.h>
#include <mod/logger.h>
#include <mod/config.h>

#include <jnifn.h>

#ifdef __IL2CPPUTILS
    #include <il2cpp/functions.h>
#endif

// Should be after config.h in main.cpp
#include <icfg_desc.h>
// Should be after config.h in main.cpp

#include <interfaces.h>
#include <modslist.h>

bool g_bShowUpdatedToast, g_bShowUpdateFailedToast, g_bEnableFileDownloads;
bool g_bCrashAML, g_bNoMods, g_bSimplerCrashLog = false, g_bNoSPInLog, g_bNoModsInLog, g_bMLSOnlyManualSaves, g_bDumpAllThreads, g_bEHUnwind, g_bMoreRegsInfo, g_bUnixBacktrace = false;
int g_nEnableNews, g_nDownloadTimeout;
int g_nAndroidSDKVersion = 0;
ConfigEntry* g_pLastNewsId;
char g_szInternalStoragePath[256],
     g_szAppName[256],
     g_szFakeAppName[256],
     g_szModsDir[256],
     g_szInternalModsDir[256],
     g_szAndroidDataRootDir[256],
     g_szAndroidDataDir[256],
     g_szCfgPath[256],
     g_szFastman92Android[256];
const char* g_szDataDir;
char g_szUserAgent[256];

jobject appContext;
JNIEnv* env;

// Main
static ModInfo modinfoLocal("net.rusjj.aml", "AML Core", "1.4", "RusJJ aka [-=KILL MAN=-]");
ModInfo* amlmodinfo = &modinfoLocal;
static Config cfgLocal("ModLoaderCore");
Config* cfg = &cfgLocal;
static CFG icfgLocal; ICFG* icfg = &icfgLocal;

inline size_t __strlen(const char *str)
{
    const char* s = str;
    while(*s) ++s;
    return (s - str);
}

inline bool __ispathdel(char s)
{
    return (s == '\\' || s == '/');
}

inline void __pathback(char *str)
{
    const char* s = str;
    uint16_t i = 0;
    while(*s) ++s;
    while(s != str)
    {
        if(!__ispathdel(*(--s))) break;
    }
    while(s != str)
    {
        if(__ispathdel(*(--s)))
        {
            i = (uint16_t)(s - str);
        }
        else if(i != 0) break;
    }
    if(i > 0) str[i] = 0;
}

inline bool EndsWith(const char* base, const char* str)
{
    static int blen, slen;
    blen = strlen(base);
    slen = strlen(str);
    return (blen >= slen) && (!strcmp(base + blen - slen, str));
}

inline bool EndsWithSO(const char* base)
{
    static int blen;
    blen = strlen(base);
    return (blen >= 3) && (!strcmp(base + blen - 3, ".so"));
}

// Is this actually faster, bruh?
// P.S. Yeah, it is!
inline bool CopyFileFaster(const char* file, const char* dest)
{
    int inFd = open(file, O_RDONLY);
    if(inFd < 0) return false;
    struct stat statBuf;
    fstat(inFd, &statBuf);
    int outFd = open(dest, O_WRONLY | O_CREAT, statBuf.st_mode);
    if(outFd < 0)
    {
        close(inFd);
        return false;
    }
    if(sendfile(outFd, inFd, NULL, statBuf.st_size) < 0)
    {
        close(inFd);
        close(outFd);
        return false;
    }
    close(inFd);
    close(outFd);
    return true;
}
// Slower version (because it copies the file contents byte-by-byte)
inline bool CopyFile(const char* file, const char* dest)
{
    FILE* source = fopen(file, "r");
    if(source == NULL) return false;
    FILE* target = fopen(dest, "w");
    if(target == NULL) 
    {
        fclose(source);
        return false;
    }
    while(!feof(source)) fputc(fgetc(source), target);
    fclose(source);
    fclose(target);
    return true;
}

bool AML_CopyFile(const char* file, const char* dest)
{
    return (!CopyFileFaster(file, dest) && !CopyFile(file, dest));
}

inline bool HasFakeAppName()
{
    return (g_szFakeAppName[0] != 0 && strlen(g_szFakeAppName) > 5);
}

typedef const char* (*SpecificGameFn)();
void LoadMods(const char* path)
{
    ModInfo* pModInfo = NULL;
    SpecificGameFn maybeINeedAGame = NULL;
    GetModInfoFn modInfoFn = NULL;

    char buf[256], dataBuf[256];
    DIR* dir = opendir(path);
    if (dir != NULL)
    {
        logger->Info("Loading mods from %s", path);
        struct dirent *diread; void* handle;
        const char* gameName = HasFakeAppName() ? g_szFakeAppName : g_szAppName;
        while ((diread = readdir(dir)) != NULL)
        {
            if(diread->d_name[0] == '.') continue; // Skip . and ..
            if(!EndsWithSO(diread->d_name))
            {
                // Useless info for us
                //logger->Error("File %s is not a mod, atleast it is NOT .SO file!", diread->d_name);
                continue;
            }
            snprintf(buf, sizeof(buf), "%s/%s", path, diread->d_name);
            snprintf(dataBuf, sizeof(dataBuf), "%s/%s", g_szDataDir, diread->d_name);
            //unlink(dataBuf);
            chmod(dataBuf, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP); // XMDS
            int removeStatus = remove(dataBuf);
            //if(removeStatus != 0) logger->Error("Failed to remove temp mod file! This might break the mod loading. Error %d", removeStatus);
            if(!CopyFileFaster(buf, dataBuf) && !CopyFile(buf, dataBuf))
            {
                logger->Error("File %s is failed to be copied! :(", diread->d_name);
                continue;
            }
            chmod(dataBuf, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP);

            handle = dlopen(dataBuf, RTLD_NOW); // Load it to RAM
            modInfoFn = (GetModInfoFn)dlsym(handle, "__GetModInfo");
            if(modInfoFn != NULL)
            {
                pModInfo = modInfoFn();
                maybeINeedAGame = (SpecificGameFn)dlsym(handle, "__INeedASpecificGame");
                if(maybeINeedAGame != NULL && strcmp(maybeINeedAGame(), gameName) != 0)
                {
                    logger->Error("Mod (GUID %s) built for the game %s!", pModInfo->GUID(), maybeINeedAGame());
                    goto nextMod;
                }
                if(!modlist->AddMod(pModInfo, handle, buf))
                {
                    logger->Error("Mod (GUID %s) is already loaded!", pModInfo->GUID());
                    goto nextMod;
                }
                
                logger->Info("Mod (GUID %s) has been preprocessed.", pModInfo->GUID());
            }
            else
            {
              nextMod:
                dlclose(handle);
            }
            //unlink(dataBuf);
            removeStatus = remove(dataBuf);
            if(removeStatus != 0) logger->Error("Failed to remove temp mod file! This might break the mod loading. Error %d", removeStatus);
        }
        closedir(dir);
    }
    else
    {
        logger->Error("Failed to load mods: unable to open directory");
    }
}

extern ModDesc* pLastModProcessed;

void StartSignalHandler();
void HookALog();
JavaVM *g_pJavaVM = NULL;
void *g_pJavaReserved = NULL;

extern bool bAndroidLog_OnlyImportant, bAndroidLog_NoAfter, bAML_HasFastmanModified;
bool g_bAMLStarted = false;

pthread_key_t g_JNIThreadKey;
JNIEnv* GetCurrentJNI()
{
    JNIEnv* env = NULL;
    if(g_JNIThreadKey)
    {
        env = (JNIEnv*)pthread_getspecific(g_JNIThreadKey);
        if(env) return env;
    }
    else
    {
        pthread_key_create(&g_JNIThreadKey, NULL);
    }

    if(g_pJavaVM)
    {
        jint result = g_pJavaVM->AttachCurrentThread(&env, NULL);
        if(result == 0 && env)
        {
            pthread_setspecific(g_JNIThreadKey, env);
            return env;
        }
    }
    return NULL;
}

// https://stackoverflow.com/questions/46869901/how-to-get-the-android-context-instance-when-calling-jni-method
jobject g_GlobalContext = 0;
jobject GetCurrentContext()
{
    if(g_GlobalContext) return g_GlobalContext;

    JNIEnv* env = GetCurrentJNI();
    if(!env) return 0;

    jclass activityThread = env->FindClass("android/app/ActivityThread");
    jmethodID currentActivityThread = env->GetStaticMethodID(activityThread, "currentActivityThread", "()Landroid/app/ActivityThread;");
    jobject activityThreadObj = env->CallStaticObjectMethod(activityThread, currentActivityThread);
    jmethodID getApplication = env->GetMethodID(activityThread, "getApplication", "()Landroid/app/Application;");

    g_GlobalContext = env->CallObjectMethod(activityThreadObj, getApplication);
    if(g_GlobalContext) g_GlobalContext = env->NewGlobalRef(g_GlobalContext);
    return g_GlobalContext;
}

struct LibraryLoadData
{
    LibraryLoadData() : initMembersList(NULL), initMembersCount(0) { }
    typedef void(*initArrayMember)();

    initArrayMember* initMembersList;
    int initMembersCount;
};
static LibraryLoadData g_LoadDatas[2];
void AML_PostLoadLib(int libNum)
{
    libNum--;

    const int size = g_LoadDatas[libNum].initMembersCount;
    for(int i = 0; i < size; ++i)
    {
        g_LoadDatas[libNum].initMembersList[i]();
    }
}

void* AML_dlopen(const char* lib, int libNum)
{
    return dlopen(lib, RTLD_NOW);
}

void StartAMLRightNow(const char* libName1 = NULL, const char* libName2 = NULL)
{
    if(g_bAMLStarted)
    {
        logger->Error("Something was trying to boot-up AML again.");
        return;
    }

    logger->SetTag("AndroidModLoader");
    const char* szTmp; jstring jTmp;

    /* JNI Environment */
    if (g_pJavaVM->GetEnv(reinterpret_cast<void**>(&env), JNI_VERSION_1_6) != JNI_OK)
    {
        logger->Error("Cannot get JNI Environment!");
        return;
    }

    /* Application Context */
    appContext = env->NewGlobalRef( GetGlobalContext(env) );
    if(appContext == NULL)
    {
        logger->Error("AML Library should be loaded in \"onCreate\" or by injecting it directly into the main game library!");
        return;
    }

    // Preload libs
    void *lib1 = NULL, *lib2 = NULL;
    if(libName1 && libName1[0])
    {
        lib1 = AML_dlopen(libName1, 1);
    }
    if(libName2 && libName2[0])
    {
        lib2 = AML_dlopen(libName2, 2);
    }
    
    /* Must Have for mods */
    modlist->AddMod(amlmodinfo, 0, "localpath (core)");
    interfaces->Register("AMLInterface", aml);
    interfaces->Register("AMLConfig", icfg);
    InitCURL();

    /* Permissions! We really need them for configs! */
    /*if(!HasPermissionGranted(env, appContext, "READ_EXTERNAL_STORAGE") ||
       !HasPermissionGranted(env, appContext, "WRITE_EXTERNAL_STORAGE"))
    {
        // Instead of appContext should be !!!ACTIVITY!!! <- Hard to get without SMALI-Inject (just a smali hand-rewritten, lol)
        RequestPermissions(env, appContext);
    }*/

    /* Internal Storage */
    jTmp = GetAbsolutePath(env, GetStorageDir(env));
    szTmp = env->GetStringUTFChars(jTmp, NULL);
    snprintf(g_szInternalStoragePath, sizeof(g_szInternalStoragePath), "%s", szTmp);
    env->ReleaseStringUTFChars(jTmp, szTmp);

    /* Package Name */
    char i = 0;
    jTmp = GetPackageName(env, appContext);
    szTmp = env->GetStringUTFChars(jTmp, NULL);
    while(szTmp[i] != 0 && i < sizeof(g_szAppName)-1)
    {
        g_szAppName[i] = tolower(szTmp[i]);
        ++i;
    } g_szAppName[i] = 0;
    env->ReleaseStringUTFChars(jTmp, szTmp);
    logger->Info("Determined app info: %s", g_szAppName);

  #ifdef FASTMAN92_CODE
    /* Fastman92 Part */
    bAML_HasFastmanModified = GetExternalFilesDir_FLA(env, appContext, g_szFastman92Android, sizeof(g_szFastman92Android));
    __pathback(g_szFastman92Android);

    // Android/data/... dir
    snprintf(g_szAndroidDataRootDir, sizeof(g_szAndroidDataRootDir), "%s/", g_szFastman92Android);
    
    // Android/data/.../mods dir
    snprintf(g_szModsDir, sizeof(g_szModsDir), "%s/mods/", g_szFastman92Android);
    mkdir(g_szModsDir, 0777);

    // Android/data/.../files dir
    snprintf(g_szAndroidDataDir, sizeof(g_szAndroidDataDir), "%s/files/", g_szFastman92Android);
    mkdir(g_szAndroidDataDir, 0777);
    
    // Android/data/.../configs dir
    snprintf(g_szCfgPath, sizeof(g_szCfgPath), "%s/configs/", g_szFastman92Android);
    mkdir(g_szCfgPath, 0777);
  #else
    /* Create a folder in /Android/data/.../ */
    snprintf(g_szAndroidDataRootDir, sizeof(g_szAndroidDataRootDir), "%s/Android/data/%s/", g_szInternalStoragePath, g_szAppName);
    DIR* dir = opendir(g_szAndroidDataRootDir);
    if(dir != NULL) closedir(dir);
    else GetExternalFilesDir(env, appContext);

    /* Create "mods" folder in /Android/data/.../ */
    snprintf(g_szModsDir, sizeof(g_szModsDir), "%s/Android/data/%s/mods/", g_szInternalStoragePath, g_szAppName);
    mkdir(g_szModsDir, 0777);

    /* Create "files" folder in /Android/data/.../ */
    snprintf(g_szAndroidDataDir, sizeof(g_szAndroidDataDir), "%s/Android/data/%s/files/", g_szInternalStoragePath, g_szAppName);
    mkdir(g_szAndroidDataDir, 0777); // Who knows, right?

    /* Create "configs" folder in /Android/data/.../ */
    snprintf(g_szCfgPath, sizeof(g_szCfgPath), "%s/Android/data/%s/configs/", g_szInternalStoragePath, g_szAppName);
    mkdir(g_szCfgPath, 0777);
  #endif

    /* root/data/data Folder */
    g_szDataDir = env->GetStringUTFChars(GetAbsolutePath(env, GetFilesDir(env, appContext)), NULL);

    /* AML Config */
    logger->Info("Reading config...");
    cfg->Init();
    cfg->Bind("Author", "")->SetString("RusJJ aka [-=KILL MAN=-]"); cfg->ClearLast();
    cfg->Bind("Discord", "")->SetString("https://discord.gg/2MY7W39kBg"); cfg->ClearLast();
    bool bHasChangedCfgAuthor = cfg->IsValueChanged();
    cfg->Bind("Version", "")->SetString(amlmodinfo->VersionString()); cfg->ClearLast();
    cfg->Bind("LaunchedTimeStamp", 0)->SetInt((int)time(NULL)); cfg->ClearLast();
    cfg->Bind("FakePackageName", "")->GetString(g_szFakeAppName, sizeof(g_szFakeAppName)); cfg->ClearLast();
    snprintf(g_szInternalModsDir, sizeof(g_szInternalModsDir), "%s/%s/%s", g_szInternalStoragePath, cfg->Bind("InternalModsFolder", "AMLMods")->GetString(), g_szAppName); cfg->ClearLast();
    bool internalModsPriority = cfg->GetBool("InternalModsFirst", true);
    logger->ToggleOutput(cfg->GetBool("EnableLogcats", true));
    bool bEnableUpdater = cfg->GetBool("EnableUpdater", true);
    g_bShowUpdatedToast = cfg->GetBool("ShowUpdaterToast", true);
    g_bShowUpdateFailedToast = cfg->GetBool("ShowUpdaterFailedToast", true);
    g_bEnableFileDownloads = cfg->GetBool("EnableModFileDownloads", true);
    g_nEnableNews = cfg->GetInt("ShowNewsForFewTimes", 3);
    g_pLastNewsId = cfg->Bind("LastNewsIdShowed", 0, "Savings");
    g_nDownloadTimeout = cfg->GetInt("DownloadTimeout", 2);

    g_bCrashAML = cfg->GetBool("CrashAML", false, "DevTools");
    g_bNoMods = cfg->GetBool("DontLoadMods", false, "DevTools");
    //g_bSimplerCrashLog = cfg->GetBool("SimplerCrashLogs", g_bSimplerCrashLog, "DevTools");
    g_bNoSPInLog = cfg->GetBool("NoStackInCrashLog", false, "DevTools");
    g_bNoModsInLog = cfg->GetBool("NoModsInCrashLog", false, "DevTools");
    g_bMLSOnlyManualSaves = cfg->GetBool("MLSOnlyManualSaves", false, "DevTools");
    g_bDumpAllThreads = cfg->GetBool("CrashLogFromAllThreads", true, "DevTools");
    g_bEHUnwind = cfg->GetBool("EHUnwindCrashLog", false, "DevTools");
    g_bMoreRegsInfo = cfg->GetBool("MoreRegistersInfo", true, "DevTools");

    if(g_nDownloadTimeout < 1) g_nDownloadTimeout = 1;
    else if(g_nDownloadTimeout > 5) g_nDownloadTimeout = 5;
    cfg->Save();

    /* Android version */
    char sdk_ver_str[92]; // PROPERTY_VALUE_MAX
    if(__system_property_get("ro.build.version.sdk", sdk_ver_str))
    {
        g_nAndroidSDKVersion = atoi(sdk_ver_str);
    }
    else if(g_nAndroidSDKVersion == 0)
    {
        if(__system_property_get("ro.build.version.release", sdk_ver_str))
        {
            g_nAndroidSDKVersion = atoi(sdk_ver_str);
        }
        else
        {
            jclass versionClass = env->FindClass("android/os/Build$VERSION");
            jfieldID sdkIntFieldID = env->GetStaticFieldID(versionClass, "SDK_INT", "I");
            g_nAndroidSDKVersion = env->GetStaticIntField(versionClass, sdkIntFieldID);
        }
    }

    /* Catch the fish! */
    if(cfg->GetBool("SignalHandler", true))
    {
        g_pAML->AddFeature("SIGNAL");
        StartSignalHandler();
    }

    /* Catch another fish! */
    bAndroidLog_OnlyImportant = !cfg->GetBool("PrintLogsToFile_Verbose", false);
    bAndroidLog_NoAfter = cfg->GetBool("PrintLogsToFile_NoLogCat", false);
    if(cfg->GetBool("PrintLogsToFile", false))
    {
        g_pAML->AddFeature("LOGHOOK");
        HookALog();
    }

    /* Mods? */
    logger->Info("Working with mods...");
    #ifdef __IL2CPPUTILS
        logger->Info("IL2CPP: Attempting to initialize IL2CPP-Utils");
        IL2CPP::Func::HookFunctions();
    #endif
    if(!g_bNoMods)
    {
        MLS::LoadFile();
        if(g_szInternalModsDir[0] != 0)
        {
            LoadMods(internalModsPriority ? g_szInternalModsDir : g_szModsDir);
            LoadMods(internalModsPriority ? g_szModsDir : g_szInternalModsDir);
        }
        else
        {
            LoadMods(g_szModsDir);
        }
    }

    /* All mods are loaded now. We should check for dependencies! */
    logger->Info("Checking for dependencies...");
    modlist->ProcessDependencies();
    
    /* Process features */
    #ifdef __XDL
        g_pAML->AddFeature("XDL");
    #endif
    #ifdef __IL2CPPUTILS
        g_pAML->AddFeature("IL2CPP");
    #endif
    if(g_pAML->IsGameFaked()) g_pAML->AddFeature("FAKEGAME");
    if(bHasChangedCfgAuthor) g_pAML->AddFeature("STEALER"); // For fun
    if(!logger->HasOutput()) g_pAML->AddFeature("NOLOGGING");
    
    /* Load news first! */
    if(g_nEnableNews > 0)
    {
        char newsBuf[512]; memset(newsBuf, 0, sizeof(newsBuf));
        
        if(aml->DownloadFileToData("https://raw.githubusercontent.com/RusJJ/AndroidModLoader/main/news.txt", newsBuf, sizeof(newsBuf)) && newsBuf[0])
        {
            if(strncmp(g_pLastNewsId->GetString(), newsBuf, 16) != 0)
            {
                for(int i = 0; i < g_nEnableNews; ++i)
                {
                    aml->ShowToast(true, newsBuf);
                }

                newsBuf[16] = 0;
                g_pLastNewsId->SetString(newsBuf);
                cfg->Save();
            }
            delete g_pLastNewsId;
        }
    }
    
    /* All mods are sorted and should be loaded! */
    if(bEnableUpdater)
    {
        g_pAML->AddFeature("UPDATER");
        modlist->ProcessUpdater();
        logger->Info("Mods were updated!");
    }
    if(!g_bNoMods)
    {
        modlist->ProcessPreLoading();
        modlist->ProcessLoading();
        modlist->OnAllModsLoaded();
        logger->Info("Mods were launched!");
    }
    pLastModProcessed = NULL;

    #ifdef AML32
        snprintf(g_szUserAgent, sizeof(g_szUserAgent), "AndroidModLoader/%s (Android; ARM; ARM32)", amlmodinfo->VersionString());
    #else
        snprintf(g_szUserAgent, sizeof(g_szUserAgent), "AndroidModLoader/%s (Android; ARM; ARM64)", amlmodinfo->VersionString());
    #endif

    /* Fake crash for crash handler testing (does not work?) */
    //if(g_bCrashAML) __builtin_trap(); // Dont let really weird guys to use this...

    // TODO: should be loaded in a different thread..?
    if(lib1)
    {
        AML_PostLoadLib(1);
        auto libEntry = (void(*)(JavaVM*, void*))dlsym(lib1, "JNI_OnLoad");
        if(libEntry) libEntry(g_pJavaVM, g_pJavaReserved);
    }
    if(lib2)
    {
        AML_PostLoadLib(2);
        auto libEntry = (void(*)(JavaVM*, void*))dlsym(lib2, "JNI_OnLoad");
        if(libEntry) libEntry(g_pJavaVM, g_pJavaReserved);
    }

    g_bAMLStarted = true;
}


extern "C" JNIEXPORT void JNICALL Java_net_rusjj_amlcore_launchAMLCore(JNIEnv *env, jclass clazz)
{
    // Late start
    StartAMLRightNow();
}
extern "C" JNIEXPORT void JNICALL Java_net_rusjj_amlcore_earlyLaunchAMLCore(JNIEnv *env, jclass clazz, jstring lib1, jstring lib2)
{
    // Early stage starting
    // LAUNCHES lib1 AND lib2 BY ITSELF!!!
    const char* szLib1 = env->GetStringUTFChars(lib1, NULL);
    const char* szLib2 = env->GetStringUTFChars(lib2, NULL);

    StartAMLRightNow(szLib1, szLib2);

    env->ReleaseStringUTFChars(lib1, szLib1);
    env->ReleaseStringUTFChars(lib2, szLib2);
}

JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved)
{
    g_pJavaVM = vm;
    g_pJavaReserved = reserved;
    
    /* For the delayed start-up (later) */
    //StartAMLRightNow();
    
    /* Return the value it needs */
    return JNI_VERSION_1_6;
}

JNIEXPORT void JNI_OnUnload(JavaVM* vm, void* reserved)
{
    /* Not sure if it'll work... */
    /* It worked once, lol */
    modlist->ProcessUnloading();
}
```

`mls.cpp`:

```cpp
/* MLS - Mod Loader`s Settings */
/* A functionality to store game/mods settings in a better way */
/* (for those who doesn`t like 1000 config files) */

#include <mod/amlmod.h>
#include <mod/logger.h>
#include <mod/listitem.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include "mls.h"

extern bool g_bMLSOnlyManualSaves;

class MLSKeychain;

struct MLSStorage
{
    char szKey[MAX_KEY_LEN];
    char szValue[MAX_VAL_LEN];
};

MLSKeychain* listSets = NULL;
LIST_START(MLSKeychain)
    LIST_INITSTART(MLSKeychain)
        memset(storage.szKey, 0, sizeof(storage.szKey));
        memset(storage.szValue, 0, sizeof(storage.szValue));
    LIST_INITEND()

    MLSStorage storage;
LIST_END()

void MLS::LoadFile()
{
    char path[256];
    snprintf(path, sizeof(path), "%s/gamesave.mls", aml->GetAndroidDataPath());
    FILE* f = fopen(path, "rb");
    if(!f)
    {
        logger->Error("An error (%d) opening MLS file!", errno, strerror(errno));
        return;
    }

    logger->Info("MLS file is opened, reading sets...");
    MLSKeychain* item;
    while(true)
    {
        item = new MLSKeychain;
        fread(&item->storage, sizeof(MLSStorage), 1, f);
        if(!feof(f))
        {
            item->Push(&listSets);
        }
        else
        {
            fclose(f);
            logger->Info("MLS file has been readed. Sets: %d", item->Count());
            return;
        }
    }
}
void MLS::SaveFile()
{
    char path[256];
    snprintf(path, sizeof(path), "%s/gamesave.mls", aml->GetAndroidDataPath());
    FILE* f = fopen(path, "wb");
    if(!f) return;

    LIST_FOR_FAST(listSets)
    {
        fwrite(&item->storage, sizeof(MLSStorage), 1, f);
    }
    fclose(f);
}
bool MLS::HasValue(const char* key)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key)) return true;
    }
    return false;
}
void MLS::DeleteValue(const char* key)
{
    LIST_FOR(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            item->Remove(&listSets);
            delete item;
            if(!g_bMLSOnlyManualSaves) SaveFile();
        }
    }
}

void MLS::SetInt(const char* key, int32_t val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            memset(item->storage.szValue, 0, sizeof(MLSStorage::szValue));
            snprintf(item->storage.szValue, sizeof(MLSStorage::szValue), "%d", val);
            if(!g_bMLSOnlyManualSaves) SaveFile();
            return;
        }
    }

    MLSKeychain* newitem = new MLSKeychain;
    snprintf(newitem->storage.szKey, sizeof(MLSStorage::szKey), "%s", key);
    snprintf(newitem->storage.szValue, sizeof(MLSStorage::szValue), "%d", val);
    newitem->Push(&listSets);

    if(!g_bMLSOnlyManualSaves) SaveFile();
}
void MLS::SetFloat(const char* key, float val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            memset(item->storage.szValue, 0, sizeof(MLSStorage::szValue));
            snprintf(item->storage.szValue, sizeof(MLSStorage::szValue), "%8.6f", val);
            if(!g_bMLSOnlyManualSaves) SaveFile();
            return;
        }
    }

    MLSKeychain* newitem = new MLSKeychain;
    snprintf(newitem->storage.szKey, sizeof(MLSStorage::szKey), "%s", key);
    snprintf(newitem->storage.szValue, sizeof(MLSStorage::szValue), "%8.6f", val);
    newitem->Push(&listSets);

    if(!g_bMLSOnlyManualSaves) SaveFile();
}
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wformat" // dumb ass clang cries about "ld needs to be lld" and "lld needs to be ld" at the SAME TIME
void MLS::SetInt64(const char* key, int64_t val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            memset(item->storage.szValue, 0, sizeof(MLSStorage::szValue));
            snprintf(item->storage.szValue, sizeof(MLSStorage::szValue), "%lld", val);
            if(!g_bMLSOnlyManualSaves) SaveFile();
            return;
        }
    }

    MLSKeychain* newitem = new MLSKeychain;
    snprintf(newitem->storage.szKey, sizeof(MLSStorage::szKey), "%s", key);
    snprintf(newitem->storage.szValue, sizeof(MLSStorage::szValue), "%lld", val);
    newitem->Push(&listSets);

    if(!g_bMLSOnlyManualSaves) SaveFile();
}
#pragma clang diagnostic pop
void MLS::SetStr(const char* key, const char *val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            memset(item->storage.szValue, 0, sizeof(MLSStorage::szValue));
            snprintf(item->storage.szValue, sizeof(MLSStorage::szValue), "%s", val);
            if(!g_bMLSOnlyManualSaves) SaveFile();
            return;
        }
    }

    MLSKeychain* newitem = new MLSKeychain;
    snprintf(newitem->storage.szKey, sizeof(MLSStorage::szKey), "%s", key);
    snprintf(newitem->storage.szValue, sizeof(MLSStorage::szValue), "%s", val);
    newitem->Push(&listSets);

    if(!g_bMLSOnlyManualSaves) SaveFile();
}

bool MLS::GetInt(const char* key, int32_t *val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            *val = atoi(item->storage.szValue);
            return true;
        }
    }
    return false;
}
bool MLS::GetFloat(const char* key, float *val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            *val = atof(item->storage.szValue);
            return true;
        }
    }
    return false;
}
bool MLS::GetInt64(const char* key, int64_t *val)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            *val = atoll(item->storage.szValue);
            return true;
        }
    }
    return false;
}
bool MLS::GetStr(const char* key, char *val, size_t len)
{
    LIST_FOR_FAST(listSets)
    {
        if(!strcmp(item->storage.szKey, key))
        {
            memset(val, 0, len);
            snprintf(val, len, "%s", item->storage.szValue);
            return true;
        }
    }
    return false;
}
```

`mod/amlmod.h`:

```h
#ifndef _AMLMOD
#define _AMLMOD

#include <stdio.h>
#include <ctype.h>
#include <cstring>
#include <stdlib.h>
#include <signal.h>

#if defined(__arm__) || defined(_WIN32)
    #define AML32
    #define BYBIT(__32val, __64val) (__32val)
#elif defined(__aarch64__) || defined(_WIN64)
    #define AML64
    #define BYBIT(__32val, __64val) (__64val)
#else
    #error This lib is supposed to work on ARM only!
#endif

#ifdef __clang__
    #define TARGET_ARM __attribute__((target("no-thumb-mode")))
    #define TARGET_THUMB  __attribute__((target("thumb-mode")))
#endif

#ifdef __GNUC__
    #define ASM_NAKED __attribute__((naked))
#else
    #define ASM_NAKED __declspec(naked)
#endif
#define EXPORT JNIEXPORT

#define MYMOD(_guid, _name, _version, _author)                          \
    static ModInfo modinfoLocal(#_guid, #_name, #_version, #_author);   \
    ModInfo* modinfo = &modinfoLocal;                                   \
    extern "C" JNIEXPORT ModInfo* __GetModInfo() { return modinfo; }    \
    IAML* aml = NULL;                                                   \
    struct AMLInitStub {                                                \
        AMLInitStub() {                                                 \
            aml = (IAML*)GetInterface("AMLInterface");                  \
        }                                                               \
    }; AMLInitStub amlStub __attribute__((init_priority(101))); // Highest init prio

#define MYMODCFG(_guid, _name, _version, _author)                       \
    MYMOD(_guid, _name, _version, _author);                             \
    static Config cfgLocal(#_guid);                                     \
    Config* cfg = &cfgLocal;

#define MYMODCFGNAME(_guid, _name, _version, _author, _cfgname)         \
    MYMOD(_guid, _name, _version, _author);                             \
    static Config cfgLocal(#_cfgname);                                  \
    Config* cfg = &cfgLocal;

#define NEEDGAME(_pkg_name)                                             \
    extern "C" JNIEXPORT const char* __INeedASpecificGame() { return #_pkg_name; }

/* Dependencies! */
#define BEGIN_DEPLIST()                                                 \
    static ModInfoDependency g_listDependencies[] = {

#define ADD_DEPENDENCY(_guid)                                           \
    {#_guid, ""},

#define ADD_DEPENDENCY_VER(_guid, _version)                             \
    {#_guid, #_version},

#define END_DEPLIST()                                                   \
    {"", ""} };                                                         \
    extern "C" JNIEXPORT ModInfoDependency* __GetDepsList() { return &g_listDependencies[0]; }

/* Macros to stop forgetting stuff! */
#define ON_MOD_PRELOAD()                                                \
    extern "C" JNIEXPORT void OnModPreLoad()

#define ON_MOD_LOAD()                                                   \
    extern "C" JNIEXPORT void OnModLoad()

#define ON_ALL_MODS_LOAD()                                              \
    extern "C" JNIEXPORT void OnAllModsLoaded()

#define ON_MOD_UNLOAD()                                                 \
    extern "C" JNIEXPORT void OnModUnload() /*Not guaranteed*/

#define ON_GAME_CRASH()                                                 \
    extern "C" JNIEXPORT void OnGameCrash(const char* library, int sig, int code, uintptr_t libaddr, mcontext_t* mcontext) /*Not guaranteed*/

#define UPDATER_URL()                                                   \
    extern "C" JNIEXPORT const char* OnUpdaterURLRequested()

#define ON_NEW_INTERFACE()                                              \
    extern "C" JNIEXPORT void OnInterfaceAdded(const char* name, const void* ptr)

    

#define MINIMUM_MD5_BUF_SIZE ( 32 + 1 )

struct MemChunk_t
{
    char* out;
    size_t out_len;
};
    
struct ModInfoDependency
{
    const char* szGUID;
    const char* szVersion;
};

struct ModVersion
{
    unsigned short major;
    unsigned short minor;
    unsigned short revision;
    unsigned short build;
};

// Should be faster than strncpy?
inline char *strxcpy(char* __restrict__ dst, const char* __restrict__ src, int len)
{
    if (!len) return NULL;
    while (--len && (*dst++ = *src++));
    if (!len)
    {
        *dst++ = '\0';
        return *src ? NULL : dst;
    }
    else
    {
        return dst;
    }
}

inline int clampint(int min, int max, int v)
{
    if(v < min) return min;
    else if(v > max) return max;
    return v;
}
inline void clampint(int min, int max, int* v)
{
    if(*v < min) *v = min;
    else if(*v > max) *v = max;
}
inline float clampfloat(float min, float max, float v)
{
    if(v < min) return min;
    else if(v > max) return max;
    return v;
}
inline void clampfloat(float min, float max, float* v)
{
    if(*v < min) *v = min;
    else if(*v > max) *v = max;
}

class ModInfo
{
public:
    ModInfo(const char* szGUID, const char* szName, const char* szVersion, const char* szAuthor)
    {
        /* No buffer overflow! */
        strxcpy(this->szGUID, szGUID, sizeof(ModInfo::szGUID)); this->szGUID[sizeof(ModInfo::szGUID) - 1] = '\0';
        strxcpy(this->szName, szName, sizeof(ModInfo::szName)); this->szName[sizeof(ModInfo::szName) - 1] = '\0';
        strxcpy(this->szVersion, szVersion, sizeof(ModInfo::szVersion)); this->szVersion[sizeof(ModInfo::szVersion) - 1] = '\0';
        strxcpy(this->szAuthor, szAuthor, sizeof(ModInfo::szAuthor)); this->szAuthor[sizeof(ModInfo::szAuthor) - 1] = '\0';

        /* GUID should be lowcase */
        for(int i = 0; this->szGUID[i] != '\0'; ++i)
        {
            this->szGUID[i] = tolower((int)(this->szGUID[i]));
        }

        /* Parse version string */
        if(sscanf(this->szVersion, "%hu.%hu.%hu.%hu", &version.major, &version.minor, &version.revision, &version.build) < 4)
        {
            if(sscanf(this->szVersion, "%hu.%hu.%hu", &version.major, &version.minor, &version.revision) < 3)
            {
                if(sscanf(this->szVersion, "%hu.%hu", &version.major, &version.minor) < 2)
                {
                    version.major = (unsigned short)atoi(this->szVersion);
                }
                version.revision = 0;
            }
            version.build = 0;
        }
    }
    inline const char* GUID() { return szGUID; }
    inline const char* Name() { return szName; }
    inline const char* VersionString() { return szVersion; }
    inline const char* Author() { return szAuthor; }
    inline unsigned short Major() { return version.major; }
    inline unsigned short Minor() { return version.minor; }
    inline unsigned short Revision() { return version.revision; }
    inline unsigned short Build() { return version.build; }

private:
    char szGUID[48];
    char szName[48];
    char szVersion[24];
    char szAuthor[48];
    ModVersion version;

    friend class ModsList;
    friend class Mods;
};

typedef ModInfo* (*GetModInfoFn)();
extern ModInfo* modinfo;


#include "iaml.h"

#endif // _AMLMOD
```

`mod/config.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include "config.h"
#include <mod/logger.h>

#include "amlmod.h"
#include "iaml.h"
#if !defined(__AML) && defined(_ICFG)
    ICFG* icfg;
#else
    #include <fstream>
    #include "thirdparty/inicpp.h"
    ini::IniFile hINI;
#endif
#ifdef __AML
    extern char g_szCfgPath[0xFF];
#endif

inline bool str_equal(const char* str1, const char* str2)
{ 
    for( ; *str1 == *str2 && *str1 != 0; ++str1, ++str2 ) {}
    return *str2 == *str1; 
}

extern ModInfo* modinfo;
ConfigEntry* Config::pLastEntry = NULL;

Config::Config(const char* szName)
{
#if !defined(__AML) && defined(_ICFG)
    m_pICFG = (ICFG*)GetInterface("AMLConfig");
    m_iniMyConfig = m_pICFG->InitIniPointer();
#else
    m_iniMyConfig = &hINI;
#endif
    m_bInitialized = false;
    m_bValueChanged = false;
    m_szName = szName;

    #ifndef __AML
        Init();
    #endif
}

void Config::Init()
{
    if(m_bInitialized) return;
    m_bInitialized = true;
    
    #if !defined(__AML) && defined(_ICFG)
        m_pICFG->ParseInputStream(m_iniMyConfig, m_szName);
    #else
        char path[0xFF];
        #ifdef __AML
            snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
        #else
            snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
        #endif
        hINI.load(path);
    #endif
}

void Config::Save()
{
    if(!m_bInitialized || !m_bValueChanged) return;
    
    m_bValueChanged = false;
    #if !defined(__AML) && defined(_ICFG)
        m_pICFG->GenerateToOutputStream(m_iniMyConfig, m_szName);
    #else
        char path[0xFF];
        #ifdef __AML
            snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
        #else
            snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
        #endif
        hINI.save(path);
    #endif
}

ConfigEntry* Config::Bind(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strxcpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetString(szDefaultValue);
    }
    else 
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = strcmp(tryToGetValue, szDefaultValue) != 0;
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetInt(nDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (nDefaultValue != pRet->m_nIntegerValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetFloat(flDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (flDefaultValue != pRet->m_fFloatValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetBool(bDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (bDefaultValue != (!!pRet->m_nIntegerValue));
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, rgba_t clr, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetString(pRet->m_szDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (clr.value != pRet->m_ColorValue.value);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

const char* Config::GetString(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, szDefaultValue);
        #else
            hINI[szSection][szKey] = szDefaultValue;
        #endif
        Save();
        return szDefaultValue;
    }
    return tryToGetValue;
}

int Config::GetInt(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return 0;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            char tmp[16];
            snprintf(tmp, sizeof(tmp), "%d", nDefaultValue);
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, tmp);
        #else
            hINI[szSection][szKey] = nDefaultValue;
        #endif
        Save();
        return nDefaultValue;
    }
    return atoi(tryToGetValue);
}

float Config::GetFloat(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return 0.0f;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            char tmp[24];
            snprintf(tmp, sizeof(tmp), "%f", flDefaultValue);
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, tmp);
        #else
            hINI[szSection][szKey] = flDefaultValue;
        #endif
        Save();
        return flDefaultValue;
    }
    return atof(tryToGetValue);
}

bool Config::GetBool(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return false;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, bDefaultValue ? "1" : "0");
        #else
            hINI[szSection][szKey] = bDefaultValue ? "1" : "0";
        #endif
        Save();
        return bDefaultValue;
    }
    return atoi(tryToGetValue)!=0;
}

rgba_t Config::GetColor(const char* szKey, rgba_t clr, const char* szSection)
{
    if(!m_bInitialized) return rgba_t {0,0,0,0};
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetString(pRet->m_szDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    return pRet->ParseColor();
}

void ConfigEntry::SetString(const char* newValue)
{
    if(m_bLoadedData && str_equal(newValue, m_szValue)) return;
    
    strxcpy(m_szValue, newValue, sizeof(m_szValue)-1); m_szValue[sizeof(m_szValue)-1] = 0;
    m_nIntegerValue = atoi(m_szValue);
    m_fFloatValue = (float)atof(m_szValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::GetString(char* str, size_t len)
{
    strxcpy(str, GetString(), len);
}

void ConfigEntry::SetFloat(float newValue)
{
    if(m_bLoadedData && m_fFloatValue == newValue) return;
    
    m_fFloatValue = newValue;
    m_nIntegerValue = (int)newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%f", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::SetInt(int newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue) return;
    
    m_fFloatValue = (float)newValue;
    m_nIntegerValue = newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%d", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::SetBool(bool newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue?1:0) return;
    
    m_fFloatValue = newValue?1.0f:0.0f;
    m_nIntegerValue = newValue?1:0;
    m_szValue[0] = newValue ? '1' : '0'; m_szValue[1] = 0;
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

inline bool IsRGBValue(int value) { return value >= 0 && value <= 255; }
inline bool IsRGBFloatValue(float value) { return value >= 0 && value <= 1; }
rgba_t ConfigEntry::ParseColor()
{
    int r, g, b, a, sscanfed = sscanf(m_szValue, "%d %d %d %d", &r, &g, &b, &a);
    if(sscanfed == 4 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b) && IsRGBValue(a))
    {
        m_ColorValue = rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,(unsigned char)a};
    }
    else if(sscanfed == 3 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b))
    {
        m_ColorValue = rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,255};
    }
    else
    {
        float fr, fg, fb, fa;
        sscanfed = sscanf(m_szValue, "%f %f %f %f", &fr, &fg, &fb, &fa);
        if(sscanfed == 4 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b) && IsRGBFloatValue(a))
        {
            m_ColorValue = rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),(unsigned char)(255*fa)};
        }
        else if(sscanfed == 3 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b))
        {
            m_ColorValue = rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),255};
        }
    }
    //m_ColorValue = rgba_t{255,255,255,255}
    return m_ColorValue;
}

void ConfigEntry::SetColor(rgba_t clr, bool asFloat)
{
    m_nIntegerValue = (int)clr.r;
    m_fFloatValue = (float)clr.r;
    if(asFloat) snprintf(m_szValue, sizeof(m_szValue), "%.3f %.3f %.3f %.3f", (float)(clr.r/255.0f), (float)(clr.g/255.0f), (float)(clr.b/255.0f), (float)(clr.a/255.0f));
    else snprintf(m_szValue, sizeof(m_szValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    
    // Kinda expensive to parse the color every time
    // Why do you may want it to be changed automatically anyway?
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

```

`mod/config.h`:

```h
#ifndef _CONFIG
#define _CONFIG

#define KEY_SECTION_BUFFER_C 64
#define VALUE_BUFFER_C 384

/* Is not required. Can be used only for a smaller size of mod (~480kb savings) */
#include "icfg.h"
#include <stdint.h>

class ConfigEntry;

struct rgba_t
{
    union {
        struct { unsigned char r, g, b, a; };
        struct { unsigned char x, y, z, w; };
        unsigned char v[4];
        unsigned int value;
    };
    
    rgba_t() : r(0), g(0), b(0), a(0) {}
    rgba_t(unsigned char v) : r(v), g(v), b(v), a(255) {}
    rgba_t(unsigned char _r, unsigned char _g, unsigned char _b) : r(_r), g(_g), b(_b), a(255) {}
    rgba_t(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a) : r(_r), g(_g), b(_b), a(_a) {}
};

class Config
{
public:
    Config(const char* szName);
    void Init();
    void Save();
    // Allocated, needs to be manually deleted
    ConfigEntry* Bind(const char* szKey, const char* szDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, int nDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, float flDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, bool bDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, rgba_t clrDefaultValue, const char* szSection = "Preferences");
    
    // FAST GET. NO NEED TO CLEAN THE MEMORY.
    const char*  GetString(const char* szKey, const char* szDefaultValue, const char* szSection = "Preferences");
    int          GetInt(const char* szKey, int nDefaultValue, const char* szSection = "Preferences");
    float        GetFloat(const char* szKey, float flDefaultValue, const char* szSection = "Preferences");
    bool         GetBool(const char* szKey, bool bDefaultValue, const char* szSection = "Preferences");
    rgba_t       GetColor(const char* szKey, rgba_t clrDefaultValue, const char* szSection = "Preferences");

    // Self-explained
    inline bool  IsValueChanged() { return m_bValueChanged; }
    inline void  ClearLast();
    
    static Config* GetConfig();
    static ConfigEntry* pLastEntry;
    
private:
    bool m_bInitialized;
    bool m_bValueChanged;
    const char* m_szName;
    void* m_iniMyConfig;

#ifdef _ICFG
    /* Built-in optimizer thinks he's the best! Ha-ha... Not funny. It's 3AM... */
    ICFG* m_pICFG;
#endif
    
    friend class ConfigEntry;
};

class ConfigEntry
{
public:
    ConfigEntry() : m_bLoadedData(false), m_szValue(""), m_szDefaultValue("") {}
    void SetString(const char* newValue);
    inline const char* GetString() { return m_szValue; }
    void GetString(char* str, size_t len);
    void SetFloat(float newValue);
    inline float GetFloat() { return m_fFloatValue; }
    void SetBool(bool newValue);
    inline bool GetBool() { return m_nIntegerValue; }
    void SetInt(int newValue);
    inline int GetInt() { return m_nIntegerValue; }
    inline void Reset() { SetString(m_szDefaultValue); }
    rgba_t ParseColor();
    void SetColor(rgba_t clr, bool asFloat = false);

    inline bool LoadedUndefault() { return m_bNotDefaultValue; }
    inline int Clamp(int min, int max)
    {
        if(m_nIntegerValue < min)
        {
            m_pBoundCfg->m_bValueChanged = true;
            int ret = m_nIntegerValue - min;
            m_nIntegerValue = min;
            m_fFloatValue = (float)min;
            m_szValue[0] = 0;
            return ret;
        }
        if(m_nIntegerValue > max)
        {
            m_pBoundCfg->m_bValueChanged = true;
            int ret = m_nIntegerValue - max;
            m_nIntegerValue = max;
            m_fFloatValue = (float)max;
            m_szValue[0] = 0;
            return ret;
        }
        return 0;
    }
    inline float Clamp(float min, float max)
    {
        if(m_fFloatValue < min)
        {
            m_pBoundCfg->m_bValueChanged = true;
            float ret = m_fFloatValue - min;
            m_nIntegerValue = (int)min;
            m_fFloatValue = min;
            m_szValue[0] = 0;
            return ret;
        }
        if(m_fFloatValue > max)
        {
            m_pBoundCfg->m_bValueChanged = true;
            float ret = m_fFloatValue - max;
            m_nIntegerValue = (int)max;
            m_fFloatValue = max;
            m_szValue[0] = 0;
            return ret;
        }
        return 0.0f;
    }
    
private:
    Config* m_pBoundCfg;
    bool m_bLoadedData;
    bool m_bNotDefaultValue;
    char m_szMySection[KEY_SECTION_BUFFER_C];
    char m_szMyKey[KEY_SECTION_BUFFER_C];
    float m_fFloatValue;
    union
    {
        int m_nIntegerValue;
        rgba_t m_ColorValue;
    };
    char m_szValue[VALUE_BUFFER_C];
    char m_szDefaultValue[VALUE_BUFFER_C];

    friend class Config;
};
inline void Config::ClearLast() { if(pLastEntry) { delete pLastEntry; pLastEntry = NULL; } }
extern Config* cfg;

#endif // _CONFIG

```

`mod/config_inipp.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include "config.h"
#include <mod/logger.h>

#include "amlmod.h"
#include "iaml.h"
#if !defined(__AML) && defined(_ICFG)
	ICFG* icfg;
#else
	#include <fstream>
	#include "thirdparty/inipp.h"
#endif
#ifdef __AML
	extern char g_szCfgPath[0xFF];
#endif

inline bool str_equal(const char* str1, const char* str2) { 
    for ( ; *str1 == *str2 && *str1 != 0; ++str1, ++str2 ); 
        return *str2 == *str1; 
}

extern ModInfo* modinfo;
ConfigEntry* Config::pLastEntry = NULL;

Config::Config(const char* szName)
{
#if !defined(__AML) && defined(_ICFG)
	m_pICFG = (ICFG*)GetInterface("AMLConfig");
	m_iniMyConfig = m_pICFG->InitIniPointer();
#else
	m_iniMyConfig = new inipp::Ini<char>();
    logger->Info("inipp 0x%16X, 0x%16X", m_iniMyConfig, *(void**)m_iniMyConfig);
#endif
	m_bInitialized = false;
    m_bValueChanged = false;
    m_szName = szName;

	#ifndef __AML
		Init();
	#endif
}

void Config::Init()
{
	if(m_bInitialized) return;
	m_bInitialized = true;
    
	#if !defined(__AML) && defined(_ICFG)
		m_pICFG->ParseInputStream(m_iniMyConfig, m_szName);
	#else
		char path[0xFF];
		#ifdef __AML
    		snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
			std::ifstream cfgStream(path);
		#else
    		snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
			std::ifstream cfgStream(path);
		#endif
		if(cfgStream.is_open())
		{
			((inipp::Ini<char>*)m_iniMyConfig)->parse(cfgStream);
		}
		cfgStream.close();
	#endif
}

void Config::Save()
{
	if(!m_bInitialized || !m_bValueChanged) return;
    
    m_bValueChanged = false;
	#if !defined(__AML) && defined(_ICFG)
		m_pICFG->GenerateToOutputStream(m_iniMyConfig, m_szName);
	#else
		char path[0xFF];
		#ifdef __AML
    		snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
			std::ofstream cfgStream(path);
		#else
    		snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
			std::ofstream cfgStream(path);
		#endif
		if(cfgStream.is_open())
		{
			((inipp::Ini<char>*)m_iniMyConfig)->generate(cfgStream);
		}
		cfgStream << "";
		cfgStream.close();
	#endif
}

ConfigEntry* Config::Bind(const char* szKey, const char* szDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strncpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetString(szDefaultValue);
	else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
		pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, int nDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetInt(nDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, float flDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetFloat(flDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, bool bDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetBool(bDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strncpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetString(szDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetInt(nDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetFloat(flDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->SetBool(bDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

void ConfigEntry::SetString(const char* newValue)
{
    if(m_bLoadedData && str_equal(newValue, m_szValue)) return;
    
    strncpy(m_szValue, newValue, sizeof(m_szValue)-1); m_szValue[sizeof(m_szValue)-1] = 0;
	m_nIntegerValue = atoi(m_szValue);
	m_fFloatValue = (float)atof(m_szValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::GetString(char* str, size_t len)
{
    strncpy(str, GetString(), len);
}

void ConfigEntry::SetFloat(float newValue)
{
    if(m_bLoadedData && m_fFloatValue == newValue) return;
    
	m_fFloatValue = newValue;
    m_nIntegerValue = (int)newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%f", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::SetInt(int newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue) return;
    
	m_fFloatValue = (float)newValue;
    m_nIntegerValue = newValue;
	snprintf(m_szValue, sizeof(m_szValue), "%d", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::SetBool(bool newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue?1:0) return;
    
	m_fFloatValue = newValue?1.0f:0.0f;
    m_nIntegerValue = newValue?1:0;
    m_szValue[0] = newValue ? '1' : '0'; m_szValue[1] = 0;
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

inline bool IsRGBValue(int value) { return value >= 0 && value <= 255; }
inline bool IsRGBFloatValue(float value) { return value >= 0 && value <= 1; }
rgba_t ConfigEntry::ParseColor()
{
    int r, g, b, a, sscanfed = sscanf(m_szValue, "%d %d %d %d", &r, &g, &b, &a);
    if(sscanfed == 4 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b) && IsRGBValue(a))
    {
        return rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,(unsigned char)a};
    }
    else if(sscanfed == 3 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b))
    {
        return rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,255};
    }
    else
    {
        float fr, fg, fb, fa;
        sscanfed = sscanf(m_szValue, "%f %f %f %f", &fr, &fg, &fb, &fa);
        if(sscanfed == 4 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b) && IsRGBFloatValue(a))
        {
            return rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),(unsigned char)(255*fa)};
        }
        else if(sscanfed == 3 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b))
        {
            return rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),255};
        }
    }
    return rgba_t{255,255,255,255};
}

void ConfigEntry::SetColor(rgba_t clr, bool asFloat)
{
    m_nIntegerValue = (int)clr.r;
    m_fFloatValue = (float)clr.r;
    if(asFloat) snprintf(m_szValue, sizeof(m_szValue), "%.3f %.3f %.3f %.3f", (float)(clr.r/255.0f), (float)(clr.g/255.0f), (float)(clr.b/255.0f), (float)(clr.a/255.0f));
    else snprintf(m_szValue, sizeof(m_szValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    
    // Kinda expensive to parse the color every time
    // Why do you may want it to be changed automatically anyway?
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        ((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

```

`mod/iaml.h`:

```h
#ifndef _IAML
#define _IAML

// Usage: place 3 lines somewhere in the code AFTER #include <mod/amlmod.h>
// #if !defined(IAML_VER) && IAML_VER < 01030000
//     #error "You need to update your MOD folder to 1.3.0!"
// #endif
#define IAML_VER 01030000

#include "interface.h"
#include <jni.h>
#include <stdint.h>

// Because the name was changed to be more understandable
#define PlaceB PlaceJMP

#ifndef PAGE_SIZE
    #define PAGE_SIZE 4096
#endif

enum eManifestPermissions
{
    P_READ_EXTERNAL_STORAGE = 0,
    P_WRITE_EXTERNAL_STORAGE,
}; // Unused

// AML 1.3.0 stuff (Vibration patterns, examples)
static jlong DEFAULT_VIBRATE_PATTERN[4] = {0, 250, 250, 250};
static jlong g_VibroPattern_Weak[7] = { 0, 20, 80, 20, 80, 20, 80 };
static jlong g_VibroPattern_Alert[6] = { 0, 200, 100, 200, 100, 400 };

// I`m redoing this because i dont want to include additional file
// Thanks @XMDS, maybe someone will use it
struct GlossRegisters
{
#ifdef AML32
    enum e_reg
    {
        R0 = 0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, FP = R11, R12, IP = R12, R13, SP = R13, R14, LR = R14, R15, PC = R15, CPSR
    };

    union
    {
        uint32_t reg[17];
        struct
        {
            uint32_t r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, sp, lr, pc, cpsr;
        } regs;
    };
#else
    enum e_reg
    {
        X0 = 0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, X16, X17, X18, X19, X20, X21, X22, X23, X24, X25, X26, X27, X28, X29, FP = X29,
        Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12, Q13, Q14, Q15, Q16, Q17, Q18, Q19, Q20, Q21, Q22, Q23, Q24, Q25, Q26, Q27, Q28, Q29, Q30, Q31,
        X30, LR = X30, X31, SP = X31, PC, CPSR
    };

    union
    {
        uint64_t reg[66];
        struct
        {
            uint64_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29;
            double q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15, q16, q17, q18, q19, q20, q21, q22, q23, q24, q25, q26, q27, q28, q29, q30, q31;
            uint64_t lr, sp, pc, cpsr;
        } regs;
    };
#endif
};
typedef void* PHookHandle;
typedef void (*HookWithRegistersFn)(GlossRegisters* regs, PHookHandle hook);

#if defined(__cplusplus)
    extern "C"
#endif
size_t strlen(char const*);

class IAML
{
public:
    /* AML 1.0.0.0 */
    virtual const char* GetCurrentGame();
    virtual const char* GetConfigPath();
    virtual bool        HasMod(const char* szGUID);
    virtual bool        HasModOfVersion(const char* szGUID, const char* szVersion);
    virtual uintptr_t   GetLib(const char* szLib);
    virtual uintptr_t   GetSym(void* handle, const char* sym);
    virtual bool        Hook(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookPLT(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual int         Unprot(uintptr_t handle, size_t len = PAGE_SIZE);
    virtual void        Write(uintptr_t dest, uintptr_t src, size_t size);
    virtual void        Read(uintptr_t src, uintptr_t dest, size_t size);
    virtual int         PlaceNOP(uintptr_t addr, size_t count = 1);
    virtual int         PlaceJMP(uintptr_t addr, uintptr_t dest);
    virtual int         PlaceRET(uintptr_t addr);

    /* AML 1.0.0.4 */
    virtual const char* GetDataPath(); // /data/data/.../*

    /* AML 1.0.0.5 */
    virtual const char* GetAndroidDataPath(); // /sdcard/Android/data/.../files/*
    virtual uintptr_t   GetSym(uintptr_t libAddr, const char* sym); // An additional func but it uses ADDRESS instead of a HANDLE

    /* AML 1.0.0.6 */
    virtual uintptr_t   GetLibLength(const char* szLib);
    virtual int         Redirect(uintptr_t addr, uintptr_t to); // Move directly to "to" from "addr" with the same stack and registers
    virtual void        PlaceBL(uintptr_t addr, uintptr_t dest);
    virtual void        PlaceBLX(uintptr_t addr, uintptr_t dest);
    virtual uintptr_t   PatternScan(const char* pattern, const char* soLib);
    virtual uintptr_t   PatternScan(const char* pattern, uintptr_t libStart, uintptr_t scanLen);
    
    /* AML 1.0.1 */
    virtual void        PatchForThumb(bool forThumb);
    virtual const char* GetFeatures();
    virtual void        HookVtableFunc(void* ptr, unsigned int funcNum, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false); // unsafe
    virtual bool        IsGameFaked();
    virtual const char* GetRealCurrentGame();
    virtual void*       GetLibHandle(const char* soLib);
    virtual void*       GetLibHandle(uintptr_t addr);
    // xDL (will return 0 if xDL is not used)
    // These functions always exists
    // So no need to check for their availability
    virtual bool        IsCorrectXDLHandle(void* ptr);
    virtual uintptr_t   GetLibXDL(void* ptr);
    virtual uintptr_t   GetAddrBaseXDL(uintptr_t addr);
    virtual size_t      GetSymSizeXDL(void* ptr);
    virtual const char* GetSymNameXDL(void* ptr);
    
    /* AML 1.0.2 */
    virtual void        ShowToast(bool longerDuration, const char* fmt, ...);
    virtual bool        DownloadFile(const char* url, const char* saveto);
    virtual bool        DownloadFileToData(const char* url, char* out, size_t outLen);
    virtual void        FileMD5(const char* path, char* out, size_t out_len);
    virtual int         GetModsLoadedCount();
    virtual JNIEnv*     GetJNIEnvironment();
    virtual jobject     GetAppContextObject();
    
    /* AML 1.0.2.1 */
    virtual bool        HasModOfBiggerVersion(const char* szGUID, const char* szVersion);
    
    /* AML 1.0.4 */
    virtual void        HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false);
    virtual int         PlaceNOP4(uintptr_t addr, size_t count = 1);
    virtual const char* GetAndroidDataRootPath(); // /sdcard/Android/data/.../* (not /files/ !!!)
    virtual bool        HookB(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookBL(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookBLX(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    
    /* AML 1.2 */
    virtual void        MLSSaveFile();
    virtual bool        MLSHasValue(const char* key);
    virtual void        MLSDeleteValue(const char* key);
    virtual void        MLSSetInt(const char* key, int32_t val);
    virtual void        MLSSetFloat(const char* key, float val);
    virtual void        MLSSetInt64(const char* key, int64_t val);
    virtual void        MLSSetStr(const char* key, const char *val);
    virtual bool        MLSGetInt(const char* key, int32_t *val);
    virtual bool        MLSGetFloat(const char* key, float *val);
    virtual bool        MLSGetInt64(const char* key, int64_t *val);
    virtual bool        MLSGetStr(const char* key, char *val, size_t len);
    
    /* AML 1.2.1 */
    virtual bool        IsThumbAddr(uintptr_t addr);
    virtual uintptr_t   GetBranchDest(uintptr_t addr);
    
    /* AML 1.2.2 */
    virtual int         GetAndroidVersion();
    virtual bool        CopyFile(const char* file, const char* dest);
    // Gloss things
  #ifdef AML32
    virtual void        RedirectReg(...);
  #else
    virtual void        RedirectReg(uintptr_t addr, uintptr_t to, bool doShortHook = false, GlossRegisters::e_reg targetReg = GlossRegisters::e_reg::X16); // Move directly to "to" from "addr" with the same stack and registers (X16 is the same as "Redirect")
  #endif  
    virtual bool        HasAddrExecFlag(uintptr_t addr);
    virtual void        ToggleHook(PHookHandle hook, bool enable);
    virtual void        DeHook(PHookHandle hook);
    virtual PHookHandle HookInline(void* fnAddress, HookWithRegistersFn newFn, bool doShortHook = false);
    
    /* AML 1.2.3 */
    virtual bool        HasFastmanAPKModified();
    virtual const char* GetInternalPath(); // /sdcard/
    virtual const char* GetInternalModsPath(); // /sdcard/AMLMods/*game*/ (by default)
    
    /* AML 1.3.0 */
    virtual JavaVM*     GetJavaVM();
    virtual jobject     GetCurrentContext();
    virtual void        DoVibro(int msTime); // Pretty strong feedback... If you need a small vibro, do it for like ~20ms, it's gonna be enough
    virtual void        DoVibro(jlong* pattern, int patternItems); // Patterns might give you more control
    virtual void        CancelVibro();
    virtual float       GetBatteryLevel(); // returns a float from 0.0 to 100.0


    // Inlines (shortcuts for you!)
    inline void         Write(uintptr_t dest, const char* str, size_t size) { Write(dest, (uintptr_t)str, size); } // Inline
    inline void         Write(uintptr_t dest, const char* str) { Write(dest, (uintptr_t)str, strlen(str)); } // Inline
    inline void         Write8(uintptr_t dest, uint8_t v) { uint8_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 1); } // Inline
    inline void         Write16(uintptr_t dest, uint16_t v) { uint16_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 2); } // Inline
    inline void         Write32(uintptr_t dest, uint32_t v) { uint32_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 4); } // Inline
    inline void         WriteFloat(uintptr_t dest, float v) { float vPtr = v; Write(dest, (uintptr_t)&vPtr, 4); } // Inline
    inline void         WriteAddr(uintptr_t dest, uintptr_t addr) { uintptr_t addrPtr = addr; Write(dest, (uintptr_t)&addrPtr, sizeof(uintptr_t)); } // Inline
    inline void         WriteAddr(uintptr_t dest, void* addr) { uintptr_t addrPtr = (uintptr_t)addr; Write(dest, (uintptr_t)&addrPtr, sizeof(uintptr_t)); } // Inline
    // Can be used with HookVtableFunc to not to instantiate vtable for 1000 times!
    inline void**       GetVtable(void* ptr) { return *(void***)ptr; }
    inline void         SetVtable(void* ptr, void** vtable) { *(void***)ptr = vtable; }
};

extern IAML* aml;
inline IAML* GetAMLInterface() { return aml; }

/* Do not use big conversions */
#define SET_TO(__a1, __a2)  *(void**)&(__a1) = (void*)(__a2)
#define SET_TO_PTR(__a1, __a2)  *(void**)&(__a1) = *(void**)(__a2)
#define SETSYM_TO(__a1, __a2, __a3)  *(void**)&(__a1) = (void*)(aml->GetSym(__a2, __a3))
#define SETSYM_TO_PTR(__a1, __a2, __a3)  *(void**)&(__a1) = *(void**)(aml->GetSym(__a2, __a3))
#define AS_ADDR(__a1)       *(uintptr_t*)&(__a1)

/* Unprotect that memory chunk for making changes */
#define UNPROT(_addr, _count)                                   \
    aml->Unprot((uintptr_t)(_addr), ( _count ));
/* Just write own info to the memory */
#define WRITE(_addr, _whatToWrite, _size)                       \
    aml->Write(_addr, _whatToWrite, _size);

/* Just a hook declaration */
#define DECL_HOOK(_ret, _name, ...)                             \
    _ret (*_name)(__VA_ARGS__);                                 \
    _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define DECL_HOOKv(_name, ...)                                  \
    void (*_name)(__VA_ARGS__);                                 \
    void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define DECL_HOOKb(_name, ...)                                  \
    bool (*_name)(__VA_ARGS__);                                 \
    bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define DECL_HOOKi(_name, ...)                                  \
    int (*_name)(__VA_ARGS__);                                  \
    int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define DECL_HOOKp(_name, ...)                                  \
    void* (*_name)(__VA_ARGS__);                                \
    void* HookOf_##_name(__VA_ARGS__)

/* Just a hook declaration (but with static funcs and stuff) */
#define SDECL_HOOK(_ret, _name, ...)                             \
    static _ret (*_name)(__VA_ARGS__);                           \
    static _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define SDECL_HOOKv(_name, ...)                                  \
    static void (*_name)(__VA_ARGS__);                           \
    static void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define SDECL_HOOKb(_name, ...)                                  \
    static bool (*_name)(__VA_ARGS__);                           \
    static bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define SDECL_HOOKi(_name, ...)                                  \
    static int (*_name)(__VA_ARGS__);                            \
    static int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define SDECL_HOOKp(_name, ...)                                  \
    static void* (*_name)(__VA_ARGS__);                          \
    static void* HookOf_##_name(__VA_ARGS__)

/* Just a hook declaration (but with static+inlined funcs and stuff) */
#define SIDECL_HOOK(_ret, _name, ...)                             \
    static inline _ret (*_name)(__VA_ARGS__);                     \
    static _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define SIDECL_HOOKv(_name, ...)                                  \
    static inline void (*_name)(__VA_ARGS__);                     \
    static void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define SIDECL_HOOKb(_name, ...)                                  \
    static inline bool (*_name)(__VA_ARGS__);                     \
    static bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define SIDECL_HOOKi(_name, ...)                                  \
    static inline int (*_name)(__VA_ARGS__);                      \
    static int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define SIDECL_HOOKp(_name, ...)                                  \
    static inline void* (*_name)(__VA_ARGS__);                    \
    static void* HookOf_##_name(__VA_ARGS__)

/* Just a hook of a function */
#define HOOK(_name, _fnAddr)                                    \
    aml->Hook((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a function (but simpler usage) */
#define HOOKSYM(_name, _libHndl, _fnSym)                        \
    aml->Hook((void*)(aml->GetSym(_libHndl, _fnSym)), (void*)(&HookOf_##_name), (void**)(&_name));
/* Just a hook of a function located in PLT section (by address!) */
#define HOOKPLT(_name, _fnAddr)                                 \
    aml->HookPLT((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch */
#define HOOKB(_name, _fnAddr)                                   \
    aml->HookB((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch with link */
#define HOOKBL(_name, _fnAddr)                                  \
    aml->HookBL((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch with link (and registers exchange) */
#define HOOKBLX(_name, _fnAddr)                                 \
    aml->HookBLX((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a function hidden behind IL2CPP */
#define HOOK_IL2CPP(_name, _methodInfo)                         \
    aml->Hook((void*)_methodInfo->methodPointer, (void*)(&HookOf_##_name), (void**)(&_name))

#endif // _IAML
```

`mod/icfg.h`:

```h
/* Is not required. Can be used only for a smaller size of mod (~370kb savings) */
/* because of fstream include (it has a lot of templates & not only) */
/* There's no reason of using this feature if you're already using fstream */

#ifndef _ICFG
#define _ICFG

class ICFG
{
public:
    virtual void* InitIniPointer() = 0;
    virtual void ParseInputStream(void* iniPointer, const char* szFilename) = 0;
    virtual void GenerateToOutputStream(void* iniPointer, const char* szFilename) = 0;
    virtual const char* GetValueFrom(void* iniPointer, const char* szSection, const char* szKey) = 0;
    virtual void SetValueTo(void* iniPointer, const char* szSection, const char* szKey, const char* szValue) = 0;
};

extern ICFG* icfg;
inline ICFG* GetCFGInterface()
{
    return icfg;
}

#endif // _ICFG
```

`mod/il2cpp.h`:

```h
struct IL2Assembly;
struct IL2Object;
struct IL2Class;
struct IL2Image;
struct IL2Array;
struct IL2Type;

struct IL2Domain;
struct IL2ReflectionType;
struct IL2Exception;
struct IL2Profiler;
struct IL2Thread;
struct IL2ReflectionMethod;
struct IL2ManagedMemorySnapshot;
struct IL2StackFrameInfo;
struct IL2CustomAttrInfo;
struct IL2GenericClass;
struct IL2Defaults;

struct IL2TypeDefinition;
struct IL2GenericParameter;
struct IL2GenericContainer;

struct MethodInfo;
struct FieldInfo;
struct PropertyInfo;
struct EventInfo;
```

`mod/interface.h`:

```h
/* DO NOT CHANGE IT */

#ifndef __GETINTERFACE_H
#define __GETINTERFACE_H

#if defined(_WIN32) || defined(_WIN64)
    #define WIN32_LEAN_AND_MEAN
    #include <Windows.h>
#else
    #include <dlfcn.h>
#endif
#define DEFAULT_LIB_NAME    "AML"

#define WRAP_INTERFACE(__interface_name, __interface_var)	RegisterInterface(#__interface_name, __interface_var)

typedef void* (*GetInterfaceFn)(const char*);
typedef void* (*RegInterfaceFn)(const char*, void*);

inline void* GetInterface(const char* szInterfaceName)
{
#if defined(_WIN32) || defined(_WIN64)
    GetInterfaceFn _GetInterface = (GetInterfaceFn)GetProcAddress(GetModuleHandleA(DEFAULT_LIB_NAME ".dll"), "GetInterface");
#else
    GetInterfaceFn _GetInterface = (GetInterfaceFn)dlsym((void*)dlopen("lib" DEFAULT_LIB_NAME ".so", RTLD_NOW), "GetInterface");
#endif
    return _GetInterface(szInterfaceName);
}

inline void RegisterInterface(const char* szInterfaceName, void* pInterface)
{
#if defined(_WIN32) || defined(_WIN64)
    RegInterfaceFn _RegInterface = (RegInterfaceFn)GetProcAddress(GetModuleHandleA(DEFAULT_LIB_NAME ".dll"), "CreateInterface");
#else
    RegInterfaceFn _RegInterface = (RegInterfaceFn)dlsym((void*)dlopen("lib" DEFAULT_LIB_NAME ".so", RTLD_NOW), "CreateInterface");
#endif
    _RegInterface(szInterfaceName, pInterface);
}

#endif // __GETINTERFACE_H
```

`mod/listitem.h`:

```h
#pragma once

#include <stddef.h> // use of undeclared identifier 'NULL'

#define LIST_START(__cls_name) struct __cls_name { \
    __cls_name *pPrev; \
    __cls_name *pNext; \
    __cls_name *pLast; \
    unsigned int nCount; \
    typedef __cls_name MyClass; \
    \
    inline unsigned int Count() { return !this ? 0 : First()->nCount; } \
    inline __cls_name *First() \
    { \
        if(!this) return NULL; \
        __cls_name *first = this; \
        if(first->pPrev == this) { first->pPrev = NULL; return this; } \
        while(first->pPrev != NULL) first = first->pPrev; \
        return first; \
    } \
    inline __cls_name *CalcLast() \
    { \
        if(!this) return NULL; \
        __cls_name *last = this; \
        while(last->pNext != NULL) last = last->pNext; \
        return last; \
    } \
    inline __cls_name *Last() \
    { \
        return pLast; \
    } \
    inline void Push(__cls_name **listPtr) \
    { \
        __cls_name*& list = *listPtr; \
        pPrev = NULL; \
        if(list == NULL) { \
            pNext = NULL; \
            pLast = this; \
            nCount = 1; \
        } else { \
            pNext = list; \
            pLast = list->pLast; \
            list->pPrev = this; \
            nCount = list->nCount + 1; \
        } \
        list = this; \
    } \
    inline bool Remove(__cls_name **listPtr) { \
        if(!listPtr || !*listPtr || !pLast) return false; \
        __cls_name*& list = *listPtr; \
        if(list == this) { \
            if(pNext) { \
                list = pNext; \
                list->nCount = nCount - 1; \
                list->pPrev = NULL; \
                list->pLast = pLast; \
            } else { \
                list = NULL; \
            } \
        } \
        else if(list->pLast == this) { \
            list->pLast = pPrev; \
            pPrev->pNext = NULL; \
            --(list->nCount); \
        } else { \
            pPrev->pNext = pNext; \
            if(pNext) pNext->pPrev = pPrev; \
            --(list->nCount); \
        } \
        pNext = NULL; pPrev = NULL; pLast = NULL; \
        return true; \
    } \
    inline bool InList(__cls_name **listPtr) \
    { \
        LIST_FOR(*listPtr) { \
            if(item == this) return true; \
        } \
        return false; \
    }

#define LIST_END() \
};

#define LIST_INITSTART(__cls_name) \
    __cls_name() {

#define LIST_INITEND() \
        pPrev = NULL; \
        pNext = NULL; \
        pLast = NULL; \
        nCount = 1; \
    }

// Never use FAST versions if you do "Remove" or "Push" in a loop! Or maintain it by yourself!

#define LIST_FOR(__list) for(auto item = __list, itemNext = item ? item->pNext : NULL; item != NULL; item = itemNext, itemNext = item ? item->pNext : NULL)
#define LIST_FOR_FAST(__list) for(auto item = __list; item != NULL; item = item->pNext)
#define LIST_FOR2(__list, __itemname) for(auto __itemname = __list, itemNext = __itemname ? __itemname->pNext : NULL; __itemname != NULL; __itemname = itemNext, itemNext = __itemname ? __itemname->pNext : NULL)
#define LIST_FOR2_FAST(__list, __itemname) for(auto __itemname = __list; __itemname != NULL; __itemname = __itemname->pNext)
#define LIST_FOR_REVERSE(__list) for(auto item = __list ? __list->pLast : NULL, itemPrev = item ? item->pPrev : NULL; item != NULL; item = itemPrev, itemPrev = item ? item->pPrev : NULL)
#define LIST_FOR_REVERSE_FAST(__list) for(auto item = __list ? __list->pLast : NULL; item != NULL; item = item->pPrev)
#define LIST_RESET(__list, __resetFunc) LIST_FOR(__list) { __resetFunc(); item->Remove(&__list); }
```

`mod/logger.cpp`:

```cpp
#ifndef DONT_USE_STB
    #ifndef DONT_IMPLEMENT_STB
        #define STB_SPRINTF_IMPLEMENTATION
    #endif
    #include <mod/thirdparty/stb_sprintf.h>

    #define vsnprintf stbsp_vsnprintf
#endif
#include "logger.h"
#include <string.h>
#include <android/log.h>

Logger::Logger()
{
    strncpy(m_szTag, "AML Mod", sizeof(m_szTag));
    m_bEnabled = true;
    m_fnLogCallback = NULL;
    m_fnNewTagCallback = NULL;
    m_fnToggledCallback = NULL;
}

void Logger::ToggleOutput(bool enabled)
{
    if(m_bEnabled != enabled)
    {
        m_bEnabled = enabled;
        if(m_fnToggledCallback) m_fnToggledCallback(enabled);
    }
}

void Logger::SetTag(const char* szTag)
{
    if(m_fnNewTagCallback) m_fnNewTagCallback(m_szTag, szTag);
    strncpy(m_szTag, szTag, sizeof(m_szTag)-1);
    m_szTag[sizeof(m_szTag)-1] = 0;
}

void Logger::Print(eLogPrio prio, const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::PrintV(eLogPrio prio, const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
#endif
}

void Logger::PrintTag(eLogPrio prio, const char* szTag, const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::PrintTagV(eLogPrio prio, const char* szTag, const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
#endif
}

void Logger::Info(const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Info, buffer);
    __android_log_write(ANDROID_LOG_INFO, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::InfoV(const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Info, buffer);
    __android_log_write(ANDROID_LOG_INFO, m_szTag, buffer);
#endif
}

void Logger::Error(const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Error, buffer);
    __android_log_write(ANDROID_LOG_ERROR, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::ErrorV(const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Error, buffer);
    __android_log_write(ANDROID_LOG_ERROR, m_szTag, buffer);
#endif
}

static Logger loggerLocal;
Logger* logger = &loggerLocal;
```

`mod/logger.h`:

```h
#ifndef _LOGGER_H
#define _LOGGER_H

#include <stdio.h>
#define TMPBUF_SIZE 2048 // Max logging buf is 4096 btw

/* Define NOLOGGING if you DONT need logs in any form */
/* You can do it like that in Android.mk: LOCAL_CXXFLAGS += -DNOLOGGING */

enum eLogPrio
{
    LogP_Unk = 0,
    LogP_Default,
    LogP_Verbose,
    LogP_Debug,
    LogP_Info,
    LogP_Warn,
    LogP_Error,
    LogP_Fatal,
    LogP_Silent,
};

class Logger;
extern Logger* logger;

class Logger
{
public:
    typedef void (*LoggerMessageCB)(eLogPrio prio, const char* msg);
    typedef void (*LoggerSetTagCB)(const char* oldTag, const char* newTag);
    typedef void (*LoggerToggledCB)(bool isEnabled);

    inline static Logger* GetLogger() { return logger; }
    Logger();

    void ToggleOutput(bool enabled);
    void SetTag(const char* szTag);
    void Print(eLogPrio prio, const char* szMessage, ...);
    void PrintV(eLogPrio prio, const char* szMessage, va_list args);
    void PrintTag(eLogPrio prio, const char* szTag, const char* szMessage, ...);
    void PrintTagV(eLogPrio prio, const char* szTag, const char* szMessage, va_list args);
    void Info(const char* szMessage, ...);
    void InfoV(const char* szMessage, va_list args);
    void Error(const char* szMessage, ...);
    void ErrorV(const char* szMessage, va_list args);
  #ifdef NOLOGGING
    inline bool HasOutput() { return false; }
  #else
    inline bool HasOutput() { return m_bEnabled; }
  #endif

    inline void SetMessageCB(LoggerMessageCB fnCB) { m_fnLogCallback = fnCB; }
    inline void SetTagCB(LoggerSetTagCB fnCB)      { m_fnNewTagCallback = fnCB; }
    inline void SetToggleCB(LoggerToggledCB fnCB)  { m_fnToggledCallback = fnCB; }

private:
    char m_szTag[31];
    bool m_bEnabled;
    LoggerMessageCB m_fnLogCallback;
    LoggerSetTagCB m_fnNewTagCallback;
    LoggerToggledCB m_fnToggledCallback;
};

#endif // _LOGGER_H
```

`mod/thirdparty/INICPP_LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Fabian Meyer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`mod/thirdparty/STB_LICENSE`:

```
This software is available under 2 licenses -- choose whichever you prefer. ------------------------------------------------------------------------------ ALTERNATIVE A - MIT License Copyright (c) 2017 Sean Barrett Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ------------------------------------------------------------------------------ ALTERNATIVE B - Public Domain (www.unlicense.org) This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`mod/thirdparty/inicpp.h`:

```h
/*
 * inicpp.h
 *
 * Created on: 26 Dec 2015
 *     Author: Fabian Meyer
 *    License: MIT
 */

#ifndef INICPP_H_
#define INICPP_H_

#include <algorithm>
#include <fstream>
#include <istream>
#include <map>
#include <assert.h>
#include <sstream>
#include <stdexcept>
#include <vector>

namespace ini
{
    /************************************************
     * Helper Functions
     ************************************************/

    /** Returns a string of whitespace characters. */
    constexpr const char *whitespaces()
    {
        return " \t\n\r\f\v";
    }

    /** Returns a string of indentation characters. */
    constexpr const char *indents()
    {
        return " \t";
    }

    /** Trims a string in place.
      * @param str string to be trimmed in place */
    inline void trim(std::string &str)
    {
        // first erasing from end should be slighty more efficient
        // because erasing from start potentially moves all chars
        // multiple indices towards the front.

        auto lastpos = str.find_last_not_of(whitespaces());
        if(lastpos == std::string::npos)
        {
            str.clear();
            return;
        }

        str.erase(lastpos + 1);
        str.erase(0, str.find_first_not_of(whitespaces()));
    }

    /************************************************
     * Conversion Functors
     ************************************************/

    inline bool strToLong(const std::string &value, long &result)
    {
        char *endptr;
        // check if decimal
        result = std::strtol(value.c_str(), &endptr, 10);
        if(*endptr == '\0')
            return true;
        // check if octal
        result = std::strtol(value.c_str(), &endptr, 8);
        if(*endptr == '\0')
            return true;
        // check if hex
        result = std::strtol(value.c_str(), &endptr, 16);
        if(*endptr == '\0')
            return true;

        return false;
    }

    inline bool strToULong(const std::string &value, unsigned long &result)
    {
        char *endptr;
        // check if decimal
        result = std::strtoul(value.c_str(), &endptr, 10);
        if(*endptr == '\0')
            return true;
        // check if octal
        result = std::strtoul(value.c_str(), &endptr, 8);
        if(*endptr == '\0')
            return true;
        // check if hex
        result = std::strtoul(value.c_str(), &endptr, 16);
        if(*endptr == '\0')
            return true;

        return false;
    }

    template<typename T>
    struct Convert
    {};

    template<>
    struct Convert<bool>
    {
        void decode(const std::string &value, bool &result)
        {
            std::string str(value);
            std::transform(str.begin(), str.end(), str.begin(), [](const char c){
                return static_cast<char>(::toupper(c));
            });

            if(str == "TRUE")
                result = true;
            else if(str == "FALSE")
                result = false;
            else
                throw std::invalid_argument("field is not a bool");
        }

        void encode(const bool value, std::string &result)
        {
            result = value ? "true" : "false";
        }
    };

    template<>
    struct Convert<char>
    {
        void decode(const std::string &value, char &result)
        {
            assert(value.size() > 0);
            result = value[0];
        }

        void encode(const char value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<unsigned char>
    {
        void decode(const std::string &value, unsigned char &result)
        {
            assert(value.size() > 0);
            result = value[0];
        }

        void encode(const unsigned char value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<short>
    {
        void decode(const std::string &value, short &result)
        {
            long tmp;
            if(!strToLong(value, tmp))
                throw std::invalid_argument("field is not a short");
            result = static_cast<short>(tmp);
        }

        void encode(const short value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned short>
    {
        void decode(const std::string &value, unsigned short &result)
        {
            unsigned long tmp;
            if(!strToULong(value, tmp))
                throw std::invalid_argument("field is not an unsigned short");
            result = static_cast<unsigned short>(tmp);
        }

        void encode(const unsigned short value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<int>
    {
        void decode(const std::string &value, int &result)
        {
            long tmp;
            if(!strToLong(value, tmp))
                throw std::invalid_argument("field is not an int");
            result = static_cast<int>(tmp);
        }

        void encode(const int value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned int>
    {
        void decode(const std::string &value, unsigned int &result)
        {
            unsigned long tmp;
            if(!strToULong(value, tmp))
                throw std::invalid_argument("field is not an unsigned int");
            result = static_cast<unsigned int>(tmp);
        }

        void encode(const unsigned int value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<long>
    {
        void decode(const std::string &value, long &result)
        {
            if(!strToLong(value, result))
                throw std::invalid_argument("field is not a long");
        }

        void encode(const long value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned long>
    {
        void decode(const std::string &value, unsigned long &result)
        {
            if(!strToULong(value, result))
                throw std::invalid_argument("field is not an unsigned long");
        }

        void encode(const unsigned long value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<double>
    {
        void decode(const std::string &value, double &result)
        {
            result = std::stod(value);
        }

        void encode(const double value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<float>
    {
        void decode(const std::string &value, float &result)
        {
            result = std::stof(value);
        }

        void encode(const float value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<std::string>
    {
        void decode(const std::string &value, std::string &result)
        {
            result = value;
        }

        void encode(const std::string &value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<const char*>
    {
        void encode(const char* const &value, std::string &result)
        {
            result = value;
        }

        void decode(const std::string &value, const char* &result)
        {
            result = value.c_str();
        }
    };

    template<>
    struct Convert<char*>
    {
        void encode(const char* const &value, std::string &result)
        {
            result = value;
        }
    };

    template<size_t n>
    struct Convert<char[n]>
    {
        void encode(const char *value, std::string &result)
        {
            result = value;
        }
    };

    class IniField
    {
    private:
        std::string value_;

    public:
        IniField() : value_()
        {}

        IniField(const std::string &value) : value_(value)
        {}
        IniField(const IniField &field) : value_(field.value_)
        {}

        ~IniField()
        {}

        template<typename T>
        T as() const
        {
            Convert<T> conv;
            T result;
            conv.decode(value_, result);
            return result;
        }

        template<typename T>
        IniField &operator=(const T &value)
        {
            Convert<T> conv;
            conv.encode(value, value_);
            return *this;
        }

        IniField &operator=(const IniField &field)
        {
            value_ = field.value_;
            return *this;
        }
    };

    struct StringInsensitiveLess
    {
        bool operator()(std::string lhs, std::string rhs) const
        {
                std::transform(lhs.begin(), lhs.end(), lhs.begin(), [](const char c){
                    return static_cast<char>(::tolower(c));
                });
                std::transform(rhs.begin(), rhs.end(), rhs.begin(), [](const char c){
                    return static_cast<char>(::tolower(c));
                });
                return  lhs < rhs;
        }
    };

    template <typename Comparator>
    class IniSectionBase : public std::map<std::string, IniField, Comparator>
    {
    public:
        IniSectionBase()
        {}
        ~IniSectionBase()
        {}
    };

    using IniSection = IniSectionBase<std::less<std::string>>;
    using IniSectionCaseInsensitive = IniSectionBase<StringInsensitiveLess>;

    template <typename Comparator>
    class IniFileBase : public std::map<std::string, IniSectionBase<Comparator>, Comparator>
    {
    private:
        char fieldSep_ = '=';
        char esc_ = '\\';
        std::vector<std::string> commentPrefixes_ = { "#" , ";" };
        bool multiLineValues_ = false;

        void eraseComment(const std::string &commentPrefix,
            std::string &str,
            std::string::size_type startpos = 0)
        {
            size_t prefixpos = str.find(commentPrefix, startpos);
            if(std::string::npos == prefixpos)
                return;
            // Found a comment prefix, is it escaped?
            if(0 != prefixpos && str[prefixpos - 1] == esc_)
            {
                // The comment prefix is escaped, so just delete the escape char
                // and keep erasing after the comment prefix
                str.erase(prefixpos - 1, 1);
                eraseComment(
                    commentPrefix, str, prefixpos - 1 + commentPrefix.size());
            }
            else
            {
                str.erase(prefixpos);
            }
        }

        void eraseComments(std::string &str)
        {
            for(const std::string &commentPrefix : commentPrefixes_)
                eraseComment(commentPrefix, str);
        }

        /** Tries to find a suitable comment prefix for the string data at the given
          * position. Returns commentPrefixes_.end() if not match was found. */
        std::vector<std::string>::const_iterator findCommentPrefix(const std::string &str,
            const std::size_t startpos) const
        {
            // if startpos is invalid simply return "not found"
            if(startpos >= str.size())
                return commentPrefixes_.end();

            for(size_t i = 0; i < commentPrefixes_.size(); ++i)
            {
                const std::string &prefix = commentPrefixes_[i];
                // if this comment prefix is longer than the string view itself
                // then skip
                if(prefix.size() + startpos > str.size())
                    continue;

                bool match = true;
                for(size_t j = 0; j < prefix.size() && match; ++j)
                    match = str[startpos + j] == prefix[j];

                if(match)
                    return commentPrefixes_.begin() + i;
            }

            return commentPrefixes_.end();
        }

        void writeEscaped(std::ostream &os, const std::string &str) const
        {
            for(size_t i = 0; i < str.length(); ++i)
            {
                auto prefixpos = findCommentPrefix(str, i);
                // if no suitable prefix was found at this position
                // then simply write the current character
                if(prefixpos != commentPrefixes_.end())
                {
                    const std::string &prefix = *prefixpos;
                    os.put(esc_);
                    os.write(prefix.c_str(), prefix.size());
                    i += prefix.size() - 1;
                }
                else if (multiLineValues_ && str[i] == '\n')
                    os.write("\n\t", 2);
                else
                    os.put(str[i]);
            }
        }

    public:
        IniFileBase() = default;

        IniFileBase(const char fieldSep, const char comment)
            : fieldSep_(fieldSep), commentPrefixes_(1, std::string(1, comment))
        {}

        IniFileBase(const std::string &filename)
        {
            load(filename);
        }

        IniFileBase(std::istream &is)
        {
            decode(is);
        }

        IniFileBase(const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {}

        IniFileBase(const std::string &filename,
            const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {
            load(filename);
        }

        IniFileBase(std::istream &is,
            const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {
            decode(is);
        }

        ~IniFileBase()
        {}

        /** Sets the separator charactor for fields in the INI file.
          * @param sep separator character to be used. */
        void setFieldSep(const char sep)
        {
            fieldSep_ = sep;
        }

        /** Sets the character that should be interpreted as the start of comments.
          * Default is '#'.
          * Note: If the inifile contains the comment character as data it must be prefixed with
          * the configured escape character.
          * @param comment comment character to be used. */
        void setCommentChar(const char comment)
        {
            commentPrefixes_ = {std::string(1, comment)};
        }

        /** Sets the list of strings that should be interpreted as the start of comments.
          * Default is [ "#" ].
          * Note: If the inifile contains any comment string as data it must be prefixed with
          * the configured escape character.
          * @param commentPrefixes vector of comment prefix strings to be used. */
        void setCommentPrefixes(const std::vector<std::string> &commentPrefixes)
        {
            commentPrefixes_ = commentPrefixes;
        }

        /** Sets the character that should be used to escape comment prefixes.
          * Default is '\'.
          * @param esc escape character to be used. */
        void setEscapeChar(const char esc)
        {
            esc_ = esc;
        }

        /** Sets whether or not to parse multi-line field values.
          * Default is false.
          * @param enable enable or disable? */
        void setMultiLineValues(bool enable)
        {
            multiLineValues_ = enable;
        }

        /** Tries to decode a ini file from the given input stream.
          * @param is input stream from which data should be read. */
        void decode(std::istream &is)
        {
            this->clear();
            int lineNo = 0;
            IniSectionBase<Comparator> *currentSection = nullptr;
            std::string mutliLineValueFieldName = "";
            std::string line;
            // iterate file line by line
            while(!is.eof() && !is.fail())
            {
                std::getline(is, line, '\n');
                eraseComments(line);
                bool hasIndent = line.find_first_not_of(indents()) != 0;
                trim(line);
                ++lineNo;

                // skip if line is empty
                if(line.size() == 0)
                    continue;

                if(line[0] == '[')
                {
                    // line is a section
                    // check if the section is also closed on same line
                    std::size_t pos = line.find("]");
                    if(pos == std::string::npos)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, section not closed";
                        throw std::logic_error(ss.str());
                    }
                    // check if the section name is empty
                    if(pos == 1)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, section is empty";
                        throw std::logic_error(ss.str());
                    }

                    // retrieve section name
                    std::string secName = line.substr(1, pos - 1);
                    currentSection = &((*this)[secName]);

                    // clear multiline value field name
                    // a new section means there is no value to continue
                    mutliLineValueFieldName = "";
                }
                else
                {
                    // line is a field definition
                    // check if section was already opened
                    if(currentSection == nullptr)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, field has no section";
                        throw std::logic_error(ss.str());
                    }

                    // find key value separator
                    std::size_t pos = line.find(fieldSep_);
                    if (multiLineValues_ && hasIndent && mutliLineValueFieldName != "")
                    {
                        // extend a multi-line value
                        IniField previous_value = (*currentSection)[mutliLineValueFieldName];
                        std::string value = previous_value.as<std::string>() + "\n" + line;
                        (*currentSection)[mutliLineValueFieldName] = value;
                    }
                    else if(pos == std::string::npos)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, no '"
                           << fieldSep_
                           << "' found";
                        if (multiLineValues_)
                            ss << ", and not a multi-line value continuation";
                        throw std::logic_error(ss.str());
                    }
                    else
                    {
                        // retrieve field name and value
                        std::string name = line.substr(0, pos);
                        trim(name);
                        std::string value = line.substr(pos + 1, std::string::npos);
                        trim(value);
                        (*currentSection)[name] = value;
                        // store last field name for potential multi-line values
                        mutliLineValueFieldName = name;
                    }
                }
            }
        }

        /** Tries to decode a ini file from the given input string.
          * @param content string to be decoded. */
        void decode(const std::string &content)
        {
            std::istringstream ss(content);
            decode(ss);
        }

        /** Tries to load and decode a ini file from the file at the given path.
          * @param fileName path to the file that should be loaded. */
        void load(const std::string &fileName)
        {
            std::ifstream is(fileName.c_str());
            decode(is);
        }

        /** Encodes this inifile object and writes the output to the given stream.
          * @param os target stream. */
        void encode(std::ostream &os) const
        {
            // iterate through all sections in this file
            for(const auto &filePair : *this)
            {
                os.put('[');
                writeEscaped(os, filePair.first);
                os.put(']');
                os.put('\n');

                // iterate through all fields in the section
                for(const auto &secPair : filePair.second)
                {
                    writeEscaped(os, secPair.first);
                    os.put(fieldSep_);
                    writeEscaped(os, secPair.second.template as<std::string>());
                    os.put('\n');
                }
            }
        }

        /** Encodes this inifile object as string and returns the result.
          * @return encoded infile string. */
        std::string encode() const
        {
            std::ostringstream ss;
            encode(ss);
            return ss.str();
        }

        /** Saves this inifile object to the file at the given path.
          * @param fileName path to the file where the data should be stored. */
        void save(const std::string &fileName) const
        {
            std::ofstream os(fileName.c_str());
            encode(os);
        }
    };

    using IniFile = IniFileBase<std::less<std::string>>;
    using IniSection = IniSectionBase<std::less<std::string>>;
    using IniFileCaseInsensitive = IniFileBase<StringInsensitiveLess>;
    using IniSectionCaseInsensitive = IniSectionBase<StringInsensitiveLess>;
}

#endif

```

`mod/thirdparty/stb_sprintf.h`:

```h
// stb_sprintf - v1.10 - public domain snprintf() implementation
// originally by Jeff Roberts / RAD Game Tools, 2015/10/20
// http://github.com/nothings/stb
//
// allowed types:  sc uidBboXx p AaGgEef n
// lengths      :  hh h ll j z t I64 I32 I
//
// Contributors:
//    Fabian "ryg" Giesen (reformatting)
//    github:aganm (attribute format)
//
// Contributors (bugfixes):
//    github:d26435
//    github:trex78
//    github:account-login
//    Jari Komppa (SI suffixes)
//    Rohit Nirmal
//    Marcin Wojdyr
//    Leonard Ritter
//    Stefano Zanotti
//    Adam Allison
//    Arvid Gerstmann
//    Markus Kolb
//
// LICENSE:
//
//   See end of file for license information.

#ifndef STB_SPRINTF_H_INCLUDE
#define STB_SPRINTF_H_INCLUDE

/*
Single file sprintf replacement.

Originally written by Jeff Roberts at RAD Game Tools - 2015/10/20.
Hereby placed in public domain.

This is a full sprintf replacement that supports everything that
the C runtime sprintfs support, including float/double, 64-bit integers,
hex floats, field parameters (%*.*d stuff), length reads backs, etc.

Why would you need this if sprintf already exists?  Well, first off,
it's *much* faster (see below). It's also much smaller than the CRT
versions code-space-wise. We've also added some simple improvements
that are super handy (commas in thousands, callbacks at buffer full,
for example). Finally, the format strings for MSVC and GCC differ
for 64-bit integers (among other small things), so this lets you use
the same format strings in cross platform code.

It uses the standard single file trick of being both the header file
and the source itself. If you just include it normally, you just get
the header file function definitions. To get the code, you include
it from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.

It only uses va_args macros from the C runtime to do it's work. It
does cast doubles to S64s and shifts and divides U64s, which does
drag in CRT code on most platforms.

It compiles to roughly 8K with float support, and 4K without.
As a comparison, when using MSVC static libs, calling sprintf drags
in 16K.

API:
====
int stbsp_sprintf( char * buf, char const * fmt, ... )
int stbsp_snprintf( char * buf, size_t count, char const * fmt, ... )
  Convert an arg list into a buffer.  stbsp_snprintf always returns
  a zero-terminated string (unlike regular snprintf).

int stbsp_vsprintf( char * buf, char const * fmt, va_list va )
int stbsp_vsnprintf( char * buf, size_t count, char const * fmt, va_list va )
  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns
  a zero-terminated string (unlike regular snprintf).

int stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )
    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );
  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.
  Your callback can then copy the chars out, print them or whatever.
  This function is actually the workhorse for everything else.
  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.
    // you return the next buffer to use or 0 to stop converting

void stbsp_set_separators( char comma, char period )
  Set the comma and period characters to use.

FLOATS/DOUBLES:
===============
This code uses a internal float->ascii conversion method that uses
doubles with error correction (double-doubles, for ~105 bits of
precision).  This conversion is round-trip perfect - that is, an atof
of the values output here will give you the bit-exact double back.

One difference is that our insignificant digits will be different than
with MSVC or GCC (but they don't match each other either).  We also
don't attempt to find the minimum length matching float (pre-MSVC15
doesn't either).

If you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT
and you'll save 4K of code space.

64-BIT INTS:
============
This library also supports 64-bit integers and you can use MSVC style or
GCC style indicators (%I64d or %lld).  It supports the C99 specifiers
for size_t and ptr_diff_t (%jd %zd) as well.

EXTRAS:
=======
Like some GCCs, for integers and floats, you can use a ' (single quote)
specifier and commas will be inserted on the thousands: "%'d" on 12345
would print 12,345.

For integers and floats, you can use a "$" specifier and the number
will be converted to float and then divided to get kilo, mega, giga or
tera and then printed, so "%$d" 1000 is "1.0 k", "%$.2d" 2536000 is
"2.53 M", etc. For byte values, use two $:s, like "%$$d" to turn
2536000 to "2.42 Mi". If you prefer JEDEC suffixes to SI ones, use three
$:s: "%$$$d" -> "2.42 M". To remove the space between the number and the
suffix, add "_" specifier: "%_$d" -> "2.53M".

In addition to octal and hexadecimal conversions, you can print
integers in binary: "%b" for 256 would print 100.

PERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):
===================================================================
"%d" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)
"%24d" across all 32-bit ints (4.5x/4.2x faster)
"%x" across all 32-bit ints (4.5x/3.8x faster)
"%08x" across all 32-bit ints (4.3x/3.8x faster)
"%f" across e-10 to e+10 floats (7.3x/6.0x faster)
"%e" across e-10 to e+10 floats (8.1x/6.0x faster)
"%g" across e-10 to e+10 floats (10.0x/7.1x faster)
"%f" for values near e-300 (7.9x/6.5x faster)
"%f" for values near e+300 (10.0x/9.1x faster)
"%e" for values near e-300 (10.1x/7.0x faster)
"%e" for values near e+300 (9.2x/6.0x faster)
"%.320f" for values near e-300 (12.6x/11.2x faster)
"%a" for random values (8.6x/4.3x faster)
"%I64d" for 64-bits with 32-bit values (4.8x/3.4x faster)
"%I64d" for 64-bits > 32-bit values (4.9x/5.5x faster)
"%s%s%s" for 64 char strings (7.1x/7.3x faster)
"...512 char string..." ( 35.0x/32.5x faster!)
*/

#if defined(__clang__)
 #if defined(__has_feature) && defined(__has_attribute)
  #if __has_feature(address_sanitizer)
   #if __has_attribute(__no_sanitize__)
    #define STBSP__ASAN __attribute__((__no_sanitize__("address")))
   #elif __has_attribute(__no_sanitize_address__)
    #define STBSP__ASAN __attribute__((__no_sanitize_address__))
   #elif __has_attribute(__no_address_safety_analysis__)
    #define STBSP__ASAN __attribute__((__no_address_safety_analysis__))
   #endif
  #endif
 #endif
#elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))
 #if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__
  #define STBSP__ASAN __attribute__((__no_sanitize_address__))
 #endif
#endif

#ifndef STBSP__ASAN
#define STBSP__ASAN
#endif

#ifdef STB_SPRINTF_STATIC
#define STBSP__PUBLICDEC static
#define STBSP__PUBLICDEF static STBSP__ASAN
#else
#ifdef __cplusplus
#define STBSP__PUBLICDEC extern "C"
#define STBSP__PUBLICDEF extern "C" STBSP__ASAN
#else
#define STBSP__PUBLICDEC extern
#define STBSP__PUBLICDEF STBSP__ASAN
#endif
#endif

#if defined(__has_attribute)
 #if __has_attribute(format)
   #define STBSP__ATTRIBUTE_FORMAT(fmt,va) __attribute__((format(printf,fmt,va)))
 #endif
#endif

#ifndef STBSP__ATTRIBUTE_FORMAT
#define STBSP__ATTRIBUTE_FORMAT(fmt,va)
#endif

#ifdef _MSC_VER
#define STBSP__NOTUSED(v)  (void)(v)
#else
#define STBSP__NOTUSED(v)  (void)sizeof(v)
#endif

#include <stdarg.h> // for va_arg(), va_list()
#include <stddef.h> // size_t, ptrdiff_t

#ifndef STB_SPRINTF_MIN
#define STB_SPRINTF_MIN 512 // how many characters per callback
#endif
typedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);

#ifndef STB_SPRINTF_DECORATE
#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names
#endif

STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, size_t count, char const *fmt, va_list va);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(2,3);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(snprintf)(char *buf, size_t count, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(3,4);

STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);
STBSP__PUBLICDEC void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);

#endif // STB_SPRINTF_H_INCLUDE

#ifdef STB_SPRINTF_IMPLEMENTATION

#define stbsp__uint32 unsigned int
#define stbsp__int32 signed int

#ifdef _MSC_VER
#define stbsp__uint64 unsigned __int64
#define stbsp__int64 signed __int64
#else
#define stbsp__uint64 unsigned long long
#define stbsp__int64 signed long long
#endif
#define stbsp__uint16 unsigned short

#ifndef stbsp__uintptr
#if defined(__ppc64__) || defined(__powerpc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64) || defined(__s390x__)
#define stbsp__uintptr stbsp__uint64
#else
#define stbsp__uintptr stbsp__uint32
#endif
#endif

#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)
#if defined(_MSC_VER) && (_MSC_VER < 1900)
#define STB_SPRINTF_MSVC_MODE
#endif
#endif

#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses
#define STBSP__UNALIGNED(code)
#else
#define STBSP__UNALIGNED(code) code
#endif

#ifndef STB_SPRINTF_NOFLOAT
// internal float utility functions
static stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);
static stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);
#define STBSP__SPECIAL 0x7000
#endif

static char stbsp__period = '.';
static char stbsp__comma = ',';
static struct
{
   short temp; // force next field to be 2-byte aligned
   char pair[201];
} stbsp__digitpair =
{
  0,
   "00010203040506070809101112131415161718192021222324"
   "25262728293031323334353637383940414243444546474849"
   "50515253545556575859606162636465666768697071727374"
   "75767778798081828384858687888990919293949596979899"
};

STBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)
{
   stbsp__period = pperiod;
   stbsp__comma = pcomma;
}

#define STBSP__LEFTJUST 1
#define STBSP__LEADINGPLUS 2
#define STBSP__LEADINGSPACE 4
#define STBSP__LEADING_0X 8
#define STBSP__LEADINGZERO 16
#define STBSP__INTMAX 32
#define STBSP__TRIPLET_COMMA 64
#define STBSP__NEGATIVE 128
#define STBSP__METRIC_SUFFIX 256
#define STBSP__HALFWIDTH 512
#define STBSP__METRIC_NOSPACE 1024
#define STBSP__METRIC_1024 2048
#define STBSP__METRIC_JEDEC 4096

static void stbsp__lead_sign(stbsp__uint32 fl, char *sign)
{
   sign[0] = 0;
   if (fl & STBSP__NEGATIVE) {
      sign[0] = 1;
      sign[1] = '-';
   } else if (fl & STBSP__LEADINGSPACE) {
      sign[0] = 1;
      sign[1] = ' ';
   } else if (fl & STBSP__LEADINGPLUS) {
      sign[0] = 1;
      sign[1] = '+';
   }
}

static STBSP__ASAN stbsp__uint32 stbsp__strlen_limited(char const *s, stbsp__uint32 limit)
{
   char const * sn = s;

   // get up to 4-byte alignment
   for (;;) {
      if (((stbsp__uintptr)sn & 3) == 0)
         break;

      if (!limit || *sn == 0)
         return (stbsp__uint32)(sn - s);

      ++sn;
      --limit;
   }

   // scan over 4 bytes at a time to find terminating 0
   // this will intentionally scan up to 3 bytes past the end of buffers,
   // but becase it works 4B aligned, it will never cross page boundaries
   // (hence the STBSP__ASAN markup; the over-read here is intentional
   // and harmless)
   while (limit >= 4) {
      stbsp__uint32 v = *(stbsp__uint32 *)sn;
      // bit hack to find if there's a 0 byte in there
      if ((v - 0x01010101) & (~v) & 0x80808080UL)
         break;

      sn += 4;
      limit -= 4;
   }

   // handle the last few characters to find actual size
   while (limit && *sn) {
      ++sn;
      --limit;
   }

   return (stbsp__uint32)(sn - s);
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)
{
   static char hex[] = "0123456789abcdefxp";
   static char hexu[] = "0123456789ABCDEFXP";
   char *bf;
   char const *f;
   int tlen = 0;

   bf = buf;
   f = fmt;
   for (;;) {
      stbsp__int32 fw, pr, tz;
      stbsp__uint32 fl;

      // macros for the callback buffer stuff
      #define stbsp__chk_cb_bufL(bytes)                        \
         {                                                     \
            int len = (int)(bf - buf);                         \
            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \
               tlen += len;                                    \
               if (0 == (bf = buf = callback(buf, user, len))) \
                  goto done;                                   \
            }                                                  \
         }
      #define stbsp__chk_cb_buf(bytes)    \
         {                                \
            if (callback) {               \
               stbsp__chk_cb_bufL(bytes); \
            }                             \
         }
      #define stbsp__flush_cb()                      \
         {                                           \
            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \
         } // flush if there is even one byte in the buffer
      #define stbsp__cb_buf_clamp(cl, v)                \
         cl = v;                                        \
         if (callback) {                                \
            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \
            if (cl > lg)                                \
               cl = lg;                                 \
         }

      // fast copy everything up to the next % (or end of string)
      for (;;) {
         while (((stbsp__uintptr)f) & 3) {
         schk1:
            if (f[0] == '%')
               goto scandd;
         schk2:
            if (f[0] == 0)
               goto endfmt;
            stbsp__chk_cb_buf(1);
            *bf++ = f[0];
            ++f;
         }
         for (;;) {
            // Check if the next 4 bytes contain %(0x25) or end of string.
            // Using the 'hasless' trick:
            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord
            stbsp__uint32 v, c;
            v = *(stbsp__uint32 *)f;
            c = (~v) & 0x80808080;
            if (((v ^ 0x25252525) - 0x01010101) & c)
               goto schk1;
            if ((v - 0x01010101) & c)
               goto schk2;
            if (callback)
               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)
                  goto schk1;
            #ifdef STB_SPRINTF_NOUNALIGNED
                if(((stbsp__uintptr)bf) & 3) {
                    bf[0] = f[0];
                    bf[1] = f[1];
                    bf[2] = f[2];
                    bf[3] = f[3];
                } else
            #endif
            {
                *(stbsp__uint32 *)bf = v;
            }
            bf += 4;
            f += 4;
         }
      }
   scandd:

      ++f;

      // ok, we have a percent, read the modifiers first
      fw = 0;
      pr = -1;
      fl = 0;
      tz = 0;

      // flags
      for (;;) {
         switch (f[0]) {
         // if we have left justify
         case '-':
            fl |= STBSP__LEFTJUST;
            ++f;
            continue;
         // if we have leading plus
         case '+':
            fl |= STBSP__LEADINGPLUS;
            ++f;
            continue;
         // if we have leading space
         case ' ':
            fl |= STBSP__LEADINGSPACE;
            ++f;
            continue;
         // if we have leading 0x
         case '#':
            fl |= STBSP__LEADING_0X;
            ++f;
            continue;
         // if we have thousand commas
         case '\'':
            fl |= STBSP__TRIPLET_COMMA;
            ++f;
            continue;
         // if we have kilo marker (none->kilo->kibi->jedec)
         case '$':
            if (fl & STBSP__METRIC_SUFFIX) {
               if (fl & STBSP__METRIC_1024) {
                  fl |= STBSP__METRIC_JEDEC;
               } else {
                  fl |= STBSP__METRIC_1024;
               }
            } else {
               fl |= STBSP__METRIC_SUFFIX;
            }
            ++f;
            continue;
         // if we don't want space between metric suffix and number
         case '_':
            fl |= STBSP__METRIC_NOSPACE;
            ++f;
            continue;
         // if we have leading zero
         case '0':
            fl |= STBSP__LEADINGZERO;
            ++f;
            goto flags_done;
         default: goto flags_done;
         }
      }
   flags_done:

      // get the field width
      if (f[0] == '*') {
         fw = va_arg(va, stbsp__uint32);
         ++f;
      } else {
         while ((f[0] >= '0') && (f[0] <= '9')) {
            fw = fw * 10 + f[0] - '0';
            f++;
         }
      }
      // get the precision
      if (f[0] == '.') {
         ++f;
         if (f[0] == '*') {
            pr = va_arg(va, stbsp__uint32);
            ++f;
         } else {
            pr = 0;
            while ((f[0] >= '0') && (f[0] <= '9')) {
               pr = pr * 10 + f[0] - '0';
               f++;
            }
         }
      }

      // handle integer size overrides
      switch (f[0]) {
      // are we halfwidth?
      case 'h':
         fl |= STBSP__HALFWIDTH;
         ++f;
         if (f[0] == 'h')
            ++f;  // QUARTERWIDTH
         break;
      // are we 64-bit (unix style)
      case 'l':
         fl |= ((sizeof(long) == 8) ? STBSP__INTMAX : 0);
         ++f;
         if (f[0] == 'l') {
            fl |= STBSP__INTMAX;
            ++f;
         }
         break;
      // are we 64-bit on intmax? (c99)
      case 'j':
         fl |= (sizeof(size_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      // are we 64-bit on size_t or ptrdiff_t? (c99)
      case 'z':
         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      case 't':
         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      // are we 64-bit (msft style)
      case 'I':
         if ((f[1] == '6') && (f[2] == '4')) {
            fl |= STBSP__INTMAX;
            f += 3;
         } else if ((f[1] == '3') && (f[2] == '2')) {
            f += 3;
         } else {
            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);
            ++f;
         }
         break;
      default: break;
      }

      // handle each replacement
      switch (f[0]) {
         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307
         char num[STBSP__NUMSZ];
         char lead[8];
         char tail[8];
         char *s;
         char const *h;
         stbsp__uint32 l, n, cs;
         stbsp__uint64 n64;
#ifndef STB_SPRINTF_NOFLOAT
         double fv;
#endif
         stbsp__int32 dp;
         char const *sn;

      case 's':
         // get the string
         s = va_arg(va, char *);
         if (s == 0)
            s = (char *)"null";
         // get the length, limited to desired precision
         // always limit to ~0u chars since our counts are 32b
         l = stbsp__strlen_limited(s, (pr >= 0) ? pr : ~0u);
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         // copy the string in
         goto scopy;

      case 'c': // char
         // get the character
         s = num + STBSP__NUMSZ - 1;
         *s = (char)va_arg(va, int);
         l = 1;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         goto scopy;

      case 'n': // weird write-bytes specifier
      {
         int *d = va_arg(va, int *);
         *d = tlen + (int)(bf - buf);
      } break;

#ifdef STB_SPRINTF_NOFLOAT
      case 'A':              // float
      case 'a':              // hex float
      case 'G':              // float
      case 'g':              // float
      case 'E':              // float
      case 'e':              // float
      case 'f':              // float
         va_arg(va, double); // eat it
         s = (char *)"No float";
         l = 8;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         cs = 0;
         STBSP__NOTUSED(dp);
         goto scopy;
#else
      case 'A': // hex float
      case 'a': // hex float
         h = (f[0] == 'A') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))
            fl |= STBSP__NEGATIVE;

         s = num + 64;

         stbsp__lead_sign(fl, lead);

         if (dp == -1023)
            dp = (n64) ? -1022 : 0;
         else
            n64 |= (((stbsp__uint64)1) << 52);
         n64 <<= (64 - 56);
         if (pr < 15)
            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));
// add leading chars

#ifdef STB_SPRINTF_MSVC_MODE
         *s++ = '0';
         *s++ = 'x';
#else
         lead[1 + lead[0]] = '0';
         lead[2 + lead[0]] = 'x';
         lead[0] += 2;
#endif
         *s++ = h[(n64 >> 60) & 15];
         n64 <<= 4;
         if (pr)
            *s++ = stbsp__period;
         sn = s;

         // print the bits
         n = pr;
         if (n > 13)
            n = 13;
         if (pr > (stbsp__int32)n)
            tz = pr - n;
         pr = 0;
         while (n--) {
            *s++ = h[(n64 >> 60) & 15];
            n64 <<= 4;
         }

         // print the expo
         tail[1] = h[17];
         if (dp < 0) {
            tail[2] = '-';
            dp = -dp;
         } else
            tail[2] = '+';
         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));
         tail[0] = (char)n;
         for (;;) {
            tail[n] = '0' + dp % 10;
            if (n <= 3)
               break;
            --n;
            dp /= 10;
         }

         dp = (int)(s - sn);
         l = (int)(s - (num + 64));
         s = num + 64;
         cs = 1 + (3 << 24);
         goto scopy;

      case 'G': // float
      case 'g': // float
         h = (f[0] == 'G') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6;
         else if (pr == 0)
            pr = 1; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))
            fl |= STBSP__NEGATIVE;

         // clamp the precision and delete extra zeros after clamp
         n = pr;
         if (l > (stbsp__uint32)pr)
            l = pr;
         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {
            --pr;
            --l;
         }

         // should we use %e
         if ((dp <= -4) || (dp > (stbsp__int32)n)) {
            if (pr > (stbsp__int32)l)
               pr = l - 1;
            else if (pr)
               --pr; // when using %e, there is one digit before the decimal
            goto doexpfromg;
         }
         // this is the insane action to get the pr to match %g semantics for %f
         if (dp > 0) {
            pr = (dp < (stbsp__int32)l) ? l - dp : 0;
         } else {
            pr = -dp + ((pr > (stbsp__int32)l) ? (stbsp__int32) l : pr);
         }
         goto dofloatfromg;

      case 'E': // float
      case 'e': // float
         h = (f[0] == 'E') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))
            fl |= STBSP__NEGATIVE;
      doexpfromg:
         tail[0] = 0;
         stbsp__lead_sign(fl, lead);
         if (dp == STBSP__SPECIAL) {
            s = (char *)sn;
            cs = 0;
            pr = 0;
            goto scopy;
         }
         s = num + 64;
         // handle leading chars
         *s++ = sn[0];

         if (pr)
            *s++ = stbsp__period;

         // handle after decimal
         if ((l - 1) > (stbsp__uint32)pr)
            l = pr + 1;
         for (n = 1; n < l; n++)
            *s++ = sn[n];
         // trailing zeros
         tz = pr - (l - 1);
         pr = 0;
         // dump expo
         tail[1] = h[0xe];
         dp -= 1;
         if (dp < 0) {
            tail[2] = '-';
            dp = -dp;
         } else
            tail[2] = '+';
#ifdef STB_SPRINTF_MSVC_MODE
         n = 5;
#else
         n = (dp >= 100) ? 5 : 4;
#endif
         tail[0] = (char)n;
         for (;;) {
            tail[n] = '0' + dp % 10;
            if (n <= 3)
               break;
            --n;
            dp /= 10;
         }
         cs = 1 + (3 << 24); // how many tens
         goto flt_lead;

      case 'f': // float
         fv = va_arg(va, double);
      doafloat:
         // do kilos
         if (fl & STBSP__METRIC_SUFFIX) {
            double divisor;
            divisor = 1000.0f;
            if (fl & STBSP__METRIC_1024)
               divisor = 1024.0;
            while (fl < 0x4000000) {
               if ((fv < divisor) && (fv > -divisor))
                  break;
               fv /= divisor;
               fl += 0x1000000;
            }
         }
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))
            fl |= STBSP__NEGATIVE;
      dofloatfromg:
         tail[0] = 0;
         stbsp__lead_sign(fl, lead);
         if (dp == STBSP__SPECIAL) {
            s = (char *)sn;
            cs = 0;
            pr = 0;
            goto scopy;
         }
         s = num + 64;

         // handle the three decimal varieties
         if (dp <= 0) {
            stbsp__int32 i;
            // handle 0.000*000xxxx
            *s++ = '0';
            if (pr)
               *s++ = stbsp__period;
            n = -dp;
            if ((stbsp__int32)n > pr)
               n = pr;
            i = n;
            while (i) {
               if ((((stbsp__uintptr)s) & 3) == 0)
                  break;
               *s++ = '0';
               --i;
            }
            while (i >= 4) {
               *(stbsp__uint32 *)s = 0x30303030;
               s += 4;
               i -= 4;
            }
            while (i) {
               *s++ = '0';
               --i;
            }
            if ((stbsp__int32)(l + n) > pr)
               l = pr - n;
            i = l;
            while (i) {
               *s++ = *sn++;
               --i;
            }
            tz = pr - (n + l);
            cs = 1 + (3 << 24); // how many tens did we write (for commas below)
         } else {
            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;
            if ((stbsp__uint32)dp >= l) {
               // handle xxxx000*000.0
               n = 0;
               for (;;) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                     cs = 0;
                     *s++ = stbsp__comma;
                  } else {
                     *s++ = sn[n];
                     ++n;
                     if (n >= l)
                        break;
                  }
               }
               if (n < (stbsp__uint32)dp) {
                  n = dp - n;
                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {
                     while (n) {
                        if ((((stbsp__uintptr)s) & 3) == 0)
                           break;
                        *s++ = '0';
                        --n;
                     }
                     while (n >= 4) {
                        *(stbsp__uint32 *)s = 0x30303030;
                        s += 4;
                        n -= 4;
                     }
                  }
                  while (n) {
                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                        cs = 0;
                        *s++ = stbsp__comma;
                     } else {
                        *s++ = '0';
                        --n;
                     }
                  }
               }
               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens
               if (pr) {
                  *s++ = stbsp__period;
                  tz = pr;
               }
            } else {
               // handle xxxxx.xxxx000*000
               n = 0;
               for (;;) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                     cs = 0;
                     *s++ = stbsp__comma;
                  } else {
                     *s++ = sn[n];
                     ++n;
                     if (n >= (stbsp__uint32)dp)
                        break;
                  }
               }
               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens
               if (pr)
                  *s++ = stbsp__period;
               if ((l - dp) > (stbsp__uint32)pr)
                  l = pr + dp;
               while (n < l) {
                  *s++ = sn[n];
                  ++n;
               }
               tz = pr - (l - dp);
            }
         }
         pr = 0;

         // handle k,m,g,t
         if (fl & STBSP__METRIC_SUFFIX) {
            char idx;
            idx = 1;
            if (fl & STBSP__METRIC_NOSPACE)
               idx = 0;
            tail[0] = idx;
            tail[1] = ' ';
            {
               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.
                  if (fl & STBSP__METRIC_1024)
                     tail[idx + 1] = "_KMGT"[fl >> 24];
                  else
                     tail[idx + 1] = "_kMGT"[fl >> 24];
                  idx++;
                  // If printing kibits and not in jedec, add the 'i'.
                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {
                     tail[idx + 1] = 'i';
                     idx++;
                  }
                  tail[0] = idx;
               }
            }
         };

      flt_lead:
         // get the length that we copied
         l = (stbsp__uint32)(s - (num + 64));
         s = num + 64;
         goto scopy;
#endif

      case 'B': // upper binary
      case 'b': // lower binary
         h = (f[0] == 'B') ? hexu : hex;
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 2;
            lead[1] = '0';
            lead[2] = h[0xb];
         }
         l = (8 << 4) | (1 << 8);
         goto radixnum;

      case 'o': // octal
         h = hexu;
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 1;
            lead[1] = '0';
         }
         l = (3 << 4) | (3 << 8);
         goto radixnum;

      case 'p': // pointer
         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;
         pr = sizeof(void *) * 2;
         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros
                                    // fall through - to X

      case 'X': // upper hex
      case 'x': // lower hex
         h = (f[0] == 'X') ? hexu : hex;
         l = (4 << 4) | (4 << 8);
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 2;
            lead[1] = '0';
            lead[2] = h[16];
         }
      radixnum:
         // get the number
         if (fl & STBSP__INTMAX)
            n64 = va_arg(va, stbsp__uint64);
         else
            n64 = va_arg(va, stbsp__uint32);

         s = num + STBSP__NUMSZ;
         dp = 0;
         // clear tail, and clear leading if value is zero
         tail[0] = 0;
         if (n64 == 0) {
            lead[0] = 0;
            if (pr == 0) {
               l = 0;
               cs = 0;
               goto scopy;
            }
         }
         // convert to string
         for (;;) {
            *--s = h[n64 & ((1 << (l >> 8)) - 1)];
            n64 >>= (l >> 8);
            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))
               break;
            if (fl & STBSP__TRIPLET_COMMA) {
               ++l;
               if ((l & 15) == ((l >> 4) & 15)) {
                  l &= ~15;
                  *--s = stbsp__comma;
               }
            }
         };
         // get the tens and the comma pos
         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);
         // get the length that we copied
         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);
         // copy it
         goto scopy;

      case 'u': // unsigned
      case 'i':
      case 'd': // integer
         // get the integer and abs it
         if (fl & STBSP__INTMAX) {
            stbsp__int64 i64 = va_arg(va, stbsp__int64);
            n64 = (stbsp__uint64)i64;
            if ((f[0] != 'u') && (i64 < 0)) {
               n64 = (stbsp__uint64)-i64;
               fl |= STBSP__NEGATIVE;
            }
         } else {
            stbsp__int32 i = va_arg(va, stbsp__int32);
            n64 = (stbsp__uint32)i;
            if ((f[0] != 'u') && (i < 0)) {
               n64 = (stbsp__uint32)-i;
               fl |= STBSP__NEGATIVE;
            }
         }

#ifndef STB_SPRINTF_NOFLOAT
         if (fl & STBSP__METRIC_SUFFIX) {
            if (n64 < 1024)
               pr = 0;
            else if (pr == -1)
               pr = 1;
            fv = (double)(stbsp__int64)n64;
            goto doafloat;
         }
#endif

         // convert to string
         s = num + STBSP__NUMSZ;
         l = 0;

         for (;;) {
            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)
            char *o = s - 8;
            if (n64 >= 100000000) {
               n = (stbsp__uint32)(n64 % 100000000);
               n64 /= 100000000;
            } else {
               n = (stbsp__uint32)n64;
               n64 = 0;
            }
            if ((fl & STBSP__TRIPLET_COMMA) == 0) {
               do {
                  s -= 2;
                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];
                  n /= 100;
               } while (n);
            }
            while (n) {
               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {
                  l = 0;
                  *--s = stbsp__comma;
                  --o;
               } else {
                  *--s = (char)(n % 10) + '0';
                  n /= 10;
               }
            }
            if (n64 == 0) {
               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))
                  ++s;
               break;
            }
            while (s != o)
               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {
                  l = 0;
                  *--s = stbsp__comma;
                  --o;
               } else {
                  *--s = '0';
               }
         }

         tail[0] = 0;
         stbsp__lead_sign(fl, lead);

         // get the length that we copied
         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);
         if (l == 0) {
            *--s = '0';
            l = 1;
         }
         cs = l + (3 << 24);
         if (pr < 0)
            pr = 0;

      scopy:
         // get fw=leading/trailing space, pr=leading zeros
         if (pr < (stbsp__int32)l)
            pr = l;
         n = pr + lead[0] + tail[0] + tz;
         if (fw < (stbsp__int32)n)
            fw = n;
         fw -= n;
         pr -= l;

         // handle right justify and leading zeros
         if ((fl & STBSP__LEFTJUST) == 0) {
            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr
            {
               pr = (fw > pr) ? fw : pr;
               fw = 0;
            } else {
               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas
            }
         }

         // copy the spaces and/or zeros
         if (fw + pr) {
            stbsp__int32 i;
            stbsp__uint32 c;

            // copy leading spaces (or when doing %8.4d stuff)
            if ((fl & STBSP__LEFTJUST) == 0)
               while (fw > 0) {
                  stbsp__cb_buf_clamp(i, fw);
                  fw -= i;
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = ' ';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x20202020;
                     bf += 4;
                     i -= 4;
                  }
                  while (i) {
                     *bf++ = ' ';
                     --i;
                  }
                  stbsp__chk_cb_buf(1);
               }

            // copy leader
            sn = lead + 1;
            while (lead[0]) {
               stbsp__cb_buf_clamp(i, lead[0]);
               lead[0] -= (char)i;
               while (i) {
                  *bf++ = *sn++;
                  --i;
               }
               stbsp__chk_cb_buf(1);
            }

            // copy leading zeros
            c = cs >> 24;
            cs &= 0xffffff;
            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;
            while (pr > 0) {
               stbsp__cb_buf_clamp(i, pr);
               pr -= i;
               if ((fl & STBSP__TRIPLET_COMMA) == 0) {
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = '0';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x30303030;
                     bf += 4;
                     i -= 4;
                  }
               }
               while (i) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {
                     cs = 0;
                     *bf++ = stbsp__comma;
                  } else
                     *bf++ = '0';
                  --i;
               }
               stbsp__chk_cb_buf(1);
            }
         }

         // copy leader if there is still one
         sn = lead + 1;
         while (lead[0]) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, lead[0]);
            lead[0] -= (char)i;
            while (i) {
               *bf++ = *sn++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy the string
         n = l;
         while (n) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, n);
            n -= i;
            STBSP__UNALIGNED(while (i >= 4) {
               *(stbsp__uint32 volatile *)bf = *(stbsp__uint32 volatile *)s;
               bf += 4;
               s += 4;
               i -= 4;
            })
            while (i) {
               *bf++ = *s++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy trailing zeros
         while (tz) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, tz);
            tz -= i;
            while (i) {
               if ((((stbsp__uintptr)bf) & 3) == 0)
                  break;
               *bf++ = '0';
               --i;
            }
            while (i >= 4) {
               *(stbsp__uint32 *)bf = 0x30303030;
               bf += 4;
               i -= 4;
            }
            while (i) {
               *bf++ = '0';
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy tail if there is one
         sn = tail + 1;
         while (tail[0]) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, tail[0]);
            tail[0] -= (char)i;
            while (i) {
               *bf++ = *sn++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // handle the left justify
         if (fl & STBSP__LEFTJUST)
            if (fw > 0) {
               while (fw) {
                  stbsp__int32 i;
                  stbsp__cb_buf_clamp(i, fw);
                  fw -= i;
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = ' ';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x20202020;
                     bf += 4;
                     i -= 4;
                  }
                  while (i--)
                     *bf++ = ' ';
                  stbsp__chk_cb_buf(1);
               }
            }
         break;

      default: // unknown, just copy code
         s = num + STBSP__NUMSZ - 1;
         *s = f[0];
         l = 1;
         fw = fl = 0;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         goto scopy;
      }
      ++f;
   }
endfmt:

   if (!callback)
      *bf = 0;
   else
      stbsp__flush_cb();

done:
   return tlen + (int)(bf - buf);
}

// cleanup
#undef STBSP__LEFTJUST
#undef STBSP__LEADINGPLUS
#undef STBSP__LEADINGSPACE
#undef STBSP__LEADING_0X
#undef STBSP__LEADINGZERO
#undef STBSP__INTMAX
#undef STBSP__TRIPLET_COMMA
#undef STBSP__NEGATIVE
#undef STBSP__METRIC_SUFFIX
#undef STBSP__NUMSZ
#undef stbsp__chk_cb_bufL
#undef stbsp__chk_cb_buf
#undef stbsp__flush_cb
#undef stbsp__cb_buf_clamp

// ============================================================================
//   wrapper functions

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)
{
   int result;
   va_list va;
   va_start(va, fmt);
   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);
   va_end(va);
   return result;
}

typedef struct stbsp__context {
   char *buf;
   int count;
   int length;
   char tmp[STB_SPRINTF_MIN];
} stbsp__context;

static char *stbsp__clamp_callback(const char *buf, void *user, int len)
{
   stbsp__context *c = (stbsp__context *)user;
   c->length += len;

   if (len > c->count)
      len = c->count;

   if (len) {
      if (buf != c->buf) {
         const char *s, *se;
         char *d;
         d = c->buf;
         s = buf;
         se = buf + len;
         do {
            *d++ = *s++;
         } while (s < se);
      }
      c->buf += len;
      c->count -= len;
   }

   if (c->count <= 0)
      return c->tmp;
   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can
}

static char * stbsp__count_clamp_callback( const char * buf, void * user, int len )
{
   stbsp__context * c = (stbsp__context*)user;
   (void) sizeof(buf);

   c->length += len;
   return c->tmp; // go direct into buffer if you can
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE( vsnprintf )( char * buf, size_t count, char const * fmt, va_list va )
{
   stbsp__context c;

   if ( (count == 0) && !buf )
   {
      c.length = 0;

      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );
   }
   else
   {
      int l;

      c.buf = buf;
      c.count = count;
      c.length = 0;

      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );

      // zero-terminate
      l = (int)( c.buf - buf );
      if ( l >= count ) // should never be greater, only equal (or less) than count
         l = count - 1;
      buf[l] = 0;
   }

   return c.length;
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, size_t count, char const *fmt, ...)
{
   int result;
   va_list va;
   va_start(va, fmt);

   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);
   va_end(va);

   return result;
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)
{
   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);
}

// =======================================================================
//   low level float utility functions

#ifndef STB_SPRINTF_NOFLOAT

// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)
#define STBSP__COPYFP(dest, src)                   \
   {                                               \
      int cn;                                      \
      for (cn = 0; cn < 8; cn++)                   \
         ((char *)&dest)[cn] = ((char *)&src)[cn]; \
   }

// get float info
static stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)
{
   double d;
   stbsp__int64 b = 0;

   // load value and round at the frac_digits
   d = value;

   STBSP__COPYFP(b, d);

   *bits = b & ((((stbsp__uint64)1) << 52) - 1);
   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);

   return (stbsp__int32)((stbsp__uint64) b >> 63);
}

static double const stbsp__bot[23] = {
   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,
   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022
};
static double const stbsp__negbot[22] = {
   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,
   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022
};
static double const stbsp__negboterr[22] = {
   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,
   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,
   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,
   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039
};
static double const stbsp__top[13] = {
   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299
};
static double const stbsp__negtop[13] = {
   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299
};
static double const stbsp__toperr[13] = {
   8388608,
   6.8601809640529717e+028,
   -7.253143638152921e+052,
   -4.3377296974619174e+075,
   -1.5559416129466825e+098,
   -3.2841562489204913e+121,
   -3.7745893248228135e+144,
   -1.7356668416969134e+167,
   -3.8893577551088374e+190,
   -9.9566444326005119e+213,
   6.3641293062232429e+236,
   -5.2069140800249813e+259,
   -5.2504760255204387e+282
};
static double const stbsp__negtoperr[13] = {
   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,
   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,
   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,
   8.0970921678014997e-317
};

#if defined(_MSC_VER) && (_MSC_VER <= 1200)
static stbsp__uint64 const stbsp__powten[20] = {
   1,
   10,
   100,
   1000,
   10000,
   100000,
   1000000,
   10000000,
   100000000,
   1000000000,
   10000000000,
   100000000000,
   1000000000000,
   10000000000000,
   100000000000000,
   1000000000000000,
   10000000000000000,
   100000000000000000,
   1000000000000000000,
   10000000000000000000U
};
#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)
#else
static stbsp__uint64 const stbsp__powten[20] = {
   1,
   10,
   100,
   1000,
   10000,
   100000,
   1000000,
   10000000,
   100000000,
   1000000000,
   10000000000ULL,
   100000000000ULL,
   1000000000000ULL,
   10000000000000ULL,
   100000000000000ULL,
   1000000000000000ULL,
   10000000000000000ULL,
   100000000000000000ULL,
   1000000000000000000ULL,
   10000000000000000000ULL
};
#define stbsp__tento19th (1000000000000000000ULL)
#endif

#define stbsp__ddmulthi(oh, ol, xh, yh)                            \
   {                                                               \
      double ahi = 0, alo, bhi = 0, blo;                           \
      stbsp__int64 bt;                                             \
      oh = xh * yh;                                                \
      STBSP__COPYFP(bt, xh);                                       \
      bt &= ((~(stbsp__uint64)0) << 27);                           \
      STBSP__COPYFP(ahi, bt);                                      \
      alo = xh - ahi;                                              \
      STBSP__COPYFP(bt, yh);                                       \
      bt &= ((~(stbsp__uint64)0) << 27);                           \
      STBSP__COPYFP(bhi, bt);                                      \
      blo = yh - bhi;                                              \
      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \
   }

#define stbsp__ddtoS64(ob, xh, xl)          \
   {                                        \
      double ahi = 0, alo, vh, t;           \
      ob = (stbsp__int64)xh;                \
      vh = (double)ob;                      \
      ahi = (xh - vh);                      \
      t = (ahi - xh);                       \
      alo = (xh - (ahi - t)) - (vh + t);    \
      ob += (stbsp__int64)(ahi + alo + xl); \
   }

#define stbsp__ddrenorm(oh, ol) \
   {                            \
      double s;                 \
      s = oh + ol;              \
      ol = ol - (s - oh);       \
      oh = s;                   \
   }

#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);

#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);

static void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350
{
   double ph, pl;
   if ((power >= 0) && (power <= 22)) {
      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);
   } else {
      stbsp__int32 e, et, eb;
      double p2h, p2l;

      e = power;
      if (power < 0)
         e = -e;
      et = (e * 0x2c9) >> 14; /* %23 */
      if (et > 13)
         et = 13;
      eb = e - (et * 23);

      ph = d;
      pl = 0.0;
      if (power < 0) {
         if (eb) {
            --eb;
            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);
            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);
         }
         if (et) {
            stbsp__ddrenorm(ph, pl);
            --et;
            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);
            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);
            ph = p2h;
            pl = p2l;
         }
      } else {
         if (eb) {
            e = eb;
            if (eb > 22)
               eb = 22;
            e -= eb;
            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);
            if (e) {
               stbsp__ddrenorm(ph, pl);
               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);
               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);
               ph = p2h;
               pl = p2l;
            }
         }
         if (et) {
            stbsp__ddrenorm(ph, pl);
            --et;
            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);
            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);
            ph = p2h;
            pl = p2l;
         }
      }
   }
   stbsp__ddrenorm(ph, pl);
   *ohi = ph;
   *olo = pl;
}

// given a float value, returns the significant bits in bits, and the position of the
//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values
//   returned in the decimal_pos parameter.
// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000
static stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)
{
   double d;
   stbsp__int64 bits = 0;
   stbsp__int32 expo, e, ng, tens;

   d = value;
   STBSP__COPYFP(bits, d);
   expo = (stbsp__int32)((bits >> 52) & 2047);
   ng = (stbsp__int32)((stbsp__uint64) bits >> 63);
   if (ng)
      d = -d;

   if (expo == 2047) // is nan or inf?
   {
      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? "NaN" : "Inf";
      *decimal_pos = STBSP__SPECIAL;
      *len = 3;
      return ng;
   }

   if (expo == 0) // is zero or denormal
   {
      if (((stbsp__uint64) bits << 1) == 0) // do zero
      {
         *decimal_pos = 1;
         *start = out;
         out[0] = '0';
         *len = 1;
         return ng;
      }
      // find the right expo for denormals
      {
         stbsp__int64 v = ((stbsp__uint64)1) << 51;
         while ((bits & v) == 0) {
            --expo;
            v >>= 1;
         }
      }
   }

   // find the decimal exponent as well as the decimal bits of the value
   {
      double ph, pl;

      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046
      tens = expo - 1023;
      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);

      // move the significant bits into position and stick them into an int
      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);

      // get full as much precision from double-double as possible
      stbsp__ddtoS64(bits, ph, pl);

      // check if we undershot
      if (((stbsp__uint64)bits) >= stbsp__tento19th)
         ++tens;
   }

   // now do the rounding in integer land
   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);
   if ((frac_digits < 24)) {
      stbsp__uint32 dg = 1;
      if ((stbsp__uint64)bits >= stbsp__powten[9])
         dg = 10;
      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {
         ++dg;
         if (dg == 20)
            goto noround;
      }
      if (frac_digits < dg) {
         stbsp__uint64 r;
         // add 0.5 at the right position and round
         e = dg - frac_digits;
         if ((stbsp__uint32)e >= 24)
            goto noround;
         r = stbsp__powten[e];
         bits = bits + (r / 2);
         if ((stbsp__uint64)bits >= stbsp__powten[dg])
            ++tens;
         bits /= r;
      }
   noround:;
   }

   // kill long trailing runs of zeros
   if (bits) {
      stbsp__uint32 n;
      for (;;) {
         if (bits <= 0xffffffff)
            break;
         if (bits % 1000)
            goto donez;
         bits /= 1000;
      }
      n = (stbsp__uint32)bits;
      while ((n % 1000) == 0)
         n /= 1000;
      bits = n;
   donez:;
   }

   // convert to string
   out += 64;
   e = 0;
   for (;;) {
      stbsp__uint32 n;
      char *o = out - 8;
      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)
      if (bits >= 100000000) {
         n = (stbsp__uint32)(bits % 100000000);
         bits /= 100000000;
      } else {
         n = (stbsp__uint32)bits;
         bits = 0;
      }
      while (n) {
         out -= 2;
         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];
         n /= 100;
         e += 2;
      }
      if (bits == 0) {
         if ((e) && (out[0] == '0')) {
            ++out;
            --e;
         }
         break;
      }
      while (out != o) {
         *--out = '0';
         ++e;
      }
   }

   *decimal_pos = tens;
   *start = out;
   *len = e;
   return ng;
}

#undef stbsp__ddmulthi
#undef stbsp__ddrenorm
#undef stbsp__ddmultlo
#undef stbsp__ddmultlos
#undef STBSP__SPECIAL
#undef STBSP__COPYFP

#endif // STB_SPRINTF_NOFLOAT

// clean up
#undef stbsp__uint16
#undef stbsp__uint32
#undef stbsp__int32
#undef stbsp__uint64
#undef stbsp__int64
#undef STBSP__UNALIGNED

#endif // STB_SPRINTF_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`modpaks.cpp`:

```cpp
#include "modpaks.h"
#include <stdio.h>
#include <stdlib.h>
#include <mod/logger.h>

extern int g_nDownloadTimeout;

CURL* curl = NULL;
char szFileData[FILE_DATA_SIZE] = {0};
extern char g_szUserAgent[256];
size_t nReadedBytes = 0;

void InitCURL()
{
    curl_global_init(CURL_GLOBAL_ALL);
    curl = curl_easy_init();
}

static size_t WriteToFileCB(void* buffer, size_t size, size_t nmemb, void* userdata)
{
    FILE* file = fopen((char*)userdata, "wb");
    if(!file) return 0;
    
    size_t written = fwrite(buffer, size, nmemb, file);
    fclose(file);
    return written;
}
static size_t WriteToDataCB(void* buffer, size_t size, size_t nmemb, void* userdata)
{
    szFileData[0] = 0;
    nReadedBytes = size * nmemb;
    return snprintf(szFileData, FILE_DATA_SIZE, "%s", (const char*)buffer);
}

CURLcode DownloadFile(const char* url, const char* path)
{
    if(!curl) return CURLE_FAILED_INIT;
    curl_easy_reset(curl);
    
    // Dont delete file contents at first try
    FILE* file = fopen(path, "a");
    if(!file) return CURLE_WRITE_ERROR;
    fclose(file);
    
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // cURL fails at SSL/TLS here, for some reason
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteToFileCB);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, path);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, g_nDownloadTimeout);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, g_szUserAgent);
    
    CURLcode res = curl_easy_perform(curl);
    return res;
}

CURLcode DownloadFileToData(const char* url)
{
    if(!curl) return CURLE_FAILED_INIT;
    curl_easy_reset(curl);
    
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // cURL fails at SSL/TLS here, for some reason
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteToDataCB);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, url);
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, g_nDownloadTimeout);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, g_szUserAgent);
    
    CURLcode res = curl_easy_perform(curl);
    return res;
}

inline bool str_equal(const char* str1, const char* str2) { 
    for ( ; *str1 == *str2 && *str1 != 0; ++str1, ++str2 ) {}
        return *str2 == *str1; 
}
extern bool g_bShowUpdatedToast, g_bShowUpdateFailedToast;
static inline void ProcessLine(ModDesc* d, char* data)
{
    char left[64], middle[64], right[128];
    int scanned = sscanf(data, "%[^:]:%[^:]:%[^\n]", left, middle, right);
    if(scanned < 3) return;
    else if(!strncmp(left, "myself", 6) || !strcmp(left, d->m_pInfo->GUID()))
    {
        if(!modlist->HasModOfVersion(d->m_pInfo->GUID(), middle))
        {
            CURLcode res = DownloadFile(right, d->m_szLibPath);
            if(res == CURLE_OK)
            {
                if(g_bShowUpdatedToast) aml->ShowToast(true, "Mod %s has been updated!\nRestart the game to load new mod.", d->m_pInfo->Name());
            }
            else
            {
                if(g_bShowUpdateFailedToast) aml->ShowToast(true, "Mod %s has failed to update!\nIs this located in internal folder..?", d->m_pInfo->Name());
            }
        }
    }
    else
    {
        // files
        // 1: filepath (relative to files folder)
        // 2: checksum (MD5?)
        // 3: URL
        
        char md5[MINIMUM_MD5_BUF_SIZE] {0};
        char filepath[256], filepathTmp[256], filepathOld[256];
        snprintf(filepath, sizeof(filepath), "%s/%s", aml->GetAndroidDataPath(), left);
        snprintf(filepathOld, sizeof(filepathOld), "%s/%s.old", aml->GetAndroidDataPath(), left);
        aml->FileMD5(filepath, md5, sizeof(md5));
        
        //if(!md5[0]) return;
        
        if(md5[0] == 0 || !str_equal(md5, middle))
        {
            DownloadFile(right, filepath);
        }
    }
}
void ProcessData(ModDesc* d)
{
    if(szFileData[0] == 0) return; // bruh
    
    char* newlinePtr = &szFileData[0], *data;
    do
    {
        data = newlinePtr;
        newlinePtr = strstr(data, "\n");
        if(newlinePtr != NULL)
        {
            newlinePtr[0] = 0;
            ++newlinePtr;
        }
        if(data[0] != 0 && data[0] != '/' && data[1] != '/') ProcessLine(d, data);
        if(newlinePtr == NULL) break;
    }
    while(true);
    
    // End
    szFileData[0] = 0;
}

```

`modslist.cpp`:

```cpp
#include <modslist.h>
#include <modpaks.h>
#include <mod/logger.h>
#include <mod/listitem.h>

extern ModDesc* pLastModProcessed;

Mods* listMods = NULL;
LIST_START(Mods)

    LIST_INITSTART(Mods)
        pModInfo = NULL;
        pModDesc = NULL;
        pHandle = NULL;
    LIST_INITEND()

    static void AddNew(ModInfo* info, void* libhandle, const char* path)
    {
        Mods* newItem = new Mods;
        newItem->pModInfo = info;
        newItem->pHandle = libhandle;

        ModDesc* d = new ModDesc();
        d->m_pInfo = info;
        d->m_pHandle = libhandle;
        d->m_aDependencies = NULL;
        if(path) snprintf(d->m_szLibPath, 256, "%s", path);
        else d->m_szLibPath[0] = 0;
        if(libhandle != NULL)
        {
            GetDependenciesListFn getDepList = (GetDependenciesListFn)dlsym(libhandle, "__GetDepsList");
            if(getDepList != NULL) d->m_aDependencies = getDepList();
        }
        newItem->pModDesc = d;
        
        newItem->Push(&listMods);
    }
    static Mods* Get(const char* guid)
    {
        LIST_FOR_FAST(listMods)
        {
            if (!strcmp(item->pModInfo->szGUID, guid)) return item;
        }
        return NULL;
    }

    ModInfo* pModInfo;
    ModDesc* pModDesc;
    void* pHandle;
LIST_END()

bool ModsList::AddMod(ModInfo* modinfo, void* modhandle, const char* path)
{
    if(Mods::Get(modinfo->szGUID) != NULL) return false;
    Mods::AddNew(modinfo, modhandle, path);
    return true;
}

bool ModsList::RemoveMod(ModInfo* modinfo)
{
    LIST_FOR(listMods)
    {
        if(item->pModInfo == modinfo)
        {
            dlclose(item->pHandle);
            if(item->Remove(&listMods))
            {
                delete item->pModDesc;
                delete item;
            }
            return true;
        }
    }
    return false;
}

bool ModsList::RemoveMod(const char* szGUID)
{
    LIST_FOR(listMods)
    {
        if(!strcmp(item->pModInfo->szGUID, szGUID))
        {
            dlclose(item->pHandle);
            if(item->Remove(&listMods))
            {
                delete item->pModDesc;
                delete item;
            }
            return true;
        }
    }
    return false;
}

bool ModsList::HasMod(const char* szGUID)
{
    LIST_FOR_FAST(listMods)
    {
        if(!strcmp(item->pModInfo->szGUID, szGUID))
        {
            return true;
        }
    }
    return false;
}

bool ModsList::HasModOfVersion(const char* szGUID, const char* szVersion)
{
    if(szVersion[0] == '\0') return HasMod(szGUID);
    unsigned short major, minor, revision, build;
    if(sscanf(szVersion, "%hu.%hu.%hu.%hu", &major, &minor, &revision, &build) < 4)
    {
        if(sscanf(szVersion, "%hu.%hu.%hu", &major, &minor, &revision) < 3)
        {
            if(sscanf(szVersion, "%hu.%hu", &major, &minor) < 2)
            {
                major = (unsigned short)atoi(szVersion);
            }
            revision = 0;
        }
        build = 0;
    }

    ModInfo* pInfo = NULL;
    LIST_FOR_FAST(listMods)
    {
        pInfo = item->pModInfo;
        if(!strcmp(pInfo->szGUID, szGUID))
        {
            if(pInfo->version.major > major) return true;
            if(pInfo->version.major == major)
            {
                if(pInfo->version.minor > minor) return true;
                if(pInfo->version.minor == minor)
                {
                    if(pInfo->version.revision > revision) return true;
                    if(pInfo->version.revision == revision && pInfo->version.build >= build) return true;
                }
            }
            return false;
        }
    }
    return false;
}

bool ModsList::HasModOfBiggerVersion(const char* szGUID, const char* szVersion)
{
    if(szVersion[0] == '\0') return HasMod(szGUID);
    unsigned short major, minor, revision, build;
    if(sscanf(szVersion, "%hu.%hu.%hu.%hu", &major, &minor, &revision, &build) < 4)
    {
        if(sscanf(szVersion, "%hu.%hu.%hu", &major, &minor, &revision) < 3)
        {
            if(sscanf(szVersion, "%hu.%hu", &major, &minor) < 2)
            {
                major = (unsigned short)atoi(szVersion);
            }
            revision = 0;
        }
        build = 0;
    }

    ModInfo* pInfo = NULL;
    LIST_FOR_FAST(listMods)
    {
        pInfo = item->pModInfo;
        if(!strcmp(pInfo->szGUID, szGUID))
        {
            if(pInfo->version.major > major) return true;
            if(pInfo->version.major == major)
            {
                if(pInfo->version.minor > minor) return true;
                if(pInfo->version.minor == minor)
                {
                    if(pInfo->version.revision > revision) return true;
                    if(pInfo->version.revision == revision && pInfo->version.build > build) return true;
                }
            }
            return false;
        }
    }
    return false;
}

void ModsList::ProcessDependencies()
{
    ModInfoDependency* depList;
    ModInfo* info;

  label_run_dependencies_check:
    //logger->Info("Checking dependencies from the start! Mods count: %d", modlist->GetModsNum());
    LIST_FOR_FAST(listMods)
    {
        // If the mod is already ok or doesnt require check, depList = NULL
        depList = item->pModDesc->m_aDependencies;
        if(depList)
        {
            info = item->pModInfo;
            for(int i = 0; depList[i].szGUID && depList[i].szGUID[0] != 0; ++i)
            {
                if(depList[i].szVersion)
                {
                    if(!HasModOfVersion(depList[i].szGUID, depList[i].szVersion))
                    {
                        logger->Error("Mod (GUID %s) requires a mod %s of version %s and newer", info->szGUID, depList[i].szGUID, depList[i].szVersion);
                        ModsList::RemoveMod(info);
                        goto label_run_dependencies_check;
                    }
                }
                else
                {
                    if(!HasMod(depList[i].szGUID))
                    {
                        logger->Error("Mod (GUID %s) requires a mod %s of any version", info->szGUID, depList[i].szGUID);
                        ModsList::RemoveMod(info);
                        goto label_run_dependencies_check;
                    }
                }
            }

            // Everything is okay, we dont need to check it again!
            item->pModDesc->m_aDependencies = NULL;
        }
    }
}

void ModsList::ProcessPreLoading()
{
    OnModLoadFn onModPreLoadFn;
    ModDesc* desc;
    void* handle;
    LIST_FOR_FAST(listMods)
    {
        handle = item->pHandle;
        if(handle != NULL)
        {
            desc = item->pModDesc;
            pLastModProcessed = desc;

            onModPreLoadFn = (OnModLoadFn)dlsym(handle, "OnModPreLoad");
            //if(onModPreLoadFn == NULL) onModPreLoadFn = (OnModLoadFn)dlsym(handle, "_Z12OnModPreLoadv");
            if(onModPreLoadFn != NULL) onModPreLoadFn();

            desc->m_fnOnModLoaded = (OnModLoadFn)dlsym(handle, "OnModLoad");
            //if(desc->m_fnOnModLoaded == NULL) desc->m_fnOnModLoaded = (OnModLoadFn)dlsym(handle, "_Z9OnModLoadv");

            desc->m_fnOnModUnloaded = (OnModLoadFn)dlsym(handle, "OnModUnload");
            //if(desc->m_fnOnModUnloaded == NULL) desc->m_fnOnModUnloaded = (OnModLoadFn)dlsym(handle, "_Z11OnModUnloadv");

            desc->m_fnRequestUpdaterURL = (GetUpdaterURLFn)dlsym(handle, "OnUpdaterURLRequested");
            //if(desc->m_fnRequestUpdaterURL == NULL) desc->m_fnRequestUpdaterURL = (GetUpdaterURLFn)dlsym(handle, "_Z21OnUpdaterURLRequestedv");

            desc->m_fnInterfaceAddedCB = (OnInterfaceAddedFn)dlsym(handle, "OnInterfaceAdded");
            //if(desc->m_fnInterfaceAddedCB == NULL) desc->m_fnInterfaceAddedCB = (OnInterfaceAddedFn)dlsym(handle, "_Z16OnInterfaceAddedPKcPKv");

            desc->m_fnOnAllModsLoaded = (OnModLoadFn)dlsym(handle, "OnAllModsLoaded");
            //if(desc->m_fnOnAllModsLoaded == NULL) desc->m_fnOnAllModsLoaded = (OnModLoadFn)dlsym(handle, "_Z15OnAllModsLoadedv");

            desc->m_fnGameCrashedCB = (OnGameCrashedFn)dlsym(handle, "OnGameCrash");
            //if(desc->m_fnGameCrashedCB == NULL) desc->m_fnGameCrashedCB = (OnGameCrashedFn)dlsym(handle, "_Z11OnGameCrashv");
        }
    }
    logger->Info("Mods were preloaded!");
}

void ModsList::ProcessLoading()
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnOnModLoaded) desc->m_fnOnModLoaded();
    }
    logger->Info("Mods were loaded!");
}

void ModsList::ProcessUnloading()
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnOnModUnloaded) desc->m_fnOnModUnloaded();
    }
}

void ModsList::ProcessUpdater()
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnRequestUpdaterURL)
        {
            const char* url = desc->m_fnRequestUpdaterURL();
            CURLcode res = DownloadFileToData(url);
            if(res != CURLE_OK)
            {
                logger->Error("Updater failed to determine an update info for %s, err %d", desc->m_pInfo->GUID(), res);
            }
            else
            {
                ProcessData(desc);
            }
        }
    }
}

void ModsList::ProcessCrash(const char* szLibName, int sig, int code, uintptr_t libaddr, mcontext_t* mcontext)
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnGameCrashedCB) desc->m_fnGameCrashedCB(szLibName, sig, code, libaddr, mcontext);
    }
}

int ModsList::GetModsNum()
{
    return listMods->Count();
}

void ModsList::PrintModsList(std::ofstream& logfile)
{
    logfile << "\n----------------------------------------------------\nList of loaded mods (count=" << std::dec << listMods->Count() << "):\n";

    ModInfo* info = NULL;
    ModDesc* desc = NULL;
    LIST_FOR_REVERSE_FAST(listMods)
    {
        info = item->pModInfo;
        desc = item->pModDesc;
        
        logfile << info->Name() << " (" << info->Author() << ", version " << info->VersionString() << ")\n";
        logfile << " - GUID: " << info->GUID() << " | Base: 0x" << std::hex << std::uppercase << (uintptr_t)desc->m_pHandle << " | Path: " << desc->m_szLibPath << "\n";
    }
}

void ModsList::OnInterfaceAdded(const char* name, const void* ptr)
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnInterfaceAddedCB) desc->m_fnInterfaceAddedCB(name, ptr);
    }
}

void ModsList::OnAllModsLoaded()
{
    ModDesc* desc = NULL;
    LIST_FOR_FAST(listMods)
    {
        desc = item->pModDesc;
        pLastModProcessed = desc;
        if(desc->m_fnOnAllModsLoaded) desc->m_fnOnAllModsLoaded();
    }
    logger->Info("Mods were postloaded!");
}

static ModsList modlistLocal;
ModsList* modlist = &modlistLocal;
```

`news.txt`:

```txt
We are getting SDK for mods! Now everyone can start their own mod!

```

`signal.cpp`:

```cpp
#include <mod/logger.h>
#include <modslist.h>
#include <fstream>
#include <unistd.h>
#include <dlfcn.h>
#include <aml.h>
#include <jnifn.h>
#include <cxxabi.h> // char* demangled = abi::__cxa_demangle(mangled, nullptr, nullptr, &status); free(demangled);
#include "xunwind.h"

// execinfo.h
typedef int (*backtrace_fn)(void**, int);
typedef char** (*backtrace_symbols_fn)(void* const*, int);

#define STACKDUMP_SIZE 0x510
std::ofstream g_pLogFile;

struct sigaction newSigaction[7];
struct sigaction oldSigaction[7];
extern bool g_bSimplerCrashLog, g_bNoSPInLog, g_bNoModsInLog, g_bDumpAllThreads, g_bEHUnwind, g_bMoreRegsInfo, g_bUnixBacktrace;
extern int g_nAndroidSDKVersion;

static stack_t stackstruct;
static char signalstack[SIGSTKSZ];
static uintptr_t g_frames[128];
static void* btBuffer[64];

extern jobject appContext;
extern JNIEnv* env;

ModDesc* pLastModProcessed = NULL;

int SignalInnerId(int code)
{
    switch(code)
    {
        case SIGABRT:   return 0;
        case SIGBUS:    return 1;
        case SIGFPE:    return 2;
        case SIGSEGV:   return 3;
        case SIGILL:    return 4;
        case SIGSTKFLT: return 5;
        case SIGTRAP:   return 6;
    }
    return -1;
}

#define ENUMERATE_THIS(_me) case _me: return #_me
const char* SignalEnum(int sig)
{
    switch(sig)
    {
        ENUMERATE_THIS(SIGABRT);
        ENUMERATE_THIS(SIGBUS);
        ENUMERATE_THIS(SIGFPE);
        ENUMERATE_THIS(SIGSEGV);
        ENUMERATE_THIS(SIGILL);
        ENUMERATE_THIS(SIGSTKFLT);
        ENUMERATE_THIS(SIGTRAP);
    }
    return "UNKNOWN";
}

const char* CodeEnum(int sig, int code)
{
    switch(code)
    {
        ENUMERATE_THIS(SI_USER);
        ENUMERATE_THIS(SI_QUEUE);
        ENUMERATE_THIS(SI_TIMER);
        ENUMERATE_THIS(SI_ASYNCIO);
        ENUMERATE_THIS(SI_MESGQ);
        default:         break;
    }
    switch(sig)
    {
        case SIGILL:
        {
            switch(code)
            {
                ENUMERATE_THIS(ILL_ILLOPC);
                ENUMERATE_THIS(ILL_ILLOPN);
                ENUMERATE_THIS(ILL_ILLADR);
                ENUMERATE_THIS(ILL_ILLTRP);
                ENUMERATE_THIS(ILL_PRVOPC);
                ENUMERATE_THIS(ILL_PRVREG);
                ENUMERATE_THIS(ILL_COPROC);
                ENUMERATE_THIS(ILL_BADSTK);
            }
        }
        case SIGFPE:
        {
            switch(code)
            {
                ENUMERATE_THIS(FPE_INTDIV);
                ENUMERATE_THIS(FPE_INTOVF);
                ENUMERATE_THIS(FPE_FLTDIV);
                ENUMERATE_THIS(FPE_FLTOVF);
                ENUMERATE_THIS(FPE_FLTUND);
                ENUMERATE_THIS(FPE_FLTRES);
                ENUMERATE_THIS(FPE_FLTINV);
                ENUMERATE_THIS(FPE_FLTSUB);
            }
        }
        case SIGSEGV:
        {
            switch(code)
            {
                ENUMERATE_THIS(SEGV_MAPERR);
                ENUMERATE_THIS(SEGV_ACCERR);
            }
        }
        case SIGBUS:
        {
            switch(code)
            {
                ENUMERATE_THIS(BUS_ADRALN);
                ENUMERATE_THIS(BUS_ADRERR);
                ENUMERATE_THIS(BUS_OBJERR);

                #ifdef BUS_MCEEFF_AO
                    ENUMERATE_THIS(BUS_MCEEFF_AO);
                #endif
                #ifdef BUS_MCEERR_AR
                    ENUMERATE_THIS(BUS_MCEERR_AR);
                #endif
            }
        }
        case SIGTRAP:
        {
            switch(code)
            {
                ENUMERATE_THIS(TRAP_BRKPT);
                ENUMERATE_THIS(TRAP_TRACE);
                #ifdef TRAP_BRANCH
                    ENUMERATE_THIS(TRAP_BRANCH);
                #endif
                #ifdef TRAP_HWBKPT
                    ENUMERATE_THIS(TRAP_HWBKPT);
                #endif
            }
        }
        case SIGCHLD:
        {
            switch(code)
            {
                ENUMERATE_THIS(CLD_EXITED);
                ENUMERATE_THIS(CLD_KILLED);
                ENUMERATE_THIS(CLD_DUMPED);
                ENUMERATE_THIS(CLD_TRAPPED);
                ENUMERATE_THIS(CLD_STOPPED);
                ENUMERATE_THIS(CLD_CONTINUED);
            }
        }
#ifdef SIGPOLL
        case SIGPOLL:
        {
            switch(code)
            {
                ENUMERATE_THIS(POLL_IN);
                ENUMERATE_THIS(POLL_OUT);
                ENUMERATE_THIS(POLL_MSG);
                ENUMERATE_THIS(POLL_ERR);
                ENUMERATE_THIS(POLL_PRI);
                ENUMERATE_THIS(POLL_HUP);
            }
        }
#endif
    }
    return "UNKNOWN";
}

inline const char* GetFilenamePart(const char* path)
{
    int idx = 0;
    for(int i = 0; path[i] != 0; ++i)
    {
        if((path[i] == '/' || path[i] == '\\') &&
           (path[i + 1] != '/' && path[i + 1] != '\\'))
        {
            idx = i + 1;
        }
    }
    return &path[idx];
}

bool bHasHandledError = false;
void Handler(int sig, siginfo_t *si, void *ptr)
{
    if(bHasHandledError)
    {
        exit(0);
        return;
    }
    bHasHandledError = true;

    void* libC = dlopen("libc.so", RTLD_NOW | RTLD_GLOBAL);

    char *stack;
    ucontext_t* ucontext = (ucontext_t*)ptr;
    mcontext_t* mcontext = &ucontext->uc_mcontext;
    
    #ifdef AML32
        uintptr_t PC = mcontext->arm_pc;
    #else
        uintptr_t PC = mcontext->pc;
    #endif
    uintptr_t faultAddr = mcontext->fault_address; // == si->si_addr?

    char path[320], pathText[512];
    sprintf(path, "%s/aml_crashlog.txt", aml->GetAndroidDataRootPath());
    sprintf(pathText, "Application has been crashed!\n\nCrashlog should be saved in %s", path);
    logger->Error("Exception Signal %d - %s (%s)", sig, SignalEnum(sig), CodeEnum(sig, si->si_code));
    logger->Error(pathText);
    g_pLogFile.open(path, std::ios::out | std::ios::trunc);


    char* stackLog;
    if(!g_pLogFile.is_open()) goto skip_logging;

    g_pLogFile << "!!! THIS IS A CRASH LOG !!!\nIf you are experiencing a crash, give us this file.\n>>> DO NOT SEND US A SCREENSHOT OF THIS FILE <<<" << std::endl << std::endl;

    #define DEVVAR_LOG(__v) g_pLogFile << #__v << (__v ? " = 1 | " : " = 0 | ")
    g_pLogFile << "Config variables: | "; DEVVAR_LOG(g_bSimplerCrashLog); DEVVAR_LOG(g_bNoSPInLog);
    DEVVAR_LOG(g_bNoModsInLog); DEVVAR_LOG(g_bDumpAllThreads); DEVVAR_LOG(g_bEHUnwind); DEVVAR_LOG(g_bMoreRegsInfo); DEVVAR_LOG(g_bUnixBacktrace); g_pLogFile << std::endl;

    g_pLogFile << "Exception Signal " << sig << " - " << SignalEnum(sig) << " (" << CodeEnum(sig, si->si_code) << ")" << std::endl;
    g_pLogFile << "Fault address: 0x" << std::hex << std::uppercase << faultAddr << " (0x" << (uintptr_t)si->si_addr << ") at 0x" << PC << std::nouppercase << std::endl;
    g_pLogFile << "A POSSIBLE (!) reason of the crash:\n- ";
    switch(sig)
    {
    case SIGABRT:
        g_pLogFile << "Probably the game is closed by something (Android`s Low Memory Killer?)" << std::endl;
        break;
    case SIGBUS:
        g_pLogFile << "Not enough memory, or invalid execution address, or a bad mod patch" << std::endl;
        break;
    case SIGFPE:
        g_pLogFile << "An error somewhere in the code, often - dividing by zero" << std::endl;
        break;
    case SIGSEGV:
        g_pLogFile << "An application tried to access the memory address that is unaccessible, protected or just wrong" << std::endl;
        break;
    case SIGILL:
        g_pLogFile << "Corrupted application stack, wrong call address or no privileges to do something" << std::endl;
        break;
    case SIGSTKFLT:
        g_pLogFile << "Stack fault on coprocessor" << std::endl;
        break;
    case SIGTRAP:
        g_pLogFile << "It`s a trap! Somewhere in the game was called a function to FORCE CLOSE the game" << std::endl;
        break;
    }

    static Dl_info dlInfo;
    if(PC && dladdr((void*)PC, &dlInfo) != 0)
    {
        // Success
        if(dlInfo.dli_fname)
        {
            g_pLogFile << "Library base: 0x" << std::hex << std::uppercase << (uintptr_t)dlInfo.dli_fbase << std::endl;
            g_pLogFile << GetFilenamePart(dlInfo.dli_fname) << " + 0x" << std::hex << std::uppercase << (PC - (uintptr_t)dlInfo.dli_fbase);
        }
        else
        {
            if(!dlInfo.dli_fbase) goto label_unsuccess;
            g_pLogFile << "Library base: 0x" << std::hex << std::uppercase << (uintptr_t)dlInfo.dli_fbase << std::endl;
            g_pLogFile << "Program counter: Unknown Lib + 0x" << std::hex << std::uppercase << (PC - (uintptr_t)dlInfo.dli_fbase);
        }
    }
    else
    {
        // Unsuccess
      label_unsuccess:
        g_pLogFile << "Failed to get a library. Program counter: 0x" << std::hex << std::uppercase << PC;
    }

    if(dlInfo.dli_sname)
    {
        g_pLogFile << std::nouppercase << " (" << dlInfo.dli_sname << ")" << std::endl;
    }
    else
    {
        g_pLogFile << std::endl;
    }
    g_pLogFile.flush();

    char sysprop_str[92];
    g_pLogFile << "\n----------------------------------------------------\nShort device info:" << std::endl;
    g_pLogFile << "Android SDK Version: " << std::dec << g_nAndroidSDKVersion << std::endl;
    if(__system_property_get("ro.product.brand", sysprop_str) || __system_property_get("ro.product.system.brand", sysprop_str))
    {
        g_pLogFile.flush();
        g_pLogFile << "Brand: " << sysprop_str << std::endl;
    }
    if(__system_property_get("ro.product.device", sysprop_str) || __system_property_get("ro.product.system.device", sysprop_str))
    {
        g_pLogFile.flush();
        g_pLogFile << "Device: " << sysprop_str << std::endl;
    }
    if(__system_property_get("ro.system.product.cpu.abilist", sysprop_str))
    {
        g_pLogFile.flush();
        g_pLogFile << "Supported ABIs: " << sysprop_str;
        if(strstr(sysprop_str, "86") != NULL) g_pLogFile << " (it looks like you`re on emulator?)";
        g_pLogFile << std::endl;
    }
    if(__system_property_get("ro.build.date", sysprop_str))
    {
        g_pLogFile.flush();
        g_pLogFile << "OS Build Date: " << sysprop_str << std::endl;
    }
    if(__system_property_get("ro.build.id", sysprop_str) || __system_property_get("ro.system.build.id", sysprop_str))
    {
        g_pLogFile.flush();
        g_pLogFile << "OS Build ID: " << sysprop_str << std::endl;
    }
    g_pLogFile.flush();


    g_pLogFile << "\n----------------------------------------------------\nRegisters:" << std::endl;

    // dlInfo.dli_sname in register might point to the variable with corrupted name
    #define SHOWREG(__t, __v)   g_pLogFile << #__t ":\t" << std::dec << __v << "\t0x" << std::hex << std::uppercase << __v; \
                                if((void*)(__v) && dladdr((void*)(__v), &dlRegInfo) != 0 && dlRegInfo.dli_fname) { \
                                    g_pLogFile << " (" << GetFilenamePart(dlRegInfo.dli_fname) << " + 0x" << std::hex << std::uppercase << ((uintptr_t)(__v) - (uintptr_t)dlRegInfo.dli_fbase) << ")"; \
                                    /*if(dlRegInfo.dli_sname) { g_pLogFile << std::nouppercase << " (" << dlInfo.dli_sname << ")"; }*/ \
                                } g_pLogFile << std::endl

                                
    #ifdef AML32
        if(g_bMoreRegsInfo)
        {
            static Dl_info dlRegInfo;
            SHOWREG(R0, mcontext->arm_r0);
            SHOWREG(R1, mcontext->arm_r1);
            SHOWREG(R2, mcontext->arm_r2);
            SHOWREG(R3, mcontext->arm_r3);
            SHOWREG(R4, mcontext->arm_r4);
            SHOWREG(R5, mcontext->arm_r5);
            SHOWREG(R6, mcontext->arm_r6);
            SHOWREG(R7, mcontext->arm_r7);
            SHOWREG(R8, mcontext->arm_r8);
            SHOWREG(R9, mcontext->arm_r9);
            SHOWREG(R10, mcontext->arm_r10);
            SHOWREG(R11, mcontext->arm_fp);
            SHOWREG(R12, mcontext->arm_ip);
            SHOWREG(SP, mcontext->arm_sp);
            SHOWREG(LR, mcontext->arm_lr);
            SHOWREG(PC, mcontext->arm_pc);
            SHOWREG(CPSR, mcontext->arm_cpsr);
        }
        else
        {
            g_pLogFile << "R0:   " << std::dec << mcontext->arm_r0 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r0   << std::endl;
            g_pLogFile << "R1:   " << std::dec << mcontext->arm_r1 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r1   << std::endl;
            g_pLogFile << "R2:   " << std::dec << mcontext->arm_r2 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r2   << std::endl;
            g_pLogFile << "R3:   " << std::dec << mcontext->arm_r3 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r3   << std::endl;
            g_pLogFile << "R4:   " << std::dec << mcontext->arm_r4 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r4   << std::endl;
            g_pLogFile << "R5:   " << std::dec << mcontext->arm_r5 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r5   << std::endl;
            g_pLogFile << "R6:   " << std::dec << mcontext->arm_r6 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r6   << std::endl;
            g_pLogFile << "R7:   " << std::dec << mcontext->arm_r7 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r7   << std::endl;
            g_pLogFile << "R8:   " << std::dec << mcontext->arm_r8 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r8   << std::endl;
            g_pLogFile << "R9:   " << std::dec << mcontext->arm_r9 <<   " 0x" << std::hex << std::uppercase << mcontext->arm_r9   << std::endl;
            g_pLogFile << "R10:  " << std::dec << mcontext->arm_r10 <<  " 0x" << std::hex << std::uppercase << mcontext->arm_r10  << std::endl;
            g_pLogFile << "R11:  " << std::dec << mcontext->arm_fp <<   " 0x" << std::hex << std::uppercase << mcontext->arm_fp   << std::endl;
            g_pLogFile << "R12:  " << std::dec << mcontext->arm_ip <<   " 0x" << std::hex << std::uppercase << mcontext->arm_ip   << std::endl;
            g_pLogFile << "SP:   " << std::dec << mcontext->arm_sp <<   " 0x" << std::hex << std::uppercase << mcontext->arm_sp   << std::endl;
            g_pLogFile << "LR:   " << std::dec << mcontext->arm_lr <<   " 0x" << std::hex << std::uppercase << mcontext->arm_lr   << std::endl;
            g_pLogFile << "PC:   " << std::dec << mcontext->arm_pc <<   " 0x" << std::hex << std::uppercase << mcontext->arm_pc   << std::endl;
            g_pLogFile << "CPSR: " << std::dec << mcontext->arm_cpsr << " 0x" << std::hex << std::uppercase << mcontext->arm_cpsr << std::endl;
        }
    #else
        if(g_bMoreRegsInfo)
        {
            static Dl_info dlRegInfo;
            SHOWREG(X0, mcontext->regs[0]);
            SHOWREG(X1, mcontext->regs[1]);
            SHOWREG(X2, mcontext->regs[2]);
            SHOWREG(X3, mcontext->regs[3]);
            SHOWREG(X4, mcontext->regs[4]);
            SHOWREG(X5, mcontext->regs[5]);
            SHOWREG(X6, mcontext->regs[6]);
            SHOWREG(X7, mcontext->regs[7]);
            SHOWREG(X8, mcontext->regs[8]);
            SHOWREG(X9, mcontext->regs[9]);
            SHOWREG(X10, mcontext->regs[10]);
            SHOWREG(X11, mcontext->regs[11]);
            SHOWREG(X12, mcontext->regs[12]);
            SHOWREG(X13, mcontext->regs[13]);
            SHOWREG(X14, mcontext->regs[14]);
            SHOWREG(X15, mcontext->regs[15]);
            SHOWREG(X16, mcontext->regs[16]);
            SHOWREG(X17, mcontext->regs[17]);
            SHOWREG(X18, mcontext->regs[18]);
            SHOWREG(X19, mcontext->regs[19]);
            SHOWREG(X20, mcontext->regs[20]);
            SHOWREG(X21, mcontext->regs[21]);
            SHOWREG(X22, mcontext->regs[22]);
            SHOWREG(X23, mcontext->regs[23]);
            SHOWREG(X24, mcontext->regs[24]);
            SHOWREG(X25, mcontext->regs[25]);
            SHOWREG(X26, mcontext->regs[26]);
            SHOWREG(X27, mcontext->regs[27]);
            SHOWREG(X28, mcontext->regs[28]);
            SHOWREG(X29, mcontext->regs[29]);
            SHOWREG(X30, mcontext->regs[30]);
            SHOWREG(SP, mcontext->sp);
            SHOWREG(PC, mcontext->pc);
            SHOWREG(CPSR, mcontext->pstate);
        }
        else
        {
            g_pLogFile << "X0:   " << std::dec << mcontext->regs[0] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[0]  << std::endl;
            g_pLogFile << "X1:   " << std::dec << mcontext->regs[1] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[1]  << std::endl;
            g_pLogFile << "X2:   " << std::dec << mcontext->regs[2] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[2]  << std::endl;
            g_pLogFile << "X3:   " << std::dec << mcontext->regs[3] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[3]  << std::endl;
            g_pLogFile << "X4:   " << std::dec << mcontext->regs[4] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[4]  << std::endl;
            g_pLogFile << "X5:   " << std::dec << mcontext->regs[5] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[5]  << std::endl;
            g_pLogFile << "X6:   " << std::dec << mcontext->regs[6] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[6]  << std::endl;
            g_pLogFile << "X7:   " << std::dec << mcontext->regs[7] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[7]  << std::endl;
            g_pLogFile << "X8:   " << std::dec << mcontext->regs[8] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[8]  << std::endl;
            g_pLogFile << "X9:   " << std::dec << mcontext->regs[9] <<  " 0x" << std::hex << std::uppercase << mcontext->regs[9]  << std::endl;
            g_pLogFile << "X10:  " << std::dec << mcontext->regs[10] << " 0x" << std::hex << std::uppercase << mcontext->regs[10] << std::endl;
            g_pLogFile << "X11:  " << std::dec << mcontext->regs[11] << " 0x" << std::hex << std::uppercase << mcontext->regs[11] << std::endl;
            g_pLogFile << "X12:  " << std::dec << mcontext->regs[12] << " 0x" << std::hex << std::uppercase << mcontext->regs[12] << std::endl;
            g_pLogFile << "X13:  " << std::dec << mcontext->regs[13] << " 0x" << std::hex << std::uppercase << mcontext->regs[13] << std::endl;
            g_pLogFile << "X14:  " << std::dec << mcontext->regs[14] << " 0x" << std::hex << std::uppercase << mcontext->regs[14] << std::endl;
            g_pLogFile << "X15:  " << std::dec << mcontext->regs[15] << " 0x" << std::hex << std::uppercase << mcontext->regs[15] << std::endl;
            g_pLogFile << "X16:  " << std::dec << mcontext->regs[16] << " 0x" << std::hex << std::uppercase << mcontext->regs[16] << std::endl;
            g_pLogFile << "X17:  " << std::dec << mcontext->regs[17] << " 0x" << std::hex << std::uppercase << mcontext->regs[17] << std::endl;
            g_pLogFile << "X18:  " << std::dec << mcontext->regs[18] << " 0x" << std::hex << std::uppercase << mcontext->regs[18] << std::endl;
            g_pLogFile << "X19:  " << std::dec << mcontext->regs[19] << " 0x" << std::hex << std::uppercase << mcontext->regs[19] << std::endl;
            g_pLogFile << "X20:  " << std::dec << mcontext->regs[20] << " 0x" << std::hex << std::uppercase << mcontext->regs[20] << std::endl;
            g_pLogFile << "X21:  " << std::dec << mcontext->regs[21] << " 0x" << std::hex << std::uppercase << mcontext->regs[21] << std::endl;
            g_pLogFile << "X22:  " << std::dec << mcontext->regs[22] << " 0x" << std::hex << std::uppercase << mcontext->regs[22] << std::endl;
            g_pLogFile << "X23:  " << std::dec << mcontext->regs[23] << " 0x" << std::hex << std::uppercase << mcontext->regs[23] << std::endl;
            g_pLogFile << "X24:  " << std::dec << mcontext->regs[24] << " 0x" << std::hex << std::uppercase << mcontext->regs[24] << std::endl;
            g_pLogFile << "X25:  " << std::dec << mcontext->regs[25] << " 0x" << std::hex << std::uppercase << mcontext->regs[25] << std::endl;
            g_pLogFile << "X26:  " << std::dec << mcontext->regs[26] << " 0x" << std::hex << std::uppercase << mcontext->regs[26] << std::endl;
            g_pLogFile << "X27:  " << std::dec << mcontext->regs[27] << " 0x" << std::hex << std::uppercase << mcontext->regs[27] << std::endl;
            g_pLogFile << "X28:  " << std::dec << mcontext->regs[28] << " 0x" << std::hex << std::uppercase << mcontext->regs[28] << std::endl;
            g_pLogFile << "X29:  " << std::dec << mcontext->regs[29] << " 0x" << std::hex << std::uppercase << mcontext->regs[29] << std::endl;
            g_pLogFile << "X30:  " << std::dec << mcontext->regs[30] << " 0x" << std::hex << std::uppercase << mcontext->regs[30] << std::endl;
            g_pLogFile << "SP:   " << std::dec << mcontext->sp <<       " 0x" << std::hex << std::uppercase << mcontext->sp       << std::endl;
            g_pLogFile << "PC:   " << std::dec << mcontext->pc <<       " 0x" << std::hex << std::uppercase << mcontext->pc       << std::endl;
            g_pLogFile << "CPSR: " << std::dec << mcontext->pstate <<   " 0x" << std::hex << std::uppercase << mcontext->pstate   << std::endl;
        }
    #endif
    g_pLogFile.flush();

    if(!g_bNoModsInLog)
    {
        modlist->PrintModsList(g_pLogFile);
        g_pLogFile.flush();
    }

    if(pLastModProcessed)
    {
        g_pLogFile << "\n----------------------------------------------------\nLatest mod processed:\n";
        g_pLogFile << pLastModProcessed->m_pInfo->Name() << " (" << pLastModProcessed->m_pInfo->Author() << ", version " << pLastModProcessed->m_pInfo->VersionString() << ")\n";
        g_pLogFile << " - GUID: " << pLastModProcessed->m_pInfo->GUID() << " | Base: 0x" << std::hex << std::uppercase << (uintptr_t)pLastModProcessed->m_pHandle << " | Path: " << pLastModProcessed->m_szLibPath << "\n";
        g_pLogFile.flush();
    }

    #ifdef AML32
        stack = (char*)mcontext->arm_sp;
    #else
        stack = (char*)mcontext->sp;
    #endif

    if(!g_bNoSPInLog && stack)
    {
        g_pLogFile << "\n----------------------------------------------------\nPrinting " << std::dec << STACKDUMP_SIZE << " bytes of stack:" << std::endl;
        g_pLogFile << std::hex << std::uppercase;
        g_pLogFile.flush();
        for(int i = 1; i <= STACKDUMP_SIZE; ++i)
        {
            g_pLogFile << " " << std::setfill('0') << std::setw(2) << (int)(stack[i - 1]);
            if(i % 16 == 0)
            {
                g_pLogFile << " (SP+0x" << std::setfill('0') << std::setw(3) << 16 * ((i / 16) - 1) << ") [";
                int endv = i;
                for(int j = i-16; j < endv && j < STACKDUMP_SIZE; ++j)
                {
                    char spc = stack[j];
                    if(std::isalnum(spc) || std::ispunct(spc)) g_pLogFile << spc;
                    else g_pLogFile << '.';
                }
                g_pLogFile << "]" << std::endl;
                g_pLogFile.flush();
            }
        }
    }
    else if(!stack)
    {
        g_pLogFile << "\n----------------------------------------------------\nA program stack is missing..?!\n";
        g_pLogFile.flush();
    }

    if(!g_bSimplerCrashLog)
    {
        bool bSkipCrashLog = false;
        if(g_bUnixBacktrace && g_nAndroidSDKVersion > 33 && libC)
        {
            backtrace_fn backtrace_ptr = (backtrace_fn)dlsym(libC, "backtrace");
            backtrace_symbols_fn backtrace_symbols_ptr = (backtrace_symbols_fn)dlsym(libC, "backtrace_symbols");

            if(backtrace_ptr && backtrace_symbols_ptr)
            {
                int symbolsCount = backtrace_ptr(btBuffer, 64);
                char** symbols = backtrace_symbols_ptr(btBuffer, symbolsCount);
                if(symbols)
                {
                    if(symbolsCount)
                    {
                        bSkipCrashLog = true;
                        g_pLogFile << "\n----------------------------------------------------\n" << "Call stack:\n";
                        for(int i = 0; i < symbolsCount; ++i)
                        {
                            g_pLogFile << symbols[i] << std::endl;
                        }
                        g_pLogFile.flush();
                    }
                    free(symbols);
                }
            }
        }
      #ifdef IO_GITHUB_HEXHACKING_XUNWIND
        if(!bSkipCrashLog && ( g_bEHUnwind || g_nAndroidSDKVersion > 33) )
        {
          go_EHUnwind:
            stackLog = NULL;
            g_bDumpAllThreads = false;

            size_t frames_sz = xunwind_eh_unwind(g_frames, sizeof(g_frames) / sizeof(g_frames[0]), ucontext);
            if(frames_sz > 0)
            {
                stackLog = xunwind_frames_get(g_frames, frames_sz, "");
            }
        }
        else
        {
            stackLog = xunwind_cfi_get(XUNWIND_CURRENT_PROCESS, g_bDumpAllThreads ? XUNWIND_ALL_THREADS : XUNWIND_CURRENT_THREAD, ucontext, "");
            if(!stackLog && g_nAndroidSDKVersion > 33) goto go_EHUnwind; // Android 14 and upper does not have libbacktrace?
        }
        if(stackLog)
        {
            if(stackLog[0])
            {
                g_pLogFile << "\n----------------------------------------------------\n" << (g_bDumpAllThreads ? "Call stack (of all threads):\n" : "Call stack:\n") << stackLog;
                g_pLogFile.flush();
            }
            free(stackLog);
        }
        else
        {
            g_pLogFile << "\n----------------------------------------------------\nCall stack:\nA system returned no crash log!";
            g_pLogFile.flush();
        }
      #endif
    }

    g_pLogFile << "\n----------------------------------------------------\n\t\tEND OF REPORT\n----------------------------------------------------\n\n";
    g_pLogFile << "If you`re having problems using OFFICIAL mods, please report about this problem in our OFFICIAL server:\n\t\thttps://discord.gg/2MY7W39kBg\nPlease follow the rules and head to the #help section!";
    g_pLogFile.flush();
    
  skip_logging:
    logger->Info("Notifying mods about the crash...");
    modlist->ProcessCrash(dlInfo.dli_fname ? GetFilenamePart(dlInfo.dli_fname) : "", sig, si->si_code, (uintptr_t)dlInfo.dli_fbase, mcontext);
    logger->Info("Telling mods to unload after the crash...");
    modlist->ProcessUnloading();

    oldSigaction[SignalInnerId(sig)].sa_sigaction(sig, si, ptr);
    exit(0);
}

#define HANDLESIG(_code) sigbreak = newSigaction + SignalInnerId(_code); sigbreak->sa_sigaction = &Handler; \
                         sigbreak->sa_flags = SA_SIGINFO | SA_ONSTACK | SA_RESETHAND; sigaction(_code, sigbreak, oldSigaction + SignalInnerId(_code))
void StartSignalHandler()
{
    stackstruct.ss_sp = &signalstack[0];
    stackstruct.ss_size = SIGSTKSZ;
    stackstruct.ss_flags = 0;
    sigaltstack(&stackstruct, NULL);

    struct sigaction* sigbreak = NULL;

    HANDLESIG(SIGABRT);
    HANDLESIG(SIGBUS);
    HANDLESIG(SIGFPE);
    HANDLESIG(SIGSEGV);
    HANDLESIG(SIGILL);
    HANDLESIG(SIGSTKFLT);
    HANDLESIG(SIGTRAP);
}

```

`template_of_mod/Android.mk`:

```mk
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_CPP_EXTENSION := .cpp .cc
LOCAL_MODULE    := modtemplate
LOCAL_SRC_FILES := main.cpp mod/logger.cpp mod/config.cpp
LOCAL_CFLAGS += -O2 -mfloat-abi=softfp -DNDEBUG -std=c++17
LOCAL_C_INCLUDES += ./include
LOCAL_LDLIBS += -llog
include $(BUILD_SHARED_LIBRARY)
```

`template_of_mod/Application.mk`:

```mk
APP_STL := c++_static
APP_ABI := armeabi-v7a
APP_OPTIM := release
```

`template_of_mod/main.cpp`:

```cpp
#include <mod/amlmod.h>
#include <mod/logger.h>
#include <mod/config.h>

MYMODCFG(net.rusjj.mymod.guid, AML Mod Template, 1.0, RusJJ)

//MYMOD(net.rusjj.mymod.guid, AML Mod Template Without Config, 1.0, RusJJ)

//NEEDGAME(net.rusjj.mygame)

//BEGIN_DEPLIST()
//    ADD_DEPENDENCY_VER(net.rusjj.aml, 1.0)
//END_DEPLIST()

uintptr_t pGameLibrary = 0;
ConfigEntry* pCfgMyBestEntry;

extern "C" void OnModLoad()
{
    logger->SetTag("Mod Template");
    
    pGameLibrary = aml->GetLib("libMyGame.so");
    if(pGameLibrary)
    {
        logger->Info("MyGame mod is loaded!");
    }
    else
    {
        logger->Error("MyGame mod is not loaded :(");
        return; // Do not load our mod?
    }

    pCfgMyBestEntry = cfg->Bind("mySetting", "DefaultValue is 0?", "MyUniqueSection");
    pCfgMyBestEntry->SetString("DefaultValue is unchanged");
    pCfgMyBestEntry->SetInt(1);
    pCfgMyBestEntry->Reset();
    delete pCfgMyBestEntry; // Clean-up memory
    
    bool bEnabled = cfg->Bind("Enable", true)->GetBool();
    delete Config::pLastEntry; // Clean-up of the latest ConfigEntry*
    
    cfg->Save(); // Will only save if something was changed
}

```

`template_of_mod/mod/amlmod.h`:

```h
#ifndef _AMLMOD
#define _AMLMOD

#include <stdio.h>
#include <ctype.h>
#include <cstring>
#include <stdlib.h>
#include <signal.h>

#if defined(__arm__) || defined(_WIN32)
    #define AML32
    #define BYBIT(__32val, __64val) (__32val)
#elif defined(__aarch64__) || defined(_WIN64)
    #define AML64
    #define BYBIT(__32val, __64val) (__64val)
#else
    #error This lib is supposed to work on ARM only!
#endif

#ifdef __clang__
    #define TARGET_ARM __attribute__((target("no-thumb-mode")))
    #define TARGET_THUMB  __attribute__((target("thumb-mode")))
#endif

#ifdef __GNUC__
    #define ASM_NAKED __attribute__((naked))
#else
    #define ASM_NAKED __declspec(naked)
#endif
#define EXPORT JNIEXPORT

#define MYMOD(_guid, _name, _version, _author)                          \
    static ModInfo modinfoLocal(#_guid, #_name, #_version, #_author);   \
    ModInfo* modinfo = &modinfoLocal;                                   \
    extern "C" JNIEXPORT ModInfo* __GetModInfo() { return modinfo; }    \
    IAML* aml = NULL;                                                   \
    struct AMLInitStub {                                                \
        AMLInitStub() {                                                 \
            aml = (IAML*)GetInterface("AMLInterface");                  \
        }                                                               \
    }; AMLInitStub amlStub __attribute__((init_priority(101))); // Highest init prio

#define MYMODCFG(_guid, _name, _version, _author)                       \
    MYMOD(_guid, _name, _version, _author);                             \
    static Config cfgLocal(#_guid);                                     \
    Config* cfg = &cfgLocal;

#define MYMODCFGNAME(_guid, _name, _version, _author, _cfgname)         \
    MYMOD(_guid, _name, _version, _author);                             \
    static Config cfgLocal(#_cfgname);                                  \
    Config* cfg = &cfgLocal;

#define NEEDGAME(_pkg_name)                                             \
    extern "C" JNIEXPORT const char* __INeedASpecificGame() { return #_pkg_name; }

/* Dependencies! */
#define BEGIN_DEPLIST()                                                 \
    static ModInfoDependency g_listDependencies[] = {

#define ADD_DEPENDENCY(_guid)                                           \
    {#_guid, ""},

#define ADD_DEPENDENCY_VER(_guid, _version)                             \
    {#_guid, #_version},

#define END_DEPLIST()                                                   \
    {"", ""} };                                                         \
    extern "C" JNIEXPORT ModInfoDependency* __GetDepsList() { return &g_listDependencies[0]; }

/* Macros to stop forgetting stuff! */
#define ON_MOD_PRELOAD()                                                \
    extern "C" JNIEXPORT void OnModPreLoad()

#define ON_MOD_LOAD()                                                   \
    extern "C" JNIEXPORT void OnModLoad()

#define ON_ALL_MODS_LOAD()                                              \
    extern "C" JNIEXPORT void OnAllModsLoaded()

#define ON_MOD_UNLOAD()                                                 \
    extern "C" JNIEXPORT void OnModUnload() /*Not guaranteed*/

#define ON_GAME_CRASH()                                                 \
    extern "C" JNIEXPORT void OnGameCrash(const char* library, int sig, int code, uintptr_t libaddr, mcontext_t* mcontext) /*Not guaranteed*/

#define UPDATER_URL()                                                   \
    extern "C" JNIEXPORT const char* OnUpdaterURLRequested()

#define ON_NEW_INTERFACE()                                              \
    extern "C" JNIEXPORT void OnInterfaceAdded(const char* name, const void* ptr)

    

#define MINIMUM_MD5_BUF_SIZE ( 32 + 1 )

struct MemChunk_t
{
    char* out;
    size_t out_len;
};
    
struct ModInfoDependency
{
    const char* szGUID;
    const char* szVersion;
};

struct ModVersion
{
    unsigned short major;
    unsigned short minor;
    unsigned short revision;
    unsigned short build;
};

// Should be faster than strncpy?
inline char *strxcpy(char* __restrict__ dst, const char* __restrict__ src, int len)
{
    if (!len) return NULL;
    while (--len && (*dst++ = *src++));
    if (!len)
    {
        *dst++ = '\0';
        return *src ? NULL : dst;
    }
    else
    {
        return dst;
    }
}

inline int clampint(int min, int max, int v)
{
    if(v < min) return min;
    else if(v > max) return max;
    return v;
}
inline void clampint(int min, int max, int* v)
{
    if(*v < min) *v = min;
    else if(*v > max) *v = max;
}
inline float clampfloat(float min, float max, float v)
{
    if(v < min) return min;
    else if(v > max) return max;
    return v;
}
inline void clampfloat(float min, float max, float* v)
{
    if(*v < min) *v = min;
    else if(*v > max) *v = max;
}

class ModInfo
{
public:
    ModInfo(const char* szGUID, const char* szName, const char* szVersion, const char* szAuthor)
    {
        /* No buffer overflow! */
        strxcpy(this->szGUID, szGUID, sizeof(ModInfo::szGUID)); this->szGUID[sizeof(ModInfo::szGUID) - 1] = '\0';
        strxcpy(this->szName, szName, sizeof(ModInfo::szName)); this->szName[sizeof(ModInfo::szName) - 1] = '\0';
        strxcpy(this->szVersion, szVersion, sizeof(ModInfo::szVersion)); this->szVersion[sizeof(ModInfo::szVersion) - 1] = '\0';
        strxcpy(this->szAuthor, szAuthor, sizeof(ModInfo::szAuthor)); this->szAuthor[sizeof(ModInfo::szAuthor) - 1] = '\0';

        /* GUID should be lowcase */
        for(int i = 0; this->szGUID[i] != '\0'; ++i)
        {
            this->szGUID[i] = tolower((int)(this->szGUID[i]));
        }

        /* Parse version string */
        if(sscanf(this->szVersion, "%hu.%hu.%hu.%hu", &version.major, &version.minor, &version.revision, &version.build) < 4)
        {
            if(sscanf(this->szVersion, "%hu.%hu.%hu", &version.major, &version.minor, &version.revision) < 3)
            {
                if(sscanf(this->szVersion, "%hu.%hu", &version.major, &version.minor) < 2)
                {
                    version.major = (unsigned short)atoi(this->szVersion);
                }
                version.revision = 0;
            }
            version.build = 0;
        }
    }
    inline const char* GUID() { return szGUID; }
    inline const char* Name() { return szName; }
    inline const char* VersionString() { return szVersion; }
    inline const char* Author() { return szAuthor; }
    inline unsigned short Major() { return version.major; }
    inline unsigned short Minor() { return version.minor; }
    inline unsigned short Revision() { return version.revision; }
    inline unsigned short Build() { return version.build; }

private:
    char szGUID[48];
    char szName[48];
    char szVersion[24];
    char szAuthor[48];
    ModVersion version;

    friend class ModsList;
    friend class Mods;
};

typedef ModInfo* (*GetModInfoFn)();
extern ModInfo* modinfo;


#include "iaml.h"

#endif // _AMLMOD
```

`template_of_mod/mod/config.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include "config.h"
#include <mod/logger.h>

#include "amlmod.h"
#include "iaml.h"
#if !defined(__AML) && defined(_ICFG)
    ICFG* icfg;
#else
    #include <fstream>
    #include "thirdparty/inicpp.h"
    ini::IniFile hINI;
#endif
#ifdef __AML
    extern char g_szCfgPath[0xFF];
#endif

inline bool str_equal(const char* str1, const char* str2)
{ 
    for( ; *str1 == *str2 && *str1 != 0; ++str1, ++str2 ) {}
    return *str2 == *str1; 
}

extern ModInfo* modinfo;
ConfigEntry* Config::pLastEntry = NULL;

Config::Config(const char* szName)
{
#if !defined(__AML) && defined(_ICFG)
    m_pICFG = (ICFG*)GetInterface("AMLConfig");
    m_iniMyConfig = m_pICFG->InitIniPointer();
#else
    m_iniMyConfig = &hINI;
#endif
    m_bInitialized = false;
    m_bValueChanged = false;
    m_szName = szName;

    #ifndef __AML
        Init();
    #endif
}

void Config::Init()
{
    if(m_bInitialized) return;
    m_bInitialized = true;
    
    #if !defined(__AML) && defined(_ICFG)
        m_pICFG->ParseInputStream(m_iniMyConfig, m_szName);
    #else
        char path[0xFF];
        #ifdef __AML
            snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
        #else
            snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
        #endif
        hINI.load(path);
    #endif
}

void Config::Save()
{
    if(!m_bInitialized || !m_bValueChanged) return;
    
    m_bValueChanged = false;
    #if !defined(__AML) && defined(_ICFG)
        m_pICFG->GenerateToOutputStream(m_iniMyConfig, m_szName);
    #else
        char path[0xFF];
        #ifdef __AML
            snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
        #else
            snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
        #endif
        hINI.save(path);
    #endif
}

ConfigEntry* Config::Bind(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strxcpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetString(szDefaultValue);
    }
    else 
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = strcmp(tryToGetValue, szDefaultValue) != 0;
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetInt(nDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (nDefaultValue != pRet->m_nIntegerValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetFloat(flDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (flDefaultValue != pRet->m_fFloatValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetBool(bDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (bDefaultValue != (!!pRet->m_nIntegerValue));
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, rgba_t clr, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry* pRet = new ConfigEntry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->m_bNotDefaultValue = false;
        pRet->SetString(pRet->m_szDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        pRet->m_bNotDefaultValue = (clr.value != pRet->m_ColorValue.value);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet;
    return pRet;
}

const char* Config::GetString(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, szDefaultValue);
        #else
            hINI[szSection][szKey] = szDefaultValue;
        #endif
        Save();
        return szDefaultValue;
    }
    return tryToGetValue;
}

int Config::GetInt(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return 0;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            char tmp[16];
            snprintf(tmp, sizeof(tmp), "%d", nDefaultValue);
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, tmp);
        #else
            hINI[szSection][szKey] = nDefaultValue;
        #endif
        Save();
        return nDefaultValue;
    }
    return atoi(tryToGetValue);
}

float Config::GetFloat(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return 0.0f;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            char tmp[24];
            snprintf(tmp, sizeof(tmp), "%f", flDefaultValue);
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, tmp);
        #else
            hINI[szSection][szKey] = flDefaultValue;
        #endif
        Save();
        return flDefaultValue;
    }
    return atof(tryToGetValue);
}

bool Config::GetBool(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return false;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        m_bValueChanged = true;
        #if !defined(__AML) && defined(_ICFG)
            m_pICFG->SetValueTo(m_iniMyConfig, szSection, szKey, bDefaultValue ? "1" : "0");
        #else
            hINI[szSection][szKey] = bDefaultValue ? "1" : "0";
        #endif
        Save();
        return bDefaultValue;
    }
    return atoi(tryToGetValue)!=0;
}

rgba_t Config::GetColor(const char* szKey, rgba_t clr, const char* szSection)
{
    if(!m_bInitialized) return rgba_t {0,0,0,0};
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strxcpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strxcpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = hINI[szSection][szKey].as<const char*>();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetString(pRet->m_szDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    return pRet->ParseColor();
}

void ConfigEntry::SetString(const char* newValue)
{
    if(m_bLoadedData && str_equal(newValue, m_szValue)) return;
    
    strxcpy(m_szValue, newValue, sizeof(m_szValue)-1); m_szValue[sizeof(m_szValue)-1] = 0;
    m_nIntegerValue = atoi(m_szValue);
    m_fFloatValue = (float)atof(m_szValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::GetString(char* str, size_t len)
{
    strxcpy(str, GetString(), len);
}

void ConfigEntry::SetFloat(float newValue)
{
    if(m_bLoadedData && m_fFloatValue == newValue) return;
    
    m_fFloatValue = newValue;
    m_nIntegerValue = (int)newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%f", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::SetInt(int newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue) return;
    
    m_fFloatValue = (float)newValue;
    m_nIntegerValue = newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%d", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

void ConfigEntry::SetBool(bool newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue?1:0) return;
    
    m_fFloatValue = newValue?1.0f:0.0f;
    m_nIntegerValue = newValue?1:0;
    m_szValue[0] = newValue ? '1' : '0'; m_szValue[1] = 0;
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

inline bool IsRGBValue(int value) { return value >= 0 && value <= 255; }
inline bool IsRGBFloatValue(float value) { return value >= 0 && value <= 1; }
rgba_t ConfigEntry::ParseColor()
{
    int r, g, b, a, sscanfed = sscanf(m_szValue, "%d %d %d %d", &r, &g, &b, &a);
    if(sscanfed == 4 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b) && IsRGBValue(a))
    {
        m_ColorValue = rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,(unsigned char)a};
    }
    else if(sscanfed == 3 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b))
    {
        m_ColorValue = rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,255};
    }
    else
    {
        float fr, fg, fb, fa;
        sscanfed = sscanf(m_szValue, "%f %f %f %f", &fr, &fg, &fb, &fa);
        if(sscanfed == 4 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b) && IsRGBFloatValue(a))
        {
            m_ColorValue = rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),(unsigned char)(255*fa)};
        }
        else if(sscanfed == 3 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b))
        {
            m_ColorValue = rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),255};
        }
    }
    //m_ColorValue = rgba_t{255,255,255,255}
    return m_ColorValue;
}

void ConfigEntry::SetColor(rgba_t clr, bool asFloat)
{
    m_nIntegerValue = (int)clr.r;
    m_fFloatValue = (float)clr.r;
    if(asFloat) snprintf(m_szValue, sizeof(m_szValue), "%.3f %.3f %.3f %.3f", (float)(clr.r/255.0f), (float)(clr.g/255.0f), (float)(clr.b/255.0f), (float)(clr.a/255.0f));
    else snprintf(m_szValue, sizeof(m_szValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    
    // Kinda expensive to parse the color every time
    // Why do you may want it to be changed automatically anyway?
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        hINI[m_szMySection][m_szMyKey] = m_szValue;
    #endif
}

```

`template_of_mod/mod/config.h`:

```h
#ifndef _CONFIG
#define _CONFIG

#define KEY_SECTION_BUFFER_C 64
#define VALUE_BUFFER_C 384

/* Is not required. Can be used only for a smaller size of mod (~480kb savings) */
#include "icfg.h"
#include <stdint.h>

class ConfigEntry;

struct rgba_t
{
    union {
        struct { unsigned char r, g, b, a; };
        struct { unsigned char x, y, z, w; };
        unsigned char v[4];
        unsigned int value;
    };
    
    rgba_t() : r(0), g(0), b(0), a(0) {}
    rgba_t(unsigned char v) : r(v), g(v), b(v), a(255) {}
    rgba_t(unsigned char _r, unsigned char _g, unsigned char _b) : r(_r), g(_g), b(_b), a(255) {}
    rgba_t(unsigned char _r, unsigned char _g, unsigned char _b, unsigned char _a) : r(_r), g(_g), b(_b), a(_a) {}
};

class Config
{
public:
    Config(const char* szName);
    void Init();
    void Save();
    // Allocated, needs to be manually deleted
    ConfigEntry* Bind(const char* szKey, const char* szDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, int nDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, float flDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, bool bDefaultValue, const char* szSection = "Preferences");
    ConfigEntry* Bind(const char* szKey, rgba_t clrDefaultValue, const char* szSection = "Preferences");
    
    // FAST GET. NO NEED TO CLEAN THE MEMORY.
    const char*  GetString(const char* szKey, const char* szDefaultValue, const char* szSection = "Preferences");
    int          GetInt(const char* szKey, int nDefaultValue, const char* szSection = "Preferences");
    float        GetFloat(const char* szKey, float flDefaultValue, const char* szSection = "Preferences");
    bool         GetBool(const char* szKey, bool bDefaultValue, const char* szSection = "Preferences");
    rgba_t       GetColor(const char* szKey, rgba_t clrDefaultValue, const char* szSection = "Preferences");

    // Self-explained
    inline bool  IsValueChanged() { return m_bValueChanged; }
    inline void  ClearLast();
    
    static Config* GetConfig();
    static ConfigEntry* pLastEntry;
    
private:
    bool m_bInitialized;
    bool m_bValueChanged;
    const char* m_szName;
    void* m_iniMyConfig;

#ifdef _ICFG
    /* Built-in optimizer thinks he's the best! Ha-ha... Not funny. It's 3AM... */
    ICFG* m_pICFG;
#endif
    
    friend class ConfigEntry;
};

class ConfigEntry
{
public:
    ConfigEntry() : m_bLoadedData(false), m_szValue(""), m_szDefaultValue("") {}
    void SetString(const char* newValue);
    inline const char* GetString() { return m_szValue; }
    void GetString(char* str, size_t len);
    void SetFloat(float newValue);
    inline float GetFloat() { return m_fFloatValue; }
    void SetBool(bool newValue);
    inline bool GetBool() { return m_nIntegerValue; }
    void SetInt(int newValue);
    inline int GetInt() { return m_nIntegerValue; }
    inline void Reset() { SetString(m_szDefaultValue); }
    rgba_t ParseColor();
    void SetColor(rgba_t clr, bool asFloat = false);

    inline bool LoadedUndefault() { return m_bNotDefaultValue; }
    inline int Clamp(int min, int max)
    {
        if(m_nIntegerValue < min)
        {
            m_pBoundCfg->m_bValueChanged = true;
            int ret = m_nIntegerValue - min;
            m_nIntegerValue = min;
            m_fFloatValue = (float)min;
            m_szValue[0] = 0;
            return ret;
        }
        if(m_nIntegerValue > max)
        {
            m_pBoundCfg->m_bValueChanged = true;
            int ret = m_nIntegerValue - max;
            m_nIntegerValue = max;
            m_fFloatValue = (float)max;
            m_szValue[0] = 0;
            return ret;
        }
        return 0;
    }
    inline float Clamp(float min, float max)
    {
        if(m_fFloatValue < min)
        {
            m_pBoundCfg->m_bValueChanged = true;
            float ret = m_fFloatValue - min;
            m_nIntegerValue = (int)min;
            m_fFloatValue = min;
            m_szValue[0] = 0;
            return ret;
        }
        if(m_fFloatValue > max)
        {
            m_pBoundCfg->m_bValueChanged = true;
            float ret = m_fFloatValue - max;
            m_nIntegerValue = (int)max;
            m_fFloatValue = max;
            m_szValue[0] = 0;
            return ret;
        }
        return 0.0f;
    }
    
private:
    Config* m_pBoundCfg;
    bool m_bLoadedData;
    bool m_bNotDefaultValue;
    char m_szMySection[KEY_SECTION_BUFFER_C];
    char m_szMyKey[KEY_SECTION_BUFFER_C];
    float m_fFloatValue;
    union
    {
        int m_nIntegerValue;
        rgba_t m_ColorValue;
    };
    char m_szValue[VALUE_BUFFER_C];
    char m_szDefaultValue[VALUE_BUFFER_C];

    friend class Config;
};
inline void Config::ClearLast() { if(pLastEntry) { delete pLastEntry; pLastEntry = NULL; } }
extern Config* cfg;

#endif // _CONFIG

```

`template_of_mod/mod/config_inipp.cpp`:

```cpp
#ifndef DONT_USE_STB
    #include <mod/thirdparty/stb_sprintf.h>
    #define sprintf stbsp_sprintf
    #define snprintf stbsp_snprintf
#endif
#include "config.h"
#include <mod/logger.h>

#include "amlmod.h"
#include "iaml.h"
#if !defined(__AML) && defined(_ICFG)
	ICFG* icfg;
#else
	#include <fstream>
	#include "thirdparty/inipp.h"
#endif
#ifdef __AML
	extern char g_szCfgPath[0xFF];
#endif

inline bool str_equal(const char* str1, const char* str2) { 
    for ( ; *str1 == *str2 && *str1 != 0; ++str1, ++str2 ); 
        return *str2 == *str1; 
}

extern ModInfo* modinfo;
ConfigEntry* Config::pLastEntry = NULL;

Config::Config(const char* szName)
{
#if !defined(__AML) && defined(_ICFG)
	m_pICFG = (ICFG*)GetInterface("AMLConfig");
	m_iniMyConfig = m_pICFG->InitIniPointer();
#else
	m_iniMyConfig = new inipp::Ini<char>();
    logger->Info("inipp 0x%16X, 0x%16X", m_iniMyConfig, *(void**)m_iniMyConfig);
#endif
	m_bInitialized = false;
    m_bValueChanged = false;
    m_szName = szName;

	#ifndef __AML
		Init();
	#endif
}

void Config::Init()
{
	if(m_bInitialized) return;
	m_bInitialized = true;
    
	#if !defined(__AML) && defined(_ICFG)
		m_pICFG->ParseInputStream(m_iniMyConfig, m_szName);
	#else
		char path[0xFF];
		#ifdef __AML
    		snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
			std::ifstream cfgStream(path);
		#else
    		snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
			std::ifstream cfgStream(path);
		#endif
		if(cfgStream.is_open())
		{
			((inipp::Ini<char>*)m_iniMyConfig)->parse(cfgStream);
		}
		cfgStream.close();
	#endif
}

void Config::Save()
{
	if(!m_bInitialized || !m_bValueChanged) return;
    
    m_bValueChanged = false;
	#if !defined(__AML) && defined(_ICFG)
		m_pICFG->GenerateToOutputStream(m_iniMyConfig, m_szName);
	#else
		char path[0xFF];
		#ifdef __AML
    		snprintf(path, sizeof(path), "%s/%s.ini", g_szCfgPath, m_szName);
			std::ofstream cfgStream(path);
		#else
    		snprintf(path, sizeof(path), "%s/%s.ini", aml->GetConfigPath(), m_szName);
			std::ofstream cfgStream(path);
		#endif
		if(cfgStream.is_open())
		{
			((inipp::Ini<char>*)m_iniMyConfig)->generate(cfgStream);
		}
		cfgStream << "";
		cfgStream.close();
	#endif
}

ConfigEntry* Config::Bind(const char* szKey, const char* szDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strncpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetString(szDefaultValue);
	else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
		pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, int nDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetInt(nDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, float flDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetFloat(flDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::Bind(const char* szKey, bool bDefaultValue, const char* szSection)
{
	if(!m_bInitialized) return NULL;
	ConfigEntry* pRet = new ConfigEntry;
	pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
	const char* tryToGetValue;
	#if !defined(__AML) && defined(_ICFG)
		tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
	#else
		tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
	#endif
	if(tryToGetValue[0] == '\0')
		pRet->SetBool(bDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
	Save();
    pLastEntry = pRet;
	return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, const char* szDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    strncpy(pRet->m_szDefaultValue, szDefaultValue, sizeof(pRet->m_szDefaultValue));
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetString(szDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, int nDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%d", nDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetInt(nDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, float flDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    snprintf(pRet->m_szDefaultValue, sizeof(pRet->m_szDefaultValue), "%f", flDefaultValue);
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
        pRet->SetFloat(flDefaultValue);
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

ConfigEntry* Config::BindOnce(const char* szKey, bool bDefaultValue, const char* szSection)
{
    if(!m_bInitialized) return NULL;
    ConfigEntry entry; ConfigEntry* pRet = &entry;
    pRet->m_pBoundCfg = this;
    strncpy(pRet->m_szMySection, szSection, sizeof(pRet->m_szMySection));
    strncpy(pRet->m_szMyKey, szKey, sizeof(pRet->m_szMyKey));
    pRet->m_szDefaultValue[0] = bDefaultValue ? '1' : '0'; pRet->m_szDefaultValue[1] = 0;
    const char* tryToGetValue;
    #if !defined(__AML) && defined(_ICFG)
        tryToGetValue = m_pICFG->GetValueFrom(m_iniMyConfig, szSection, szKey);
    #else
        tryToGetValue = ((inipp::Ini<char>*)m_iniMyConfig)->sections[szSection][szKey].c_str();
    #endif
    if(tryToGetValue[0] == '\0')
    {
        pRet->SetBool(bDefaultValue);
    }
    else
    {
        bool bShouldChange = !pRet->m_pBoundCfg->m_bValueChanged;
        pRet->SetString(tryToGetValue);
        if(bShouldChange) pRet->m_pBoundCfg->m_bValueChanged = false;
    }
    Save();
    pLastEntry = pRet; // Unsafe!
    return pRet;
}

void ConfigEntry::SetString(const char* newValue)
{
    if(m_bLoadedData && str_equal(newValue, m_szValue)) return;
    
    strncpy(m_szValue, newValue, sizeof(m_szValue)-1); m_szValue[sizeof(m_szValue)-1] = 0;
	m_nIntegerValue = atoi(m_szValue);
	m_fFloatValue = (float)atof(m_szValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::GetString(char* str, size_t len)
{
    strncpy(str, GetString(), len);
}

void ConfigEntry::SetFloat(float newValue)
{
    if(m_bLoadedData && m_fFloatValue == newValue) return;
    
	m_fFloatValue = newValue;
    m_nIntegerValue = (int)newValue;
    snprintf(m_szValue, sizeof(m_szValue), "%f", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::SetInt(int newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue) return;
    
	m_fFloatValue = (float)newValue;
    m_nIntegerValue = newValue;
	snprintf(m_szValue, sizeof(m_szValue), "%d", newValue);
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

void ConfigEntry::SetBool(bool newValue)
{
    if(m_bLoadedData && m_nIntegerValue == newValue?1:0) return;
    
	m_fFloatValue = newValue?1.0f:0.0f;
    m_nIntegerValue = newValue?1:0;
    m_szValue[0] = newValue ? '1' : '0'; m_szValue[1] = 0;
    
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

	#if !defined(__AML) && defined(_ICFG)
		m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
	#else
		((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

inline bool IsRGBValue(int value) { return value >= 0 && value <= 255; }
inline bool IsRGBFloatValue(float value) { return value >= 0 && value <= 1; }
rgba_t ConfigEntry::ParseColor()
{
    int r, g, b, a, sscanfed = sscanf(m_szValue, "%d %d %d %d", &r, &g, &b, &a);
    if(sscanfed == 4 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b) && IsRGBValue(a))
    {
        return rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,(unsigned char)a};
    }
    else if(sscanfed == 3 && IsRGBValue(r) && IsRGBValue(g) && IsRGBValue(b))
    {
        return rgba_t{(unsigned char)r,(unsigned char)g,(unsigned char)b,255};
    }
    else
    {
        float fr, fg, fb, fa;
        sscanfed = sscanf(m_szValue, "%f %f %f %f", &fr, &fg, &fb, &fa);
        if(sscanfed == 4 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b) && IsRGBFloatValue(a))
        {
            return rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),(unsigned char)(255*fa)};
        }
        else if(sscanfed == 3 && IsRGBFloatValue(r) && IsRGBFloatValue(g) && IsRGBFloatValue(b))
        {
            return rgba_t{(unsigned char)(255*fr),(unsigned char)(255*fg),(unsigned char)(255*fb),255};
        }
    }
    return rgba_t{255,255,255,255};
}

void ConfigEntry::SetColor(rgba_t clr, bool asFloat)
{
    m_nIntegerValue = (int)clr.r;
    m_fFloatValue = (float)clr.r;
    if(asFloat) snprintf(m_szValue, sizeof(m_szValue), "%.3f %.3f %.3f %.3f", (float)(clr.r/255.0f), (float)(clr.g/255.0f), (float)(clr.b/255.0f), (float)(clr.a/255.0f));
    else snprintf(m_szValue, sizeof(m_szValue), "%d %d %d %d", (int)clr.r, (int)clr.g, (int)clr.b, (int)clr.a);
    
    // Kinda expensive to parse the color every time
    // Why do you may want it to be changed automatically anyway?
    m_pBoundCfg->m_bValueChanged = true;
    m_bLoadedData = true;

    #if !defined(__AML) && defined(_ICFG)
        m_pBoundCfg->m_pICFG->SetValueTo(m_pBoundCfg->m_iniMyConfig, m_szMySection, m_szMyKey, m_szValue);
    #else
        ((inipp::Ini<char>*)(m_pBoundCfg->m_iniMyConfig))->sections[m_szMySection][m_szMyKey] = m_szValue;
	#endif
}

```

`template_of_mod/mod/iaml.h`:

```h
#ifndef _IAML
#define _IAML

// Usage: place 3 lines somewhere in the code AFTER #include <mod/amlmod.h>
// #if !defined(IAML_VER) && IAML_VER < 01030000
//     #error "You need to update your MOD folder to 1.3.0!"
// #endif
#define IAML_VER 01030000

#include "interface.h"
#include <jni.h>
#include <stdint.h>

// Because the name was changed to be more understandable
#define PlaceB PlaceJMP

#ifndef PAGE_SIZE
    #define PAGE_SIZE 4096
#endif

enum eManifestPermissions
{
    P_READ_EXTERNAL_STORAGE = 0,
    P_WRITE_EXTERNAL_STORAGE,
}; // Unused

// AML 1.3.0 stuff (Vibration patterns, examples)
static jlong DEFAULT_VIBRATE_PATTERN[4] = {0, 250, 250, 250};
static jlong g_VibroPattern_Weak[7] = { 0, 20, 80, 20, 80, 20, 80 };
static jlong g_VibroPattern_Alert[6] = { 0, 200, 100, 200, 100, 400 };

// I`m redoing this because i dont want to include additional file
// Thanks @XMDS, maybe someone will use it
struct GlossRegisters
{
#ifdef AML32
    enum e_reg
    {
        R0 = 0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, FP = R11, R12, IP = R12, R13, SP = R13, R14, LR = R14, R15, PC = R15, CPSR
    };

    union
    {
        uint32_t reg[17];
        struct
        {
            uint32_t r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, sp, lr, pc, cpsr;
        } regs;
    };
#else
    enum e_reg
    {
        X0 = 0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, X16, X17, X18, X19, X20, X21, X22, X23, X24, X25, X26, X27, X28, X29, FP = X29,
        Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12, Q13, Q14, Q15, Q16, Q17, Q18, Q19, Q20, Q21, Q22, Q23, Q24, Q25, Q26, Q27, Q28, Q29, Q30, Q31,
        X30, LR = X30, X31, SP = X31, PC, CPSR
    };

    union
    {
        uint64_t reg[66];
        struct
        {
            uint64_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29;
            double q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15, q16, q17, q18, q19, q20, q21, q22, q23, q24, q25, q26, q27, q28, q29, q30, q31;
            uint64_t lr, sp, pc, cpsr;
        } regs;
    };
#endif
};
typedef void* PHookHandle;
typedef void (*HookWithRegistersFn)(GlossRegisters* regs, PHookHandle hook);

#if defined(__cplusplus)
    extern "C"
#endif
size_t strlen(char const*);

class IAML
{
public:
    /* AML 1.0.0.0 */
    virtual const char* GetCurrentGame();
    virtual const char* GetConfigPath();
    virtual bool        HasMod(const char* szGUID);
    virtual bool        HasModOfVersion(const char* szGUID, const char* szVersion);
    virtual uintptr_t   GetLib(const char* szLib);
    virtual uintptr_t   GetSym(void* handle, const char* sym);
    virtual bool        Hook(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookPLT(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual int         Unprot(uintptr_t handle, size_t len = PAGE_SIZE);
    virtual void        Write(uintptr_t dest, uintptr_t src, size_t size);
    virtual void        Read(uintptr_t src, uintptr_t dest, size_t size);
    virtual int         PlaceNOP(uintptr_t addr, size_t count = 1);
    virtual int         PlaceJMP(uintptr_t addr, uintptr_t dest);
    virtual int         PlaceRET(uintptr_t addr);

    /* AML 1.0.0.4 */
    virtual const char* GetDataPath(); // /data/data/.../*

    /* AML 1.0.0.5 */
    virtual const char* GetAndroidDataPath(); // /sdcard/Android/data/.../files/*
    virtual uintptr_t   GetSym(uintptr_t libAddr, const char* sym); // An additional func but it uses ADDRESS instead of a HANDLE

    /* AML 1.0.0.6 */
    virtual uintptr_t   GetLibLength(const char* szLib);
    virtual int         Redirect(uintptr_t addr, uintptr_t to); // Move directly to "to" from "addr" with the same stack and registers
    virtual void        PlaceBL(uintptr_t addr, uintptr_t dest);
    virtual void        PlaceBLX(uintptr_t addr, uintptr_t dest);
    virtual uintptr_t   PatternScan(const char* pattern, const char* soLib);
    virtual uintptr_t   PatternScan(const char* pattern, uintptr_t libStart, uintptr_t scanLen);
    
    /* AML 1.0.1 */
    virtual void        PatchForThumb(bool forThumb);
    virtual const char* GetFeatures();
    virtual void        HookVtableFunc(void* ptr, unsigned int funcNum, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false); // unsafe
    virtual bool        IsGameFaked();
    virtual const char* GetRealCurrentGame();
    virtual void*       GetLibHandle(const char* soLib);
    virtual void*       GetLibHandle(uintptr_t addr);
    // xDL (will return 0 if xDL is not used)
    // These functions always exists
    // So no need to check for their availability
    virtual bool        IsCorrectXDLHandle(void* ptr);
    virtual uintptr_t   GetLibXDL(void* ptr);
    virtual uintptr_t   GetAddrBaseXDL(uintptr_t addr);
    virtual size_t      GetSymSizeXDL(void* ptr);
    virtual const char* GetSymNameXDL(void* ptr);
    
    /* AML 1.0.2 */
    virtual void        ShowToast(bool longerDuration, const char* fmt, ...);
    virtual bool        DownloadFile(const char* url, const char* saveto);
    virtual bool        DownloadFileToData(const char* url, char* out, size_t outLen);
    virtual void        FileMD5(const char* path, char* out, size_t out_len);
    virtual int         GetModsLoadedCount();
    virtual JNIEnv*     GetJNIEnvironment();
    virtual jobject     GetAppContextObject();
    
    /* AML 1.0.2.1 */
    virtual bool        HasModOfBiggerVersion(const char* szGUID, const char* szVersion);
    
    /* AML 1.0.4 */
    virtual void        HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* fnAddress, void** orgFnAddress = NULL, bool instantiate = false);
    virtual int         PlaceNOP4(uintptr_t addr, size_t count = 1);
    virtual const char* GetAndroidDataRootPath(); // /sdcard/Android/data/.../* (not /files/ !!!)
    virtual bool        HookB(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookBL(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    virtual bool        HookBLX(void* handle, void* fnAddress, void** orgFnAddress = NULL);
    
    /* AML 1.2 */
    virtual void        MLSSaveFile();
    virtual bool        MLSHasValue(const char* key);
    virtual void        MLSDeleteValue(const char* key);
    virtual void        MLSSetInt(const char* key, int32_t val);
    virtual void        MLSSetFloat(const char* key, float val);
    virtual void        MLSSetInt64(const char* key, int64_t val);
    virtual void        MLSSetStr(const char* key, const char *val);
    virtual bool        MLSGetInt(const char* key, int32_t *val);
    virtual bool        MLSGetFloat(const char* key, float *val);
    virtual bool        MLSGetInt64(const char* key, int64_t *val);
    virtual bool        MLSGetStr(const char* key, char *val, size_t len);
    
    /* AML 1.2.1 */
    virtual bool        IsThumbAddr(uintptr_t addr);
    virtual uintptr_t   GetBranchDest(uintptr_t addr);
    
    /* AML 1.2.2 */
    virtual int         GetAndroidVersion();
    virtual bool        CopyFile(const char* file, const char* dest);
    // Gloss things
  #ifdef AML32
    virtual void        RedirectReg(...);
  #else
    virtual void        RedirectReg(uintptr_t addr, uintptr_t to, bool doShortHook = false, GlossRegisters::e_reg targetReg = GlossRegisters::e_reg::X16); // Move directly to "to" from "addr" with the same stack and registers (X16 is the same as "Redirect")
  #endif  
    virtual bool        HasAddrExecFlag(uintptr_t addr);
    virtual void        ToggleHook(PHookHandle hook, bool enable);
    virtual void        DeHook(PHookHandle hook);
    virtual PHookHandle HookInline(void* fnAddress, HookWithRegistersFn newFn, bool doShortHook = false);
    
    /* AML 1.2.3 */
    virtual bool        HasFastmanAPKModified();
    virtual const char* GetInternalPath(); // /sdcard/
    virtual const char* GetInternalModsPath(); // /sdcard/AMLMods/*game*/ (by default)
    
    /* AML 1.3.0 */
    virtual JavaVM*     GetJavaVM();
    virtual jobject     GetCurrentContext();
    virtual void        DoVibro(int msTime); // Pretty strong feedback... If you need a small vibro, do it for like ~20ms, it's gonna be enough
    virtual void        DoVibro(jlong* pattern, int patternItems); // Patterns might give you more control
    virtual void        CancelVibro();
    virtual float       GetBatteryLevel(); // returns a float from 0.0 to 100.0


    // Inlines (shortcuts for you!)
    inline void         Write(uintptr_t dest, const char* str, size_t size) { Write(dest, (uintptr_t)str, size); } // Inline
    inline void         Write(uintptr_t dest, const char* str) { Write(dest, (uintptr_t)str, strlen(str)); } // Inline
    inline void         Write8(uintptr_t dest, uint8_t v) { uint8_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 1); } // Inline
    inline void         Write16(uintptr_t dest, uint16_t v) { uint16_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 2); } // Inline
    inline void         Write32(uintptr_t dest, uint32_t v) { uint32_t vPtr = v; Write(dest, (uintptr_t)&vPtr, 4); } // Inline
    inline void         WriteFloat(uintptr_t dest, float v) { float vPtr = v; Write(dest, (uintptr_t)&vPtr, 4); } // Inline
    inline void         WriteAddr(uintptr_t dest, uintptr_t addr) { uintptr_t addrPtr = addr; Write(dest, (uintptr_t)&addrPtr, sizeof(uintptr_t)); } // Inline
    inline void         WriteAddr(uintptr_t dest, void* addr) { uintptr_t addrPtr = (uintptr_t)addr; Write(dest, (uintptr_t)&addrPtr, sizeof(uintptr_t)); } // Inline
    // Can be used with HookVtableFunc to not to instantiate vtable for 1000 times!
    inline void**       GetVtable(void* ptr) { return *(void***)ptr; }
    inline void         SetVtable(void* ptr, void** vtable) { *(void***)ptr = vtable; }
};

extern IAML* aml;
inline IAML* GetAMLInterface() { return aml; }

/* Do not use big conversions */
#define SET_TO(__a1, __a2)  *(void**)&(__a1) = (void*)(__a2)
#define SET_TO_PTR(__a1, __a2)  *(void**)&(__a1) = *(void**)(__a2)
#define SETSYM_TO(__a1, __a2, __a3)  *(void**)&(__a1) = (void*)(aml->GetSym(__a2, __a3))
#define SETSYM_TO_PTR(__a1, __a2, __a3)  *(void**)&(__a1) = *(void**)(aml->GetSym(__a2, __a3))
#define AS_ADDR(__a1)       *(uintptr_t*)&(__a1)

/* Unprotect that memory chunk for making changes */
#define UNPROT(_addr, _count)                                   \
    aml->Unprot((uintptr_t)(_addr), ( _count ));
/* Just write own info to the memory */
#define WRITE(_addr, _whatToWrite, _size)                       \
    aml->Write(_addr, _whatToWrite, _size);

/* Just a hook declaration */
#define DECL_HOOK(_ret, _name, ...)                             \
    _ret (*_name)(__VA_ARGS__);                                 \
    _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define DECL_HOOKv(_name, ...)                                  \
    void (*_name)(__VA_ARGS__);                                 \
    void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define DECL_HOOKb(_name, ...)                                  \
    bool (*_name)(__VA_ARGS__);                                 \
    bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define DECL_HOOKi(_name, ...)                                  \
    int (*_name)(__VA_ARGS__);                                  \
    int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define DECL_HOOKp(_name, ...)                                  \
    void* (*_name)(__VA_ARGS__);                                \
    void* HookOf_##_name(__VA_ARGS__)

/* Just a hook declaration (but with static funcs and stuff) */
#define SDECL_HOOK(_ret, _name, ...)                             \
    static _ret (*_name)(__VA_ARGS__);                           \
    static _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define SDECL_HOOKv(_name, ...)                                  \
    static void (*_name)(__VA_ARGS__);                           \
    static void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define SDECL_HOOKb(_name, ...)                                  \
    static bool (*_name)(__VA_ARGS__);                           \
    static bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define SDECL_HOOKi(_name, ...)                                  \
    static int (*_name)(__VA_ARGS__);                            \
    static int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define SDECL_HOOKp(_name, ...)                                  \
    static void* (*_name)(__VA_ARGS__);                          \
    static void* HookOf_##_name(__VA_ARGS__)

/* Just a hook declaration (but with static+inlined funcs and stuff) */
#define SIDECL_HOOK(_ret, _name, ...)                             \
    static inline _ret (*_name)(__VA_ARGS__);                     \
    static _ret HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void */
#define SIDECL_HOOKv(_name, ...)                                  \
    static inline void (*_name)(__VA_ARGS__);                     \
    static void HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = bool */
#define SIDECL_HOOKb(_name, ...)                                  \
    static inline bool (*_name)(__VA_ARGS__);                     \
    static bool HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = int */
#define SIDECL_HOOKi(_name, ...)                                  \
    static inline int (*_name)(__VA_ARGS__);                      \
    static int HookOf_##_name(__VA_ARGS__)
/* Just a hook declaration with return type = void* */
#define SIDECL_HOOKp(_name, ...)                                  \
    static inline void* (*_name)(__VA_ARGS__);                    \
    static void* HookOf_##_name(__VA_ARGS__)

/* Just a hook of a function */
#define HOOK(_name, _fnAddr)                                    \
    aml->Hook((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a function (but simpler usage) */
#define HOOKSYM(_name, _libHndl, _fnSym)                        \
    aml->Hook((void*)(aml->GetSym(_libHndl, _fnSym)), (void*)(&HookOf_##_name), (void**)(&_name));
/* Just a hook of a function located in PLT section (by address!) */
#define HOOKPLT(_name, _fnAddr)                                 \
    aml->HookPLT((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch */
#define HOOKB(_name, _fnAddr)                                   \
    aml->HookB((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch with link */
#define HOOKBL(_name, _fnAddr)                                  \
    aml->HookBL((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a branch with link (and registers exchange) */
#define HOOKBLX(_name, _fnAddr)                                 \
    aml->HookBLX((void*)(_fnAddr), (void*)(&HookOf_##_name), (void**)(&_name))
/* Just a hook of a function hidden behind IL2CPP */
#define HOOK_IL2CPP(_name, _methodInfo)                         \
    aml->Hook((void*)_methodInfo->methodPointer, (void*)(&HookOf_##_name), (void**)(&_name))

#endif // _IAML
```

`template_of_mod/mod/icfg.h`:

```h
/* Is not required. Can be used only for a smaller size of mod (~370kb savings) */
/* because of fstream include (it has a lot of templates & not only) */
/* There's no reason of using this feature if you're already using fstream */

#ifndef _ICFG
#define _ICFG

class ICFG
{
public:
    virtual void* InitIniPointer() = 0;
    virtual void ParseInputStream(void* iniPointer, const char* szFilename) = 0;
    virtual void GenerateToOutputStream(void* iniPointer, const char* szFilename) = 0;
    virtual const char* GetValueFrom(void* iniPointer, const char* szSection, const char* szKey) = 0;
    virtual void SetValueTo(void* iniPointer, const char* szSection, const char* szKey, const char* szValue) = 0;
};

extern ICFG* icfg;
inline ICFG* GetCFGInterface()
{
    return icfg;
}

#endif // _ICFG
```

`template_of_mod/mod/il2cpp.h`:

```h
struct IL2Assembly;
struct IL2Object;
struct IL2Class;
struct IL2Image;
struct IL2Array;
struct IL2Type;

struct IL2Domain;
struct IL2ReflectionType;
struct IL2Exception;
struct IL2Profiler;
struct IL2Thread;
struct IL2ReflectionMethod;
struct IL2ManagedMemorySnapshot;
struct IL2StackFrameInfo;
struct IL2CustomAttrInfo;
struct IL2GenericClass;
struct IL2Defaults;

struct IL2TypeDefinition;
struct IL2GenericParameter;
struct IL2GenericContainer;

struct MethodInfo;
struct FieldInfo;
struct PropertyInfo;
struct EventInfo;
```

`template_of_mod/mod/interface.h`:

```h
/* DO NOT CHANGE IT */

#ifndef __GETINTERFACE_H
#define __GETINTERFACE_H

#if defined(_WIN32) || defined(_WIN64)
    #define WIN32_LEAN_AND_MEAN
    #include <Windows.h>
#else
    #include <dlfcn.h>
#endif
#define DEFAULT_LIB_NAME    "AML"

#define WRAP_INTERFACE(__interface_name, __interface_var)	RegisterInterface(#__interface_name, __interface_var)

typedef void* (*GetInterfaceFn)(const char*);
typedef void* (*RegInterfaceFn)(const char*, void*);

inline void* GetInterface(const char* szInterfaceName)
{
#if defined(_WIN32) || defined(_WIN64)
    GetInterfaceFn _GetInterface = (GetInterfaceFn)GetProcAddress(GetModuleHandleA(DEFAULT_LIB_NAME ".dll"), "GetInterface");
#else
    GetInterfaceFn _GetInterface = (GetInterfaceFn)dlsym((void*)dlopen("lib" DEFAULT_LIB_NAME ".so", RTLD_NOW), "GetInterface");
#endif
    return _GetInterface(szInterfaceName);
}

inline void RegisterInterface(const char* szInterfaceName, void* pInterface)
{
#if defined(_WIN32) || defined(_WIN64)
    RegInterfaceFn _RegInterface = (RegInterfaceFn)GetProcAddress(GetModuleHandleA(DEFAULT_LIB_NAME ".dll"), "CreateInterface");
#else
    RegInterfaceFn _RegInterface = (RegInterfaceFn)dlsym((void*)dlopen("lib" DEFAULT_LIB_NAME ".so", RTLD_NOW), "CreateInterface");
#endif
    _RegInterface(szInterfaceName, pInterface);
}

#endif // __GETINTERFACE_H
```

`template_of_mod/mod/listitem.h`:

```h
#pragma once

#include <stddef.h> // use of undeclared identifier 'NULL'

#define LIST_START(__cls_name) struct __cls_name { \
    __cls_name *pPrev; \
    __cls_name *pNext; \
    __cls_name *pLast; \
    unsigned int nCount; \
    typedef __cls_name MyClass; \
    \
    inline unsigned int Count() { return !this ? 0 : First()->nCount; } \
    inline __cls_name *First() \
    { \
        if(!this) return NULL; \
        __cls_name *first = this; \
        if(first->pPrev == this) { first->pPrev = NULL; return this; } \
        while(first->pPrev != NULL) first = first->pPrev; \
        return first; \
    } \
    inline __cls_name *CalcLast() \
    { \
        if(!this) return NULL; \
        __cls_name *last = this; \
        while(last->pNext != NULL) last = last->pNext; \
        return last; \
    } \
    inline __cls_name *Last() \
    { \
        return pLast; \
    } \
    inline void Push(__cls_name **listPtr) \
    { \
        __cls_name*& list = *listPtr; \
        pPrev = NULL; \
        if(list == NULL) { \
            pNext = NULL; \
            pLast = this; \
            nCount = 1; \
        } else { \
            pNext = list; \
            pLast = list->pLast; \
            list->pPrev = this; \
            nCount = list->nCount + 1; \
        } \
        list = this; \
    } \
    inline bool Remove(__cls_name **listPtr) { \
        if(!listPtr || !*listPtr || !pLast) return false; \
        __cls_name*& list = *listPtr; \
        if(list == this) { \
            if(pNext) { \
                list = pNext; \
                list->nCount = nCount - 1; \
                list->pPrev = NULL; \
                list->pLast = pLast; \
            } else { \
                list = NULL; \
            } \
        } \
        else if(list->pLast == this) { \
            list->pLast = pPrev; \
            pPrev->pNext = NULL; \
            --(list->nCount); \
        } else { \
            pPrev->pNext = pNext; \
            if(pNext) pNext->pPrev = pPrev; \
            --(list->nCount); \
        } \
        pNext = NULL; pPrev = NULL; pLast = NULL; \
        return true; \
    } \
    inline bool InList(__cls_name **listPtr) \
    { \
        LIST_FOR(*listPtr) { \
            if(item == this) return true; \
        } \
        return false; \
    }

#define LIST_END() \
};

#define LIST_INITSTART(__cls_name) \
    __cls_name() {

#define LIST_INITEND() \
        pPrev = NULL; \
        pNext = NULL; \
        pLast = NULL; \
        nCount = 1; \
    }

// Never use FAST versions if you do "Remove" or "Push" in a loop! Or maintain it by yourself!

#define LIST_FOR(__list) for(auto item = __list, itemNext = item ? item->pNext : NULL; item != NULL; item = itemNext, itemNext = item ? item->pNext : NULL)
#define LIST_FOR_FAST(__list) for(auto item = __list; item != NULL; item = item->pNext)
#define LIST_FOR2(__list, __itemname) for(auto __itemname = __list, itemNext = __itemname ? __itemname->pNext : NULL; __itemname != NULL; __itemname = itemNext, itemNext = __itemname ? __itemname->pNext : NULL)
#define LIST_FOR2_FAST(__list, __itemname) for(auto __itemname = __list; __itemname != NULL; __itemname = __itemname->pNext)
#define LIST_FOR_REVERSE(__list) for(auto item = __list ? __list->pLast : NULL, itemPrev = item ? item->pPrev : NULL; item != NULL; item = itemPrev, itemPrev = item ? item->pPrev : NULL)
#define LIST_FOR_REVERSE_FAST(__list) for(auto item = __list ? __list->pLast : NULL; item != NULL; item = item->pPrev)
#define LIST_RESET(__list, __resetFunc) LIST_FOR(__list) { __resetFunc(); item->Remove(&__list); }
```

`template_of_mod/mod/logger.cpp`:

```cpp
#ifndef DONT_USE_STB
    #ifndef DONT_IMPLEMENT_STB
        #define STB_SPRINTF_IMPLEMENTATION
    #endif
    #include <mod/thirdparty/stb_sprintf.h>

    #define vsnprintf stbsp_vsnprintf
#endif
#include "logger.h"
#include <string.h>
#include <android/log.h>

Logger::Logger()
{
    strncpy(m_szTag, "AML Mod", sizeof(m_szTag));
    m_bEnabled = true;
    m_fnLogCallback = NULL;
    m_fnNewTagCallback = NULL;
    m_fnToggledCallback = NULL;
}

void Logger::ToggleOutput(bool enabled)
{
    if(m_bEnabled != enabled)
    {
        m_bEnabled = enabled;
        if(m_fnToggledCallback) m_fnToggledCallback(enabled);
    }
}

void Logger::SetTag(const char* szTag)
{
    if(m_fnNewTagCallback) m_fnNewTagCallback(m_szTag, szTag);
    strncpy(m_szTag, szTag, sizeof(m_szTag)-1);
    m_szTag[sizeof(m_szTag)-1] = 0;
}

void Logger::Print(eLogPrio prio, const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::PrintV(eLogPrio prio, const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
#endif
}

void Logger::PrintTag(eLogPrio prio, const char* szTag, const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::PrintTagV(eLogPrio prio, const char* szTag, const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(prio, buffer);
    __android_log_write((android_LogPriority)prio, m_szTag, buffer);
#endif
}

void Logger::Info(const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Info, buffer);
    __android_log_write(ANDROID_LOG_INFO, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::InfoV(const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Info, buffer);
    __android_log_write(ANDROID_LOG_INFO, m_szTag, buffer);
#endif
}

void Logger::Error(const char* szMessage, ...)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    va_list args;
    va_start(args, szMessage);
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Error, buffer);
    __android_log_write(ANDROID_LOG_ERROR, m_szTag, buffer);
    va_end(args);
#endif
}

void Logger::ErrorV(const char* szMessage, va_list args)
{
#ifndef NOLOGGING
    if(!m_bEnabled) return;
    
    char buffer[TMPBUF_SIZE];
    vsnprintf(buffer, sizeof(buffer), szMessage, args);
    if(m_fnLogCallback) m_fnLogCallback(LogP_Error, buffer);
    __android_log_write(ANDROID_LOG_ERROR, m_szTag, buffer);
#endif
}

static Logger loggerLocal;
Logger* logger = &loggerLocal;
```

`template_of_mod/mod/logger.h`:

```h
#ifndef _LOGGER_H
#define _LOGGER_H

#include <stdio.h>
#define TMPBUF_SIZE 2048 // Max logging buf is 4096 btw

/* Define NOLOGGING if you DONT need logs in any form */
/* You can do it like that in Android.mk: LOCAL_CXXFLAGS += -DNOLOGGING */

enum eLogPrio
{
    LogP_Unk = 0,
    LogP_Default,
    LogP_Verbose,
    LogP_Debug,
    LogP_Info,
    LogP_Warn,
    LogP_Error,
    LogP_Fatal,
    LogP_Silent,
};

class Logger;
extern Logger* logger;

class Logger
{
public:
    typedef void (*LoggerMessageCB)(eLogPrio prio, const char* msg);
    typedef void (*LoggerSetTagCB)(const char* oldTag, const char* newTag);
    typedef void (*LoggerToggledCB)(bool isEnabled);

    inline static Logger* GetLogger() { return logger; }
    Logger();

    void ToggleOutput(bool enabled);
    void SetTag(const char* szTag);
    void Print(eLogPrio prio, const char* szMessage, ...);
    void PrintV(eLogPrio prio, const char* szMessage, va_list args);
    void PrintTag(eLogPrio prio, const char* szTag, const char* szMessage, ...);
    void PrintTagV(eLogPrio prio, const char* szTag, const char* szMessage, va_list args);
    void Info(const char* szMessage, ...);
    void InfoV(const char* szMessage, va_list args);
    void Error(const char* szMessage, ...);
    void ErrorV(const char* szMessage, va_list args);
  #ifdef NOLOGGING
    inline bool HasOutput() { return false; }
  #else
    inline bool HasOutput() { return m_bEnabled; }
  #endif

    inline void SetMessageCB(LoggerMessageCB fnCB) { m_fnLogCallback = fnCB; }
    inline void SetTagCB(LoggerSetTagCB fnCB)      { m_fnNewTagCallback = fnCB; }
    inline void SetToggleCB(LoggerToggledCB fnCB)  { m_fnToggledCallback = fnCB; }

private:
    char m_szTag[31];
    bool m_bEnabled;
    LoggerMessageCB m_fnLogCallback;
    LoggerSetTagCB m_fnNewTagCallback;
    LoggerToggledCB m_fnToggledCallback;
};

#endif // _LOGGER_H
```

`template_of_mod/mod/thirdparty/INICPP_LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Fabian Meyer

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`template_of_mod/mod/thirdparty/STB_LICENSE`:

```
This software is available under 2 licenses -- choose whichever you prefer. ------------------------------------------------------------------------------ ALTERNATIVE A - MIT License Copyright (c) 2017 Sean Barrett Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ------------------------------------------------------------------------------ ALTERNATIVE B - Public Domain (www.unlicense.org) This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`template_of_mod/mod/thirdparty/inicpp.h`:

```h
/*
 * inicpp.h
 *
 * Created on: 26 Dec 2015
 *     Author: Fabian Meyer
 *    License: MIT
 */

#ifndef INICPP_H_
#define INICPP_H_

#include <algorithm>
#include <fstream>
#include <istream>
#include <map>
#include <assert.h>
#include <sstream>
#include <stdexcept>
#include <vector>

namespace ini
{
    /************************************************
     * Helper Functions
     ************************************************/

    /** Returns a string of whitespace characters. */
    constexpr const char *whitespaces()
    {
        return " \t\n\r\f\v";
    }

    /** Returns a string of indentation characters. */
    constexpr const char *indents()
    {
        return " \t";
    }

    /** Trims a string in place.
      * @param str string to be trimmed in place */
    inline void trim(std::string &str)
    {
        // first erasing from end should be slighty more efficient
        // because erasing from start potentially moves all chars
        // multiple indices towards the front.

        auto lastpos = str.find_last_not_of(whitespaces());
        if(lastpos == std::string::npos)
        {
            str.clear();
            return;
        }

        str.erase(lastpos + 1);
        str.erase(0, str.find_first_not_of(whitespaces()));
    }

    /************************************************
     * Conversion Functors
     ************************************************/

    inline bool strToLong(const std::string &value, long &result)
    {
        char *endptr;
        // check if decimal
        result = std::strtol(value.c_str(), &endptr, 10);
        if(*endptr == '\0')
            return true;
        // check if octal
        result = std::strtol(value.c_str(), &endptr, 8);
        if(*endptr == '\0')
            return true;
        // check if hex
        result = std::strtol(value.c_str(), &endptr, 16);
        if(*endptr == '\0')
            return true;

        return false;
    }

    inline bool strToULong(const std::string &value, unsigned long &result)
    {
        char *endptr;
        // check if decimal
        result = std::strtoul(value.c_str(), &endptr, 10);
        if(*endptr == '\0')
            return true;
        // check if octal
        result = std::strtoul(value.c_str(), &endptr, 8);
        if(*endptr == '\0')
            return true;
        // check if hex
        result = std::strtoul(value.c_str(), &endptr, 16);
        if(*endptr == '\0')
            return true;

        return false;
    }

    template<typename T>
    struct Convert
    {};

    template<>
    struct Convert<bool>
    {
        void decode(const std::string &value, bool &result)
        {
            std::string str(value);
            std::transform(str.begin(), str.end(), str.begin(), [](const char c){
                return static_cast<char>(::toupper(c));
            });

            if(str == "TRUE")
                result = true;
            else if(str == "FALSE")
                result = false;
            else
                throw std::invalid_argument("field is not a bool");
        }

        void encode(const bool value, std::string &result)
        {
            result = value ? "true" : "false";
        }
    };

    template<>
    struct Convert<char>
    {
        void decode(const std::string &value, char &result)
        {
            assert(value.size() > 0);
            result = value[0];
        }

        void encode(const char value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<unsigned char>
    {
        void decode(const std::string &value, unsigned char &result)
        {
            assert(value.size() > 0);
            result = value[0];
        }

        void encode(const unsigned char value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<short>
    {
        void decode(const std::string &value, short &result)
        {
            long tmp;
            if(!strToLong(value, tmp))
                throw std::invalid_argument("field is not a short");
            result = static_cast<short>(tmp);
        }

        void encode(const short value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned short>
    {
        void decode(const std::string &value, unsigned short &result)
        {
            unsigned long tmp;
            if(!strToULong(value, tmp))
                throw std::invalid_argument("field is not an unsigned short");
            result = static_cast<unsigned short>(tmp);
        }

        void encode(const unsigned short value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<int>
    {
        void decode(const std::string &value, int &result)
        {
            long tmp;
            if(!strToLong(value, tmp))
                throw std::invalid_argument("field is not an int");
            result = static_cast<int>(tmp);
        }

        void encode(const int value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned int>
    {
        void decode(const std::string &value, unsigned int &result)
        {
            unsigned long tmp;
            if(!strToULong(value, tmp))
                throw std::invalid_argument("field is not an unsigned int");
            result = static_cast<unsigned int>(tmp);
        }

        void encode(const unsigned int value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<long>
    {
        void decode(const std::string &value, long &result)
        {
            if(!strToLong(value, result))
                throw std::invalid_argument("field is not a long");
        }

        void encode(const long value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<unsigned long>
    {
        void decode(const std::string &value, unsigned long &result)
        {
            if(!strToULong(value, result))
                throw std::invalid_argument("field is not an unsigned long");
        }

        void encode(const unsigned long value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<double>
    {
        void decode(const std::string &value, double &result)
        {
            result = std::stod(value);
        }

        void encode(const double value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<float>
    {
        void decode(const std::string &value, float &result)
        {
            result = std::stof(value);
        }

        void encode(const float value, std::string &result)
        {
            std::stringstream ss;
            ss << value;
            result = ss.str();
        }
    };

    template<>
    struct Convert<std::string>
    {
        void decode(const std::string &value, std::string &result)
        {
            result = value;
        }

        void encode(const std::string &value, std::string &result)
        {
            result = value;
        }
    };

    template<>
    struct Convert<const char*>
    {
        void encode(const char* const &value, std::string &result)
        {
            result = value;
        }

        void decode(const std::string &value, const char* &result)
        {
            result = value.c_str();
        }
    };

    template<>
    struct Convert<char*>
    {
        void encode(const char* const &value, std::string &result)
        {
            result = value;
        }
    };

    template<size_t n>
    struct Convert<char[n]>
    {
        void encode(const char *value, std::string &result)
        {
            result = value;
        }
    };

    class IniField
    {
    private:
        std::string value_;

    public:
        IniField() : value_()
        {}

        IniField(const std::string &value) : value_(value)
        {}
        IniField(const IniField &field) : value_(field.value_)
        {}

        ~IniField()
        {}

        template<typename T>
        T as() const
        {
            Convert<T> conv;
            T result;
            conv.decode(value_, result);
            return result;
        }

        template<typename T>
        IniField &operator=(const T &value)
        {
            Convert<T> conv;
            conv.encode(value, value_);
            return *this;
        }

        IniField &operator=(const IniField &field)
        {
            value_ = field.value_;
            return *this;
        }
    };

    struct StringInsensitiveLess
    {
        bool operator()(std::string lhs, std::string rhs) const
        {
                std::transform(lhs.begin(), lhs.end(), lhs.begin(), [](const char c){
                    return static_cast<char>(::tolower(c));
                });
                std::transform(rhs.begin(), rhs.end(), rhs.begin(), [](const char c){
                    return static_cast<char>(::tolower(c));
                });
                return  lhs < rhs;
        }
    };

    template <typename Comparator>
    class IniSectionBase : public std::map<std::string, IniField, Comparator>
    {
    public:
        IniSectionBase()
        {}
        ~IniSectionBase()
        {}
    };

    using IniSection = IniSectionBase<std::less<std::string>>;
    using IniSectionCaseInsensitive = IniSectionBase<StringInsensitiveLess>;

    template <typename Comparator>
    class IniFileBase : public std::map<std::string, IniSectionBase<Comparator>, Comparator>
    {
    private:
        char fieldSep_ = '=';
        char esc_ = '\\';
        std::vector<std::string> commentPrefixes_ = { "#" , ";" };
        bool multiLineValues_ = false;

        void eraseComment(const std::string &commentPrefix,
            std::string &str,
            std::string::size_type startpos = 0)
        {
            size_t prefixpos = str.find(commentPrefix, startpos);
            if(std::string::npos == prefixpos)
                return;
            // Found a comment prefix, is it escaped?
            if(0 != prefixpos && str[prefixpos - 1] == esc_)
            {
                // The comment prefix is escaped, so just delete the escape char
                // and keep erasing after the comment prefix
                str.erase(prefixpos - 1, 1);
                eraseComment(
                    commentPrefix, str, prefixpos - 1 + commentPrefix.size());
            }
            else
            {
                str.erase(prefixpos);
            }
        }

        void eraseComments(std::string &str)
        {
            for(const std::string &commentPrefix : commentPrefixes_)
                eraseComment(commentPrefix, str);
        }

        /** Tries to find a suitable comment prefix for the string data at the given
          * position. Returns commentPrefixes_.end() if not match was found. */
        std::vector<std::string>::const_iterator findCommentPrefix(const std::string &str,
            const std::size_t startpos) const
        {
            // if startpos is invalid simply return "not found"
            if(startpos >= str.size())
                return commentPrefixes_.end();

            for(size_t i = 0; i < commentPrefixes_.size(); ++i)
            {
                const std::string &prefix = commentPrefixes_[i];
                // if this comment prefix is longer than the string view itself
                // then skip
                if(prefix.size() + startpos > str.size())
                    continue;

                bool match = true;
                for(size_t j = 0; j < prefix.size() && match; ++j)
                    match = str[startpos + j] == prefix[j];

                if(match)
                    return commentPrefixes_.begin() + i;
            }

            return commentPrefixes_.end();
        }

        void writeEscaped(std::ostream &os, const std::string &str) const
        {
            for(size_t i = 0; i < str.length(); ++i)
            {
                auto prefixpos = findCommentPrefix(str, i);
                // if no suitable prefix was found at this position
                // then simply write the current character
                if(prefixpos != commentPrefixes_.end())
                {
                    const std::string &prefix = *prefixpos;
                    os.put(esc_);
                    os.write(prefix.c_str(), prefix.size());
                    i += prefix.size() - 1;
                }
                else if (multiLineValues_ && str[i] == '\n')
                    os.write("\n\t", 2);
                else
                    os.put(str[i]);
            }
        }

    public:
        IniFileBase() = default;

        IniFileBase(const char fieldSep, const char comment)
            : fieldSep_(fieldSep), commentPrefixes_(1, std::string(1, comment))
        {}

        IniFileBase(const std::string &filename)
        {
            load(filename);
        }

        IniFileBase(std::istream &is)
        {
            decode(is);
        }

        IniFileBase(const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {}

        IniFileBase(const std::string &filename,
            const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {
            load(filename);
        }

        IniFileBase(std::istream &is,
            const char fieldSep,
            const std::vector<std::string> &commentPrefixes)
            : fieldSep_(fieldSep), commentPrefixes_(commentPrefixes)
        {
            decode(is);
        }

        ~IniFileBase()
        {}

        /** Sets the separator charactor for fields in the INI file.
          * @param sep separator character to be used. */
        void setFieldSep(const char sep)
        {
            fieldSep_ = sep;
        }

        /** Sets the character that should be interpreted as the start of comments.
          * Default is '#'.
          * Note: If the inifile contains the comment character as data it must be prefixed with
          * the configured escape character.
          * @param comment comment character to be used. */
        void setCommentChar(const char comment)
        {
            commentPrefixes_ = {std::string(1, comment)};
        }

        /** Sets the list of strings that should be interpreted as the start of comments.
          * Default is [ "#" ].
          * Note: If the inifile contains any comment string as data it must be prefixed with
          * the configured escape character.
          * @param commentPrefixes vector of comment prefix strings to be used. */
        void setCommentPrefixes(const std::vector<std::string> &commentPrefixes)
        {
            commentPrefixes_ = commentPrefixes;
        }

        /** Sets the character that should be used to escape comment prefixes.
          * Default is '\'.
          * @param esc escape character to be used. */
        void setEscapeChar(const char esc)
        {
            esc_ = esc;
        }

        /** Sets whether or not to parse multi-line field values.
          * Default is false.
          * @param enable enable or disable? */
        void setMultiLineValues(bool enable)
        {
            multiLineValues_ = enable;
        }

        /** Tries to decode a ini file from the given input stream.
          * @param is input stream from which data should be read. */
        void decode(std::istream &is)
        {
            this->clear();
            int lineNo = 0;
            IniSectionBase<Comparator> *currentSection = nullptr;
            std::string mutliLineValueFieldName = "";
            std::string line;
            // iterate file line by line
            while(!is.eof() && !is.fail())
            {
                std::getline(is, line, '\n');
                eraseComments(line);
                bool hasIndent = line.find_first_not_of(indents()) != 0;
                trim(line);
                ++lineNo;

                // skip if line is empty
                if(line.size() == 0)
                    continue;

                if(line[0] == '[')
                {
                    // line is a section
                    // check if the section is also closed on same line
                    std::size_t pos = line.find("]");
                    if(pos == std::string::npos)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, section not closed";
                        throw std::logic_error(ss.str());
                    }
                    // check if the section name is empty
                    if(pos == 1)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, section is empty";
                        throw std::logic_error(ss.str());
                    }

                    // retrieve section name
                    std::string secName = line.substr(1, pos - 1);
                    currentSection = &((*this)[secName]);

                    // clear multiline value field name
                    // a new section means there is no value to continue
                    mutliLineValueFieldName = "";
                }
                else
                {
                    // line is a field definition
                    // check if section was already opened
                    if(currentSection == nullptr)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, field has no section";
                        throw std::logic_error(ss.str());
                    }

                    // find key value separator
                    std::size_t pos = line.find(fieldSep_);
                    if (multiLineValues_ && hasIndent && mutliLineValueFieldName != "")
                    {
                        // extend a multi-line value
                        IniField previous_value = (*currentSection)[mutliLineValueFieldName];
                        std::string value = previous_value.as<std::string>() + "\n" + line;
                        (*currentSection)[mutliLineValueFieldName] = value;
                    }
                    else if(pos == std::string::npos)
                    {
                        std::stringstream ss;
                        ss << "l." << lineNo
                           << ": ini parsing failed, no '"
                           << fieldSep_
                           << "' found";
                        if (multiLineValues_)
                            ss << ", and not a multi-line value continuation";
                        throw std::logic_error(ss.str());
                    }
                    else
                    {
                        // retrieve field name and value
                        std::string name = line.substr(0, pos);
                        trim(name);
                        std::string value = line.substr(pos + 1, std::string::npos);
                        trim(value);
                        (*currentSection)[name] = value;
                        // store last field name for potential multi-line values
                        mutliLineValueFieldName = name;
                    }
                }
            }
        }

        /** Tries to decode a ini file from the given input string.
          * @param content string to be decoded. */
        void decode(const std::string &content)
        {
            std::istringstream ss(content);
            decode(ss);
        }

        /** Tries to load and decode a ini file from the file at the given path.
          * @param fileName path to the file that should be loaded. */
        void load(const std::string &fileName)
        {
            std::ifstream is(fileName.c_str());
            decode(is);
        }

        /** Encodes this inifile object and writes the output to the given stream.
          * @param os target stream. */
        void encode(std::ostream &os) const
        {
            // iterate through all sections in this file
            for(const auto &filePair : *this)
            {
                os.put('[');
                writeEscaped(os, filePair.first);
                os.put(']');
                os.put('\n');

                // iterate through all fields in the section
                for(const auto &secPair : filePair.second)
                {
                    writeEscaped(os, secPair.first);
                    os.put(fieldSep_);
                    writeEscaped(os, secPair.second.template as<std::string>());
                    os.put('\n');
                }
            }
        }

        /** Encodes this inifile object as string and returns the result.
          * @return encoded infile string. */
        std::string encode() const
        {
            std::ostringstream ss;
            encode(ss);
            return ss.str();
        }

        /** Saves this inifile object to the file at the given path.
          * @param fileName path to the file where the data should be stored. */
        void save(const std::string &fileName) const
        {
            std::ofstream os(fileName.c_str());
            encode(os);
        }
    };

    using IniFile = IniFileBase<std::less<std::string>>;
    using IniSection = IniSectionBase<std::less<std::string>>;
    using IniFileCaseInsensitive = IniFileBase<StringInsensitiveLess>;
    using IniSectionCaseInsensitive = IniSectionBase<StringInsensitiveLess>;
}

#endif

```

`template_of_mod/mod/thirdparty/stb_sprintf.h`:

```h
// stb_sprintf - v1.10 - public domain snprintf() implementation
// originally by Jeff Roberts / RAD Game Tools, 2015/10/20
// http://github.com/nothings/stb
//
// allowed types:  sc uidBboXx p AaGgEef n
// lengths      :  hh h ll j z t I64 I32 I
//
// Contributors:
//    Fabian "ryg" Giesen (reformatting)
//    github:aganm (attribute format)
//
// Contributors (bugfixes):
//    github:d26435
//    github:trex78
//    github:account-login
//    Jari Komppa (SI suffixes)
//    Rohit Nirmal
//    Marcin Wojdyr
//    Leonard Ritter
//    Stefano Zanotti
//    Adam Allison
//    Arvid Gerstmann
//    Markus Kolb
//
// LICENSE:
//
//   See end of file for license information.

#ifndef STB_SPRINTF_H_INCLUDE
#define STB_SPRINTF_H_INCLUDE

/*
Single file sprintf replacement.

Originally written by Jeff Roberts at RAD Game Tools - 2015/10/20.
Hereby placed in public domain.

This is a full sprintf replacement that supports everything that
the C runtime sprintfs support, including float/double, 64-bit integers,
hex floats, field parameters (%*.*d stuff), length reads backs, etc.

Why would you need this if sprintf already exists?  Well, first off,
it's *much* faster (see below). It's also much smaller than the CRT
versions code-space-wise. We've also added some simple improvements
that are super handy (commas in thousands, callbacks at buffer full,
for example). Finally, the format strings for MSVC and GCC differ
for 64-bit integers (among other small things), so this lets you use
the same format strings in cross platform code.

It uses the standard single file trick of being both the header file
and the source itself. If you just include it normally, you just get
the header file function definitions. To get the code, you include
it from a C or C++ file and define STB_SPRINTF_IMPLEMENTATION first.

It only uses va_args macros from the C runtime to do it's work. It
does cast doubles to S64s and shifts and divides U64s, which does
drag in CRT code on most platforms.

It compiles to roughly 8K with float support, and 4K without.
As a comparison, when using MSVC static libs, calling sprintf drags
in 16K.

API:
====
int stbsp_sprintf( char * buf, char const * fmt, ... )
int stbsp_snprintf( char * buf, size_t count, char const * fmt, ... )
  Convert an arg list into a buffer.  stbsp_snprintf always returns
  a zero-terminated string (unlike regular snprintf).

int stbsp_vsprintf( char * buf, char const * fmt, va_list va )
int stbsp_vsnprintf( char * buf, size_t count, char const * fmt, va_list va )
  Convert a va_list arg list into a buffer.  stbsp_vsnprintf always returns
  a zero-terminated string (unlike regular snprintf).

int stbsp_vsprintfcb( STBSP_SPRINTFCB * callback, void * user, char * buf, char const * fmt, va_list va )
    typedef char * STBSP_SPRINTFCB( char const * buf, void * user, int len );
  Convert into a buffer, calling back every STB_SPRINTF_MIN chars.
  Your callback can then copy the chars out, print them or whatever.
  This function is actually the workhorse for everything else.
  The buffer you pass in must hold at least STB_SPRINTF_MIN characters.
    // you return the next buffer to use or 0 to stop converting

void stbsp_set_separators( char comma, char period )
  Set the comma and period characters to use.

FLOATS/DOUBLES:
===============
This code uses a internal float->ascii conversion method that uses
doubles with error correction (double-doubles, for ~105 bits of
precision).  This conversion is round-trip perfect - that is, an atof
of the values output here will give you the bit-exact double back.

One difference is that our insignificant digits will be different than
with MSVC or GCC (but they don't match each other either).  We also
don't attempt to find the minimum length matching float (pre-MSVC15
doesn't either).

If you don't need float or doubles at all, define STB_SPRINTF_NOFLOAT
and you'll save 4K of code space.

64-BIT INTS:
============
This library also supports 64-bit integers and you can use MSVC style or
GCC style indicators (%I64d or %lld).  It supports the C99 specifiers
for size_t and ptr_diff_t (%jd %zd) as well.

EXTRAS:
=======
Like some GCCs, for integers and floats, you can use a ' (single quote)
specifier and commas will be inserted on the thousands: "%'d" on 12345
would print 12,345.

For integers and floats, you can use a "$" specifier and the number
will be converted to float and then divided to get kilo, mega, giga or
tera and then printed, so "%$d" 1000 is "1.0 k", "%$.2d" 2536000 is
"2.53 M", etc. For byte values, use two $:s, like "%$$d" to turn
2536000 to "2.42 Mi". If you prefer JEDEC suffixes to SI ones, use three
$:s: "%$$$d" -> "2.42 M". To remove the space between the number and the
suffix, add "_" specifier: "%_$d" -> "2.53M".

In addition to octal and hexadecimal conversions, you can print
integers in binary: "%b" for 256 would print 100.

PERFORMANCE vs MSVC 2008 32-/64-bit (GCC is even slower than MSVC):
===================================================================
"%d" across all 32-bit ints (4.8x/4.0x faster than 32-/64-bit MSVC)
"%24d" across all 32-bit ints (4.5x/4.2x faster)
"%x" across all 32-bit ints (4.5x/3.8x faster)
"%08x" across all 32-bit ints (4.3x/3.8x faster)
"%f" across e-10 to e+10 floats (7.3x/6.0x faster)
"%e" across e-10 to e+10 floats (8.1x/6.0x faster)
"%g" across e-10 to e+10 floats (10.0x/7.1x faster)
"%f" for values near e-300 (7.9x/6.5x faster)
"%f" for values near e+300 (10.0x/9.1x faster)
"%e" for values near e-300 (10.1x/7.0x faster)
"%e" for values near e+300 (9.2x/6.0x faster)
"%.320f" for values near e-300 (12.6x/11.2x faster)
"%a" for random values (8.6x/4.3x faster)
"%I64d" for 64-bits with 32-bit values (4.8x/3.4x faster)
"%I64d" for 64-bits > 32-bit values (4.9x/5.5x faster)
"%s%s%s" for 64 char strings (7.1x/7.3x faster)
"...512 char string..." ( 35.0x/32.5x faster!)
*/

#if defined(__clang__)
 #if defined(__has_feature) && defined(__has_attribute)
  #if __has_feature(address_sanitizer)
   #if __has_attribute(__no_sanitize__)
    #define STBSP__ASAN __attribute__((__no_sanitize__("address")))
   #elif __has_attribute(__no_sanitize_address__)
    #define STBSP__ASAN __attribute__((__no_sanitize_address__))
   #elif __has_attribute(__no_address_safety_analysis__)
    #define STBSP__ASAN __attribute__((__no_address_safety_analysis__))
   #endif
  #endif
 #endif
#elif defined(__GNUC__) && (__GNUC__ >= 5 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8))
 #if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__
  #define STBSP__ASAN __attribute__((__no_sanitize_address__))
 #endif
#endif

#ifndef STBSP__ASAN
#define STBSP__ASAN
#endif

#ifdef STB_SPRINTF_STATIC
#define STBSP__PUBLICDEC static
#define STBSP__PUBLICDEF static STBSP__ASAN
#else
#ifdef __cplusplus
#define STBSP__PUBLICDEC extern "C"
#define STBSP__PUBLICDEF extern "C" STBSP__ASAN
#else
#define STBSP__PUBLICDEC extern
#define STBSP__PUBLICDEF STBSP__ASAN
#endif
#endif

#if defined(__has_attribute)
 #if __has_attribute(format)
   #define STBSP__ATTRIBUTE_FORMAT(fmt,va) __attribute__((format(printf,fmt,va)))
 #endif
#endif

#ifndef STBSP__ATTRIBUTE_FORMAT
#define STBSP__ATTRIBUTE_FORMAT(fmt,va)
#endif

#ifdef _MSC_VER
#define STBSP__NOTUSED(v)  (void)(v)
#else
#define STBSP__NOTUSED(v)  (void)sizeof(v)
#endif

#include <stdarg.h> // for va_arg(), va_list()
#include <stddef.h> // size_t, ptrdiff_t

#ifndef STB_SPRINTF_MIN
#define STB_SPRINTF_MIN 512 // how many characters per callback
#endif
typedef char *STBSP_SPRINTFCB(const char *buf, void *user, int len);

#ifndef STB_SPRINTF_DECORATE
#define STB_SPRINTF_DECORATE(name) stbsp_##name // define this before including if you want to change the names
#endif

STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsnprintf)(char *buf, size_t count, char const *fmt, va_list va);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(2,3);
STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(snprintf)(char *buf, size_t count, char const *fmt, ...) STBSP__ATTRIBUTE_FORMAT(3,4);

STBSP__PUBLICDEC int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va);
STBSP__PUBLICDEC void STB_SPRINTF_DECORATE(set_separators)(char comma, char period);

#endif // STB_SPRINTF_H_INCLUDE

#ifdef STB_SPRINTF_IMPLEMENTATION

#define stbsp__uint32 unsigned int
#define stbsp__int32 signed int

#ifdef _MSC_VER
#define stbsp__uint64 unsigned __int64
#define stbsp__int64 signed __int64
#else
#define stbsp__uint64 unsigned long long
#define stbsp__int64 signed long long
#endif
#define stbsp__uint16 unsigned short

#ifndef stbsp__uintptr
#if defined(__ppc64__) || defined(__powerpc64__) || defined(__aarch64__) || defined(_M_X64) || defined(__x86_64__) || defined(__x86_64) || defined(__s390x__)
#define stbsp__uintptr stbsp__uint64
#else
#define stbsp__uintptr stbsp__uint32
#endif
#endif

#ifndef STB_SPRINTF_MSVC_MODE // used for MSVC2013 and earlier (MSVC2015 matches GCC)
#if defined(_MSC_VER) && (_MSC_VER < 1900)
#define STB_SPRINTF_MSVC_MODE
#endif
#endif

#ifdef STB_SPRINTF_NOUNALIGNED // define this before inclusion to force stbsp_sprintf to always use aligned accesses
#define STBSP__UNALIGNED(code)
#else
#define STBSP__UNALIGNED(code) code
#endif

#ifndef STB_SPRINTF_NOFLOAT
// internal float utility functions
static stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits);
static stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value);
#define STBSP__SPECIAL 0x7000
#endif

static char stbsp__period = '.';
static char stbsp__comma = ',';
static struct
{
   short temp; // force next field to be 2-byte aligned
   char pair[201];
} stbsp__digitpair =
{
  0,
   "00010203040506070809101112131415161718192021222324"
   "25262728293031323334353637383940414243444546474849"
   "50515253545556575859606162636465666768697071727374"
   "75767778798081828384858687888990919293949596979899"
};

STBSP__PUBLICDEF void STB_SPRINTF_DECORATE(set_separators)(char pcomma, char pperiod)
{
   stbsp__period = pperiod;
   stbsp__comma = pcomma;
}

#define STBSP__LEFTJUST 1
#define STBSP__LEADINGPLUS 2
#define STBSP__LEADINGSPACE 4
#define STBSP__LEADING_0X 8
#define STBSP__LEADINGZERO 16
#define STBSP__INTMAX 32
#define STBSP__TRIPLET_COMMA 64
#define STBSP__NEGATIVE 128
#define STBSP__METRIC_SUFFIX 256
#define STBSP__HALFWIDTH 512
#define STBSP__METRIC_NOSPACE 1024
#define STBSP__METRIC_1024 2048
#define STBSP__METRIC_JEDEC 4096

static void stbsp__lead_sign(stbsp__uint32 fl, char *sign)
{
   sign[0] = 0;
   if (fl & STBSP__NEGATIVE) {
      sign[0] = 1;
      sign[1] = '-';
   } else if (fl & STBSP__LEADINGSPACE) {
      sign[0] = 1;
      sign[1] = ' ';
   } else if (fl & STBSP__LEADINGPLUS) {
      sign[0] = 1;
      sign[1] = '+';
   }
}

static STBSP__ASAN stbsp__uint32 stbsp__strlen_limited(char const *s, stbsp__uint32 limit)
{
   char const * sn = s;

   // get up to 4-byte alignment
   for (;;) {
      if (((stbsp__uintptr)sn & 3) == 0)
         break;

      if (!limit || *sn == 0)
         return (stbsp__uint32)(sn - s);

      ++sn;
      --limit;
   }

   // scan over 4 bytes at a time to find terminating 0
   // this will intentionally scan up to 3 bytes past the end of buffers,
   // but becase it works 4B aligned, it will never cross page boundaries
   // (hence the STBSP__ASAN markup; the over-read here is intentional
   // and harmless)
   while (limit >= 4) {
      stbsp__uint32 v = *(stbsp__uint32 *)sn;
      // bit hack to find if there's a 0 byte in there
      if ((v - 0x01010101) & (~v) & 0x80808080UL)
         break;

      sn += 4;
      limit -= 4;
   }

   // handle the last few characters to find actual size
   while (limit && *sn) {
      ++sn;
      --limit;
   }

   return (stbsp__uint32)(sn - s);
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintfcb)(STBSP_SPRINTFCB *callback, void *user, char *buf, char const *fmt, va_list va)
{
   static char hex[] = "0123456789abcdefxp";
   static char hexu[] = "0123456789ABCDEFXP";
   char *bf;
   char const *f;
   int tlen = 0;

   bf = buf;
   f = fmt;
   for (;;) {
      stbsp__int32 fw, pr, tz;
      stbsp__uint32 fl;

      // macros for the callback buffer stuff
      #define stbsp__chk_cb_bufL(bytes)                        \
         {                                                     \
            int len = (int)(bf - buf);                         \
            if ((len + (bytes)) >= STB_SPRINTF_MIN) {          \
               tlen += len;                                    \
               if (0 == (bf = buf = callback(buf, user, len))) \
                  goto done;                                   \
            }                                                  \
         }
      #define stbsp__chk_cb_buf(bytes)    \
         {                                \
            if (callback) {               \
               stbsp__chk_cb_bufL(bytes); \
            }                             \
         }
      #define stbsp__flush_cb()                      \
         {                                           \
            stbsp__chk_cb_bufL(STB_SPRINTF_MIN - 1); \
         } // flush if there is even one byte in the buffer
      #define stbsp__cb_buf_clamp(cl, v)                \
         cl = v;                                        \
         if (callback) {                                \
            int lg = STB_SPRINTF_MIN - (int)(bf - buf); \
            if (cl > lg)                                \
               cl = lg;                                 \
         }

      // fast copy everything up to the next % (or end of string)
      for (;;) {
         while (((stbsp__uintptr)f) & 3) {
         schk1:
            if (f[0] == '%')
               goto scandd;
         schk2:
            if (f[0] == 0)
               goto endfmt;
            stbsp__chk_cb_buf(1);
            *bf++ = f[0];
            ++f;
         }
         for (;;) {
            // Check if the next 4 bytes contain %(0x25) or end of string.
            // Using the 'hasless' trick:
            // https://graphics.stanford.edu/~seander/bithacks.html#HasLessInWord
            stbsp__uint32 v, c;
            v = *(stbsp__uint32 *)f;
            c = (~v) & 0x80808080;
            if (((v ^ 0x25252525) - 0x01010101) & c)
               goto schk1;
            if ((v - 0x01010101) & c)
               goto schk2;
            if (callback)
               if ((STB_SPRINTF_MIN - (int)(bf - buf)) < 4)
                  goto schk1;
            #ifdef STB_SPRINTF_NOUNALIGNED
                if(((stbsp__uintptr)bf) & 3) {
                    bf[0] = f[0];
                    bf[1] = f[1];
                    bf[2] = f[2];
                    bf[3] = f[3];
                } else
            #endif
            {
                *(stbsp__uint32 *)bf = v;
            }
            bf += 4;
            f += 4;
         }
      }
   scandd:

      ++f;

      // ok, we have a percent, read the modifiers first
      fw = 0;
      pr = -1;
      fl = 0;
      tz = 0;

      // flags
      for (;;) {
         switch (f[0]) {
         // if we have left justify
         case '-':
            fl |= STBSP__LEFTJUST;
            ++f;
            continue;
         // if we have leading plus
         case '+':
            fl |= STBSP__LEADINGPLUS;
            ++f;
            continue;
         // if we have leading space
         case ' ':
            fl |= STBSP__LEADINGSPACE;
            ++f;
            continue;
         // if we have leading 0x
         case '#':
            fl |= STBSP__LEADING_0X;
            ++f;
            continue;
         // if we have thousand commas
         case '\'':
            fl |= STBSP__TRIPLET_COMMA;
            ++f;
            continue;
         // if we have kilo marker (none->kilo->kibi->jedec)
         case '$':
            if (fl & STBSP__METRIC_SUFFIX) {
               if (fl & STBSP__METRIC_1024) {
                  fl |= STBSP__METRIC_JEDEC;
               } else {
                  fl |= STBSP__METRIC_1024;
               }
            } else {
               fl |= STBSP__METRIC_SUFFIX;
            }
            ++f;
            continue;
         // if we don't want space between metric suffix and number
         case '_':
            fl |= STBSP__METRIC_NOSPACE;
            ++f;
            continue;
         // if we have leading zero
         case '0':
            fl |= STBSP__LEADINGZERO;
            ++f;
            goto flags_done;
         default: goto flags_done;
         }
      }
   flags_done:

      // get the field width
      if (f[0] == '*') {
         fw = va_arg(va, stbsp__uint32);
         ++f;
      } else {
         while ((f[0] >= '0') && (f[0] <= '9')) {
            fw = fw * 10 + f[0] - '0';
            f++;
         }
      }
      // get the precision
      if (f[0] == '.') {
         ++f;
         if (f[0] == '*') {
            pr = va_arg(va, stbsp__uint32);
            ++f;
         } else {
            pr = 0;
            while ((f[0] >= '0') && (f[0] <= '9')) {
               pr = pr * 10 + f[0] - '0';
               f++;
            }
         }
      }

      // handle integer size overrides
      switch (f[0]) {
      // are we halfwidth?
      case 'h':
         fl |= STBSP__HALFWIDTH;
         ++f;
         if (f[0] == 'h')
            ++f;  // QUARTERWIDTH
         break;
      // are we 64-bit (unix style)
      case 'l':
         fl |= ((sizeof(long) == 8) ? STBSP__INTMAX : 0);
         ++f;
         if (f[0] == 'l') {
            fl |= STBSP__INTMAX;
            ++f;
         }
         break;
      // are we 64-bit on intmax? (c99)
      case 'j':
         fl |= (sizeof(size_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      // are we 64-bit on size_t or ptrdiff_t? (c99)
      case 'z':
         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      case 't':
         fl |= (sizeof(ptrdiff_t) == 8) ? STBSP__INTMAX : 0;
         ++f;
         break;
      // are we 64-bit (msft style)
      case 'I':
         if ((f[1] == '6') && (f[2] == '4')) {
            fl |= STBSP__INTMAX;
            f += 3;
         } else if ((f[1] == '3') && (f[2] == '2')) {
            f += 3;
         } else {
            fl |= ((sizeof(void *) == 8) ? STBSP__INTMAX : 0);
            ++f;
         }
         break;
      default: break;
      }

      // handle each replacement
      switch (f[0]) {
         #define STBSP__NUMSZ 512 // big enough for e308 (with commas) or e-307
         char num[STBSP__NUMSZ];
         char lead[8];
         char tail[8];
         char *s;
         char const *h;
         stbsp__uint32 l, n, cs;
         stbsp__uint64 n64;
#ifndef STB_SPRINTF_NOFLOAT
         double fv;
#endif
         stbsp__int32 dp;
         char const *sn;

      case 's':
         // get the string
         s = va_arg(va, char *);
         if (s == 0)
            s = (char *)"null";
         // get the length, limited to desired precision
         // always limit to ~0u chars since our counts are 32b
         l = stbsp__strlen_limited(s, (pr >= 0) ? pr : ~0u);
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         // copy the string in
         goto scopy;

      case 'c': // char
         // get the character
         s = num + STBSP__NUMSZ - 1;
         *s = (char)va_arg(va, int);
         l = 1;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         goto scopy;

      case 'n': // weird write-bytes specifier
      {
         int *d = va_arg(va, int *);
         *d = tlen + (int)(bf - buf);
      } break;

#ifdef STB_SPRINTF_NOFLOAT
      case 'A':              // float
      case 'a':              // hex float
      case 'G':              // float
      case 'g':              // float
      case 'E':              // float
      case 'e':              // float
      case 'f':              // float
         va_arg(va, double); // eat it
         s = (char *)"No float";
         l = 8;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         cs = 0;
         STBSP__NOTUSED(dp);
         goto scopy;
#else
      case 'A': // hex float
      case 'a': // hex float
         h = (f[0] == 'A') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_parts((stbsp__int64 *)&n64, &dp, fv))
            fl |= STBSP__NEGATIVE;

         s = num + 64;

         stbsp__lead_sign(fl, lead);

         if (dp == -1023)
            dp = (n64) ? -1022 : 0;
         else
            n64 |= (((stbsp__uint64)1) << 52);
         n64 <<= (64 - 56);
         if (pr < 15)
            n64 += ((((stbsp__uint64)8) << 56) >> (pr * 4));
// add leading chars

#ifdef STB_SPRINTF_MSVC_MODE
         *s++ = '0';
         *s++ = 'x';
#else
         lead[1 + lead[0]] = '0';
         lead[2 + lead[0]] = 'x';
         lead[0] += 2;
#endif
         *s++ = h[(n64 >> 60) & 15];
         n64 <<= 4;
         if (pr)
            *s++ = stbsp__period;
         sn = s;

         // print the bits
         n = pr;
         if (n > 13)
            n = 13;
         if (pr > (stbsp__int32)n)
            tz = pr - n;
         pr = 0;
         while (n--) {
            *s++ = h[(n64 >> 60) & 15];
            n64 <<= 4;
         }

         // print the expo
         tail[1] = h[17];
         if (dp < 0) {
            tail[2] = '-';
            dp = -dp;
         } else
            tail[2] = '+';
         n = (dp >= 1000) ? 6 : ((dp >= 100) ? 5 : ((dp >= 10) ? 4 : 3));
         tail[0] = (char)n;
         for (;;) {
            tail[n] = '0' + dp % 10;
            if (n <= 3)
               break;
            --n;
            dp /= 10;
         }

         dp = (int)(s - sn);
         l = (int)(s - (num + 64));
         s = num + 64;
         cs = 1 + (3 << 24);
         goto scopy;

      case 'G': // float
      case 'g': // float
         h = (f[0] == 'G') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6;
         else if (pr == 0)
            pr = 1; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, (pr - 1) | 0x80000000))
            fl |= STBSP__NEGATIVE;

         // clamp the precision and delete extra zeros after clamp
         n = pr;
         if (l > (stbsp__uint32)pr)
            l = pr;
         while ((l > 1) && (pr) && (sn[l - 1] == '0')) {
            --pr;
            --l;
         }

         // should we use %e
         if ((dp <= -4) || (dp > (stbsp__int32)n)) {
            if (pr > (stbsp__int32)l)
               pr = l - 1;
            else if (pr)
               --pr; // when using %e, there is one digit before the decimal
            goto doexpfromg;
         }
         // this is the insane action to get the pr to match %g semantics for %f
         if (dp > 0) {
            pr = (dp < (stbsp__int32)l) ? l - dp : 0;
         } else {
            pr = -dp + ((pr > (stbsp__int32)l) ? (stbsp__int32) l : pr);
         }
         goto dofloatfromg;

      case 'E': // float
      case 'e': // float
         h = (f[0] == 'E') ? hexu : hex;
         fv = va_arg(va, double);
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr | 0x80000000))
            fl |= STBSP__NEGATIVE;
      doexpfromg:
         tail[0] = 0;
         stbsp__lead_sign(fl, lead);
         if (dp == STBSP__SPECIAL) {
            s = (char *)sn;
            cs = 0;
            pr = 0;
            goto scopy;
         }
         s = num + 64;
         // handle leading chars
         *s++ = sn[0];

         if (pr)
            *s++ = stbsp__period;

         // handle after decimal
         if ((l - 1) > (stbsp__uint32)pr)
            l = pr + 1;
         for (n = 1; n < l; n++)
            *s++ = sn[n];
         // trailing zeros
         tz = pr - (l - 1);
         pr = 0;
         // dump expo
         tail[1] = h[0xe];
         dp -= 1;
         if (dp < 0) {
            tail[2] = '-';
            dp = -dp;
         } else
            tail[2] = '+';
#ifdef STB_SPRINTF_MSVC_MODE
         n = 5;
#else
         n = (dp >= 100) ? 5 : 4;
#endif
         tail[0] = (char)n;
         for (;;) {
            tail[n] = '0' + dp % 10;
            if (n <= 3)
               break;
            --n;
            dp /= 10;
         }
         cs = 1 + (3 << 24); // how many tens
         goto flt_lead;

      case 'f': // float
         fv = va_arg(va, double);
      doafloat:
         // do kilos
         if (fl & STBSP__METRIC_SUFFIX) {
            double divisor;
            divisor = 1000.0f;
            if (fl & STBSP__METRIC_1024)
               divisor = 1024.0;
            while (fl < 0x4000000) {
               if ((fv < divisor) && (fv > -divisor))
                  break;
               fv /= divisor;
               fl += 0x1000000;
            }
         }
         if (pr == -1)
            pr = 6; // default is 6
         // read the double into a string
         if (stbsp__real_to_str(&sn, &l, num, &dp, fv, pr))
            fl |= STBSP__NEGATIVE;
      dofloatfromg:
         tail[0] = 0;
         stbsp__lead_sign(fl, lead);
         if (dp == STBSP__SPECIAL) {
            s = (char *)sn;
            cs = 0;
            pr = 0;
            goto scopy;
         }
         s = num + 64;

         // handle the three decimal varieties
         if (dp <= 0) {
            stbsp__int32 i;
            // handle 0.000*000xxxx
            *s++ = '0';
            if (pr)
               *s++ = stbsp__period;
            n = -dp;
            if ((stbsp__int32)n > pr)
               n = pr;
            i = n;
            while (i) {
               if ((((stbsp__uintptr)s) & 3) == 0)
                  break;
               *s++ = '0';
               --i;
            }
            while (i >= 4) {
               *(stbsp__uint32 *)s = 0x30303030;
               s += 4;
               i -= 4;
            }
            while (i) {
               *s++ = '0';
               --i;
            }
            if ((stbsp__int32)(l + n) > pr)
               l = pr - n;
            i = l;
            while (i) {
               *s++ = *sn++;
               --i;
            }
            tz = pr - (n + l);
            cs = 1 + (3 << 24); // how many tens did we write (for commas below)
         } else {
            cs = (fl & STBSP__TRIPLET_COMMA) ? ((600 - (stbsp__uint32)dp) % 3) : 0;
            if ((stbsp__uint32)dp >= l) {
               // handle xxxx000*000.0
               n = 0;
               for (;;) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                     cs = 0;
                     *s++ = stbsp__comma;
                  } else {
                     *s++ = sn[n];
                     ++n;
                     if (n >= l)
                        break;
                  }
               }
               if (n < (stbsp__uint32)dp) {
                  n = dp - n;
                  if ((fl & STBSP__TRIPLET_COMMA) == 0) {
                     while (n) {
                        if ((((stbsp__uintptr)s) & 3) == 0)
                           break;
                        *s++ = '0';
                        --n;
                     }
                     while (n >= 4) {
                        *(stbsp__uint32 *)s = 0x30303030;
                        s += 4;
                        n -= 4;
                     }
                  }
                  while (n) {
                     if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                        cs = 0;
                        *s++ = stbsp__comma;
                     } else {
                        *s++ = '0';
                        --n;
                     }
                  }
               }
               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens
               if (pr) {
                  *s++ = stbsp__period;
                  tz = pr;
               }
            } else {
               // handle xxxxx.xxxx000*000
               n = 0;
               for (;;) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (++cs == 4)) {
                     cs = 0;
                     *s++ = stbsp__comma;
                  } else {
                     *s++ = sn[n];
                     ++n;
                     if (n >= (stbsp__uint32)dp)
                        break;
                  }
               }
               cs = (int)(s - (num + 64)) + (3 << 24); // cs is how many tens
               if (pr)
                  *s++ = stbsp__period;
               if ((l - dp) > (stbsp__uint32)pr)
                  l = pr + dp;
               while (n < l) {
                  *s++ = sn[n];
                  ++n;
               }
               tz = pr - (l - dp);
            }
         }
         pr = 0;

         // handle k,m,g,t
         if (fl & STBSP__METRIC_SUFFIX) {
            char idx;
            idx = 1;
            if (fl & STBSP__METRIC_NOSPACE)
               idx = 0;
            tail[0] = idx;
            tail[1] = ' ';
            {
               if (fl >> 24) { // SI kilo is 'k', JEDEC and SI kibits are 'K'.
                  if (fl & STBSP__METRIC_1024)
                     tail[idx + 1] = "_KMGT"[fl >> 24];
                  else
                     tail[idx + 1] = "_kMGT"[fl >> 24];
                  idx++;
                  // If printing kibits and not in jedec, add the 'i'.
                  if (fl & STBSP__METRIC_1024 && !(fl & STBSP__METRIC_JEDEC)) {
                     tail[idx + 1] = 'i';
                     idx++;
                  }
                  tail[0] = idx;
               }
            }
         };

      flt_lead:
         // get the length that we copied
         l = (stbsp__uint32)(s - (num + 64));
         s = num + 64;
         goto scopy;
#endif

      case 'B': // upper binary
      case 'b': // lower binary
         h = (f[0] == 'B') ? hexu : hex;
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 2;
            lead[1] = '0';
            lead[2] = h[0xb];
         }
         l = (8 << 4) | (1 << 8);
         goto radixnum;

      case 'o': // octal
         h = hexu;
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 1;
            lead[1] = '0';
         }
         l = (3 << 4) | (3 << 8);
         goto radixnum;

      case 'p': // pointer
         fl |= (sizeof(void *) == 8) ? STBSP__INTMAX : 0;
         pr = sizeof(void *) * 2;
         fl &= ~STBSP__LEADINGZERO; // 'p' only prints the pointer with zeros
                                    // fall through - to X

      case 'X': // upper hex
      case 'x': // lower hex
         h = (f[0] == 'X') ? hexu : hex;
         l = (4 << 4) | (4 << 8);
         lead[0] = 0;
         if (fl & STBSP__LEADING_0X) {
            lead[0] = 2;
            lead[1] = '0';
            lead[2] = h[16];
         }
      radixnum:
         // get the number
         if (fl & STBSP__INTMAX)
            n64 = va_arg(va, stbsp__uint64);
         else
            n64 = va_arg(va, stbsp__uint32);

         s = num + STBSP__NUMSZ;
         dp = 0;
         // clear tail, and clear leading if value is zero
         tail[0] = 0;
         if (n64 == 0) {
            lead[0] = 0;
            if (pr == 0) {
               l = 0;
               cs = 0;
               goto scopy;
            }
         }
         // convert to string
         for (;;) {
            *--s = h[n64 & ((1 << (l >> 8)) - 1)];
            n64 >>= (l >> 8);
            if (!((n64) || ((stbsp__int32)((num + STBSP__NUMSZ) - s) < pr)))
               break;
            if (fl & STBSP__TRIPLET_COMMA) {
               ++l;
               if ((l & 15) == ((l >> 4) & 15)) {
                  l &= ~15;
                  *--s = stbsp__comma;
               }
            }
         };
         // get the tens and the comma pos
         cs = (stbsp__uint32)((num + STBSP__NUMSZ) - s) + ((((l >> 4) & 15)) << 24);
         // get the length that we copied
         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);
         // copy it
         goto scopy;

      case 'u': // unsigned
      case 'i':
      case 'd': // integer
         // get the integer and abs it
         if (fl & STBSP__INTMAX) {
            stbsp__int64 i64 = va_arg(va, stbsp__int64);
            n64 = (stbsp__uint64)i64;
            if ((f[0] != 'u') && (i64 < 0)) {
               n64 = (stbsp__uint64)-i64;
               fl |= STBSP__NEGATIVE;
            }
         } else {
            stbsp__int32 i = va_arg(va, stbsp__int32);
            n64 = (stbsp__uint32)i;
            if ((f[0] != 'u') && (i < 0)) {
               n64 = (stbsp__uint32)-i;
               fl |= STBSP__NEGATIVE;
            }
         }

#ifndef STB_SPRINTF_NOFLOAT
         if (fl & STBSP__METRIC_SUFFIX) {
            if (n64 < 1024)
               pr = 0;
            else if (pr == -1)
               pr = 1;
            fv = (double)(stbsp__int64)n64;
            goto doafloat;
         }
#endif

         // convert to string
         s = num + STBSP__NUMSZ;
         l = 0;

         for (;;) {
            // do in 32-bit chunks (avoid lots of 64-bit divides even with constant denominators)
            char *o = s - 8;
            if (n64 >= 100000000) {
               n = (stbsp__uint32)(n64 % 100000000);
               n64 /= 100000000;
            } else {
               n = (stbsp__uint32)n64;
               n64 = 0;
            }
            if ((fl & STBSP__TRIPLET_COMMA) == 0) {
               do {
                  s -= 2;
                  *(stbsp__uint16 *)s = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];
                  n /= 100;
               } while (n);
            }
            while (n) {
               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {
                  l = 0;
                  *--s = stbsp__comma;
                  --o;
               } else {
                  *--s = (char)(n % 10) + '0';
                  n /= 10;
               }
            }
            if (n64 == 0) {
               if ((s[0] == '0') && (s != (num + STBSP__NUMSZ)))
                  ++s;
               break;
            }
            while (s != o)
               if ((fl & STBSP__TRIPLET_COMMA) && (l++ == 3)) {
                  l = 0;
                  *--s = stbsp__comma;
                  --o;
               } else {
                  *--s = '0';
               }
         }

         tail[0] = 0;
         stbsp__lead_sign(fl, lead);

         // get the length that we copied
         l = (stbsp__uint32)((num + STBSP__NUMSZ) - s);
         if (l == 0) {
            *--s = '0';
            l = 1;
         }
         cs = l + (3 << 24);
         if (pr < 0)
            pr = 0;

      scopy:
         // get fw=leading/trailing space, pr=leading zeros
         if (pr < (stbsp__int32)l)
            pr = l;
         n = pr + lead[0] + tail[0] + tz;
         if (fw < (stbsp__int32)n)
            fw = n;
         fw -= n;
         pr -= l;

         // handle right justify and leading zeros
         if ((fl & STBSP__LEFTJUST) == 0) {
            if (fl & STBSP__LEADINGZERO) // if leading zeros, everything is in pr
            {
               pr = (fw > pr) ? fw : pr;
               fw = 0;
            } else {
               fl &= ~STBSP__TRIPLET_COMMA; // if no leading zeros, then no commas
            }
         }

         // copy the spaces and/or zeros
         if (fw + pr) {
            stbsp__int32 i;
            stbsp__uint32 c;

            // copy leading spaces (or when doing %8.4d stuff)
            if ((fl & STBSP__LEFTJUST) == 0)
               while (fw > 0) {
                  stbsp__cb_buf_clamp(i, fw);
                  fw -= i;
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = ' ';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x20202020;
                     bf += 4;
                     i -= 4;
                  }
                  while (i) {
                     *bf++ = ' ';
                     --i;
                  }
                  stbsp__chk_cb_buf(1);
               }

            // copy leader
            sn = lead + 1;
            while (lead[0]) {
               stbsp__cb_buf_clamp(i, lead[0]);
               lead[0] -= (char)i;
               while (i) {
                  *bf++ = *sn++;
                  --i;
               }
               stbsp__chk_cb_buf(1);
            }

            // copy leading zeros
            c = cs >> 24;
            cs &= 0xffffff;
            cs = (fl & STBSP__TRIPLET_COMMA) ? ((stbsp__uint32)(c - ((pr + cs) % (c + 1)))) : 0;
            while (pr > 0) {
               stbsp__cb_buf_clamp(i, pr);
               pr -= i;
               if ((fl & STBSP__TRIPLET_COMMA) == 0) {
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = '0';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x30303030;
                     bf += 4;
                     i -= 4;
                  }
               }
               while (i) {
                  if ((fl & STBSP__TRIPLET_COMMA) && (cs++ == c)) {
                     cs = 0;
                     *bf++ = stbsp__comma;
                  } else
                     *bf++ = '0';
                  --i;
               }
               stbsp__chk_cb_buf(1);
            }
         }

         // copy leader if there is still one
         sn = lead + 1;
         while (lead[0]) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, lead[0]);
            lead[0] -= (char)i;
            while (i) {
               *bf++ = *sn++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy the string
         n = l;
         while (n) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, n);
            n -= i;
            STBSP__UNALIGNED(while (i >= 4) {
               *(stbsp__uint32 volatile *)bf = *(stbsp__uint32 volatile *)s;
               bf += 4;
               s += 4;
               i -= 4;
            })
            while (i) {
               *bf++ = *s++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy trailing zeros
         while (tz) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, tz);
            tz -= i;
            while (i) {
               if ((((stbsp__uintptr)bf) & 3) == 0)
                  break;
               *bf++ = '0';
               --i;
            }
            while (i >= 4) {
               *(stbsp__uint32 *)bf = 0x30303030;
               bf += 4;
               i -= 4;
            }
            while (i) {
               *bf++ = '0';
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // copy tail if there is one
         sn = tail + 1;
         while (tail[0]) {
            stbsp__int32 i;
            stbsp__cb_buf_clamp(i, tail[0]);
            tail[0] -= (char)i;
            while (i) {
               *bf++ = *sn++;
               --i;
            }
            stbsp__chk_cb_buf(1);
         }

         // handle the left justify
         if (fl & STBSP__LEFTJUST)
            if (fw > 0) {
               while (fw) {
                  stbsp__int32 i;
                  stbsp__cb_buf_clamp(i, fw);
                  fw -= i;
                  while (i) {
                     if ((((stbsp__uintptr)bf) & 3) == 0)
                        break;
                     *bf++ = ' ';
                     --i;
                  }
                  while (i >= 4) {
                     *(stbsp__uint32 *)bf = 0x20202020;
                     bf += 4;
                     i -= 4;
                  }
                  while (i--)
                     *bf++ = ' ';
                  stbsp__chk_cb_buf(1);
               }
            }
         break;

      default: // unknown, just copy code
         s = num + STBSP__NUMSZ - 1;
         *s = f[0];
         l = 1;
         fw = fl = 0;
         lead[0] = 0;
         tail[0] = 0;
         pr = 0;
         dp = 0;
         cs = 0;
         goto scopy;
      }
      ++f;
   }
endfmt:

   if (!callback)
      *bf = 0;
   else
      stbsp__flush_cb();

done:
   return tlen + (int)(bf - buf);
}

// cleanup
#undef STBSP__LEFTJUST
#undef STBSP__LEADINGPLUS
#undef STBSP__LEADINGSPACE
#undef STBSP__LEADING_0X
#undef STBSP__LEADINGZERO
#undef STBSP__INTMAX
#undef STBSP__TRIPLET_COMMA
#undef STBSP__NEGATIVE
#undef STBSP__METRIC_SUFFIX
#undef STBSP__NUMSZ
#undef stbsp__chk_cb_bufL
#undef stbsp__chk_cb_buf
#undef stbsp__flush_cb
#undef stbsp__cb_buf_clamp

// ============================================================================
//   wrapper functions

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(sprintf)(char *buf, char const *fmt, ...)
{
   int result;
   va_list va;
   va_start(va, fmt);
   result = STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);
   va_end(va);
   return result;
}

typedef struct stbsp__context {
   char *buf;
   int count;
   int length;
   char tmp[STB_SPRINTF_MIN];
} stbsp__context;

static char *stbsp__clamp_callback(const char *buf, void *user, int len)
{
   stbsp__context *c = (stbsp__context *)user;
   c->length += len;

   if (len > c->count)
      len = c->count;

   if (len) {
      if (buf != c->buf) {
         const char *s, *se;
         char *d;
         d = c->buf;
         s = buf;
         se = buf + len;
         do {
            *d++ = *s++;
         } while (s < se);
      }
      c->buf += len;
      c->count -= len;
   }

   if (c->count <= 0)
      return c->tmp;
   return (c->count >= STB_SPRINTF_MIN) ? c->buf : c->tmp; // go direct into buffer if you can
}

static char * stbsp__count_clamp_callback( const char * buf, void * user, int len )
{
   stbsp__context * c = (stbsp__context*)user;
   (void) sizeof(buf);

   c->length += len;
   return c->tmp; // go direct into buffer if you can
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE( vsnprintf )( char * buf, size_t count, char const * fmt, va_list va )
{
   stbsp__context c;

   if ( (count == 0) && !buf )
   {
      c.length = 0;

      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__count_clamp_callback, &c, c.tmp, fmt, va );
   }
   else
   {
      int l;

      c.buf = buf;
      c.count = count;
      c.length = 0;

      STB_SPRINTF_DECORATE( vsprintfcb )( stbsp__clamp_callback, &c, stbsp__clamp_callback(0,&c,0), fmt, va );

      // zero-terminate
      l = (int)( c.buf - buf );
      if ( l >= count ) // should never be greater, only equal (or less) than count
         l = count - 1;
      buf[l] = 0;
   }

   return c.length;
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(snprintf)(char *buf, size_t count, char const *fmt, ...)
{
   int result;
   va_list va;
   va_start(va, fmt);

   result = STB_SPRINTF_DECORATE(vsnprintf)(buf, count, fmt, va);
   va_end(va);

   return result;
}

STBSP__PUBLICDEF int STB_SPRINTF_DECORATE(vsprintf)(char *buf, char const *fmt, va_list va)
{
   return STB_SPRINTF_DECORATE(vsprintfcb)(0, 0, buf, fmt, va);
}

// =======================================================================
//   low level float utility functions

#ifndef STB_SPRINTF_NOFLOAT

// copies d to bits w/ strict aliasing (this compiles to nothing on /Ox)
#define STBSP__COPYFP(dest, src)                   \
   {                                               \
      int cn;                                      \
      for (cn = 0; cn < 8; cn++)                   \
         ((char *)&dest)[cn] = ((char *)&src)[cn]; \
   }

// get float info
static stbsp__int32 stbsp__real_to_parts(stbsp__int64 *bits, stbsp__int32 *expo, double value)
{
   double d;
   stbsp__int64 b = 0;

   // load value and round at the frac_digits
   d = value;

   STBSP__COPYFP(b, d);

   *bits = b & ((((stbsp__uint64)1) << 52) - 1);
   *expo = (stbsp__int32)(((b >> 52) & 2047) - 1023);

   return (stbsp__int32)((stbsp__uint64) b >> 63);
}

static double const stbsp__bot[23] = {
   1e+000, 1e+001, 1e+002, 1e+003, 1e+004, 1e+005, 1e+006, 1e+007, 1e+008, 1e+009, 1e+010, 1e+011,
   1e+012, 1e+013, 1e+014, 1e+015, 1e+016, 1e+017, 1e+018, 1e+019, 1e+020, 1e+021, 1e+022
};
static double const stbsp__negbot[22] = {
   1e-001, 1e-002, 1e-003, 1e-004, 1e-005, 1e-006, 1e-007, 1e-008, 1e-009, 1e-010, 1e-011,
   1e-012, 1e-013, 1e-014, 1e-015, 1e-016, 1e-017, 1e-018, 1e-019, 1e-020, 1e-021, 1e-022
};
static double const stbsp__negboterr[22] = {
   -5.551115123125783e-018,  -2.0816681711721684e-019, -2.0816681711721686e-020, -4.7921736023859299e-021, -8.1803053914031305e-022, 4.5251888174113741e-023,
   4.5251888174113739e-024,  -2.0922560830128471e-025, -6.2281591457779853e-026, -3.6432197315497743e-027, 6.0503030718060191e-028,  2.0113352370744385e-029,
   -3.0373745563400371e-030, 1.1806906454401013e-032,  -7.7705399876661076e-032, 2.0902213275965398e-033,  -7.1542424054621921e-034, -7.1542424054621926e-035,
   2.4754073164739869e-036,  5.4846728545790429e-037,  9.2462547772103625e-038,  -4.8596774326570872e-039
};
static double const stbsp__top[13] = {
   1e+023, 1e+046, 1e+069, 1e+092, 1e+115, 1e+138, 1e+161, 1e+184, 1e+207, 1e+230, 1e+253, 1e+276, 1e+299
};
static double const stbsp__negtop[13] = {
   1e-023, 1e-046, 1e-069, 1e-092, 1e-115, 1e-138, 1e-161, 1e-184, 1e-207, 1e-230, 1e-253, 1e-276, 1e-299
};
static double const stbsp__toperr[13] = {
   8388608,
   6.8601809640529717e+028,
   -7.253143638152921e+052,
   -4.3377296974619174e+075,
   -1.5559416129466825e+098,
   -3.2841562489204913e+121,
   -3.7745893248228135e+144,
   -1.7356668416969134e+167,
   -3.8893577551088374e+190,
   -9.9566444326005119e+213,
   6.3641293062232429e+236,
   -5.2069140800249813e+259,
   -5.2504760255204387e+282
};
static double const stbsp__negtoperr[13] = {
   3.9565301985100693e-040,  -2.299904345391321e-063,  3.6506201437945798e-086,  1.1875228833981544e-109,
   -5.0644902316928607e-132, -6.7156837247865426e-155, -2.812077463003139e-178,  -5.7778912386589953e-201,
   7.4997100559334532e-224,  -4.6439668915134491e-247, -6.3691100762962136e-270, -9.436808465446358e-293,
   8.0970921678014997e-317
};

#if defined(_MSC_VER) && (_MSC_VER <= 1200)
static stbsp__uint64 const stbsp__powten[20] = {
   1,
   10,
   100,
   1000,
   10000,
   100000,
   1000000,
   10000000,
   100000000,
   1000000000,
   10000000000,
   100000000000,
   1000000000000,
   10000000000000,
   100000000000000,
   1000000000000000,
   10000000000000000,
   100000000000000000,
   1000000000000000000,
   10000000000000000000U
};
#define stbsp__tento19th ((stbsp__uint64)1000000000000000000)
#else
static stbsp__uint64 const stbsp__powten[20] = {
   1,
   10,
   100,
   1000,
   10000,
   100000,
   1000000,
   10000000,
   100000000,
   1000000000,
   10000000000ULL,
   100000000000ULL,
   1000000000000ULL,
   10000000000000ULL,
   100000000000000ULL,
   1000000000000000ULL,
   10000000000000000ULL,
   100000000000000000ULL,
   1000000000000000000ULL,
   10000000000000000000ULL
};
#define stbsp__tento19th (1000000000000000000ULL)
#endif

#define stbsp__ddmulthi(oh, ol, xh, yh)                            \
   {                                                               \
      double ahi = 0, alo, bhi = 0, blo;                           \
      stbsp__int64 bt;                                             \
      oh = xh * yh;                                                \
      STBSP__COPYFP(bt, xh);                                       \
      bt &= ((~(stbsp__uint64)0) << 27);                           \
      STBSP__COPYFP(ahi, bt);                                      \
      alo = xh - ahi;                                              \
      STBSP__COPYFP(bt, yh);                                       \
      bt &= ((~(stbsp__uint64)0) << 27);                           \
      STBSP__COPYFP(bhi, bt);                                      \
      blo = yh - bhi;                                              \
      ol = ((ahi * bhi - oh) + ahi * blo + alo * bhi) + alo * blo; \
   }

#define stbsp__ddtoS64(ob, xh, xl)          \
   {                                        \
      double ahi = 0, alo, vh, t;           \
      ob = (stbsp__int64)xh;                \
      vh = (double)ob;                      \
      ahi = (xh - vh);                      \
      t = (ahi - xh);                       \
      alo = (xh - (ahi - t)) - (vh + t);    \
      ob += (stbsp__int64)(ahi + alo + xl); \
   }

#define stbsp__ddrenorm(oh, ol) \
   {                            \
      double s;                 \
      s = oh + ol;              \
      ol = ol - (s - oh);       \
      oh = s;                   \
   }

#define stbsp__ddmultlo(oh, ol, xh, xl, yh, yl) ol = ol + (xh * yl + xl * yh);

#define stbsp__ddmultlos(oh, ol, xh, yl) ol = ol + (xh * yl);

static void stbsp__raise_to_power10(double *ohi, double *olo, double d, stbsp__int32 power) // power can be -323 to +350
{
   double ph, pl;
   if ((power >= 0) && (power <= 22)) {
      stbsp__ddmulthi(ph, pl, d, stbsp__bot[power]);
   } else {
      stbsp__int32 e, et, eb;
      double p2h, p2l;

      e = power;
      if (power < 0)
         e = -e;
      et = (e * 0x2c9) >> 14; /* %23 */
      if (et > 13)
         et = 13;
      eb = e - (et * 23);

      ph = d;
      pl = 0.0;
      if (power < 0) {
         if (eb) {
            --eb;
            stbsp__ddmulthi(ph, pl, d, stbsp__negbot[eb]);
            stbsp__ddmultlos(ph, pl, d, stbsp__negboterr[eb]);
         }
         if (et) {
            stbsp__ddrenorm(ph, pl);
            --et;
            stbsp__ddmulthi(p2h, p2l, ph, stbsp__negtop[et]);
            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__negtop[et], stbsp__negtoperr[et]);
            ph = p2h;
            pl = p2l;
         }
      } else {
         if (eb) {
            e = eb;
            if (eb > 22)
               eb = 22;
            e -= eb;
            stbsp__ddmulthi(ph, pl, d, stbsp__bot[eb]);
            if (e) {
               stbsp__ddrenorm(ph, pl);
               stbsp__ddmulthi(p2h, p2l, ph, stbsp__bot[e]);
               stbsp__ddmultlos(p2h, p2l, stbsp__bot[e], pl);
               ph = p2h;
               pl = p2l;
            }
         }
         if (et) {
            stbsp__ddrenorm(ph, pl);
            --et;
            stbsp__ddmulthi(p2h, p2l, ph, stbsp__top[et]);
            stbsp__ddmultlo(p2h, p2l, ph, pl, stbsp__top[et], stbsp__toperr[et]);
            ph = p2h;
            pl = p2l;
         }
      }
   }
   stbsp__ddrenorm(ph, pl);
   *ohi = ph;
   *olo = pl;
}

// given a float value, returns the significant bits in bits, and the position of the
//   decimal point in decimal_pos.  +/-INF and NAN are specified by special values
//   returned in the decimal_pos parameter.
// frac_digits is absolute normally, but if you want from first significant digits (got %g and %e), or in 0x80000000
static stbsp__int32 stbsp__real_to_str(char const **start, stbsp__uint32 *len, char *out, stbsp__int32 *decimal_pos, double value, stbsp__uint32 frac_digits)
{
   double d;
   stbsp__int64 bits = 0;
   stbsp__int32 expo, e, ng, tens;

   d = value;
   STBSP__COPYFP(bits, d);
   expo = (stbsp__int32)((bits >> 52) & 2047);
   ng = (stbsp__int32)((stbsp__uint64) bits >> 63);
   if (ng)
      d = -d;

   if (expo == 2047) // is nan or inf?
   {
      *start = (bits & ((((stbsp__uint64)1) << 52) - 1)) ? "NaN" : "Inf";
      *decimal_pos = STBSP__SPECIAL;
      *len = 3;
      return ng;
   }

   if (expo == 0) // is zero or denormal
   {
      if (((stbsp__uint64) bits << 1) == 0) // do zero
      {
         *decimal_pos = 1;
         *start = out;
         out[0] = '0';
         *len = 1;
         return ng;
      }
      // find the right expo for denormals
      {
         stbsp__int64 v = ((stbsp__uint64)1) << 51;
         while ((bits & v) == 0) {
            --expo;
            v >>= 1;
         }
      }
   }

   // find the decimal exponent as well as the decimal bits of the value
   {
      double ph, pl;

      // log10 estimate - very specifically tweaked to hit or undershoot by no more than 1 of log10 of all expos 1..2046
      tens = expo - 1023;
      tens = (tens < 0) ? ((tens * 617) / 2048) : (((tens * 1233) / 4096) + 1);

      // move the significant bits into position and stick them into an int
      stbsp__raise_to_power10(&ph, &pl, d, 18 - tens);

      // get full as much precision from double-double as possible
      stbsp__ddtoS64(bits, ph, pl);

      // check if we undershot
      if (((stbsp__uint64)bits) >= stbsp__tento19th)
         ++tens;
   }

   // now do the rounding in integer land
   frac_digits = (frac_digits & 0x80000000) ? ((frac_digits & 0x7ffffff) + 1) : (tens + frac_digits);
   if ((frac_digits < 24)) {
      stbsp__uint32 dg = 1;
      if ((stbsp__uint64)bits >= stbsp__powten[9])
         dg = 10;
      while ((stbsp__uint64)bits >= stbsp__powten[dg]) {
         ++dg;
         if (dg == 20)
            goto noround;
      }
      if (frac_digits < dg) {
         stbsp__uint64 r;
         // add 0.5 at the right position and round
         e = dg - frac_digits;
         if ((stbsp__uint32)e >= 24)
            goto noround;
         r = stbsp__powten[e];
         bits = bits + (r / 2);
         if ((stbsp__uint64)bits >= stbsp__powten[dg])
            ++tens;
         bits /= r;
      }
   noround:;
   }

   // kill long trailing runs of zeros
   if (bits) {
      stbsp__uint32 n;
      for (;;) {
         if (bits <= 0xffffffff)
            break;
         if (bits % 1000)
            goto donez;
         bits /= 1000;
      }
      n = (stbsp__uint32)bits;
      while ((n % 1000) == 0)
         n /= 1000;
      bits = n;
   donez:;
   }

   // convert to string
   out += 64;
   e = 0;
   for (;;) {
      stbsp__uint32 n;
      char *o = out - 8;
      // do the conversion in chunks of U32s (avoid most 64-bit divides, worth it, constant denomiators be damned)
      if (bits >= 100000000) {
         n = (stbsp__uint32)(bits % 100000000);
         bits /= 100000000;
      } else {
         n = (stbsp__uint32)bits;
         bits = 0;
      }
      while (n) {
         out -= 2;
         *(stbsp__uint16 *)out = *(stbsp__uint16 *)&stbsp__digitpair.pair[(n % 100) * 2];
         n /= 100;
         e += 2;
      }
      if (bits == 0) {
         if ((e) && (out[0] == '0')) {
            ++out;
            --e;
         }
         break;
      }
      while (out != o) {
         *--out = '0';
         ++e;
      }
   }

   *decimal_pos = tens;
   *start = out;
   *len = e;
   return ng;
}

#undef stbsp__ddmulthi
#undef stbsp__ddrenorm
#undef stbsp__ddmultlo
#undef stbsp__ddmultlos
#undef STBSP__SPECIAL
#undef STBSP__COPYFP

#endif // STB_SPRINTF_NOFLOAT

// clean up
#undef stbsp__uint16
#undef stbsp__uint32
#undef stbsp__int32
#undef stbsp__uint64
#undef stbsp__int64
#undef STBSP__UNALIGNED

#endif // STB_SPRINTF_IMPLEMENTATION

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
```

`vtable_hooker.cpp`:

```cpp
#include "vtable_hooker.h"
#include <string.h> // memcpy
#include <unistd.h>
#include <sys/mman.h>
#include <mod/icfg.h>
#include <aml.h>

void* vtablez[MAX_VTABLE_FUNCS] = {NULL};
int vtablez_offset = 0;

// This function is not gonna work correctly if vtable has "holes" (incomplete/abstract virtual class)
void HookVtableFunc(void* ptr, unsigned int funcNum, void* func, void** original, bool instantiate)
{
    if(!ptr || !func || funcNum < 0) return;
    if(ptr == aml || ptr == icfg) return; // you aint doin thiz dirty boy
    void** vtableArray = *(void***)ptr;
    
    int count = 0;
    while(vtableArray[count] != NULL) ++count;
    if(funcNum > count) return;
    
    if(instantiate)
    {
        memcpy(&vtablez[vtablez_offset], vtableArray, count * sizeof(void*));
        *(void***)ptr = &vtablez[vtablez_offset];
        vtableArray = *(void***)ptr;
        vtablez_offset += count;
    }
    else
    {
        g_pAML->Unprot((uintptr_t)&vtableArray[funcNum], sizeof(void*));
    }
    
    if(original != NULL) *original = vtableArray[funcNum];
    vtableArray[funcNum] = func;
}

// Better func but you need to know how much funcs it has
void HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* func, void** original, bool instantiate)
{
    if(!ptr || !func || funcNum < 0) return;
    if(ptr == aml || ptr == icfg) return; // you aint doin thiz dirty boy
    void** vtableArray = *(void***)ptr;
    
    if(funcNum > count) return;
    
    if(instantiate)
    {
        memcpy(&vtablez[vtablez_offset], vtableArray, count * sizeof(void*));
        *(void***)ptr = &vtablez[vtablez_offset];
        vtableArray = *(void***)ptr;
        vtablez_offset += count;
    }
    else
    {
        g_pAML->Unprot((uintptr_t)&vtableArray[funcNum], sizeof(void*));
    }
    
    if(original != NULL) *original = vtableArray[funcNum];
    vtableArray[funcNum] = func;
}
```

`vtable_hooker.h`:

```h
#define MAX_VTABLE_FUNCS 8192 // This is not a count of max instantiated!

void HookVtableFunc(void* ptr, unsigned int funcNum, void* fnAddress, void** orgFnAddress = (void**)0, bool instantiate = false);
void HookVtableFunc(void* ptr, unsigned int funcNum, unsigned int count, void* func, void** orgFnAddress = (void**)0, bool instantiate = false);
```